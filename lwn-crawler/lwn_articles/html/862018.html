        <!DOCTYPE html>
        <html lang="en">
        <head><title>Rust for Linux redux [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/862018/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/861536/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/862018/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Rust for Linux redux</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>July 7, 2021</br>
           </div>
<p>
On July 4, the <a href="https://github.com/Rust-for-Linux">Rust for Linux</a> project
<a
href="/ml/linux-kernel/20210704202756.29107-1-ojeda@kernel.org/">posted</a>
another version of its patch set adding support for the language to the
kernel.  It would seem that the project feels that it is ready to be considered for
merging into the mainline.  Perhaps a bigger question lingers, though: is the kernel
development community ready for Rust?  That part still seems to be up in the air.
</p>

<h4>Round 2</h4>

<p>
Miguel Ojeda, who has been hired to <a href="/Articles/860160/">work on
the project full-time</a>, posted the patch set; in the cover letter, he listed a
number of changes and updates since the <a
href="/ml/linux-kernel/20210414184604.23473-1-ojeda@kernel.org/">RFC patch
set</a> was <a href="/Articles/853423/">posted back in April</a>.  In
particular, the allocations that would call <tt>panic!()</tt> when they
failed have been
replaced.  A modified version of the <a
href="https://doc.rust-lang.org/alloc/"><tt>alloc</tt> crate</a> has been
<a href="https://rust-for-linux.github.io/docs/alloc/">created for the
kernel project</a>, though the plan is for the changes to work their way
into the upstream project so that the customized version can eventually be dropped.
Incidentally, the patch adding the modified crate was <a
href="/ml/linux-kernel/CANiq72nQq8Y8v9Pyf7JFq6Kf-+doNP+mHAFNzj_cSFBa3KwS5w@mail.gmail.com/">apparently
too large for the lore archive</a>, though it does <a
href="/ml/linux-kernel/20210704202756.29107-8-ojeda@kernel.org/">show
up</a> in the LWN archive.
</p>

<p>
There is more progress on Rust abstractions for kernel facilities,
including "<q>red-black trees, reference-counted objects, file
descriptor creation, tasks, files, io vectors...</q>", he said, as well
as additions for driver support.  Beyond that, the
Rust driver for the <a
href="https://elinux.org/Android_Binder">Android Binder</a> interprocess
communication mechanism has more features and there is ongoing work on a driver for
the hardware random-number generator available on some Raspberry Pi models.
</p>

<p>
But the lack of a "real" driver was one of the sticking points back in
April, and it was raised again this time.  Christoph Hellwig <a
href="/ml/linux-kernel/YOVNJuA0ojmeLvKa@infradead.org/">said</a> that he was
strongly against merging the code if that was the intent of the posting.
In the cover letter, Ojeda said that the patch set was being added to linux-next, and
he <a
href="/ml/linux-kernel/CANiq72mKPFtB4CtHcc94a_y1V4bEOXXN2CwttQFvyzwXJv62kw@mail.gmail.com/">confirmed</a>
that it is being submitted for merging.  Hellwig wants to see Rust prove
itself before being included:
<blockquote class="bq">
[...] prove it actually is useful first.  Where
useful would be a real-life driver like say nvme or a usb host
controller driver that actually works and shows benefits over the
existing one.  Until it shows such usefulness it will just drag
everyone else down.
</blockquote>
</p>

<p>
Ojeda pointed at the Binder driver as a "<q>non-trivial module</q>"
that "<q>is already working</q>", but acknowledged that a real
hardware driver is an important (and, as yet, missing) piece.  But the cover
letter listed a number of organizations that are interested in or involved with
the project already, and Ojeda believes that is also something that is
helping to prove the 
project:
<blockquote class="bq">
It is "proven" in the sense we are already starting to get users
downstream and other interested parties have shown support.
<p>
However, others are more conservative and will only start investing
into it if we are in mainline, i.e. if the decision of having Rust or
not is already taken.
</blockquote>
</p>

<p>
But the Binder "driver" is not really a good example to use for a few different
reasons, Greg Kroah-Hartman <a
href="/ml/linux-kernel/YOXB7FRqldZik2Xn@kroah.com/">said</a>.  It is
missing a fairly large piece of functionality (binderfs) for one thing, but it also does
little to help show how Rust will fit in with the rest of the kernel.  As
before, he strongly recommended working on something that would help clear
up some of the questions that kernel developers have about Rust:
<blockquote class="bq">
Not to say that it doesn't have its usages, but the interactions between
binder and the rest of the kernel are very small and specific.
Something that almost no one else will ever write again.
<p>
Please work on a real driver to help prove, or disprove, that this all
is going to be able to work properly.  There are huge unanswered
questions that need to be resolved that you will run into when you do
such a thing.
</blockquote>
</p>

<h4>Kernel Summit topic</h4>

<p>
The theme of Rust proving itself was also present in a thread on the ksummit-discuss mailing
list.  At the end of June, Ojeda <a
href="/ml/ksummit-discuss/CANiq72kF7AbiJCTHca4A0CxDDJU90j89uh80S3pDqDt7-jthOg@mail.gmail.com/">proposed</a>
Rust for Linux as a technical topic for the Kernel Summit track at this
year's <a href="https://linuxplumbersconf.org/">Linux Plumbers
Conference</a>.  On July&nbsp;6,  Linus Walleij <a
href="/ml/ksummit-discuss/CACRpkdbbPEnNTLYSP-YP+hTnqhUGQ8FjJLNY_fpSNWWd8tCFTQ@mail.gmail.com/">replied</a>, 
agreeing that it was a topic that should be discussed.  He noted that there
are already quite a few languages that kernel developers need to be
up on (e.g. C, assembly, Make, Bash, Perl, Python, ...), so a question in
his mind is what Rust will bring to the table that makes it worth adding to
the list. 
</p>

<p>
That message started the ball rolling on a discussion of how Rust fits—and
where the experiment leads. There is clearly some concern among kernel
developers about having to know Rust to continue working on the kernel.
Ojeda tried to allay those fears to a certain extent, but did acknowledge
that most kernel developers would eventually need to understand the
language.  For now, the intent is for the project to work with
maintainers that want to add a Rust API to their subsystem, Ojeda <a
href="/ml/ksummit-discuss/CANiq72mPMa9CwprrkL7QsEChQPMNtC61kJgaM4Rx0EyuQmvs2g@mail.gmail.com/">said</a>.
That will bootstrap support for Rust within the kernel and will help alleviate some of
the concerns expressed by <a
href="/ml/ksummit-discuss/YOPcZE+WjlwNueTa@unreal/"> Leon Romanovsky</a>,
<a
href="/ml/ksummit-discuss/19e0f737a3e58ed32758fb4758393c197437e8de.camel@HansenPartnership.com/">James
Bottomley</a>, and others.
</p>

<p>
Romanovsky was worried about refactoring, especially cross-subsystem
refactoring, in a system with drivers in both languages.  Bottomley
suggested that there would be fewer reviewers for the Rust code, so bugs
could more easily slip in:
<blockquote class="bq">
Since most of our CVE type problems are usually
programming mistakes nowadays, the lack of review could contribute to
an increase in programming fault type bugs which aren't forbidden by
the safer memory model. 
</blockquote>
</p>

<p>
In the near term, those are problems that will need to be dealt with, but
the goal is to get to a point where Rust knowledge is more widespread among
kernel developers.  As Ojeda <a
href="/ml/ksummit-discuss/CANiq72=vjXYN-A1gZysXzKvR+NgmxpSGOiOGro0S6tMhYAwR6Q@mail.gmail.com/">put
it</a>:
<blockquote class="bq">
After all, if we are going to have Rust as a second language in the
kernel, we should try to have as many people on board as possible, at
least to some degree, within some reasonable time frame.
</blockquote>
</p>

<p>
As Laurent Pinchart <a
href="/ml/ksummit-discuss/YOSjETKWhuRz0Poq@pendragon.ideasonboard.com/">pointed
out</a>, that is an important point and one that needs to be more clearly
highlighted in the discussion:
<blockquote class="bq">
[...]  adopting Rust as
a second language in the kernel isn't just a technical decision with
limited impact, but also a process decision that will create a
requirement for most kernel developers to learn Rust. Whether that
should and will happen is what we're debating, but regardless of the
outcome, it's important to phrase the question correctly, with a broad
view of the implications.
</blockquote>
</p>

<p>
There are, of course, plenty of technical hurdles that need to be cleared
as well.  One of those areas is the Linux driver model and the
object-lifetime handling that goes along with it.  Roland Dreier <a
href="/ml/ksummit-discuss/CAG4TOxMzf1Wn6PcWk=XfB+SV+MHwbxUq8t1RNswie5e3=Y+OXQ@mail.gmail.com/">suggested</a>
that interfaces like <a
href="https://www.kernel.org/doc/html/latest/driver-api/driver-model/devres.html">devres</a>
(i.e. managed device resources) could have avoided a lot of problems that
he has seen in drivers regarding lifetime management, and error paths in particular, but
that it has not been adopted widely.  Walleij <a
href="/ml/ksummit-discuss/CACRpkdZyJd0TW5aVRfxSSWknzCyVhjMwQuAj9i9iuQ6pW9vftQ@mail.gmail.com/">disagreed</a>
that it hasn't been widely used, but is not at all sure that a Rust switch is better:
<blockquote class="bq">
I think it's a formidable success, people just need to learn to do it more.
<p>
But if an easier path to learn better behaviours is to shuffle the whole
chessboard and replace it with drivers written in Rust, I don't know?
Maybe?
</blockquote>
</p>

<p>
For Kroah-Hartman, seeing real drivers in Rust for the kernel would
<a href="/ml/ksummit-discuss/YOVbsS9evoCx0isz@kroah.com/">help clear up</a> how these problems are going to be solved in the language.
There are some difficult problems that will need to be tackled:
<blockquote class="bq">
This is going to be the "interesting" part of the rust work, where it
has to figure out how to map the reference counted objects that we
currently have in the driver model across to rust-controlled objects and
keep everything in sync properly.
<p>
For the normal code, the fact that the memory was assigned to one
specific object (the struct device) but yet referenced from another
object (the cdev).  devm_* users like this do not seem to realize there
are two separate object lifecycles happening here as the interactions
are subtle at times.
<p>
I am looking forward to how the rust implementation is going to handle
all of this as I have no idea.
</blockquote>
</p>

<p>
There is also the question of where all of this leads.  Walleij <a
href="/ml/ksummit-discuss/CACRpkdatK-U16oefmGoov7u_obekVP4m1fT=6joCVpT00Sm09A@mail.gmail.com/">wondered</a>
whether the "leaf nodes" of the kernel (i.e. drivers) are actually the best place to start
from the perspective of showing the benefits of the language.  He also <a
href="/ml/linux-kernel/CACRpkdat-4BbKHMBerdxXBseMb9O3PiDRZmMLP_OWFE2ctSgEg@mail.gmail.com/">asked</a>
about that in a lengthy message back in April.  Part of his question is
whether the
decision to start with drivers was made for other reasons:
<blockquote class="bq">
If the whole rationale with doing device drivers first is strategic,
not necessarily bringing any benefits to that device driver
subsystem but rather serving as a testing ground and guinea
pig, then that strategy needs to be explicit and understood
by everyone. So while we understand that Rust as
all these $UPSIDES doing device drivers first is purely
strategic, correct? I think the ability to back out the whole
thing if it wasn't working out was mentioned too?
</blockquote>
</p>

<p>
He also asked about writing whole subsystems in Rust.  That would entail exposing
Rust APIs to C code elsewhere in the kernel.  It would also potentially allow
an evolution toward more and more Rust in the kernel:
<blockquote class="bq">
If we want to *write* a subsystem in Rust then of course it will
go the other way: Rust need to expose APIs to C. And I assume
the grand vision is that after that Rust will eat Linux, one piece
at a time. If it proves better than C, that is.
</blockquote>
</p>

<p>
Ojeda <a
href="/ml/ksummit-discuss/CANiq72mi-oGAgsws5SpbVyp+NOPXp_6NYq-oWLKe_UD95POGVA@mail.gmail.com/">said</a>
that while it is possible to expose Rust APIs to the C part of the system,
he does not recommend it.  The problem is that the C callers lose much of
the benefit that Rust brings to the table:
<blockquote class="bq">
In general, I would avoid exposing Rust subsystems to C.
<p>
It is possible, of course, and it gives you the advantages of Rust in
the *implementation* of the subsystem. However, by having to expose a
C API, you would be losing most of the advantages of the richer type
system, plus the guarantees that Rust bring as a language for the
consumers of the subsystem.
</blockquote>
</p>

<p>
In a similar vein,  Johannes Berg <a
href="/ml/ksummit-discuss/db6ee5da45bbf526b13fda7d1cd2bf93f24cd84f.camel@sipsolutions.net/">asked</a>
about replacing parts of a subsystem with Rust, but leaving the drivers in
C—the reverse of the existing plan, effectively.  Once again, Ojeda <a
href="/ml/ksummit-discuss/CANiq72=HAMqn6aqVpieyLyP4gOMT4zKzYRNTZ0TqNYEC4hdjKw@mail.gmail.com/">said</a>
that its possible, but cautioned about losing Rust features and
guarantees.  In addition, there are architectures where there is no Rust
compiler available at this point, so it may be premature to be looking at
Rust-based subsystems.
</p>

<h4>Future</h4>

<p>
The project's eventual goal is not entirely clear. 
If all of the Linux drivers were written in Rust, there would still be lots
of big important pieces that are running unsafe C; is the next step to
replace those if Rust proves itself in the meantime?  But it is also
unclear what "proves itself" actually means in this context.
</p>

<p>
Learning a new language, with all of its different behaviors,
quirks, and idiosyncrasies,
is a pretty big ask for developers who are already juggling a fair amount
of complexity in maintaining the existing kernel code.  Not to mention the added
complexity of providing new functionality on top of what's already there.  The
skepticism that seems fairly prevalent from commenters in both threads (and
elsewhere) 
likely stems from that learning burden.
</p>

<p>
Adding Rust to the kernel requires a lot of work, for a lot of
different people, without a clear and obvious benefit beyond promises that
can only truly be fully fulfilled with a whole kernel written in Rust.
With luck, the project can provide some clear "wins" in the early going
that clearly demonstrate both the potential of the language and an ability
to be utilized incrementally on a large and complex code base like the
kernel.  Without that, it may be difficult for the project to progress very
far in the goal of "rustifying" the kernel.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/862018/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor862084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 7, 2021 23:47 UTC (Wed)
                               by <b>rvolgers</b> (guest, #63218)
                              [<a href="/Articles/862084/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Ojeda tried to allay those fears to a certain extent, but did acknowledge that most kernel developers would eventually need to understand the language.</font><br>
<p>
I think this is referring to this email: <a href="https://lwn.net/ml/ksummit-discuss/CANiq72=LrxpE_2WmdDdb5G=8ZbWnZLQTetmRjz+yH024eT4Fag@mail.gmail.com/">https://lwn.net/ml/ksummit-discuss/CANiq72=LrxpE_2WmdDdb5...</a><br>
<p>
Basically it seems to be saying that if the project is a success the end result should be, if you want to change APIs which have Rust bindings, then you need to understand those Rust bindings so you can adjust them as well.<br>
<p>
Which makes a lot of sense, if you change kernel code which breaks other kernel code, then you need to fix that other code. But it does make clear the scope of this project and how big a decision it is to commit to this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862090"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust noise</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 1:07 UTC (Thu)
                               by <b>eacb</b> (guest, #134663)
                              [<a href="/Articles/862090/">Link</a>] (131 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why such a bia in LWN articles to talk about rust?<br>
I mean, this patchset, that will probably (hopefuly) never get merged, has as many lwn articles as versions published. How many important patchsets got to a v2+ (and with a chance to land) were uncovered here?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862090/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust noise</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 2:36 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/862097/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      This is a fundamental decision about the future of the kernel project; it seems worthy of more than one detailed look.
      
          <div class="CommentReplyButton">
            <form action="/Articles/862097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 2:04 UTC (Sun)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/862495/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seconded. One of the most important changes ever considered. Please continue to err on the side of more coverage rather than less.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862096"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 2:40 UTC (Thu)
                               by <b>karath</b> (subscriber, #19025)
                              [<a href="/Articles/862096/">Link</a>] (125 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The bias that you do not like is a bias that I like.<br>
<p>
There are people that want to improve the Linux environment. Their effort might be rejected because they end up not meeting the reasonable entry criteria. And that is not relevant.<br>
<p>
What is relevant is that they have a goal that is quite different to most other improvement efforts, and believe in it enough to spend resources (time, money, etc). And if they fail, then that failure will inform future efforts, including languages other than Rust.<br>
<p>
This is worth reporting.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862096/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 7:19 UTC (Thu)
                               by <b>proski</b> (subscriber, #104)
                              [<a href="/Articles/862111/">Link</a>] (124 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent answer, thank you! On top of that Rust may bring new developers to Linux kernel who would not touch it otherwise. Rust is a marketable programming language, C is legacy. Switching from any modern programming language to C feels like going to a minefield. Even more so when going from userspace to kernel development.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862122"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 12:33 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862122/">Link</a>] (119 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Switching from any modern programming language to C feels like going to a minefield. Even more so when going from userspace to kernel development.</font>

<p>Exactly. C have lots of footguns. C++ have <b>even more</b> footguns. You can write nice, clean, concise code in C++… but you can't avoid them — especially when compiler developers add more and more of them to the language each year.</p>

<p>Rust doesn't try to remove footguns from the language (indeed, when you are programming the kernel that's basically impossible) but tries to make sure each and every one of them is marked as <b>unsafe</b>.</p>

<p>That's why driver sounds, in theory, most promising thing to port to Rust: they are often written by hardware guys, who are not experienced with judging all these footguns. And, also, hopefully, API can be presented to them which allows them to write drivers in default, safe, Rust.</p>

<p>This would be huge win if that would happen to be actually possible.</p>

<p>But if you rewrite core of kernel into Rust… gains would be much smaller: the closer to the dark magic of core data structures you come the more <b>inherent</b> footguns would be there.</p>

<p>And that's also why implementing real driver for real hardware is important milestone: certain nasty footguns live in kernel because they are inherent to interaction with hardware and it would be nice to see how large the glue code would be needed to even port one driver. It's fine if there would be more glue code than actual driver code (it would, eventually, be shared with all drivers so it's not a big deal), but if the driver itself would be peppered with numerous <b>unsafe</b> blocks then the whole exercise would become a bit pointless.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862122/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862393"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 17:04 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/862393/">Link</a>] (118 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s not true that Rust doesn&#x27;t try to outright remove footguns.<br>
<p>
Some of the C++ footguns, especially C++ footguns inherited from, or founded upon C compatibility (even if they weren&#x27;t necessarily footguns in C) are relics of a forgotten past. For example, why is &quot;char&quot; allowed to be _either_ signed or unsigned and it&#x27;s up to the implementation to choose? Because the hardware at the time varied. Fast forward to the 21st century and nobody wishes they had whichever of Rust&#x27;s i8 and u8 is faster on the CPU they&#x27;re using. That isn&#x27;t a thing. So, if you want i8 you ask for i8 and if you want u8 you ask for u8, and you thus can&#x27;t blow your foot off by getting a type that isn&#x27;t what you thought it would be.<br>
<p>
Likewise, why do the signed integers have undefined behaviour on overflow? Ancient hardware represented negative numbers in several ways. So, for maximum compatibility C can&#x27;t specify what happens. Maybe it should have said platform defined, too late now. Great, but every platform available today has two&#x27;s complement arithmetic, so this serves no purpose. Rust gets to just say this up front. Debug builds panic! if you overflow, if the mistake survives until Production you get two&#x27;s complement arithmetic and good luck with that. If you explicitly _want_ wrapping, or saturating arithmetic (the latter especially could make sense in audio), you can ask for them in Rust, either for one operation (e.g. a saturating addition) or as the type of a variable and you get what you asked for, no panics, the compiler produces good optimised code for this case. But even if not the footgun of &quot;Undefined behaviour&quot; for overflow is banished.<br>
<p>
Sometimes compilers got better and we no longer need to spell out what can be inferred. C and C++ both have the pair of unary increment operators. They are footguns. Both b++ and ++b are a bit less typing than b += 1 but they squeeze a lot of opportunity for mistakes into so few characters. Why two of them? Because C and C++ make these unary operators have a result as well as their assignment effect, even though you rarely need it, and the results are different. In Rust the unary increments don&#x27;t exist, and the other assignment operators do not have a result (strictly, their result is the empty tuple), if you mean a = b; b+= 1 you can write that, and if you mean b+= 1; a = b you can write that instead. Don&#x27;t worry, a modern compiler is smart, you don&#x27;t get slower code just because it was slightly more typing.<br>
<p>
Sometimes the problem scope was meanwhile clarified. Rust lacks C and C++&#x27;s &quot;volatile&quot; keyword which I&#x27;ve talked about before at some length. That keyword is probably a mistake. The thing it was intended for in Unix exists in Rust as a set of compiler intrinsics named volatile_read and volatile_write (a set because they come in different sizes, it turns out your hardware knows whether you wrote a 32-bit integer or two 16-bit integers to memory), and many of the things it was mistakenly abused to do in C or C++ are specifically outlawed in those languages today because they can&#x27;t work. So in practice the gap between Rust&#x27;s volatile_read/ volatile_write and C++ volatile keyword is just footguns you avoided by not having that type qualifier.<br>
<p>
Aside from things related to the unsafe keyword itself (e.g. calling unsafe functions) I believe Rust only lets you do 3 things in unsafe code that you weren&#x27;t anyway allowed to do in safe code. You can dereference a raw pointer. You can access fields in a union. You can mutate statics. That&#x27;s all. Those are indeed potential footguns (who knows what, if anything, that raw pointer is pointing at; maybe that field in the union isn&#x27;t the one with valid data in it; hey, another thread is reading that static variable, changing it seems like a bad idea) but that&#x27;s a much smaller set than you might have expected.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862393/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862396"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 18:21 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862396/">Link</a>] (113 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Maybe it should have said platform defined, too late now.</font>

<p>Why is it too late? Correct programs would stay correct and incorrect programs (which their authors perceive as correct!) would become truly correct.</p>

<p>In fact his is <b>exactly</b> <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n897.pdf">what was supposed to happen</a>: <i>Undefined behavior gives the implementor license not to catch certain program errors that are difficult to diagnose. It also identifies areas of possible conforming language extension: <b>the implementor may augment the language by providing a definition of the officially undefined behavior</b></i> (emphasis mine).</p>

<p>Signed overflow was declared “undefined” not because of differences in hardware, because of ones-complement — but simply because it was obvious to the developers of C almost half-century ago that it's hard to add new undefined behaviors but easy to remove them.</p>

<p>That was an era when developers of the standard cared about users of the language, though. Over time users stopped being direct influencers of the standard. Instead it caters more to the developers of the compilers. Who do care about how can they write a compiler and don't really care about the need to, you know, <b>use</b> that compiler. To write real programs. <b>That</b> is not a problem. They can/should navigate the footguns when they no longer make any sense.</p>

<font class="QuotedText">&gt; Rust gets to just say this up front.</font>

<p>And C++20 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1236r1.html">says that</a>, too. Except they kept most the footguns there to trip the unwary. They just demand two's complement now.</p>

<p>Rust is <a href="https://rust-lang.github.io/rfcs/0560-integer-overflow.html">not entirely consistent</a> there, as you have correctly noted. Overflow may panic (in debug builds or if you use <code>-C overflow-checks</code> or it may silently wrap (like it does in C with unsigned types). What it <b>can not do</b> under <b>any circumstances</b> is to give the compiler license to turn the whole program into a pile of goo. Not even in <code>unsafe</code> blocks.</p>

<font class="QuotedText">&gt; It's not true that Rust doesn't try to outright remove footguns.</font>

<p>Okay. You are right. Some footguns are removed entirely. Many more still live. But only in <code>unsafe</code> code blocks.</p>

<font class="QuotedText">&gt; that's a much smaller set than you might have expected.</font>

<p>You sound just like von Jolly. Who said to Max Planck back in the 1878: <i>in this field, almost everything is already discovered, and all that remains is to fill a few unimportant holes</i>. Same with Rust: yes, <code>unsafe</code> gives you a tiny number of superpowers, but abuse of these superpowers can easily cause effects which will infect the whole program and would cause undefined behaviors god know where.</p>

<p>That's why is important to see how many <code>unsafe</code> blocks real drivers would requite and what kind of code would you need to include in such unsafe blocks.</p>

<p>Very few <code>unsafe</code> blocks (but tricky and complex to use ones) may herald the return of majority of C-style footguns. Just the ability to transmute to the value which doesn't exist in enum may lead to very misterious crashes in completely superficially unrelated code, e.g.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862396/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 20:07 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/862404/">Link</a>] (112 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why is it too late?</font><br>
<p>
In practice when they have an opportunity to do so, all the platforms you care about (e.g. GCC or LLVM) will leave the definition blank. They don&#x27;t want to commit to anything in particular and so given the option they won&#x27;t. As you observe the C++ committee is gradually moving towards just defining that you get two&#x27;s complement in the language standard which sidesteps this problem.<br>
<p>
However, some of the authors of the C++ work in the area you cited observe that programmers are unduly hopeful about what this means. If your code has an overflow you don&#x27;t handle correct, you are unlikely to be happier with what happens under twos complement arithmetic than with the practical results (not pregnant male cats, nasal demons or formatted hard disks) of Undefined Behaviour. That is:<br>
<p>
If you write Rust and it overflows under debug and panics, and so then you fix your code, that&#x27;s something a hypothetical alternate C++ doesn&#x27;t give you.<br>
<p>
Only if you write Rust, switch off overflow detection, and it overflows anyway but that works out OK due to two&#x27;s complement arithmetic, is that something you&#x27;d get with the hypothetical alternative C++. This Rust code smells funny, if I had to review it I would flag this and ask why you didn&#x27;t explicitly say (not in a comment, in the code) what&#x27;s going on. If you actually *want* a wrapping multiply, in Rust you can explicitly say that&#x27;s what you wanted, the compiler couldn&#x27;t care less but a human maintainer does.<br>
<p>
Now C++ standards people are smart, and so perhaps in reality C++ 23 gets Wrapping&lt;int&gt; and Saturating&lt;int&gt; for all integer types, as well as a family of standard overflow arithmetic check operators so programmers who *know* they have a potential problem don&#x27;t have to contort themselves as they would today. *That* would be equivalent to what Rust has already today.<br>
<p>
<font class="QuotedText">&gt; Just the ability to transmute to the value which doesn&#x27;t exist in enum may lead to very misterious crashes in completely superficially unrelated code, e.g.</font><br>
<p>
What sort of error are you imagining here? Are you thinking about a C enumerated type? Or Rust&#x27;s more sophisticated enum? And how is it being transmuted? I mean, sure, unsafe pointer dereference could do absolutely anything, but somehow a lot of C and C++ footguns do not involve any pointers being dereferenced at all so I still think you&#x27;re underestimating how much difference this makes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 21:17 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862408/">Link</a>] (111 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; I mean, sure, unsafe pointer dereference could do absolutely anything, but somehow a lot of C and C++ footguns do not involve any pointers being dereferenced at all so I still think you're underestimating how much difference this makes.</font>

<p>It does a lot of difference. But look on <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:rust,selection:(endColumn:5,endLineNumber:21,positionColumn:5,positionLineNumber:21,selectionStartColumn:5,selectionStartLineNumber:21,startColumn:5,startLineNumber:21),source:'%23%5Bderive(Debug)%5D%0A%23%5Brepr(i8)%5D%0Apub+enum+Foo+%7B%0A++++A+%3D+0,%0A++++B+%3D+1,%0A++++C+%3D+2,%0A++++D+%3D+3%0A%7D%0A%0Afn+gimme_a_enum()+-%3E+Foo+%7B%0A++unsafe+%7B+std::mem::transmute::%3Ci8,+Foo%3E(4)+%7D%0A%7D%0A%0Apub+fn+main()+%7B+%0A++++let+var:+Foo+%3D+gimme_a_enum()%3B%0A++++let+var:+Option%3CFoo%3E+%3D+Some(var)%3B%0A++++match+var+%7B%0A++++++++Some(_)+%3D%3E+println!!(%22Some%22),%0A++++++++None+%3D%3E+println!!(%22None%22)%0A++++%7D%0A++++println!!(%22%7B:%3F%7D%22,+var)%0A+%7D%0A'),l:'5',n:'0',o:'Rust+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:r1530,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'0',trim:'1'),fontScale:14,fontUsePx:'0',j:1,lang:rust,libs:!(),options:'',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'rustc+1.53.0+(Editor+%231,+Compiler+%231)+Rust',t:'0')),header:(),k:50,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'Output+of+rustc+1.53.0+(Compiler+%231)',t:'0')),header:(),l:'4',m:50,n:'0',o:'',s:0,t:'0')),k:50,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">this simple example</a> (without any crazy pointers): somehow <b>Some</b> have become <b>None</b>… but only in debug build. In optimized build it's both <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:rust,selection:(endColumn:5,endLineNumber:21,positionColumn:5,positionLineNumber:21,selectionStartColumn:5,selectionStartLineNumber:21,startColumn:5,startLineNumber:21),source:'%23%5Bderive(Debug)%5D%0A%23%5Brepr(i8)%5D%0Apub+enum+Foo+%7B%0A++++A+%3D+0,%0A++++B+%3D+1,%0A++++C+%3D+2,%0A++++D+%3D+3%0A%7D%0A%0Afn+gimme_a_enum()+-%3E+Foo+%7B%0A++unsafe+%7B+std::mem::transmute::%3Ci8,+Foo%3E(4)+%7D%0A%7D%0A%0Apub+fn+main()+%7B+%0A++++let+var:+Foo+%3D+gimme_a_enum()%3B%0A++++let+var:+Option%3CFoo%3E+%3D+Some(var)%3B%0A++++match+var+%7B%0A++++++++Some(_)+%3D%3E+println!!(%22Some%22),%0A++++++++None+%3D%3E+println!!(%22None%22)%0A++++%7D%0A++++println!!(%22%7B:%3F%7D%22,+var)%0A+%7D%0A'),l:'5',n:'0',o:'Rust+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:r1530,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'0',trim:'1'),fontScale:14,fontUsePx:'0',j:1,lang:rust,libs:!(),options:'-O',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'rustc+1.53.0+(Editor+%231,+Compiler+%231)+Rust',t:'0')),header:(),k:50,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'Output+of+rustc+1.53.0+(Compiler+%231)',t:'0')),header:(),l:'4',m:50,n:'0',o:'',s:0,t:'0')),k:50,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">Some and None</a>.</p>

<font class="QuotedText">&gt; *That* would be equivalent to what Rust has already today.</font>

<p>No, it wouldn't. Rust would <b>never</b> just throw away <code>assert(x + 100 &gt; x);</code> and introduce the security hole. It may trigger an assert message. Or panic. But it wouldn't remove security check. <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVAB9LclIj2yAnjqVMtdAGFUrAK4BbWl06lT6ADJ5amAHJ2ARpmJlAAdUIUIjWksbe0dSELDDOndPH1t/QKc9TAMIhgJmYgIouwdOTMx9RNo8goJk7z8A5SF8wuKYst1Wuo8GtKbOAEpdVGtiZA4pAFIAJgBmD2QbLABqKbnzZiERQoA6BHXsKZkAQWOTgDdUPHQV1AuAqlZUAHcNZARsgGsIDwIV8SDNYAdgAQucVpCVlsdgQIOI1jNQStODIZGs5tgAYN1uDTlNgQARc5SYasaQAVnkDlk8lQ0nMKyEo3GmERc048gI0jkg2GXy4aJU0m48lsIApMlINLkpHpUnkQhAUu5tOGcFgMEQKFQtiCeHYZAoEDQeoNTWQwDKTioBoIASVEF8PPkvg8BQAntJOaRTbZTAQAPK0Vhe2mkLC2NTAdguiN4YjZQwPJXhzDibLWe1xv4VOOsPC%2BYieyxYOMEYh4cVSTnDfiMFixnh8OgEYRiSThpQzFTRkBad4qQtKyDDVBBKqpgC0gZmioqSYiJjM7VKzjM9VS6WCoXCdFXO4SEU3jQyugXOToNTaVhKzQvVWvPRSp%2Ba3QPmW6J/6GWGzLGExcGSlLUnG8riAAHAAbFOUHcCswDIMgKKcLsnArBAuCECQ7JOCslhmoa7IzEC5hci6fKkAKMwUsKUiiqQ4qStKYHSIqyqkKqvKkBq2qmvqhrkJQ/HmoESGqOonAzEKtqsPaxCOs64ZurQnrevIfoBsGoZxpG0axuG%2BCJjkKZxummbZuGubkuGBZFiWGCTLKFZVupdatkwbAcM29bthIcZKE4EmaNoQ6%2BCOEBjhOETTrO86VEuEAuB%2B65uL0W4DHEu5VCl8R7rQ37buUCVXu%2Bt4dOeJXVF%2B6Wvp%2BtQpS0tSFQMf4soBQx0VSLHhuB0GwfBSzRiiMy7DIY0YVhRDELhpD4bqAkBLhpHkWqwyfMwWCBJFVEgDRdEMTKdJsboHFcaSPFahASAiYJxq3RaSwaJ4bxwXwdoOpQSmyipak1hpur%2BvQ2lhrKenqAZYMJouplphmyBZk58jWfmhbFsQHqlkjnGVtWtYtvQnlNrwvkiP5XYgHMvbqP2oV2RFUWTtIM5zpVi7GElK7lWuLgtWeeU5dzh75Xz95VU%2BjUPrkNUvj%2Bb4NUL9WFKLnX/qyQFdaBvXSOIcErLYQgXMhFycAAnGh8EQAA6gAkl42BAph%2BDTbN82EUtsxzHMK2cRR/J7dwuym8HIeh6HUEHVrsryuxKoUZd8DXTq7tGsJC2iSgeBIdJMxlD2snyYpca/Rj6m%2BoDWkhqD8jgzG2NGTDmCprK5kI5Zsoo7ZaMOWW4YuXjF31kT3kk62fmdrKSi8MFtODvT8CMzFzNxWzl4OJzFiK6lKtZUe%2B5bwLx61XLxXs9VCvRGuWRr0%2BO9NTel/y8rx9FW1AHecBUjdUdco6/1etZ2QjnVCqEZiTWdjhT2eECKLRmp7bgPtzqUWorRGyh1WIKlOnHNadFWZMSlD/GOvscE2TmFHY6mCkHDAeApJc3AgA%3D%3D">C compiler can and would do that</a>. Huge difference.</p>

<font class="QuotedText">&gt; In practice when they have an opportunity to do so, all the platforms you care about (e.g. GCC or LLVM) will leave the definition blank.</font>

<p>Except GCC and LLVM are not “platforms”. They are just compilers. And they are replaceable. Yes, their authors work diligently on making C and C++ <i>unfit for any purpose</i>. But they are not there yet. And while Rust uses LLVM as a base… somehow the very simple <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVDIApACYAQjt2kR7ZATx1KmWugDCqVgFcAtrWVX0AGTy1MAOWcARpjEXJykAA6oQoTmtHaOLsqR0WZ0Xj7%2BTkEhnGHGmKaxDATMxATxzq55mCaptMWlBOl%2BgcGhRiVlFYl5nU3eLVltuQCURqgOxMgcUjoAzN7IjlgA1JpzNuZCBMSYzE7r2JoyAILHJwGo9itEAPpBtyS3tKgEt3dBECNrAOz6pytAStvAQVkF1v8TkCVrsCJNaGDML8bJofjYVmAwOC5pDUQARc7nEErJzMbxfX6Q6HbdAgFATUHrFEbNbabQAFVQiJWJBWL1BRERIFZ2jWGyZN1Q90wj2Iz1e7yln2%2BTIlNLp7lYEMJPwJpykY1Y0gArPJXLJ5KhpCi9AYVkIJlMkfNOPICNI5CMxgBrEBzOYAOn9wZDoYAbCppNwzR7LdJ5EIQDJSO6LWM4LAkGgnOE8OwyBQINnc/mUKp1JxtDJk1Q8wRgomIAFY6QAt5SgBPaSu0jZpxWAgAeVorC7FtIWFJ6nYLfwu0KADdMInx5hxAUHPWWyCai3WHgAsRO3YsC2dngnN2DXw6IwWDOeDfBCIJC2lGFyxoDAYVAfE5AxlQcI6hXABaQdtATGoCjqSxrG6KpSHcZpMmyJIohiOgEPQlJYhQ1ociMaDCjoBounsSplHyEj6j6fChkI7ZGmw3pGnotDODGB1JmmLhDRNGNxytKRxAADjDUCw24FYljUYAVkrAMZCUlYIFwQheRdUgVjsHM82CVk5k4nTvz0N1Yy9UgED2LAQi%2BUhfX9INQxc/0IyNKRo1Ic05FIYSEyTFMLNIDNEBABlwk3chKGLfTCMwfAiEI/g7zYDhHxS4QxEkccAHcj3CK9%2BKkU1vJbYTB03SLQVQKgVjEiSpJkz8FO0JSVIgXSSwMl0RnMtMfT9QNXNcyNPME3z/KMQLU09YrILKoT4yCgbSCXYhogsbggA">to be or not to be is… false</a> gotcha is not reproducible with Rust. At least <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:rust,selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'fn+gimme_a_bool()+-%3E+bool+%7B%0A++let+uninit:+i8+%3D+unsafe+%7B+std::mem::MaybeUninit::uninit().assume_init()+%7D%3B%0A++let+be+%3D+unsafe+%7B+std::mem::transmute::%3Ci8,+bool%3E(uninit)+%7D%3B%0A++return+be+%7C%7C+!!be+%3B%0A%7D%0A%0Apub+fn+main()+%7B+%0A++++println!!(%22To+be+or+not+to+be+is:+%7B:%3F%7D%22,+gimme_a_bool())%0A+%7D%0A'),l:'5',n:'0',o:'Rust+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:r1530,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'0',trim:'1'),fontScale:14,fontUsePx:'0',j:1,lang:rust,libs:!(),options:'-O',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'rustc+1.53.0+(Editor+%231,+Compiler+%231)+Rust',t:'0')),header:(),k:50,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'Output+of+rustc+1.53.0+(Compiler+%231)',t:'0')),header:(),l:'4',m:50,n:'0',o:'',s:0,t:'0')),k:50,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">not as easily as doing the direct conversion</a>.

<p>This being said I wouldn't trust <code>unsafe</code> Rust to produce sane results (e.g. I'm pretty sure that “to be or not to be gotcha” can be reproduced in Rust… just maybe with larger structures or something).</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862419"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 0:58 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/862419/">Link</a>] (107 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But look on this simple example (without any crazy pointers)</font><br>
<p>
Fair. However std::mem::transmute is an intrinsic, its implementation isn&#x27;t Rust - presumably under the hood it just tells the compiler this 4 is actually a Foo not an i8, and thus it isn&#x27;t pointer shenanigans, but I don&#x27;t actually know how to check.<br>
<p>
The Linux kernel will for the foreseeable future have tonnes of C code in it, which likewise you can call from unsafe Rust and might do anything, but hopefully even the Rust sceptics don&#x27;t blame Rust for that.<br>
<p>
I was only making claims about what the unsafe Rust itself can do, all bets are off once it&#x27;s not Rust. For one thing there&#x27;s an intrinsic which just emits the assembly you write, binding Rust variables to input or output registers of your choosing - which obviously might do anything, and again is not Rust and doesn&#x27;t have Rust&#x27;s safety guarantees.<br>
<p>
Let&#x27;s take a contrasting example. Suppose I have a function which takes arrays of exactly 4096 bytes. I can&#x27;t write unsafe { x = array[4100]; }. That&#x27;s an error, the compiler will explain that this would definitely panic at runtime and so it won&#x27;t compile. If I add a parameter z and write unsafe { x = array[z] } then the function compiles, but if I call it with z = 4100 the program panics, it does not have Undefined Behaviour, even though I used the unsafe keyword. In fact, if I haven&#x27;t disabled warn(unused_unsafe) the compiler warns me that my unsafe was useless, this code is safe because it will just panic if bounds are exceeded.<br>
<p>
<font class="QuotedText">&gt; But it wouldn&#x27;t remove security check. C compiler can and would do that.</font><br>
<p>
The C compiler removes this check because the scenario where the assert fails is Undefined Behaviour. But in the hypothetical language revision I describe as &quot;equivalent to what Rust has already today&quot; (e.g. a hypothetical C++ 23) this is not Undefined Behaviour, like in Rust you get two&#x27;s complement arithmetic and so the assert survives the removal of redundant code and fires if you overflow.<br>
<p>
This code still smells bad. In Rust I think I would prefer to see something like let result = x.checked_add(100).expect(&quot;x + 100 overflowed&quot;); <br>
<p>
This way I get my result or, I panic with a message explaining what impossible thing happened. If upon reflection it isn&#x27;t so impossible after all I could write x.checked_add(100).unwrap_or(sane_default); to carry on with sane_default instead when x + 100 overflows.<br>
<p>
<font class="QuotedText">&gt; Yes, their authors work diligently on making C and C++ unfit for any purpose. But they are not there yet.</font><br>
<p>
They produce programs with good performance characteristics. For a correct C or C++ program this gives you metrics you can work with. The compiler that turned my correct program into a binary which consumed 45MB and took 800 seconds to get the answer is strictly worse than the compiler which turned the correct program into a binary which consumed 40MB and took 680 seconds to get that answer by these metrics.<br>
<p>
What can we say about the compiler which turned my incorrect program into a binary which gave one result, versus a different compiler which turned my incorrect program into a binary with a different result? Nothing whatsoever.<br>
<p>
They also use their greater understanding of the language to do something you might value more. They write sanitisers. You can often use LLVM with its sanitizers to find out why your program isn&#x27;t correct. If you fix all the problems this finds, maybe your program will be correct and you get the results you wanted.<br>
<p>
Consider something that&#x27;s pretty &quot;old hat&quot; these days but I still remember as a breakthrough. One day GCC learned how to tell whether your printf() format string is bogus at compile time. In Rust this isn&#x27;t so hard, the println format string is required to be a literal string, so although it has to be a macro (no variadic functions in Rust) the checking is always viable at compile time. But in C printf takes any arbitrary pointer to some chars that obey the format string rules at runtime, and then any number of auxiliary parameters of any type. What a mess. But they got it done, today newbies expect the compiler to tell them when they try to printf() four integers but only provide two or vice versa.<br>
<p>
Finally:<br>
<p>
Messing about with unsafe { } to cause yourself problems seems like a poor use of time.  Follow Mara Bos <a href="https://twitter.com/m_ou_se/status/1411294073969950722">https://twitter.com/m_ou_se/status/1411294073969950722</a> for actual mischief with Rust. That link for example is Mara&#x27;s ludicrous macro which tricks the Rust compiler into letting you selectively enable nightly features in your otherwise stable code. To make her trick work, Mara has a proc macro which re-runs the compiler after setting a flag so that it will think it&#x27;s recompiling itself not your code. Rust&#x27;s compiler is allowed to use new features that aren&#x27;t in the stable language yet because otherwise things get a bit too meta. Doing this (using Mara&#x27;s macro or actually just tricking the compiler yourself) invalidates your stability guarantees of course.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862419/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862492"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 1:56 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862492/">Link</a>] (106 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; But in the hypothetical language revision I describe as "equivalent to what Rust has already today" (e.g. a hypothetical C++ 23) this is not Undefined Behaviour, like in Rust you get two's complement arithmetic and so the assert survives the removal of redundant code and fires if you overflow.</font>

<p>This was proposed and rejected. Apparently benchmarks are sacred. Thus it's not happening.</p>

<p>Well… it may happen if people would start abandoning C/C++ ship and switch to Rust (and other languages). But if that would be massive enough movement to make C/C++ committees actually care… then I think it wouldn't matter anymore. So don't expect anything like that any time soon.</p>

<font class="QuotedText">&gt; They produce programs with good performance characteristics.</font>

<p>They turn working programs into broken ones. Once you pass that threshold “performance characteristics” become secondary concern.</p>

<font class="QuotedText">&gt; What can we say about the compiler which turned my incorrect program into a binary which gave one result, versus a different compiler which turned my incorrect program into a binary with a different result? Nothing whatsoever.</font>

<p>What can we say about compiler which produces mathematically <b>impossible result</b>? Function which takes an integer and the returns <code>b || !b</code> should always return true. Any mathematician would say so and even just someone who studied logic a bit would say so.</p>

<p>Yet clang would happily turn it into a function which returns <code>false</code> if you give it some variable which is not initialized.</p>

<p>This goes <b>so</b> far beyond the abilities of someone to reason about the program it's not funny.</p>

<p>In theory it's possible to write program which doesn't trigger any undefined behaviors. In practice I haven't see anyone who have done that with programs of size comparable to Linux kernel.</p>

<p>And since undefined behaviors are infectious in modern compilers you have no idea when and how your program would explode. <a href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">Huge bodies of C code are land mines just waiting to explode</a> is what LLVM developer wrote, not me.</p>

<p>And they are diligently working on a way to detonate them.</p>

<font class="QuotedText">&gt; They also use their greater understanding of the language to do something you might value more. They write sanitisers. You can often use LLVM with its sanitizers to find out why your program isn't correct. If you fix all the problems this finds, maybe your program will be correct and you get the results you wanted.</font>

<p>Let's go to that infamous <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:2,endLineNumber:11,positionColumn:2,positionLineNumber:11,selectionStartColumn:2,selectionStartLineNumber:11,startColumn:2,startLineNumber:11),source:'%23include+%3Cstdio.h%3E%0A%23include+%3Cstdlib.h%3E%0Aint+main()+%7B%0A++++int+*p+%3D+(int*)malloc(sizeof(int))%3B%0A++++int+*q+%3D+(int*)realloc(p,+sizeof(int))%3B%0A++++if+(p+%3D%3D+q)+%7B%0A++++++++*p+%3D+1%3B%0A++++++++*q+%3D+2%3B%0A++++++++printf(%22%25d+%25d%5Cn%22,+*p,+*q)%3B%0A++++%7D%0A%7D'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:100,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:cclang1200,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'1',trim:'0'),fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'-O2+-std%3Dc89',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x86-64+clang+12.0.0+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),k:49.99999999999999,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'%231+with+x86-64+clang+12.0.0',t:'0')),k:49.99999999999999,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',m:50,n:'0',o:'',t:'0')),l:'3',n:'0',o:'',t:'0')),version:4">realloc example</a>.</p>

<p>Can you show me what kind of sanitizer should I use to catch error in it? Or what compilation option? Or… anything at all, really? Can you even <b>explain</b> why compiler was allowed to provide the output it does?</p>

<p>When I pushed really hard on the issue of “how can two pointers be identical yet one is usable while other is not usable” I have got the answer that yes, standard permits that — when one <i>one is a pointer one past the end of one array object and the other is a pointer to the start of a different array  object  that  happens  to  immediately  follow  the  first  array  object  in  the  address space</i>… and apparently after <code>realloc</code> pointer which was passed to it magically turns into pointer one past the end…</p>

<p>Seriously? <b>This</b> what I should have expected from function which <i>returns  a  pointer  to  the  new object  (which  may  have  the  same value  as  a  pointer  to  the  old  object),  or  a  null  pointer  if  the  new  object  could  not  be allocated</i>?</p>

<p>Why does it even say that it <i>may  have  the  same value  as  a  pointer  to  the  old  object</i> if I couldn't use that fact for <b>anything</b>?</p>

<p>These sanitizers are just catching certain common mistakes. They <b>don't even try</b> to catch many cases of undefined behaviors. Which compiler, nonetheless, would ruthlessly exploit.</p>

<font class="QuotedText">&gt; One day GCC learned how to tell whether your printf() format string is bogus at compile time.</font>

<p>These were different days and these were different compiler developers. Back then they were not afraid to help developers to write code instead of catering to KPIs. Remember <a href="https://www.complang.tuwien.ac.at/kps2015/proceedings/KPS_2015_submission_29.pdf">that rant</a>? It may be opinionated but it highlights the story well. 10+ years ago GCC developers cared about <b>real</b> code, and <b>real</b> problems faced by <b>real</b> developers.</p>

<p>But after rise of clang… it all turned into a rat race: gcc and clang looking for a more and more clever ways to punish the developer. Often without even providing any benefits on benchmarks (again: that <code>realloc</code> crazyness definitely doesn't affect <b>any</b> benchmarks). They break the code just because they are allowed to do that.</p>

<p>As simple as that.</p>

<font class="QuotedText">&gt; Rust's compiler is allowed to use new features that aren't in the stable language yet because otherwise things get a bit too meta</font>

<p>Nah. It's because otherwise we would have waited for the stable release of Rust for 10 more years.</p>

<p>It's similar crime to the undefined behavior issue of C: once upon time it wasn't the monstrosity which it turned into recently. But over time something which was supposed to highlight <i>areas  of  possible  conforming  language  extension</i> turned into monster which threatens to destroy everything.</p>

<p>Only time would tell if Rust would, eventually, stabilize enough internal features to make standard-library stable-Rust compatible or if it would follow in the C footsteps.</p>

<p>I, certainly, hope that lessons were learned. But we wouldn't know any time soon.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862492/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 2:24 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/862496/">Link</a>] (77 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; They turn working programs into broken ones. </font><br>
<p>
This rant, and many others, seems to ignore the plain fact that *every single* optimization that GCC or Clang performs is *optional*.  In other words, don&#x27;t tell it to try and optimize your code, and it won&#x27;t.<br>
<p>
Why are C compilers so &quot;awful&quot;?  Because the *users* of those compilers *demand* that awfulness.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862497"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 2:52 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862497/">Link</a>] (58 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt;  Why are C compilers so "awful"? Because the *users* of those compilers *demand* that awfulness.</font>

<p>Seriously? Can you show me <b>one</b> used who <b>wanted</b> to see <code>realloc</code> broken? Or <b>wanted</b> to see code which treats null pointer as just a pointer broken? Or bazillion other things which break the code without giving a significant speedup?</p>

<p>As for “all passes are optional”… is that a joke? Yes, sure, all passes are optional. But e.g., <b>the only way</b> to turn pointers back into addresses is to disable <b>all of them</b>. There are <b>no</b> <code>-fno-provenance</code> flag (even if it was actually <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2263.htm">officially proposed</a>) and there <b>no</b> plans to introduce it.</p>

<p>This is in spite of the fact that <b>zero</b> existing standards mention pointer provenance and <b>no one</b> can actually explain the rules which developer should follow. In reality the rules which are used to deal with it are <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">currently unsound</a>. It's also telling that <b>the only</b> guys who are bothered by the fact that these rules can turn valid programs into invalid ones are… as you have guessed… Rust developers.</p>

<p>Compiler developers? They just happily apply these, as of now, unwritten and untested rules when they compile existing programs. And yes, they routinely break valid (according to the letter of the existing standard) programs. In fact all these half-dozen or so proposals are dedicated to the attempt to <b>add more undefined behaviors to the standard</b> to turn valid programs into invalid ones and thus, retroactively, justify what compilers are doing today.</p>

<p>Do you <b>really</b> want to say that this is what <b>users</b> wanted? Are they even <b>aware</b> that's what they wanted?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862497/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 6:01 UTC (Sun)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862501/">Link</a>] (57 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Compiler developers? They just happily apply these, as of now, unwritten and untested rules when they compile existing programs. And yes, they routinely break valid (according to the letter of the existing standard) programs. In fact all these half-dozen or so proposals are dedicated to the attempt to add more undefined behaviors to the standard to turn valid programs into invalid ones and thus, retroactively, justify what compilers are doing today.</font><br>
<p>
I totally agree with this and it&#x27;s why I&#x27;m extremely angry at gcc&#x27;s developers for destroying what used to be the most portable compiler. I suspect they&#x27;re sponsored by the same who sponsor rust because over the last 5 years or so, their only contribution has been to carefully break programs that used to work flawlessly for 20 years on the very same compiler. Worse, they break boundary tests that were purposely placed in programs to avoid security issues, just because one day they decide that it&#x27;s useful to drop an overflow test that is based on an undefined behavior, without ever being able to emit the slightest warning about it! We&#x27;re seeing an increase of compiler-induced bugs that are sometimes security issues, and given that new optimizations come by default and the compiler continues to complain about unknown -fno-foobar options, you cannot easily disable these in a portable way in your programs without breaking older compilers that were still sane.<br>
<p>
The last trustable gcc version I&#x27;ve used was 4.7. After that it progressively became utter crap introducing random breakages in your back. It coincides with the rewrite in C++, maybe it indicates a lack of interest for the practical C language by their developers, though I don&#x27;t know.<br>
<p>
Ah and please don&#x27;t speak about optimizations. Code size has since significantly increased, is often slower (likely due to L1 cache footprint and/or extreme vectorization/unrolling for short iterations), and the build time has increased 2-3 fold.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862507"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 9:16 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862507/">Link</a>] (55 responses)
      </p>
      
      </div>
      </summary>
      <p>Do you really hope anyone would treat your rants seriously when you don't do even a simple fact-checking?</p>

<font class="QuotedText">&gt; The last trustable gcc version I've used was 4.7.</font>

<p>How is it “trustable” when it happily removes your beloved <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:1,endLineNumber:6,positionColumn:1,positionLineNumber:6,selectionStartColumn:1,selectionStartLineNumber:6,startColumn:1,startLineNumber:6),source:'%23include+%3Cassert.h%3E%0A%0Avoid+check_for_overflow(int+x)+%7B%0A++++assert(x+%2B+100+%3E+x)%3B%0A%7D%0A'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:100,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:cg471,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'1',trim:'0'),fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'-O2',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x86-64+gcc+4.7.1+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),k:49.99999999999999,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'Output+of+x86-64+gcc+4.7.1+(Compiler+%231)',t:'0')),k:49.99999999999999,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',m:50,n:'0',o:'',t:'0')),l:'3',n:'0',o:'',t:'0')),version:4">security checks</a>? Heck, even GCC 4.1 (oldest available on godbolt) <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:1,endLineNumber:6,positionColumn:1,positionLineNumber:6,selectionStartColumn:1,selectionStartLineNumber:6,startColumn:1,startLineNumber:6),source:'%23include+%3Cassert.h%3E%0A%0Avoid+check_for_overflow(int+x)+%7B%0A++++assert(x+%2B+100+%3E+x)%3B%0A%7D%0A'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:100,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:cg412,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'1',trim:'0'),fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'-O2',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x86-64+gcc+4.1.2+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),k:49.99999999999999,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'Output+of+x86-64+gcc+4.1.2+(Compiler+%231)',t:'0')),k:49.99999999999999,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',m:50,n:'0',o:'',t:'0')),l:'3',n:'0',o:'',t:'0')),version:4">does that</a>. And if you would look on the <a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=30475">appropriate bug</a> you'll know GCC 2.95 did that as well!</p>

<p>And it was released last century when Rust wasn't even a thing! Graydon Hoare may have played with some ideas which eventually lead to creation of Rust back then, but it wasn't even presented to Mozilla employees, let alone general public.</p>

<p>In fact in the beginning Rust wasn't even about replacement of C or C++ (it still isn't… some Rust fanboys are trying to portray Rust as “modern C/C++ replacement” but it's developers are not aiming that high).</p>

<p>It was about moving low-level programming field from 70th to 90th (yes, Rust includes <b>zero</b> ideas from XXI century, all things which you see in it were “boring and old” when it was conceived…). Some of these ideas were quite “modern and unproven” at the end of XX century but today they are “old and boring”.</p>

<font class="QuotedText">&gt; It coincides with the rewrite in C++, maybe it indicates a lack of interest for the practical C language by their developers, though I don't know.</font>

<p>If you “don't know” then why do you write all these rants which one step away from “<a href="https://en.wikipedia.org/wiki/Reptilian_conspiracy_theory">reptiolds</a> are using Rust to destroy human civilization!” ?</p>

<p>Yes, compilers have become more and more clever at exploiting what they consider undefined behavior. But this “fall from grace” was very slow and gradual. And it wasn't caused by a switch to C++ or creation of clang, let alone Rust.</p>

<p>To claim that <b>all that</b> was done by some hidden beneficiary which did all that to, somehow, push modern language into system developer's community and bring them, kicking and screaming, to XXI century… that's new low, I think.</p>

<p>Sure, at first the breakage could be contained with the use of some simple flags… but as time marched on… it became harder and harder to do.</p>

<p>And these flags were introduced as a concession to developers, not as something compiler developer promised to always deliver.</p>

<p>The new thing that happened recently is situation where complexity of compiler optimizations have grown enough that not only offering such flags have become more-or-less impossible, but where they couldn't even compile correct programs reliably — and instead of thinking about how they can change the compiler to bring it back to standards-compliance they started thinking about way to move the goalposts in the standard text!</p>

<p><b>That</b> is when C and C++ have become “languages unfit for any purpose” and Rust have started gaining popularity.</p>

<font class="QuotedText">&gt; Code size has since significantly increased, is often slower (likely due to L1 cache footprint and/or extreme vectorization/unrolling for short iterations), and the build time has increased 2-3 fold.</font>

<p>Yet execution time for benchmarks decreased which was the goal. The fact that kernel community was burned in the process is just a side effect.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/862507/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862517"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 11:40 UTC (Sun)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862517/">Link</a>] (54 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; The last trustable gcc version I&#x27;ve used was 4.7.</font><br>
<font class="QuotedText">&gt; How is it “trustable” when it happily removes your beloved security checks? Heck, even GCC 4.1 (oldest available on godbolt) does that. And if you would look on the appropriate bug you&#x27;ll know GCC 2.95 did that as well!</font><br>
<p>
Indeed it does with constants! With variables (which used to be my main use case) it resisted much longer, and 7 still emits the test, which was dropped in 8: (x+y &lt; x) with both x and y ints simply checks for the sign of y now.<br>
<p>
Anyway what I said still translates my experience. From 2.5.8 to 4.7, my concerns were mostly varying optimization quality (e.g. -Os giving significantly larger executables past 3.4), some jokes about structures initialization, and variable array declaration, changes to asm input/output/clobbers, out-of-block asm being reordered, but most of these resulted in build-time errors that were annoying but addressable. I started to spot runtime breakage once in 4.8, a few times in 5, then 6 broke quite some builds, then runtime breakage again in 8, 10, and 11 with each time a good explanation such as &quot;your 25-years old expression needed 12 extra casts to be fully spec-compliant, even if it works fine like this on any other compiler&quot;.<br>
<p>
In my opinion all this doesn&#x27;t deserve yet-another-flag, it instead deserves a dialect to be used like &quot;-std=safe11&quot; for example, which would turn UB and IDB to well-defined behavior, even if it makes SPECint look slightly less advantageous. Defining valid pointer arithmetics, not breaking the absurd realloc() case nor the &quot;b||!b&quot; case, using signed chars by default etc would respond to the principle of least surprise for the vast majority of developers, and actually get back to when C was and easy and portable assembly language.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862517/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862521"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 13:32 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862521/">Link</a>] (53 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; In my opinion all this doesn't deserve yet-another-flag, it instead deserves a dialect to be used like "-std=safe11" for example, which would turn UB and IDB to well-defined behavior, even if it makes SPECint look slightly less advantageous.</font>

<p>This wouldn't “make SPECint look slightly less advantageous”, this would outlaw <b>any and all optimizations</b>.</p>

<p>Let's take a look <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:15,endLineNumber:10,positionColumn:15,positionLineNumber:10,selectionStartColumn:15,selectionStartLineNumber:10,startColumn:15,startLineNumber:10),source:'%23include+%3Cstdio.h%3E%0A%0Avoid+foo(int*+i)+%7B%0A++i%5B1%5D+%3D+42%3B%0A%7D%0A%0Aint+bar()+%7B%0A++int+i+%3D+3,+j+%3D+3,+k+%3D+3%3B%0A++foo(%26i)%3B%0A++return+j+%2B+k%3B%0A%7D%0A%0Aint+main()+%7B%0A++printf(%22%25d%5Cn%22,+bar())%3B%0A%7D%0A'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:33.333333333333336,l:'4',m:100,n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:cg102,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'0',trim:'1'),fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'-O0+',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x86-64+gcc+10.2+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),k:33.333333333333336,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'Output+of+x86-64+gcc+10.2+(Compiler+%231)',t:'0')),k:33.33333333333333,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',m:100,n:'0',o:'',t:'0')),version:4">on a concrete example</a>:

<pre>
#include &lt;stdio.h&gt;

void foo(int* i) {
  i[1] = 42;
}

int bar() {
  int i = 3, j = 3, k = 3;
  foo(&amp;i);
  return j + k;
}

int main() {
  printf("%d\n", bar());
}
</pre>

<p>What kind of compiler can you imagine that would optimize anything while leaving such example (and other similar examples) intact?</p>

<p>All optimizations in C rely on absence of UB. All. No exceptions.</p>

<p>You cound't even turn 2 + 2 into 4 without breaking something if you would allow any and all UB (don't show such an example because GCC optimizes that even with <code>-O0</code>!… so much about “just turn off optimizations off if you don't like them” BTW).</p>

<p>To permit <b>all</b> UBs would mean to go back to “C from 70th” where only variables declared as <code>register</code> can be put in registers. Result would be not “make SPECint look slightly less advantageous”, but something that no one (not even you, I suspect) would want to use.</p>

<p>That's just how C and C++ are made.</p>

<font class="QuotedText">&gt; Defining valid pointer arithmetics, not breaking the absurd realloc() case nor the "b||!b" case, using signed chars by default etc would respond to the principle of least surprise for the vast majority of developers, and actually get back to when C was and easy and portable assembly language.</font>

<p>Before you can introduce such switch (in a meaningful manner, not in 
“stop turning <code>2 + 2</code> into <code>4</code>” manner) you have to do <b>insane</b> amount of work. Classify all these undefined behaviors, clarify what compiler is allowed and not allowed to do about them and so on.</p>

<p>You need to, basically, invent completely new language.</p>

<p>And if you are inventing completely new language then why not add some markups there which would make compiler job easier? And why not make things which existing C and C++ compiler try to glean from the shaky “developer is smart and wouldn't write code which triggers UB” rule explicit if you are inventing new language anyway?</p>

<p>Someone may end up creating another Rust-alike  but there are literally <b>zero</b> chances of ever getting that <code>-std=safe11</code> switch. Not gonna happen. Deal with it. </p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862521/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862523"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 14:47 UTC (Sun)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/862523/">Link</a>] (52 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  This wouldn&#x27;t “make SPECint look slightly less advantageous”, this would outlaw any and all optimizations. […]</font><br>
<font class="QuotedText">&gt;  All optimizations in C rely on absence of UB. All. No exceptions.</font><br>
<p>
Huh? There are plenty of optimizations that work perfectly well precisely *because* they do *not* rely on any UB. In fact, the desire to do whatever real hardware would do with the C code even in the presence of UBs (like aliased pointers that can modify literally anything, including CPU registers in some architectures) is a main blocker of optimizations. Or rather, it was a blocker – before the C people decided to grab that desire by the neck and throw it under a bus, regardless of the collateral damage.<br>
<p>
The example program you cite is a case in point. It&#x27;s buggy trash; calling it &quot;intact&quot; is an insult to any and all less-broken programs. Please use an example that at least has some chance of doing what you think it should be doing.<br>
<p>
<font class="QuotedText">&gt; you have to do insane amount of work.</font><br>
<p>
Yeah, so? It&#x27;s been done, most recently by writing a Rust compiler instead, you can do it again. That&#x27;s not the problem.<br>
<p>
<font class="QuotedText">&gt; You need to, basically, invent completely new language.</font><br>
<p>
Exactly. But the reason for that isn&#x27;t that UB-free C code can&#x27;t be optimized. The reason is that a C compiler can&#x27;t know whether any piece of code is in fact UB-free. The language simply doesn&#x27;t have the features required to convey the necessary information.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862523/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 15:17 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862526/">Link</a>] (51 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Please use an example that at least has some chance of doing what you think it should be doing.</font>

<p>Hmm. How about <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVAB9LclIj2yAnjqVMtdAGFUrAK4BbWiACsj0qfQAZPLUwA5OwCNMYhAANlIAB1QhQiNaSxt7JxdI6MM6T28/W0DgsL1MA1iGAmZiAni7B2ddTH002mLSggzfAKDQ3RKyisTqoS7mr1bs9pCASl1Ua2JkDikAUgAmAGYvZBssAGp55fN%2B/FQAOgQd7HmZAEFzi68CTdtmLwgx7YB2ACFrzc20Wn7N26bAgIPBCDSgjQALyCqG2ywAIpsZDtPpdvgAqCC3dFjCBLELAiEQ6HEVAvHaI7iLFFfTbhYi3Kh4xaLADqCFhQke6CBIKEAP5JNQIG2i0c6HmjnMtCWi1IvKJYKFYxpaM2xEwBGmtCRqqur3hUgmrGkjnkDlk8mFUnMmyEUxmmFFy048gI0jkYwmAGsQMtlod/UHgyGwiapNx5LYuDIZKQLXJSNb5EIQHH3ZaJnBYDBEChULZwnh2GQKBA0IXi%2B1kMBODI5VRiwQgqmIP4PfJ/F5SgBPaSu0gV2ymAgAeVorD7ltIWAe6nYHZneA1hQAbphU9PMOICtZm4vbrVF6w8P5iL3LFhFwQGdGpK6JvxGCwFzw%2BHQCMIxJJp0pOCo1E0bQVFPVNIAmVBwnqTcU1qAp6hMMwegcf83BaLIcmUFIYjoZCsKiHDaHQtpgn/fJCjoRpuisSplHI%2BoqMGTISLogY8LIgZiJGUiJntaZZi4Y1TXNRdrXEAAOEIAFoQm4TZgGQZBNjrQ5Fk2CBcEIEhnX/TZLErEsdJecw3Q7L1SAQTBmCwYJnlIX1/UDENnP9MNpEjUho0cOMEytaQUzTUgM09UhszzCsixLchKAiqtghrOsGybFtKHbacu1oXt%2B3kIcR3HSdF1nQCF2nfAV0MddN0Tbdd33adD3DRMTzPC8MDmRMbzwO8H3fegmDYDg3yfL8JEXJQ5VUdQQC0DQdGasC7Mg6DpCk0dFlgupYkQiwaMSVCzC4zD/2w%2Bp2IiAj6kO9oyLgiiGjY3aUJqTbKM4oYMOuzomjO/omiunjJn4wahKkM141E6QJOk2T5MU5SZFU9TNKIYgdPlfTIqCZ1FmM0zMwmSzrPaOzww8ryfIhqQAvTMyfT9AMXJctypGWETp2TIKzNC3MwogJApgIcI92i8sC0x0jXHwFHlCffrX14YaRFG6cAHdz3CbKQbB3yk2kUc9yFu5UCoTYoZkuSFKUlS1IgDG4qMvHPTpxzGeclR3KjJwKfZ/zdEC4KjW5%2BA%2BZAAXDZF2KSxAOVMClkgZY/OXBoVj8Rp/RM1eYDX70D8Ntcp/XBb3TZjdNyTzdhq2EZtu3DKWZYccdo0CasmzKBBsmvfBn2qb9mn8fs%2BmnNdoN3ZZtnEw5gPzPDdbPJjb3J996eJnXYhomMbggA%3D%3D%3D">something like this</a>:

<pre>
#include &lt;stdio.h&gt;

int main() {
  const int this_is_zero = 0;
  *(int*)(&amp;this_is_zero) = 42;
  printf("Who said this is zero: %d\n", this_is_zero);
  return 0;
}
</pre>

<p>Better?</p>

<font class="QuotedText">&gt; It's buggy trash; calling it "intact" is an insult to any and all less-broken programs.</font>

<p>Yet without proper guadance about what kind of “trash” you have to accept and execute correctly and what kind of “trash” you are allowed to turn into pile of goo you have to handle it. Somehow.</p>

<p>Both program are 100% syntactically correct, both work quite reliably on many platforms and many compilers (with optimizations disabled). Why do you can them “trash”? Just because you dislike them? Well, compiler developers dislike programs which rely on integer overflow, so what's the difference?</p>

<font class="QuotedText">&gt; It's been done, most recently by writing a Rust compiler instead.</font>

<p>Except Rust compiler wouldn't even accept such program thus there are no need to think about what would it do when executed. But yeah, it can be done, sure.</p>

<font class="QuotedText">&gt; you can do it again.</font>

<p>True. And then you would have <b>another</b> Rust-like language. Because if we are starting splitting the hairs and starting to put some valid programs into “this is trash, we don't plan to support that” bucket then why not change the rules and turn them just a compile-time errors instead?</p>

<p>When C was developed… then answer was obvious: “computers are slow and limited, they don't have resources to deal with that”. But what excuse would you have to do that <b>today</b>?</p>

<font class="QuotedText">&gt; But the reason for that isn't that UB-free C code can't be optimized.</font>

<p>Of course not! UB-free C <b>can</b> be optimized! It's C code which <b>triggers</b> some UB where sh$t hits the fan. Please read what you argue against, please! Optimizations rely not on UB but on the <b>absence</b> of UB!</p>

<font class="QuotedText">&gt; The language simply doesn't have the features required to convey the necessary information.</font>

<p>Precisely and exactly my point. In practice anyone who tries to invent that hypothetical <code>-std=safe11</code> language end up adding such features to C and the end result becomes <code>C#</code> or <code>Go</code>, or <code>Rust</code>.</p>

<p>What you <b>don't get</b> out of these attempts are <code>-std=safe11</code>. Precisely and exactly because it's “too little gain for too much effort”.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862957"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 13:11 UTC (Thu)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/862957/">Link</a>] (50 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Both program are 100% syntactically correct, both work quite reliably on many platforms and many compilers (with optimizations disabled). Why do you can them “trash”?</font><br>
Because you&#x27;re writing to a memory location that you previously declared to be const. Why would you expect sane results when you do things that are so obviously not sane? And in fact this code requires a cast, which is a pretty clear signal by the compiler that you&#x27;re doing something fishy. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862957/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 14:37 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863005/">Link</a>] (27 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Because you're writing to a memory location that you previously declared to be const.</font>

<p>But I “know” it's on stack and stack is not const!</p>

<font class="QuotedText">&gt; Why would you expect sane results when you do things that are so obviously not sane?</font>

<p>Because to me they look “sane”. The exact same way I “know” that if you overflow <code>int</code> it becomes negative I know also that there are no const objects on stack (at least on most OSes).</p>

<p>Why one thing would be supported, while other wouldn't be?</p>

<font class="QuotedText">&gt; And in fact this code requires a cast, which is a pretty clear signal by the compiler that you're doing something fishy.</font>

<p>Well… in C you couldn't eve call <code>qsort</code> without casts, but if you want to try to optimize something without casts… <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:2,endLineNumber:16,positionColumn:2,positionLineNumber:16,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:'%23include+%3Cstdio.h%3E%0A%0Aint+foo()+%7B%0A++int+i%3B%0A++i+%3D+42%3B%0A%7D%0A%0Aint+bar()+%7B%0A++int+i%3B%0A++return+i%3B%0A%7D%0A%0Aint+main()+%7B%0A++foo()%3B%0A++printf(%22%25d%5Cn%22,+bar())%3B%0A%7D'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:33.333333333333336,l:'4',m:100,n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:cg102,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'0',trim:'1'),fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'-O0+-Wno-return-type',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x86-64+gcc+10.2+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),k:33.333333333333336,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'Output+of+x86-64+gcc+10.2+(Compiler+%231)',t:'0')),k:33.33333333333333,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',m:100,n:'0',o:'',t:'0')),version:4">here we go</a>:

<pre>
#include &lt;stdio.h&gt;

int foo() {
  int i;
  i = 42;
}

int bar() {
  int i;
  return i;
}

int main() {
  foo();
  printf("%d\n", bar());
}
</pre>

<p>As you wanted: no casts, no <code>const</code>. Am I safe now?</p>

<p>And yes, I know, there are UB, too. But that's exactly the point: you can't optimize <b>anything</b> in C unless you would declare some subset of syntactically correct C “improper and not allowed”. And <b>that</b> is where all attempts to imagine <code>-std=safe11</code> <a href="https://blog.regehr.org/archives/1287">fail</a>.</p>

<p>The problem is: there are no C or C++ “community”. Just lots of people who don't really talk to each other. Even here: you don't even <b>try</b> to understand the point which these program illustrating. Instead you are attacking me as if I'm proposing to write code like that. Thus, as I have said: there would be no <code>-std=safe11</code>. Ever. Deal with it.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863036"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 16:38 UTC (Thu)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863036/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But I “know” it&#x27;s on stack and stack is not const!</font><br>
<p>
const isn&#x27;t only there to set the relevant pages read-only, it also allows things like constant folding. So I think it&#x27;s reasonable to make it UB when you try to write to a location that is marked const, whether or not it is static.<br>
<p>
<font class="QuotedText">&gt; Because to me they look “sane”.</font><br>
Well, your example doesn&#x27;t look sane to me 🤷🏻‍♂️<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863036/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 16:48 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863042/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Well, your example doesn't look sane to me 🤷🏻‍♂️</font>

<p>And that's how we end up with bazillion incompatible “friendly C” proposals <a href="https://blog.regehr.org/archives/1287">which would never be implemented</a>.</p>

<p>Because none of them would even reach “written spec” stage… and you need it before an actual implementation stage.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor863138"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 9:21 UTC (Fri)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/863138/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><em>As you wanted: no casts, no const. Am I safe now?</em></blockquote>
<p>
That example may have no casts or <tt>const</tt> but it is still really crummy C code. I'm not sure exactly what this is supposed to illustrate, let alone prove.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863138/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863154"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 12:39 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863154/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; That example may have no casts or <code>const</code> but it is still really crummy C code.</font>

<p>But it's syntactically valid and works on most C compilers with optimizations disabled, isn't it?</p>

<font class="QuotedText">&gt; I'm not sure exactly what this is supposed to illustrate, let alone prove.</font>

<p>The point was: that hypothetical proposed <code>-std=safe11</code> or <code>-std=friendly-c</code> C dialect is impossible to create without creating <b>another</b> full-blown language spec.</p>

<p>You couldn't just say <i>anything syntactically valid and working in <code>-O0</code> mode should work</i>. Because <b>that</b> would mean you have to, somehow, correctly compile also an atrocities I have shown.</p>

<p>And if you start creating spec… and trying to keep it sane… you end up, eventually with a spec for D, C# or Rust… not with a spec for a “friendly C”</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863154/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 16:12 UTC (Fri)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863205/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But it&#x27;s syntactically valid and works on most C compilers with optimizations disabled, isn&#x27;t it?</font><br>
I don&#x27;t think it does. What if a signal or interrupt is delivered after the call to foo()? It would invoke a signal handler which is probably going to clobber the memory where foo&#x27;s stack frame used to be. <br>
<p>
<font class="QuotedText">&gt; The point was: that hypothetical proposed -std=safe11 or -std=friendly-c C dialect is impossible to create without creating another full-blown language spec.</font><br>
That may or may not be true, but either way, your example doesn&#x27;t demonstrate that. Every compiler these days has warnings to prevent that sort of thing.<br>
<p>
Oh, and coming back to your previous example: <br>
<font class="QuotedText">&gt; const int this_is_zero = 0;</font><br>
<font class="QuotedText">&gt; But I “know” it&#x27;s on stack and stack is not const!</font><br>
Why would the compiler allocate this on the stack? It&#x27;s not using any local variables or function parameters, so it might as well allocate it statically on a read-only page.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 18:08 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863219/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; What if a signal or interrupt is delivered after the call to foo()?</font>

<p>There's <code>sigaltstack</code> for that. Or, if that's MS-DOS, <code>cli</code> and <code>sti</code>.</p>

<font class="QuotedText">&gt; Every compiler these days has warnings to prevent that sort of thing.</font>

<p>Well… the fact that it's a warning says that it's dangerous, but supported thing, isn't it? And I can change the code to make sure <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:5,endLineNumber:3,positionColumn:5,positionLineNumber:3,selectionStartColumn:5,selectionStartLineNumber:3,startColumn:5,startLineNumber:3),source:'%23include+%3Cstdio.h%3E%0A%0Avoid+foo(int*+i)+%7B%0A++i%5B1%5D+%3D+42%3B%0A%7D%0A%0Aint+bar()+%7B%0A++int+i+%3D+0,+j+%3D+0%3B%0A++foo(%26i)%3B%0A++return+j%3B%0A%7D%0A%0Aint+main()+%7B%0A++printf(%22%25d%5Cn%22,+bar())%3B%0A%7D'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:33.333333333333336,l:'4',m:100,n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:cg102,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'0',trim:'1'),fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'-O0+-Wall+-Wextra',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x86-64+gcc+10.2+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),k:33.333333333333336,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'Output+of+x86-64+gcc+10.2+(Compiler+%231)',t:'0')),k:33.33333333333333,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',m:100,n:'0',o:'',t:'0')),version:4">there are no warnings</a>:

<pre>
void foo(int* i) {
  i[1] = 42;
}

int bar() {
  int i = 0, j = 0;
  foo(&amp;i);
  return j;
}

int main() {
  printf("%d\n", bar());
}
</pre>

<p>Better now?</p>

<font class="QuotedText">&gt; Why would the compiler allocate this on the stack?</font>

<p>You mean: without explicit <code>auto</code>? I think even <code>C89</code> had implicit <code>auto</code>. I can add explicit <code>auto</code>, if you want. Compiler <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVAB9LclIj2yAnjqVMtdAGFUrAK4BbWlwCcpU%2BgAyeWpgBydgEaYxCAAzKQADqhChEa0ljb2TuGR0XQeXr62AUGhepgGMQwEzMQEcXYOnM65%2BXSFxQRpPv6BIbpFJWUJlW31jRlZIQCUuqjWxMgcUp4EANS2zJ4QgzMApADsAEIrMgCCMzNotEKz0zN4q8EAIjMyK8Fbu/sAVBDTT4MQKwBMAGx4y3drtwvncHnsZsRMAQxrQzqDtjt1pcpMNWNIAKzyByyeSoaTmGZCUbjTCrL7BTjyAjSOSDYYAaxCwQAdME2eyORyfippNx5LYuDIZKRsXJSHipPIhCBhdSccM4LAYIgUKhbGE8OwyBQIGh1ZqWshgJwTXxNQRAtKIH4afI/J5igBPaSU0h62ymAgAeVorGdONIWHm6nYtsDeEh%2BQAbphpQHMOI8tYLWHppg0QHWHg/MQnZYsGGCMQ8AKpJThvxGCxQzw%2BHQCMIxJIA0pOCo1JptCps9LIMNUGFDHQ4wBaL1i6pDhwQVydCouMx9ZpBNsRKJTufKNcpWhLzItNuTgrtUpWcrKI%2B1E97gaHk%2Bbu%2B9TxNfcr4ZEsYTLiojFYsMS8QAA4fhHH5uBmYBkGQGYTWZTgZggXBCBIMkKVIGZLH1LVUM4ZZzCpW06VIBBMGYLAgiWUhGTZVlOTotluQzPlSAFdFhVFXFpClGVSDlWlSEVFU9Q1LVyEoYSDSCKDVHUTgviFM1WAtYgrRtAN7VoJ0XXkd1PR9P0wyDDtQwDfBI0MGM4zFBMkxTAM0wzMUsxzPMMEmMUixLbSK3rJg2A4WtK0bCQwyUL523UEAtA0HRnN7SiBynUdxyldM8inEwzAfBd3GffoDySdcYmy7cpxvArL1oOoOjPLpdDSmoquvPLlwve9avnY4n3SVrcJGT8Ap/KRMRFf9pCAkCwIOGTgBgr5mRkBaEKQohiBw9DMJEwJUK%2BPCCPlYYSLIlpKKY/kQDY0aAwlbjZUIhkmVo%2BjOUY6Rgj/a6uN4wiBOVQSICQUYCDCZMxN1NUtpXFx8FW5RKz8mteCCkQQoDAB3XMwm8nlho%2BsUJS9ZMQdmVAqBmCbQPAyDoNg%2BCIE2yScMGfbaQemjnronHmNY9ixslXQeL4lFfvgAGQCB4mwYkrUQHCzAYZIOHfOrAKkfrYLmzFDHmCxsthYzEaOPFaRCeB5MZlJ8ngMp6aOzmhalvpiHGe%2BYJdpZlFDtI8jKCG7mLt5z7%2BelO6Dqox6Oc5HH3qu/GvqFoiMy%2Bc7OAUo2bu%2BsOYxUmIQG4IA%3D">still misbehaves</a>.</p>

<p>The really funny thing: just a tiny modification of that code <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVAB9LclIj2yAnjqVMtdAGFUrAK4BbWlwCcpU%2BgAyeWpgBydgEaYxCAATKQADqhChEa0ljb2TuGR0XQeXr62AUGhepgGMQwEzMQEcXYOnM65%2BXSFxQRpPv6BIbpFJWUJlW31jRlZIQCUuqjWxMgcUp4EANS2zJ4QgzMApADsAEIrMgCCMzPM1kQzaLRCs9MzYSsArFs3ACKrAMxP6xsypDOf318y6w8Vs8trt9gAqCDTMGDCBhZZAp7cYJAkF7GbETAEMa0K63D63QHA7Y7AFSYasaQ3eQOWTyVDScwzISjcaYVbBZ6ceQEaRyQbDADWIGezwAdCKJZKpQA2FTSbjyWxcGSfGlyUj0qTyIQgT482nDOCwGCIFCoWxhPDsMgUCBoC1WlrIYCcV18K0EQI6iB%2BXnyPyeYoAT2kXNI9tspgIAHlaKwQ7TSFh5up2H6k3gMfkAG6YHWJzDiPJHSbq6aYCmJ1h4PzEYOWLDpgjEPBKqRc4b8RgsNM8Ph0AjCMSSRNKTgqNSabQqGs6yDDVBhQx0fMAWmjz21Fbyy4cEFcnQqLjMfWaQXHESiu8PykvKVop8yLXH1V3dQ6VnKylfBXaDU8TRPuePQfvER7nL0AH9M%2BwzMmMExcOSlLUummriAAHNKq7StwMzAMgyAzK6oqcDMEC4IQJDspyXyWA61rUZwyzmNyfr8qQCCYMwWBBEspBCiK4pSsJIqypWCqkEqNyqqh0jarqpD6nypBGqa9qWta5CUOpjpBARqjqJwwQqu6rCesQ3q%2BomAa0MGobyBGUaxvG6bJpOaaJvgWaGLm%2BbqoWxaeum5aVuq1a1vWGCltyLZth2/b0EwbAcH2XZDhI6ZKKEBlThoOjhXOfGLrua4blu%2Bi7iYZg3uOriPgMF7JNen5dEkV4xPVz66NuNS0O%2BpQteBPVvn%2BnXARBoFfi%2Bo1QWeiEjPBKVIVIVKkGqdLSBhWE4ScOVEcEooyIdZEUUQxCMbR5oaYE1HBMxrEGsMnHcS0fHiYqIDSWtslaroClKWSgrCmKIkiWJ0ibt9iaag9ymqfDSCjAQYRHFpdpXbpyiYPgZ3KF2SW9rwaUiBliYAO51mE9nLat60atI0ZHCjsyoFQMxbdhuH4YRxGkRAdHXedKwckxsOA/xwNCaDkpylIElSTJ0NyX9epsSpJoQIjTOo7aOnWq02OUcB%2BM9ilRMDulI7qhTzBU%2B2ZKy7TP2M8jRwzKz7OYZzu2Tvth3HfzGMMcLzx3WL7HPTxlDLfLn2K%2BqMMq4pbFA4J0tSrLkN04nAPsZWwQfZwJnZ8rufDLmFkxCA3BAA%3D%3D%3D">makes it compileable with -O2</a>, too.</p>

<p>Thus modern compilers don't <b>really</b> propagate all “undefined behaviors” blindly. No, they are more-or-less testing C and C++ developers patience.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 23:42 UTC (Fri)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863240/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>There's sigaltstack for that. Or, if that's MS-DOS, cli and sti.</blockquote>
Interesting, I didn't know about that. Anyway, it's a platform-dependent mechanism which isn't guaranteed to be available, and even on Linux it's only used when SA_ONSTACK is used. So I still believe it's reasonable to make that undefined.

<blockquote>Well… the fact that it's a warning says that it's dangerous, but supported thing, isn't it?</blockquote>
That's up to you. If you want, make it -Werror=uninitialized instead. 

<blockquote>Better now?</blockquote>
I don't consider it reasonable to make assumptions about how the compiler lays out the memory for local variables.

That said, I'll grant you that reasonable people can differ about something like this:
<pre>
void foo(int *i, int o) {
        i[o] = 42;
}
int bar() {
        int i = 0, j = 0;
        foo(&amp;i, &amp;j - &amp;i);
        return j;
}
int main() {
        printf("%d\n", bar());
}
</pre>
But I'm not enough of a compiler expert to be able to assess what the performance impact would be if this were allowed. I suspect it would be severe. 



      
          <div class="CommentReplyButton">
            <form action="/Articles/863240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 0:11 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863244/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Anyway, it's a platform-dependent mechanism which isn't guaranteed to be available</font>

<p>Seriously? POSIX <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaltstack.html">guarantees it's availability</a>, Windows doesn't need (it doesn't support signals), MS-DOS &amp; embedded are handled with <code>cli</code>/<code>sli</code> (and analogues)… so what kind of 
“important platform” is in the problem?</p>

<font class="QuotedText">&gt; So I still believe it's reasonable to make that undefined.</font>

<p>Maybe, but that's the thing: it works on almost everything. Thus simple rule “things are disallowed if they couldn't ever work” doesn't cover it.</p>

<font class="QuotedText">&gt; That's up to you. If you want, make it -Werror=uninitialized instead.</font>

<p>Maybe, but safer option would be to switch to something that doesn't change it's rules every year.</p>

<font class="QuotedText">&gt; But I'm not enough of a compiler expert to be able to assess what the performance impact would be if this were allowed. I suspect it would be severe.</font>

<p>Most likely. This would break almost all optimizations based on these “noalias” rules which power <b>a lot of</b> optimizations.</p>

<p>But the story here is: what's the point of something being <b>speedy</b> if said something is no longer <b>correct</b>?</p>

<p>If there were some kind of dialogue between C/C++ compiler developers and users of said compilers then maybe they would have come to an agreement. But there are none.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/863244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 13:26 UTC (Sat)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863248/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Seriously? POSIX guarantees it&#x27;s availability, Windows doesn&#x27;t need (it doesn&#x27;t support signals), MS-DOS &amp; embedded are handled with cli/sli (and analogues)… so what kind of “important platform” is in the problem?</font><br>
As I already mentioned, sigaltstack is only used if you specify SA_ONSTACK. Or that is how I understand the documentation, anyway.<br>
<p>
<font class="QuotedText">&gt; Maybe, but safer option would be to switch to something that doesn&#x27;t change it&#x27;s rules every year.</font><br>
Sure, most software shouldn&#x27;t be written in C or C++. <br>
<p>
<font class="QuotedText">&gt; But the story here is: what&#x27;s the point of something being speedy if said something is no longer correct?</font><br>
Well, nobody said writing high performance software was going to be easy. But there are legitimate use cases where you really do want to squeeze every last cycle out of the hardware. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 13:49 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863267/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; As I already mentioned, sigaltstack is only used if you specify SA_ONSTACK.</font>

<p>Please read the documentation again. You can not ever set <code>SA_ONSTACK</code>. It's not something you set, but something you can <b>read</b>: <code>sigaltstack</code> couldn't change state of altstack if you are in the middle of a signal handler and said altstack is currently in use!</p>

<font class="QuotedText">&gt; But there are legitimate use cases where you really do want to squeeze every last cycle out of the hardware.</font>

<p>But C and C++ are making it harder and harder each year! Because time which is spent making pointless changes which would keep tested and debugging programs working could have been spent on the changes which would make these programs faster instead.</p>

<p>And in <b>wast</b> majority of cases you can get more speedup from doing that. Where new version of compiler can buy you 3% or maybe 5% (if you are lucky) manual tuning can often bring 2x, 3x or even 10x improvements.</p>

<p>And the more artificial constructs you add to your program the slower it becomes.</p>

<p>No wonder that developers of embedded systems where efficiency would be obviously desired typically stick to one version of the compiler (which is not upgraded ever) or, sometimes, even use <code>-O0</code> to free time for manual optimizations.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/863267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863269"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 14:51 UTC (Sat)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/863269/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; No wonder that developers of embedded systems where efficiency would be obviously desired typically stick to one version of the compiler (which is not upgraded ever) or, sometimes, even use -O0 to free time for manual optimizations.</font><br>
<p>
Based on a majority of the embedded code I&#x27;ve seen, the actual reason is that most embedded software developers are bad software developers. You&#x27;re lucky if they&#x27;ll write code that isn&#x27;t full of obvious buffer overflows, race conditions, etc, and there&#x27;s almost no chance they&#x27;ll appreciate concepts like aliasing or memory barriers. That&#x27;s why it&#x27;s no surprise their &#x27;tested and debugged&#x27; code breaks when they turn on new optimisations - it was only working in the first place by luck and by the very limited extent of their testing. And even when projects are run by competent software developers, they&#x27;ll probably have to import some third-party libraries (chip SDKs, drivers, etc) which are badly written and/or are precompiled binaries from an ancient compiler version, so they face the same problems.<br>
<p>
(To be fair these embedded software developers may have a much better understanding of hardware than the average software developer, which is crucial for doing their job; but they&#x27;re still bad at software.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863269/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor863283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 21:08 UTC (Sat)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/863283/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><em>But it's syntactically valid and works on most C compilers with optimizations disabled, isn't it?</em></blockquote>
<p>
What do you mean “works”? Prints “42”? Only by happenstance. That's not something I would rely on, ever. As I said, it's really crummy C code, and it doesn't prove anything.
</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/863283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 21:59 UTC (Sat)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863285/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The original SimCity game had a use-after-free bug, but it happened to work fine on DOS. It broke on Windows, so Microsoft added code to detect if SimCity is running. If that was found to be the case, it would run the allocator in a special mode that allowed use-after-free.<br>
<p>
Given some of khim&#x27;s other comments, this is the kind of thing he seems to expect platform developers to do when dealing with broken code. Except of course he&#x27;s going to say that said code is not broken because, after all, it has been working for decades, and the problem is clearly you and your toxic attitude.<br>
<p>
Well, I have a different opinion. If your code is broken, LLVM (or GCC) developers are under no obligation to accommodate that. The fact that they still do in some ways (with options like -fwrapv or -fno-strict-aliasing) is them being nice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863290"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 23:44 UTC (Sat)
                               by <b>Vipketsh</b> (guest, #134480)
                              [<a href="/Articles/863290/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; is them being nice.</font><br>
<p>
I have to wonder .. do you consider the Linux policy of not breaking user space, even buggy ones, them being overly nice ?<br>
<p>
Clearly no one would accept Linux changing the semantics of read() every release and substantiate that with &quot;we never agreed to be posix compliant&quot;.  This is what user&#x27;s of compilers feel is happening to them (please read below).  It&#x27;s easy to brush off complaints when you are screwing over others, but it&#x27;s seriously not great when others are screwing you.<br>
<p>
I agree that the examples given are not spectacular in that for most of them I don&#x27;t think one can expect any explicit well defined result.  However, I think that there are still reasonable expectations for things the compiler will not do (e.g. start operating on non-rings).<br>
<p>
Reality and de-facto standards are also important.  For decades compilers compiled code with the semantics of wrapping 2&#x27;s complement signed arithmetic thereby creating an implicit agreement that that&#x27;s how signed integers work.  Compiler writers then unilaterally broke the agreement without much warning.<br>
<p>
In some ways I can understand that only a few people will ever fully comprehend all the fine print in a standard and sometimes user&#x27;s have the wrong idea and things break.  The issue here is that these breakages occur all too frequently and when they do the argument isn&#x27;t an explanation about how the new behaviour makes sense or issues about what the old behaviour had it&#x27;s just bluntly &quot;some paper with black splodges says we can&quot;.<br>
<p>
The situation isn&#x27;t helped by the fact that many of these surprising issues occur because the compiler is explicitly special casing something (looking for realloc(), null pointer checks, etc.).  Clearly someone put in the effort to look for these things and then make deductions based on them.  Presumably there is a reason why all this effort was made but that reason never seems to be given.  There is some understanding that the reason is probably some performance improvement in which case I think it is reasonable to expect compiler authors to be able to point to a commit log or discussion where the numbers were passed around, but it never happens.<br>
<p>
In the end what users believe is that the compiler is miss-compiling their valid code and after some long &amp; painstaking debugging the other party just tells them to get lost.  You see why people get upset ?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863290/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 1:25 UTC (Sun)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863295/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However, I think that there are still reasonable expectations for things the compiler will not do (e.g. start operating on non-rings).</font><br>
Let&#x27;s say you do an out-of-bounds write somewhere in your program. There&#x27;s a chance that it might overwrite the piece of machine code that was generated from the &quot;return be || !be&quot; statement, and it might replace it with &quot;return 0&quot; (I&#x27;m aware of W^X etc, but not all platforms support that). There&#x27;s no way the compiler can be expected to guard against that. I think a reasonable debate can be had about what exactly should trigger undefined behaviour, and it seems to me that compiler authors agree, as evidenced by the fact that they offer flags like -fwrapv. But I don&#x27;t think it&#x27;s reasonable to expect compilers to make any guarantees about what happens after UB has been invoked, not even for the be || !be example.<br>
<p>
<font class="QuotedText">&gt; Reality and de-facto standards are also important. For decades compilers compiled code with the semantics of wrapping 2&#x27;s complement signed arithmetic thereby creating an implicit agreement that that&#x27;s how signed integers work.</font><br>
Again, SimCity was working fine for many years, despite having use-after-free bugs. Does that mean there&#x27;s an &quot;implicit agreement&quot; that that&#x27;s how free should “work”?<br>
I think the standard should be that a behaviour should be preserved (at least optionally) if it has been around for a long time and a reasonable person might have specified it in some form of documentation. Reasonable people might have written a C standard where two&#x27;s complement representation is specified for signed integer types. But no reasonable person would write a specification for free that says you can still use the data you just freed, because that just doesn&#x27;t make sense. Now of course people have different ideas about what reasonable people would or wouldn&#x27;t do, but my point is that “this has been working for years, so it must continue to work” just isn&#x27;t sufficient by itself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 8:14 UTC (Sun)
                               by <b>Vipketsh</b> (guest, #134480)
                              [<a href="/Articles/863311/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There&#x27;s a chance that it might overwrite ...</font><br>
<p>
So, I think this is a key point to understand about C.  In C you can and want to have pointers going to any arbitrary piece of memory (e.g. for I/O access) and as you say no standard can hope to define what happens when some data structure, or in more extreme cases, code is arbitrarily overwritten.  The reasonable thing to do when analysing C code is to assume such things don&#x27;t happen, and not to go out of your way to find such cases and generate garbage.<br>
<p>
<font class="QuotedText">&gt; There&#x27;s no way the compiler can be expected to guard against that.</font><br>
<p>
Sure, it&#x27;s unreasonable to expect the compiler to guarantee that your pointers don&#x27;t overwrite something you didn&#x27;t expect.  It&#x27;s a completely different matter when the compiler goes out of its way to look for these things and then generating complete garbage, not because it&#x27;s sane for some surprising reason, but because &quot;it&#x27;s allowed&quot;.<br>
<p>
Let&#x27;s also not forget that in the original example of (be || !be)=false there was no random overwriting of anything.  It was reading an un-initialised variable, which is a little easier to reason about -- there is no explicit value one can expect when reading un-initialised variables, at the same time it is also reasonable to expect that the value that one gets does not fall outside of the set of allowed values for that type.<br>
<p>
There is also another piece of to this puzzle: only clang assigns values outside the set of allowed values for the type, gcc assigns 0.  Yet gcc&#x27;s performance on the all-important SPEC benchmarks is not lagging miles behind clang so it&#x27;s clearly not an all important optimisation. So the yet-unanswered question is raised of what advantage does clang&#x27;s behviour have ?  The disadvantages are clear. <br>
<p>
<font class="QuotedText">&gt; there&#x27;s an &quot;implicit agreement&quot; that that&#x27;s how free should “work”?</font><br>
<p>
In some ways, yes, I do think there is implicit agreement here.  I also think that user-after-free is not a good example because just like defining what overwriting arbitrary pieces of memory will result in is impossible, so is use-after-free.  Still, I think the compiler should not go out of its way to detect use-after-free type situations and then generate garbage in responce.<br>
<p>
A different but similar example perhaps would be the case of &quot;The sims&quot;, which was known to write past allocated memory areas.  It happened to work on Windows 9x.  In later versions of windows they changed the allocator and put some internal data structures in those locations resulting in the game not working anymore.  In the end Microsoft changed the allocator behaviour such that if you asked for X bytes you got X+Y bytes.  Not logical behaviour when looking an allocator but well defined.  For me, such changes are a reasonable price to pay for compatibility.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 11:34 UTC (Sun)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/863319/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The disadvantages are clear.</font><br>
<p>
Out of curiousity, what are these clear disadvantages? If be is undefined, then (be || !be) is also undefined. This is &quot;garbage in, garbage out&quot; at work here. You can&#x27;t create information out of nothing. It&#x27;s madness to start reasoning about this before fixing the underlying problem first, i.e. make sure the variable has a value before using it.<br>
<p>
On the contrary, I would say the compiler did you a favour by giving a hint in the form of an unexpected result. A hint telling you that there is something wrong with the code. Of course it would have been more helpful if the compiler had printed the real error, that the variable is uninitialised. Which is what compilers usually do nowadays, when they are able to detect the it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 12:43 UTC (Sun)
                               by <b>Vipketsh</b> (guest, #134480)
                              [<a href="/Articles/863322/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; what are these clear disadvantages?</font><br>
<p>
It breaks the foundations of the arithmetic all users expect.<br>
<p>
My experience with Verilog, that has a number system that is not a ring opposed to (almost) all software, tells me that the number one thing people expect is ring-like behaviour, more so than operating on an infinite set.  You can argue that all people are mentally completely deficient when they expect that if they have INT_MAX apples, acquire an additional two and finally eat two of them there are going to be INT_MAX left instead of &quot;poison&quot; number of apples, but perhaps it would be easier to just apply the models that work in the real world and have done so for more than a century ?<br>
<p>
<font class="QuotedText">&gt; You can&#x27;t create information out of nothing.</font><br>
<p>
Pretty much the entirety of mathematics is about &quot;creating information out of nothing&quot; and that&#x27;s the beauty of it.  Guess what ?  In the given case, the maths says that (be || !be) is true.  Not undefined or &quot;poison&quot;, but true.  In all cases.  No exceptions.<br>
<p>
You could argue that this isn&#x27;t a normal system but &quot;LLVM special&quot;.  It&#x27;s a valid argument, but you can&#x27;t have it both ways and keep sane results like LLVM tries in vain: it uses a non-ring but then applies transformations that are valid only on a ring.<br>
<p>
<font class="QuotedText">&gt; On the contrary, I would say the compiler did you a favour by giving a hint in the form of an unexpected result.</font><br>
<p>
What an overly kind compiler that is.  What&#x27;s next ?  I should be donating them a kidney because they were oh-so-kind to insert an arbitrary write in my code, corrupting memory as a way of &quot;warning me of an unexpected result&quot; ?<br>
<p>
It&#x27;s incredibly difficult to figure out what happened when the compiler is doing everything right, and your code is clearly at fault (think: memory corruption).  Suggesting that the compiler introducing random behaviour &quot;is helping the user&quot; is preposterous.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863323"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 13:24 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/863323/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m OK with the ring argument to an extent, but I don&#x27;t think one can actually apply it to the C Abstract Machine. My main question is: how far do we go down this road? I understand that `be || !be` is &quot;trivial&quot;, but is `i &lt; 2 || is_prime(i) || is_composite(i)` supposed to be something the compiler can reason about? If not, why not? After all, every value in the domain for integer types in C is fine here. To go even further, one could have `i &lt; 2 || is_odd(i) || goldbach_conjecture_holds(i)`. While not known for *all* numbers, this is known for up to 2³²-1 at least (64-bit unsigned seems to be a *bit* past the current proof available; 4e18 versus 1.8e19). Where do we draw the line for such &quot;if we treat the types as holding to the rules of a ring, the value is always N, so replace it with such&quot;?<br>
<p>
Of course, this is assuming that `be` and `i` do not change from access to access. However, this is exactly the kind of assumption that is allowed for uninitialized variables. Sure, machines today might have all values in the normal range be the only values supported and they won&#x27;t change willy-nilly, but the Mill has a NAR result; this could certainly be the representation for uninitialized variables in which case C would either need to inject an initialization for you (what rules exist for this?) or do some complicated runtime NAR tracking to handle the cases given above (because the operations will generally result in NAR propagation).<br>
<p>
I think people need to remember that &quot;the hardware&quot; is *not* what C targets. Hasn&#x27;t been for a long time either. The rules of the C Abstract Machine are not beholden to &quot;what currently prevailing hardware does&quot; and nor should it unless it wants to do one of:<br>
<p>
  - make uninitialized variables a compile error (like Rust does) and require source code changes to continue using newer compilers;<br>
  - pessimize future potentials (such as having to inject initialization into every POD variable on the Mill); or<br>
  - declare that hardware today has all of the properties we can expect and enshrine them.<br>
<p>
Of course, C (and C++) have painted themselves into a corner by trying to say:<br>
<p>
  - old code will continue to compile (though not necessarily with the same behaviors :/ ) (this has been broken somewhat by the removal of trigraphs and maybe removing some EBCDIC allowances);<br>
  - we don&#x27;t want to enshrine existing architectures and require future hardware to emulate any decisions made here (e.g., twos complement (yes, C++ has done this, but I don&#x27;t know the status for C), IEEE floating point formats, etc.);<br>
  - ABI compatibility; and<br>
  - as close to &quot;zero cost abstractions as possible&quot;.<br>
<p>
Rust, on the other hand, says &quot;we&#x27;re willing to give up some future opportunities and supporting older platforms at the expense of better available reasoning about the code at compilation time on the hardware that is widely used today&quot;. Sure, if some new floating point format appears, Rust&#x27;s IEEE expectations are going to have to be emulated where that gets used preferentially. But it means that Rust has chosen &quot;working on extant hardware today as well as possible&quot; over &quot;works on ancient stuff, current stuff, and whatever may exist in the future&quot;. Given how much extant language design ends up influencing marketable hardware, I think the former is more useful. But who knows, maybe security will become a big enough problem that capability-based processors will be a thing and Rust will then be in a corner and C able to morph over into defining its behavior on such a machine. It&#x27;s not a bet I would take, but it&#x27;s also a possibility.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863323/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 14:17 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863326/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Sure, machines today might have all values in the normal range be the only values supported</font>

<p>Period. Full stop. End of discussion. If certain behavior is dictated by hardware then compiler shouldn't invent it's own rules which permit it to <s>optimize</s> destroy programs.</p>

<p>Sure, it may invent some additional rules (e.g. Rust <a href="https://rust-lang.github.io/unsafe-code-guidelines/layout/enums.html#discriminant-elision-on-option-like-enums">may use the fact that certain types don't use all bit patters to save some memory</a>) — but then it becomes responsibility of the compiler to maintain these additional rules and it must abort an attempt of the user to violate such rules.</p>

<p>It's idiotic to just assume that user is simultaneously super-advanced and knowledgeable and remembers all these hundreds of UBs defined in standard (and not defined by standard too, as we now know) yet, simultaneously, is dumb enough to write code which would do something wrong — unconditionally.</p>

<font class="QuotedText">&gt; I think people need to remember that "the hardware" is *not* what C targets.</font>

<p>Why not? The only reason compilers exist and are used is to take programs and execute them on hardware. Why make that task unnecessarily complicated?</p>

<font class="QuotedText">&gt; But who knows, maybe security will become a big enough problem that capability-based processors will be a thing and Rust will then be in a corner and C able to morph over into defining its behavior on such a machine.</font>

<p>Dream on. Just don't forget to do a reality check when you would wake up.</p>

<font class="QuotedText">&gt; It's not a bet I would take, but it's also a possibility.</font>

<p>No. There are no such possibility. People are <b>not</b> writing code for “abstract C machine”. They are writing code for the existing hardware and then fight the compiler till it works.</p>

<p>I have talked with a guy who participated in the development of compiler for E2k CPU (which <b>does</b> have capability-based processor… (or, rather, it had in the initial design, not sure if they kept it).</p>

<p>Approximately zero non-trivial C programs can be compiled in strict mode. Because in any non-trial program sooner or later you hit a code which assumes that pointer is just a number. Maybe a weird number (like <code>far</code> pointer in Windows 16bit) but still a number.</p>

<p>Similarly you hit code which assumes than numbers are two's complement and so on. <a href="https://www.hyrumslaw.com/">Hyrum's Law</a> ensures that you couldn't <b>ever</b> transfer non-trivial C  or C++ codebase to a radically new architecture (one of the reasons why all CPUs today are so strikingly similar, BTW).</p>

<p>Safe Rust rules, on the other hand, can happily coexist with capability-driven CPU. And given the fact that Rust developers try to minimize use of unsafe Rust (and it's always clearly marked when used) port of Rust code to the capability-driven CPU is quite feasible.</p>

<p>If we ever would switch to capabilities-driven CPUs then C and C++ wouldn't survive the transition for sure. While Rust might.</p>

<font class="QuotedText">&gt;  To go even further, one could have <code>i &lt; 2 || is_odd(i) || goldbach_conjecture_holds(i)</code></font>

<p>What's the issue with that code? Pick any <b>single</b> value and calculate the answer, if you can.</p>

<font class="QuotedText">&gt; C would either need to inject an initialization for you (what rules exist for this?) or do some complicated runtime NAR tracking to handle the cases given above (because the operations will generally result in NAR propagation).</font>

<p>As long as mental model “uninitialized variable contains whatever garbage which was found there when memory was allocated” holds… people would accept it. Sure, there are programs which would be broken with these optimizations, but it's very hard to find someone who thinks they <b>should</b> work.</p>

<p>Using standard as a guide which includes current state of affairs is fine, too. But when following the standard gives surprising (to the user) result then changes to the standards should be contemplated, too. I remind you, once more, what C committee said <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n897.pdf">explicitly</a>:</p>

<blockquote><i>Undefined behavior gives the implementor license not to catch certain program errors that are difficult to diagnose. It also identifies areas of possible conforming language extension: <b>the implementor may augment the language by providing a definition of the officially undefined behavior</b></i> (emphasis mine).</blockquote>

<p>WTH this recommendation (which would have been widely welcomed by C and C++ developers) was followed so rarely and contradicted so often?</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/863326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor863332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 16:49 UTC (Sun)
                               by <b>Vipketsh</b> (guest, #134480)
                              [<a href="/Articles/863332/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is your argument here that it is unreasonable to expect the compiler to be able to be able to prove properties of expressions and perform optimisations based on those properties ?  If that is indeed your argument I agree with you.  It&#x27;s also the reason why in the &quot;p = realloc(q, ..); if (q == p) ...&quot; example I think it is wrong to argue &quot;but, I checked the pointers are equal&quot; because there are a lot of expressions which can be true if and only if p and q are equal, but it is not reasonable to expect the compiler to see that in all cases.  In that case I think the aliasing rules are just messed up.<br>
<p>
The reason I think the (be || !be)=false result is unreasonable is not because LLVM is unable to prove that it should evaluate to true.  Instead, my problem is because LLVM goes out of its way to use a non-ring to evaluate it and I have no idea what the advantage is in doing that.  If it just didn&#x27;t try to do anything special, perhaps even just emitted the expression as-is in machine instructions, it would arrive at the expected result.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 17:14 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863334/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt;  Instead, my problem is because LLVM goes out of its way to use a non-ring to evaluate it and I have no idea what the advantage is in doing that.</font>

<p>“Dead code elimination”. The idea the same with most “optimizations” which break formerly valid code: programmer is utterly and inescapably deeply schizophrenic entity which:
<ol>
<li>Keeps is mind all hundreds of UBs (even if compiler authors couldn't themselves compile adequate list of them in case of C++) and never, just <b>NEVER</b> violates them.</li>
<li>Produces complete and utter garbage in place of code (probably because his head is taken by aforementioned rules and there are no space for anything else in it) which includes lots of pointless manipulations which process undefined values.</li>
</ol>

<p>If we are dealing with such an entity then using #1 to combat #2 is entirely reasonable.</p>

<p>Unfortunately in real life programmers are exact opposite: they tend not to produce too much garbage yet sometimes create UBs by mistake. Applying these principles to code written by real people turns compiler writers into their adversaries, but that's OK since these users are not the ones who pay salaries to compiler writers, isn't it?</p>





      
          <div class="CommentReplyButton">
            <form action="/Articles/863334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor863365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 8:36 UTC (Mon)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/863365/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think it is wrong to argue &quot;but, I checked the pointers are equal&quot; because there are a lot of expressions which can be true if and only if p and q are equal</font><br>
<p>
That&#x27;s not the problem here, and if it was then the compiler should treat them as potentially aliased.<br>
<p>
Instead, it treats p as both valid (the location it points to can be written to) and invalid (it cannot possibly point at the same location as another pointer) at the same time. That&#x27;s the very antithesis of correctness.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor863325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 13:08 UTC (Sun)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/863325/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I would say the compiler did you a favour by giving a hint in the form of an unexpected result.</font><br>
<p>
The compiler doing me a favour would be if it defaulted to throwing a fatal error (not a warning, a fatal error, your code doesn&#x27;t compile, fix it please) when it is asked to compile code which invokes UB 100% of the time and can be cheaply proven to do so.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 9:56 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/863372/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>This is something I hope future languages steal from Rust (along with Esteban Kuber's great work on high quality error messages): there is no UB in parts of the code not marked out as potentially containing it.
<p>Now, there's a gotcha with this, in that while it's always an <tt>unsafe</tt> block in Rust that actually invokes UB, it's possible for the preconditions for that UB to be set up by Safe Rust (e.g. you set an offset into an array in safe code, but deference it in unsafe code), but you always know where UB could possibly be found in a body of Rust code, and you can use module scoping (privacy) to ensure that UB can't leak - with that done, it's possible to check an entire module that contains an unsafe block, and be confident that your human analysis shows no UB.


      
          <div class="CommentReplyButton">
            <form action="/Articles/863372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor863314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 10:17 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/863314/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Now of course people have different ideas about what reasonable people would or wouldn&#x27;t do, but my point is that “this has been working for years, so it must continue to work” just isn&#x27;t sufficient by itself.</font><br>
<p>
Another story about compilers: it had taken Microsoft more than 5 years to move their C# and C++ compilers onto a new backend. Not because it was so complex, but because they wanted to maintain bug-for-bug compatibility with the old compiler.<br>
<p>
They went to their biggest clients and made sure that huge codebases, like the ones that Adobe has, work perfectly.<br>
<p>
This is another reason why Windows platform is still the main desktop environment.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor863310"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 7:19 UTC (Sun)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/863310/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Well, I have a different opinion. If your code is broken, LLVM (or GCC) developers are under no obligation to accommodate that.</font><br>
<p>
You&#x27;re getting off on a tangent. The code in question is not SimCity and their use-after-free bug.<br>
<p>
The realloc example we&#x27;re talking about is not broken in any way, shape or form. It&#x27;s a valid optimization technique to not update pointers after realloc if you determine that the pointer didn&#x27;t change. LLVM still breaks. There is no freakin&#x27; reason why that can possibly be OK.<br>
<p>
If your nice and shiny pointer provenance rules and optimization break valid code, then, sorry, but at least one of those rules or optimizations is broken.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863310/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor863028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 15:43 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/863028/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why would you expect sane results when you do things that are so obviously not sane?</font><br>
<p>
Then why won&#x27;t the compiler stop me? That is also a sane behavior in the face of such code, but we can&#x27;t have that either apparently.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 15:58 UTC (Thu)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/863031/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Then why won&#x27;t the compiler stop me? That is also a sane behavior in the face of such code, but we can&#x27;t have that either apparently.</font><br>
<p>
But that would cause old code to *gasp* Not Compile. No, we can&#x27;t have that, because fixing this problem requires amending the standard so that programmers can tell the compiler what they mean.<br>
<p>
Apparently, though, the compiler is by definition the all-knowing oracle which, by following The Holy Standard, is able to understand all by itself what a program may or may not mean. Thus actually telling it to behave differently is thus Abject Blasphemy, and amending the standard to afford such horrors would thus be Vile Heresy.<br>
<p>
… or so it seems to me.<br>
<p>
Prove me wrong.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863035"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 16:09 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/863035/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nothing in the C++ (or C) standard stops implementations from warning about all kinds of valid-but-silly nonsense. We have warnings when you shadow variables (perfectly valid C++), implicit `int` to `bool` conversions (also valid, but a &quot;performance concern&quot; to MSVC), and other things. A warning that &quot;I noticed that this can overflow and have therefore assumed it doesn&#x27;t happen and removed it&quot; is perfectly valid. Sure, it isn&#x27;t the compiler *stopping* me, but it is at least letting me know that the grenade I&#x27;ve put into my pocket is missing a pin.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863035/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863090"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 21:22 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863090/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Nothing in the C++ (or C) standard stops implementations from warning about all kinds of valid-but-silly nonsense.</font><br>
<p>
Yet nothing in the standards mandate it. How hard could it be to make them warn about it as part of the spec?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863090/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 0:44 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/863112/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe the line is that doing so would:<br>
<p>
  - inundate projects with oodles of warnings which they&#x27;ll promptly disable anyways; and<br>
  - compilers would become much slower in order to track and issue diagnostics for such things.<br>
<p>
But you&#x27;d have to ask the implementers for specifics if you want more. All I can say is that suggestions to do such things are not taken lightly on the implementer side at ISO C++ meetings.<br>
<p>
Personally, I&#x27;d be fine with a warning level to such heights if just to show people how little they actually understand about C and C++ behaviors. Instead, we get monster threads like this one one a semiregular basis.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 15:41 UTC (Sat)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863271/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; - inundate projects with oodles of warnings which they&#x27;ll promptly disable anyways; and</font><br>
As long as there&#x27;s a flag, it&#x27;s only a minor annoyance.<br>
<p>
<font class="QuotedText">&gt; - compilers would become much slower in order to track and issue diagnostics for such things.</font><br>
I thought of this, but I&#x27;d rather have a slower build than a broken program. Besides, the flag is enough to mitigate this if I&#x27;m OK with my program being completely broken but want faster builds.<br>
<p>
<font class="QuotedText">&gt; But you&#x27;d have to ask the implementers for specifics if you want more. All I can say is that suggestions to do such things are not taken lightly on the implementer side at ISO C++ meetings.</font><br>
I&#x27;m aware. But my point is this shouldn&#x27;t be up for implementors to decide IMO. If our code is not doing what we think it&#x27;s doing we need to know, it&#x27;s as simple as that.<br>
<p>
<font class="QuotedText">&gt; Personally, I&#x27;d be fine with a warning level to such heights if just to show people how little they actually understand about C and C++ behaviors. Instead, we get monster threads like this one one a semiregular basis.</font><br>
Agreed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863292"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 0:00 UTC (Sun)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863292/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If our code is not doing what we think it&#x27;s doing we need to know, it&#x27;s as simple as that.</font><br>
So you&#x27;re saying it&#x27;s simple for the compiler to figure out what you think the code ought to be doing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863292/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 3:33 UTC (Sun)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863306/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So you&#x27;re saying it&#x27;s simple for the compiler to figure out what you think the code ought to be doing?</font><br>
No, I&#x27;m saying it&#x27;s simple for the compiler to figure out that what you code means nothing and you obviously meant something, so in that case it isn&#x27;t doing what you think it&#x27;s doing :)<br>
That&#x27;s what happens when you hit UB. Nasal demons and all that. If your program has no meaning, that&#x27;s not what you want it to mean.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863373"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 10:26 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/863373/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <p>The problem with UB is not when all ways to interpret the code interpret UB - everyone, even compiler writers, agrees that there should be diagnostics for that.
<p>The problem is when there are multiple ways to interpret the code, such that some interpretations don't lead to UB, but others do. The classic example is:
<p>
<pre><code>
struct useful {
    int value;
    /* And a lot more bits */
};

void ub(void * forty) {
    struct useful * ptr = (useful*) forty;
    int value = ptr-&gt; value;
    if (!forty) {
        return;
    }
    /* Do stuff with value */
}
</code></pre>
<p>There are two interpretations here; either forty is NULL, or it isn't. If forty is NULL, then ptr-&gt;value; is UB, and thus the code snippet invokes UB. If forty is not NULL, then ptr-&gt;value is not UB, and so the compiler reasons that !forty must be false, always.
<p>And generated code, among other uses of C compilers, often depends on the compiler being able to spot that an expression must be true, and optimising accordingly. As a result, there's plenty of real code that depends on the optimizations that fire when forty cannot be NULL, and the compiler simply works backwards from what it knows - that if forty was NULL, then there would be UB, ergo forty must be known not to be NULL.
<p>In this particular example, the compiler's reasoning chain (and the user's mistake) is fairly obvious, and it wouldn't be challenging to have a warning that says "hey, !forty is always false because ptr-&gt;value would be UB otherwise, so this if statement is not meaningful", and have the user spot the error from there, but it gets more challenging with complex code. And neither compiler developers nor standard committees seem willing to say that good C compilers give a friendly warning when they find a codepath that invokes UB - in part because it'd trigger a lot of noise on legacy codebases.


      
          <div class="CommentReplyButton">
            <form action="/Articles/863373/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863375"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 11:20 UTC (Mon)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/863375/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There are two interpretations here</font><br>
<p>
Three. The third is that whoever wrote the program mis-ordered these statements. So the compiler might as well rearrange them (the code has UB, so it&#x27;s allowed to do that), and emit a warning while it&#x27;s at it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863375/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863376"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 11:45 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/863376/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>That is not an interpretation of the code as written - that's a guess at the authorial intention. And while this is a simple case, chosen because it's painfully obvious what the author meant, but it's also obvious how the compiler gets to "!forty must be false", one of the things that makes UB so painful is that the chain of reasoning the compiler uses from "if this is true, then UB" to "the meaning of this program is nowhere near what the author intended" can be huge, and even span multiple files if you're unlucky (assumption of not-NULL in a header file resulting in the only non-UB case being pointer is not NULL, or unsigned value is less than 64, or more complex things around signed overflow).
<p>Which is why I think that there should be a way to mark areas where UB could happen (Rust uses the <tt>unsafe</tt> keyword for this), and the compiler should be on the hook for defining all behaviour outside those blocks. If that's not reasonable (e.g. due to legacy code), then as a QoI issue, I'd like compilers to explicitly call out in a warning when they're reasoning backwards from "anything else would be UB".
<p>And yes, I know this is not easy. But it'd help out the people who want to write good modern C or C++ if their compilers could be trusted to alert them when there's a risk of UB resulting in badly behaved programs.


      
          <div class="CommentReplyButton">
            <form action="/Articles/863376/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor863377"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 12:46 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/863377/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Three. The third is that whoever wrote the program mis-ordered these statements. So the compiler might as well rearrange them (the code has UB, so it&#x27;s allowed to do that), and emit a warning while it&#x27;s at it.</font><br>
<p>
Reordering the statements means it would have to emit instructions to perform the NULL check. If the function is never called with NULL, that&#x27;s an unnecessary performance cost. It&#x27;s not a &quot;might as well&quot; situation - it&#x27;s choosing to sacrifice performance of correct code, in exchange for less surprising behaviour if the code is buggy.<br>
<p>
I think farnz&#x27;s point about &quot;generated code&quot; is particularly relevant for C++ because many libraries (including the standard library) depend heavily on template metaprogramming, which is basically a program that runs at compile-time where the inputs are C++ types and the outputs are C++ functions, so most C++ programs will include a lot of generated code in that sense. And that relies heavily on inlining, constant propagation, dead code elimination, etc, to get good performance - the metaprogram itself is (usually) functional and very recursive and has huge amounts of dead code, but needs to end up compiling the same as a simple imperative function.<br>
<p>
Because the library developers know they can rely on the compiler doing that optimisation, they can design the libraries to be generic and type-safe and easy-to-use, while still getting as good performance as specialised hand-tuned code (sometimes purely by relying on clever compiler optimisation, sometimes by explicitly selecting different algorithms based on properties of the type it&#x27;s being specialised for). And then users of the library can write much safer programs than if they tried to implement it by hand, because the library has been carefully designed and tested and reviewed by experts for years.<br>
<p>
If you try to sacrifice performance for safety, then those libraries may become much slower and developers would stop using them, so they&#x27;d write bad manual replacements, and then you&#x27;d end up losing performance *and* safety.<br>
<p>
(That doesn&#x27;t apply so much to C, which doesn&#x27;t have that metaprogramming facility (the closest thing is macros, which are terrible). But I guess the issue there is that few people care enough about C to write a dedicated C compiler, they just write a C++ compiler and stick a C frontend on it, and if C programmers refuse to use C++ then they&#x27;ll share the costs of that C++-focused optimisation but will miss out on most of the high-level safety benefits.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863377/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 13:22 UTC (Mon)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863382/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Reordering the statements means it would have to emit instructions to perform the NULL check. If the function is never called with NULL, that&#x27;s an unnecessary performance cost. It&#x27;s not a &quot;might as well&quot; situation - it&#x27;s choosing to sacrifice performance of correct code, in exchange for less surprising behaviour if the code is buggy.</font><br>
If the programmer put the check there then the programmer told the compiler the pointer could be NULL, so it shouldn&#x27;t assume the opposite unless it can absolutely prove the programmer was wrong.<br>
<p>
<font class="QuotedText">&gt; If you try to sacrifice performance for safety, then those libraries may become much slower and developers would stop using them, so they&#x27;d write bad manual replacements, and then you&#x27;d end up losing performance *and* safety.</font><br>
The template metaprogramming case is special in the sense the compiler knows if for that particular invocation the argument would be NULL (although you can&#x27;t pass pointers as template arguments AFAIR, if we assume that it relies on inlining then we know for sure once the check has been performed at the outmost call we can erase it from all of the recursive calls). So you don&#x27;t really sacrifice that much performance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 13:58 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/863384/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Trivial plain C counterexample, where the check is seen by the compiler, but the programmer did not intend to tell the compiler that the pointer could be NULL:
<pre><code>
/* In a header file, for config handling */
struct configs {
/* Lots of pointers to config members here, omitted */
};

#define GET_STR_CONFIG_OR_DEFAULT(config, member, default) \
    (config ? config-&gt;member ? config-&gt;member : default : default)

#define GET_INT_CONFIG_OR_DEFAULT(config, member, default)
    (config ? config-&gt;member ; default)

/* In a C file, using the header file */
void do_amazing_things(void *config) {
    int rating = GET_INT_CONFIG_OR_DEFAULT(config, rating, 0);
    char * expertise = GET_STR_CONFIG_OR_DEFAULT(config, expertise, "novice");

    /* Do the amazing things */
}
</code></pre>
<p>In this case, the call to GET_INT_CONFIG_OR_DEFAULT (a macro) has promised that config is not NULL because it does an early return; a compiler that doesn't optimize this will be issuing repeated NULL checks for something that it knows must be non-NULL, or complaining because the user has an unnecessary NULL check in the expansion of GET_STR_CONFIG_OR_DEFAULT.
<p>The code the compiler sees when the preprocessor hands it off is:
<pre><code>
struct configs {
/* Lots of pointers to config members here, omitted */
};
/* Rest of headers etc */

void do_amazing_things(void *config) {
    int rating = (config ? config-&gt;member : 0);
    char * expertise = (config ? config-&gt;member ? "expertise" : "expertise");
}
</code></pre>
<p>Which leads you into the question of provenance of your "always true" if statement; in this case, the compiler has to know that it knows config is not NULL because the programmer did something that's an explicit check, not a "if it's NULL, then we have UB" case, otherwise you get a noisy warning because the programmer included an unnecessary NULL check in the macro. But they did that because that way the macro is safe to use even if it's only used once in a function, and if the user does do:
<pre><code>
/* In a C file, using the header file */
void do_amazing_things(void *config) {
    int rating = ((struct configs*) config)-gt;rating;
    char * expertise = GET_STR_CONFIG_OR_DEFAULT(config, expertise, "novice");

    /* Do the amazing things */
}
</code></pre>
<p>then the compiler will need to warn because its "config is not NULL" assumption came from "if config is NULL, then there is UB in the execution". But first we need compiler authors to get onboard with the idea that whenever UB is invoked to permit an optimization (noting that this can require you to do complex tracking to get from your low-level IR (MachineInstr in the LLVM case, for example) all the way back to C, so that you can confirm that a given decision in codegen is not causing issues because it results in bad signed overflow behaviour (for example).


      
          <div class="CommentReplyButton">
            <form action="/Articles/863384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863493"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 19:11 UTC (Mon)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863493/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In this case, the call to GET_INT_CONFIG_OR_DEFAULT (a macro) has promised that config is not NULL because it does an early return; a compiler that doesn&#x27;t optimize this will be issuing repeated NULL checks for something that it knows must be non-NULL, or complaining because the user has an unnecessary NULL check in the expansion of GET_STR_CONFIG_OR_DEFAULT.</font><br>
The compiler can prove the extra check is unnecessary there. I&#x27;m not sure it would be wrong for it to complain, but it&#x27;s an entirely different case than adding a test after a dereference of something you can&#x27;t prove to not be NULL.<br>
<p>
<font class="QuotedText">&gt; Which leads you into the question of provenance of your &quot;always true&quot; if statement; in this case, the compiler has to know that it knows config is not NULL because the programmer did something that&#x27;s an explicit check, not a &quot;if it&#x27;s NULL, then we have UB&quot; case, otherwise you get a noisy warning because the programmer included an unnecessary NULL check in the macro. But they did that because that way the macro is safe to use even if it&#x27;s only used once in a function, and if the user does do:</font><br>
<p>
<font class="QuotedText">&gt; /* In a C file, using the header file */</font><br>
<font class="QuotedText">&gt; void do_amazing_things(void *config) {</font><br>
<font class="QuotedText">&gt;     int rating = ((struct configs*) config)-gt;rating;</font><br>
<font class="QuotedText">&gt;     char * expertise = GET_STR_CONFIG_OR_DEFAULT(config, expertise, &quot;novice&quot;);</font><br>
<p>
<font class="QuotedText">&gt;     /* Do the amazing things */</font><br>
<font class="QuotedText">&gt; }</font><br>
<p>
<font class="QuotedText">&gt; then the compiler will need to warn because its &quot;config is not NULL&quot; assumption came from &quot;if config is NULL, then there is UB in the execution&quot;. But first we need compiler authors to get onboard with the idea that whenever UB is invoked to permit an optimization (noting that this can require you to do complex tracking to get from your low-level IR (MachineInstr in the LLVM case, for example) all the way back to C, so that you can confirm that a given decision in codegen is not causing issues because it results in bad signed overflow behaviour (for example).</font><br>
<p>
The only thing I said is always true is that you can&#x27;t dereference something you can&#x27;t prove not to be NULL and expect it to not be UB; the check reordering is allowed because it was UB before and we can assume at that point what the author wanted. This doesn&#x27;t mean a warning should not be emitted unless (somehow) specified otherwise. If there&#x27;s a check before in the same function it&#x27;s trivial to prove it&#x27;s no longer NULL after that. Besides, you don&#x27;t need to know whether an optimization resulted from the UB. Knowing it exists is enough. And AFAICT that can be known before transforming to IR.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863493/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863555"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2021 11:54 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/863555/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  The only thing I said is always true is that you can&#x27;t dereference something you can&#x27;t prove not to be NULL and expect it to not be UB; the check reordering is allowed because it was UB before and we can assume at that point what the author wanted. This doesn&#x27;t mean a warning should not be emitted unless (somehow) specified otherwise. If there&#x27;s a check before in the same function it&#x27;s trivial to prove it&#x27;s no longer NULL after that. Besides, you don&#x27;t need to know whether an optimization resulted from the UB. Knowing it exists is enough. And AFAICT that can be known before transforming to IR.</font><br>
<p>
This is the difference between your model, and the C model. In C, you can dereference something that you can&#x27;t prove not to be NULL, and expect it to not be UB; it&#x27;s only UB if, on a specific execution, the thing is NULL. If it happens not to be NULL, then there&#x27;s no UB. This comes down to whole program analysis - as a programmer, you might ensure that you only call ub(config) with non-NULL pointers, and thus it&#x27;s fine. <br>
<p>
So the C compiler is able to reason backwards - if thing *is* NULL, then there is UB. Ergo is must not be NULL, because UB isn&#x27;t allowed, which permits optimization on the basis that it&#x27;s not NULL. This is fine if the explicit NULL check is (e.g.) from a macro, or in generated code, or left over from refactoring and not yet removed; you&#x27;ve taken out something that&#x27;s always false in this context, and just deleted the dead code.<br>
<p>
It only becomes a problem where the human is surprised by the deletion of dead code - i.e. where the human thought the check was still important, but it&#x27;s actually considered always false (or always true) by the compiler. And as deletion of dead code takes place at every level - from AST, through IR, through machine instruction choice - the compiler needs to link back its elimination of dead code and determine whether or not the human would be surprised by this particular elimination.<br>
<p>
And that&#x27;s what makes it a hard problem - we may know that ub(config) is only ever called with a non-NULL pointer, but that needs a whole program analysis which the compiler cannot perform. We may also know this simply because we&#x27;ve refactored so that callers of ub(config) do the NULL check themselves, and the extra NULL check inside the function may be there because a preprocessor (which can be outside the compiler!) has used a general form of code that works regardless of the presence of the NULL checks; why use two macros and force the human to think about whether or not a NULL check has happened already, when you can use one?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863555/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor863410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 14:56 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/863410/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; The template metaprogramming case is special in the sense the compiler knows if for that particular invocation the argument would be NULL (although you can't pass pointers as template arguments AFAIR, if we assume that it relies on inlining then we know for sure once the check has been performed at the outmost call we can erase it from all of the recursive calls)</font>

<p>But the compiler may not know that. E.g. you could have code like:</p>

<pre>struct S {
    int n;
    // ...
};

template &lt;typename T, typename Pred&gt;
void reset_if(T &amp;items, Pred pred) {
    for (auto &amp;item : items)
        if (pred(item))
            item = nullptr;
}

// Precondition: all items are not nullptr
// Postcondition: all items are even-numbered or are nullptr
void remove_odd(std::vector&lt;std::unique_ptr&lt;S&gt;&gt; &amp;items)
{
    reset_if(items, [](auto &amp;item) { return item-&gt;n % 2 != 0; });
}
</pre>

<p>(i.e. there's a dynamically-allocated array of pointers to S, and the function deallocates all the Ss that match some condition. This is somewhat artificial, but I don't think it's totally implausible as a component of some larger operation). The function's precondition is guaranteed by the programmer but is not visible to the compiler. (Maybe the caller is in a separate translation unit, or a dynamically-loaded library.)</p>

<p>On "item = nullptr", the unique_ptr will deallocate its original contents (to prevent memory leaks). Because unique_ptr is generic and supports custom deallocator functions, and the custom deallocator might not accept nullptr as an argument, the unique_ptr destructor is specified to do something like "if (get() != nullptr) get_deleter()(get());".</p>

<p>In this function, the unique_ptr destructor is only called after the "item-&gt;n % 2" check, which is dereferencing the pointer. Then the compiler knows the pointer can't be nullptr, so it can omit the "if (get() != nullptr)" test and save some time and code size. (In this case it's only a couple of instructions, but it's not hard to imagine similar cases where the 'if' is followed by an 'else' with a much larger chunk of code, and eliminating the whole 'else' clause could make a big difference.)</p>

<p>The null check wasn't intentionally added to this code by any programmer, it's just a part of the (relatively) safe abstraction provided by unique_ptr, so it's included in the code that's generated by the template instantiation. In this function the code is used in a way where the check is redundant and the compiler is able to figure that out because it sees the programmer was deliberately dereferencing the pointer, so the abstraction has zero cost and the programmer doesn't have to revert to a less-safe kind of pointer to get the same performance.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/863410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor863380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 13:16 UTC (Mon)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863380/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There are two interpretations here; either forty is NULL, or it isn&#x27;t. If forty is NULL, then ptr-&gt;value; is UB, and thus the code snippet invokes UB. If forty is not NULL, then ptr-&gt;value is not UB, and so the compiler reasons that !forty must be false, always.</font><br>
AFAICT, the logical conclusion here is that every pointer argument can be NULL unless proved otherwise. Since you can&#x27;t prove that for non-static functions, that&#x27;s necessarily UB. This is why many compilers have extensions to explicitly tell the compiler an argument can never be NULL.<br>
<p>
<p>
<font class="QuotedText">&gt; In this particular example, the compiler&#x27;s reasoning chain (and the user&#x27;s mistake) is fairly obvious, and it wouldn&#x27;t be challenging to have a warning that says &quot;hey, !forty is always false because ptr-&gt;value would be UB otherwise, so this if statement is not meaningful&quot;, and have the user spot the error from there, but it gets more challenging with complex code. And neither compiler developers nor standard committees seem willing to say that good C compilers give a friendly warning when they find a codepath that invokes UB - in part because it&#x27;d trigger a lot of noise on legacy codebases.</font><br>
Which was exactly my point. Besides, the point of triggering noise is moot IMO, since you can always add a flag to ignore the warning like with any other warning.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 13:27 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/863383/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; There are two interpretations here; either forty is NULL, or it isn&#x27;t. If forty is NULL, then ptr-&gt;value; is UB, and thus the code snippet invokes UB. If forty is not NULL, then ptr-&gt;value is not UB, and so the compiler reasons that !forty must be false, always.</font><br>
<p>
<font class="QuotedText">&gt; AFAICT, the logical conclusion here is that every pointer argument can be NULL unless proved otherwise. Since you can&#x27;t prove that for non-static functions, that&#x27;s necessarily UB. This is why many compilers have extensions to explicitly tell the compiler an argument can never be NULL.</font><br>
<p>
This is why the function included the check &quot;if (!forty) { return; }&quot;; after that test, forty is provably not NULL, and the compiler can optimize knowing that forty is not NULL. The gotcha is that the user invoked UB before that check by dereferencing ptr, and the compiler used that information to know that forty cannot be NULL after the dereference, because if it is, UB is invoked.<br>
<p>
<font class="QuotedText">&gt; &gt; In this particular example, the compiler&#x27;s reasoning chain (and the user&#x27;s mistake) is fairly obvious, and it wouldn&#x27;t be challenging to have a warning that says &quot;hey, !forty is always false because ptr-&gt;value would be UB otherwise, so this if statement is not meaningful&quot;, and have the user spot the error from there, but it gets more challenging with complex code. And neither compiler developers nor standard committees seem willing to say that good C compilers give a friendly warning when they find a codepath that invokes UB - in part because it&#x27;d trigger a lot of noise on legacy codebases.</font><br>
<p>
<font class="QuotedText">&gt; Which was exactly my point. Besides, the point of triggering noise is moot IMO, since you can always add a flag to ignore the warning like with any other warning.</font><br>
<p>
And my point is that this is entirely a social problem - nobody with the power to say &quot;compilers that use UB to optimize must tell the user what UB the compiler is exploiting&quot; is willing to do so. If compiler writers for C were doing that, even if it was the preserve of the very best C compilers (so GCC and CLang), it&#x27;d be enough to reduce the number of developers who get surprised by compiler use of UB.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863490"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 18:57 UTC (Mon)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863490/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This is why the function included the check &quot;if (!forty) { return; }&quot;; after that test, forty is provably not NULL, and the compiler can optimize knowing that forty is not NULL. The gotcha is that the user invoked UB before that check by dereferencing ptr, and the compiler used that information to know that forty cannot be NULL after the dereference, because if it is, UB is invoked.</font><br>
Of course. My point was that _on entry_ it isn&#x27;t provably not NULL, so NULL dereference is a possibility in that line, and thus the conclusion should consistently that the first dereference is UB. My point is that there&#x27;s no true ambiguity about that.<br>
<p>
<font class="QuotedText">&gt; And my point is that this is entirely a social problem - nobody with the power to say &quot;compilers that use UB to optimize must tell the user what UB the compiler is exploiting&quot; is willing to do so. If compiler writers for C were doing that, even if it was the preserve of the very best C compilers (so GCC and CLang), it&#x27;d be enough to reduce the number of developers who get surprised by compiler use of UB.</font><br>
So we agree, then?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863490/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863513"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 21:10 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/863513/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>And the problem with your point is that C is not very amenable to whole program analysis (for a variety of reasons to do with only having a global and a local <tt>static</tt> namespace, plus using textual inclusion instead of modules), which means that there's a lot of legacy code where the first dereference is <em>not</em> UB. It's only UB if the program execution can call <tt>ub</tt> with <tt>forty</tt> being NULL, which is not guaranteed. If the rest of the code ensures that <tt>ub</tt> is always called with a valid pointer to configs, then no UB is present.
<p>As I've pointed out in another comment, that check could be the consequence of a macro expansion - in which case, pessimising the output machine code because you've used a macro to access configs isn't a good look - there was no UB before, now you're adding code that verifies something that the human writing the code has already verified is true outside <tt>ub</tt>, and the use of a macro has been sufficient to introduce extra machine instructions.
<p>This is part of why it's a damn hard social problem - it's possible that <tt>ub</tt> is only called from code in 3 different C files, and all of those files already check for NULL before calling <tt>ub</tt>, so in the actual final application, there is no UB. The compiler using the fact that the check can only be true and cause an early return if UB has already happened to optimize <tt>ub</tt> simply speeds things up at no cost. 


      
          <div class="CommentReplyButton">
            <form action="/Articles/863513/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor863038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 16:38 UTC (Thu)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863038/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Then why won&#x27;t the compiler stop me?</font><br>
It does, unless you explicitly tell it not to by casting away const.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor862554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 23:35 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862554/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I suspect they&#x27;re sponsored by the same who sponsor rust because over the last 5 years or so</font><br>
<p>
I hope you&#x27;re joking, because if you aren&#x27;t, it&#x27;s bonkers conspiracy theory stuff.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor862504"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 6:39 UTC (Sun)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862504/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why are C compilers so &quot;awful&quot;? Because the *users* of those compilers *demand* that awfulness.</font><br>
<p>
This is false. The worst fear from both developers and distro maintainers is the release of the next gcc version that will again immediately break the build of 10% of their software and silently break 10 other percent at runtime, that will often be detected by end users before being caught by unit tests or reg tests.<br>
<p>
The *only* motivation here is competition between gcc and clang. Binary code correctness is their least concern. The amount of stupid warnings they can throw at the developer&#x27;s face however, is a well accepted metric, which often forces developers to introduce dangerous workarounds to silence them, to the point of sometimes writing bugs where they were none.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862504/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862525"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 15:08 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/862525/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This is false. The worst fear from both developers and distro maintainers is the release of the next gcc version that will again immediately break the build of 10% of their software and silently break 10 other percent at runtime, that will often be detected by end users before being caught by unit tests or reg tests.</font><br>
<p>
Sure, those are legitimate concerns from a subset of compiler users.  But they&#x27;re not the only users, many of whom are busy chasing [micro]benchmarks and lauding 0.5% performance boosts and/or 2% smaller binaries out of existing codebases.  [1] Perhaps more importantly, the latter folks are the ones actually funding compiler development.<br>
<p>
<font class="QuotedText">&gt;  The *only* motivation here is competition between gcc and clang. Binary code correctness is their least concern. The amount of stupid warnings they can throw at the developer&#x27;s face however, is a well accepted metric, which often forces developers to introduce dangerous workarounds to silence them, to the point of sometimes writing bugs where they were none.</font><br>
<p>
In the 20-odd-years I&#x27;ve been slinging C, the number of &quot;false positive&quot; warnings generated by the compiler represent a fraction of a percent.  The overwhelming, overwhelming majority of the other warnings were legit issues caused by the programmer making assumptions that might not be true in practice... if not outright mistakes.<br>
<p>
[1] I&#x27;ve been one of those users several times over the course of my career, gladly turning on every &quot;Make the binary as small as possible&quot; black-magic option.  The alternative was redesigning the hardware (which in one case was an actual ASIC).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862525/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862515"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 11:36 UTC (Sun)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/862515/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In other words, don&#x27;t tell it to try and optimize your code, and it won&#x27;t.</font><br>
<p>
That doesn&#x27;t work, there is lots of code out there that won&#x27;t even link when optimizations are turned off.<br>
<p>
<font class="QuotedText">&gt; Why are C compilers so &quot;awful&quot;? Because the *users* of those compilers *demand* that awfulness.</font><br>
<p>
No. Because these optimizations are perfectly valid in languages without C&#x27;s undefined-behavior &quot;rules&quot;. Optimized programs are faster and/or smaller. Uusers want optimizeable programs. When compiler A builds code that&#x27;s 2% smaller and/or 1.5% faster than compiler B&#x27;s, users complain to B&#x27;s authors and demand improvements.<br>
<p>
The problem is that, all too often, warnings about undefined behavior fall by the wayside.<br>
<p>
The realloc nonsense is a case in point. Disregarding for the moment that the optimizer should recognize that &quot;p&quot; aliases &quot;q&quot;, the pointer you pass in becomes invalid whenever realloc returns non-NULL. You&#x27;re not supposed to use it after that call, end of discussion. Does the compiler complain when you do anyway? no, mainly because the language doesn&#x27;t even have a way to freakin&#x27; *tell* it. Neither can you teach the compiler that a return value can be NULL and thus *must* be checked before being used.<br>
<p>
There are lots of other examples of this kind of &quot;why add a way to reject undefined behavior when we could just as well let the program crash and burn instead&quot; thinking by the C/C++ standardization people, which is why it&#x27;s completely understandable that certain people got fed up with it all and created Rust instead.<br>
<p>
.-.<br>
<p>
The failure IMHO isn&#x27;t so much that there are new optimizations here. The failure is that you can&#x27;t tell the compiler when you know they&#x27;re invalid, and even when you can and do (e.g. using the realloc example&#x27;s pointer comparison) some optimizers refuse to listen but still, apparently, conform to the standard.<br>
<p>
Just for laughs: this problem was introduced in clang 3.7. It&#x27;s now at version 12 and the bug is still there. GCC on the other hand does the same optimization (i.e. it doesn&#x27;t dereference the pointers) but at least it notices that they are aliased. In fact it has noticed since 4.1, which is the earliest version on godbolt.<br>
<p>
Cute, clang people. Really cute. Tell me again why I should trust your compiler to generate correct code?<br>
<p>
NB: not to single out clang. I just didn&#x27;t check whether GCC has similar brokenness somewhere else in its codebase.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862515/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 12:18 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862518/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; NB: not to single out clang. I just didn't check whether GCC has similar brokenness somewhere else in its codebase.</font>

<p>It sure does. If you look on the proposal which explicitly intends to <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2577.pdf">declare formely valid programs invalid because of UB</a> you'll find examples there for GCC, too. And <code>realloc</code> example is broken on ICC and MSVC, so no need to look hard.</p>

<p>In fact MSVC goes father than clang and GCC. If doesn't even look on the name of function! If your function accepts void pointer and size, then it's probably <code>realloc</code> and <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:16,endLineNumber:5,positionColumn:16,positionLineNumber:5,selectionStartColumn:16,selectionStartLineNumber:5,startColumn:16,startLineNumber:5),source:'%23include+%3Cstdio.h%3E%0A%23include+%3Cstdlib.h%3E%0A%0A__declspec(noinline)+void+*hohoho(void+*ptr,+size_t+size)+%7B%0A++++return+ptr%3B%0A%7D%0A%0Aint+main()+%7B%0A++++int+*p+%3D+(int*)malloc(sizeof(int))%3B%0A++++int+*q+%3D+(int*)hohoho(p,+sizeof(int))%3B%0A++++if+(p+%3D%3D+q)+%7B%0A++++++++*p+%3D+1%3B%0A++++++++*q+%3D+2%3B%0A++++++++printf(%22%25d+%25d%5Cn%22,+*p,+*q)%3B%0A++++%7D%0A%7D'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:50,l:'4',m:100,n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:ccl19_2015_u3_64,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'1',trim:'0'),fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:/O2,selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x64+msvc+v19.0+(WINE)+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">it's Ok for the compiler to rely on that</a>.</p>

<p>Nifly, huh? Even if your <code>hohoho</code> just returns pointer it receives — according to MSVC that invalidates pointer passed to it.</p>

<font class="QuotedText">&gt; which is why it's completely understandable that certain people got fed up with it all and created Rust instead.</font>

<p>Actually that's the reason why Rust tries so very hard to ensure that only code marked with <code>unsafe</code> moniker can cause undefined behavior. But keep in mind that wrong <code>unsafe</code> can “infect” safe Rust and thus actual misbehavior can happen in a very different piece of program, not just inside an <code>unsafe</code> code block.</p>

<p>Initially Rust wasn't as religious about it, but as C/C++ compiler developers tried to ensure that these languages are unfit for any purpose harder and harder… Rust tightened the screws more and more tightly.</p>

<p>Today they promise that any undefined behavior in an unsafe code <b>have</b> to come from <code>unsafe</code> code block and that code block should live outside of standard library.</p>

<p>In fact that's where they put the limit on a stability guarantee: if your old program doesn't work with a new compiler (or couldn't be compiled with a new compiler) it's a bug to be fixed ASAP — except when your program relies on some kind of loophole which may introduce UB into safe Rust. Then, as last resort, they can break such code (but preference goes into “make it compile-time error” instead of crazy C/C++ stance where making code non-compileable is huge sin, but making it broken is “business as usual”).</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862530"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 15:27 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/862530/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The problem is that, all too often, warnings about undefined behavior fall by the wayside.</font><br>
<p>
If by this you mean &quot;folks writing code routinely ignore/disable warnings and complain when things don&#x27;t work as expected&quot; then I wholeheartedly agree.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862530/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862531"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 15:55 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862531/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <p>But they don't disable warnings because of malice! They disable warning because “they know better”! And, indeed, the original plan <b>explicitly</b> called for compilers writers to <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n897.pdf"> augment the language by providing a definition of the officially undefined behavior</a>. To make life of such developers easier.</p>

<p>Instead C and C++ developers have painted themselves into the corner: by repeating mantra “nothing except the standard text matter to us” they made said standard text sacred. Now, when they have found out that some optimizations they actually perform are unsound and don't obey the letter of said standard… attempts to change the standard are <b>rightfully and correctly</b> perceived as an act of sabotage.</p>

<p>Maybe if for last couple of decades compiler developers have actually listened to the users and not used said standard as fig leaf… then maybe, just maybe reaction would have been different. Even then: it's not guaranteed. Backward incompatible changes, <b>especially</b> not detectable at compile time is not something which users would welcome.</p>

<p>But at this point it looks as if the only sane decision would be to switch to some other language. Where developers <b>actually listen</b> to user's complains.</p>

<p>Rust is one such language.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862531/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862533"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 16:09 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/862533/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But they don&#x27;t disable warnings because of malice! They disable warning because “they know better”! </font><br>
<p>
&quot;Sufficiently advanced stupidity is indistinguishable from malice&quot;<br>
<p>
<font class="QuotedText">&gt; Instead C and C++ developers have painted themselves into the corner: by repeating mantra “nothing except the standard text matter to us”</font><br>
<p>
Because &quot;The standard&quot; is all that actually matters, because it is the contract that everyone involved relies upon to determine what to expect.  If &quot;the standard&quot; is inadequate, then the correct thing to do is *improve the standard*<br>
<p>
Otherwise you&#x27;re just asking for the compiler equivalent of IE6 (&quot;standards be damned, we&#x27;re the ones with the market share&quot;) and OOXML&#x27;s &quot;autoSpaceLikeWord95&quot; parameter.<br>
<p>
<font class="QuotedText">&gt; But at this point it looks as if the only sane decision would be to switch to some other language. Where developers actually listen to user&#x27;s complains.  Rust is one such language.</font><br>
<p>
Which users are Rust&#x27;s stewards listening to?  What happens when (if?) its userbase grows large enough that their requests can not be reconciled? Will the &quot;losing users&quot; then have to switch to a new language whose developers &quot;Actually listen to users&#x27; complaints&quot;?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862533/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862536"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 17:00 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862536/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; If "the standard" is inadequate, then the correct thing to do is *improve the standard*</font>

<p>Then why haven't compiler developer have done <b>that</b>? Why the heck they <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1236r1.html">made signed integer two's complement</a> <b>without</b> making integer overflow legit?</p>

<font class="QuotedText">&gt; Otherwise you're just asking for the compiler equivalent of IE6 ("standards be damned, we're the ones with the market share") and OOXML's "autoSpaceLikeWord95" parameter.</font>

<p>No. I'm asking about some kind of <b>dialogue</b> where users talk to compiler writers and they <b>listen</b> (instead of dismissing any and all concerns with reference to the standard).</p>

<p>Note that story with IE6 ended not with some kind of all-compassing “finished and sacred” HTML5 standard, but with <a href="https://en.wikipedia.org/wiki/WHATWG">living standard</a>. Which tries to <b>reconcile</b> concerns of different actors.</p>

<p>Nothing like that happened with C/C++ developers. First they <b>ignored</b> any and all concerns about standard craziness. And then, when they found out that standard is problematic for them, too — they decided do change it. And <b>retroactively</b> turn valid programs into invalid.</p>

<p><b>That</b> is why it was pulled in through “defect report” venue (and not through “changes for the next version” venue).</p>

<p>They want to try to pretend that standard <b>always</b> meant to say what it doesn't explicitly say. And <b>don't</b> plan to offer <b>any</b> compatibility options.</p>

<p>Have they really though compiler users wouldn't notice that bait-and-switch tactic?</p>

<font class="QuotedText">&gt; Which users are Rust's stewards listening to?</font>

<p>Please watch (or read) <a href="https://www.infoq.com/presentations/rust-tradeoffs/">that presentation by Stephen Klabnik</a>. He explains that better than me.</p>

<p>But the short answer is: they try to minimize number of unhappy users. Not by applying some crazy rules buy by listening to a different people and trying to reconcile opposing POV.</p>

<p>They have found out that when you actually <b>listen</b> and <b>explain</b> people <b>very often</b> are willing to change their opinions and compromise which is acceptable for everyone (or almost everyone) involved is possible more often then you may think.</p>

<p>Right now they are brainstorming the <a href="https://blog.rust-lang.org/2021/04/14/async-vision-doc-shiny-future.html">asynchronous programming story</a> and, frankly, I'm 99% sure they would reach a much better compromise then <a href="https://en.cppreference.com/w/cpp/language/coroutines">what C++ got</a> and instead of something everyone hates equally they would reach to something everyone would accept equally.</p>

<font class="QuotedText">&gt; What happens when (if?) its userbase grows large enough that their requests can not be reconciled? Will the "losing users" then have to switch to a new language whose developers "Actually listen to users' complaints"?</font>

<p>We would see, I think. Nobody have the crystal ball and can predict the future. Anything can happen but I just don't foresee the situation which was the norm for last 10-15 years in the C/C++ land where opinions of the wast majority of “normal developers” were ignored “because sacred standard gave us that right” and the “my way or the highway” approach to the treatment of UB was normal.</p>

<p>In spite of the fact that standards committee <b>explicitly</b> said that UB <i> identifies areas of possible conforming language extension</i> it was almost never treated as such.</p>

<p>Instead of looking for a way to <b>remove</b> UB where it made sense (to make language easier to work with) compiler developers always seeked a way to <b>exploit and amplify</b> them (to win these all-important 2-3% on SPEC CPU benchmarks).</p>

<p><b>That</b> is something I don't see in Rust so far (but then, it only has one official compiler thus benchmark games don't matter… yet).</p>

<p>Consider how that issue with signed overflow was treated. First of all: there are <a href="https://rust-lang.github.io/rfcs/0560-integer-overflow.html">large and detailed document which explains the decision</a>. Second: for the ones who want/need wrapround <a href="https://doc.rust-lang.org/std/num/struct.Wrapping.html">there are standardized</a> handling of it. And, most important, it was clearly decided that overflow may be handled differently, but it absolutely, <b>under no circumstances</b> can be used to remove code from the program.</p>

<p>It's not a UB.</p>

<p>Now compare to what happens in C/C++ land.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862536/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862840"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2021 16:21 UTC (Wed)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/862840/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Now compare to what happens in C/C++ land.</font><br>
<p>
Here&#x27;s what I see.  <br>
<p>
Rust is able to be more &quot;responsive&quot; to users&#x27; complaints than the C &amp; C++ folks because it is young, immature, and not widely used. [1] I&#x27;m not saying that pejoratively; this gives Rust a _lot_ more freedom and flexibility to rapidly evolve and improve, and this is also reflected in the processes that Rust uses to improve itself.  Its lack of users (and diversity of use) means there&#x27;s very little at stake, and the single-implementation monoculture ensures everyone is using the same tooling with changes becoming rapidly available.<br>
<p>
However, C &amp; C++ have many independent implementations, and (due in part to a 30 year head start vs Rust) have many orders of magnitude more lines of code, projects, and active coders out there, with the inevitable (and _considerable_) historical baggage that entails.  Each of those stakeholders has different requirements and goals (that are, more often than not, inherently confliciting), and collectively represent a _lot_ of investment.  This means the standardization efforts operate much more conservatively, slowly, and *formally*, but perversely, that many-independent-implementations state of affairs means that there&#x27;s _less_ need to actually participate in standardization efforts.  (This is why C++ was such an utter interoperability mess for so long..)<br>
<p>
But yes, standards groups fall back to their standards documents, which are simultaneously sacrosanct and highly fungible depending on the context and what&#x27;s being discussed.  Welcome to the wonderful world of diverse stakeholders that only occasionally pull in the same direction.  If Rust succeeds in becoming anything more than a small niche language, this diversity (and inevitable impact on velocity &amp; responsiveness) will happen to them too... indeed, it&#x27;s more likely that achieving this diversity is necessary in order for Rust to succeed.<br>
<p>
Rust seems to have the basics/core down pretty solidly now; ie the language meets their own goals/needs fairly well.  But trying to grow the tent means they have to appeal more broadly -- and beating/berating the folks you&#x27;re trying to convince isn&#x27;t exactly endearing. Putting questionable PR aside, the harsh reality is that these other prospective users need a gradual path to adoption, and Rust is still quite awful about integrating into both predominantly non-Rust codebases and into a larger systems as a whole.  Sure, they&#x27;re working on improving both, but again, software &amp; system maintainers tend to be _very_ conservative and have seen plenty of &quot;don&#x27;t worry, we&#x27;ll solve these [very hard problems] later&quot; hot-and-shinies come and go.<br>
<p>
FWIW, personally, if I were to start a new project today I&#x27;d probably try it in Rust, but there&#x27;s zero advantage to rewriting my existing C projects.<br>
<p>
[1] The product at $dayjob that my team will eventually integrate into has over 5.5M lines of in-house C++ code.  Once you include stuff shared with other in-house products and 3rd-party code/libraries it goes up considerably further.  It&#x27;s safe to say that my employer easily has tens of millions of lines of C++ code in production today, and I wouldn&#x27;t be surprised if the actual number is closer to 100 million.  And this is just _one_ (admittedly large) organization.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862840/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2021 17:19 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862884/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Rust is able to be more "responsive" to users' complaints than the C &amp; C++ folks because it is young, immature, and not widely used.</font>

<p>True, but what about Java, Python, or, IDK., C#? Python is 30 years old, Java is 26 years old. And amount of code written in both is comparable to C or C++.</p>

<p>Yes, there are tensions between developers of these languages and users of them, there are always are. But nothing like the situation with C and C++ where  concerns of users are usually dismissed with magic phrase “you don't know C (or C++), read the standard, please”.</p>

<p>I don't know of <b>any</b> other language where “holy standard gave us the right, you must bow before our might” is the normal attitude.</p>

<p>In fact even when Spidermonkey or V8 developers justify something with reference to standard it's usually with note of sadness and intent to help. You can certainly feel that they genuinely want to help the developer, user of their language, but they <b>have</b> to follow the standard rules, too. So they are looking for the compromise (and often finding it: by showing standard-compliant compromise, adding certain feature or just offering a way to refactor code to make it better).</p>

<p>For them the fact that standard is, in some places, crazy and stupid is a limitation which they still have to follow, but attempts to make life of users easier are equally important.</p>

<p>And if they can fix the issue in a new version of a standard — they do that <b>without</b> leaving pile of footguns behind (except where backward compatibility <b>make</b> them do that).</p>

<font class="QuotedText">&gt; This means the standardization efforts operate much more conservatively, slowly, and *formally*, but perversely, that many-independent-implementations state of affairs means that there's _less_ need to actually participate in standardization efforts. (This is why C++ was such an utter interoperability mess for so long..)</font>

<p>Java never had such an issue, despite there being lots of players, too. No, I think the toxic C/C++ compiler developers attitude comes from the mere fact that most C/C++ developers, perversely enough, are irrelevant for them.</p>

<p>They are captive audience. Either they need to use proprietary compiler to develop code for certain hardware platform. Or, they are not even directly relevant at all if compiler developer comes from some university (then the need to publish paper is much more important than the need to send time thinking how real users would use the compiler).</p>

<p>It also doesn't help that C and C++ are last widely used languages which were developed before rise of the Usenet, mailing lists or web sites.</p>

<p><b>The actual software developers are not their customers</b> — that is the issue. Everything else is secondary.</p>

<font class="QuotedText">&gt; Sure, they're working on improving both, but again, software &amp; system maintainers tend to be _very_ conservative and have seen plenty of "don't worry, we'll solve these [very hard problems] later" hot-and-shinies come and go.</font>

<p>That's exactly why I think trying to bring these folks by talking about virtues of Rust is pointless. Ultimately it all would be decided by Google and Microsoft (and other large companies to lesser degree). If their management would like Rust and divert development resources from C++… house of cards may implode <b>very</b> quickly. If not… then Rust would remain strong yet niche player like Haskell for years.</p>

<p>In both cases it makes little sense to try to bring C++ developers to the Rust bandwagon: if Google and Microsoft would continue with C++ then they would be able to use for years, if they would back Rust instead then they would <b>have</b> to come to Rust camp.</p>

<p>It's probably better to bring Javascript, Python or maybe even Java developers: users of these language are not accustomed to the deal with languages composed almost entirely from footguns, but they appreciate speed.</p>

<p>C++ developers would join later… if that would even happen at all.</p>

<font class="QuotedText">&gt; FWIW, personally, if I were to start a new project today I'd probably try it in Rust, but there's zero advantage to rewriting my existing C projects.</font>

<p>That sounds like a sensible approach. Yes, sooner or later, without constant vigilance, these C projects would die because new generations of compilers would find a way to compile them onto nothing with a very powerful prover that would prove that something triggers “undefined behavior” in them, but while they work… why spend efforts to fix something that is not broken?</p>

<font class="QuotedText">&gt; Rust is still quite awful about integrating into both predominantly non-Rust codebases and into a larger systems as a whole.</font>

<p>I'm 99% sure Google and Microsoft would find a way to solve that issue. Maybe by creation of Rust++ (similar to how Apple solved that problem with <a href="https://en.wikipedia.org/wiki/Objective-C#Objective-C++">Objective C++</a> years ago — language which makes zero sense on it's own, but allows one to write a glue code which connects Objective C code to C++ code).</p>

<p>If they would decide it's worthwhile for them to switch from C++ to Rust, of course. I don't think they would bother to <b>both</b> push C++ forward <b>and</b> write something like that.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862893"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2021 18:45 UTC (Wed)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/862893/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Java never had such an issue, despite there being lots of players, too.</font><br>
<p>
Yes and no -- Java was completely proprietary until 2007, and to this day is still ultimately under the control/ownership of a single (very litigious) company.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862893/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862895"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2021 19:17 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862895/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>But why would <b>that</b> force it's developers to hear complains of the users? Wouldn't that make reponse “you have violated the spec, thus your program is wrong, just go and fix it” <b>more</b> attractive, not <b>less</b>?</p>

<p>Can you show me <b>any other language at all</b> where response to some complaint from users (and they are numerous for any language) <b>starts and finishes</b> with reference the the standard, reference manual, or some other documentation?</p>

<p><b>Not</b> “if we do X then we would have this, if we do Y then we would have that, and we if we would do Z then we would have something else and standard says we should do Y thus that's what we do”, but flat out <b>refusal</b> to even hypothetically contemplate the notion that what the standard says may not be a good idea to do <b>at all</b>? Where standard is turned into holy gospel instead of being perceived as <b>one</b> (albeit, sure, very serious) argument among many?</p>

<p>I just couldn't recall such an attitude among developers of any other language. Consider shifts: Java and Rust pick “modulo size of operand” choice while Go picks “mathematically defined shift” (where <code>1 &lt;&lt; 100</code> is <code>0</code>). Both choices have <i>pro</i> and <i>cons</i>, both make some sense, but C compiler developers pick “if we ever catch you doing that we would punish you” which have only one justification: “standard allows us to do that thus we will do that”.</p>

<p>Can you show me <b>one</b> place where developers of <b>any</b> other language are doing that? Knowingly make the life of their users hell just because their “holy gospel” say they have the right to do that — while pointedly and explicitly ignoring and and all other arguments?</p>

<p>I'm not saying that it never happens. I just haven't seen that. So if you have such examples — can you show me them to make our discussion more concrete?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862895/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor862886"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2021 18:03 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/862886/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; FWIW, personally, if I were to start a new project today I&#x27;d probably try it in Rust, but there&#x27;s zero advantage to rewriting my existing C projects.</font><br>
<p>
It might make sense to eventually rewrite legacy codebases (like Unix command line tools) just to make them more approachable for new people.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862886/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862887"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2021 18:28 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862887/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It may be fun project for someone who may want to learn Rust, but it don't think right now it would make them <i>more approachable for new people</i>.</p>

<p>Rust currently <a href="https://www.tiobe.com/tiobe-index/rust/">much more popular</a>, than, e.g., <a href="https://www.tiobe.com/tiobe-index/haskell/">Haskell</a>, but still there are many times less developers than <a href="https://www.tiobe.com/tiobe-index/c/">C</a> or <a href="https://www.tiobe.com/tiobe-index/cplusplus/">C++</a>.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862887/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor862581"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 9:19 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/862581/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  &gt; Instead C and C++ developers have painted themselves into the corner: by repeating mantra “nothing except the standard text matter to us”</font><br>
<p>
<font class="QuotedText">&gt; Because &quot;The standard&quot; is all that actually matters, because it is the contract that everyone involved relies upon to determine what to expect. If &quot;the standard&quot; is inadequate, then the correct thing to do is *improve the standard*</font><br>
<p>
You&#x27;re missing Khim&#x27;s point. Whether he is right or not is irrelevant here - what has allegedly happened is that the compiler writers have BROKEN THE STANDARD and, instead of trying to fix the compiler, are trying to fix the standard instead.<br>
<p>
Oh - and as for the standard being inadequate, the correct fix is to *remove* UB, not convert what was defined behaviour into UB, which again is Khim&#x27;s point.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862581/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862586"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 10:39 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862586/">Link</a>] 
      </p>
      
      </div>
      </summary>
      What you are saying is correct, only there are no <i>allegedly</i> there.

<p>The sequence of events:
<ol>
<li>First compiler writers <b>for decades</b> use standard as “big club” to lord over the users. When users (including <b>very</b> prominent users like Linus) claimed that standard is inadequate their response is always “dura lex, sed lex” — and all the (hundreds thousands? millions?) of C/C++ developers must just bow and accept (sometimes they offer some flags as concessions like <code>-fwrapv</code>/<code>-ftrapv</code>, but AFAIK <code>-ftrapv</code> was broken for years with GCC and I'm not even sure it's fixed now).
<li>At some point they have found out that they don't have enough undefined behaviors in the standard to <s>punish the users</s> optimize well… and they needed them because they <b>already miscompiled certain standard-compliant code</b>.</li>
<li>They went to the standards committee and presented their question (remember, we are talking about breaking well-defined, according to the standard, C programs here!) as certain <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_260.htm">defect report</a>… note the dates.</li>
<li>There was “much discussion” and eventually, reluctantly, C committee “came to a number of conclusions as to <b>what it would be desirable for the Standard to mean</b>” (emphasis mine). Note: even after, most likely, threatening to just ignore the standard and do their own thing, they <b>haven't got the concession</b> about <b>actual</b> meaning of the standard… only about “what it would be desirable for the Standard to mean”</li>
<li>At that point story have started to become bizzare. After the resolution of the standard committee <b>two C standards</b> (C11 and C18) were created and <b>both</b> without incorporation of these changes. Why? Because of unsoundness. Standards committee (and remember, it's more thorough than C++ standards committee, it actually lists all these all-important “undefined behaviors” in attachment) rejected <b>numerous</b> proposals because of that.</li>
<li>In fact, when Rust developers (who are, as we know, obsessing not about benchmarks, but about correctness) started looking on that issue (and they had to because currently Rust compiler is based on LLVM, GCC backend was added just few days ago) they have found out that they <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">can turn completely valid C program into pile of goo</a> (it doesn't happen in real LLVM usage because optimization phases are applied in certain order).</li>
</ol>

<p>So the end result:</p>

<ol>
<li>For last 20 years compiler authors claimed that C and C++ developers <b>have</b> to follow the standard (because, see, it's <b>the only contract</b> between compiler and users… nothing else matters).</li>
<li>For last 20 years compiler authors <b>refused to follow</b> the same standard (because, see, we have the fig leaf of DR260 resolution and it's “only technical issue” of actually changing the standard now).</li>
</ol>

<p>P.S. I would have been more sympathetic to the woes of compiler writer is <b>they</b> would have been more sympathetic to woes of developers. And requests of “why shift by 32 turns my program into pile of goo?” (even if after said shift I do <code>x &amp; 0</code> which, you know, in normal math always produces zero) answer was not “standard gave us right to assume that, go away” but something more reasonable (e.g. some kind of intrinsic which I can use for that). But after <b>decades</b> of <b>both</b> insisting that <b>users</b> have to follow standard to the letter and apparent refusal of <b>developers</b> to follow it… it's hard to see what kind of dialogue is possible.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862586/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor862537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 17:03 UTC (Sun)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/862537/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, that&#x27;s not what I mean.<br>
<p>
My point is that C / C++ doesn&#x27;t have any features to declare whether, or to what extent, any given code is &quot;safe&quot; or &quot;unsafe&quot;. Like &quot;this value might be aliased&quot; (one of the zillion possible meanings of &quot;volatile&quot; …) or &quot;this here is a pointer; that there is an array of size 42&quot; or &quot;tell me if this integer operation overflows&quot;.<br>
<p>
Thus the compiler can either assume the worst (which disables whole classes of optimizations: traditional compilers) or transitively propagate UBs to whichever remotely plausible result (for some value of &quot;plausible&quot; that often corresponds to no real computer ever built) produces the best-optimizable code (current clang and/or gcc).<br>
<p>
Most of these problems DO NOT generate warnings at either compile or run time and there is NO way to catch them without extensive tooling (e.g. convert integers into a struct/class and overloading all basic integer operations), if at all (you simply can&#x27;t teach the C compiler to not just let you use a pointer like an array) - and even when you can, and do, the compiler people seem to be free to ignore you, as witnessed by the aforementioned realloc nonsense.<br>
<p>
The upshot is that compilers do not warn about (many, but not all of) these problems because your compiler run would be inundated with ludicrous warnings about perfectly safe code, both your own and in header files, which the compiler cannot distinguish from unsafe usage. In many cases, there&#x27;s no way to tell, and the people responsible for the language refuse to add ways to fix the problem.<br>
<p>
This won&#x27;t go away even if the compiler could prove that 95% of these cases are safe because the remaining 5% are still too much. Thus nobody would enable these warnings, thus there&#x27;s no reason a sane compiler coder would add them in the first place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 21:13 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/862552/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; My point is that C / C++ doesn&#x27;t have any features to declare whether, or to what extent, any given code is &quot;safe&quot; or &quot;unsafe&quot;. Like &quot;this value might be aliased&quot; (one of the zillion possible meanings of &quot;volatile&quot; …) or &quot;this here is a pointer; that there is an array of size 42&quot; or &quot;tell me if this integer operation overflows&quot;.</font><br>
<p>
Ah, okay.  Thanks for the clarification.  FWIW I think I&#x27;m in agreement with you.<br>
<p>
Unfortunately, most of my professional C slinging has been with code that is inherently &quot;unsafe&quot;.  I do wish the C standards folks would try to improve bare-metal usecases instead of trying to make C more like (the awful parts [1] of) C++.  <br>
<p>
...On the other hand, I recently had to write a userspace DMA driver.. in Python.  Talk about the worst of all possible worlds...<br>
<p>
[1] which IMO is &quot;most of it&quot;<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor862532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 16:00 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/862532/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Yet clang would happily turn it into a function which returns false if you give it some variable which is not initialized.</font><br>
<p>
<font class="QuotedText">&gt; This goes so far beyond the abilities of someone to reason about the program it&#x27;s not funny.</font><br>
<p>
This is the problem with tri-value logic. Look at how SQL handles NULL, for example. By definition, &quot; NULL || !NULL = NULL &quot;.<br>
<p>
Although &quot; b || !b &quot; should translate into &quot; known or not known &quot; which one would expect to be true, depending on your definition of &quot;not known&quot;, or NULL, or uninitialised ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862534"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 16:10 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862534/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Although " b || !b " should translate into " known or not known " which one would expect to be true, depending on your definition of "not known", or NULL, or uninitialised ...</font>

<p>It's C, not SQL. And valid <code>int</code> doesn't have a value which can lead to this three-way logic (<code>float</code> does, BTW, I wouldn't be much surprised to see the exact same example with floats: <code>(f == 0.0) || (f != 0.0)</code> can be false in a program without any UB).</p>

<p>They had to specifically add said trilogic to the code and introduce special “poison” (the name is telling, isn't it?) value to the set of “normal” <code>int</code> values to achieve that effect.</p>

<p>This doesn't look like a “mere accident” to me, more like an act of sabotage.</p>

<p>P.S. GCC does such optimizations a bit differently. Instead of treating undefined value as special “poison” value with trilogic it just assigns arbitrary value to it and then does the usual constant propagation and other such optimizations. This produces almost the same speedup without making user angry.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862534/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862597"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 12:37 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/862597/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Let&#x27;s go to that infamous realloc example. Can you show me what kind of sanitizer should I use to catch error in it?</font><br>
<p>
I genuinely don&#x27;t know what sanitizer would best help you avoid getting this wrong. I had to stare at this code for some time to even discern what its author might have expected it to do beyond &quot;Not work&quot;.<br>
<p>
<font class="QuotedText">&gt; Can you even explain why compiler was allowed to provide the output it does?</font><br>
<p>
I can try.<br>
<p>
After calling malloc p is a pointer to some uninitialized memory big enough to store an int (or it&#x27;s NULL, but we&#x27;ll ignore this scenario). After calling realloc p is still definitely a pointer BUT we need to examine q to know whether p still points _to_ anything. If q is NULL, p still points to that same memory (and of course this NULL pointer in q isn&#x27;t pointing at anything), however if q is not NULL, p has been free&#x27;d and now doesn&#x27;t point to anything (even though its bit pattern might seem to suggest otherwise) while q is now pointing to uninitialized memory big enough to store an int.<br>
<p>
Then the code tries to compare p and q to see if they&#x27;re &quot;equal&quot;, if p and q are both NULL that&#x27;s fine (and true) although what&#x27;s about to happen next is a bad idea. If either of them isn&#x27;t NULL, this comparison is invalid because they definitely aren&#x27;t pointing at the same object.<br>
<p>
Having concluded that p and q are &quot;equal&quot;, it tries to store different values to these pointers. The compiler is under no obligation to actually implement this by writing values to RAM at addresses stored in p and q, and as it is sure that they aren&#x27;t pointing at the same object (one of them isn&#x27;t pointing at anything at all), it needn&#x27;t worry whether in the programmer&#x27;s imagination this should be overwriting the same value.<br>
<p>
This code repeatedly dereferences a pointer that was free()d. It is not surprising that it doesn&#x27;t always do what you wanted.<br>
<p>
<font class="QuotedText">&gt; Why does it even say that it may have the same value as a pointer to the old object if I couldn&#x27;t use that fact for anything?</font><br>
<p>
The copy of K&amp;R I own doesn&#x27;t say this, but the Linux manual pages do. I imagine they were hoping to prevent confusion, by assuring you that it&#x27;s possible you&#x27;ll get the &quot;same&quot; value back and not only &quot;different&quot; values and so you shouldn&#x27;t try to conclude anything from that. Alas as so often they&#x27;ve instead made things worse by persuading you that you could try to compare these values when in fact you can&#x27;t do that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862597/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862678"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 17:21 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862678/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; The copy of K&amp;R I own doesn't say this, but the Linux manual pages do.</font>

<p>C standard says that. It should be enough. Besides compiler developers have said long ago they don't care about anything else.</p>

<font class="QuotedText">&gt; I imagine they were hoping to prevent confusion, by assuring you that it's possible you'll get the "same" value back and not only "different" values and so you shouldn't try to conclude anything from that.</font>

<p>I don't think so. Let's look on the original description in the C89:</p>

<blockquote>The <code>realloc</code> function changes the size of the object pointed to by <code>ptr</code> to the size specified by <code>size</code>. The contents of the object shall be unchanged up to the lesser of the new and old sizes. If the new size is larger, the value of the newly allocated portion of the object is indeterminate. If <code>ptr</code> is a null pointer, the <code>realloc</code> function behaves like the <code>malloc</code> function for the specified size. Otherwise, if <code>ptr</code> does not match a pointer earlier returned by the <code>calloc</code>, <code>malloc</code>, or <code>realloc</code> function, or if the space has been deallocated by a call to the <code>free</code> or <code>realloc</code> function, the behavior is undefined. If the space cannot be allocated, the object pointed to by <code>ptr</code> is unchanged. If size is zero and <code>ptr</code> is not a null pointer, the object it points to is freed. 

<p>The <code>realloc</code> function returns either a null pointer or a pointer to the possibly moved allocated space.</p></blockquote>

<p>No funny business with objects which are deallocted then allocated in the same place. And phrasing “possibly moved allocated space” definitely sounds as if “object was left untouched” is normal case while “object was moved” as an exception. Which matches the behavior of early allocators, BTW.</p>

<p>And phrase <i>The realloc function returns a pointer to the new object (which may have the same value as a pointer to the old object), or a null pointer if the new object has not been allocated</i> is just a translation of that “easy to understand English” to modern “incomprehensible standartize English”.</p>

<font class="QuotedText">&gt; After calling realloc p is still definitely a pointer BUT we need to examine q to know whether p still points _to_ anything.</font>

<p>No we don't. You are <b>not</b> supposed to even <b>look</b> on pointer which no longer points to valid object: attempt to use <i>the value of a pointer that refers to space deallocated by a call to the free or realloc function isused</i> triggers not just any random simple “bounded undefined behavior” but actually triggers “unbounded undefined behavior”. Yet standard <b>explicitly</b> says that value passed to <code>realloc</code> and returned from <code>realloc</code> may be the same. And yes, it's not just “pass NULL, get NULL back” — that would mean entirely different thing than “possibly moved allocated space”.

<p>Also. Pointer provenance is <b>not a thing</b> and that's how pointer comparison works, according to C18:</p>

<blockquote>Two pointers compare equal if and only if both are null pointers, both are pointers to the same object(including a pointer to an object and a subobject at its beginning) or function, both are pointers to one past the last element of the same array object, or one is a pointer to one past the end of one array object and the other is a pointer to the start of a different array object that happens to immediately follow the first array object in the address space.</blockquote>

<p>List is an exhaustive. There are no provisions for two pointers being equal except that tiny loophole about <i>one past the end of one array object</i>. Some compiler authors tried to say to me that it's exactly what happens but that's clear attempt to just invent some plausible justification for harmful and pointless compiler behavior.</p>

<font class="QuotedText">&gt; even though its bit pattern might seem to suggest otherwise</font>

<p>Sorry, but no. Standard currently includes exactly and <b>precisely</b> one case where pointers with the same bit patterns may be treated differently: when you have two adjacent arrays and one pointer is pointer <i>one past the end of one array object</i> and another is <i>pointer to the start of a different array object that happens to immediately follow the first array object in the address space</i>.

<p>That's it. No other cases are allowed.</p>

<font class="QuotedText">&gt; I genuinely don't know what sanitizer would best help you avoid getting this wrong.</font>

<p>The correct answer: none of them. Sanitizers only catch tiny subset of undefined behaviors — and ubsan, in particular, mostly catches UBs which shouldn't be UBs in the first place.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862678/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862683"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 17:43 UTC (Mon)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/862683/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The realloc function …</font><br>
<p>
and its definition in the standard is irrelevant here. The simple reason for this is that there is no way to even *tell* the compiler that the pointer passed into realloc is invalid if (and only if) realloc returns NULL. Thus it has no business whatsoever blithely ignoring the pointer comparison; you could call a &quot;foobar&quot; function that does exactly the same thing.<br>
<p>
Would you deny that it&#x27;s a valid optimization to not update pointers to an object if it happens not to have been moved? same thing.<br>
<p>
The comparison after realloc tells the compiler that p and q are aliased to the same location. It bloody well should listen to that if it is supposed to not break existing code. Doing that is not rocket science. Anyway, please explain how the fact that a piece of code affects program flow but not the optimizer can possibly be anything but a bug. It&#x27;s not as if the C standard forbids aliased pointers. In fact there&#x27;s the &quot;restrict&quot; keyword which tells it that there&#x27;s no danger of aliasing, so why does it assume so in that keyword&#x27;s absence?<br>
<p>
The claim that comparing these two pointers can possibly be illegal makes no sense whatsoever IMHO, and I very much doubt that that was the intent of the C standards people. They might be misguided but they&#x27;re not *that* stupid.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862683/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 18:39 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862687/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; The simple reason for this is that there is no way to even *tell* the compiler that the pointer passed into realloc is invalid if (and only if) realloc returns NULL.</font>

<p>It's done <a href="https://github.com/llvm/llvm-project/blob/1aa02b37e7dcbf9fb35662fde8c65ac9a277f6b9/llvm/test/Transforms/InstCombine/realloc.ll">in the compiler sources</a>. The same way as with <code>memcpy</code>. You can even disable it the exact same way, by specifying <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:2,endLineNumber:11,positionColumn:2,positionLineNumber:11,selectionStartColumn:2,selectionStartLineNumber:11,startColumn:2,startLineNumber:11),source:'%23include+%3Cstdio.h%3E%0A%23include+%3Cstdlib.h%3E%0Aint+main()+%7B%0A++++int+*p+%3D+(int*)malloc(sizeof(int))%3B%0A++++int+*q+%3D+(int*)realloc(p,+sizeof(int))%3B%0A++++if+(p+%3D%3D+q)+%7B%0A++++++++*p+%3D+1%3B%0A++++++++*q+%3D+2%3B%0A++++++++printf(%22%25d+%25d%5Cn%22,+*p,+*q)%3B%0A++++%7D%0A%7D'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:100,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:cclang1200,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'1',trim:'0'),fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'-O2+-std%3Dc89+-fno-builtin-realloc',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x86-64+clang+12.0.0+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),k:49.99999999999999,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'Output+of+x86-64+clang+12.0.0+(Compiler+%231)',t:'0')),k:49.99999999999999,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',m:50,n:'0',o:'',t:'0')),l:'3',n:'0',o:'',t:'0')),version:4">-fno-builtin-realloc</a>. And then, of course, everything works.</p>

<font class="QuotedText">&gt; Thus it has no business whatsoever blithely ignoring the pointer comparison; you could call a "foobar" function that does exactly the same thing.</font>

<p>That's <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:26,endLineNumber:10,positionColumn:26,positionLineNumber:10,selectionStartColumn:26,selectionStartLineNumber:10,startColumn:26,startLineNumber:10),source:'%23include+%3Cstdio.h%3E%0A%23include+%3Cstdlib.h%3E%0A%0A__declspec(noinline)+void+*foobar(void+*ptr,+size_t+size)+%7B%0A++++return+ptr%3B%0A%7D%0A%0Aint+main()+%7B%0A++++int+*p+%3D+(int*)malloc(sizeof(int))%3B%0A++++int+*q+%3D+(int*)foobar(p,+sizeof(int))%3B%0A++++if+(p+%3D%3D+q)+%7B%0A++++++++*p+%3D+1%3B%0A++++++++*q+%3D+2%3B%0A++++++++printf(%22%25d+%25d%5Cn%22,+*p,+*q)%3B%0A++++%7D%0A%7D'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:50,l:'4',m:100,n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:ccl19_2015_u3_64,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'1',trim:'0'),fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:/O2,selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x64+msvc+v19.0+(WINE)+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">MSVC.</a> Don't mix them. Clang, at least, looks on the function name…</p>

<font class="QuotedText">&gt; Would you deny that it's a valid optimization to not update pointers to an object if it happens not to have been moved?</font>

<p>Indeed. But you would be naive you C compiler developers agreed. When I talked about this I was assured that it's absolutely not possible to do that. And if object is actually moved you can not traverse it and update insider pointers, too.</p>

<p>Instead you have to convert all insider pointers into indexes, store these indexes somewhere (but you can use unions to save space so could just copy then into <code>uintptr_t</code> which resides in the exact same place) and then turn indexes back into pointers (properly adjusted now).</p>

<p>And no, it's <b>not</b> a joke.</p>

<font class="QuotedText">&gt; It bloody well should listen to that if it is supposed to not break existing code.</font>

<p>Irrelevant (according to compiler developers). Existing code must be fixed as described above. The fact that it may force it to become slower (and much slower in some cases) is irrelevant, again. Unless it's part of some well-known benchmark, of course.</p>

<font class="QuotedText">&gt; It's not as if the C standard forbids aliased pointers.</font>

<p>C standard says something which is, as Linus would would say, is “total and utter crap”. On one hand it says this:</p>

<blockquote>Two pointers compare equal if and only if both are null pointers, both are pointers to the same object (including a pointer to an object and a subobject at its beginning) or function,both are pointers to one past the last element of the same array object, or one is a pointer to one past the end of one array object and the other is a pointer to the start of a different array  object  that  happens  to  immediately  follow  the  first  array  object  in  the  address space¹⁰⁹).</blockquote>

<p>But if you notice there's a footnote ¹⁰⁹). It says this:

<blockquote>Two  objects  may  be  adjacent  in  memory  because  they  are  adjacent  elements  of  a  larger  array  oradjacent members of a structure with no padding between them, or because the implementation choseto place them so, even though they are unrelated.  If prior invalid pointer operations (such as accesses outside  array  bounds)  produced  undefined  behavior, subsequent  comparisons  also  produce  undefined behavior.</blockquote>

<p>If you read it carefully you will realize that since accessing one-past-end-element is forbidden it <b>also</b> means that what the main body of the standard says is just not possible… but then why is it there?</p>

<p>The answer: C compiler developers <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_260.htm">got an approval from C standards committee</a> to add what they call 
“pointer provenance” to the C standard but since in 15 years they <b>still</b> were unable to invent sane rules which people would be able to understand… they only managed to add that one tiny footnote.</p>

<p>And they were unable to put anything else to the standard because C committee (unlike C++ committee) actually cares about correctness and just doesn't want to add complete an utter garbage to the standard (you can read about why it's complete and utter garbage <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">here</a>).

<font class="QuotedText">&gt; The claim that comparing these two pointers can possibly be illegal makes no sense whatsoever IMHO, and I very much doubt that that was the intent of the C standards people. They might be misguided but they're not *that* stupid.</font>

<p>True. They resisted more-or-less succesfully with both C11 and C18. But C/C++ compiler developers <b>are</b> that stupid. This now they are <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2577.pdf">trying again</a>.</p>

<p>And what is their reasoning, pray tell? Why, of course: <i>existing compilers already rely on the properties and thus standard have to be changed</i>!</p>

<p>I would have been somewhat sympathetic if the exact same prompt by C/C++ users WRT other controversial parts of the standard would not have been meet with derision and prompts to <s>burn the heretics</s> rewrite all the programs.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 18:40 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/862694/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And phrase &quot;The realloc function returns a pointer to the new object (which may have the same value as a pointer to the old object), or a null pointer if the new object has not been allocated&quot; is just a translation of that “easy to understand English” to modern “incomprehensible standartize English”.</font><br>
<p>
I think the root of the problem is that the &quot;easy to understand&quot; version of the C standard was ambiguous and contradictory. People writing C programs interpreted it one way (or one of several ways, depending on which paragraphs they read). People writing C compilers interpreted it a different way. That was a failure of the language specification and needed to be fixed.<br>
<p>
To fix the specification, they needed to come up with something closer to a formal specification of the language&#x27;s semantics. In the ambiguous cases there was a choice of specifying the behaviour that users expected, vs specifying the behaviour that compiler developers expected. But I suspect all users&#x27; mental models of the language&#x27;s semantics are not logically consistent - they&#x27;ll say &quot;example A should obviously output X&quot; and &quot;the compiler should obviously be able to optimise example B into assembly code Y&quot; even though it&#x27;s impossible for both to be true at once - because they&#x27;ve never had to think about the gnarly edge cases. That&#x27;s not an adequate basis for designing a specification.<br>
<p>
Compiler developers&#x27; mental models were a lot more complex, but also a lot closer to being logically consistent and complete, because they had already thought about most of those edge cases and invented new concepts and terminology so they could implement it in a way that balanced users&#x27; expectations of correctness and performance. Maybe it wasn&#x27;t the best balance, but at least it was based on a coherent set of rules that could be reasoned about. The language specification can take those concepts and rules and formalise them, so it can provide a single correct answer to the question of what a piece of code should do, and that answer is not incompatible with the optimisations that users expect their compiler to do. So it&#x27;s inevitable that the specification grew into being a compiler developer&#x27;s interpretation of the language, full of weird concepts and terminology that make it almost incomprehensible to regular users, because that&#x27;s the only way to formalise something that grew informally. It&#x27;s not good, but it&#x27;s better than leaving it ambiguous.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862696"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 19:22 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862696/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Compiler developers' mental models were a lot more complex, but also a lot closer to being logically consistent and complete, because they had already thought about most of those edge cases and invented new concepts and terminology so they could implement it in a way that balanced users' expectations of correctness and performance.</font>

<p>No. It was neither consistent nor complete. That's why they weren't able to add pointer provenance neither to C11 nor to C18. The <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2577.pdf">latest attempt is here</a>. Please note the dates.</p>

<font class="QuotedText">&gt; Maybe it wasn't the best balance, but at least it was based on a coherent set of rules that could be reasoned about.</font>

<p>Nope. Not even close. Kinda-sorta coherent models were developed (here is <a href="https://sf.snu.ac.kr/llvmtwin/">one attempt</a>) — but they don't match what the compilers are actually doing (<i>the new model requires a handful of problematic IR-level optimizations to be removed, but it also supports the addition of new optimizations that were not previously legal</i> is pretty telling, isn't it?) and, more importantly, it's not clear why they are supposed to be applicable to C89 or even C99 programs.</p>

<font class="QuotedText">&gt; So it's inevitable that the specification grew into being a compiler developer's interpretation of the language</font>

<p>It haven't done that yet. <b>Pointer provenance is not a thing</b> — even in C18 version of C standard.</p>

<font class="QuotedText">&gt; It's not good, but it's better than leaving it ambiguous.</font>

<p>Good for whom? Compiler writers? Maybe. It's bad for C users, definitely, but since they couldn't present anything better they had only one option: accept the standard or live without a compiler.</p>

<p>But now it looks as if accepting standard is not enough. <b>That</b> is the problem.</p>

<p>When the story was presented as <a href="https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html">“Semi-portable C” vs “Standard C”</a> this sounded like a sensible compromise: sure standard maybe harsh is some places, but hey, it's a standard!</p>

<p>Now, then we know that compiler developers don't feel themselves restricted by requirements of the standard the question arises: why then C users demands to change the standard are ignored? Hmm?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862696/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 21:44 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/862700/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The insistence that &quot;Pointer provenance is not a thing&quot; appears to be a false claim about reality. As you have noticed, programs written with your belief do not necessarily work. I think you&#x27;ve mentioned Defect Report #260 previously. Just as C programmers are often too clever for their own good, sometimes the standards committee is likewise and that&#x27;s reflected in #260. This also happened with the Memory Model, C++ 17 &quot;temporarily discouraged&quot; use of consume ordering because eh, it seemed like a good idea when it was invented and now it does not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862705"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 22:25 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862705/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; The insistence that "Pointer provenance is not a thing" appears to be a false claim about reality.</font>

<p>What kind of reality?</p>

<font class="QuotedText">&gt; As you have noticed, programs written with your belief do not necessarily work.</font>

<p>Yes. Compilers are broken. And now we even know there <b>broken not as an accident</b>. So?</p>

<font class="QuotedText">&gt; Just as C programmers are often too clever for their own good, sometimes the standards committee is likewise and that's reflected in #260.</font>

<p>Indeed. Instead of throwing away premature and unfinished ideas about how the so-called “pointer provenance” have to work they acquiesced to compiler writers demands (or,  more likely, an ultimatum, but I wasn't there and couldn't say for sure). Yet instead of saying that standard is wrong they just “came to a number of conclusions as to what it would be desirable for the Standard to mean”. IOW: they proposed that compiler developer would start developing some <b>sane</b> set of rules for the C users to follow.</p>

<p>Instead of doing <b>that</b> compiler developers went on to invent unproven, buggy and half-specified schemes which were, as they claim, permitted by DR260. Indeed even <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2577.pdf">latest proposal</a> from <b>last year</b> explicitly says <i>DR260 CR has never been incorporated in the standard text</i> and lament about the sad fact that DR260 only explicitly permits <i>track  the  origins  of  a  bit-pattern  and  [...]  may  also  treat pointers based on different origins as distinct even though they are bitwise identical</i></p>

<p>Which basically means: output from that <code>realloc</code> example is <b>still</b> buggy. Even if you would incorporate DR260 resolution into the standard — you <b>still</b> couldn't get output <code>1 2 </code> in question. The <b>most</b> you can get is elimination of comparison and the whole code which does operations after that branch.</p>

<p>Now, you may try to argue that compiler was clever enough to notice that the only situation where <code>p</code> is equal to <code>q</code> and both are valid… <a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(fontScale:14,fontUsePx:'0',j:1,lang:___c,selection:(endColumn:22,endLineNumber:6,positionColumn:22,positionLineNumber:6,selectionStartColumn:22,selectionStartLineNumber:6,startColumn:22,startLineNumber:6),source:'%23include+%3Cstdio.h%3E%0A%23include+%3Cstdlib.h%3E%0Aint+main()+%7B%0A++++int+*p+%3D+(int*)malloc(sizeof(int))%3B%0A++++int+*q+%3D+(int*)realloc(p,+sizeof(int))%3B%0A++++if+(q+!!%3D+NULL+%26%26+p+%3D%3D+q)+%7B%0A++++++++*p+%3D+1%3B%0A++++++++*q+%3D+2%3B%0A++++++++printf(%22%25d+%25d%5Cn%22,+*p,+*q)%3B%0A++++%7D%0A%7D'),l:'5',n:'0',o:'C+source+%231',t:'0')),k:100,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:cclang1200,filters:(b:'0',binary:'0',commentOnly:'0',demangle:'0',directives:'0',execute:'0',intel:'0',libraryCode:'1',trim:'0'),fontScale:14,fontUsePx:'0',j:1,lang:___c,libs:!(),options:'-O2+-std%3Dc89',selection:(endColumn:1,endLineNumber:1,positionColumn:1,positionLineNumber:1,selectionStartColumn:1,selectionStartLineNumber:1,startColumn:1,startLineNumber:1),source:1),l:'5',n:'0',o:'x86-64+clang+12.0.0+(Editor+%231,+Compiler+%231)+C',t:'0')),header:(),k:49.99999999999999,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,fontScale:14,fontUsePx:'0',wrap:'1'),l:'5',n:'0',o:'Output+of+x86-64+clang+12.0.0+(Compiler+%231)',t:'0')),k:49.99999999999999,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',m:50,n:'0',o:'',t:'0')),l:'3',n:'0',o:'',t:'0')),version:4">nope, no cigar</a></p>

<font class="QuotedText">&gt; This also happened with the Memory Model, C++ 17 "temporarily discouraged" use of consume ordering because eh, it seemed like a good idea when it was invented and now it does not.</font>

<p>Yes, but at least there some memory model <b>was actually accepted</b> and <b>added to the text of standard</b>. Nothing like that happened with DR260.</p>

<font class="QuotedText">&gt; it seemed like a good idea when it was invented and now it does not.</font>

<p>And I would argue that “pointer provenance” was a very bad idea and shouldn't brought to the realms of C as unconditional property. <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2263.htm">Previous proposal</a> at least tried to acknowledged that and proposed two modes, test macros and so on.</p>

<p>But it was rejected. Most likely because it was “too much work” to implement.</p>

<p>So… it's too much work for the compiler writers to implement <code>-fno-provenance</code> switch yet reviewing and rewriting billions lines of code to make them compliant with new “optimizations” (which break code which was acceptable for decades) is not “too much work”? WTH?</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862705/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862727"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2021 13:13 UTC (Tue)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/862727/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What kind of reality?</font><br>
<p>
This kind. Where your program doesn&#x27;t do what you expected.<br>
<p>
C and C++ are ISO standards. But, ISO standards are just written documents. One of the insights of the IETF is appropriate here. If there&#x27;s a standards document which says X, but everybody does Y, then X is not in fact the standard. But worse than that, the standards document might (hopefully inadvertently) say that 2+2=5, and even if everybody tries very hard to obey that standard they can&#x27;t.<br>
<p>
For some of the ISO standards the difference between what the text says, what it is understood to mean, and what is practical, is negligible. ISO 216 A-series paper sizes are simple enough that this works.<br>
<p>
But C++ is very far from that. So, the C++ standards document says words, but in some cases those words turn out to be incoherent nonsense (like 2+2=5) as happened for the Memory Model. In other cases, as here with pointers, the words imply that C++ is a language whose correct implementation has terrible performance. But nobody wants terrible performance (sometimes in this sort of forum they&#x27;ll _say_ they want terrible performance, but then immediately they demand a way to &quot;opt out&quot; and they never switch it off) so what you&#x27;ll actually get is not that language.<br>
<p>
For years Java had to pretend there was a special &quot;less strict&quot; interpretation of how floating point numbers work distinct from how they&#x27;re documented in the actual language standard, which was optional and might be (read: was) switched on for some (read: Intel architecture) platforms. Eventually the terrible Intel x87 FPU was obsolete and Java removed this &quot;feature&quot; entirely. It was a necessary evil, until it wasn&#x27;t, and then it was gladly killed.<br>
<p>
Anyway, not only do you have the problem that C++ as-it-is-compiled is not the written standards document, because rooms full of people translating your C++ into assembly language would be a horror show -- but worse, the optimizers, which you can&#x27;t live without, do not actually optimise C++. They have an Intermediate Representation and optimize that.<br>
<p>
One of the things that makes some people unhappy about Rust is that it doesn&#x27;t have a written standard. If you&#x27;ve got an unjustifiable faith in the power and correctness of standards documents this can feel like a big obstacle. But in truth Rust&#x27;s bigger obstacle isn&#x27;t the lack of a standards document for Rust the programming language, but for the LLVM IR. Everybody is agreed that Rust has different semantics from C++ and so it needs to express those in the LLVM IR. Famously for example infinite loops aren&#x27;t a thing in C++ (forward progress is mandatory, sometimes the compiler can&#x27;t be sure if there is progress and so the running program is actually an infinite loop, but if it knew that it would elide the loop entirely) so Clang needn&#x27;t express &quot;this is an infinite loop&quot; because there aren&#x27;t any in C++ whereas in Rust they&#x27;re a thing, so rustc needs to express that and have LLVM produce correct code for an infinite loop. But, since the IR is not formally standardised, there is no analysis which says the optimisations actually work on the IR, only that they seem to work for C++. Sometimes a C++ programmer will optimise the IR in a way that deletes Rust&#x27;s infinite loop. Oops.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862727/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862729"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2021 14:41 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862729/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; If there's a standards document which says X, but everybody does Y, then X is not in fact the standard. But worse than that, the standards document might (hopefully inadvertently) say that 2+2=5, and even if everybody tries very hard to obey that standard they can't.</font>

<p>Except that's <b>not</b> what I hear when I bring the question of overflowing shift or <code>nullptr</code> arithmetic.</p>

<p>When I bring this up and ask for some <b>sanity</b> (like: I don't care what <code>i &lt;&lt; 32</code> would be as long as <code>(i &lt;&lt; 32) &amp; 0</code> is still <code>0</code>) the answer is always the same: <i>“holy standard” proclaimed that's an UB, thus go away and not bother us with triflities, fix your program instead</i> (it's usually more polite, but idea is always the same).</p>

<p>I'm more than willing to discuss things like this with Rust developers because they:</p>
<ol>
<li><a href="https://rust-lang.github.io/rfcs/0560-integer-overflow.html">Explain their decisions in plain English</a>.</li>
<li><a href="https://doc.rust-lang.org/std/primitive.u32.html#method.checked_shl">Offer me an alternative which I may use instead.</a></li>
</ol>

<p>I would have been willing to discuss that with C/C++ developers if <b>they</b> wouldn't have brought sayings from “holy standard” into discussions about how should I deal with <code>mmap</code> or shift-by-32 but treated these questions like IETF (or Rust developers) treat.</p>

<p>At times it felt like I'm talking with devout Jews who are believing that all the answers can be found in Torah. It looked somewhat acceptable (if tiring after same time) if they were <b>actually</b> devout believers and <b>actually</b> tried to follow their “holy scripture”.</p>

<p>But when they started talking about pointer provenance and brought <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_260.htm">DR260</a> which is 2004 year decision <b>not incorporated</b> into their “holy scripture” in the course of last <b>15 years</b> (and two published standards)… I have realized the depth of hypocrisy. They were <b>knowingly</b> breaking standard-compliant programs <b>for more than decade</b> while <b>simultaneously preaching standard as the source of truth</b>.</p>

<font class="QuotedText">&gt; But C++ is very far from that.</font>

<p>Maybe, but that's not what C/C++ compiler developers say usually. You can't have you cake and eat it too. Well… you can <b>try</b> but when you would be, eventually, caught, you would lose what little trust you had.</p>

<font class="QuotedText">&gt; For years Java had to pretend there was a special "less strict" interpretation of how floating point numbers work distinct from how they're documented in the actual language standard, which was optional and might be (read: was) switched on for some (read: Intel architecture) platforms. Eventually the terrible Intel x87 FPU was obsolete and Java removed this "feature" entirely. It was a necessary evil, until it wasn't, and then it was gladly killed.</font>

<p>But note that both Strict or Nonstrict Floating-Point Arithmetic was described in books and present from the beginning. It was nothing like what C/C++ compiler developers are trying to do with their “we don't even yet know themsleves the rules in year 2020 but let's pretend they were already there in C in 1989 and demand that C users obey them”.</p>

<font class="QuotedText">&gt; If you've got an unjustifiable faith in the power and correctness of standards documents this can feel like a big obstacle.</font>

<p>I don't. But C/C++ compiler developers do. Except when it doesn't suit them. <b>That</b> is the problem.</p>

<p>Basically: “if compiler user violated the standard and program was miscompiled then it's fault of said user and there would be no lenience” simultaneously “if compiler violated the standard and program was miscompiled then it's fault of the standard and standard (and <b>not</b> the compiler) would be fixed” stance is flat out unacceptable.</p>

<font class="QuotedText">&gt; But in truth Rust's bigger obstacle isn't the lack of a standards document for Rust the programming language, but for the LLVM IR.</font>

<p>Well… LLVM IR simultaneously with the need for optimizations. Rust without optimizations <a href="https://blog.akquinet.de/2020/10/09/yes-rust-has-garbage-collection-and-a-fast-one/">is not viable</a> which means that for the foreseeable future it would have to consider limitations of LLVM. That's serious problem but as long as Rust developers are trustworthy and don't adopt the C/C++ developers “it's my way or the highway” stance it's manageable.</p>

<font class="QuotedText">&gt;  Sometimes a C++ programmer will optimise the IR in a way that deletes Rust's infinite loop. Oops.</font>

<p>Oops indeed. But I think if Rust would adopt the stance similar to what Java had as explicitly say: “here is what may happen because we rely on the untrustworthy LLVM” then people would accept that.</p>

<p>Maybe some time down the road Rust would be big enough to afford completely separately compiler and these warts could be fixed for real, but noone expects them to do the impossible. Because <b>they</b> in turn don't demand the impossible from compiler users.</p>

<p>In fact Rust developers tell that <b>explicitly</b>: <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">we need better language specs</a>. They admit the fact that <code>unsafe</code> Rust is underspecified and they couldn't <b>actually</b> explain how and what can be done in it safely.</p>

<p>But for them <b>it's a problem</b>. They don't pretend that <b>everything's peachy, Rust users would follow the rules even we couldn't even write these rules themselves</b>.</p>

<p>On the other hand C/C++ compiler developers made standard text sacred by constant insistence that we should ignore everything and anything when we talk about C/C++ programs (“POSIX, x86/ARM/RISC-V architecture specs and so on are all irrellevant and <b>must</b> be ignored, if you want to change even one jot your have to change the standard first”  was their persistent public stance <b>for years</b>).</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862729/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862798"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">realloc</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2021 23:12 UTC (Tue)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/862798/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW, the handling of infinite loops in LLVM IR was codified late last year with the addition of the &quot;mustprogress&quot; function and loop attribute in LLVM IR, whereby languages which want to require forward progress must explicitly opt into the requirement. (&quot;forward progress&quot; being defined by the C and C++ standards, e.g. <a href="https://eel.is/c++draft/intro.progress">https://eel.is/c++draft/intro.progress</a> for C++).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862798/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor863885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer provenance</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2021 19:32 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/863885/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;ll note these two papers for the C++ committee which describe and propose resolutions to the provenance issue (for C++):<br>
<p>
P1726R5 (describing the problem)<br>
P2414R0 (proposed solutions)<br>
<p>
I believe they are publicly available, but in an abundance of caution, I&#x27;ll leave them unlinked in case they are not (but those with access should be able to find them given these IDs).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863907"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pointer provenance</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2021 2:14 UTC (Thu)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/863907/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://wg21.link/P1726R5">https://wg21.link/P1726R5</a><br>
<a href="https://wg21.link/P2414R0">https://wg21.link/P2414R0</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863907/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor863087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 21:04 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863087/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why does it even say that it may have the same value as a pointer to the old object if I couldn&#x27;t use that fact for anything?</font><br>
<p>
One pointer is valid and the other isn&#x27;t because of the semantics of reallocating memory. I think that part is reasonable, pointers are unrelated and one, from the point of view of the user, has been freed. However, the runtime can use the fact that their value may be the same: malloc will often have arenas of fixed size regions (depending on implementation, of course); your allocated memory may come from an area bigger than the size you requested or, as in your example, be the same size. You may also be trying to shrink, so the contents of the new region can fit the old region anyway. Explicitly allowing the value of the pointer to be the same is what allows this, avoiding looking for another chunk of memory and copying the contents of your previous buffer to a new one. And in this case the performance win could be significant, a lot of processing goes just into copies in some workloads.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 22:32 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863092/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; I think that part is reasonable, pointers are unrelated and one, from the point of view of the user, has been freed.</font>

<p>Except there are no such thing in C as “pointers that are equal yet one is valid and the other is not”. Except for one case where you have no right to even attempt to compare them.</p>

<p>Here is the full exhaustive list from latest draft (identical to C18):

<blockquote>Two pointers compare equal if and only if both are null pointers, both are pointers to the same object(including a pointer to an object and a subobject at its beginning) or function, both are pointers to one past the last element of the same array object, or one is a pointer to one past the end of one array object and the other is a pointer to the start of a different array object that happens to immediately follow the first array object in the address space¹¹¹)</blockquote>

<p>Some Clang developers even tried to claim that after call to <code>realloc</code> “old pointer” have become pointer to “one past the end of the array”, but no, C18 removed all doubts but adding that note:

<blockquote>Two objects may be adjacent in memory because they are adjacent elements of a larger array or adjacent membersof a structure with no padding between them, or because the implementation chose to place them so, even though they are unrelated.  If prior invalid pointer operations (such as accesses outside array bounds) produced undefined behavior, subsequent comparisons also produce undefined behavior.</blockquote>

<font class="QuotedText">&gt; However, the runtime can use the fact that their value may be the same</font>

<p>I don't care about what runtime does. It's not really important here. I only care about what standard says:</p>

<blockquote>The <code>realloc</code> function returns a pointer to the new object (which may have the same value as a pointer to the old object), or a null pointer if the new object has not been allocated.</blockquote>

<p>See? The fact that I can compare these two pointers and they can be identical is spelled there <b>explicitly</b>. It's <b>part of the standard text</b>, not something I may want to see there. And then, when standard talks about pointer equality it explains what that does mean: it means that they either point to the same object <b>or</b>, alternatively, both of them are pointers to one past the end. One additional possibility is not really allowed because it would trigger UB which would make <b>explicit</b> permission to compare these two pointers invalid.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 15:54 UTC (Sat)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863272/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Except there are no such thing in C as “pointers that are equal yet one is valid and the other is not”. Except for one case where you have no right to even attempt to compare them.</font><br>
I&#x27;m not talking about how C defines them on the letter, I&#x27;m talking about what&#x27;s reasonable. You realloc something, your chunk of memory is not the same from the POV of your application. I&#x27;m talking about the high level in the quoted part. It can be argued that a pointer just points to memory and is thus just the number, but I don&#x27;t think it&#x27;s entirely clear that it has to be just the number.<br>
<p>
<font class="QuotedText">&gt; Some Clang developers even tried to claim that after call to realloc “old pointer” have become pointer to “one past the end of the array”, but no, C18 removed all doubts but adding that note:</font><br>
Yeah, that sounds just like mental gymnastics. Just admit you&#x27;re making an exception for performance, there&#x27;s nothing in the semantics of realloc that make you think somehow it becomes &quot;one past the end of the array&quot;.<br>
<p>
    Two objects may be adjacent in memory because they are adjacent elements of a larger array or adjacent membersof a structure with no padding between them, or because the implementation chose to place them so, even though they are unrelated. If prior invalid pointer operations (such as accesses outside array bounds) produced undefined behavior, subsequent comparisons also produce undefined behavior.<br>
<p>
<font class="QuotedText">&gt; I don&#x27;t care about what runtime does. It&#x27;s not really important here. I only care about what standard says:</font><br>
<p>
<font class="QuotedText">&gt; The realloc function returns a pointer to the new object (which may have the same value as a pointer to the old object), or a null pointer if the new object has not been allocated.</font><br>
<p>
<font class="QuotedText">&gt; See? The fact that I can compare these two pointers and they can be identical is spelled there explicitly. It&#x27;s part of the standard text, not something I may want to see there. And then, when standard talks about pointer equality it explains what that does mean: it means that they either point to the same object or, alternatively, both of them are pointers to one past the end. One additional possibility is not really allowed because it would trigger UB which would make explicit permission to compare these two pointers invalid.</font><br>
<p>
I see. My understanding of your claim was precisely that the standard said something about the lines even tho the numeric value (emphasis in numeric) may be the same, the pointers were not equal. That would allow to make that distinction. But the fact the value can be the same is most likely because that allows the runtime to allocate extra space the first time and reuse the same chunk. Most often than not, the standard defines things thinking about how it&#x27;ll help implementors and users (maybe not so much recently). But yeah, it says &quot;value&quot;, not &quot;numeric value&quot;, which wouldn&#x27;t imply they are equal. Like, (uintptr_t)old == (uintptr_t)new but old != new.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 16:09 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863274/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; You realloc something, your chunk of memory is not the same from the POV of your application.</font>

<p>Why is not <i>not the same</i>? On the contrary: it <b>is</b> the same. I have verified that.</p>

<font class="QuotedText">&gt; I'm talking about the high level in the quoted part.</font>

<p>And I'm talking about explicit mention about the possibility of <i>in</i> pointer being the same as <i>out</i> pointer. Why is it there? What can one <b>do</b> with that information? How can I <b>use</b> it?</p>

<p>I assume that standard writers weren't insane and haven't been adding some notes just to make standard bigger and more complex. So what's <b>the reason</b> to include that note as <b>part of the interface</b>?</p>

<font class="QuotedText">&gt; My understanding of your claim was precisely that the standard said something about the lines even tho the numeric value (emphasis in numeric) may be the same, the pointers were not equal.</font>

<p>But these are just wet dreams of C/C++ compiler developers. Right now standard <b>doesn't</b> allow for the possibility of two pointers being equal <b>and comparable</b> and yet them being different.</p>

<p>One concession which standard did in C11 was to declare some pointer comparisons as being UB (e.g. you are not supposed to compare one-past-the-end-pointer to “normal” pointer… that comparison is UB).</p>

<font class="QuotedText">&gt; Just admit you're making an exception for performance, there's nothing in the semantics of realloc that make you think somehow it becomes "one past the end of the array".</font>

<p>Except to claim this they would need to show at least one real-world example where it have improved performance. So far nothing was shown thus we may safely assume all that code was added specifically to break otherwise good programs and there are no other reason.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/863274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863304"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 3:32 UTC (Sun)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863304/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why is not not the same? On the contrary: it is the same. I have verified that.</font><br>
For a start, because for your application they don&#x27;t (usually) have the same size.<br>
<p>
<font class="QuotedText">&gt; And I&#x27;m talking about explicit mention about the possibility of in pointer being the same as out pointer. Why is it there? What can one do with that information? How can I use it?</font><br>
<font class="QuotedText">&gt; I assume that standard writers weren&#x27;t insane and haven&#x27;t been adding some notes just to make standard bigger and more complex. So what&#x27;s the reason to include that note as part of the interface?</font><br>
Again, because that allows runtime writers to reduce the cost of calling realloc, that&#x27;s why it&#x27;s mentioned. But you&#x27;re right in that clang breaks this rule, I think I mentioned it in the quoted comment.<br>
<p>
<font class="QuotedText">&gt; But these are just wet dreams of C/C++ compiler developers. Right now standard doesn&#x27;t allow for the possibility of two pointers being equal and comparable and yet them being different.</font><br>
Yep, I got that.<br>
<p>
<font class="QuotedText">&gt; One concession which standard did in C11 was to declare some pointer comparisons as being UB (e.g. you are not supposed to compare one-past-the-end-pointer to “normal” pointer… that comparison is UB).</font><br>
I always thought that was there for C89 already. The more you know.<br>
<p>
<font class="QuotedText">&gt; Except to claim this they would need to show at least one real-world example where it have improved performance. So far nothing was shown thus we may safely assume all that code was added specifically to break otherwise good programs and there are no other reason.</font><br>
Indeed. But saying that is already an improvement compared to just intentionally misinterpreting the standard. At least it&#x27;s a lie that the infinite sea of possibilities makes impossible to really disprove.<br>
Regarding intention, I addressed in a different comment that there&#x27;s a lot of other possibilities that can explain bad decisions.<br>
<p>
Sorry for answering everything even when I&#x27;m just acknowledging I agree with you now that I understand better what you say. It just seemed rude not to.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863304/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 16:55 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/863470/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; Why is not not the same? On the contrary: it is the same. I have verified that.</font><br>
<p>
<font class="QuotedText">&gt; For a start, because for your application they don&#x27;t (usually) have the same size.</font><br>
<p>
????<br>
<p>
Not particularly elegant programming, but it&#x27;s quite possible that a programmer (a) knows how much space he needs but (b) does not know how much space he&#x27;s got. So he does a realloc for &quot;safety&#x27;s sake&quot;. The data portion of a linked list, for example. If the majority of your data elements are the same size that could easily result in a lot of reallocs of the same size.<br>
<p>
(If I want to throw away the current value in the list, and replace it with a new one, a safety realloc is much quicker than parsing the value to find out whether I need to realloc ...)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor863476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 17:38 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863476/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt;  I always thought that was there for C89 already. The more you know.</font>

<p>Nope. It was only added in C11. And that was done sloppily: main body of text still says that says that 
“pointers are equal only if they point to the same object but since one-past-the-end pointer doesn't point to any object it may be identical to the other pointer which points to <b>actual</b> object”… then footnote (added in C11 only) turns that logic on it's ear and says “hey, but you are not supposed to compare pointer which doesn't point to anything to another pointer which points to something”.</p>

<p>I think you are confused about different place where standard says about <b>pointers ordering</b>. Indeed, pointer arithmetic and &lt; or &gt; pointer comparisons are only defined for pointers which point to the elements of the same array, but equality/unequality couldn't work like that or else you would make many complex data structures (like <a href="https://gist.github.com/santisbon/42580049705ba3d8fbef7168e4668e3c">Linus list with root node instead of nullptr</a>) invalid.</p>

<p>Actually, if you think about it, C89 definition contradicts even MS-DOS memory model where 0x0040:0x0000 and 0x0000:0x0400 pointers point to the exact same memory yet are not identical (but then MS-DOS compilers included <code>huge</code> memory model where they were conformant and other memory models were easily understood by programmers even if they were not 100% C89 conformant).</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/863476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor863098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 22:58 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863098/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; And in this case the performance win could be significant, a lot of processing goes just into copies in some workloads.</font>

<p>That's another interesting question: what kind of workload can that “optimization” make faster? What application? What benchmark?</p>

<p>Yes, I think you may try to invent some kind of benchmark which would become faster, but then, it's <b>much</b> easier to invent something which would become slower if you do crazy turn-pointers-into-indexes-then-call-<code>realloc</code>-then-turn-them-back-into-pointers dance, and I <b>quite literally</b> know exactly <b>zero</b> programs which become faster or smaller. Clang developers were unable to present anything either, they were too busy inventing excuses.</p>

<p>Basically AFAICS this change does exactly and precisely two things:
<ol>
<li>It miscompiles some [rare] real-world programs and makes them incorrect.</li>
<li>Changes which it imposes on C developers almost always make programs slower and never, not for <b>any</b> real-world application make them faster.</li>
</ol>

<p>Thankfully this particular “optimization” can be easily disable in clang with <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVAB9LclIj2yAnjqVMtdAGFUrAK4BbWiABMpU%2BgAyeWpgBydgEaYxFycpAAOqEKERrSWNvZOYRFRdB5evrYBQZwhepgG0QwEzMQEsXYOzrn5dIXFBKk%2B/oHBukUlZfGVbfWejRnN2QCUuqjWxMgcUgCkjgDMnsg2WADUU7PmQgT4qAB0CGvYUzIAgjPztIvWK2sbW6x4fnsHR8eeBMu2zJ4Qg6sA7AAhF7LEHLN7LABUoVWswAIssIG8IYNPqxWKhkBBIgAvTCoKiI%2BiDQZrIEnUFg%2BiQgCOMPhhIIyOImDY6MxoVIyxxeIJb2JpOBoLwVAR0LWsPFy2pvymgMFFJBULpy04AvJCsVtMljjVxw1INCxDeBJmOscAFZ0KsLegpubzLRTZyoc7pbqKbKJSdPVJhqxpOb5A5ZPJUNJzFzRuNMNbZpx5ARpHJiaQANYgWazHaZnO5vMANhU0m48lsXBkMlIwbkpDDUnkQhAlcTIeGcFgMEQKFQtlCeHYZAoEDQvf7zWQizUwE4jgrfH7BECjYgfiT8j8nmKAE816QR7ZTAQAPK0Vg7kOkLCfdTsXf4Zn5ABumEbF8w4jy1kXu7emH9F/uPxiG3SwsGkeNSAII0y1bPg6EYFhbx4ODBBECRdyUEJVHUEAtA0HRAMbSBhlQUJDDoV8AFoj0cZZKM2W04WQAAOABOBs/zyciHAgVwOgcEJXAadJMmUcJIm4/ixKSbjhKaLJdE46paFqdorHKZQqm41SejSeTNO6KScm6OT%2BiyYYhCjCYuD9AMg13OtxGY/NKPzbhlkndQVUcHYZF8hFcEIEhYxCZZLFHAcQt%2BcwEzXFMEBZLAgh%2BNMMyzPMMpzQt/xLUgy3NStq1DaQGybSC4tIdsuxHPsB3ISgarHIIJ2w6dZ0rKgFyXShVwvDdaG3Xd90PE8zzvTBr2AW8L3vLi8GfV8a3fT9vwvX9/xrQDgOILdQMmCCoLwGDkxQhC2A4ZD%2BAIYQxEkC8lGcVrcO0FQHiIlLSO4qiaLohjxRY1i6KoWhUEovxrAXTxKOZVkMQ4/RuJMMwjJcMxTNEkJxOSGJ1PiTGZOidGBkUhGCkM3GBJJuaahM3oROJzY6hRxmSiJ8yRjGazOFsqRAyrBzpCcly3I81rvN8/yIECohiBCzlwtqwJY0caLYtbYYEuYJLKB53L8sKgX610MqW2TYZ00zbNMoy7LpFmeyLzrNWTqq12kFGAhQi/erhx7RWFMwfAZeUK6mHOrheCum70IvAB3YDQnA30i15h2azrI8vy9958WWIXXPczzgHFvyZARBWmqi53fXNtKret3MU71kACv5x2SuN5sKrdkAPezn3GoHBJA6ChTQ8Qi7I/g6O7prePmETqR4x5vmitraRM89r9llz/ORaLkvJYryKzhV6v4sS5oUpy0sW4N9ujcbLv1dSy2G7zFP7bb9OO9NmuU8cGnYqRs/4pmfMQSIxhuBAA">-fno-builtin-realloc</a> thus it's effect is easy to benchmark.</p>

<p>I <b>sincerely</b> hope it wasn't done with an explicit goal to make C developers life miserable (this would imply C compiler developers are real sadists which is disturbing discovery if true), but I couldn't see any other reason for that “optimization” to exist. Maybe I don't understand something.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863273"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 16:03 UTC (Sat)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863273/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That&#x27;s another interesting question: what kind of workload can that “optimization” make faster? What application? What benchmark?</font><br>
realloc heavy loads. You append quite a lot to an array. realloc can be clever and allocate exponentially for bigger buffers. That is much faster. I know that much by experience, by having to mitigate a performance bug where someone made an array of key-values rather than make a hashmap. I didn&#x27;t have the time to fix it properly, so I both appended where I knew the key wasn&#x27;t previously defined and used exponential alloc.<br>
<p>
<font class="QuotedText">&gt; Yes, I think you may try to invent some kind of benchmark which would become faster, but then, it&#x27;s much easier to invent something which would become slower if you do crazy turn-pointers-into-indexes-then-call-realloc-then-turn-them-back-into-pointers dance, and I quite literally know exactly zero programs which become faster or smaller. Clang developers were unable to present anything either, they were too busy inventing excuses.</font><br>
No, because provenance doesn&#x27;t generally propagate to runtime. It&#x27;s something the compiler uses to try to be more clever than it should, apparently, not some kind of instrumentation.<br>
<p>
<font class="QuotedText">&gt;    It miscompiles some [rare] real-world programs and makes them incorrect.</font><br>
We agree that&#x27;s the current use case, yes. But that doesn&#x27;t have a lot to do with the concept of provenance. Also, I have yet to see an example where you would want to make that comparison. Yes, if you do, it misbehaves. Why did you do it in the first place?<br>
<font class="QuotedText">&gt;    Changes which it imposes on C developers almost always make programs slower and never, not for any real-world application make them faster.</font><br>
Casting is literally free on runtime. It&#x27;s an annoyance, yes, but it doesn&#x27;t affect runtime in any reasonable implementation.<br>
<p>
<font class="QuotedText">&gt; Thankfully this particular “optimization” can be easily disable in clang with -fno-builtin-realloc thus it&#x27;s effect is easy to benchmark.</font><br>
I see the same code in both sides. So no problem?<br>
<p>
<font class="QuotedText">&gt; I sincerely hope it wasn&#x27;t done with an explicit goal to make C developers life miserable (this would imply C compiler developers are real sadists which is disturbing discovery if true), but I couldn&#x27;t see any other reason for that “optimization” to exist. Maybe I don&#x27;t understand something.</font><br>
This is just paranoia. You had good points before this, I don&#x27;t intend this as an ad hominem. But you should probably keep it in check, from a person with a mental illness to one who may or may not have one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863273/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 17:36 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863276/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>I think we are talking past each other. When I'm asking about “optimization” I'm <b>not</b> talking about realloc <b>implementation</b>.</p>

<p>I <b>know</b> when <code>realloc</code> can leave things untouched and why. That's not the interesting case.</p>

<p>The interesting case is an “optimization” enabled with <code>-fbuiltin-realloc</code>. The one which forbids user to compare <code>p</code> and <code>q</code> and says that you can't use pointers to the “old” realloced object. What does <b>that one</b> improve?</p>

<font class="QuotedText">&gt; It's something the compiler uses to try to be more clever than it should, apparently, not some kind of instrumentation.</font>

<p>Precisely. And now I can't just do a simple <code>q == p</code> check to see if object is unmoved. I have to, basically, always do <code>p = q</code> assignment (if <code>q</code> is not <code>nullptr</code>) but what's more important: I can't keep pointers to “old” realloced object <b>anywhere</b>. If I have some other pointers (besides <code>p</code>) and, especially, if I have “internal” pointers (which point to the inside of that object) then I have to turn <b>them all</b> into indexes and then traverse everything after <code>realloc</code> <b>again</b> and turn these indexes back to pointers!</p>

<p>Now, I can <b>easily</b> imagine where such “compiler appease dance” can introduce slowdowns (even if <code>realloc</code> is clever and allocates exponentially for bigger buffers, etc).</p>

<p>But where the heck that dance imposed on me by C compiler developers <b>helps</b>? What kind of program? What benchmark? Can you show me <b>anything at all</b> where <code>-fbuiltin-realloc</code> is faster than <code>-fno-builtin-realloc</code>?</p>

<font class="QuotedText">&gt; But that doesn't have a lot to do with the concept of provenance.</font>

<p>It has <b>everything</b> to do with the concept of provenance. What <code>-fbuiltin-realloc</code> option does is tells the compiler: “if someone does <code>q = realloc(p, …)</code> then you can assume that <code>p</code> and <code>q</code> have different provenance, they could never alias (not even after explicit <code>p == q</code> check) and you can optimize on basis of that”.</p>
 
<p>The one thing (and very big thing for me): WTH can you use that assertion for? What kind of code should we observe for that rule to speed up <b>anything</b>?</p>

<font class="QuotedText">&gt; Casting is literally free on runtime. It's an annoyance, yes, but it doesn't affect runtime in any reasonable implementation.</font>

<p>Casting itself is free. But because new “optimized” rules demand that you find and convert <b>all</b> pointers before you call <code>realloc</code> you would need <b>additional code</b> which would traverse additional data structures and scans all these pointers.</p>

<p>And <b>after</b> <code>realloc</code> you have to traverse all these data structures <b>again</b> and turn indexes back into pointers.</p>

<p>Not only that adds additional code which complicates logic, there are no guarantee that this code would be optimized away by the compiler (and in some cases, when external functions are involved, it <b>couldn't be removed</b>).</p>

<font class="QuotedText">&gt; I see the same code in both sides.</font>

<p>It's not the same. Version with <code>-fbuiltin-realloc</code> does this:
<pre>
 mov esi,0x1
 mov edx,0x2
 xor eax,eax
 call 401030 &lt;printf@plt&gt;
</pre>

<p>Version with <code>-fno-builtin-realloc</code> does this:
<pre>
 mov esi,0x2
 mov edx,0x2
 xor eax,eax
 call 401030 &lt;printf@plt&gt;
</pre>

So yeah, code is very similar except <code>-fbuiltin-realloc</code> one is broken while <code>-fno-builtin-realloc</code> works.</p>

<p>But lots of people claim it's “an optimization”. It's supposed to “improve” something. So…  what, where and how does it improve?</p>

<font class="QuotedText">&gt; This is just paranoia.</font>

<p>If that's a paranoia then surely it would be easy for you to show something which benefits from <code>-fbuiltin-realloc</code>. Anything at all, I'm not that picky, if you don't have a real-world app I can even accept some contrived artificial example for the start.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/863276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863303"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 3:24 UTC (Sun)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863303/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think we are talking past each other.</font><br>
Oh no, I was just explaining where my confusion came from, but we were on the same page by that comment :)<br>
<p>
<font class="QuotedText">&gt; The interesting case is an “optimization” enabled with -fbuiltin-realloc. The one which forbids user to compare p and q and says that you can&#x27;t use pointers to the “old” realloced object. What does that one improve?</font><br>
And we agreed it doesn&#x27;t improve anything.<br>
<p>
<font class="QuotedText">&gt; Precisely. And now I can&#x27;t just do a simple q == p check to see if object is unmoved. I have to, basically, always do p = q assignment (if q is not nullptr) but what&#x27;s more important: I can&#x27;t keep pointers to “old” realloced object anywhere. If I have some other pointers (besides p) and, especially, if I have “internal” pointers (which point to the inside of that object) then I have to turn them all into indexes and then traverse everything after realloc again and turn these indexes back to pointers!</font><br>
You have a great point. I didn&#x27;t think about the internal pointers that get invalidated. The check saves you that iteration, but now you can&#x27;t.<br>
<p>
<font class="QuotedText">&gt; But where the heck that dance imposed on me by C compiler developers helps? What kind of program? What benchmark? Can you show me anything at all where -fbuiltin-realloc is faster than -fno-builtin-realloc?</font><br>
No, I&#x27;m not defending whatever nonsense they introduced.<br>
<p>
<font class="QuotedText">&gt; It has everything to do with the concept of provenance. What -fbuiltin-realloc option does is tells the compiler: “if someone does q = realloc(p, …) then you can assume that p and q have different provenance, they could never alias (not even after explicit p == q check) and you can optimize on basis of that”.</font><br>
I picked the wrong words. What I meant is that, while the concept provenance is what allows this behavior, and provenance by itself makes sense, it&#x27;s still a stupid thing to do. It doesn&#x27;t mandate it, and you know, the fact that you can do something doesn&#x27;t mean it&#x27;s a good idea.<br>
<p>
<font class="QuotedText">&gt; The one thing (and very big thing for me): WTH can you use that assertion for? What kind of code should we observe for that rule to speed up anything?</font><br>
I can&#x27;t think of any examples that wouldn&#x27;t require an idiot to make them useful, I give you that.<br>
<p>
<font class="QuotedText">&gt; Casting itself is free. But because new “optimized” rules demand that you find and convert all pointers before you call realloc you would need additional code which would traverse additional data structures and scans all these pointers.</font><br>
<font class="QuotedText">&gt; And after realloc you have to traverse all these data structures again and turn indexes back into pointers.</font><br>
Agreed. Shitty idea.<br>
<p>
<font class="QuotedText">&gt; But lots of people claim it&#x27;s “an optimization”. It&#x27;s supposed to “improve” something. So… what, where and how does it improve?</font><br>
It definitely doesn&#x27;t optimize anything there if it just changes a constant :/<br>
<p>
<font class="QuotedText">&gt; If that&#x27;s a paranoia then surely it would be easy for you to show something which benefits from -fbuiltin-realloc. Anything at all, I&#x27;m not that picky, if you don&#x27;t have a real-world app I can even accept some contrived artificial example for the start.</font><br>
Not really. There&#x27;s no need for evil to make bad choices. You can have stupidity, arrogance, stubbornness, misguidance, and countless other reasons that may lead to that. That&#x27;s why I say it&#x27;s paranoia. In this case, I&#x27;d go with &quot;we tried to improve this little number because we needed a report to look better&quot; kind of misguidance. They had an artificial benchmark that somehow got a benefit (possibly giving a broken result that they didn&#x27;t check) and called it a day. Under lack of evidence of the contrary I&#x27;ll always assume there was no bad intention. Specially for something that doesn&#x27;t seem to have stakes that high such as promoting another language. I simply don&#x27;t see the benefit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863303/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor863317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 11:27 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/863317/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; The interesting case is an “optimization” enabled with -fbuiltin-realloc. The one which forbids user to compare p and q and says that you can't use pointers to the “old” realloced object. What does that one improve?</font>

<p>If I'm interpreting it correctly, <a href="https://godbolt.org/z/78q6v1aEo">this example</a>. The -fno-builtin-realloc version increases the main loop from 4 instructions to 6 instructions, which is a significant performance difference. That code is:</p>

<pre>
struct Context { int initial; };

int *test(Context *ctx, int *p, int n) {
    int *q = (int *)realloc(p, n * sizeof(int));
    for (int i = 0; i &lt; n; ++i)
        q[i] = ctx-&gt;initial + 1;
    return q;
}</pre>

<p>which I think is not particularly artificial or unrealistic.</p>

<p>As far as the compiler knows, this might be called with p == ctx. Then realloc returns a pointer which (with -fno-builtin-realloc, or with a builtin that doesn't have the rule about invalidating pointers to the old object) might be equal to p and pointing to the same object, in which case the write to q[i] might validly change the value of ctx-&gt;initial, therefore it has to dereference ctx on every iteration.</p>

<p>With builtin realloc, the compiler knows that q is always a pointer to a newly-allocated object that is distinct from any object pointed to by previously-existing pointers, even if q happens to be numerically equal to the old p, so there's no aliasing between q and ctx and it's safe to hoist the "ctx-&gt;initial + 1" out of the loop. ("safe" in the sense that it won't affect behaviour unless the program is illegally accessing the object pointed to by p, in which case the program is buggy.)</p>

<p>(I guess in theory the compiler could do this optimisation without the "invalidating old pointers" rule, with the reasoning that realloc <em>might</em> deallocate p (and the programmer can never be sure that it won't, even if n matches the size of the original allocation), therefore it's invalid for the programmer to call this function with p == ctx &amp;&amp; n != 0 because that will dereference ctx which might have been deallocated, so the compiler can assume n == 0 || p != ctx, and the loop body only executes if n != 0, so the loop body can be compiled assuming p != ctx, in which case q != ctx (because either q == p or q is a new numerically-distinct pointer, by the basic definition of realloc). But that sounds infeasibly complicated to implement, whereas "the pointer returned by realloc never aliases any pointer that already exists" sounds pretty simple.)</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/863317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2021 12:09 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863321/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>That's pretty nice example. But it shows all the issues discussed in the <a href="http://www.complang.tuwien.ac.at/kps2015/proceedings/KPS_2015_submission_29.pdf">well-known rant</a> perfectly.</p>

<p>First: it doesn't require you to make surprising and crazy assumption that <code>p</code> and <code>q</code> point to distinct objects. So it's not <b>quite</b> the same optimization as I'm not talking about.</p>

<p>Second: it can be easily fixed by just adding one <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVDIApACYAQjt2kR7ZATx1KmWugDCqVgFcAtrRDaAHKSvoAMnlqYAHLOAEaYxCAAnKQADqhChOa0do4ubp5xCWZ0fgHBTmER0caYpkkMBMzEBCnOrh5GmCbZtBVVBLlBoeFRRpXVtWkNQv0d/l0FPZEAlEaoDsTIHFI6AMz%2ByI5YANSaqzbII%2BiseCF72JoyAIKXVyPEDqbbdvSY4gS7AOy62/4f/ok2HsfppPgARYG3KHadZUayYKjbABK2AYABUkQBJGxo6GrLBUcbI1EY7Fo7YAfQpxEw9zwpjx3jwVCh1z%2B2wAVARaQQIC9ue9OSj0VicdtTOJSL96JyYlL2bRpl99NdtmrpR8OQBHXarMHbCDsjnTGlsVioZAQOXbWic7YJABemFQVEN9Gm00hqvVNGIBvZeF1%2BpkwN%2BupsNtDBgMeE93vV6q1mgArLo8Cn9Xt9RKALTnAFmNi7PTbTheq4JmkEBa2pOrFU3cG3KSzVjSZPyVyyeSoaQ2aMloTzRaYYurTjyAjSOQe0gAazcMgAdJ9uJ9tJ9kwA2GTuTirT6cLcqaTceROLgyGSkLtyUi9qTyIQga9T7uzOCwJBoJwxPDsMgKAgH8/wAlBVHUThtBkTg%2BH/bliGfCAQmneQQn8KoAE9pAnUgfycKwCAAeVoVhsO7UgsCcNRgHYVDKLwGkygAN1pei3lKBxuRw%2BQ/iaeiThCYgsLsLB6IIYg8AvKQJ1mfhGBYOieD4OgCGEMRJAopRYIgjQB0MQTn0gWZUBiFpnykHMiNwkoygsCBvEGVxYO8Tp8kKZRMkSOgnM8%2BJvNoNzugiWDbJaNoBnsOplDC8pRiCyYQr6dpfNC%2BLxncnpOFmIcFiWLhW3bTt6IfcR3C3HMt24cVdNLbQl2XTgDVwQgSDHWDnlQX9/3CdqlX7PQDEnVDZwQTBmCwCIIFmBdOEiJdx3cVduG3bglo8GETykM9SAvTgrxvErpCfF9SDfGdSE/RAUC60DwnISgQJ6iJNhoqCYLg1gEKQlCKPQ2gsJ4vCuoI%2BgSLI%2BiqJouiKPwJizFYiy7w45AuOWXC%2BLbCjBOE4hMNE5Y7wkqSeLk1SmDYDhlPk9SJHopRtBUGiUH0lRTiM6b7zMpILKspqczhVAcxCBx4P8HNTVYc1kCfJpShaSxrFSrxrASjzYK8lplc1pI1ayxpmjilKorSUK5bs1p0ryYKYtGZWRnaPWQpy4d8uyraO0OijSvKyrqte9Q6oapcmogFqiD9NYOrsbqALHbR%2Bv04b31mMaJp6TnZvmyJVlWSJPkidxtC3SJIivRmsZ2vaDtvHtjqMU7zpbS6YGup6AIe4DbuekBgE4fvPu%2Byhfrvf7AZk%2BR8MI8HyLvKH1BhufGPlvBEfY8ROO4ifyFeLG7xxkSMEJydJOk2SVPoCmlN4GmRDprSQFWJn1BZwa9DZkIOZM7m6F56zthzGCYUpIcRZh0NocBstDb2UcibZyKtfAZRthrfyWs4F%2BSyLrJBiUYrm3CnbdBZtoGW0dtg9WyVIqpHgQ7aoTsCpzDylTQqUhPa13vNIMqFUqrbGAMgZApZOAh2avgCO7UpQxzupHGEqxE5v10MnGcM1FxbR2mwh8J1XwjRbvACA35u4dyAu3HofcB6Ei%2BuEH69Ex54yBlPMGpFZ7yHnrRY%2BDF4arzYhRFGaMgaYwEqcXG%2BMj7iVPqTC%2BClKZcBvqpWmmk7xKF4LpV%2B%2Bh36GXgN/cy0g%2BZQJXjApWhCEF0JQZgnyBSdY5DIfrWKdAIo1AKdUkhtDKlJRoXUqhttSHWxwe7XKI56FY1YUdKQnC/Y8L4QIoRYcRFtSjuI/RvU1jcFkSk%2BRZ0RpKOgio4q3t67Pk0SnLa2htl3nUWsg5rFEJJBANwIAA%3D%3D%3D">restrict</a> - and that works even for a compiler which doesn't know anything about <code>realloc</code>.</p>

<font class="QuotedText">&gt; But that sounds infeasibly complicated to implement, whereas "the pointer returned by realloc never aliases any pointer that already exists" sounds pretty simple.)</font>

<p>Sounds “infeasibly complicated”… to whom? To someone who doesn't want to compile standard-conforming programs correctly? To someone who feels C and C++ develpers are slaves of the compiler and would have to follow all the warts of it no matter what?</p>

<p>Adding 10 (20? 100?) lines of code was “infeasibly complicated”, but forcing <b>all</b> users of <code>realloc</code> to review and fix their code is not?</p>

<p>That's precisely an attitude which makes C and C++ <i>unsuitable for any purpose</i>.</p>

<p>That's already a very-very troubling and hard to accept attitude. But at least when there was that “holy scripture”, that standard, which <b>everyone</b> was supposed to obey… it looked doable.</p>

<p>Now, when we <b>know</b> compiler developers wouldn't stop their work on sabotaging perfectly working programs (yes, I know: usually it's considered polite to say something like <a href="https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html">compiler writers really like the freedom that aggressive undefined behavior gives them to optimize, and are reluctant to cede any ground that might impact performance</a> but I'm rude guy and when I see that something is black I call it black) we need to start thinking about escape plan.</p>

<p>Not necessarily Rust. It may be Ada, C# or even, gasp, Java or JavaScript.</p>

<p>But we <b>have</b> to start working on migration. <b>Now</b>. Till we still have time.</p>

<p>It's time to declare C and C++ a liability and start working on making sure they would join PL/I in the annals of history. Maybe then people would learn something.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/863321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor862940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 9:37 UTC (Thu)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/862940/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>What's the correct way to do the <tt>assert(x + 100 &gt; x)</tt> check?

<p><a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVAB9LclIj2yAnjqVMtdAGFUrAK4BbWl06lT6ADJ5amAHJ2ARpmJlAAdUIUIjWksbe0dSELDDOndPH1t/QKc9TAMIhgJmYgIouwdOTMx9RNo8goJk7z8A5SF8wuKYst1Wuo8GtKbOAEpdVGtiZA4pAFIAJgBmD2QbLABqKbnzZiERQoA6BHXsKZkAQWOTgDdUPHQV1AuAqlZUAHcNZARsgGsIDwIV8SDNYAdgAQucVpCVlsdgQIOI1jNQStODIZGs5tgAYN1uDTlNgQARc5SYasaQAVnkDlk8lQ0nMKyEo3GmERc048gI0jkg2GXy4aJU0m48lsIApMlINLkpHpUnkQhAUu5tOGcFgMEQKFQtiCeHYZAoEDQeoNTWQwDKTioBoIASVEF8PPkvg8BQAntJOaRTbZTAQAPK0Vhe2mkLC2NTAdguiN4YjZQwPJXhzDibLWe1xv4VOOsPC%2BYieyxYOMEYh4cVSTnDfiMFixnh8OgEYRiSThpQzFTRkBad4qQtKyDDVBBKqpgC0gZmioqSYiJjM7VKzjM9VS6WCoXCdFXO4SEU3jQyugXOToNTaVhKzQvVWvPRSp%2Ba3QPmW6J/6GWGzLGExcGSlLUnG8riAAHAAbFOUHcCswDIMgKKcLsnArBAuCECQ7JOCslhmoa7IzEC5hci6fKkAKMwUsKUiiqQ4qStKYHSIqyqkKqvKkBq2qmvqhrkJQ/HmoESGqOonAzEKtqsPaxCOs64ZurQnrevIfoBsGoZxpG0axuG%2BCJjkKZxummbZuGubkuGBZFiWGCTLKFZVupdatkwbAcM29bthIcZKE4EmaNoQ6%2BCOEBjhOETTrO86VEuEAuB%2B65uL0W4DHEu5VCl8R7rQ37buUCVXu%2Bt4dOeJXVF%2B6Wvp%2BtQpS0tSFQMf4soBQx0VSLHhuB0GwfBSzRiiMy7DIY0YVhRDELhpD4bqAkBLhpHkWqwyfMwWCBJFVEgDRdEMTKdJsboHFcaSPFahASAiYJxq3RaSwaJ4bxwXwdoOpQSmyipak1hpur%2BvQ2lhrKenqAZYMJouplphmyBZk58jWfmhbFsQHqlkjnGVtWtYtvQnlNrwvkiP5XYgHMvbqP2oV2RFUWTtIM5zpVi7GElK7lWuLgtWeeU5dzh75Xz95VU%2BjUPrkNUvj%2Bb4NUL9WFKLnX/qyQFdaBvXSOIcErLYQgXMhFycAAnGh8EQAA6gAkl42BAph%2BDTbN82EUtsxzHMK2cRR/J7dwuym8HIeh6HUEHVrsryuxKoUZd8DXTq7tGsJC2iSgeBIdJMxlD2snyYpca/Rj6m%2BoDWkhqD8jgzG2NGTDmCprK5kI5Zsoo7ZaMOWW4YuXjF31kT3kk62fmdrKSi8MFtODvT8CMzFzNxWzl4OJzFiK6lKtZUe%2B5bwLx61XLxXs9VCvRGuWRr0%2BO9NTel/y8rx9FW1AHecBUjdUdco6/1etZ2QjnVCqEZiTWdjhT2eECKLRmp7bgPtzqUWorRGyh1WIKlOnHNadFWZMSlD/GOvscE2TmFHY6mCkHDAeApJc3AgA%3D%3D"><tt>assert(x &lt;= INT_MAX - 100)</tt></a>?

<p>(I'd not even chance it and reach for <tt>__builtin_add_overflow </tt> but of course that might not be available in your favourite implementation...)
      
          <div class="CommentReplyButton">
            <form action="/Articles/862940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 10:14 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862943/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Yes, <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVAB9LclIj2yAnjqVMtdAGFUrAK4BbWiADMM0qfQAZPLUwA5OwCNMYhAAVlIAB1QhQiNaSxt7JxdI6MM6T28/W0DgsL1MA1iGAmZiAni7B2ddTH002mLSggzfAKDQ3RKyisTqoS7mr1bs9pCASl1Ua2JkDikAUgAmRy9kGywAannHc2YhETKAOgRt7HmZAEElldo1603t81Y8W0IhY9Pzq8uAN1Q8dAbVA/IJUVioADuGmQCAKAGsIF4CBtxGMtgB2ABCXw2uI2ewOBAg4i2O22ABENgBJHwAFQ0AFkLgANDYAWg2nBkMjG22xl3m6PJXykE1Y0hC8gcsnkqGk5g2QimM0wW2WnHkBGkcjGEzhXG5Kmk3HktlCLmlclIcqk8iEIBcWplEzgsBgiBQqFs4Tw7DIFAgaG9vvayGAnAjfF9BCC9og/m18n8XlKAE9pBrSEHbKYCAB5WisdMy0hYWxqYDsROlvDEAqGEH2kuYcQFawx6tI2rV57%2BYhpyxYasEYgvDOivh0RgsKs8SeCEQSatKRYqCsgLTQlR4fz2yATVDhepNtl5xZ22r12ImMw9BycVxmFpZHLKFIxOh3t9RD%2B0Z9tYIH3yQo6EaborEqZRgPqMDBkyACoIGL8gIGf8RkAiYlWmWYuDFCUpWrG1xAADgANjZUjuA2YBkGQTlOEOTgNggXBCBINVHAfDZLGDP0OMWNFzE1RNdVIfVFjCcUpBNUgzRCC1COkO0HVIJ0dVIV0PSDH0/XIShtJDYJaNUdROEWQ0qGjWNKATEtk1oNNxyzL0c3oAsi2rMsKyrEt8DrQpG2rFs2w7Esuykq1e37YhU0HOYrRHMcpA1CZ%2BGnNgODnNLhDESQSyUB8TM0bRt13eADyPWITzPC86mvCA3GQx8PCGF92gfd96iazrYjQ18gMvECGiQiDEgGurQNQ1qEJQpomv6Jo%2BvazDlRwzg8KkSVSEtWVpBI8jKI2NYK05RZDhkc7mNYohiA4rieJ0oI7sE4TnQmWFmCwYIID1EAJKNaSCJLG1lMdESNPdCAkAM3SAxh0M1g0bwoUoqNWBjYg41sq17Mc5L5GzXN3OLK0vPUHzSdrK9AubVtkHbeL5HCnsd2i2KMEZ1TRzNfHUqnJgMq4XhssXPKrSURw13UDcSt7PcfutSq6Gq88agmhwGtvUb72apbAIiH8uu179Ul66b0KgwaYJGhIdegoopvgi3ZvA23EMW83%2BpW7DMo2radutPbDtsIQfjon5OAATkYqiIAAdRpbA0RY/Abru0huK9R7buuRwXtUkTfsWbhDkjsvy4rivSIBmSA5B3QVLUidNKhz1eKCPTAyzwyUDwWjzMWCNV0s9HrPjatcZipzCbcwsSfkMnK05vzqcwJsrWC%2BnQqtZmSyigcOeHbnxz5%2BgBdnYWpxypd8pAXgiplrc5fKxXj2kU9Vft4xNYsY2HzcPWJtfzdUNmbJ2/U1ZXkmnNP%2BkChqwUAS7cosCFplEQd7FUuEAb%2B0UlIfaFEqJ9zogPBiDFFhXVTuxa491u58WuNwfOTdRLiUksaIGVp672jBm9AGqs5IKWBkpAuPCpKOHYbtW0widQTBBJja83AgA%3D%3D">assert(x &lt; INT_MAX - 100)</a> is the one pushed by C compiler developers, but since unsigned overflow is not a thing (usigned arithmetic is defined as modular arithmetic by the standard thus it may never overflow)… and since conversion between signed and unsigned was always <i>implementation-defined behavior</i>, not <i>undefined behavior</i>… and since in C++ is <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1236r1.html">mandatory to use two's complement now</a>… starting from C++20 in theory and in all existing compilers in practice you can use… drumroll… <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVAB9LclIj2yAnjqVMtdAGFUrAK4BbWiG4BmUqfQAZPLUwA5OwCNMYkdSAAdUIUIjWksbexAAVjCIqLpPbz9bQODePUwDaIYCZmICWLsHZ11MfUM6IpKCdN8AoJChYtLy%2BKSOxubM7McASl1Ua2JkDikAUgAmJy9kGywAahmnc2YhEVKAOgQN7BmZAEET04A3VDx0VdRLoKpWVAB3DWQEfIBrCC8CVbiYbrADsACELqsoattrsCFB/sMoNZaJFgN50MNxOs5mDVpwZDIBMCjoDhhsIWcZiCACIXKSjVjSBLyByyeSoaTmVZCcaTTA4pyceQEaRyYajb5cQkqaTceS2RIyUhsuSkTlSeRCEDK0Xs0ZwWAwRAoVC2UJ4dhkCgQNDmy1tZDATguviWghBbUQfxi%2BT%2BLwlACe0mFpDttlMBAA8rRWMH2aQsLY1MB2L7E3hiPlDI9tQnMOJ8tYPen/jV06w8P5iEHLFh0wRiHhFVJhaN%2BIwWGmeHw6ARhGJJAmlHMVCmQFoPioq9rIKNUKE6qjpABaKNzLU1bPRExmboOTiuMwDVrBQ/hSJL/fKC%2BpWgnrJtQ95Ar1TplKwVZQvpcNUoPoZn3fa8gP6LwWkfM9Rl5CYpi4RlmVZdMNXEAAOAA2Fd0O4VZgGQZB8U4PZOFWCBcEIEhBUPVZLHtK1BTmYFzBFX0JVIKU5iSJkpHlUhFQSZVVQ5aQtR1Ug9XFUhDRNO0LStchKFkh1gnw1R1E4OYZSod1PUoH0E39WggxDeRw0jGM43TJMUzTBN8CzApc3TAsixLBMy24tVK2rWsMGmNVG2bEz2z7Jg2A4HsOwHCR0yUQ81M0bRp38WcIHnRdojzNcN2qWodwgNwQKPDxwMGJ9kkvaIitvJcAPKn9CmAz94mfLdX1oP8mlK09vyauID10d86qgsZYIihCpBZFVkOkNDMOw1ZlhTfE5j2GQ1tI8iiGIKjSBos05KCKimJY/VRi%2BZgsGCNL2JATjZR4pCEw1UTdVYqTjQgJAlPkm0fsdZYNG8d5sLdVgPWIL19LVQzjNbUyzQjegLPjNVrPUWy0czbcnPzQtkGLfz5A8isqxrYhAzrInxKbFs217egwu7XgopEGLhxAFwEonJLvNS9Klyy9dNzy4wCr3ZqBrcYabxSK9Jdlyq0m6yDvza38%2Bq/VrRY6oaVcAwbGiKvp/31p9oL5ODOAmqahPVWaFtsIRLgIy5OAATmInCIAAdQASR8bBgTI/Btt2/a6KO%2BYnCcE7xNYyU7u4PZ3dTtP0/T9CHt4u2Xt0MSJIZD74C%2B01I%2BtRSDuUlA8HwzS5hdUdtPB3TvXTWGKZMsNEfM2NUfkdHU2p%2ByccwPM1Rcgm3LVEmE288nKb8htaeChnO3CrgWb7aKhzVJReG5ycdD5%2BABcy1dhdy7cxcKhXD2ls2zwqu9qrl6IZe16/daNu%2Br/azqP6Gy6L/E2XUMg9WtqNfk8EHq2xmlIOaWEcK1wIvXIiRE5ibVDpRaO1FaKHR2tHbgcdC5sQ4lxOUT01R521G9M6D0cr8UEvA064oJpOCocJTU8d6GPEhjubgQA%3D">assert((int)((unsigned)x + 100U) &gt; x);</a>. Easy, ne?</p>

<p>It works exactly the same as <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVAB9LclIj2yAnjqVMtdAGFUrAK4BbWlwBMpU%2BgAyeWpgBydgEaYxCC8AA6oQoRGtJY29k6kYRGGdB5evrYBQbx6mAZRDATMxAQxdg6czjl5dAVFBKk%2B/oHBuoXFpXEVrXUN6ZnBAJS6qNbEyBxSAKSOAMyeyDZYANSTM%2BbMQiLFAHQIq9iTMgCCh0cAbqh46EuoZ4FUrKgA7hrICLkA1hCeBEviAysAOwAIVOS3BSw2WwIEHEK0cwKWnBkMhWM2wfwGq1Bx0mgIAIqcpENWNIAKzyByyeSoaTmJZCEZjTDwmaceQEaRyAZDD5cFEqaTceS2EBkmSkKlyUi0qTyIQgCWc6lDOCwGCIFCoWwhPDsMgUCBoHV65rIYCcS18PUEQIKiB%2BLnyPyeIoAT2k7NIxtspgIAHlaKwPdTSFhbGpgOwnWG8MRcoY7grQ5hxLlrLaYz9MKTQ6w8H5iO7LFgYwRiHhRVJ2UN%2BIwWNGeHw6ARhGJJKGlM5VOoQFpXioCwrIENUCFkrRkwBaf2OJZTqhPIshM7ynMJqImMwdcouMy9JpBTgJcKROg75SJM%2B0A8ZZrHqoT2rtKxlZSP/JteqeRp3o/dF9Yl3IQv1vfpOCGRlRnGLgSXJSkY1lcQAA4ADYp1Q7glmAZBkCRThtk4JYIFwQgSFZY8lksE19VZRwAXMDknR5Ug%2BRmGZtnYrjuJ4wUpGFUhRXFSVEOkeVFVIZVuVINVNWNXV9XISh5NNIJcJ7C1HAFKgbTtShHVDF1aHdT15B9P1A2DGNw0jaNQ3weM8iTGNU3TTNQ2zXNpXzQtiwwCZpXLStTNrFsmDYDgmzrNsJBjJRjw0vttEHPxhwgUdxyiadZ3nRdl1XXR12qBwIFcC9j1cMD7xPJIonKmrryq/8PxqL96pa2hn2/NJD3fNrX06ADut/cDIKZGCIL4ikRNDJC0IwrCFkjJFHG2GQ1uI0iiGICjSCo7UFMCCiGKYlUhneZgsCCdLWJAdjOJ4x72L4gSpRpMTdAkqTiRkjUICQFTFMNQGzTwXCtMcS1nB01hbWIe0DOlIyTOrMztV9ehLJDaUbPUOycbjDdnJTNNkAzAL5E8mMfKLYg3RLCnJIrKsa2behwsbXhopEWLOxaRL%2Bx0Hy0oyidsrnBcl2YFc130CctwsAbd0qn8%2Bmqq8J3qjWoia98iqffqgL1uXPx6VXeofQ230ts2er/WDhmgyK4Kkaa3plaQUPQzCljBvCIYIgi5xI/Btt2/aaKO6YZm4E7JOY3k7o4p6npehDZo%2BhUlQTvjHBFMUJXd2VTu5F2ZnT6Vi/js7SDueHN24IA%3D%3D%3D">assert(x + 100 &gt; x);</a> (with <code>-fwrapv</code>) the only difference it that it's ugly and you wouldn't learn about it in books.</p>

<p>That's the problem with C/C++ compiler developers: it lies not with the fact that it's impossible to write correct C/C++ code. But it's hard, and, worst of all, C/C++ compiler developers employ extremely strong <a href="https://en.wikipedia.org/wiki/Somebody_else%27s_problem#Douglas_Adams'_SEP">SEP field</a> and never even consider the need, to, you know, write real program somehow, important. It's always “go read the standard”, “our way or the highway” style discussion.</p>

<p>And <code>__builtin_add_overflow</code> shows that perfectly: yes, it's very  nice solution. The only issue: gcc 2.95 from last century <b>already</b> breaks these checks, yet first version of GCC which got <code>__builtin_add_overflow</code> was version 5.0 (and clang got that one even later and no because they think C developers deserve it, but because they wanted to be more GCC compatible).</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 14:08 UTC (Thu)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/862953/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks. And wow that expression with the casts is unpleasant... I think I&#x27;ll stick with the INT_MAX version!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor864222"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2021 16:03 UTC (Sat)
                               by <b>gbutler69</b> (guest, #54063)
                              [<a href="/Articles/864222/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I believe Rust only lets you do 3 things in unsafe code that you weren&#x27;t anyway allowed to do in safe code. You can dereference a raw pointer. You can access fields in a union. You can mutate statics. That&#x27;s all.</font><br>
<p>
There is a 4th thing. It lets you make FFI calls to C. And also a 5th thing. It lets you implement unsafe traits.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864222/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864227"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2021 22:40 UTC (Sat)
                               by <b>MrWim</b> (subscriber, #47432)
                              [<a href="/Articles/864227/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also you can call unsafe functions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864227/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864393"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2021 13:14 UTC (Tue)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/864393/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But that&#x27;s just a thing akin to Perl&#x27;s taint mode, right? I wouldn&#x27;t call it a new capability.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864393/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864401"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Footguns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2021 13:40 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/864401/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Different to taint mode - taint in Perl attaches to data, not operations. Perl's taint says "this data is from the user and therefore untrusted until sanitised" (even if minimally sanitised). Rust's unsafe says "this operation has human-checked invariants that can result in UB if not correctly checked". 
<p>You can implement Perl's taint system easily in Rust, with a <tt>struct Tainted&lt;T&gt;(T)</tt> expressing that it holds tainted data, and some way to extract the tainted data and feed it back to the rest of the program. You can't implement <tt>unsafe</tt> easily in Perl 5, because Perl does not have the same ability to represent a function that breaks the abstract machine's invariants if misapplied.



      
          <div class="CommentReplyButton">
            <form action="/Articles/864401/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor862301"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 13:57 UTC (Fri)
                               by <b>LtWorf</b> (subscriber, #124958)
                              [<a href="/Articles/862301/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well if you are writing low level code, I&#x27;d say that understanding how the machine architecture works is rather important, though it&#x27;s harder than writing python and having no clue.<br>
<p>
Adding safety is one thing, but adding abstractions that hide details is a bit different.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862301/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862420"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 23:56 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862420/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It's not about machine architecture. It's about more mundane things. Like freeing the memory in case of failure or avoiding numerous landmines from compiler developers.</p>

<p>And I'm afraid that long-term former problem would be less relevant than latter one. Remember than developers of C and C++ compilers are diligently working on turning C and C++ into abominations unfit for any purpose (and they are proud of it: <i>if you believe pointers are mere addresses, you are not writing C++; you are writing the C of K&amp;R, which is a dead language</i> was what they said to me when I asked where the hell they got an idea that changing the rules  and turning valid programs into invalid ones is an acceptable way forward).</p>

<p>Just read the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2577.pdf">proposal</a>… and weep. Specifically that part: <i>However, DR260 CR has never been incorporated in the standard text, and it gives no more detail.  This leaves many specific questions unclear: it is ambiguous whether some programming idioms are allowed or not, and exactly what compiler alias analysis and optimisation are allowed to do.</i></p>

<p>So now we are at point where compiler writers ignore POSIX standards, x86 and ARM manuals and so — because these are not sacred C/C++ standards, you see. And when C/C++ standards don't give them enough rope to hang unsuspicious developers — they demand more rope from the standard's committee. When someone says that maybe, just <b>maybe</b> it would be good idea to <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2263.htm">add a bit of safety</a> (in form of a compiler switch, like it was <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n897.pdf">planned in last century</a> when an idea that  the <i>implementor may augment the language by providing a definition of the officially undefined behavior</i> was considered <b>normal</b> and not a blasphemy, an attempt to undermine sacred rights of compiler writers to break working decades-old code) — this idea is rejected.</p>

<p>So far this whole house of card is held together by Linus valiant fight with GCC developers, but how long can he keep it? Sooner or later it would become completely impossible for any “normal” developer to write anything in that language and they would, finally, achieve that coveted “unfit for any purpose” status.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862420/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor863075"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 19:37 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/863075/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t think that&#x27;s an obvious pro, considering most embedded/systems developers know C but not Rust. I&#x27;m not denying the advantages of Rust or that it&#x27;s becoming increasingly popular, but *if* adding it means everyone else needs to learn Rust, then you may lose more developers than you gain by such change.<br>
Hopefully that will not be the case. I&#x27;m almost certain it won&#x27;t if they stick to drivers where you can have most covered by a small development team.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863075/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor864217"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2021 15:11 UTC (Sat)
                               by <b>Avamander</b> (guest, #152359)
                              [<a href="/Articles/864217/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it&#x27;s really not about the languages that much, those can be learned albeit with time. But a first contributor can&#x27;t improve the accessibility and user experience of bug triaging, discussion and patch submission, but they absolutely are dissuaded by those being outdated or poor. I really don&#x27;t think C has the need to be marketable other than the fact that it&#x27;s required for now. On the other hand things like mailing lists, git-email, bugzilla or IRC are real anti-advertisements for many. I mean, why bother with Linux if there are plethora of other projects that don&#x27;t place such annoyances in front of you in addition to writing good code itself?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864217/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor862167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust noise</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 14:40 UTC (Thu)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/862167/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In addition to other reasons: there&#x27;s a lot of interest in reading about it, and LWN provides what people want to read about. Consider that the Rust in Linux session at Linux Plumbers last year was the most attended session at the conference.<br>
<p>
Put that together with it being a substantial change to the way people work, which also makes it interesting to read about and talk about the implications.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust noise</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 13:58 UTC (Fri)
                               by <b>LtWorf</b> (subscriber, #124958)
                              [<a href="/Articles/862302/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well it&#x27;s also an easy read, unlike extra technical articles that are directed towards a much smaller audience.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust noise</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 22:16 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/862416/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, let&#x27;s address the real sealion in the room here: what is *your* deal? Why does any mention of Rust anywhere on the internet bring out a bunch of weird, professionally-offended non-practicing gatekeepers, frantically parroting the same 3 talking points like they&#x27;re reciting the lord&#x27;s prayer?<br>
<p>
There&#x27;s no hit squad for news on the decade+ old RT patchset, or the millions of lines in comedi, or the fact Python gets the lion&#x27;s share of language articles here. Give it a rest.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862091"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 1:08 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862091/">Link</a>] (88 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Adding Rust to the kernel requires a lot of work, for a lot of different people, without a clear and obvious benefit beyond promises that can only truly be fully fulfilled with a whole kernel written in Rust.</font><br>
<p>
This is somewhat awkwardly phrased and misleading.<br>
<p>
Writing some individual components in Rust will provide real, concrete benefits even if nothing ever progresses further than that. Rust *will* catch errors in those components that would not have been caught if they had been written in C. Furthermore, if the FFI interfaces are written correctly, then safe Rust code in those components is guaranteed to be free of important classes of errors (memory corruption, unexpected data races).<br>
<p>
Of course introducing Rust has significant costs which have to be weighed against those benefits, so it&#x27;s still not a no-brainer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862091/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862120"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 12:18 UTC (Thu)
                               by <b>mchehab</b> (subscriber, #41156)
                              [<a href="/Articles/862120/">Link</a>] (87 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; Adding Rust to the kernel requires a lot of work, for a lot of different people, without a clear and obvious benefit beyond promises that can only truly be fully fulfilled with a whole kernel written in Rust.</font><br>
<p>
<font class="QuotedText">&gt; This is somewhat awkwardly phrased and misleading.</font><br>
<p>
No, that&#x27;s very precise, and it is not about Rust itself. If any other language would be used, the same will apply. <br>
<p>
See, when a subsystem maintainer would receive the first Rust code for its subsystem, such maintainer will need to not only learn Rust, but will also need to become an expert on it. Even if Rust itself is already known by the maintainer, this is not enough, as for sure there will be a lot of glue in order for Rust to see Kernel objects, refcounts, kalloc, etc. Also, some extra kAPI patches will be needed in order make the subsystem-specific kAPI visible in Rust. This is something that a normal Rust developer usually won&#x27;t do.<br>
<p>
On other words, accepting a Rust patchset will require a lot of extra work for the maintainer. The same is true for subsystem reviewers (if they&#x27;re also willing to become experts on another language).<br>
<p>
Also, due to the kAPI glue, nobody can really warrant that there will be less bugs in the end. <br>
<p>
The Rust code could also have worse performance, memory consumption, power consumption, etc than if the same code was written in C. Hard to measure, except if the same driver would be written on both languages.<br>
<p>
Also, as pointed by others, once a subsystem reaches a certain amount of Rust code, it will make sense to rewrite the subsystem&#x27;s into Rust - which wil require Rust to C kAPI interface, to allow the remaining non-converted drivers to keep running while the entire subsystem&#x27;s isn&#x27;t fully rewritten in Rust.<br>
<p>
All of those have a big cost, with no tangible benefits, as, even with a perfect driver conversion from C to Rust, the drivers should keep having exactly the same functionality as before. So, the conversion step won&#x27;t have any user-visible effect. Due to that, it would likely be hard to find sponsors for such conversion work and/or to convince existing driver developers to do that.<br>
<p>
That not mentioning that any driver rework will almost certainly bring new bugs, and may have hidden impacts (in performance, memory usage, etc).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862120/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862127"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 13:03 UTC (Thu)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/862127/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the part that roc was finding problematic is:<br>
<font class="QuotedText">&gt; without a clear and obvious benefit beyond promises that can only truly be fully fulfilled with a whole kernel written in Rust.</font><br>
<p>
There is benefit in adopting Rust even if it&#x27;s not used for the whole kernel. I think what the initial text means is that partial Rust won&#x27;t completely eliminate memory errors (well, errors that Rust prevents). That&#x27;s true, but full Rust wouldn&#x27;t either unless unsafe is forbidden. The Rust code could be buggy because of the C code it uses, but that&#x27;s just because the C code is unsafe (by Rust definition of safe).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862127/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862169"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 14:54 UTC (Thu)
                               by <b>mtu</b> (guest, #144375)
                              [<a href="/Articles/862169/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For a while now, I couldn&#x27;t put my finger on what I find so … irritating about Rust advocacy. This matter really make it more clear: It&#x27;s the almost religious disregard for any and all arguments that speak against (or just put a different perspective on) the adoption of Rust for any and all software.<br>
<p>
“You should use Rust, it&#x27;s memory safe!”—“Well, that would mean extensive changes to…”—“But it&#x27;s memory safe! How could you not want that!”—“Well, we have to consider the interopab…”—“But memory safety solves so many problems!”—“Look, our workflows require…”—“JUST LET THE MEMORY SAVIOR INTO YOUR HEARTS ALREADY!”<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862169/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862172"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 15:06 UTC (Thu)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/862172/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; For a while now, I couldn&#x27;t put my finger on what I find so … irritating about Rust advocacy. This matter really make it more clear: It&#x27;s the almost religious disregard for any and all arguments that speak against (or just put a different perspective on) the adoption of Rust for any and all software.</font><br>
<p>
That doesn&#x27;t match the post you appear to be responding to, which ends with &quot;Of course introducing Rust has significant costs which have to be weighed against those benefits, so it&#x27;s still not a no-brainer.&quot;<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862172/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862176"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 15:28 UTC (Thu)
                               by <b>mtu</b> (guest, #144375)
                              [<a href="/Articles/862176/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My comment meant to endorse, not diasgree with, the posting it replied to.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862176/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 17:21 UTC (Thu)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/862181/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The quote is from the post above that, in which the benefits and drawbacks of rust are carefully weighed by someone advocating for it. Which disagrees with your depiction of a fictional obsessive uncompromising rust programmer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862184"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 17:35 UTC (Thu)
                               by <b>mtu</b> (guest, #144375)
                              [<a href="/Articles/862184/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please continue to explain my intentions to me. I&#x27;m delighted to encounter so many graduates of the Hacker News Academy of Rhetorics here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862184/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 19:03 UTC (Thu)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/862198/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You should take it as someone explaining what they received from what you said. Which may not be what you thought you said. That is a common problem when communicating.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor862187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 17:59 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862187/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m feeling the same, it&#x27;s presented as THE solution to every existing problem.<br>
<p>
I&#x27;ve never seen any of its advocates estimate the risk of logic error that comes from the extreme complexity of the language. You won&#x27;t accidently overwrite a byte there but will likely forget certain critical controls of permissions etc. The linux kernel is not just a memcpy() implementation, it does a huge amount of controls that must be safe in their logic. And based on all the patches that I&#x27;ve seen posted, it seems particularly hard to quickly grasp a missing or misplaced check.<br>
<p>
Overall I&#x27;m a bit irritated by all the marketing around the use of the &quot;safe&quot; word. I tend to consider a lot of C code as &quot;safe&quot; because it trivially translates to machine code. I haven&#x27;t seen safe Rust code posted yet because I can&#x27;t parse it.<br>
<p>
For me the reality is a matter of whom to trust. It would be more honnest to call them TTC vs TTD (Trust The Compiler vs Trust The Developer). Relying entirely on the compiler to render a program safe is not my approach. I&#x27;m already fighting with C compiler bugs enough not to blindly trust a much more complex Rust compiler which itself will suffer from its own logic bugs and possibly result in insecure code that looks inoffensive at first glance.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 19:22 UTC (Thu)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/862197/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I&#x27;m feeling the same, it&#x27;s presented as THE solution to every existing problem.</font><br>
<p>
If others are claiming that, then they are mistaken. Rust is not a silver bullet for everything.<br>
<p>
However, it does statically prevent some classes of issues that C/C++ do not.<br>
<p>
<font class="QuotedText">&gt; Overall I&#x27;m a bit irritated by all the marketing around the use of the &quot;safe&quot; word.</font><br>
<p>
If you prefer another term, you may think about it as &quot;UB-less&quot; instead.<br>
<p>
That is, whenever someone says &quot;this is safe&quot;, you may read it as &quot;this is guaranteed to not have undefined behavior (as long as unsafe code is sound)&quot;.<br>
<p>
<font class="QuotedText">&gt; I&#x27;m already fighting with C compiler bugs</font><br>
<p>
I have the feeling you may be referring to things like GCC/Clang optimizers breaking the intention of your code because they are taking advantage of some UB as defined in the C standard (which lists in Annex J.2 about 200+ cases of UB).<br>
<p>
If that is the case, then please give Rust a chance. Its &quot;safe&quot; subset is precisely all about preventing UB, which includes the peace of mind that the optimizer will not be exploiting some subtle case of UB that you did not intend to introduce.<br>
<p>
Of course, compiler bugs (as in actual bugs, not just optimizers reasoning about UB) can and will still happen from time to time -- Rust does not prevent that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 21:32 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862211/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  However, it does statically prevent some classes of issues that C/C++ do not.</font><br>
<p>
Yes, but in exchange of what ? How many new classes of bugs that never existed in C will appear ?<br>
<p>
<font class="QuotedText">&gt; &gt; I&#x27;m already fighting with C compiler bugs</font><br>
<font class="QuotedText">&gt; I have the feeling you may be referring to things like GCC/Clang optimizers breaking the intention of your code because they are taking advantage of some UB as defined in the C standard (which lists in Annex J.2 about 200+ cases of UB).</font><br>
<p>
Not just that, even real bugs, like the latest that comes to mind from a  month ago or so, where a type previously known as incomplete ignores its packed attribute, resulting in multiple files having different layouts for the same structure depending on the order of includes. These are real bugs to be concerned about from a compiler.<br>
<p>
<font class="QuotedText">&gt; If that is the case, then please give Rust a chance.</font><br>
<p>
I tried a little bit but it&#x27;s far too complex for my little brain, I&#x27;m sorry. It uses virtually all characters from my keyboard to do things I don&#x27;t understand (hence when I said I feel like I&#x27;m coding with smileys), the ratios of non-letter to letter is probably even higher than in Ruby, and I need pronounceable statements to learn them. I can&#x27;t learn &quot;quote underscore opening paren less than colon&quot; and stuff like this in a single statement.<br>
<p>
<font class="QuotedText">&gt; Its &quot;safe&quot; subset is precisely all about preventing UB</font><br>
<p>
UB is not as much my concern as readability and correctness by just reading it. I still can&#x27;t even figure what the code you post in your patches aims to do, you can guess I&#x27;m extremely far from being able to figure if there&#x27;s a bug there at all :-(<br>
<p>
At the very least one thing is certain, the first successful backdoor will come from there by lack of capable reviewers.<br>
<p>
<font class="QuotedText">&gt; Of course, compiler bugs (as in actual bugs, not just optimizers reasoning about UB) can and will still happen from time to time -- Rust does not prevent that.</font><br>
<p>
Of course like in C. However in C it&#x27;s trivial to map the C code to the emitted asm code and compare (and I run objdump all the day). I&#x27;m not sure I&#x27;d be able to figure if some asm code matches what I tried to do in rust or if the differences are due to the compiler considering it safe enough to optimize certain parts away. And worse, I&#x27;m even less convinced that such a stubborn language will let me abuse all possible tricks to work around compiler bugs like we all were used to do in C. I only trust permissive languages if I have to put my name on something that could have consequences for others, because I don&#x27;t want to be held responsible for something others decided was better for me.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862362"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 3:28 UTC (Sat)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/862362/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Yes, but in exchange of what ? How many new classes of bugs that never existed in C will appear ?</font><br>
<p>
I am unaware of any class of bug that C as a language is able to prevent that Rust is not.<br>
<p>
Now, there is an actual concern about mistakes that may be introduced by people that is new to a second language. We acknowledged this in the very first paragraph of the RFC.<br>
<p>
<font class="QuotedText">&gt; These are real bugs to be concerned about from a compiler.</font><br>
<p>
Definitely, but that applies the same way to both C and Rust -- it is orthogonal.<br>
<p>
<font class="QuotedText">&gt; I tried a little bit but it&#x27;s far too complex for my little brain, I&#x27;m sorry.</font><br>
<p>
From my interactions with you, I know you are smart -- you can definitely learn Rust or any other language.<br>
<p>
Of course, learning takes an effort for all of us, and we do not have infinite time in our lives. But for kernel development, I think it is well worth the investment.<br>
<p>
<font class="QuotedText">&gt; UB is not as much my concern as readability and correctness by just reading it. I still can&#x27;t even figure what the code you post in your patches aims to do, you can guess I&#x27;m extremely far from being able to figure if there&#x27;s a bug there at all :-(</font><br>
<p>
Readability is an issue as one is learning a new language, yes. But there is not much that can be done around that.<br>
<p>
At least, Rust syntax is fairly close to that of C and C++ (e.g. it does not follow Ada or Lisp).<br>
<p>
<font class="QuotedText">&gt; Of course like in C. However in C it&#x27;s trivial to map the C code to the emitted asm code and compare (and I run objdump all the day). I&#x27;m not sure I&#x27;d be able to figure if some asm code matches what I tried to do in rust</font><br>
<p>
I typically use Compiler Explorer for that (I do it for C, C++ and Rust routinely).<br>
<p>
I do think it is easier to map C to asm than C++ or Rust -- C is a simpler language with less &quot;high-level&quot; constructions, after all. <br>
<p>
However, I do not think it is necessarily trivial as soon as a modern optimizer is involved. The classical example of a vectorized/unrolled loop comes to mind, as you know very well: <a href="https://godbolt.org/z/6Yb5nq94d">https://godbolt.org/z/6Yb5nq94d</a> (here in both C and Rust).<br>
<p>
<font class="QuotedText">&gt; And worse, I&#x27;m even less convinced that such a stubborn language will let me abuse all possible tricks to work around compiler bugs like we all were used to do in C.</font><br>
<p>
Fighting the compiler is never going to end well. Yes, sometimes there are compiler bugs and a workaround may be needed. But, in general, most &quot;tricks&quot; contain UB one way or another, thus they are temporary at best and need to be properly fixed (either in the compiler or in the code, depending on what it is).<br>
<p>
In any case, in unsafe Rust you can play with e.g. pointers as much as you want and introduce as much as UB as you want, just like in C. I do not see that as a good thing, but if it gives you peace of mind...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862362/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862373"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 5:16 UTC (Sat)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862373/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; At least, Rust syntax is fairly close to that of C and C++</font><br>
<p>
Maybe C++, then that would explain why I can&#x27;t parse it at all, but for now the patches you sent look nothing like C to me at all. I never managed to learn C++, I&#x27;ve long thought it was by far the ugliest language ever created, absolutely tasteless and looking like random garbage dumped into a text file. But with rust now we could have a contender. At least I think that the complicated constructs in rust being less permissive than C++, there are less risk of shooting yourself in the foot writing something neither you nor the compiler understand.<br>
<p>
<font class="QuotedText">&gt; you can definitely learn Rust or any other language.</font><br>
<p>
I tried in good faith, believe me. And no, that&#x27;s among the stuff I cannot grasp at all. Too many concepts. Too many unpronounceable symbols that evoke nothing to me. It looks like it requires tons of declarations of stuff I have no idea what it&#x27;s for and I can hardly find where the procedural code is.<br>
<p>
<font class="QuotedText">&gt; I do think it is easier to map C to asm than C++ or Rust -- C is a simpler language with less &quot;high-level&quot; constructions, after all.</font><br>
<p>
I agree, I frequently present C as a &quot;portable assembly language&quot;. In C it&#x27;s simple, instructions for humans are in comments, and instructions for the machine are the rest. This is why I don&#x27;t like it when the compiler tries to be smart with what I&#x27;m asking the machine, or when it decides to read comments that are not for it (e.g. lack of &quot;fall through&quot;).<br>
<p>
<font class="QuotedText">&gt; The classical example of a vectorized/unrolled loop comes to mind, as you know very well: <a href="https://godbolt.org/z/6Yb5nq94d">https://godbolt.org/z/6Yb5nq94d</a> (here in both C and Rust).</font><br>
<p>
Indeed it&#x27;s absolutely ugly, and very likely extremely inefficient for small loops. But if you add -mno-sse like we have in the kernel, then it becomes perfectly readable again.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862373/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor863086"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 21:26 UTC (Thu)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863086/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However in C it&#x27;s trivial to map the C code to the emitted asm code and compare</font><br>
Actually it&#x27;s not, and it hasn&#x27;t been for a long, long time. Ever since optimizing compilers appeared, really.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863086/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor862224"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 0:10 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862224/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Safe Rust is only superficially more complex than C. Yes, it has more language features, but you don&#x27;t have to think about UB at all, which makes things *vastly* simpler (e.g. no issues with pointer provenance, which casts are safe, etc). You can rely on drop() logic for cleanup, which reduces the need to think about exit path handling. You don&#x27;t have to think about which special values returned from each function are valid results and which are errors. Etc, etc.<br>
<p>
<font class="QuotedText">&gt; I&#x27;ve never seen any of its advocates estimate the risk of logic error that comes from the extreme complexity of the language.</font><br>
<p>
I will: the risk is negligible. I almost never find a bug in my Rust code and thinking &quot;wow, that wouldn&#x27;t have happened if I&#x27;d written this in C or C++&quot;.<br>
<p>
In fact the only case I can think of is when something got cleaned up automatically that I didn&#x27;t want cleaned up. I think I once had a case where I created a named temporary file that I needed to stick around but the TempFile object went out of scope and deleted the file early. (Of course, bugs where you *fail* to clean something up are far more common than bugs where you clean something up too early.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862224/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862225"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 0:19 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862225/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And based on all the patches that I&#x27;ve seen posted, it seems particularly hard to quickly grasp a missing or misplaced check.</font><br>
<p>
One thing that&#x27;s not obvious if you haven&#x27;t used Rust or a similar language before is that the type system (one area where it&#x27;s more complex than C) gives you powerful tools to help avoid missing or misplaced checks.<br>
<p>
The classic example is &quot;newtypes&quot;: define dedicated types that wrap values that need to be checked or sanitized before they can be used. The only way to get at the real value is via an API that performs the check, so the compiler guarantees that the check is performed when necessary. Yes, you can code up something similar in C, but people typically don&#x27;t because you have to write a ton of boilerplate code per type and the generated code is fatter and slower even in optimized builds. In Rust, a struct that wraps a single value is guaranteed to be optimized away in optimized builds.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862225/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862229"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 4:20 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862229/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The classic example is &quot;newtypes&quot;: define dedicated types that wrap values that need to be checked or sanitized before they can be used.</font><br>
<p>
But checking file mode, user ID &amp; capabilities, path permissions etc has nothing to do with types, and requires a specific test sequence that is related to what you&#x27;re doing and not at all to the language or compiler. Testing the file mode before the permissions along the path to that file for example does open security issues by revealing the hidden existence of intermediary path components or even the file&#x27;s existence. And I think that all these important things tend to be completely overlooked or systematically classified under the &quot;just use a type for this and the compiler will do it for you&quot; principle. My point is that no, you must never ever trust a compiler, and not only the code MUST look valid when you read it, and it MUST be easy to check that the emitted object code matches it if you don&#x27;t trust the compiler.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862229/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 6:36 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862240/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can encode a required series of checks in a specific order in Rust&#x27;s type system if you want to. E.g. if you have to check three things in order you can have four types: Checked0, Checked1, Checked2, AllChecked (with better names) where each Checked* has an associated function that consumes its input, does the check, and returns a value of the next type.<br>
<p>
I don&#x27;t know if this kind of thing would be helpful for file modes etc. I&#x27;m not saying that *all* of these kinds of checks can be enforced in the type system. However, a great many checks can. A rich type system, strongly enforced, buys you a *lot* more security than just memory safety.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862488"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 0:09 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862488/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; I'm not saying that *all* of these kinds of checks can be enforced in the type system.</font>

<p><b>All</b> kinds of checks can be encoded in Rust types. You can even put full-blown theorem prover into it.</p>

<p>But then Law of Diminishing Returns hits you: if it takes 100 lines of code to add 2 and 2 and compilation times are measured in hours… it's just not worth it.</p>

<p>But it's question of practical usability where you draw the line, not language capability.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862488/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862241"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 6:38 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862241/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This point about checking the compiler output is interesting.<br>
<p>
What are you checking *for* exactly? Do you check the output on all architectures Linux supports, for all compilers supported? Do you recheck all your code when you update the compiler?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862241/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 6:52 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862244/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What are you checking *for* exactly? Do you check the output on all architectures Linux supports, for all compilers supported? Do you recheck all your code when you update the compiler?</font><br>
<p>
It depends on what I&#x27;m doing. The first motivation for this is to have a quick look at the code to see if the compiler decided to be creative by unrolling short loops or placing else statements at the very end of a function in a location that&#x27;s unlikely prefetched yet, in which case I have to help it be smarter. It&#x27;s also in order to see if it didn&#x27;t decide to optimize away some blocks because I made a mistake resulting in an impossible block being discarded. And it gives me a general sense of the code&#x27;s quality. For example you can see that an inefficient condition requires multiple conditional jumps while it&#x27;s possible to express it differently using arithmetics to reduce the number of tests.<br>
<p>
For performance critical parts, I can spend a lot of time checking various compilers from 3.4 to 11.0 and see if the code differs a lot or not. If the core remains mostly the same, it&#x27;s generally an indication that I&#x27;m not doing something too hard for the compiler. If it changes a lot, I tend to be more careful and to try to get mostly the same code using likely/unlikely, or switching &quot;while/do&quot; with &quot;do/while&quot; or &quot;for&quot; constructs, and such hints. For parts that can involve different arithmetics (multiply, divides) or large spans of bit fields or constants, I also commonly check the output on ARMv8 that is my secondary target. For code that aims to remain efficient on small systems (e.g. networking code), I like to have a look at what MIPS32 code looks like, as this platform is still used a lot in cheap routers, and certain apparently trivial operations can be quite painful there.<br>
<p>
These are just examples, it&#x27;s difficult to explain in a few paragraphs and would take months of training, but I consider that it&#x27;s just part of a normal developers&#x27; job to check the quality and efficiency of the output code :-/<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 7:14 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862246/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OK. You can do all these things about as easily with Rust as with C, in my experience. I don&#x27;t often have the need to do this kind of microoptimization, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor862267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 11:13 UTC (Fri)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/862267/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;d like to propose an opposite observation: &quot;blatant disregard to any concerns raised&quot; is *always* raised when something new comes up and there&#x27;s a vocal minority of opponents. We&#x27;ve seen it with Pulse Audio, with Wayland, with systemd and plenty of other &quot;holy wars&quot;. I don&#x27;t have hard data but it usually goes like this:<br>
<p>
- Here&#x27;s a new that we believe can help a lot with X<br>
- It&#x27;s useless because it doesn&#x27;t have Y<br>
- We&#x27;re aware of it, and working on a fix, but we have to prioritize<br>
- Your blatant disregard for our concerns is astounding!!!!<br>
<p>
It&#x27;s like the concerns were in fact addressed so the opposer has nothing else to be opposed to but still wants to stop it so they pull out a wildcard like this. Emotional language is a sure fire way to detect this. So tone it down, please.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862510"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 9:42 UTC (Sun)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/862510/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
There are two kinds of fool. One says “This is old, and therefore good.” And one says, “This is new, and therefore better”.<br>
– John Brunner, <i>The Shockwave Rider</i>
</blockquote>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862510/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor862124"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 16:59 UTC (Thu)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/862124/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; All of those have a big cost, with no tangible benefits, as, even with a perfect driver conversion from C to Rust, the drivers should keep having exactly the same functionality as before</font><br>
<p>
Sure, if you only care about the generated machine code it&#x27;s hard to justify. But that is such a deliberately narrow view of what the benefits could be that I&#x27;d almost accuse it of being disingenuous.<br>
The arguments for Rust in the kernel have always been about benefits to maintenance that come from being able to make stronger guarantees about code statically. From easier refactoring to increased participation to reduced reluctance to make things multithreaded. If you ignore those, it&#x27;s unsurprising you&#x27;re not convinced.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862124/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862185"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 17:52 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862185/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; See, when a subsystem maintainer would receive the first Rust code for its subsystem, such maintainer will need to not only learn Rust, but will also need to become an expert on it.</font><br>
<p>
That&#x27;s exactly it. To put it blunt, the discussion is important because it&#x27;s more a matter of replacing people than a new way to write code. And it&#x27;s totally natural that those having done their work meticulously for so many years to make what linux currently is, and who are constantly being told they&#x27;ve been doing crap and that others with a magic stick will suddenly avoid all their errors, feel really unpleasant.<br>
<p>
The real risk in this project is to make a number of people give up due to the permanent arrogance around &quot;your code is sh*t, ours will never smell anymore&quot;, or just due to their perceived inability to continue their job.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862185/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862193"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 18:23 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/862193/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      Willy, I think you're misinterpreting the message.  I don't hear "you're doing crap"; instead I hear "with better tools, it would be easier for you to work meticulously".  I'm not taking a position on whether the Rust stuff should go in, but I do think that message is worth listening to and thinking about.  Improved tools have made a big difference in kernel development over the years.
      
          <div class="CommentReplyButton">
            <form action="/Articles/862193/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862212"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 21:49 UTC (Thu)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862212/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Willy, I think you&#x27;re misinterpreting the message. I don&#x27;t hear &quot;you&#x27;re doing crap&quot;; instead I hear &quot;with better tools, it would be easier for you to work meticulously&quot;.</font><br>
<p>
I disagree Jonathan. There&#x27;s so much insistance that we absolutely need it to fix all the trouble we&#x27;re currently supposed to be in that it&#x27;s definitely an statement of the currently quality. There are possibly some well-designed and written parts which have not suffered a memory safety issues in many years. It&#x27;s insulting to present this as an improvement over what was achieved by those doing all this hard work.<br>
<p>
<font class="QuotedText">&gt; I&#x27;m not taking a position on whether the Rust stuff should go in, but I do think that message is worth listening to and thinking about. Improved tools have made a big difference in kernel development over the years.</font><br>
<p>
I have nothing against improving tools, quite the opposite, here we&#x27;re speaking about *replacing* them entirely and trashing the 10,20,30 years of expertise that some developers have accumulated to instantly turn them back to novices who will suddenly have to create huge amounts of beginners&#x27; bugs, as a way to thank them for all their decades-long efforts.<br>
<p>
I made the effort already, of trying to write a hello-world that displayed my age taken from a command line argument. It took me two hours following non-working suggestions in error outputs and copy-pasting random smiley-looking stuff I didn&#x27;t understand from stackoverflow. It&#x27;s clear that I cannot learn this thing. I think we must not dismiss the extreme level of difficulty required to just approach the language. There are probably people that are made for it and others not, and it&#x27;s possible that a number of those being very good C developers that we&#x27;ve collected over time in the kernel might not necessarily fit well with this language. Should they be declared inapt now ?<br>
<p>
In face of this, I must confess I&#x27;m glad not to maintain stable branches anymore, I would be forced to totally ignore any fix for these areas simply by not even understanding anything from them, or to pass the job to someone else and retire. And I&#x27;m pretty sure that some maintainers currently feel the same, and it&#x27;s understandable.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862212/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862214"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 22:30 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/862214/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      Those maintainers are going to retire someday anyway — some of us are getting a little long in the tooth...:)  They will take their 30 years of experience with them.  It's not at all clear that Kids These Days have much enthusiasm for accumulating similar amounts of experience, especially in a world where other development environments make it so you don't <i>need</i> that experience.
<p>
That is where we differ, I guess.  You see the Rust advocates as attacking the quality of the kernel and its developers.  Some probably are; there's no shortage of obnoxious language zealots out there, for any language.  But I think the people behind this effort are, instead, attacking (if you want to use that word) the need to accumulate all that experience (which comes the hard way!) and the need to be meticulous about whole classes of things when we have computers that can do that for us.
<p>
I'm not entirely convinced about Rust in the kernel either, but I'm glad that people are exploring this area and showing us what it would look like.  This is how the community will develop the experience it will need to keep the kernel going for the next 30 years.
      
          <div class="CommentReplyButton">
            <form action="/Articles/862214/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862231"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 4:41 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862231/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Those maintainers are going to retire someday anyway — some of us are getting a little long in the tooth...:)</font><br>
<p>
Sure!<br>
<p>
<font class="QuotedText">&gt; They will take their 30 years of experience with them. It&#x27;s not at all clear that Kids These Days have much enthusiasm for accumulating similar amounts of experience, especially in a world where other development environments make it so you don&#x27;t need that experience.</font><br>
<p>
Probably, but throwing all existing working code through the drain and rewriting everything, with a 20-years transition period during which nobody will understand both what it does and what it was expected to do can have devastating impacts. And I&#x27;m not even trying to imagine the situation consisting in replacing Rust by $language_of_the_year 10 years from now before the transition was complete just because another set of fanboys put money on the table to sponsor another conversion to catch a trophee!<br>
<p>
Maybe rewriting a full OS from scratch in Rust for the next 30 years will be easier than trying to progressively replace the one the whole internet runs on and that cannot be trivially changed that way. Will the new developers accept to maintain old code they didn&#x27;t write ?  I  guess I know the response &quot;I don&#x27;t read this language, let&#x27;s first rewrite this&quot;. That&#x27;s not a way to do proper software maintenance, to replace bugs with new ones.<br>
<p>
And my gut feeling is that the amount of efforts required to put that into the kernel is 100 times higher than the amount of efforts required to improve the C language and compilers. And with that amount of effort, instead of replacing one project at a time, it becomes possible to help many projects at once.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862231/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 7:26 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862247/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One can imagine doing a sort of longitudinal upgrade of the Linux kernel, where you gradually add features to C and remove features from C and update the kernel accordingly until you have something with the benefits of Rust. That would be more incremental than writing new kernel components in Rust, in some sense, and perhaps be more palatable because all along you can say it&#x27;s &quot;just kernel C&quot;.<br>
<p>
One problem with that approach, however, is that only the kernel will be using that language. Maybe Linux could get away with that. It&#x27;s a barrier to entry, but in practice it doesn&#x27;t matter how high the barrier to entry is for kernel development, while Linux is so dominant in the market.<br>
<p>
Other problems with that approach of course is that it would be incredibly expensive and slow and you&#x27;d need to draft the gcc team into it etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 9:40 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862264/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s not necessarily as difficult as the proposed solution because maintainers have always progressively replaced other ones. It&#x27;s easy to spot good ones and get them up to speed until you can let them run the business alone. It&#x27;s much harder to replace people with no ability to help because there&#x27;s nothing to share between teams due to code, language, approach, knowledge etc being different. It&#x27;s really about replacing people rather than improving code. I&#x27;m not kidding.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862328"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 18:14 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/862328/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Probably, but throwing all existing working code through the drain and rewriting everything, with a 20-years transition period during which nobody will understand both what it does and what it was expected to do can have devastating impacts. And I&#x27;m not even trying to imagine the situation consisting in replacing Rust by $language_of_the_year 10 years from now before the transition was complete just because another set of fanboys put money on the table to sponsor another conversion to catch a trophee!</font><br>
<p>
Not knowing how this works, but can you write a library crate and access it via C calls? If you can write chunks of code in Rust, which will enable you to say &quot;this bit of code at least is memory-safe&quot;, and link it in to the rest of the kernel, then yes the kernel will become a bif of a chimera, but you can steadily propagate Rust through the kernel, even to the extent maybe of saying &quot;all new code will be in Rust&quot;. At which point the C code will become legacy and rust away :-)<br>
<p>
And yes, I&#x27;m reading up on Rust and thinking &quot;what the hell is this?&quot;. It looks great - and coming from FORTRAN and PL/1 originally I&#x27;m not a fan of C - but I&#x27;m struggling with understanding it all, too.<br>
<p>
The ability to call crates from C would be brilliant, aiui you can call C from crates ...<br>
<p>
Cheers,<br>
Wol<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862328/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862345"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 21:58 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/862345/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, you can. At <a href="https://github.com/bonzini/rust-and-c">https://github.com/bonzini/rust-and-c</a> you can find a (toy) example of starting with C code, adding a Rust wrapper, and ending with a C-compatible Rust implementation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862345/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862489"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 0:27 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862489/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; And yes, I'm reading up on Rust and thinking "what the hell is this?".</font>

<p>The short answer is: Haskell. Rust pretends that it's C-family language, but deep under it all it's a bunch of ideas from the functional languages brought to C-style world.</p>

<p>What I find surpising about Rust is the fact that while it's language construct look totally alien to C/C++/Java developers at first… after some digging around you find, to your astonishment, that they map exactly not on the <b>language constructs</b> of of C/C++/Java but on <b>design patterns</b> used by C/C++/Java developers.</p>

<p>E.g. dynamic trait objects is <b>precisely</b> how kernel does OOP. While ownership and borrows is what so-called “modern C++” (with <code>std::unique_ptr</code> and rvalue references) tries to push.</p>

<p>P.S. It doesn't yet have monads and other higher kind things from Haskell. But they are working on it.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862489/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor862227"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 0:33 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862227/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Asking kernel developers to learn a new language is certainly a big deal.<br>
<p>
Part of the problem is that it&#x27;s less incremental than simply extending C with more language extensions, more sanitizers, more coding rules, etc. That latter is always going to be the path of least resistance for existing developers, but eventually (if not already) it will be more of a cognitive burden to use than a new language.<br>
<p>
Another part of the problem is well illustrated by your comment here: when you&#x27;re an expert in everything you currently use, diving into something in which you&#x27;re not already expert is a blow to the ego. That&#x27;s a real issue.<br>
<p>
The position &quot;Linux kernel developers shall never need to learn a new language, regardless of the benefits&quot; may prevail, but if it does, then eventually Linux will have to be replaced.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862227/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 4:29 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862230/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Another part of the problem is well illustrated by your comment here: when you&#x27;re an expert in everything you currently use, diving into something in which you&#x27;re not already expert is a blow to the ego. That&#x27;s a real issue.</font><br>
<p>
It&#x27;s a strange statement. I&#x27;m speaking about one&#x27;s efficiency at some task and you turn that to ego. I think on the opposite that most experts have no particular ego and are only interested in the quality of what they&#x27;re producing, and this starts by openly admitting one&#x27;s own bugs. Being denied this ability can certainly be a big problem.<br>
<p>
If you&#x27;re used to cook your own meals from good raw products and suddenly someone replaces them with industrial ones and says &quot;they were pre-mixed and cleaned in factory for you, do not worry, you will eventually learn how to cook with them&quot;, you know you&#x27;re going to eat awful tasting crap for a long time despite your huge efforts, and you&#x27;re probably not interested in this unpleasant experience when you know that with much less efforts your meals can taste much better. And if you&#x27;re a chef in a restaurant you can even fear losing all your customers at this game.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 8:31 UTC (Fri)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/862255/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the outside world, this kind of thing - forming alliances based on silly things like favourite programming language - would be called &quot;identity politics&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862265"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 9:42 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862265/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, it&#x27;s called &quot;mentoring&quot;.<br>
<p>
If you take a student out of whatever school you want an name him general to conduct an army, or director of the nuclear power plant or whatever without having passed time learning all the fine details of how the stuff works, you may eventually end up with some good surprises but you are almost certain to pass through terrible ones.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862265/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 22:00 UTC (Fri)
                               by <b>polyergic</b> (guest, #153186)
                              [<a href="/Articles/862344/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t have a dog in this fight. I have not nor do I anticipate contributing to the Linux kernel. Reading Rust hurts my head about as much as reading C--the former because the language is unfamiliar; the latter because there are booby traps everywhere.<br>
<p>
<font class="QuotedText">&gt; If you&#x27;re used to cook your own meals from good raw products and suddenly someone replaces them with industrial ones and says &quot;they were pre-mixed and cleaned in factory for you, do not worry, you will eventually learn how to cook with them&quot;, you know you&#x27;re going to eat awful tasting crap for a long time despite your huge efforts, and you&#x27;re probably not interested in this unpleasant experience when you know that with much less efforts your meals can taste much better. And if you&#x27;re a chef in a restaurant you can even fear losing all your customers at this game.</font><br>
That in mind, I think this analogy is both silly and ill-fitting... it&#x27;s not as if using a different programming language is at all akin to &quot;industrial products&quot; (???) instead of &quot;good raw products.&quot; It sounds like Rust is pre-chewed dog food to you!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor862268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 11:29 UTC (Fri)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/862268/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I have nothing against improving tools, quite the opposite, here we&#x27;re speaking about *replacing* them entirely and trashing the 10,20,30 years of expertise that some developers have accumulated to instantly turn them back to novices</font><br>
<p>
I acknowledge this, but here&#x27;s the thing. I have huge respect for experience and while I &quot;only&quot; have 20 years of professional programming behind me, I already can see how you can see all this hard-won knowledge and think &quot;it is what it is&quot; and that you *have* to go through all these fights to become good at your work. But - I think it&#x27;s time we learned *something* from all those years of experience. Rust, for me, is an embodiment of these lessons.<br>
<p>
I&#x27;m not one of those obnoxious advocates who are going to push Rust everywhere, but it would be really nice if projects like Linux found a way to include it and made it work for their purposes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 15:08 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/862317/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The flip side of this is that this is, or may ultimately become, an opportunity to take some of this 20+-year experience and bake it into the interface,.<br>
<p>
Using Rust to ensure memory safety (no double free, no race conditions, no memory leaks, sane error paths) is, by itself, strictly superior to (a) keeping track of all the idioms we&#x27;re using in C to do this manually and (b) writing and maintaining a bunch of imperfect combs (sparse, coverity, …) that go through the kernel&#x27;s code and try to ensure (emphasis on &quot;try&quot;) that there aren&#x27;t any.<br>
<p>
Note the &quot;by itself&quot;. As always there are other considerations to be taken into account.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862324"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 17:52 UTC (Fri)
                               by <b>ericonr</b> (guest, #151527)
                              [<a href="/Articles/862324/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust doesn&#x27;t protect against memory leaks. Those are not memory safety issues. I would assume the RAII stuff makes leaks harder, but they are still possible in 100% safe code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862324/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862490"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Meticulous work</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 0:36 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862490/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p><b>Nothing</b> can prevent memory leaks. After all nothing stops you from implementing x86 emulator on top of any modern language and then running C program in that emulator.</p>

<p>Java guys would claim that it's not a “real” memory leak (because there are live references to all that garbage, you see), but users of these Java-monstrosities which consume gigabytes if RAM before finally crashing don't feel very sympathetic.</p>

<p>That was the reason for why Rust lost GC (yes, believe it or not early versions of Rust used green threads and GC!): you can prevent the majority of leaks with just a simple borrow-checker and the remaining ones are almost as easy to fix as memory leaks in languages with GC.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862490/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor862200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 20:05 UTC (Thu)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/862200/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; See, when a subsystem maintainer would receive the first Rust code for its subsystem, such maintainer will need to not only learn Rust, but will also need to become an expert on it.</font><br>
<p>
It is up to each subsystem whether they want to provide Rust APIs and therefore accept Rust modules or not.<br>
<p>
This follows from the design we have where Rust modules should not directly talk to C APIs.<br>
<p>
<font class="QuotedText">&gt; Even if Rust itself is already known by the maintainer, this is not enough, as for sure there will be a lot of glue in order for Rust to see Kernel objects, refcounts, kalloc, etc.</font><br>
<p>
General facilities are shared -- subsystem maintainers do not need to maintain those in every subsystem.<br>
<p>
<font class="QuotedText">&gt; Also, some extra kAPI patches will be needed in order make the subsystem-specific kAPI visible in Rust.</font><br>
<p>
In most cases, the C API does not require patches -- Rust is one consumer more.<br>
<p>
But obviously, Rust code is needed if one wants to abstract the C API.<br>
<p>
<font class="QuotedText">&gt; The Rust code could also have worse performance, memory consumption, power consumption, etc than if the same code was written in C.</font><br>
<p>
Yes, it could.<br>
<p>
It could also be better, for at least several reasons:<br>
<p>
  - Rust is able to provide better aliasing information to optimizers (though currently it is unused due to bugs in LLVM&#x27;s optimizer).<br>
<p>
  - Rust prevents data races, thus people may start using concurrency more.<br>
<p>
  - Rust prevents using non-thread-safe types in a multi-threaded scenario. Thus, for instance, you may use a non-atomic refcount without fear that somebody later may share it with another thread by mistake (and thus choosing an atomic one even if you do not need it).<br>
<p>
<font class="QuotedText">&gt; Hard to measure, except if the same driver would be written on both languages.</font><br>
<p>
We have C Binder and Rust Binder and they can be compared.<br>
<p>
Later on, and specially if Rust gets into mainline, we will likely have more drivers that may be compared.<br>
<p>
<font class="QuotedText">&gt; All of those have a big cost, with no tangible benefits,</font><br>
<p>
Please read the RFC from April for a summary of the benefits.<br>
<p>
<font class="QuotedText">&gt; So, the conversion step won&#x27;t have any user-visible effect.</font><br>
<p>
Memory-safety, for instance, has user-visible consequences.<br>
<p>
<font class="QuotedText">&gt; That not mentioning that any driver rework will almost certainly bring new bugs</font><br>
<p>
For new drivers this does not apply.<br>
<p>
And, for old drivers, while one can definitely introduce new logic bugs, it can also be the case that you remove some, e.g. if you had a bug in the C implementation that Rust statically prevents.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862213"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 21:35 UTC (Thu)
                               by <b>BirAdam</b> (guest, #132170)
                              [<a href="/Articles/862213/">Link</a>] (42 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is, in my mind, one bigger issue with using Rust in the kernel. Rust is not stable in the sense of a set and defined language that changes little over time. I can compile ancient C code in a modern environment. Rust, in its short life, has already broken backward compatibility. To me, this makes Rust a terrible systems language. For whatever memory safety and type advantages it may bring, it will grow the maintenance burden radically.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862213/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862222"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 23:54 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862222/">Link</a>] (41 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For safe Rust code, there have been very few compatibility breaks in the 6 years since Rust 1.0. It really is incredibly rare, and when it does happen, it&#x27;s almost always because the code was actually unsound and *needs* to not compile. Breaks for unsafe code are a little more common but still rare, and most Rust devs write very little unsafe code.<br>
<p>
<font class="QuotedText">&gt; I can compile ancient C code in a modern environment</font><br>
<p>
You might be able to compile that ancient C code with modern compilers, but a lot of ancient C code does not *work* when compiled with optimizations enabled, because it does things which have been declared UB and which the optimizer now miscompiles. And of course, when you do have a compatibility break, it&#x27;s much better for it to fail to compile (Rust) than to compile but fail at run time (C).<br>
<p>
The situation for C is much worse if you compile with -Werror --- which you really want to do, because really stupid stuff like &quot;no return statement in function returning non-void&quot; is not an error in C. With -Werror you often need to make significant changes for new major compiler versions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862222/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 7:38 UTC (Fri)
                               by <b>bartoc</b> (guest, #124262)
                              [<a href="/Articles/862250/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even C and C++ break are willing to break unsafe code (code that&#x27;s basically always a bug).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 8:33 UTC (Fri)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/862256/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I understand it, Rust unsafe code isn&#x27;t &quot;basically always a bug&quot; - it&#x27;s code that won&#x27;t pass the type checker, possibly because the type checker isn&#x27;t sophisticated enough or the code is too complex or the result isn&#x27;t statically knowable (like interpreting a DMA buffer).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862273"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 11:54 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862273/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s right. (Though &quot;interpreting a DMA buffer&quot; would usually not require unsafe code, I think.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862273/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 0:53 UTC (Sat)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/862360/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not exactly -- Rust unsafe code is just a superset of Rust safe code. That is, it allows a few extra operations like dereferencing a raw pointer, but it still has to pass the type and borrow checkers, and has nothing to do with having a bug or not.<br>
<p>
In other words, you may have bugs (or not) in both safe and unsafe code. What you cannot have is UB in safe code (as long as unsafe code is sound).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862584"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 10:29 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/862584/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Even Unsafe Rust has to pass the type checker etc; it's not a free-for-all. There are <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">5 "unsafe superpowers"</a> which are the 3 operations that can break Safe Rust's promises (no undefined behaviour, no memory unsafety, no data races between threads) if misused, plus 2 more related to making <tt>unsafe</tt> usable within abstractions.
<p>The idea is that within a module (the privacy boundary in Rust), you can develop a Safe Rust abstraction over potentially dangerous operations, and the <tt>unsafe</tt> keyword marks out places where you can break Safe Rust invariants in your module. It's then easier to audit the module for broken invariants that lead to UB, broken memory safety or data races, because the presence of such invariants is marked out by <tt>unsafe</tt>; you can look at <tt>unsafe</tt> blocks, confirm that they are not themselves broken, and then confirm that the rest of the module (Safe or Unsafe Rust) does not break the invariants the <tt>unsafe</tt> blocks depend on. The Rust unsafe book has an example where it reimplements <a href="https://doc.rust-lang.org/nomicon/vec.html">Rust's <tt>std::vec::Vec</tt></a> without some of the complexity in the real implementation; if you look at the <a href="https://doc.rust-lang.org/nomicon/vec-final.html">final code</a>, you'll see that you need to audit all the <tt>unsafe</tt> blocks, and that the <tt>unsafe</tt> blocks depend upon <tt>cap</tt> and <tt>len</tt> struct members not being manipulated badly by Safe Rust.
<p>So, you audit the Safe Rust in this module for bad manipulations of those two variables; you audit the Unsafe Rust for the full range of broken invariants, and you have a safe abstraction in the sense that Rust uses the term safe; because you've put this code in its own module, you know that external code cannot manipulate <tt>len</tt> or <tt>cap</tt> directly, and thus can focus your audit efforts on just that module to confirm no UB, unsafe memory accesses, or data races.
<p>Taking your example of interpreting a DMA buffer; I'd need to use Unsafe Rust (in the form of <a href="https://doc.rust-lang.org/core/slice/fn.from_raw_parts.html"><tt>slice::from_raw_parts</tt></a>) to turn the DMA buffer start address and length into a <tt>[u8]</tt>, but from there I can rely on Safe Rust to interpret the byte slice into whatever it contains. I could also use other unsafe functions from <a href="https://doc.rust-lang.org/core/ptr/index.html"><tt>core::ptr</tt></a> to do more sophisticated tricks - e.g. copy individual unaligned words from the DMA buffer, or interpret the DMA buffer directly as a <tt>#[repr(C, packed(1))]</tt> struct that Safe Rust can read.
      
          <div class="CommentReplyButton">
            <form action="/Articles/862584/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor862363"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 2:18 UTC (Sat)
                               by <b>BirAdam</b> (guest, #132170)
                              [<a href="/Articles/862363/">Link</a>] (35 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Say what you will, but will current Rust code still compile and run in 30 years? For the Linux kernel this is a very real concern. This is a test that I do not believe Rust can reasonably pass.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862363/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862378"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 9:31 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/862378/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Say what you will, but will current Rust code still compile and run in 30 years? For the Linux kernel this is a very real concern. This is a test that I do not believe Rust can reasonably pass.</font><br>
<p>
Rust is making very hard guarantees about backward compatibility. Thus I would guess that the chances of compiling the code with a compiler from the future are much higher with Rust than with C. Have you tried compiling 30 year old C code with a modern compiler? I do not mean a hello world program. Just take one of the earlier linux kernels. I just had a quick try and I did not even manage to do a make config.<br>
<p>
The test you are describing is a test that C has already shown that it cannot pass. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862378/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 16:56 UTC (Sat)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/862395/">Link</a>] (33 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good luck compiling even a 10 year old kernel with a modern compiler... Just tried with v3.0.0 for fun. 1st error &quot;cc1: error: code model kernel does not support PIC mode<br>
&quot;, googling solution to that and next error is &quot;fatal error: linux/compiler-gcc7.h: No such file or directory&quot;. Didn&#x27;t try to go any further.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 17:46 UTC (Sat)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862402/">Link</a>] (32 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This has nothing to do with the language but with compiler options. And gcc isn&#x27;t exactly a model of software helping with backwards compatibility, sadly. It&#x27;s probably one of the pieces of software responsible for the creation of Rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862491"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 0:46 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862491/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; It's probably one of the pieces of software responsible for the creation of Rust.</font>

<p>I'm pretty sure it was clang. At least in GCC, even in latest version, <code>be || !be</code> is still <code>true</code>. In clang it can be <code>false</code>, <a href="https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAM1QDsCBlZAQwBtMQBGAFlJvoCqAZ0wAFAB4gA5AAYppAFZdSrZrVAB9LclIj2yAnjqVMtdAGFUrAK4BbWiAAcpU%2BgAyeWpgBydgEaYxCAATKQADqhChEa0ljb2TuGR0XQeXr62AUGhepgGMQwEzMQEcXYOzrn5dIXFBGk%2B/oEhukUlZQmVbfWejZnNwQCUuqjWxMgcUp4EANREGgEaJBq0qAQa8wEQgzMApADsAEK7MgCCMxcz0zMBuwDMx2eXM8SYBGO0N5h7%2B%2BYH5jMwGBbg8TqcDgARKTDVjSACs8gcsnkqGkAKEo3G312wTunHkBGkckGwwA1lwZDIVNJuPJbCA4VSkXJSKipPIhCAqYTkcM4LAYIgUKhbGE8OwyBQIGhReLmshkKp1JxgpS%2BOKCIFORA/ET5H5PMUAJ7SfGkGW2UwEADytFYJuRpCwtjUwHYeqdeFe%2BQAbphOY7MOI8tZNab5NNMLDHaw8H5iMbLFgPQRiHh6VJ8cN%2BIwWO6eHw6ARhGJJI6lJwVK6QFoNDpY35OZBhqgwoY6AGALTW4IcqN5dsOCCuDoOSuuBoZLLKCJRQejmfJQeTppBStVQe1dpWcrKDcFbor/pr1p1Bfrw%2B9KfNTjDDFjCZcGHwxEetniRwANk7n%2B4M0VrozCqAB0MigTMEC4IQJB7LilYzJYsoSrBeI7OYBJ6iSpAIJgzBYEE2ykOSjLUlItKkPSJHMii0gclypA8sSpD8kKMpihK5CUGxcpBMgwCcAJ6qsJqxDarqjoGrQxrhuaIqWvQtr2h6zquu6jr4N6hh%2BgGLJBiGYaZhG9BRh6DYJsQRpJpMLKpum4bZkWTBsBwBY5iWEgekooRKpo2gqHGTaEa2g5dj2fb6IOJhmOeLhmEe06VrOKSxDuCSJUuMTxTeuj9tUtBbqUqVjjlEUHnUWUnkI3QxVV5VXquT4jA%2BLnPlICKkNRrLSB%2B36/jMwAKkBnDAZwEFQUQxAofBiHsYEKFDAhGG8sMOF4c0hHEVS0bkZ1bJ0dymGtb2FEMkyb60Qxh2kXcr6Ontl3LaQfqiTEIDcEAA">easily</a>.

      
          <div class="CommentReplyButton">
            <form action="/Articles/862491/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862511"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 9:59 UTC (Sun)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/862511/">Link</a>] (30 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well … it&#x27;s an uninitialized variable, so the result is undefined, so it may just as well be zero. Did you expect anything else?<br>
<p>
The problem here is that C is supposed to be a language that runs on real hardware. Real hardware however cannot behave like this. Thus an optimizer that resolves undefined behavior to a result that&#x27;s physically impossible is broken IMHO.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862511/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862512"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2021 10:16 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862512/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Well … it's an uninitialized variable, so the result is undefined, so it may just as well be zero.</font>

<p>If <code>be</code> would be zero then <code>!be</code> would be non-zero thus the final value of <code>be || !be</code> would still be true.</p>

<p>And please don't tell me how and why clang produced that craziness. I know. Again: Rust developers (who are trying to make sure language would be usable not trying to justify craziness by standard lawyers) <a href="https://www.ralfj.de/blog/2019/07/14/uninit.html">explained all that</a>.</p>

<p>And, again, the main justification was “let's break the programs because we are allowed to… it's fun: silly developers scream so funnily when they discover the breakage” (the last part wasn't said but was just implied, obviously).</p>

<font class="QuotedText">&gt; Thus an optimizer that resolves undefined behavior to a result that's physically impossible is broken IMHO.</font>

<p>It's worse than that. Not only it resolves undefined behavior into something that's physically impossible <b>as an accident</b>. Compiler actually includes bunch of code which find and exploits such things in your program. To make it “more optimal”.</p>

<p>And they are <b>proud</b> that they are doing that: <i>if you believe pointers are mere addresses, you are not writing C++; you are writing the C of K&amp;R, which is a dead language</i> — these are their words, not mine.</p>

<p>If that's not an act of a sabotage then what is it?
      
          <div class="CommentReplyButton">
            <form action="/Articles/862512/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862559"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 0:35 UTC (Mon)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/862559/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If that&#x27;s not an act of a sabotage then what is it? </font><br>
<p>
Making a better compiler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862559/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor863105"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2021 23:25 UTC (Thu)
                               by <b>Vipketsh</b> (guest, #134480)
                              [<a href="/Articles/863105/">Link</a>] (27 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Did you expect anything else?</font><br>
<p>
Yes.  I expect the number system (set of values and operators) to be at least a ring, preferably a field.  (be || !be) turning into false means that the system is not a ring.  If it&#x27;s not, I can not reason about it and hence can not understand the code.  Is it really so much to ask that arithmetic works the way we all learned it in primary school ?<br>
<p>
In the world of HW development the predominant language, Verilog, has the infamous four value system: each bit can be from the set {0,1,Z,X}, where &quot;X&quot; is intended to model &quot;undefined&quot; (as in the value is undefined, not in the sense of C&#x27;s &quot;undefined behaviour&quot; -- it&#x27;s behaviour is fully defined[1]).  From experience in this world it is abundantly clear that the behvaiour of &quot;undefined&quot; has a tendency to result is non-working HW simulations and many weeks wasted hacking around the fact that the synthesis tool (compiler) changed expressions to propagate the X differently.  I have also found that many times it hides real bugs.  It&#x27;s probably too much to ask, but still would be good if compiler authors look a bit at how &quot;undefined&quot; values played out in practice elsewhere.<br>
<p>
[1] For example (be || !be)=X if be=X.  On the other hand (X ? a : b) is a/b if a=0/b=0 or a=1/b=1 and X otherwise.  However if(X) is always false.  In many ways it is similar to the idea that clang has.  It doesn&#x27;t work very well for verilog, I doubt it will work well for clang.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863105/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863130"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 6:31 UTC (Fri)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/863130/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of the fundamental principles of programming is that you don&#x27;t evaluate expressions containing uninitialised variables. Trying to reason about it makes as much sense as trying to reason about code with syntax errors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863130/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 7:48 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/863131/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      I don't know where you get the idea from that this is a fundamental principle of anything. In any case, I disagree.
<p>
The problem with this kind of reasoning is that real machines don't have tri-valued bits. If the optimizer can prove that no matter which value a variable contains, the result of the expression must be X, it has no business whatsoever returning Y, much less without bloody well telling the programmer about it.
<p>
Alternate reasoning: Yes, assuming X==undefined, then X||!X is also undefined in the strict maths sense. However, the compiler doesn't not-evaluate / optimize this expression to X, it not-evaluates / optimizes it away to zero and <b>doesn't bother to tell you</b>.
<p>
It actually makes a lot of sense to reason about syntax errors. You intuit what the programmer might have meant (which frequently is much more complicated than "there's a missing closing brace here" at the very end of your ten-k-lines file when the real reason is a misplaced quote in line 42), then <b>you fail the compilation anyway</b>. 
<p>
The fact that it is impossible to do the same thing (or at least emit a warning) with obviously-specious cannot-happen-in-a-real-computer "UB" reflects on the idiocy of the C standardization people and/or the compiler writers. Nothing to do with any fundamental principle.
      
          <div class="CommentReplyButton">
            <form action="/Articles/863131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 12:49 UTC (Fri)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/863151/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;The problem with this kind of reasoning is that real machines don&#x27;t have tri-valued bits.</font><br>
<p>
Yes, of course the memory of (current) real machines contains either zeroes or ones, regardless if the variable occupying the memory bits has been initialized or not. But Vipketsh was introducing &quot;strict maths&quot; into the discussion, and my point was that it is useless to think in terms of  school algebra, and rings and fields if your input is undefined.<br>
<p>
I understand the frustration some people (including you) have with the C++ standard and compilers, but that was not my point.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 14:26 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863183/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; But Vipketsh was introducing "strict maths" into the discussion, and my point was that it is useless to think in terms of school algebra, and rings and fields if your input is undefined.</font>

<p>Except my input is not “undefined”. It's “unspecified”. There are no such thing as “undefined input” in C standard.</p>

<p>Sure, <b>behavior</b> (not input!) is “undefined” but without special “maximum destruction module” added into the compiler specifically to attempt to make sure people would start abandoning C and C++ <code>be || !be → false</code> wouldn't be possible.</p>

<p>LLVM developers had to do <b>significant</b> amount of work to make sure they can reliably break math. It doesn't happen just by accident. You have to introduce special <i>poison</i> value, you have to define rules of doing calculations with it which turn well-behaving programs into misbehaving, etc.</p>

<p>It's a lot of work.</p>

<p>The best interpretation which comes to mind: C/C++ compiler developers are, actually, true altruists and wouldn't mind if everyone would stop using these toxic languages and switch to something else — but they are constrained by their managers and couldn't just flat out say that. That is why they turned <i>huge bodies of C</i> code into <i>a land mines just waiting to explode</i> (their <a href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html">words</a>, not mine).</p>

<p>And while I appreciate the effort… and admit that it may prove to be the best one to achieve that goal… I would have preferred if they would have picked some other approach. Yes, at this point people are ready to understand that they have to abandon C (they still do <a href="https://lwn.net/Articles/763641/">feeble attempts to save it</a>, but it's obvious they are deemed to fail), but was it <b>really</b> impossible to achieve the same <b>without</b> introducing so many security holes and <b>without</b> making people feel so miserable?</p>

<p>Maybe the answer is “no”, maybe it's <b>really</b> the best way… but still… somehow it doesn't feel like it was the only choice.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863194"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 15:11 UTC (Fri)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/863194/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was talking about input in a more abstract sense, like the input to mathematical equations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863194/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863500"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 19:55 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/863500/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And when your input is unknown?<br>
<p>
All this is basic &quot;given an unknown value X, what can we deduce?&quot;. And from what everybody seems to be saying, the answer is &quot;don&#x27;t try using a C program to deduce anything!&quot;<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863500/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor863132"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 8:29 UTC (Fri)
                               by <b>Vipketsh</b> (guest, #134480)
                              [<a href="/Articles/863132/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A fundamental principal of all arithmetic is that (be || !be) evaluates to true in all cases.  The reason it does so is because the system is at least a ring.  The thing is that all those nice transformations we learned in school, say (a+b-b)=a, is valid only because the system is a ring.  If it is not a ring, it is not necessarily valid and requires extra proofs.<br>
<p>
The way llvm arrives at the answer of (be || !be)=false is by extending the usual system with two elements: poison and undef, defined in a way that the resulting system is not a ring anymore.  (be || !be)=false proves that.  If their system is not a ring how do they reason about *any* expression transformation ?  Because the usual reasoning of &quot;I am a ring and ring theory tells me it is valid&quot; is not applicable anymore.<br>
<p>
A sane way to reason about uninitialised variables is that it takes some value from the usual system, you just don&#x27;t know which.  In that case your system is still a ring and thus get all the nice (and expected) things ring theory guarantees, like (be || !be)=true.  Yes, you can&#x27;t reason about what printf will give you for it, but you also don&#x27;t throw away the mathematical underpinnings of everything.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863132/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863142"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 9:48 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/863142/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (be || !be)=false</font><br>
<p>
The thing is, it doesn&#x27;t actually think that. If &quot;be&quot; is undef, the result of the whole thing is also undef, which is perfectly fine.<br>
<p>
The problem is that one of the next steps decides undef ≃ zero because undef ∈ UB and UB means &quot;the compiler can do anything it bloody well wants to&quot;, including not telling anybody about it.¹<br>
<p>
I consider all of these assumptions to be deeply flawed.<br>
<p>
(1) I know that it will do so in this case if you turn on warnings, but there are plenty of situations where it won&#x27;t.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863142/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor863147"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 12:05 UTC (Fri)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/863147/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;A fundamental principal of all arithmetic is that (be || !be) evaluates to true in all cases.</font><br>
<p>
Really? Also in the case the value of be is undefined?  Undefined in the sense that it is not an unknown to be deduced from the values of other variables, but it truly has no value.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863147/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 12:29 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863152/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Undefined in the sense that it is not an unknown to be deduced from the values of other variables, but it truly has no value.</font>

<p>But <b>everything</b> have some value when your program is executed on CPU.</p>

<p><b>That</b> is the fundamental disconnect between C/C++ compiler developers and users of said developers.</p>

<p>The people who are writing an actual program are not interested in appeasing C/C++ $DEITY. They just want to have working program which they can either sell or use.</p>

<p>C/C++ compiler developers are not interested in working programs. They fulfill various KPI (some want to some certain improvements on benchmarks to earn their bonus, some want to publish article and get the grant, etc), but actual C/C++ developers are, basically, an obstacle for them.</p>

<p>This perverse state of the affairs if what caused this crisis.</p>

<p>Only creation of Rust revealed the truth. And not directly but because Rust developers used LLVM to build Rust and tried to just find out what specs there are for that creature… yet found nothing. Nothing mathematically sound at least.</p>

<p>Note that most attempts to show that C/C++ compilers language models are unsound (as in: they can produce anything at all as their output and it's a miracle that they sometimes produce working code) come from Rust developers, not C/C++ developers.</p>

<p>C/C++ compiler developers started talking about provenance <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/dr_260.htm">more than 20 years ago</a> yet only after creation of Rust and an attempt to actually use that much-talked-about for mathematically defined target it was revealed that their models are totally unusable (before that happened they were rejected two times by C committee, but it was perceived as nit-picking of committee, not symptom of something more sinister).</p>

<p>This tells us volumes about the C/C++ developers goals and their priorities, isn't it?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor863143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 9:57 UTC (Fri)
                               by <b>mbunkus</b> (subscriber, #87248)
                              [<a href="/Articles/863143/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To me (a C++ developer for 25 years or so) such things look so hostile.<br>
<p>
It&#x27;s clear that the user must not use uninitialized values.<br>
<p>
It&#x27;s also clear that the compiler knows that the value being uninitialized, otherwise it wouldn&#x27;t be able to do some of those optimizations we&#x27;re talking about.<br>
<p>
But instead of helping the programmer by rejecting that use the compiler goes off and does optimizations that result in all kinds of possible situations including security issues.<br>
<p>
Yeah sure, the human wasn&#x27;t perfect. But the compiler is punishing you for it instead of helping you.<br>
<p>
Same argument with the pointer comparison example khim used. Someone said: you must not use invalid pointers. Sure, I guess we all know that. But sometimes we do, unintentionally. And the compiler knows that the pointer must be invalid now as it does its crazy optimizations instead of helping the user fix their mistake.<br>
<p>
In the face of UB I often feel completely helpless. I know I make mistakes, and the compiler isn&#x27;t helping me. At all. If compiler devs cannot create a helpful compiler &quot;because the spec&quot;, then the language is broken and ill-suited for creating bug-free programs.<br>
<p>
I would love to able to switch to Rust (for other reasons, too), but unfortunately my main work is Qt-based, and I&#x27;d have to throw all of that away. I will definitely not write new programs in C++ anymore.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 11:14 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863144/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; And the compiler knows that the pointer must be invalid now as it does its crazy optimizations instead of helping the user fix their mistake.</font>

<p>Nah. Compiler doesn't know that. Semantic of the <code>realloc</code> is actually pretty complex: because it may return <code>NULL</code> (and then you are supposed to use the pointer which was passed to <code>realloc</code> to access the object) you couldn't blindly assume <code>p</code> is invalid.</p>

<p>That's why clang doesn't do that. Instead it adds “noalias” attributes to these pointers. Remember <a href="https://groups.google.com/g/comp.lang.c/c/K0Cz2s9il3E/m/YDyo_xaRG5kJ">these</a>? The ones which were rejected in 1988 because they made almost impossible to write real programs in that language? Well… compiler developers haven't given up. They called these “pointer provenance” and built the whole house of cards on top of that.</p>

<p>Because <code>p</code> and <code>q</code> are “noalias” and couldn't ever point to the same memory (not even after <code>if (p == q)</code> comparison which is explicitly permitted by standard) clang does what it does.</p>

<p>And why <code>if (p == q)</code> doesn't remove “noalias” attribute? Why: it would make code slower! And, apparently, in correct program it shouldn't matter.</p>

<p>Except it <b>does</b> matter. All modern compilers miscompile certain valid programs (that's the reason “pointer provenance” wasn't added to the standard… you can read about this <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2577.pdf">in the proposal</a>). What's really funny: Rust actually <b>does</b> have a working, mathematically proven, “noalias”. It paid high price for it, but it's actually mathematically-proven one.</p>

<p>And the couldn't pass it to LLVM because LLVM starts producing wrong code (more about it <a href="https://www.ralfj.de/blog/2020/12/14/provenance.html">here</a>).</p>

<p>There are actually some research which is supposed to fix that issue (e.g. <a href="https://www.cs.utah.edu/~regehr/oopsla18.pdf">here</a>), but the fact that said research was only started after many years of abuse… says volumes.</p>

<font class="QuotedText">&gt; I would love to able to switch to Rust (for other reasons, too), but unfortunately my main work is Qt-based, and I'd have to throw all of that away.</font>

<p>You have to wait for now. GUI in Rust is actually a very hot topic and active area of research and they show very promising results… but it's most definitely not at stage where they can offer replacement for Qt yet.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor863146"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 11:29 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863146/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; I have also found that many times it hides real bugs. It's probably too much to ask, but still would be good if compiler authors look a bit at how "undefined" values played out in practice elsewhere.</font>

<p>They <b>do</b> look. And try to propagate it as far as they can. Because this, apparently, should help with “optimizations”.</p>

<p>Their efforts are thwarted by SPEC. Six out of nine benchmarks may be miscompiled because they trigger “undefined behavior”. And SPEC refuses to change them (yes, C/C++ compiler developers are showing <b>this level of hopelessness</b>, they actually wanted to claim that decades old benchmarks must be fixed to adhere to their ideas of UB treatment).

<p>The same can be said about GLibC (some optimizations break it) and few other well-known libraries.</p>

<p>This limits their efforts to some degree. But they usually try to invent something that would keep really well-known pieces of software untouched (although <code>autoconf</code> was fixed instead if you remember) while would happily break less-known libraries and programs.</p>

<font class="QuotedText">&gt; It doesn't work very well for verilog, I doubt it will work well for clang.</font>

<p>It works perfectly. More and more developers are contemplating switch to C#, Go, Java, Rust or any other language just to avoid this madness.</p>

<p>Not sure if that was the intent, but it was obvious to anyone but C/C++ compiler developers that this would happen: if you make the language “unsuitable for any purpose” then you, in effect, are forcing developers to look elsewhere.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/863146/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 23:56 UTC (Fri)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863245/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Their efforts are thwarted by SPEC. Six out of nine benchmarks may be miscompiled because they trigger “undefined behavior”. And SPEC refuses to change them (yes, C/C++ compiler developers are showing this level of hopelessness, they actually wanted to claim that decades old benchmarks must be fixed to adhere to their ideas of UB treatment).</font><br>
<p>
“It has been working for decades” is just not something that justifies any expectation for that program to continue running. That kind of attitude reminds me a whole lot of Tony Hoare&#x27;s Fortran compiler:<br>
<a rel="nofollow" href="https://youtu.be/YYkOWzrO3xg?t=1014">https://youtu.be/YYkOWzrO3xg?t=1014</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 0:43 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863246/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; “It has been working for decades” is just not something that justifies any expectation for that program to continue running.</font>

<p>Wow. Did you come from an alternate universe? Where Linux dominates the desktop with such attitude?</p>

<p>In the universe where I live it's market share <a href="https://gs.statcounter.com/os-market-share/desktop/worldwide">is about 2-3% for last two decades</a>. <b>Precisely</b> because of that toxic attitude.</p>

<p>Linus kernel, on the other hand, which is religious about that… it's ubiquitous. Coupled with non-<a href="https://www.jwz.org/doc/cadt.html">CADT</a> software it powers phones, robots, routers and almost anything you can imagine… except desktop.</p>

<p>If program worked then it must continue to work! Compiler, operation system and so on are, for the majority of people, are <b>only enablers</b> — their raison d'être is the need to have tools to run certain program or programs, they are useless on their own.</p>

<p>Sometimes said program doesn't even have sources and then quality of the compiler doesn't matter, of course, but if source <b>is</b> there then the <b>last</b> thing user wants to hear “this is incorrect program, you have to fix it”. Excuse me? How is it incorrect when I used it before and it worked? And I can still use it… except if I use <s>broken</s> new compiler.</p>

<p>Except in C/C++ land that obvious idea transformed into something completely crazy: if new version of compiler couldn't compile that old code… it's not acceptable. But if it turns it into pile of goo… that's fine and not a problem.</p>

<p>Frankly: that's the opposite stance from what I would consider “sane”.</p>

<font class="QuotedText">&gt; That kind of attitude reminds me a whole lot of Tony Hoare's Fortran compiler: <a href="https://youtu.be/YYkOWzrO3xg?t=1014">https://youtu.be/YYkOWzrO3xg?t=1014</a></font>

<p>Yup. Exactly. That Fortran compiler which was useless because people couldn't use it with their programs.</p>

<p>C/C++ compiler developers were sure they have invented “a way out”: create a cabal, make sure C and C++ users couldn't leave… and voila: you can do anything you want to them. Except people <b>are</b> leaving: C++ popularity is already <a href="https://www.tiobe.com/tiobe-index/cplusplus/">2x less than it was 10-15 years ago</a>. So far it <a href="https://www.tiobe.com/tiobe-index/c/">doesn't look as if C is losing developers very actively</a>, but I think it's because C is mostly used in embedded industry which is <b>very</b> conservative. 6 years of Rust for them is more-or-less enough to notice but not enough to even <b>start</b> thinking about switching. Maybe in next 10 years they would slowly start investigating.</p>

<p>Many of them would be <b>amazed</b> by Rust's speed. Since they are using <code>gcc</code> in <code>-O0</code> mode. And no, I'm not joking, I have heard that from <b>many</b> embedded guys: they compile everything with <code>-O0</code> “because it's the only way to make sure program would work” and then sometimes compile some pieces with <code>-O2</code> (which obviously requires freeze of the compiler version… or how else can we be sure it would continue to work?)…</p>








      
          <div class="CommentReplyButton">
            <form action="/Articles/863246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 13:37 UTC (Sat)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/863266/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m not interested in having a conversation where you accuse of a “toxic attitude” just because I happen to have a different opinion on certain issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor863734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2021 13:35 UTC (Wed)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/863734/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; “It has been working for decades” is just not something that justifies any expectation for that program to continue running</font><br>
<p>
I&#x27;m saddened that we&#x27;ve reached the point where I genuinely can&#x27;t tell if this statement is meant seriously or not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2021 15:46 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/863863/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, obviously it matters whether we&#x27;re talking about &quot;X is retroactively declared to be UB&quot; (evaluate &quot;be||!be&quot; to be zero, or &quot;realloc()&quot; to poison the pointer you pass to it), or &quot;X is a bug which didn&#x27;t trigger any misbehavior due to Y but now does&quot; (e.g. Y = memory layout or register allocation, when X is a write-beyond-end-of-array or use-after-free bug).<br>
<p>
Without this context, both the statement itself and arguing about it is meaningless.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor863148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 11:41 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/863148/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In the world of HW development the predominant language, Verilog, has the infamous four value system: each bit can be from the set {0,1,Z,X}, where &quot;X&quot; is intended to model &quot;undefined&quot; (as in the value is undefined, not in the sense of C&#x27;s &quot;undefined behaviour&quot; -- it&#x27;s behaviour is fully defined[1]). From experience in this world it is abundantly clear that the behvaiour of &quot;undefined&quot; has a tendency to result is non-working HW simulations and many weeks wasted hacking around the fact that the synthesis tool (compiler) changed expressions to propagate the X differently. I have also found that many times it hides real bugs. It&#x27;s probably too much to ask, but still would be good if compiler authors look a bit at how &quot;undefined&quot; values played out in practice elsewhere.</font><br>
<p>
I only know a little about Verilog so I could be mistaken, but it seems the problem is that Verilog is really two languages - one for simulation, one for hardware - which have enough overlap that you can write code that compiles as both, but enough differences that any non-trivial code is unlikely to behave the same. That creates some awkward compromises, and a lot of those compromises are found in X.<br>
<p>
Sometimes X might represent a &quot;do not care&quot; value, like when you&#x27;re defining a truth table with N input bits and you know some of the 2^N input states are impossible so you don&#x27;t care what the corresponding output bits are, and (for hardware) the compiler can choose whether the outputs are 0 or 1 based on which will allow a more efficient logic gate implementation. When compiling for simulation, the language tries to be helpful by propagating the X instead of arbitrarily replacing it with 0 or 1, so that you can detect situations where your code might have different behaviour once it&#x27;s compiled for hardware with different arbitrary choices.<br>
<p>
In many cases Verilog tries to eliminate Xs when it&#x27;s safe, e.g. if b = X then &quot;0 &amp; b&quot; is 0, and &quot;1 | b&quot; is 1, because those are valid whether b is actually 0 or 1. But it doesn&#x27;t have a sophisticated representation of values, so &quot;~b&quot; has to simply give the value X (with no extra data to indicate its relationship to the original X signal), and therefore &quot;b | ~b&quot; gives X. (Apparently some Verilog implementations are more sophisticated though, and could simulate the block with b=0 and b=1 and observe the output is the same in both cases, so it could eliminate the X.)<br>
<p>
In other cases Verilog tries to hide Xs when it doesn&#x27;t seem safe at all, like with &quot;if (X)&quot; being simulated as false. I&#x27;m not sure if there&#x27;s any coherent design principle behind those choices.<br>
<p>
But you can also get X from e.g. timing violations, which might correspond in hardware to a metastable value that is neither 0 nor 1. Or you can get X if a wire is being driven to 0 and 1 simultaneously, which in hardware is probably some illegal voltage (or hopefully the synthesis tool will detect and prohibit that to avoid damaging your chip). In hardware the signal might be interpreted differently at different points in the circuit, or might change unpredictably during a clock cycle, and &#x27;b | ~b&#x27; may well give 0 because you&#x27;ve already left the bounds of digital logic. But Verilog treats that as the same X as the &quot;do not care&quot; values, so it might fail to propagate the X when it really should.<br>
<p>
So I think there&#x27;s partly the fundamental difficulty of creating an accurate digital approximation of analog hardware, and partly Verilog&#x27;s overly simplistic implementation of X for simulation. (Verilog was designed in the 1980s, and to me it feels like it hasn&#x27;t moved on much since then - the recent SystemVerilog brought it up to the level of maybe C89 - so &quot;overly simplistic&quot; applies to a lot of it). That means it doesn&#x27;t really prove much about modern C/C++ compilers modelling &#x27;unknown&#x27; values, because they&#x27;re modelling something that is still digital and deterministic (and therefore much easier than hardware), and also they&#x27;re able to use much more sophisticated mathematical tools to manipulate those values in a more complex (but provably safe) way, based on the last few decades of compiler research.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor863225"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 19:57 UTC (Fri)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/863225/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;I expect the number system (set of values and operators) to be at least a ring, preferably a field. (be || !be) turning into false means that the system is not a ring.&quot;<br>
<p>
Pretty sure it&#x27;s already not a ring for lots of other reasons.  But it&#x27;s hard to tell, since you don&#x27;t define &quot;the system&quot;  (what values, what operators?)  Do that, then remind yourself of the definition of a &quot;ring&quot;, and let us know what you conclude....<br>
<p>
&quot;If it&#x27;s not, I can not reason about it&quot;<br>
<p>
It might be nice if rings and fields were good models for the types we use in programming languages, but often they aren&#x27;t.  Fortunately, it turns out it *is* possible to reason about things that aren&#x27;t rings or fields....<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863225/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2021 21:18 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/863232/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; It might be nice if rings and fields were good models for the types we use in programming languages, but often they aren't.</font>

<p>How often, though? All integers types <b>are</b> rings in modern CPUs (except when compilers add special facilities to make them non-rings). By design. Floating-point numbers are not rings, but that inevitable: ℝ can not be represented in a finite computer, all representations are approximate.</p>

<p>ℤ₂³² or ℤ₂⁶⁴ sure as hell <b>can</b> e represented in a computer — and that's <b>exactly what happens</b>: all moderns computers have integers which are rings and thus don't have separate same-sized instructions for signed and unsigned addition or multiplication.</p>

<p>And no, there are no need to ask for the definition, just open any math book.</p>

<font class="QuotedText">&gt;  Fortunately, it turns out it *is* possible to reason about things that aren't rings or fields....</font>

<p>Sure, if you are not interested in writing the correct code, then you don't need these pesky math theories. </p>

<p>This reminds me of one funny guy I meet once who claimed that statically-typed languages are really-really bad at many programs, because they, you know, require definition of tasks where you have no contradictions. And when I brought <a href="https://www.youtube.com/watch?v=BKorP55Aqvg">the well-known sketch</a> he claimed that yes, this is <b>exactly</b> what he talked about: real expert have no need for math or logic! He can <b>always</b> solve the task. Like, you know, “experts” which developed the infamous <a href="https://en.wikipedia.org/wiki/Boeing_737_MAX">Boeing 737 MAX</a>. <b>Thease</b> are “real experts”. They make stockholders rich. Which is important. Whileas stupid guys who want rings and other stupid things just make thing that work — and where's the value in <b>that</b>, hmm?</p>

<p>Sadly later he deleted an account and left the forum thus depriving us of healthy dose of laughs… but the sad thing: he left the form, not Earth… means he is still out there “solving tasks” and “delivering solutions”… and people are using them…</p>





      
          <div class="CommentReplyButton">
            <form action="/Articles/863232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 2:58 UTC (Sat)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/863255/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;All integers types are rings in modern CPUs&quot;<br>
<p>
Under + and *, and granting the assumptions about signed arithmetic, sure.  But Vipketsh seemed to be making some claim about how they behave under ||.  I think.  I wasn&#x27;t quite following....<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2021 6:00 UTC (Sat)
                               by <b>Vipketsh</b> (guest, #134480)
                              [<a href="/Articles/863259/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I will kindly remind you of the first rule of the hole: &quot;If you are in it, stop digging&quot;.<br>
<p>
Heard of &quot;boolean algebra&quot; ?  You know, that very simple field (and thus ring) consisting of the set {false,true} with XOR being the additive operator and AND being the multiplicative operator.<br>
<p>
(A || B) is shorthand for the expression (A XOR B XOR (A AND B)), while (!A) is shorthand for (true XOR A).  Putting it all together (be || !be) represents (be XOR true XOR be XOR (be AND (true XOR be))), an expression in the boolean field.  This complicated looking expression has a provable result for any combination of inputs: true.<br>
<p>
All modern CPU are perfectly capable of performing operations in the boolean field.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863515"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 21:04 UTC (Mon)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/863515/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;Heard of &quot;boolean algebra&quot; ? You know, that very simple field (and thus ring) consisting of the set {false,true} with XOR being the additive operator and AND being the multiplicative operator.&quot;<br>
<p>
Got it, thanks!  And apologies for assuming you were trying to make a ring out of the set of ints with || and &amp;&amp; as the operations, or something equally strange.<br>
<p>
That&#x27;s a bit of an obscure way of making the point that it&#x27;s more complicated to reason about a system where (x or !x) isn&#x27;t necessarily true, but, fair enough.<br>
<p>
I still maintain that &quot;if it isn&#x27;t a ring or a field, I can&#x27;t reason about it&quot; is overreach.  I mean, people do manage to write correct floating point software, for example.<br>
<p>
But, it&#x27;s *more complicated* to reason about, and it&#x27;s fair to argue whether the tradeoff is worth it, of course.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863515/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863589"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2021 14:58 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/863589/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I still maintain that &quot;if it isn&#x27;t a ring or a field, I can&#x27;t reason about it&quot; is overreach. I mean, people do manage to write correct floating point software, for example.</font><br>
<p>
But isn&#x27;t the set of all floating point numbers a finite set? Not that I know what the words &quot;ring&quot; or &quot;field&quot; actually mean in this context, but surely the set of valid REAL*4 numbers is smaller than the set of int32 numbers.<br>
<p>
So it&#x27;s easy to reason about floating point in exactly the same way as we reason about ints. It only becomes a problem if we forget that floating point numbers and irrational numbers are disjoint sets ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863589/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863621"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2021 15:25 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/863621/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But isn&#x27;t the set of all floating point numbers a finite set? Not that I know what the words &quot;ring&quot; or &quot;field&quot; actually mean in this context</font><br>
<p>
A ring is a set of values plus a pair of operators (&#x27;+&#x27; and &#x27;*&#x27;), which have the properties listed on <a href="https://mathworld.wolfram.com/Ring.html">https://mathworld.wolfram.com/Ring.html</a> . Floating point with addition and multiplication operators does not meet those properties, e.g. not all values have an additive inverse (you can&#x27;t subtract anything from Infinity or NaN to get 0), and it doesn&#x27;t guarantee a*(b+c) == a*b + a*c (so it&#x27;s not even a semiring), etc. A field is a ring with some additional properties on the &#x27;*&#x27; operator. You can reason about floating point numbers, but not using any of those common algebraic concepts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863621/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863638"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2021 17:01 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/863638/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; I still maintain that &quot;if it isn&#x27;t a ring or a field, I can&#x27;t reason about it&quot; is overreach. I mean, people do manage to write correct floating point software, for example.</font><br>
<p>
Ah ... so the OP was correct in saying it is overreach, but not for the reasons I understood ... fp is *almost* a ring :-) (if you use the &quot;approximately equal&quot; rather than the &quot;equals&quot; operator :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863638/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor862098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 2:36 UTC (Thu)
                               by <b>alkbyby</b> (subscriber, #61687)
                              [<a href="/Articles/862098/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t remember if it was brought up already, but does this rust thing especially if used for subsystems, implies that bunches of old architectures won&#x27;t be supported by Linux? Rust only supports small handful of arches afair.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 3:09 UTC (Thu)
                               by <b>rvolgers</b> (guest, #63218)
                              [<a href="/Articles/862099/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;d be long term, for now the plans are not to require Rust unless you want to use certain drivers or other modules written in Rust.<br>
<p>
Rust&#x27;s platform support is limited by LLVM&#x27;s platform support and by having hardware available for testing. It already supports way more than a &quot;handful&quot; if you count lower support tiers: <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">https://doc.rust-lang.org/nightly/rustc/platform-support....</a><br>
<p>
Dependence on LLVM is being addressed in two ways. There is work ongoing to add a code generation backend to the official Rust compiler which is based on GCC&#x27;s backend infrastructure instead of LLVM&#x27;s. And there is a separate project to create a new, independent compiler for Rust under the GCC project.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862102"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 4:15 UTC (Thu)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/862102/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And there is a simple Rust compiler call mrustc written in C++ that aims to be able to build the official Rust compiler, so that you can bootstrap Rust from source without any Rust related binaries. It currently generates C code, which is then compiled with GCC/etc.<br>
<p>
<a href="https://github.com/thepowersgang/mrustc">https://github.com/thepowersgang/mrustc</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862102/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862114"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 9:09 UTC (Thu)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/862114/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So it might be possible, in principle anyway, to compile kernel modules written in Rust with mrustc+gcc if there&#x27;s no official compiler for the target architecture?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862114/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 12:30 UTC (Thu)
                               by <b>djc</b> (subscriber, #56880)
                              [<a href="/Articles/862123/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
mrustc&#x27;s main use case is bootstrap the Rust compiler. It is not obvious that it would want to support compiling other components. I think the gcc rust backend is the more promising candidate here, but either way it looks like Rust will be able to target architectures supported by gcc in the not-so-long term.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor862168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 14:42 UTC (Thu)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/862168/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s covered in the patchset: rustc_codegen_gcc is a near-term solution providing a rustc backend using GCC to generate code, which should be able to support almost any architecture GCC does. I&#x27;d expect that to be available in the not too distant future, at which point we could start talking about enabling Rust in the kernel by default because it won&#x27;t limit architecture support.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 17:23 UTC (Thu)
                               by <b>lkundrak</b> (subscriber, #43452)
                              [<a href="/Articles/862182/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In fact, rustc_codegen_gcc seems to have been merged to rustc today:<br>
<a href="https://github.com/rust-lang/compiler-team/issues/442">https://github.com/rust-lang/compiler-team/issues/442</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862587"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2021 10:21 UTC (Mon)
                               by <b>pavon</b> (guest, #142617)
                              [<a href="/Articles/862587/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My understanding is that work hasn&#x27;t been merged yet (or even submitted for merging). The linked issue is a policy statement agreeing that the now external rustc_codegen_gcc project should be merged into the mainline rust compiler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862587/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor862101"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 5:05 UTC (Thu)
                               by <b>irogers</b> (subscriber, #121692)
                              [<a href="/Articles/862101/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t work on the Rust-for-Linux, but as a kernel developer contributing to the perf subsystem I see a large appeal to using Rust. The original motivation for Rust was that Mozilla were fed up with C++ bugs. That&#x27;s C++, where you have RAII types that clean up for themselves. In kernel style C code, with gotos for cleanup, the potential for bugs is greater and is putting a huge burden on developers. To this end there have been efforts like Sparse [1], originally written by Linus Torvalds, but I&#x27;d question whether heavily annotated C code aiming at emulating Rust is just a poor man&#x27;s Rust - why not put the same energy into just supporting Rust?<br>
<p>
For some concrete examples of the problems Rust solves from my Linux work, here are two recent examples. The first is a patch aiming to fix a memory leak [2], however, in fixing the memory leak the patch introduced a double free. Luckily this was caught by a diligent reviewer. We also run valgrind/sanitizers to try to catch such issues, but they are reliant on test coverage. The second is a patch I wrote [3] where the size parameter to strncat was incorrect. Luckily GCC has a check to catch such errors, but an eye ball check by two somewhat competent people had failed to spot the issue in a seemingly trivial change. The argument of, &quot;if you just knew how to write C properly,&quot; just doesn&#x27;t stand scrutiny. We know C and because of this we appreciate just how easy it is to make mistakes. The dream is a compiler that takes these worries away from us, and to a large extent Rust succeeds in doing this.<br>
<p>
Reading the similar article on the Register [4] a different point in the comments is that C and assembly code allow for maximum performance. Rather than give counter examples from other pieces of software, in Linux the most significant recent performance improvements I&#x27;ve seen have come from Link Time Optimization [5]. There are examples where being smart with assembly can be a win, I&#x27;m reminded of the asm-goto work [6], but Rust doesn&#x27;t preclude this.<br>
<p>
My final point is that as a developer I want to spend less time fixing bugs and more on performance and features. A transition to Rust is imo the best way to achieve this. I particularly enjoyed and agreed with the comment in this LWN article [7] that a lot of code is &quot;criminally underthreaded&quot;. We need to fix this while at the same time not endlessly shooting ourself in the foot, which was why Rust was created in the first place.<br>
<p>
[1] <a href="https://lwn.net/Articles/689907/">https://lwn.net/Articles/689907/</a><br>
[2] <a href="https://lore.kernel.org/lkml/20210702040955.631618-1-gushengxian507419@gmail.com/">https://lore.kernel.org/lkml/20210702040955.631618-1-gush...</a><br>
[3] <a href="https://lore.kernel.org/lkml/20210617184216.2075588-2-irogers@google.com/">https://lore.kernel.org/lkml/20210617184216.2075588-2-iro...</a><br>
[4] <a href="https://www.theregister.com/2021/07/05/rust_for_linux_kernel_project/">https://www.theregister.com/2021/07/05/rust_for_linux_ker...</a><br>
[5] <a href="https://llvm.org/docs/LinkTimeOptimization.html">https://llvm.org/docs/LinkTimeOptimization.html</a><br>
[6] <a href="https://lore.kernel.org/lkml/CA+55aFy+OxjvzxE3AXDwOwWJZLRAAR32OSsT9f5qy4r8qA+KCw@mail.gmail.com/">https://lore.kernel.org/lkml/CA+55aFy+OxjvzxE3AXDwOwWJZLR...</a><br>
[7] <a href="https://lwn.net/Articles/857599/">https://lwn.net/Articles/857599/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862101/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 5:51 UTC (Thu)
                               by <b>erwaelde</b> (subscriber, #34976)
                              [<a href="/Articles/862106/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;Adding Rust to the kernel requires a lot of work, for a lot of different people,  ...&quot;<br>
<p>
I&#x27;m not a kernel developer. I&#x27;m living in &quot;user space&quot;. That means once in a while I have to build kernels from scratch to meet our requirements (rt patch mostly). With Rust in the kernel, I suspect that I must then have a complete Rust (cross-)toolchain as well just to compile a kernel. I have to admit, that I&#x27;m not sold on this idea.<br>
<p>
Cheers,<br>
Erich<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862128"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 13:11 UTC (Thu)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/862128/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m not sure I see why this could be a problem.<br>
Unsupported systems is an issue. Additional burden on developers, definitely too.<br>
<p>
Users not willing to install the tools required to build the source without justifying why other than &quot;I&#x27;m not sold to it&quot; well, shouldn&#x27;t be considered as an obstacle IMO.<br>
<p>
What if some user doesn&#x27;t want to install a recent gcc? Should the kernel stay compatible with gcc 3 forever?<br>
<p>
Any good reason why someone who wants to build the kernel may not want/be able to install rust?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862128/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 13:57 UTC (Thu)
                               by <b>ericonr</b> (guest, #151527)
                              [<a href="/Articles/862141/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Any good reason why someone who wants to build the kernel may not want/be able to install rust?</font><br>
<p>
Yes, as quoted from the cover letter:<br>
<p>
<font class="QuotedText">&gt; Note that the kernel still requires unstable features, even if it is compiled with a stable `rustc` release, thus we cannot guarantee that future `rustc` versions will work without changes to the kernel tree.</font><br>
<p>
<font class="QuotedText">&gt; Thus, until all the unstable features we need are stabilized, we will support a single `rustc` version for each kernel release.</font><br>
<p>
As a distro developer, I can say we have enough trouble keeping up with Rust releases for Firefox, Thunderbird, random userspace utilities and what users want to use, because Rust moves fast and projects love to rely on newly-released functionality. I consider the requirement of a separate toolchain package just to build the kernel, because it has to stay at a given version (or multiple packages, since many distros support more than one kernel version) completely unacceptable. And no, installing a toolchain using rustup is not an option for distro packages.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 15:07 UTC (Thu)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/862173/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s definitely a good reason and I missed that part. Relying on unstable stuff does seem problematic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862223"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 23:57 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862223/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Everyone understands that that has to be fixed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862223/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 5:36 UTC (Fri)
                               by <b>riking</b> (subscriber, #95706)
                              [<a href="/Articles/862232/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Luckily, if you install with `rustup`, you can specify the exact rustc version to use at the start of any cargo command. Installing an old toolchain is extremely easy.<br>
<p>
$ rustup toolchain install 1.54<br>
$ cargo +1.54 build<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862234"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 5:37 UTC (Fri)
                               by <b>riking</b> (subscriber, #95706)
                              [<a href="/Articles/862234/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oops, didn&#x27;t fully read that. Distros not being able to side-by-side install multiple versions strikes again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862234/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 17:58 UTC (Fri)
                               by <b>ericonr</b> (guest, #151527)
                              [<a href="/Articles/862325/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, the issue isn&#x27;t that distros can&#x27;t do side by side installs. It&#x27;s maintaining and building all those toolchains. And (almost - there are distros where policy is more relaxed) no one is building a distro kernel with a rustup provided toolchain.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor862233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 5:56 UTC (Fri)
                               by <b>erwaelde</b> (subscriber, #34976)
                              [<a href="/Articles/862233/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;Any good reason why someone who wants to build the kernel may not want/be able to install rust?&quot;<br>
<p>
Good morning!<br>
<p>
This is entirely MY point of view, and MY context.<br>
<p>
The company I work for is building machinery. There are a several components running a very small Linux system inside.<br>
We work hard on providing all sources to fulfill our obligations with respect to all involved copyleft licenses.<br>
I am using a tool for this, https://elbe-rfs.org/, but not everyting is automatic and never will be.<br>
<p>
Adding any new language to the mix is just adding complexity and work. I&#x27;m willing to do this IF I can see visible benefits --- totally subjective from my point of view. FWIW: this has happened before: I&#x27;m with Debian long enough to have used systems lacking python entirely. And this crossing of boundaries will happen again, such is life.<br>
<p>
To add a bit more fuel to the fire: I also have headaches with BPF. In my (overly?) simplistic view this adds something akin to a virtual machine into the kernel. Of course there are valid use cases! I personally don&#x27;t have them, but heck. For me this addition crosses a subtle line of complexity as well. In the case of rust this line is more visible, imho. As someone else has pointed out: writing a new kernel from scratch with rust, well, go for it! Adding rust to the 20 years streamlined magic incantations of C and asm --- well, maybe not.<br>
<p>
I repeat: I&#x27;m not a kernel hacker. If I were good at this, I would most probably not be doing &quot;systems integration&quot;. I&#x27;m looking forward to be proven wrong on any of these points. But so far I just see a lot more work for a lot of people, interesting bugs due to &quot;domain crossing&quot; and me being at a total loss, where to even start looking.<br>
<p>
Cheers,<br>
erwaelde<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 8:37 UTC (Fri)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/862258/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why is it any worse than needing a complete C (cross-)toolchain to compile the kernel?<br>
<p>
That said, I wish there would be a Rust-to-C compiler to make the toolchain a bit more flexible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862358"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 23:37 UTC (Fri)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/862358/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I wish there would be a Rust-to-C compiler to make the toolchain a bit more flexible.</font><br>
<p>
`mrustc` (a WIP compiler) currently uses C as its output, e.g. <a href="https://godbolt.org/z/zEeqazox4">https://godbolt.org/z/zEeqazox4</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862358/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor862129"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 13:24 UTC (Thu)
                               by <b>karim</b> (subscriber, #114)
                              [<a href="/Articles/862129/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m currently failing to see the value-prop for a project as well established as the kernel. I can, however, definitely see the value-prop for something written from scratch  -- new, independent projects -- that would benefit from such a language.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862129/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 15:39 UTC (Thu)
                               by <b>floppus</b> (guest, #137245)
                              [<a href="/Articles/862175/">Link</a>] (32 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Note that the kernel still requires unstable features, even if it is compiled with a stable `rustc` release, thus we cannot guarantee that future `rustc` versions will work without changes to the kernel tree.</font><br>
<p>
<font class="QuotedText">&gt; Thus, until all the unstable features we need are stabilized, we will support a single `rustc` version for each kernel release.</font><br>
<p>
Out of curiosity, what unstable features are those, and why are they so crucial for the kernel?  How long should we expect it will take before those features are considered stable?<br>
<p>
It does feel as though any language used in a kernel release ought to be a language that has some guarantee of being supported into the future - though I suppose if &quot;unstable features&quot; did make it into a kernel release that would also create a substantial incentive to standardize those features in a compatible way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862179"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 16:48 UTC (Thu)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/862179/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem isn&#x27;t unstable features for the kernel, but unstable Rust versions used by everybody else.<br>
<p>
That would require creating a separate kernel-rust-compiler package so that the distro can keep the kernel compilation and the rust-for-everybody-else separate.<br>
<p>
Nobody wants that kind of headache.<br>
<p>
It&#x27;s unclear whether this will be a problem in practice, but past experience (&quot;use gccN, not gccM, to compile the kernel&quot; with N&lt;M) teaches us that this situation is more likely than some people are comfortable with.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862179/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862190"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 18:01 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/862190/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  The problem isn&#x27;t unstable features for the kernel, but unstable Rust versions used by everybody else.</font><br>
Rust compiler is backwards compatible, so this shouldn&#x27;t be a problem. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862190/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862202"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 19:40 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/862202/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not necessarily with unstable features. They can be changed or removed as it makes sense. Granted, ones the stdlib itself uses are slightly more likely to be more reliable, but they&#x27;re not &quot;stable&quot; in the sense that Rust has any guarantees about the same spelling working in the future.<br>
<p>
IMO, it&#x27;s still better than C or C++&#x27;s extension mechanisms which are usually implicit or only visible on the command line rather than in the source itself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862202/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862235"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 6:22 UTC (Fri)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/862235/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So is C, more or less. That&#x27;s not the problem.<br>
<p>
New versions will introduce new bugs, they always do. That doesn&#x27;t have to be a new source code feature. Some new optimization path that subtly breaks in corner cases that only the kernel is likely to hit (we&#x27;ve been there with GCC) is sufficient.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862235/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 6:26 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/862238/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Some new optimization path that subtly breaks in corner cases that only the kernel is likely to hit (we&#x27;ve been there with GCC) is sufficient.</font><br>
I can&#x27;t remember any such cases for Rust. It&#x27;s much better specified than C, so the potential for silent breakages is a bit smaller.<br>
<p>
And it&#x27;s not like GCC С has stellar reputation in this regard. So yeah, compiler bugs might happen. And they&#x27;ll need to be fixed and/or worked around, just as usual.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862249"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 7:39 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862249/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One problem with C is that in real C programs it&#x27;s almost impossible to avoid undefined behaviour. You&#x27;ll get away with it in one version of gcc, and then a later version of gcc will add an optimization that assumes that undefined behavior is absent, and now you have a bug (that only shows up at runtime). I guess this is part of what you&#x27;re talking about.<br>
<p>
In safe Rust, there is no undefined behavior so that doesn&#x27;t happen. I guess there are probably corner cases that were missed where the semantics aren&#x27;t quite nailed down, but those are bugs in the language spec which should be removed over time. In C it&#x27;s endemic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862249/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862260"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 8:43 UTC (Fri)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/862260/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Avoiding undefined behaviour is not always simple, but it is not impossible, either. Don&#x27;t kid yourself by thinking C is some kind of unexploded ordnance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862260/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 9:33 UTC (Fri)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/862262/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many things that are possible only via a sufficiently disciplined developer are in practice impossible for any team beyond a certain size.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 12:02 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862274/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you write reasonably complex code in C and you haven&#x27;t run ASAN/UBSAN on it with fuzzing then I&#x27;m confident that code will permit undefined behavior. Well, at least I&#x27;m confident of that for reasonably complex C code that *I* write.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862323"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 17:45 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862323/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; One problem with C is that in real C programs it&#x27;s almost impossible to avoid undefined behaviour. You&#x27;ll get away with it in one version of gcc, and then a later version of gcc will add an optimization that assumes that undefined behavior is absent, and now you have a bug (that only shows up at runtime).</font><br>
<p>
I partially agree with this. Gcc adopting a behavior for 20 years and suddenly breaking it just because &quot;it can&quot;, despite many times longer build times and very often bigger and slower binaries.<br>
<p>
But in a well established project like the kernel you almost don&#x27;t meet them anymore because the internal API provides many tools to help you. You want to safely rotate an integer? You can. You want to read a value here and now with no reordering ? you can. You want to perform some dangerous signed vs unsigned divides ? you can.<br>
The kernel code involves lots of macros and inlines to hide the dangerous parts. I could understand this argument for a new project where the tooling is missing, but here, such issues are not common, and when you see them, actually they are in very old code that was never updated to new standards.<br>
<p>
I do consider our modern C code base as readable, maintainable, auditable and reasonably safe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862323/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 18:28 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/862331/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The kernel code involves lots of macros and inlines to hide the dangerous parts. I could understand this argument for a new project where the tooling is missing, but here, such issues are not common, and when you see them, actually they are in very old code that was never updated to new standards.</font><br>
<p>
And isn&#x27;t that a big barrier to entry for new coders? Anything that lowers barriers should be cautiously welcomed.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862335"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 19:21 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862335/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And isn&#x27;t that a big barrier to entry for new coders?</font><br>
<p>
Of course it definitely is but it&#x27;s easy during reviews (and always done) to provide advices such as &quot;don&#x27;t use this, it&#x27;s unsafe, do that instead&quot;, thus teaching the newcomer how to improve their skills.<br>
<p>
<font class="QuotedText">&gt; Anything that lowers barriers should be cautiously welcomed.</font><br>
<p>
I agree, and Rust isn&#x27;t the thing that lowers that barrier at all, quite the opposite, the language is probably one of the most difficult to learn ever created and that&#x27;s even admitted by its proponents that &quot;the learning curve is steep&quot;. C, conversely, has long been established as the &quot;computer language&quot; and was used as a basis to derive plenty of other ones. If you&#x27;ve ever coded in C++,C#,awk, Java, Javascript, Go, Perl, OpenCL, even PHP to some extents, you probably know how to write basic C. *this* does lower the barrier. And it has been proven to be true since 1991.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862335/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862339"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 20:06 UTC (Fri)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/862339/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I agree, and Rust isn&#x27;t the thing that lowers that barrier at all, quite the opposite, the language is probably one of the most difficult to learn ever created and that&#x27;s even admitted by its proponents that &quot;the learning curve is steep&quot;. </font><br>
<p>
Steep learning curve does not imply that it is hard to learn. Just that you need to learn a lot in the beginning and cannot start coding right away. In my view, C is much harder to learn because learning C includes in my view to avoid any UB. Of course if someone has very low coding standards than learning C without all those nasty UB cases might be possible. And looking what makes the learning curve for rust that steep is the borrow checker, i.e., the central component that enforces the avoidance of UB. Thus rust programmers have to learn this certainly nontrivial part of programming just at the beginning.<br>
<p>
<font class="QuotedText">&gt; C, conversely, has long been established as the &quot;computer language&quot; and was used as a basis to derive plenty of other ones. If you&#x27;ve ever coded in C++,C#,awk, Java, Javascript, Go, Perl, OpenCL, even PHP to some extents, you probably know how to write basic C. *this* does lower the barrier. And it has been proven to be true since 1991.</font><br>
<p>
The thing that I see and that is proven to be correct ever and ever again is that even lots of experience of programming C is not enough to write correct C code. Correct C code of course implies the absence of any UB. You are certainly right that it is much easier to write a program that is accepted by a C compiler than to write a program that is accepted by a rust compiler. But once you achieve the goal of getting the rust program accepted than (at least for safe rust) there is no UB. What are the chances of a beginner written C code without UB? How many years of experience does a developer need until (s)he writes UB free code?  Does this happen ever?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862339/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862341"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 20:59 UTC (Fri)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/862341/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; And isn&#x27;t that a big barrier to entry for new coders?</font><br>
<font class="QuotedText">&gt; Of course it definitely is but it&#x27;s easy during reviews (and always done) to provide advices such as &quot;don&#x27;t use this, it&#x27;s unsafe, do that instead&quot;, thus teaching the newcomer how to improve their skills.</font><br>
<p>
....  followed by<br>
<p>
<font class="QuotedText">&gt; I agree, and Rust isn&#x27;t the thing that lowers that barrier at all, quite the opposite, the language is probably one of the most difficult to learn ever created and that&#x27;s even admitted by its proponents that &quot;the learning curve is steep&quot;</font><br>
<p>
Let&#x27;s put all this together,  you clearly see the advantage of reviewers giving advice on what&#x27;s unsafe and how to avoid that but when the language enforces that behavior that adds to a initial learning curve but is far more rigorous than reviewers ever can and  frees up reviewers time to focus on other things not enforceable by a compiler such as logic errors, you appear to dismiss the advantages entirely. <br>
<p>
<font class="QuotedText">&gt; you probably know how to write basic C. *this* does lower the barrier. And it has been proven to be true since 1991.</font><br>
<p>
It has also proven to result is a lot of bugs including security issues<br>
<p>
https://msrc-blog.microsoft.com/2019/07/22/why-rust-for-safe-systems-programming/<br>
<p>
 &quot;As we’ve seen, roughly 70% of the security issues that the MSRC assigns a CVE to are memory safety issues. This means that if that software had been written in Rust, 70% of these security issues would most likely have been eliminated. And we’re not the only company to have reported such findings.&quot;<br>
<p>
or the last LWN post<br>
<p>
<a href="https://lwn.net/Articles/862329/">https://lwn.net/Articles/862329/</a><br>
<p>
&quot;For us, these problems mean that programming in C is a slow and painstaking process. Everything we write takes more code than we&#x27;d like it to, and we need to double-check even the safest-looking code to make sure it doesn&#x27;t fall prey to any of C&#x27;s list of enormous gotchas. This slows us down seriously, and increases the cost of adding new features.<br>
<p>
&quot;Rust seems like the clearest way out of our bind. It&#x27;s a high-level language, and significantly more expressive than C. What&#x27;s more, it&#x27;s got some really innovative features that let the language enforce certain safety properties at compile-time. To a first approximation, if the code compiles, and it isn&#x27;t explicitly marked as &quot;unsafe&quot;, then large categories of bugs are supposed to be impossible.<br>
<p>
That&#x27;s a huge win for us in programming and debugging time, and a huge win for users in security and reliability. Since 2016, we&#x27;ve been tracking all the security bugs that we&#x27;ve found in Tor, and it turns out that at least half of them were specifically due to mistakes that should be impossible in safe Rust code.&quot;<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862341/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862343"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 21:59 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862343/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; you appear to dismiss the advantages entirely.</font><br>
<p>
Wow, like a number of others here I&#x27;ve been thinking for a while that there was an arrogant approach around &quot;in rust we write almost no bugs thanks to strong type checking and absence of UB&quot;, yet I&#x27;m used to seeing plenty of bugs that involve neither, and I&#x27;ve yet to get a response to my previous question: &quot;what will we get in exchange for those bugs saved ?&quot;. More logic bugs due to developers having more difficulties with a complex language ? More undebuggable bugs in unsafe sections that no rust developer will feel like willing to analyse ? Compiler bugs that nobody will believe in because &quot;we are serious people not C devs, we don&#x27;t write bugs&quot; ?<br>
<p>
From the very beginning, numbers are aggressively thrown at people&#x27;s faces like &quot;we could have saved 70% of these bugs&quot;. And who proved that no more complex ones would be added? And how long would it take to figure and fix the 30% uncovered ones ? How can you claim that rust is *the* solution compared to other new languages that maybe would address 85% of these ?<br>
<p>
Dividing a number of bugs by only 3 in existing code requires tooling, not a new language. Today a crash was reported in the panel driver after the code was refactored. Very likely it will be claimed that with rust this wouldn&#x27;t have happened, especially since Miguel is on both sides and will probably figure his mistake and how he would have avoided that with rust. Yet we still have to see a single driver written in rust to gauge that. In the mean time a one-liner will probably fix the driver while 6 more months will be needed to write it in rust, test it and iteratively fix it, because apparently we&#x27;re still far from being able to write a real driver. Where&#x27;s the efficiency here ? What are we saving ? Will it take 40 years to get a C-free kernel entirely written in rust ? Will Rust still be actively maintained in only 10 years ? Who will fix bugs in production for the code written in C while rust developers will push hard to deploy full rewrites in stable branches claiming &quot;rust or I won&#x27;t fix it&quot; ?<br>
<p>
<font class="QuotedText">&gt; &gt; you probably know how to write basic C. *this* does lower the barrier. And it has been proven to be true since 1991.</font><br>
<font class="QuotedText">&gt; It has also proven to result is a lot of bugs including security issues</font><br>
<p>
Of course, since close to 100% of existing infrastructure code or even compilers are written using this language. Languages don&#x27;t write bugs. Humans do. Languages help humans avoid them. Whatever language you&#x27;ll use, you&#x27;ll *always* have bugs. You can have less, more, different classes depending on the languages (e.g. some consider Perl, PHP and Ruby as memory-safe[1], yet programs written using some of these possibly collect the largest number of RCEs of all the web server industry).<br>
<p>
I don&#x27;t like the fact that 100% of the focus is put on the very same arguments that are circling as if they were written big in red on the salespersons&#x27; training guide. &quot;type safety prevents bugs&quot;, &quot;memory safety prevents bugs&quot;, &quot;no undefined behavior&quot;. Sure these are improvements over some other languages and they may address *some* classes of bugs.<br>
<p>
But there are maybe 1000 times less rust developers than C developers in the world, even less skilled ones that are able to code safely, to review code and to help fix issues. How long will we have to insist on &quot;we have a bug here&quot; when we&#x27;ll repeatedly get in the face &quot;no it&#x27;s not possible it&#x27;s in a safe section, rust doesn&#x27;t have such class of bugs, find something else&quot; ?<br>
<p>
An operating system has to deal with hardware bugs, CPU bugs, datasheet bugs, compiler bugs, API bugs, some of them having no effect until someone figures a way to exploit them for fun (e.g. spectre). The current linux kernel developers do routinely deal with such classes of bugs, and all I&#x27;m reading here is that the language is the solution. I mean, are we serious about the fact that we&#x27;ll constantly try to hide behind a strongly-typed language to address all such issues ? How will the compat32 stuff be safe against leaking bits in the topmost bits of registers that cannot exist by definition thanks to their strong 32-bit type ?<br>
<p>
There are a ton of things I hate in C. Really. My C code tends to have quite a bunch of asm statements whenever I&#x27;m bothered by the language or the compiler. But there&#x27;s something I hate even more than language absurdities, it&#x27;s to trash working code and replace it with new one, because with new code comes new bugs and new vulnerabilities. And your language-of-the-year will not change this because those writing that code are mere humans, just like those who author bugs in C and those who create bugs in your rust compiler. The difference is that when a bug report lands on the security list, there are plenty of people jumping on it to discuss the best way to fix it. Here I fear that we&#x27;ll have to call poor Miguel and a few already overloaded friends to the rescue and that it will take a lot of time to fix such vulnerabilities.<br>
<p>
Please, better rewrite a new kernel from scratch. You&#x27;ll save your time by not having to implement all this interface. You&#x27;ll save the kernel&#x27;s security by not having this opaque stuff in the middle that nobody will understand. And you&#x27;ll be able to get rid of plenty of mistakes of the past that really don&#x27;t deserve being implemented anymore. It will take the same amount of time to reach 10% implemented, without ruining what&#x27;s currently working fine, and it will be faster to get close to 100% than if you modify existing code. You never replace 100% of some code, you asymptotically converge towards 100%.<br>
<p>
[1] <a href="https://www.infoworld.com/article/2886810/how-safe-is-perl-php-ruby-experts-weigh-in.html">https://www.infoworld.com/article/2886810/how-safe-is-per...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862343/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 11:16 UTC (Sat)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/862380/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Languages don&#x27;t write bugs. Humans do.</font><br>
<p>
That&#x27;s not the whole picture. The other half is &quot;Humans don&#x27;t prevent bugs. Languages do.&quot;<br>
<p>
When a language eliminates the possibility for a whole class of bugs to exist then the human can&#x27;t write code with the bug and doesn&#x27;t have to check the code (or write tools that try to do it, a job which due to Turing completeness will never be 100% successful).<br>
<p>
If the language has values that must be handled (like error conditions) you can&#x27;t forget to do so. If exactly one piece of code *must* be responsible for an object you can&#x27;t double-free it. If there are no unbounded arrays, you can&#x27;t accidentally (or maliciously) code an out-of-bounds access. And so on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor862350"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 22:55 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862350/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Of course it definitely is but it&#x27;s easy during reviews (and always done) to provide advices such as &quot;don&#x27;t use this, it&#x27;s unsafe, do that instead&quot;, thus teaching the newcomer how to improve their skills.</font><br>
<p>
It is much more efficient to put as much of that reviewing into the language/compiler as possible. Faster turnaround for contributors, lightens the workload for maintainers.<br>
<p>
<font class="QuotedText">&gt; I agree, and Rust isn&#x27;t the thing that lowers that barrier at all, quite the opposite, the language is probably one of the most difficult to learn ever created and that&#x27;s even admitted by its proponents that &quot;the learning curve is steep&quot;.</font><br>
<p>
This vastly overstates the difficulty of Rust. Many people who were afraid to try systems programming before have gotten into Rust and like it.<br>
<p>
<font class="QuotedText">&gt; If you&#x27;ve ever coded in C++,C#,awk, Java, Javascript, Go, Perl, OpenCL, even PHP to some extents, you probably know how to write basic C.</font><br>
<p>
C++ sure, but the others ---- absolutely not. Taking a programmer used to languages with GC and no UB and letting them loose with C, without lots of tool support and review support is going to lead to disastrous results.<br>
<p>
There is a low barrier to entry to C in the sense that it is easy to write small programs that work on some testcases. Those programs will have UB and various security issues (e.g. they&#x27;re probably using fixed buffer sizes because there is no standard growable array in C). In that sense --- and that sense alone --- the barrier to entry for C can be lower than Rust.<br>
<p>
But for what we actually care about --- writing robust, UB-free kernel-quality code --- it is *so* much easier in Rust than in C for both new and experienced devs. Yes, you will fight the compiler for a while in Rust before you get something that runs. Better for everyone that you iterate with the Rust compiler than with human reviewers trying to spot your bugs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862350/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862351"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 23:14 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/862351/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BTW the &quot;work required to get something that runs&quot; metric definitely *is* a problem for Rust in general. Developers, especially but not only new developers, prefer a &quot;quickly get something running&quot; language for prototyping and &quot;small&quot; projects (or at least, projects whose imagined scope starts out small). Naturally, once you&#x27;ve started with such a language, it&#x27;s easier to continue with it rather than switch, even as your projects grow past the point where &quot;quickly get something running&quot; was relevant.<br>
<p>
However, the real competition in that space is Python (and others), not C. And none of this is relevant to kernel development.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862351/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor862400"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 17:30 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/862400/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But for what we actually care about --- writing robust, UB-free kernel-quality code --- it is *so* much easier in Rust than in C for both new and experienced devs. Yes, you will fight the compiler for a while in Rust before you get something that runs. Better for everyone that you iterate with the Rust compiler than with human reviewers trying to spot your bugs.</font><br>
<p>
I took over a C project. It was *amazing* the number of bugs that &quot;disappeared&quot; - and I do NOT mean &quot;were found and fixed&quot; - when I added &quot;warning = 3&quot; or whatever the syntax was to the makefile. The project was initially compiled with the default level of 1, I just upped it and fixed the warnings. A lot of them really were bugs ...<br>
<p>
If you&#x27;re writing serious code, you need a serious language, and (that was MS-C v5) that most certainly was not a serious language by default ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862400/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862353"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 23:17 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/862353/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  If you&#x27;ve ever coded in C++,C#,awk, Java, Javascript, Go, Perl, OpenCL, even PHP to some extents, you probably know how to write basic C. *this* does lower the barrier. And it has been proven to be true since 1991.</font><br>
I&#x27;ve had experience of mentoring developers familiar with Java and Python to write C and C++. <br>
<p>
It. Was. Not. Fun.<br>
<p>
Learning how to track objects&#x27; lifetime, manage memory, write exception-safe code was not at all easy for most. And I&#x27;m talking about very smart people, graduates of major US universities.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862353/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor862275"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 12:45 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/862275/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  New versions will introduce new bugs, they always do. That doesn&#x27;t have to be a new source code feature. Some new optimization path that subtly breaks in corner cases that only the kernel is likely to hit (we&#x27;ve been there with GCC) is sufficient.</font><br>
<p>
Let&#x27;s keep in mind that &quot;some new optimization path&quot; is an intentional new feature that users gladly take advantage of.<br>
<p>
The entire point of these endless incremental compiler improvements (and the occasional regression they introduce) is to incrementally improve the behavior (be it performance, safety, whatever) of _existing_ code.  Rewrites are _very_ expensive.<br>
<p>
Back on-topic, the big question I have about &quot;Rust in Linux&quot; is how the conceptual differences between the C preprocessor and Rust&#x27;s macros are handled.  Given how heavily Linux relies on cpp, this is IMO a significant question.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862275/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor862205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2021 20:23 UTC (Thu)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/862205/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Out of curiosity, what unstable features are those, and why are they so crucial for the kernel?</font><br>
<p>
Please see <a href="https://github.com/Rust-for-Linux/linux/issues/2">https://github.com/Rust-for-Linux/linux/issues/2</a><br>
<p>
<font class="QuotedText">&gt; How long should we expect it will take before those features are considered stable?</font><br>
<p>
It will take a while, but we are working with upstream on this.<br>
<p>
A way to speed it up would be to fund someone to work upstream on the features that are missing. Companies would be more easily convinced to provide funding if Rust goes into mainline, of course.<br>
<p>
<font class="QuotedText">&gt; It does feel as though any language used in a kernel release ought to be a language that has some guarantee of being supported into the future</font><br>
<p>
Only code that relies on those features would need changes if they happen to change, and we are concious about the features we use: we only use features that either we really need, or features that make a substantial improvement to our code (and that are expected to be stabilized).<br>
<p>
Furthermore, we are in contact with several Rust experts and upstream to advice us on these features.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2021 18:14 UTC (Fri)
                               by <b>ericonr</b> (guest, #151527)
                              [<a href="/Articles/862327/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Companies would be more easily convinced to provide funding if Rust goes into mainline, of course.</font><br>
<p>
This feels a bit like putting the responsibility on the wrong actors... Not depending on unstable compiler features should be (IMO as a distro maintainer who doesn&#x27;t want (or have time) to maintain one Rust toolchain for each kernel release - we ship all supported kernel releases) a requirement for being merged at all. Saying this minimal requirement can be achieved more easily if the work is accepted into the kernel in a manner completely unsuitable for distribution usage makes it seem like the responsibility is on Linux maintainers to make the patch more acceptable.<br>
<p>
There have also been others instances in the patch discussion where similar arguments were made, that once Rust in the kernel was accepted, then there&#x27;d be more motivation for things to be stabilized on the Rust side. That feels like the wrong direction, and my strong belief is that things necessary to make Rust acceptable for kernel use should be stabilized / accepted before Rust is in the kernel.<br>
<p>
Apologies if I read you wrong, but the way the discussion has gone gave me this impression.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 0:43 UTC (Sat)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/862357/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If I understand you correctly, you are saying the kernel should delay a fundamental decision on adding a second language due to your distribution having issues allocating resources to maintain a `kernel-rust-toolchain` package to go along each release.<br>
<p>
To me, that sounds the opposite of how things should be done.<br>
<p>
Do not get me wrong, I understand adding Rust to the kernel has consequences elsewhere. However, your resource allocation problem is not a fundamental issue for you (you have several ways to resolve it) nor big enough to the point of asking other projects to factor your situation in.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862370"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 3:48 UTC (Sat)
                               by <b>ericonr</b> (guest, #151527)
                              [<a href="/Articles/862370/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If I understand you correctly, you are saying the kernel should delay a fundamental decision on adding a second language due to your distribution having issues allocating resources to maintain a `kernel-rust-toolchain` package to go along each release.</font><br>
<p>
The kernel can be built with a wide range of GCC releases. It should at least be able to build with actually released features of the new compiler you want to make it depend on.<br>
<p>
I used my example as something I know personally about; I am reasonably sure other distros will have similar issues with depending on Rust, even if bigger ones like Debian and Fedora probably have the manpower to deal with this (I should mention that Debian rolled with outdated KDE and Chromium for a long while due to lack of maintainership, though, so even such an apparently huge distro isn&#x27;t immune to &quot;resource allocation issues&quot;). Given that distros are by far main distributors and builders of the kernel besides Android (though many android devices are stuck with a specific release already, so the requirement of a specific Rust compiler doesn&#x27;t matter as much), I feel they should be considered when one talks of adding new important build time dependencies into the kernel.<br>
<p>
Another issue with depending on a specific Rust release is that kernel LTS releases are maintained for a much longer time than Rust releases are; if a codegen bug or performance improvement is found, this will require every single distro shipping that kernel to backport the fixes they want and/or need into the Rust version that can build their kernel. This is not sustainable.<br>
<p>
<font class="QuotedText">&gt;  Do not get me wrong, I understand adding Rust to the kernel has consequences elsewhere. However, your resource allocation problem is not a fundamental issue for you (you have several ways to resolve it) nor big enough to the point of asking other projects to factor your situation in.</font><br>
<p>
I should maybe have worded it better that this isn&#x27;t an issue only I, in the distro I contribute to, suffer. Even maintainers of well funded distros will thank you if you don&#x27;t increase their workload two or threefold, and think about them and their time. Time not spent wrangling toolchains is time that can be spent doing something else worthwhile.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862370/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862374"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 5:28 UTC (Sat)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/862374/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Even maintainers of well funded distros will thank you if you don&#x27;t increase their workload two or threefold, and think about them and their time. Time not spent wrangling toolchains is time that can be spent doing something else worthwhile.</font><br>
<p>
What will happen instead is that distros without that amount of resources will simply disable the features that depend on rust, similar to the era where debian kernels would disable a number of drivers containing binary firmwares.<br>
<p>
And only once users will really insist on having these features, some discussions will start on how to minimize the cost of dealing with rust (i.e. engage on not forcing to upgrade the compiler version for 10 years and usual stuff like this that already applies to the C compiler). For sure this will mean that rust developers will have to force themselves to work without the latest shiny features, but they can&#x27;t have both the pleasure of working in the kernel without adapting to its contraints.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862374/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 18:32 UTC (Sat)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/862403/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What will happen instead is that distros without that amount of resources will simply disable the features that depend on rust, similar to the era where debian kernels would disable a number of drivers containing binary firmwares.</font><br>
<p>
This is perfectly fine. We understand not everybody has resources to maintain everything.<br>
<p>
What is not reasonable is to ask us to stop the Rust support proposal because someone may not have resources to maintain a package.<br>
<p>
<font class="QuotedText">&gt; And only once users will really insist on having these features, some discussions will start on how to minimize the cost of dealing with rust</font><br>
<p>
The discussions should start today. Furthermore, distributions that may not have the resources to maintain whatever they need today should also start planning for it, too, so that when the day comes that users start asking for it, they have a solution ready.<br>
<p>
<font class="QuotedText">&gt; For sure this will mean that rust developers will have to force themselves to work without the latest shiny features,</font><br>
<p>
We are very concious about what unstable features we use. We only use them when there is no way around it or when they make the code fundamentally better (and only if we are fairly confident they are on track to become stable).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor862397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 18:21 UTC (Sat)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/862397/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I am reasonably sure other distros will have similar issues with depending on Rust, even if bigger ones like Debian and Fedora probably have the manpower to deal with this</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; ...</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; Even maintainers of well funded distros will thank you if you don&#x27;t increase their workload two or threefold, and think about them and their time.</font><br>
<p>
Sorry, but we are not increasing your workload &quot;two or threefold&quot; -- that may be a result of particular procedures in your distribution system. Please do not blame us for that.<br>
<p>
<font class="QuotedText">&gt; Time not spent wrangling toolchains is time that can be spent doing something else worthwhile.</font><br>
<p>
Adding Rust to the kernel is also worthwhile. Please see it the other way around: you are asking us to skip doing something we consider worthwhile just because you do not see it as important as other things you want to do. And, instead of working with us to see how things could be improved for both sides, you are asking us to stop.<br>
<p>
<font class="QuotedText">&gt; I feel they should be considered when one talks of adding new important build time dependencies into the kernel.</font><br>
<p>
And we are considering them -- that is precisely why I am replying to you.<br>
<p>
However, you have not presented any strong argument as to why this is such a fundamental issue for you as to ask the kernel to stop this proposal. In fact, you have many ways out. For instance:<br>
<p>
  - Improve or automate your procedures.<br>
  - Relax your policies (e.g. if you always build toolchains from scratch; ship the official binaries instead).<br>
  - Increase the number of maintainers.<br>
  - Decrease the number of supported kernel releases.<br>
  - Reallocate support from other packages.<br>
  - Disable Rust support in your kernels until the kernel can be built only with stable features.<br>
<p>
And that is not even getting into other potential solutions, e.g. working with us and upstream Rust to try to come to a compromise where some unstable features are expected to be maintained for some time, even if they keep the freedom to eventually remove them (I am not saying this would be feasible at all -- I am just saying there are alternatives that you could explore).<br>
<p>
<font class="QuotedText">&gt; this will require every single distro shipping that kernel to backport the fixes they want and/or need into the Rust version that can build their kernel. This is not sustainable.</font><br>
<p>
Please note that the Rust support being added is experimental. Until things have matured a bit and some modules are written in Rust and intended to be used in production, I would avoid distributing LTS kernels with Rust support enabled. Your distribution may even want to wait until the kernel can be built without unstable features before shipping it for an LTS.<br>
<p>
And, to clarify: it is not that we are forcing a particular Rust release and failing to build if the version does not match -- it is just that we cannot guarantee the kernel will build with every future release of the Rust toolchain (until the unstable features are stabilized). But it is definitely possible that it may build with several releases just fine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2021 21:17 UTC (Sat)
                               by <b>ericonr</b> (guest, #151527)
                              [<a href="/Articles/862410/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Sorry, but we are not increasing your workload &quot;two or threefold&quot; -- that may be a result of particular procedures in your distribution system. Please do not blame us for that.</font><br>
<p>
One Rust toolchain vs one Rust toolchain for each kernel release.<br>
<p>
<font class="QuotedText">&gt; Please see it the other way around: you are asking us to skip doing something we consider worthwhile just because you do not see it as important as other things you want to do. And, instead of working with us to see how things could be improved for both sides, you are asking us to stop.</font><br>
<p>
I&#x27;m not asking to stop; I&#x27;m saying that I strongly believe stabilization of the features being used should come before the work is merged into the kernel.<br>
<p>
<font class="QuotedText">&gt;  - Relax your policies (e.g. if you always build toolchains from scratch; ship the official binaries instead).</font><br>
<p>
Not an option for many of our targets (both because of musl and because the archs aren&#x27;t high in Rust&#x27;s tier list - and at least one arch requires patching the toolchain because there aren&#x27;t as many configure knobs as GCC provides). I should note I have been active in the discussion to make shipping Rust in musl-based distros easier, but the results have yet to land.<br>
<p>
<font class="QuotedText">&gt;  - Disable Rust support in your kernels until the kernel can be built only with stable features.</font><br>
<p>
That&#x27;s probably what I will do. But I think that&#x27;s worse for the effort, since now there are fewer testers. Distros are resistant to changing their policies. Fedora and Debian go to the effort of packaging every single crate that packages depend on, instead of letting cargo fetch from crates.io. A distro like mine has to bow down to upstream pressure at some point, many of the bigger ones won&#x27;t; and that leads to more friction than there need be.<br>
<p>
<font class="QuotedText">&gt; I would avoid distributing LTS kernels with Rust support enabled. Your distribution may even want to wait until the kernel can be built without unstable features before shipping it for an LTS.</font><br>
<p>
Thanks for the tip, assuming it&#x27;s merged.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2021 21:29 UTC (Tue)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/862788/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; One Rust toolchain vs one Rust toolchain for each kernel release.</font><br>
<p>
Again, that is not &quot;two or threefold&quot;. Even if you are talking only about kernel packages (vs. the entire distribution) and even if everything is done manually, I still do not see how you arrive to such a big increase.<br>
<p>
In any case, please note that your workload issue will not completely dissappear even if we had zero unstable features, because the minimum Rust toolchain version will *still* be raised from time to time (like it is raised for GCC and Clang) in order to take advantage of new features or to be able to perform cleanups.<br>
<p>
<font class="QuotedText">&gt; I&#x27;m not asking to stop; I&#x27;m saying that I strongly believe stabilization of the features being used should come before the work is merged into the kernel.</font><br>
<p>
...which is pretty much asking everyone to freeze.<br>
<p>
See, it is not just asking us to wait, it implies other things, such as less support from third-parties (which want to start writing subsystems and drivers in Rust) and less incentive for upstream Rust to stabilize the features we need in the kernel (which could imply increasing the total time until the features are actually stabilized).<br>
<p>
In the end, if we are going to have Rust in the kernel, at some point we need to bite the bullet. And, in any case, if this disrupts your distribution that much, you are free to wait on your side until you can enable Rust support -- nothing forces you to enable it right away. You can take the time to figure out how you want to support it.<br>
<p>
<font class="QuotedText">&gt; That&#x27;s probably what I will do. But I think that&#x27;s worse for the effort, since now there are fewer testers.</font><br>
<p>
Testers are definitely welcome, but please note that the Rust support, even if merged, is experimental and needs work in several fronts (as noted in the cover letters) and thus testers should not be general users of a Linux distribution.<br>
<p>
That is why I was telling you I do not think Linux distributions should go and enable things right away. However, being in mainline does have benefits for everyone involved as well as third-parties, because then everyone knows it will eventually become stable enough, thus everything can be set in motion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2021 10:07 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/862815/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; However, being in mainline does have benefits for everyone involved as well as third-parties, because then everyone knows it will eventually become stable enough,</font>

<p>Actually it may still be ripped out (think <a href="https://lwn.net/Articles/139595/">devfs</a>). But that rarely happen. So yeah, it's a serious commitment. And many times when things were merged prematurely it meant a lot of pain to third parties. So bar for such changes was raised quite far.</p>

<font class="QuotedText">&gt; thus everything can be set in motion.</font>

<p>If you have “a business plan” which involves merging into mainline before anyone would ship actual distributions or devices with that stuff then I recommend to rethink it. <a href="https://www.kernel.org/doc/man-pages/linux-next.html">Linux-next</a> is the possiblity (<b>precisely</b> because there are no expectation that anything from there will ever land in mainline… it's there specifically to see if that would make sense or not).</p>

<p>But mainline? Don't hold your breath. The chances are high (99%) it wouldn't land there before few years in some kind of distribution (Android, ChromeOS, maybe Arch or Fedora).</p>

<p>Linux developers have become more strict over years about what they merge if it may effect more than people who directly touch that stuff. And Rust may change so much that I doubt it will happen in the next couple of years.</p>

<p>In some (very-very rare) cases Linus is known to override everyone's else decisions, thus 1% is still there… but I don't recommend to base your plans on that possibility.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/862815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor862823"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unstable features</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2021 11:31 UTC (Wed)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/862823/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However, being in mainline does have benefits for everyone involved as well as third-parties, because then everyone knows it will eventually become stable enough,</font><br>
<font class="QuotedText">&gt; Actually it may still be ripped out (think devfs). But that rarely happen. So yeah, it&#x27;s a serious commitment. And many times when things were merged prematurely it meant a lot of pain to third parties. So bar for such changes was raised quite far.</font><br>
<p>
This is quite different than devfs. Removing devfs is a userspace visible space. Thus removing it has to meet the golden rule &quot;do not break userspace&quot;. Replacing rust code by C code is different. If the interfaces to userspace stay the same, this is just a different implementation of the same interface.<br>
<p>
<font class="QuotedText">&gt;&gt; thus everything can be set in motion.</font><br>
<font class="QuotedText">&gt; If you have “a business plan” which involves merging into mainline before anyone would ship actual distributions or devices with that stuff then I recommend to rethink it. Linux-next is the possiblity (precisely because there are no expectation that anything from there will ever land in mainline… it&#x27;s there specifically to see if that would make sense or not).</font><br>
<p>
This is a very strange description of linux-next. In fact linux-next is the repo where features are put that are expected to go into mainline. Of course it is not sure that they actually do. But the expectation is there. So linux-next might be a good idea, especially if it is planned to merge these things into mainline.<br>
<p>
<font class="QuotedText">&gt; But mainline? Don&#x27;t hold your breath. The chances are high (99%) it wouldn&#x27;t land there before few years in some kind of distribution (Android, ChromeOS, maybe Arch or Fedora).</font><br>
<font class="QuotedText">&gt; Linux developers have become more strict over years about what they merge if it may effect more than people who directly touch that stuff. And Rust may change so much that I doubt it will happen in the next couple of years.</font><br>
<p>
As long as rust is only used for drivers, it only affects the people who directly touch that stuff. No need to even install a rust compiler as long as you do not intend to use the stuff implemented in rust. Of course rust may change much, but only if many of the kernel developers/maintainers agree that it is a good idea. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/862823/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor863478"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle"> Rust / C risk management for undefined behavior (UB)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2021 18:05 UTC (Mon)
                               by <b>ma4ris5</b> (guest, #151140)
                              [<a href="/Articles/863478/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Overview<br>
<p>
I hope that you find this idea useful,<br>
although this is a bit late comment.<br>
<p>
Risk management based approach enables<br>
to identify and mitigate UB risks,<br>
while avoiding being scared about UB: &quot;UB is unmanageable, and it bites occasionally&quot;<br>
<p>
The solution is to manage it using automated UB risk mitigation testing, for example using GitLab tests.<br>
Vasileios Gemistos&#x27;s Master thesis [2] contains compiler test cases for most C UB cases for<br>
compiler consistency testing. Based on consistently validated compiler infrastructure (warnings/errors),<br>
and known valid mitigations, Kernel side could manage / rely on keeping UB risks low.<br>
Both C and Rust sides could benefit (library side improvements benefit both)<br>
of having good quality UB issue risk mitigation.<br>
<p>
<p>
More detailed thoughts<br>
<p>
My risk management point of view for C/Rust is,<br>
that, in general, for both languages there is a risk that UB<br>
sneaks in and causes software bugs.<br>
<p>
Risk management (Wikipedia reference [1]):<br>
1. Identify the threats<br>
  What are the UB cases ? C standard enlists all UB cases.<br>
  What code parts are affected? GCC&#x27;s libgccjit and LLVM library side.<br>
  * Both languages use syntax and semantics to avoid many UB cases (silence is acceptance here).<br>
  * Most remaining C language issues with sample code are enlisted in master thesis<br>
    Vasileios Gemistos: &quot;A Study on Undefined Behaviour in C&quot; [2]<br>
  - GCC / LLVM compiler C front end mitigates UB with warnings and errors (with varying success)<br>
  - GCC / LLVM compiler Rust front end mitigates UB with errors.<br>
  Where is the affected code located?<br>
  * UB code identification and mitigation is done in compiler front end and library side<br>
    - Front ends: GCC gccrs / C / C++ front ends, LLVM: rustc, C / C++ front ends<br>
    - Back end libraries: GCC libgccjit, LLVM: (llvm-config --libs core), for example libLLVM-12<br>
  What is the current status?<br>
  Test driven development:<br>
    - Thesis has test cases for many UB cases,<br>
      those tests could be automated (GitLab?) to see compiler status (error versus warning for UB case).<br>
    - After having more robust validated compiler infrastructure, Kernel developers<br>
      could rely on compiler warnings and errors for both C (and Rust).<br>
    - While seeing full overall UB picture, C front end and library side could be improved.<br>
    - Compiler library side improvements could benefit both Rust and C.<br>
<p>
2. Assess the vulnerability of critical assets to specific threats<br>
3. Determine the risk (i.e. the expected likelihood and consequences of specific types of attacks on specific assets)<br>
<p>
4. Identify ways to reduce those risks<br>
  Three ways (perhaps most in the long run per UB case):<br>
  * Kernel specific: enlist Kernel solution constructs to avoid the risks for each UB case.<br>
  * C/Rust compiler flags to enable errors and warnings for the UB cases.<br>
  * C/Rust language improvements: for example overall soundness improvements.<br>
     =&gt; Try to share code between C and Rust in library side when sane:<br>
      - Rust specific instrumentation for GIMPLE/LLVM-AST in Rust side, same for C.<br>
      - Efficient shared implementation in compiler&#x27;s library (libgccjit, libLLVM-&lt;version&gt;) side.<br>
      - Balance between front end and library side: Keep co-operation and productivity between stakeholders.<br>
      - Try to keep &quot;rustc&quot; and &quot;gccrs&quot; compilers fast, same for C front ends, all will benefit: Kernel is a large project.<br>
<p>
[1] <a href="https://en.wikipedia.org/wiki/Risk_management">https://en.wikipedia.org/wiki/Risk_management</a><br>
[2] <a href="https://solidsands.com/wp-content/uploads/Master_Thesis_Vasileios_GemistosFinal.pdf">https://solidsands.com/wp-content/uploads/Master_Thesis_V...</a><br>
<p>
Best Regards,<br>
Marko<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863478/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle"> Rust / C risk management for undefined behavior (UB)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2021 9:41 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/864083/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What are the UB cases ? C standard enlists all UB cases.</font><br>
<p>
It&#x27;s not that easy! It lists *some*. Undefined behaviour is behaviour the Standard does not define: nothing more, nothing less. It does list some of them, but not all (that list would be much longer): but things the Standard does not mention are also things it does not define, and undefined behaviour. (Some of them might be defined in other standards: POSIX defines a bunch of stuff C99 leaves either explicitly or implicitly undefined, for example.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor863541"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2021 6:13 UTC (Tue)
                               by <b>rhdxmr</b> (guest, #44404)
                              [<a href="/Articles/863541/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux kernel development community mostly uses C. And its standard is old<br>
enough for most people to get familiar with. But rust is too modern and still<br>
rapidly developed.<br>
<p>
I like both languages. I had developed applications in C for over 5 years as a<br>
professional job. And nowadays I feel fun writing rust code and I am a<br>
maintainer of redBPF which is rust library for eBPF.<br>
<p>
I know rust is suitable for doing low-level stuff while providing memory<br>
safety. But I don&#x27;t want to convince other developers to use it. It&#x27;s a too<br>
different language from C. And I don&#x27;t consider developers already satisfied<br>
with C want other modern languages. It&#x27;s really hard to prove that rust will<br>
bring great advantages to the Linux kernel. And also I am not sure it brings<br>
advantages on the whole. No quantitative numbers about it can be made. I think<br>
adding a second language to Linux is about the domain of belief or<br>
interest. Both decisions for accepting or rejecting can be selected as of<br>
now. The supporting reasons can be made up for the decision. Talking about it<br>
just causes controversy and agreement will not be reached. Because no<br>
indisputable numbers or proof can be provided. It is just politics.<br>
<p>
I like rust and I hope Linux adopts rust as its second language. But it is only<br>
my subjective valuation. I don&#x27;t know whether this is helpful to the entire<br>
Linux development community. It is just my wish. If most of the developers are<br>
happy with it, no problems. If a nonnegligible number of developers feel<br>
uncomfortable with it, rust can not be allowed.<br>
<p>
Most people choose their technical skills by pursuing their interests,<br>
prediction, or expectation about the future. But it is hard to get based on the<br>
fact. Where is the fact? How can I discover it? Nobody knows. We just do it<br>
because others do it or just it&#x27;s fun.<br>
<p>
Yes, I am a bit cynical about the argument about choosing languages. But<br>
controversy about languages always has not been reached an agreement. It&#x27;s like<br>
politics, religion, or whatever we should respect others.<br>
<p>
So I don&#x27;t like this trial of adding rust to Linux. It is pointless and if<br>
someone think rust is the silver bullet, it&#x27;s better to support Redox... Just<br>
spend your precious time to make some heritage.. not try to change something<br>
that runs fast.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863541/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863625"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2021 17:49 UTC (Tue)
                               by <b>ma4ris5</b> (guest, #151140)
                              [<a href="/Articles/863625/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust, C and C++ are compiler front end languages, both are using same compiler back end libraries for the same compiler suite.<br>
<p>
Detailed attributes seem to be the working solution to inform compiler about how the function behaves.<br>
Both front ends can use same attribute mechanisms to make compiler back end libraries informed about function behavior.<br>
<p>
realloc() bug example isn&#x27;t actually C or Kernel issue at all: It seems to be LLVM C compiler front end bug,<br>
and it affects &quot;rustc&quot; LLVM frontend implementation: &quot;rustc&quot; can&#x27;t use realloc().<br>
<p>
Here is the &quot;realloc()&quot; &quot;noalias&quot; issue analysis.<br>
Correct return value is &quot;2 2&quot; which GCC gives,<br>
and incorrect result comes from LLVM compiler (Fedora 34)<br>
Test case was shown in <a href="https://lwn.net/Articles/862521/">https://lwn.net/Articles/862521/</a><br>
<p>
$ clang -O3  realloc_test.c -o realloc_test ; ./realloc_test<br>
1 2<br>
$ gcc -O3  realloc_test.c -o realloc_test ; ./realloc_test<br>
2 2<br>
<p>
What is significant, &quot;stdlib.h&quot; doesn&#x27;t have &quot;noalias&quot; attribute for realloc()&quot;.<br>
Even while &quot;noalias&quot; is absent, &quot;clang&quot; hard codes &quot;noalias&quot; for the function:<br>
<p>
/usr/include/stdlib.h contains (Fedora 34):<br>
/* __attribute_malloc__ is not used, because if realloc returns<br>
   the same pointer that was passed to it, aliasing needs to be allowed<br>
   between objects pointed by the old and new pointers.  */<br>
extern void *realloc (void *__ptr, size_t __size)<br>
     __THROW __attribute_warn_unused_result__ __attribute_alloc_size__ ((2));<br>
<p>
The above proves, that &quot;stdlib.h&quot; is clean, and doesn&#x27;t contain the &quot;noalias&quot; attribute,<br>
so the bug is within &quot;clang&quot; LLVM compiler, for example when -O3 is used there.<br>
<p>
<p>
After realloc() definition, stdlib.h has function &quot;reallocarray()&quot;, which is also interesting,<br>
because it declares __attribute_alloc_size__ ((2, 3).<br>
<p>
/* Re-allocate the previously allocated block in PTR, making the new<br>
   block large enough for NMEMB elements of SIZE bytes each.  */<br>
/* __attribute_malloc__ is not used, because if reallocarray returns<br>
   the same pointer that was passed to it, aliasing needs to be allowed<br>
   between objects pointed by the old and new pointers.  */<br>
extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)<br>
     __THROW __attribute_warn_unused_result__<br>
     __attribute_alloc_size__ ((2, 3));<br>
#endif<br>
<p>
<p>
I think that there could be room for detailed function definition,<br>
by adding already usable attributes into Kernel library functions.<br>
<p>
Also adding new attributes into Kernel and compiler could be useful.<br>
<p>
It might be even possible to add a domain language for custom attribute declarations,<br>
which could be consumed by C compiler(s), for a precise function use validation.<br>
I don&#x27;t know if this has been considered.<br>
<p>
Also &quot;C headers to Rust&quot; automatic conversions could take advantage of those<br>
additional attributes.<br>
<p>
<p>
For example a value range could be useful, something like:<br>
__attribute_value_range__(0, 0, 64) /* return value&#x27;s value range is [0 - 64] */<br>
__attribute_value_range__(1, 0, 256) /* First argument&#x27;s value range is [0 - 256] */<br>
int foo (int i) { return i &gt;&gt; 2; }<br>
<p>
__attribute_value_errnum_with_range__(0, -255, -10, 0, 64) /* error within [-255,-10], value within [0 - 64] */<br>
__attribute_value_errnum_with_range__(1, -255, -10, 0, 256) /* error within [-255,-10], value within [0 - 256] */<br>
int foo (int i) { if (i &lt; 0) return i else return i &gt;&gt; 2; }<br>
<p>
These should be such that they should be sane, and could be mapped into &quot;C back end&quot; libraries easily.<br>
<p>
Personally I think that &quot;always inline&quot; functions could be used instead of macros, when this facility<br>
is needed, and macro kind of inlining behaviour is necessary.<br>
<p>
So if the additional attribute declaration is useful for C, and also looks good from following point of views:<br>
C++, C-to-Rust, Rust, and it is correct, readable and manageable, it should be worth adding.<br>
<p>
Compiler verification for having a working compiler:<br>
- make sure (old) compiler doesn&#x27;t generate bad code<br>
  make c_compile_bug_check<br>
- Make sure errors / warnings are reported (including relevant undefined behaviour cases for the Kernel):<br>
  make c_compile_error_warning_check<br>
<p>
Consume CERT Kernel warnings:<br>
- Add already existing attributes to function definitions and variables.<br>
- Introduce new attributes into for example value ranges, so that compiler can see whether integer could overflow.<br>
<p>
For example integer overflow mitigation could be something like:<br>
1. Enable or add (per C file) compilation flag for overflow reporting for making patches.<br>
2. Compiler (must) track value&#x27;s ranges and classifications (errors, warnings),<br>
    only warn about possible overflow cases.<br>
3. Add attributes for value&#x27;s range, to tell compiler what range the number has =&gt; unnecessary warnings go away. LTO / static check can validate these.<br>
4. Add overflow check, or add overflow semantics for a calculation with a warning (may wrap, saturate to MIN_INT, 0 or, MAX_INT) =&gt; UB warning goes away.<br>
<p>
5. Deliver individual patches for C header files for fixing overflow warning issues (add the range semantics),<br>
to fix large code base issues.<br>
6. Deliver patches that fix a single C file for remaining issues, until the C file doesn&#x27;t have integer overflow risk, 7. Last patch could enable &quot;integer overflow&quot; compiler warning, to make sure integer overflow is absent or visible in future Kernel patches (static analysis bot could watch these).<br>
<p>
A bot could also search for opportunities to enable the &quot;integer overflow compiler check&quot; for files that don&#x27;t have issues currently.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863625/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2021 0:34 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/863694/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; __attribute_value_range__(0, 0, 64) /* return value&#x27;s value range is [0 - 64] */</font><br>
<font class="QuotedText">&gt; __attribute_value_range__(1, 0, 256) /* First argument&#x27;s value range is [0 - 256] */</font><br>
<font class="QuotedText">&gt; int foo (int i) { return i &gt;&gt; 2; }</font><br>
<p>
This reads a lot like C++ contracts to me. C could adopt something like those, but I imagine the C++ committee is going to forge the main path there and C can take it or leave it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor863860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2021 15:37 UTC (Wed)
                               by <b>ma4ris5</b> (guest, #151140)
                              [<a href="/Articles/863860/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<p>
<font class="QuotedText">&gt; This reads a lot like C++ contracts to me. C could adopt something like those, but I imagine the C++ committee is going to forge the main path there and C can take it or leave it.</font><br>
<p>
I agree:<br>
<p>
Easiest low hanging fruit are the features that are already implemented and used<br>
actively at C++ side, concepts, which were taken from Rust into C++.<br>
<p>
Kernel&#x27;s requirements might be too detailed compared to generic C/C++, thus<br>
a domain language for attributes could possibly fix the remaining gap<br>
for additional checks and optimizations.<br>
<p>
I mean items like:<br>
Value compaction: negative return value is for an error, while &gt;= 0 value is success case.<br>
Value bit range classification: some bits are used independently from others.<br>
<p>
So with domain language for attributes, static analysis and compile time optimization could<br>
possibly improve runtime performance, and show places for potential overflows or leaks<br>
from those ranges of values.<br>
<p>
I found following research title, which possibly might be near the idea:<br>
<p>
<a href="https://www.researchgate.net/publication/328988822_A_Generic_Static_Analysis_Framework_for_Domain-specific_Languages">https://www.researchgate.net/publication/328988822_A_Gene...</a><br>
<p>
I&#x27;m thinking more like the &quot;printf&quot; formatting checks:<br>
If that could be generalized for functions and variables (into compile time/static check time),<br>
then it could improve robustness.<br>
<p>
In a way that the attribute declaration could be specified in the source code,<br>
so that the compiler could verify the checks efficiently (enough) and optimize accordingly.<br>
<p>
LTO side approaches this without code changes: it tracks value ranges between functions,<br>
and can see possible overflow cases.<br>
Attribute declarations could show developer&#x27;s intention in these corner cases,<br>
so compiler could warn about remaining possible issues.<br>
<p>
Thus code could be proven to have no overflow issues, or accidental collisions between error values and valid values (to reduce risk for some of the rare problems).<br>
<p>
Also C-to-Rust automatic conversion could pick those declarations and generate better wrappers.<br>
<p>
Standardizing every new attribute feels too slow to have efficient progress for Kernel development,<br>
so standardizing language for attribute declarations could be better.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/863860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 2:54 UTC (Sun)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/864233/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To suggest that anything moved from Rust into C++ makes all subsequent statements suspect, thus probably not even worth reading.<br>
<p>
Especially, C++ Concepts predate even the first proposal of Rust as a project.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864249"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 12:32 UTC (Sun)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/864249/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; To suggest that anything moved from Rust into C++ makes all subsequent statements suspect, thus &gt;probably not even worth reading.</font><br>
<p>
<a href="https://devblogs.microsoft.com/cppblog/new-safety-rules-in-c-core-check/">https://devblogs.microsoft.com/cppblog/new-safety-rules-i...</a><br>
<p>
&quot;C++ often falls behind Rust when it comes to programming safety. Visual Studio 2019 version 16.7 contains four new rules in C++ Core Check to incorporate some safety features from Rust into C++.&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864249/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor864253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 13:49 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/864253/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect you&#x27;re talking about the standards level, but implementations have definitely been paying attention (see the MSVC post in the sibling comment). However, to say that Rust is not exerting some pressure on C++ is to ignore what is happening.<br>
<p>
The epochs proposal[1] was directly inspired by Rust&#x27;s edition mechanism to allow for syntactic evolution of the language without breaking everything. Unfortunately, C++ has semantics tied too tightly to the syntax that even deprecating `0` or `NULL` for `nullptr` is a no-go due to ADL, type coercion, and confused template rules. While it&#x27;d be a nice thing to be able to bundle up terrible promotion rules to specific modules, the way that templates expand mean that you need to decide whether to evaluate them with the declaration&#x27;s epoch rules or the instantiator&#x27;s epoch rules because concepts care quite a bit about whether specific syntactic constructions are valid. Getting implementations to warn &quot;under epoch X, we find that type deduction and ADL take a different path because `0` no longer converts to `T*` silently&quot; is not something anyone is going to want to handle. Either &quot;no one&quot; updates to the new epoch because their codebase is not clean under `clang-tidy`&#x27;s &quot;modernize-*&quot; lints or only new code uses it because it&#x27;s an error for them anyways.<br>
<p>
Pattern-matching calls out Rust as a language to compare C++&#x27;s proposals against and is also called out for how to issue warnings due to incomplete matching. Pattern matching has been around since &quot;forever&quot; with various ML languages, but I wouldn&#x27;t be surprised if Rust&#x27;s success with it was the &quot;oomph&quot; that ignited the interest of it enough to actually get it in front of the committee for C++ (or into a mergable PEP for Python for that matter).<br>
<p>
I&#x27;m sure there are other Rust-inspired proposals around, but I suspect a number of them are in the library track (which I don&#x27;t have time to follow).<br>
<p>
[1] <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1881r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864287"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2021 8:01 UTC (Mon)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/864287/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Pattern-matching […] (or into a mergable PEP for Python for that matter).</font><br>
<p>
Huh? PEP 634 has been merged into what&#x27;s going to be 3.10 since February 26th, commit 145bf26.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864287/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864352"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2021 16:23 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/864352/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, that was the &quot;mergable PEP&quot; I was referring to. Weren&#x27;t there prior attempts for similar things that went nowhere or am I crossing signals in my memory?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864352/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor864462"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;anything moved from Rust into C++&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2021 3:36 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/864462/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why would such a claim &quot;make all subsequent statements suspect&quot; when it seems to be a very reasonable position?<br>
<p>
The shortest path wouldn&#x27;t be through Rust, but lots of key C++ people have exposure to stuff that they could in principle have seen somewhere else earlier but ended up learning in Rust because of Rust&#x27;s popularity.<br>
<p>
Take P2216. Rather modestly this proposal suggested that, since languages such as Rust treat nonsensical formats as a compile time error, rather than waiting until your code runs before inevitably complaining that the format is nonsense C++ could match the state of the art in this area and refuse to compile the program.<br>
<p>
Did Rust _invent_ this practice? No of course not. But, in C++ 20 (as originally shipped) the nonsense compiled, and in Rust it did not, the author and Library Evolution Working Group both saw that this is obviously superior, and so it was accepted for C++ 23 and &quot;backported&quot; into the standard library specification. P2216 doesn&#x27;t try to find out historically which postgraduate student first wrote a program that could do this, perhaps in 1985 in Lisp, it just points out that today Rust is a popular language that gets this right and C++ should join it.<br>
<p>
Or P1679. Once again, Rust doesn&#x27;t take centre stage here, the author merely acknowledges that &quot;Bananas&quot;.contains(&quot;nanas&quot;) exists in Rust† whereas in C++ you were expected to construct a string or string_view and then run find(&quot;nanas&quot;) and confirm the result is npos. Which, if you come from any language (not just Rust) with &quot;Bananas&quot;.contains(&quot;nanas&quot;) seems silly. Why am I paying the cognitive price of a find method I don&#x27;t need when all I wanted to do was check whether one thing is contained in another ?<br>
<p>
† Behind the scenes something clever is happening here. Today the C++ 23 feature is a bunch of overloads on string and string_view and so on. But the Rust feature isn&#x27;t, it&#x27;s relying on an (unstable for now) Trait named std::str::pattern::Pattern. If a future standard C++ adds any more things you might reasonably expect to be parameters for string.contains() they&#x27;ll be additional overloads. That isn&#x27;t inherited by your own string-like classes, you too will need to add the overloads explicitly, likewise if you currently add overloads to string.find() for your own needs, you&#x27;ll want to add the same overloads to string.contains() for symmetry.<br>
<p>
But thanks to Pattern in Rust both those things happen for free when you simply use Pattern. For example Rust already provided an implementation of Pattern for any F: FnMut(char) -&gt; bool -- and so, if you write any function or closure that can decide whether a particular Unicode scalar (approximately a single code point, so a Poop emoji or the capital A, but not a flag or two women kissing) is a match that&#x27;ll let you ask whether a string.contains(it) or string.ends_with(it) or just to string.find(it)  and these all work today.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864462/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;anything moved from Rust into C++&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2021 12:57 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/864470/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; a particular Unicode scalar (approximately a single code point, so a Poop emoji or the capital A, but not a flag or two women kissing) is a match that&#x27;ll let you ask whether a string.contains(it) or string.ends_with(it) or just to string.find(it) and these all work today.</font><br>
<p>
Just to nitpick, `u8` is the UTF-8 scalar (the smallest unit of the data stream). Rust&#x27;s `char` is a codepoint (which may have come from multiple scalars). What users see as a single grapheme (or grapheme cluster) may have come from multiple codepoints (including flags or the &quot;two+ people&quot; emoji). So that pattern function can &quot;see&quot; `A` alone, but is going to see a decomposed `á` as `a` and a combining character since it is two codepoints (which is why I&#x27;d assume it is `FnMut`: so it can &quot;remember&quot; such things).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;anything moved from Rust into C++&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2021 13:36 UTC (Wed)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/864471/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Just to nitpick, `u8` is the UTF-8 scalar (the smallest unit of the data stream). Rust&#x27;s `char` is a codepoint (which may have come from multiple scalars).</font><br>
<p>
Just to nitpick further, I think that&#x27;s entirely wrong :-) . The Rust documentation says char is a Unicode Scalar Value, which Unicode defines as &quot;Any Unicode code point except high-surrogate and low-surrogate code points&quot;, i.e. it&#x27;s not the same as a code point. And u8 is not a specifically UTF-8 type - it&#x27;s just an unsigned 8-bit integer, which happens to match the definition of a UTF-8 code unit (which nobody ever calls a &quot;UTF-8 scalar&quot;).<br>
<p>
(But I believe you&#x27;re right that what a human would perceive as &quot;a character&quot; is what Unicode calls an extended grapheme cluster, which is (confusingly) a sequence of Rust chars. The name &quot;char&quot; seems like a bad decision by Rust - e.g. Go uses &quot;rune&quot; as the type for code points, which is a bit weird but is much less misleading. And Rust doesn&#x27;t natively handle grapheme clusters at all, you need a third-party crate for that, unlike e.g. Swift where String is defined as a sequence of Characters and Character is defined as a grapheme cluster (and you have to use non-default APIs if you want access to a String&#x27;s Unicode Scalar Values or its UTF-8 code units).)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;anything moved from Rust into C++&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2021 14:01 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/864473/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agh. I got terms confused. `u8` is the &quot;code unit&quot; of UTF-8. Yes, scalars are code points. *face palm*<br>
<p>
<font class="QuotedText">&gt; (But I believe you&#x27;re right that what a human would perceive as &quot;a character&quot; is what Unicode calls an extended grapheme cluster, which is (confusingly) a sequence of Rust chars. The name &quot;char&quot; seems like a bad decision by Rust - e.g. Go uses &quot;rune&quot; as the type for code points, which is a bit weird but is much less misleading. And Rust doesn&#x27;t natively handle grapheme clusters at all, you need a third-party crate for that, unlike e.g. Swift where String is defined as a sequence of Characters and Character is defined as a grapheme cluster (and you have to use non-default APIs if you want access to a String&#x27;s Unicode Scalar Values or its UTF-8 code units).)</font><br>
<p>
I think Rust got it right keeping grapheme clusters out of the language proper. What sequence of code points constitutes a grapheme cluster changes from standard to standard as new codepoints and rules for combining are added. For example, `&lt;person&gt;&lt;join&gt;&lt;heart&gt;&lt;join&gt;&lt;person&gt;` is now a single grapheme cluster, but wasn&#x27;t in older versions of Unicode. Unless languages are tacking on `Unicode_12_0` on their `grapheme_length()` methods, it means that as the language updates its tables for newer standards, these methods can change their minds depending on what combinations are newly allowed.<br>
<p>
Yes, `char` is not the greatest name, `upoint` may have been better (as `unicode_point` is too long). However, I think `rune` is also poor since that brings to my mind &quot;grapheme (cluster)&quot; more than &quot;code point&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor865931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;anything moved from Rust into C++&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2021 2:14 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/865931/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; which is why I&#x27;d assume it is `FnMut`: so it can &quot;remember&quot; such things</font><br>
<p>
I expect it&#x27;s FnMut because the standard advice is to choose callable trait bounds in order of preference: FnOnce, FnMut, Fn. By using the broadest bounds in this case, and the narrowest bounds when writing functions or closures, you promote re-usability.<br>
<p>
Since we can expect to call this more than once FnOnce isn&#x27;t viable, so FnMut is next best. However although I did write an implementation to check it&#x27;s actually possible to implement e.g. a closure that matches various couples kissing in Unicode but not anything else it was rather awkward to do this, and I don&#x27;t anticipate such uses predominating. Instead I expect that once Pattern stabilizes people will write adaptors to make Patterns out of other things you could plausibly want.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor864230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 2:27 UTC (Sun)
                               by <b>Coconut</b> (guest, #153428)
                              [<a href="/Articles/864230/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Have they considered Ada/SPARK? If they did, why did they decide against it and pick Rust over it? Ada/SPARK provides all the safety Rust does without sacrificing performance, and it provides even more! Its type system is great. You can have pre- and post-conditions. You can have ranged integer types. You can eliminate runtime errors and prove correctness of your code through formal verification. Just take a look at projects from <a rel="nofollow" href="https://github.com/Componolit">https://github.com/Componolit</a>. Plus, pointers are no longer an issue either: <a rel="nofollow" href="https://blog.adacore.com/using-pointers-in-spark">https://blog.adacore.com/using-pointers-in-spark</a>. I would also like to add, that Ada has a package manager as well, namely Alire[2].<br>
<p>
Given all that, my honest question is: why not Ada/SPARK when it is undoubtedly much better when it comes to safety, and much easier to read and write (to each their own, I suppose, but normal Rust can have 7 (!)[1] symbols next to each other and what it does (in generally, too) is way too hidden as opposed to the verbose (but not annoyingly so) Ada. You look at Ada and you immediately know what it does. The same cannot be said about Rust. It is almost akin to Perl. Seriously.<br>
<p>
Useful links:<br>
<p>
- <a rel="nofollow" href="https://docs.adacore.com/spark2014-docs/html/ug/en/usage_scenarios.html">https://docs.adacore.com/spark2014-docs/html/ug/en/usage_...</a><br>
- <a rel="nofollow" href="https://docs.adacore.com/spark2014-docs/html/ug/en/source/type_contracts.html">https://docs.adacore.com/spark2014-docs/html/ug/en/source...</a><br>
- <a rel="nofollow" href="https://docs.adacore.com/spark2014-docs/html/ug/en/source/concurrency.html#protected-types-and-protected-objects">https://docs.adacore.com/spark2014-docs/html/ug/en/source...</a><br>
- <a rel="nofollow" href="https://www.electronicdesign.com/technologies/dev-tools/article/21801311/adacore-11-myths-about-ada">https://www.electronicdesign.com/technologies/dev-tools/a...</a><br>
- <a rel="nofollow" href="https://blog.adacore.com/from-rust-to-spark-formally-proven-bip-buffers">https://blog.adacore.com/from-rust-to-spark-formally-prov...</a><br>
- <a rel="nofollow" href="https://en.wikibooks.org/wiki/Ada_Programming/Contract_Based_Programming">https://en.wikibooks.org/wiki/Ada_Programming/Contract_Ba...</a><br>
- <a rel="nofollow" href="https://www.adacore.com/gems/gem-31">https://www.adacore.com/gems/gem-31</a><br>
- <a rel="nofollow" href="https://www.adacore.com/uploads/books/pdf/AdaCore-Tech-Cyber-Security-web.pdf">https://www.adacore.com/uploads/books/pdf/AdaCore-Tech-Cy...</a><br>
<p>
Check them out. After you are done, can you tell me why Rust over Ada/SPARK?<br>
<p>
[1]<br>
<p>
  let mut parents_array = ArrayVec::&lt;[&amp;[u8; BLOCK_LEN]; MAX_SIMD_DEGREE_OR_2]&gt;::new()<br>
  let input_ptrs: &amp;[*const u8; DEGREE] = &amp;*(inputs.as_ptr() as *const [*const u8; DEGREE]);<br>
<p>
[2] <a rel="nofollow" href="https://alire.ada.dev/">https://alire.ada.dev/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864242"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 9:47 UTC (Sun)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/864242/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Check them out. After you are done, can you tell me why Rust over Ada/SPARK?</font><br>
<p>
Because Rust advocates were willing to do the work (including the non-technical work of persuading the likes of Linus and Greg that their proposal is worthy of consideration at all), and Ada/SPARK advocates have apparently not been willing to do the work.<br>
<p>
Of course, I&#x27;d be surprised if the average Ada/SPARK advocate was interested in touching the Linux kernel in the first place (at least without a hazmat suit and long-handled tongs).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864242/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 18:19 UTC (Sun)
                               by <b>Coconut</b> (guest, #153428)
                              [<a href="/Articles/864256/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks, that answers my question.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor864257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 18:19 UTC (Sun)
                               by <b>joshc</b> (guest, #153433)
                              [<a href="/Articles/864257/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A quick search tells me that such a thing exists for Ada.<br>
<p>
Source code: <a rel="nofollow" href="https://github.com/alkhimey/Ada_Kernel_Module_Framework">https://github.com/alkhimey/Ada_Kernel_Module_Framework</a><br>
Blog posts can be found here: <a rel="nofollow" href="http://www.nihamkin.com/tag/kernel.html">http://www.nihamkin.com/tag/kernel.html</a><br>
<p>
I do not believe that it uses SPARK though. You might want to check out https://wookey-project.github.io/ewok/ada_spark.html for something like that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 19:28 UTC (Sun)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/864262/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looking at both of those things for a few minutes:<br>
<p>
It appears that the Ada Kernel Module Framework only exists as a proof of concept, and has not been the target of any publicly visible work in the original github repository or the two visible github forks.<br>
<p>
EwoK looks like it may well be quite an interesting project, but it&#x27;s 100% its own thing and nothing to do with the Linux kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor864251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 13:34 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/864251/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Have they considered Ada/SPARK?</font><br>
<p>
The Linux kernel was not &quot;seeking&quot; a new language to add. Developers did the work and showed how Rust could be used in it and *then* came to the kernel. Where was this done for Ada/SPARK for &quot;them&quot; to consider?<br>
<p>
<font class="QuotedText">&gt; let mut parents_array = ArrayVec::&lt;[&amp;[u8; BLOCK_LEN]; MAX_SIMD_DEGREE_OR_2]&gt;::new()</font><br>
<font class="QuotedText">&gt; let input_ptrs: &amp;[*const u8; DEGREE] = &amp;*(inputs.as_ptr() as *const [*const u8; DEGREE]);</font><br>
<p>
Sure, syntactically, all kinds of abominations are possible. Crafting a grammar to only accept &quot;beautiful&quot; code is likely a doomed endeavour for any &quot;useful&quot; language. Neither of these look like idiomatic code at all. The former because the type is probably deduced elsewhere by what APIs accept `parents_array` (or, if not, that `[u8; BLOCK_LEN]` deserves its own type name; as does the `MAX_SIMD_DEGREE_OR_2`-sized array) so you end up with either:<br>
<p>
let mut parents_array = ArrayVec::new();<br>
// parents_array.push(&amp;simd_blocks); // type deduced here<br>
<p>
or:<br>
<p>
let mut parents_array = ArrayVec::&lt;SimdBlockRefs&gt;::new();<br>
<p>
The latter `input_ptrs` is not idiomatic because it is desperately in need of an `unsafe` specifier and a comment describing what it does is safe. Slinging around an array of pointers is also not very Rust-like. The need for casts on the right and left side is also just weird…type deduction should make the left-hand type unnecessary (ignoring the unsafe-ness being presented).<br>
<p>
<font class="QuotedText">&gt; Plus, pointers are no longer an issue either: <a href="https://blog.adacore.com/using-pointers-in-spark.">https://blog.adacore.com/using-pointers-in-spark.</a></font><br>
<p>
Interesting how &quot;cannot store pointers in structures&quot; is considered suitable for &quot;no longer an issue&quot; in something like the kernel. That is still under active research and/or implementation by my reading of that post. And, without Rust, Ada/SPARK might still be without pointers, so how would that have worked out before Rust came onto the scene?<br>
<p>
<font class="QuotedText">&gt; I would also like to add, that Ada has a package manager as well, namely Alire</font><br>
<p>
I think the Linux kernel is about as interested in crates.io as they are about PyPI. Handy, but almost zero code there is suitable for usage in the kernel&#x27;s context (except for usage in build-time or other useful tools *related* to the kernel).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 18:19 UTC (Sun)
                               by <b>Coconut</b> (guest, #153428)
                              [<a href="/Articles/864255/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Neither of these look like idiomatic code at all.</font><br>
<p>
The code can be found here: <a rel="nofollow" href="https://docs.rs/blake3/0.1.0/src/blake3/lib.rs.html">https://docs.rs/blake3/0.1.0/src/blake3/lib.rs.html</a> which is the official implementation of BLAKE3 in Rust. Take of that what you will. We will see what kind of Rust code you are going to find in the Linux kernel.<br>
<p>
<font class="QuotedText">&gt; Interesting how &quot;cannot store pointers in structures&quot; is considered suitable for &quot;no longer an issue&quot; in something like the kernel. That is still under active research and/or implementation by my reading of that post.</font><br>
<p>
Perhaps a recent one would have served you better, then.<br>
<p>
<font class="QuotedText">&gt; so how would that have worked out before Rust came onto the scene?</font><br>
<p>
How can you comment on this and the previous one with so much certainty if you have seemingly have not done your research? I obviously omitted a lot of information on Ada/SPARK. I am not supposed to sell it to you. That is not the point of the comment. I just wanted to know if Ada has been ever considered given that it is *perfectly suitable* for kernel development and is actually more safe than Rust (yes, it actually is, perhaps go through all of my links, then). To answer your question: they were actually working on it before Rust.<br>
<p>
<font class="QuotedText">&gt; I think the Linux kernel is about as interested in crates.io as they are about PyPI.</font><br>
<p>
I mentioned it because it is a common reaction from people that &quot;Ada is not modern, it does not even have a package manager!&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2021 20:45 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/864268/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The code can be found here: <a href="https://docs.rs/blake3/0.1.0/src/blake3/lib.rs.html">https://docs.rs/blake3/0.1.0/src/blake3/lib.rs.html</a> which is the official implementation of BLAKE3 in Rust. Take of that what you will. We will see what kind of Rust code you are going to find in the Linux kernel.</font><br>
<p>
Hmm. Well, I found `parents_array` at least. Not *quite* sure why it needs to be specified there (possibly the length?), but type aliases would certainly make it much more readable IMO.<br>
<p>
As for `input_ptrs`, that is deep in AVX2 code…so yeah, that&#x27;s probably going to get a bit hairy (and, indeed, has a comment about its safety).<br>
<p>
Either way, given the *other* restrictions on code such as this, it&#x27;s not where I&#x27;d look for &quot;normal&quot; Rust code (unless I was coding up replacements for the sections doing similar machinations in the kernel today).<br>
<p>
<font class="QuotedText">&gt; Perhaps a recent one would have served you better, then.</font><br>
<p>
I used the post you linked to… Which, FWIW, I had actually read in the last week, though I missed that it was from 2019 (IIRC, it was from a link on HN or somewhere). Either case, yes, Ada is older than Rust. I&#x27;m not doubting that. I&#x27;m doubting the &quot;Ada finally has pointers!&quot; would have happened without Rust showing how to do lifetime tracking without runtime overhead:<br>
<p>
<font class="QuotedText">&gt; I think it was work on the ParaSail language, and the emergence of the Rust language, that first made us look again into supporting this feature. Pointer ownership models did not appear explicitly within Rust, but Rust made the restrictions associated with them look tractable, and maybe even desirable from a safety point of view.</font><br>
<p>
makes it seem like Rust is what made the SPARK team look at doing more rigorous pointer lifetime analysis. Later:<br>
<p>
<font class="QuotedText">&gt; But this is not great, as now I have a memory leak. Indeed, the value previously stored in My_Dictionary is no longer accessible and it has not been deallocated. The SPARK tool does not currently complain about this problem, even though the SPARK definition says it should (it has not been implemented yet).</font><br>
<p>
<font class="QuotedText">&gt; But this is not supported yet by the proof tool, as it raises the complex issue of tracking modifications of X that were done through Y during its lifetime:</font><br>
<p>
So maybe these things are complete, but links to further progress would be helpful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor864299"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2021 14:21 UTC (Mon)
                               by <b>oconnor663</b> (guest, #119484)
                              [<a href="/Articles/864299/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi, I wrote that code. So here&#x27;s a bunch of Rust details that no one asked for :) This is the starting example (<a rel="nofollow" href="https://github.com/BLAKE3-team/BLAKE3/blob/0.1.0/src/lib.rs#L491">https://github.com/BLAKE3-team/BLAKE3/blob/0.1.0/src/lib....</a>):<br>
<p>
    let mut parents_array = ArrayVec::&lt;[&amp;[u8; BLOCK_LEN]; MAX_SIMD_DEGREE_OR_2]&gt;::new();<br>
<p>
A couple pieces of punctuation in that example comes from the fact that prior to the release of Rust 1.51 this March, Rust didn&#x27;t properly support const generics. So types like ArrayVec needed to work around that with shenanigans. But now that we do have const generics and an updated version of ArrayVec, the code looks like this (<a rel="nofollow" href="https://github.com/BLAKE3-team/BLAKE3/blob/1.0.0/src/lib.rs#L637">https://github.com/BLAKE3-team/BLAKE3/blob/1.0.0/src/lib....</a>):<br>
<p>
    let mut parents_array = ArrayVec::&lt;&amp;[u8; BLOCK_LEN], MAX_SIMD_DEGREE_OR_2&gt;::new();<br>
<p>
That is, an &quot;ArrayVec of at most MAX_SIMD_DEGREE_OR_2 elements, each of type &#x27;reference to a byte array of length BLOCK_LEN&#x27;&quot;. One interesting thing to notice here is that the element type is actually optional. This will also compile (and would have in v0.1.0 too):<br>
<p>
    let mut parents_array = ArrayVec::&lt;_, MAX_SIMD_DEGREE_OR_2&gt;::new();<br>
<p>
That is, an &quot;ArrayVec of at most MAX_SIMD_DEGREE_OR_2 elements, each of some type that&#x27;s deduced by the compiler.&quot; I chose to write the full type out explicitly, because this is highly optimized code doing tricky things, and I think this version is actually easier to understand for someone who&#x27;s familiar with Rust. But opinions can definitely differ here.<br>
<p>
Another thing to think about is that in C, this might have been just &quot;char**&quot;. What all this extra typing is buying us in Rust, is that the function is 100% memory safe. (It&#x27;s going to call some SIMD code that isn&#x27;t, but ignore that for now.) Even though the ArrayVec is variable-length, it&#x27;s still allocated on the stack, and pushes into it are guaranteed to panic rather than overrunning its stack footprint. The array pointers inside it are also length checked during construction by array_ref!() in the code below. (Which I would probably replace with standard .try_into() if I was refactoring this code today.)<br>
<p>
Another source of punctuation woes in Rust is lifetime annotations. I think it&#x27;s interesting to notice that we don&#x27;t see any of those here. The compiler doesn&#x27;t need any help to figure out that parents_array is scoped to the current function, so putting array pointers inside of it isn&#x27;t going to cause problems. But if we wanted to say return that array, we would need explicit lifetime annotations in the function signature in this case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864299/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2021 3:53 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/864464/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the end I don&#x27;t think I&#x27;d want it here because you are making several of them but rarely need the actual type, but arguably<br>
<p>
type Block = [u8; BLOCK_LEN];<br>
<p>
makes it clearer since that&#x27;s in fact what this is, and then:<br>
<p>
let mut parents_array = ArrayVec::&lt;&amp;Block, MAX_SIMD_DEGREE_OR_2&gt;::new();<br>
<p>
... feels like a pretty reasonable type, it&#x27;s an ArrayVec of references to Blocks, right you are. Const generics helped more though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor864468"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2021 13:11 UTC (Wed)
                               by <b>mkru</b> (guest, #153470)
                              [<a href="/Articles/864468/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am not a kernel developer, but I have written a few simple drivers. <br>
I am wondering whether adding Rust to the kernel is really the best approach for achieving memory safety.<br>
There is (maybe are?) other alternative solution that is not yet available, but is on the horizon and seems to be much more inline with the C and how OS&#x27;es are implemented.<br>
Namely, the CheriABI.<br>
<p>
Rust is relatively complex language, adding it to the kernel will greatly increase cognitive complexity.<br>
Imagine 2 alternative scenarios:<br>
1. C + compiler warnings + CheriABI + a larger number of potential reviewers.<br>
2. Rust.<br>
<p>
How many errors/vulnerabilities can 2 help to avoid comparing to 1?<br>
Is anyone able to estimate this?<br>
Is greatly increasing the complexity still worth?<br>
<p>
<a rel="nofollow" href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/">https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/</a><br>
<a rel="nofollow" href="https://dl.acm.org/doi/10.1145/3297858.3304042">https://dl.acm.org/doi/10.1145/3297858.3304042</a><br>
<a rel="nofollow" href="https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/20210507-dsbd-cheri-morello.pdf">https://www.cl.cam.ac.uk/research/security/ctsrd/pdfs/202...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864468/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864527"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2021 18:42 UTC (Wed)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/864527/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Remember that even once devices with CHERI support enter the market, there will remain a large installed base of non-CHERI devices that people want to run the Linux kernel on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864527/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor864550"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust for Linux redux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 29, 2021 5:18 UTC (Thu)
                               by <b>mkru</b> (guest, #153470)
                              [<a href="/Articles/864550/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Compiling for platforms with and without CheriABI still will be possible.<br>
The old hardware will be replaced by the new one, probably slowly, but still, it will.<br>
I guess you mean that people with older hardware want to be sure that they kernel is safe.<br>
As Linux is considering adding Rust as the second language, I guess someone has counted how many bugs it would help to avoid in the last X years.<br>
Does anyone know where such report is available?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/864550/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
