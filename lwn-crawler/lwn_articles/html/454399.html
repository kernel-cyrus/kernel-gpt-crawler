        <!DOCTYPE html>
        <html lang="en">
        <head><title>The Extensible Firmware Interface - an introduction [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/454399/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/454308/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/454399/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The Extensible Firmware Interface - an introduction</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we donâ€™t have to get good at marketing.
</blockquote>
<div class="GAByline">
           <p>August 9, 2011</p>
           <p>This article was contributed by Matthew Garrett</p>
           </div>
In the beginning was the BIOS.
<p>
Actually, that's not true. Depending on where you start from, there
was either some toggle switches used to enter enough code to start
booting from something useful, a ROM that dumped you straight into a
language interpreter or a ROM that was just barely capable of reading
a file from tape or disk and going on from there. CP/M was usually one
of the latter, jumping to media that contained some hardware-specific
code and a relatively hardware-agnostic OS. The hardware-specific code
handled receiving and sending data, resulting in it being called the
"Basic Input/Output System." BIOS was born.
<p>
When IBM designed the PC they made a decision that probably seemed
inconsequential at the time but would end up shaping the entire PC
industry. Rather than leaving the BIOS on the boot media, they tied it
to the initial bootstrapping code and put it in ROM. Within a couple
of years vendors were shipping machines with reverse engineered BIOS
reimplementations and the PC clone market had come into existence.
<p>
There's very little beauty associated with the BIOS, but what it had
in its favor was functional hardware abstraction. It was possible to
write a fairly functional operating system using only the interfaces
provided by the system and video BIOSes, which meant that vendors
could modify system components and still ship unmodified install
media. Prices nosedived and the PC became almost ubiquitous.
<p>
The BIOS grew along with all of this. Various arbitrary limits were
gradually removed or at least papered over. We gained interfaces for
telling us how much RAM the system had above 64MB. We gained support
for increasingly large drives. Network booting became possible. But
limits remained.
<p>
The one that eventually cemented the argument for moving away from the
traditional BIOS turned out
to be a very old problem. Hard drives still typically have 512 byte
sectors, and the MBR partition table used by BIOSes stores sectors in
32-bit variables. Partitions above 2TB? Not really happening. And
while in the past this would have been an excuse to standardize on
another BIOS extension, the world had changed. The legacy BIOS had
lasted for around 30 years without ever having a full
specification. The modern world wanted standards, compliance tests and
management capabilities. Something clearly had to be done.
<p>
And so for the want of a new partition table standard, EFI arrived in
the PC world.
<p>
<h4>Expedient Firmware Innovation</h4>

<p>

<div class="tlrw">
[1] Intel's other stated objection to Open Firmware was that it had
its own device tree which would have duplicated the ACPI device tree
that was going to be present in IA64 systems. One of the outcomes of
the OLPC project was an Open Firmware implementation that glued the
ACPI device tree into the Open Firmware one without anyone dying in
the process, while meanwhile EFI ended up allowing you to specify
devices in either the ACPI device tree or through a runtime enumerated
hardware path. The jokes would write themselves if they weren't too
busy crying.
<p>
[2] To be fair to Intel, choosing to have drivers be written in C
rather than Forth probably did make EFI more attractive to third party
developers than Open Firmware
</div>


Intel had at least 99 problems in 1998, and IA64 was certainly one of
them. IA64 was supposed to be a break from the PC compatible market,
and so it made sense for it to have a new firmware implementation. The
90s had already seen several attempts at producing cross-platform
legacy-free firmware designs with the most notable probably being the
ARC standard that appeared on various MIPS and Alpha platforms and
Open Firmware, common on PowerPC and SPARCs. ARC mandated the presence
of certain hardware components and lacked any real process for
extending the specification, so got passed over. Open Firmware was
more attractive but had a very limited third party developer
community[1], so the choice was made to start from scratch in the hope
that a third party developer community would be along
eventually[2]. This was the Intel Boot Initiative, something that
would eventually grow into EFI.
<p>
EFI is intended to fulfill the same role as the old PC BIOS. It's a
pile of code that initializes the hardware and then provides a
consistent and fairly abstracted view of the hardware to the
operating system. It's enough to get your bootloader running and, then, for
that bootloader to find the rest of your OS. It's a specification
that's 2,210 pages long and still depends on the additional 727 pages
of the ACPI spec and numerous ancillary EFI specs. It's a standard
for the future that doesn't understand surrogate pairs and so can
never implement full Unicode support. It has a scripting environment
that looks more like DOS than you'd have believed possible. It's built
on top of a platform-independent open source core that's already
something like three times the size of a typical BIOS source
tree. It's the future of getting anything to run on your PC. This is
its story.
<p>
<h4>Eminently Forgettable Irritant</h4>

<p>
<div class="tlrw">
[3] The latest versions of EFI allow for a pre-PEI phase that verifies
that the EFI code hasn't been modified. We heard you like layers.
<p>
[4] Those of you paying attention have probably noticed that the PEI
sounds awfully like a BIOS, EFI sounds awfully like an OS and
bootloaders sound awfully like applications. There's nothing standing
between EFI and EMACS except a C library and a port of readline. This
probably just goes to show something, but I'm sure I don't know what.
</div>

The theory behind EFI is simple. At the lowest level[3] is the Pre-EFI
Initialization (PEI) code, whose job it is to handle setting up the
low-level hardware such as the memory controller. As the entry point to 
the firmware, the PEI layer also handles the first stages of resume
from S3 sleep. PEI then transfers control to the Driver Execution
Environment (DXE) and plays no further part in the running system.
<p>
The DXE layer is what's mostly thought of as EFI. It's a hardware-agnostic
core capable of loading drivers from the Firmware Volume 
(effectively a filesystem in flash), providing a standardized set of
interfaces to everything that runs on top of it. From here it's a
short step to a bootloader and UI, and then you're off out of EFI and
you don't need to care any more[4].
<p>
The PEI is mostly uninteresting. It's the chipset-level secret sauce
that knows how to turn a system without working RAM into a system with
working RAM, which is a fine and worthy achievement but not typically
something an OS needs to care about. It'll bring your memory out of
self refresh and jump to the resume vector when you're coming out of
S3. Beyond that? It's an implementation detail. Let's ignore it.
<p>
The DXE is where things get interesting. This is the layer that
presents the interface embodied in the EFI specification. Devices with
bound drivers are represented by handles, and each handle may
implement any number of protocols. Protocols are uniquely identified
with a GUID. There's a <tt>LocateHandle()</tt> call that gives you a reference
to all handles that implement a given protocol, but how do you make
the <tt>LocateHandle()</tt> call in the first place?
<p>

This turns out to be far easier than it could be. Each EFI protocol is
represented by a table (ie, a structure) of data and function
pointers. There's a couple of special tables which represent boot
services (ie, calls that can be made while you're still in DXE) and
runtime services (ie, calls that can be made once you've transitioned
to the OS), and in turn these are contained within a global system
table. The system table is passed to the main function of any EFI
application, and walking it to find the boot services table then gives
a pointer to the <tt>LocateHandle()</tt> function.
Voil&agrave;.
<p>

So you're an EFI bootloader and you want to print something on the
screen. 
This is made even easier by the presence of basic console io
functions in the global EFI system table, avoiding the need to search
for an appropriate protocol. A "Hello World" function would look something
like this: 
<p>
<pre>
    #include &lt;efi.h&gt;
    #include &lt;efilib.h&gt;

    EFI_STATUS
    efi_main (EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
    {
        SIMPLE_TEXT_OUTPUT_INTERFACE *conout;

        conout = systab-&gt;ConOut;
        uefi_call_wrapper(conout-&gt;OutputString, 2, conout, L"Hello World!\n\r");

        return EFI_SUCCESS;
    }
</pre>
<p>
In comparison, graphics require slightly more effort:
<p>
<pre>
    #include &lt;efi.h&gt;
    #include &lt;efilib.h&gt;

    extern EFI_GUID GraphicsOutputProtocol;

    EFI_STATUS
    efi_main (EFI_HANDLE image, EFI_SYSTEM_TABLE *systab)
    {
        EFI_GRAPHICS_OUTPUT_PROTOCOL *gop;
	EFI_GRAPHICS_OUTPUT_MODE_INFORMATION *info;
	UINTN SizeOfInfo;

	uefi_call_wrapper(BS-&gt;LocateProtocol, 3, &amp;GraphicsOutputProtocol,
	                  NULL, &amp;gop);
	uefi_call_wrapper(gop-&gt;QueryMode, 4, gop, 0, &amp;SizeOfInfo, &amp;info);

	Print(L"Mode 0 is running at %dx%d\n", info-&gt;HorizontalResolution,
	      info-&gt;VerticalResolution);

	return 0;
    }
</pre>
<p>
<div class="tlr">

[5] Well, except that things are obviously more complicated. It's
possible for multiple device handles to implement a single protocol,
so you also need to work out whether you're speaking to the right
one. That can end up being trickier than you'd like it to be.
</div>


Here we've asked the firmware for the first instance of a device
implementing the Graphics Output Protocol. That gives us a table of
pointers to graphics related functionality, and we're free to call
them as we please.[5]

<p>
<h4>Extremely Frustrating Issues</h4>

<p>
So far it all sounds straightforward from the bootloader
perspective. But EFI is full of surprising complexity and frustrating
corner cases, and so (unsurprisingly) attempting to work on any of
this rapidly leads to confusion, anger and a hangover. We'll explore
more of the problems in the next part of this article.
<p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Externsible_firmware_interface">Externsible firmware interface</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Garrett_Matthew">Garrett, Matthew</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/454399/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor454615"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2011 5:40 UTC (Thu)
                               by <b>DeletedUser34808</b> ((unknown), #34808)
                              [<a href="/Articles/454615/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Where is this [5] for? Could not be located in the article.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454615/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454630"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2011 9:39 UTC (Thu)
                               by <b>dmk</b> (guest, #50141)
                              [<a href="/Articles/454630/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's to get the spirit of EFI into the article...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454630/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor454641"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">[5]</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2011 12:09 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/454641/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Sigh.  I actually caught that while preparing the article and got the answer from Matthew.  I put the footnote in the right place, but forgot to add the reference...one of those weeks.  It's there now, sorry for the confusion.
      
          <div class="CommentReplyButton">
            <form action="/Articles/454641/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor454636"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2011 12:09 UTC (Thu)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/454636/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder why it should be better to have a "higher level" boot-loader, i.e. something which should run on a (reduced) operating system, instead of "as near as bare-metal" boot-loader.<br>
<p>
Basically I see these problems:<br>
- If the BIOS is really setting a minimum OS, it needs to initialise all the managed devices (wait for SATA and USB enumeration to complete), work that needs to be completely forgotten and restarted by Linux a bit later (unless Linux trusts EFI descriptions - USB3 PCI card on USB2 aware EFI).<br>
- If booting from CDROM/DVD needs to still work, everything this minimum OS has initialised has to be undone, and the memory below 1 Mbyte has to be untouched.<br>
- If booting from removable (USB) device shall still be supported, you still have the problem to tell Linux from which device it has booted (multiple possible root file-system present)<br>
- If EFI analyses partitions, it limits the partition system that can be installed (removable devices)<br>
- If EFI analyses file-systems, it limits the file-systems that can be used (removable devices)<br>
- If EFI displays characters, it limits the fonts, font sizes and number of characters (UTF-8) that can be used.<br>
- If EFI does more than put an ethernet frame on the wire and get an ethernet frame from the wire, and can do TCP, it means a lot of information has to be exchanged in between EFI and Linux (IP address, DHCP data...)<br>
- EFI do not solve the problem that "the Linux kernel has been upgraded since last boot", so shall we boot the older kernel because it is a resume operation, or shall we boot the latest kernel because that is a full boot operation, or are we in recovery mode and should boot an older but known to work kernel?<br>
<p>
I am not sure that all those are improvement, compared to having a boot-loader on the first sector of one of the disk, boot-loader that can be upgraded by standard package management.<br>
OK, the "old BIOS" is not perfect and each version has some bugs, and it does not provide a standard way to put an ethernet frame on the wire (ethernet card no more have a FLASH memory for their own BIOS driver), and you can't know which keyboard region is installed, but being lower level it has proven to be quite flexible.<br>
<p>
Disclaimer: my pet project is the Gujin boot-loader.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454636/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454754"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2011 8:09 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/454754/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If the BIOS is really setting a minimum OS, it needs to initialise all the managed devices </font><br>
<p>
EFI is designed to initialize the minimum amount of hardware required to run the bootloader. Now I am not familiar enough with various hardware configurations to know if this will be faster than old BIOSes in *every* case but I am pretty sure it will be in most.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454754/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor455957"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 12:46 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/455957/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; - If EFI analyses partitions, it limits the partition system that can be installed (removable devices)</font><br>
<font class="QuotedText">&gt; - If EFI analyses file-systems, it limits the file-systems that can be used (removable devices)</font><br>
<p>
Could you elaborate on this? EFI relies on a dedicated partition; that should not put any limit on the other partitions.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455957/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455958"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 14:05 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/455958/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; EFI relies on a dedicated partition; that should not put any limit on the other partitions.</font><br>
<p>
It seems to me like obvious, if you want your Linux on the same disk as the EFI partition, they have to use the same partition system (standard MBR partition or GPT or even others).<br>
<p>
Also, because EFI needs its own partition, what happens in the context of multiple disks?<br>
- What if you have two disks with each an EFI partition, none of those disk being the primary disk (BIOS disk 0x80)?<br>
- What if those disks are software RAID-0?<br>
- What if those disks are RAID-1 and contains only half of the files?<br>
- What if each disk contains different Linux distribution and need to boot even if the other disk is not present (hard disk swapping bay)?<br>
- What if you have to use a special partition index to boot your USB thumb drive (BIOS restriction)?<br>
- What if one disk is extremely unreliable (hardware failure or partitions overlapping) and you want to try to recover its content by booting another clean distribution?<br>
- What if there were bugs in BIOS/EFI during the transition to 4 Kbytes per hardware sectors? Is the partition table in 512 bytes or 4096 bytes sector?<br>
- What if you have a 2048 bytes/sector disk (DVD-RAM) with Linux installed but there cannot be partitions (no partition supported by Linux on CD/DVD, just "superfloppy")?<br>
<p>
The problem is not simple with "the first sector of the first disk is loaded and executed at boot", but adding EFI seems to me like making it more complex. <br>
<p>
I have seen people using quite a few cold-swappable hard disks to boot multiple operating systems, to support real applications on different setup but the same PC. There is large Post-it notes on each disk...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455958/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455962"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 14:11 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/455962/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It seems to me like obvious, if you want your Linux on the same disk as the EFI partition, they have to use the same partition system (standard MBR partition or GPT or even others).</font><br>
<p>
And? Please give a sample use case which actually demonstrates a limitation.<br>
<p>
<p>
Concerning all the other points I got bored reading before I could find any problem new to EFI.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455962/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 14:56 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/455967/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Please give a sample use case which actually demonstrates a limitation.</font><br>
<p>
No partition table that EFI will understand?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455971"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 15:40 UTC (Mon)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/455971/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your EFI bootloader must always be in either an MBR or GPT partition.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455971/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor456009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 22:37 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/456009/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think this is exactly the limitation that etienne is trying to demonstrate.<br>
<p>
However I still do not really see how this is a limitation *in practice*.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/456009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor456049"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2011 9:56 UTC (Tue)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/456049/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However I still do not really see how this is a limitation *in practice*.</font><br>
<p>
Lets take a real life example: the situation right now is that the first sector of the first disk is loaded, after that the ROM BIOS hopes for the best after jumping to the first instruction of the MBR.<br>
The "first disk" is where the BIOS can be a bit configured, there is most of the time a boot menu where you can select what the "first disk" is, and if the first disk is not readable (disk broken or any other reason), then the next disk is tried.<br>
Something nobody planned 30 years ago happens: disk sector sizes are going to increase from 512 to 4096 bytes per sector.<br>
With current systems you hopefully will still have the first sector loaded (for any sector size one can imagine) and one can hope that at least the first 512 bytes are correctly loaded, and it should be sufficient for the bootloader to manage the situation (I tried to make that possible with Gujin, but cannot test because those disks are still under NDA).<br>
Now, I believe EFI will handle 512 and 4096 bytes/sector at the SATA interface, but in few years there may be something else - and because EFI is IHMO too "intelligent", to boot you will not just need to upgrade a package in your distribution, but you will need to upgrade your BIOS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/456049/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor456055"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2011 10:50 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/456055/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I miss how this is an answer to the previous question in the thread but anyway:<br>
<p>
<font class="QuotedText">&gt; ..., but you will need to upgrade your BIOS.</font><br>
<p>
And? I have actually solved real boot problems (USB-ZIP/FDD/HDD, PXE,...) by upgrading BIOSes, this is not a pie in the sky. Note that, from the vendor's perspective it will be much cheaper to develop an upgrade in C (EFI) as opposed to assembly (BIOS).<br>
<p>
If your PC is too old for maintenance then you will do what most people do in such cases: you will buy a new PC with an updated EFI/BIOS/whatever. Consider this very similar case: how many people actually try to shoehorn a brand new &amp; big SATA drive into an old &amp; slow pre-SATA PC? Practically none. <br>
<p>
Working on a Windows 7 PC right now I often envy Apple, am tired of backward-compatibility and wish it were much more often thrown out of the window...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/456055/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor456066"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2011 13:20 UTC (Tue)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/456066/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think we can agree to disagree on that one:<br>
- for me, if it is possible to do in hardware, Linux should try to support it in software (because we do not know what will be the future).<br>
- for you, if the number of people doing strange things is statistically insufficient, there is no point in trying to support it (because anyway we will have new PC including the evolution if it is good enough).<br>
<p>
I would agree with you saying the world would be a simpler place if we did not have all those "strange" configurations to support, if the users would use their computer and OS for what it was designed for.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/456066/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor454673"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PC ROM BIOS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2011 14:31 UTC (Thu)
                               by <b>dd9jn</b> (<b>&#x272D; supporter &#x272D;</b>, #4459)
                              [<a href="/Articles/454673/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The PC worked similar to IBM's "professional" /23.  Thus the reason for having the BIOS in the ROM was that the PC booted into a BASIC interpreter stored on ROM if no boot floppy was present. IIRC, there was even no automatically boot from the optional tape drive you could use on a floppyless box.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454673/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor454682"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2011 15:31 UTC (Thu)
                               by <b>jhhaller</b> (guest, #56103)
                              [<a href="/Articles/454682/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of the slowest things with BIOS is the multitude of BIOS plugins, each of which enumerates hardware, spins up drives, or adds a delay allowing the user to interact with that plugin. This includes things like RAID controller(s)and PXE Boot. On some server configurations, the BIOS takes longer to run than the OS boot.<br>
<p>
Does EFI make this any better, such as integrating all of the delays for individual device/capability setups into the main setup, or enumerating hardware in parallel? If you can work that back into a future article, that would be great.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454682/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454685"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2011 15:39 UTC (Thu)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/454685/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hardware enumeration's only done once. It'll typically be a matter of pulling a device tree out of ACPI, adding on any additional enumerated PCI or USB devices. Beyond that? I don't think the driver model handles parallel driver init, but haven't looked closely. Remember that we're talking about something that's closer to DOS than anything with a scheduler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454685/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2011 8:06 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/454753/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is something like a primitive scheduler in EFI. You can init the initialization of a device and come back later.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor454686"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2011 15:50 UTC (Thu)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/454686/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;On some server configurations, the BIOS takes longer to run than the OS boot.</font><br>
<p>
Not just server configurations. For about 3 years now all my Debian systems have taken around as long, if not longer, to get from power on-&gt;grub than from grub-&gt;login screen.<br>
<p>
Sometimes there are options you can disable to improve matters, eg my main desktop has two SATA controllers built in to the motherboard, one of which also does PATA. Disabling it means losing PATA and a couple of SATA ports, but saving about 10s from each boot. When grub-&gt;desktop takes ~40-50s, that's a lot. With an SSD grub-&gt;desktop is likely to be more like 20-30s, so it's even more significant.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454686/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2011 20:32 UTC (Sun)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/454948/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Check out the kexec-tools package, if you haven't already.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2011 17:58 UTC (Mon)
                               by <b>knobunc</b> (subscriber, #4678)
                              [<a href="/Articles/455058/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
kexec helps reduce reboot time, does it help with a cold boot?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor456052"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2011 10:22 UTC (Tue)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/456052/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If I may, I would like to say something about kexec.<br>
It is not to criticise kexec, that probably works perfectly, it is just about one use case: booting a different kernel release.<br>
<p>
Let's imagine yesterday kernel managing yesterday device.<br>
That yesterday device has some configuration bits labelled "do not touch", i.e. bits that you should write to the same value that you read them.<br>
Having "do not touch" bits in configuration words is a usual way to plan for extensibility, those bits are currently zero, but in future (backward compatible) version of the device they may have a meaning, like enabling the super-duper new function.<br>
So yesterday kernel behaves perfectly well, preserving the value of the "do not touch" bits, and obviously do not have the driver of the super-duper function.<br>
<p>
Back to today, I have currently booted the today kernel, which knows how to drive the super-duper function, and because it has recognised the more powerful today's device, it has enabled the super-duper function in the device by setting the previously "do not touch" bit (now enable super-duper function bit) to the device register.<br>
<p>
Now, if I kexec yesterday's kernel, it will not change the "do not touch" bit, but it does not have the super-duper function driver neither.<br>
I am not saying this pattern happens often, I am not saying the system will always misbehave, I am just saying there is a risk.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/456052/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor456053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2011 10:28 UTC (Tue)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/456053/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is a real risk, to be certain: but not in kexec itself; just in the tools that decide which kernel will be kexec'd when the shutdown command is issued.<br>
<p>
Debian's kexec-tools package for instance always boots /vmlinuz, which is a symlink maintained by the various linux-image-* packages and which usually points to the latest installed kernel. IMO this is a mistake, and kexec should attempt to boot into the currently installed kernel, if it still exists.<br>
<p>
This doesn't sound too hard--just look at the results of uname(2) and then look for a matching file in /boot. I think this would make your scenario less likely, however (at least in Debian's case) they only use a different filename for different kernel releases and ABI-changing updates to the same release, so the file /boot/vmlinux-3.0.0-1-amd64 that currently exists on my system may have been updated since the system booted with a file of the same name.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/456053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor454699"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2011 17:17 UTC (Thu)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/454699/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think the driver model does parallelism :) It's written using polled IO and is only supposed to be used for as long as you're explicitly driving some device.<br>
<p>
FWIW, I'm a huge fan of things like EFI. And layers aren't a problem if you don't have to care about the layer beneath. For example, on ARM systems, we are increasingly booting using EFI (a good thing) and sometimes even doing so in convoluted ways (x-loader-&gt;u-boot-&gt;tianocore) but it doesn't matter because the time taken to do these steps is minimal overall. I'm far more worried about layers of complexity being added in the desktop than in EFI, which is at least a cross-vendor, cross-platform standard we can all use.<br>
<p>
Jon.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454699/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454739"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2011 23:14 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/454739/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Of course, you don't have to care about the layers underneath as long as they are bug-free and do what you want.<br>
<p>
I'm sure that in future articles Matthew will assure us that EFI implementations are bug-free flawless jewels of perfect software engineering which work brilliantly on all operating systems, just as we would expect from the geniuses and wizards who work on BIOSes. (It's true: they do, as long as the set of operating systems consists of one single version of Windows on one single hardware configuration and it was only booted once during testing while holding a horseshoe and a rabbit's foot above the monitor.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454739/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor454845"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2011 0:54 UTC (Sat)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/454845/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On my desktop the BIOS takes longer than the Linux-based OS on my SSD. :-(<br>
<p>
I keep looking at the CoreBoot supported mainboards list, but it isn't on it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454845/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455620"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2011 21:20 UTC (Thu)
                               by <b>jd</b> (guest, #26381)
                              [<a href="/Articles/455620/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Check the source, rather than the website. They don't always link boards that are supported.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455620/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor454755"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2011 8:19 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/454755/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And so for the want of a new partition table standard, EFI arrived in the PC world. </font><br>
<p>
I think that is far from having been the only reason (maybe I just missed the smiley?)<br>
<p>
BIOS implementations are all proprietary assembly code. EFI is at least 95% open-source C.<br>
<p>
<font class="QuotedText">&gt; It's the chipset-level secret sauce that knows how to turn a system without working RAM into a system with working RAM, which is a fine and worthy achievement but not typically something an OS needs to care about.</font><br>
<p>
Note that initializing memory has become incredibly complex.<br>
<p>
<font class="QuotedText">&gt; [2] To be fair to Intel, choosing to have drivers be written in C rather than Forth probably did make EFI more attractive to third party developers than Open Firmware </font><br>
<p>
EFI also supports byte code applications and drivers for obvious portability reasons.<br>
<p>
<font class="QuotedText">&gt; There's nothing standing between EFI and EMACS except a C library and a port of readline. </font><br>
<p>
I think EFI cannot send email yet, but that will come eventually.<br>
<p>
<a href="http://catb.org/jargon/html/Z/Zawinskis-Law.html">http://catb.org/jargon/html/Z/Zawinskis-Law.html</a><br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454755/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2011 16:29 UTC (Wed)
                               by <b>xilun</b> (guest, #50638)
                              [<a href="/Articles/455302/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"EFI is at least 95% open-source C."<br>
<p>
The open source part (EDK/EDK2) does only contains very abstracted software infrastructure, arguably quite badly designed (e.g. you can see the hand of the psychopaths of MS putting GUID everywhere even and especially where it does not make any beginning of sense). I don't see why anybody would want to write programs for that environment.<br>
<p>
What could be interesting to take for something which has the actual intent of booting a computer, like coreboot+its various payloads, instead of merely providing an ms-dos like os where linking is done by guid and the whole thing is burned down on your motherboard, is not open source at all. Depending on the cpu and chipset vendor, there are not even public datasheet for booting your chips.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455313"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2011 16:43 UTC (Wed)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/455313/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are basically whining that EFI's core is not licensed under the GPL but BSD. This is correct.<br>
<p>
<font class="QuotedText">&gt; ... is not open source at all</font><br>
<p>
Still whining but plain wrong as anyone can see.<br>
<p>
<font class="QuotedText">&gt; Depending on the cpu and chipset vendor,...</font><br>
<p>
Usual and well-known consequence of a BSD license.<br>
<p>
<p>
PS: we miss your fair comparison with older BIOSes.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455313/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor455621"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2011 21:24 UTC (Thu)
                               by <b>jd</b> (guest, #26381)
                              [<a href="/Articles/455621/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OpenBIOS is a fairly decent open-source BIOS replacement. My biggest gripe with OpenBIOS is they dumped the Forth interpreter support. Very low level interfaces are exactly what you want for diagnostics, for example, where an OS would just get in the way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455621/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor454762"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2011 13:13 UTC (Fri)
                               by <b>njwhite</b> (subscriber, #51848)
                              [<a href="/Articles/454762/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How does this compare with coreboot?<br>
<p>
Coreboot always struck me (as a layman), like a nicely engineered system. Does it suffer from intractable BIOS issues enough that EFI is an improvement?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454762/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2011 15:33 UTC (Fri)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/454769/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That depends on what you're trying to achieve. At its most basic, Coreboot is a set of platform initialisation code. That corresponds to the PEI layer in an EFI image. Coreboot can then launch a bunch of different payloads, which include the ability to execute a kernel directly, boot a legacy BIOS (based on SeaBIOS) or even launch an EFI environment based on the Tiano Core release.<br>
<p>
If all you want to do is boot Linux then Coreboot definitely lets you achieve that with less overhead, and if vendors used it as the basis for the PEI layer we'd benefit from having the source to their setup code and could use that to identify bugs. But we'd still run into the common BIOS issue that vendors *will* introduce bugs, and we still need to work around them. Even if we have the source code and can rebuild the full BIOS image with a bugfix, having someone flash a third-party BIOS image would probably void the manufacturer warranty. So we're still at the mercy of the vendors in terms of bugfixes, and the open source nature of Coreboot doesn't benefit us hugely in that respect.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor454814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 12, 2011 20:11 UTC (Fri)
                               by <b>mturquette</b> (subscriber, #54268)
                              [<a href="/Articles/454814/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
RE: Footnote #4, "There's nothing standing between EFI and EMACS except a C library and a port of readline. This probably just goes to show something, but I'm sure I don't know what."<br>
<p>
It goes to show that we should jump to the Linux kernel much much earlier in the boot process.  Modern SoCs like TI's OMAP have a configuration header that you can append to your binary (Linux kernel) to skip the whole boot loader issue entirely.<br>
<p>
There have been real implementations of this on OMAP where the usual U-boot has been removed entirely; at power on ROM code parses the CH, then *boom* kernel decompression and party time.<br>
<p>
I know other platforms can do similar stuff, and I also know that x86 is a world away from ARM SoCs... but still I can't help but think that BIOS, EFI, OpenFirmware, etc are all starting to sound a bit archaic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454951"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2011 21:33 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/454951/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      I think it goes to show it would be simpler just to use Linux in place of DXE.
<p>
It doesn't have to be the same Linux that will ultimately run on the machine; just something to load the real OS.
<p>
That's probably naive, but what's the problem?  Is Linux too big?  Too slow?
<p>
Reflecting on the fact that one often has to get a new motherboard or at least risk an in-situ BIOS upgrade in order to boot from a new type of device, I've often thought that motherboards should be able to do one thing at boot time: read bytes from USB storage device plugged into a particular socket inside the box and branch to them.

<p>
I'd put a Linux boot image on there, configured to load and bring up the real system.  If I got a new kind of boot device, I'd just build a new Linux system with a driver for it and store it on that USB stick.  If I accidentally bricked the system that way, I'd just plug in a different USB stick and recover.

      
          <div class="CommentReplyButton">
            <form action="/Articles/454951/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2011 9:25 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/454967/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You favor USB but other people/platforms favor something else. Anything else.<br>
<p>
<font class="QuotedText">&gt; I think it goes to show it would be simpler just to use Linux in place of DXE.</font><br>
<p>
Isn't there any actual "LinuxBIOS" project out there?<br>
<p>
<font class="QuotedText">&gt; That's probably naive, but what's the problem? Is Linux too big? Too slow? </font><br>
<p>
Not in the right place at the right time? GPLed?<br>
<p>
Maybe a bit of all these.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2011 14:23 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/454999/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
You favor USB but other people/platforms favor something else. Anything else.
</blockquote>
<p>
It doesn't matter to me if it's USB, and I'm not aware of anyone proposing anything else.
<p>
The essential element of the concept is a separate removable storage device just for the bootloader.  I can't think of anything other than a USB memory stick that would be practical for that, but if there is something, I'm all for it.

      
          <div class="CommentReplyButton">
            <form action="/Articles/454999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455109"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2011 22:08 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/455109/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&lt;<a href="http://en.wikipedia.org/wiki/Serial_interface#Examples_of_serial_communication_architectures">http://en.wikipedia.org/wiki/Serial_interface#Examples_of...</a>&gt;<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455109/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455598"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 18, 2011 19:36 UTC (Thu)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/455598/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      I can't tell what point posting the URL listing lots of serial communication protocols is supposed to make.  Is this perhaps a response to my saying I don't know of anyone proposing a protocol other than USB for talking to a bootstrap-only device?  Has someone proposed some other serial communications protocol for that?  Is there one you would recommend?

      
          <div class="CommentReplyButton">
            <form action="/Articles/455598/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 12:41 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/455953/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A significant number of the interfaces in this list are used for booting. If you "simplify" your firmware design by hardcoding to any of these you will make users of the others unhappy.<br>
<p>
Granted, you can imagine dream and modular firmware code that can be selectively trimmed down on a per-platform basis. EFI might get there but why would you do this for (expensive) PC motherboards? A development effort to lose some of your customers?!<br>
<p>
By the way USB + managed flash is among the most expensive solutions; this matters for low cost embedded systems.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor456003"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 19:53 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/456003/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
A significant number of the interfaces in this list are used for booting. If you "simplify" your firmware design by hardcoding to any of these you will make users of the others unhappy.
</blockquote>
<p>
I think you're pointing out the dilemma of standardization.  You pick one of many paths in order to reap the benefits of uniformity, but at the cost of going down a path that isn't ideal for some, or even all, particular cases.  Of course, we standardize all the time and companies that were relying on the protocol that didn't get chosen suck it up and switch.
<p>

<blockquote>
A development effort to lose some of your customers?!
</blockquote>
<p>
Unless you're talking about losing customers because it costs more, you've misunderstood the proposal, because customers can still use all of those boot protocols -- the ROM loads from the USB device the bootloader that knows how to load Windows from a SATA drive.

<blockquote>
By the way USB + managed flash is among the most expensive solutions; this matters for low cost embedded systems.
</blockquote>
<p>
I agree my scheme is not appropriate for embedded systems.  It would add very little and cost a lot.

      
          <div class="CommentReplyButton">
            <form action="/Articles/456003/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor456008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 22:35 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/456008/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think you're pointing out the dilemma of standardization.</font><br>
<p>
Yes something like that.<br>
<p>
<font class="QuotedText">&gt; you've misunderstood the proposal, because customers can still use all of those boot protocols -- the ROM loads from the USB device the bootloader that knows how to load Windows from a SATA drive.</font><br>
<p>
I think I understood the proposal; it looks like we have different customers in mind. I am considering the "ROM loads from X" part while you are considering the "bootloader that knows..." part.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/456008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor455691"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 19, 2011 9:53 UTC (Fri)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/455691/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; read bytes from USB storage device plugged into a particular socket inside the box and branch to them</font><br>
<p>
Well, they have first to recognise that the USB disk first sector contains executable code, else they will often jump to a lot of zero instructions.<br>
How some do it is a little bit boring; in my experience with Gujin few BIOS will check that the Windows MBR is present by checking bytes at offset 0x0c to be identical to the Windows MBR ones.<br>
IHMO checking the first byte would be better (either jmp or cli) when the 0xAA55 signature is present.<br>
<p>
But what I wanted to say is that at the bootloader level you do not have USB, you have OHCI, UHCI, EHCI or xHCI - and more in the embedded world.<br>
The complexity for the boot sequence is that you may be on a BIOS/EFI which only handle a previous generation (only USB1 on USB2 hardware, only USB2 on USB3 PCIe card) so you know where (PCI address) is the device you are booting from, but in Linux this PCI address do not exists because the full USB chipset is supported.<br>
Handling these corner cases (as I tried in Gujin) is not really easy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455691/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455732"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 19, 2011 16:10 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/455732/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Well, they have first to recognise that the USB disk first sector contains executable code, else they will often jump to a lot of zero instructions.
</blockquote>
<p>
I think I'd prefer that it not do that check.  It's an opportunity for something to become incompatible.

<blockquote>
at the bootloader level you do not have USB, you have OHCI, UHCI, EHCI or xHCI - and more in the embedded world.
</blockquote>
<p>
But that is just between the bootstrap ROM and the USB host controller, both of which are permanently attached to the same piece of hardware in my scheme.  So there's no chance of incompatibility.
<p>
The standardness of USB that I'm interested in is between the host controller/hub and the USB stick, such that you can 1) easily get media; and 2) easily write the media using pretty much any computer.

      
          <div class="CommentReplyButton">
            <form action="/Articles/455732/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor455964"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 14:39 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/455964/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think I'd prefer that it not do that check. It's an opportunity for something to become incompatible. </font><br>
<p>
Well, they could have trusted that if the device contains a partition which is marked bootable, the device is itself bootable, but most BIOS manufacturer did not do so.<br>
I would say, checking that the beginning of the MBR is not completely blank is still acceptable, to allow someone to boot without removing all USB stick plugged-in - but checking Windows MBR assembly crosses the limit.<br>
<p>
Note that in your scheme, you still want to simply write you Linux kernel to the USB disk (and not do "cat kernel &gt; /dev/sdb") so you need a bootloader which will analyse the partitions and the filesystem inside it - so once the bootloader is running it still need access to the underlying device to access that file (using BIOS/EFI disk services), the BIOS/EFI still need to respond to USB interrupts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/455964/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor456004"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2011 20:13 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/456004/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
I would say, checking that the beginning of the MBR is not completely blank is still acceptable, to allow someone to boot without removing all USB stick plugged-in - but checking Windows MBR assembly crosses the limit.
</blockquote>
<p>
I think you've misunderstood what the ROM bootloader does in this scheme.  It is intentionally too dumb to choose a boot device.  It always loads the next stage from the same physical place (a particular USB socket inside the box).  The code loaded can use fancy intelligence that evolves with technology to choose a boot device from which to load the OS.
<blockquote>
Note that in your scheme, you still want to simply write your Linux kernel to the USB disk (and not do "cat kernel > /dev/sdb") so you need a bootloader which will analyse the partitions and the filesystem inside it - so once the bootloader is running it still need access to the underlying device to access that file
</blockquote>
<p>
I don't know what you're saying because there are at least 3 things that can be called "bootloader" here.  One is in ROM, one is in the first block of the USB first-level boot device, and one is the complete Linux system that resides on the first-level boot device.
<p>
The ROM boot loader doesn't know anything about partition tables or filesystems.  It knows how to read the first block of a USB storage volume, plugged into a socket/hub/controller permanently married to that ROM.  The contents of the USB volume is much like we once put on floppy disks: not "cat kernel >/dev/sdb", but "cat bootstrap loader2 kernel >/dev/sdb".  Maybe the volume actually has a partition table and the kernel thus loaded knows how to find filesystems on the volume.

      
          <div class="CommentReplyButton">
            <form action="/Articles/456004/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor456038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2011 9:36 UTC (Tue)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/456038/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think you've misunderstood what the ROM bootloader does in this scheme.</font><br>
<font class="QuotedText">&gt; It is intentionally too dumb to choose a boot device.</font><br>
<p>
I wish it worked that way in the real world.<br>
In real PC you buy today, the BIOS is doing a lot more than that, that is why people have so much problems booting off USB.<br>
After a lot of debugging Gujin, I can tell you that (for instance) the EEEPc 900 BIOS will not report it has an extended BIOS disk service interface if it detect the 0x29 signature at offset 38. Also, the "HP Compaq 8000 Elite" PC will crash if it is booted with a USB device which do not contains 0x1F 0xFC 0xBE signature at 0xB (the windows MBR opcodes).<br>
There is a reason why Grub has now the Windows MBR opcodes at its MBR beginning...<br>
Also, I do not know of a single BIOS which will not test the 0xAA55 signature at the end of the MBR, and I have found BIOSes which will only boot if there is only a single partition on the device, and it is the 4th one - else the ROM code decides (without meaningful message displayed) that the device is not bootable, and the next device has to be tried.<br>
(I think that was the test for ATAPI 100 Mbytes floppies).<br>
The BIOS should be dumb, but in practice it does look at the MBR content, and because "there is no more floppies" the only test case is: does Windows boot.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/456038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor456124"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface vs early Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2011 18:05 UTC (Tue)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/456124/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
The BIOS should be dumb, but in practice it [isn't].
</blockquote>
<p>
And in case it wasn't clear, this is exactly the point I opened the thread with, if BIOS means "the code fixed to the motherboard that boots the OS."
<P>
I would like to see that intelligence moved into a physically changeable, easily creatable storage device and suggest that a Linux system on a USB disk is the best choice for that.

      
          <div class="CommentReplyButton">
            <form action="/Articles/456124/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor454934"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2011 14:49 UTC (Sun)
                               by <b>Julie</b> (guest, #66693)
                              [<a href="/Articles/454934/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A clear, nicely digestible article. I'm looking forward to the follow-up :-)<br>
<p>
And the usual high-quality comments have plugged a few knowledge gaps, too. Thanks Matthew and everyone.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454934/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor454952"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 14, 2011 21:48 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/454952/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>So is EFI just bootstrap software?  If so, it deserves a better comparison to BIOS, because starting up the computer is just a small part of the BIOS concept.  What BIOS is about is providing a hardware abstraction layer, so CP/M could write to a disk drive of a model the authors of CP/M had never heard of.  That aspect of BIOS was obsoleted by microprocessors getting cheap enough that we could put one in every peripheral device.  Now the hardware abstraction layer is in the peripherals.
<p>
One thing is clear: EFI needs a better name - a descriptive one.  Extensible Firmware Interface sounds like a patent title.  "Firmware" isn't a set of function - it's just an implementation technology.

      
          <div class="CommentReplyButton">
            <form action="/Articles/454952/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454968"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 15, 2011 9:21 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/454968/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; One thing is clear: EFI needs a better name - a descriptive one. Extensible Firmware Interface sounds like a patent title. "Firmware" isn't a set of function - it's just an implementation technology.</font><br>
<p>
In theory "EFI" is just the interface. Its implementations are abusively called EFI as well. That's not unusual.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454968/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor456097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Extensible Firmware Interface - an introduction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2011 16:38 UTC (Tue)
                               by <b>landley</b> (guest, #6789)
                              [<a href="/Articles/456097/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IBM didn't make a "decision" about the BIOS.  They didn't even come up with the name, they copied it from CP/M which Gary Kildall split into the "BIOS" (basic input/output system) and "BDOS" (basic disk operating system) at the request of Imsai when they wanted it ported from the altair to their S/100 clone.  The split was explicitly to make porting to new hardware platforms easier.<br>
<p>
The PC was _designed_ as a 16 bit sequel to the CP/M boxes, the 8086 was a 16-bit upgrade to the 8080, the OS was a 16 bit port of CP/M (either CP/M itself from Digital Research or Tim Patterson's QDOS clone rebranded by Micro-dash-soft), the ISA bus was the S100 bus with unused wires removed (there was even an adapter to fit the big cards in the small slot, the voltage and timing of signals was all the same you just had to connect up the appropriate pins).  The PC had a BIOS so it could run CP/M (DOS 1.0 was a straight CP/M clone, then Paul Allen extended it by adding a bunch of Unix features during 2.0 as a transition path to Xenix.  Until he came down with Hodgkins Lymphoma in 1983, Microsoft's planned successor to DOS was Xenix.  Messing around with OS/2 and Windows happened after Paul Allen left and Gates started following blindly after IBM and Apple because Allen had been the ideas guy, Gates was always about cashing in on _other_ people's ideas.)<br>
<p>
So when Compaq cloned IBM's PC bios, it was not exactly a new idea.  Despite IBM's best efforts: that's what it was FOR.<br>
<p>
I mirrored an old geocities site on CP/M history way back when that covers some of this:<br>
<p>
  <a rel="nofollow" href="http://landley.net/history/mirror/cpm/history.html">http://landley.net/history/mirror/cpm/history.html</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/456097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
