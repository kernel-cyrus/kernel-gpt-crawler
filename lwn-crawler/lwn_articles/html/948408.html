        <!DOCTYPE html>
        <html lang="en">
        <head><title>Better string handling for the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/948408/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/948895/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/948408/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Better string handling for the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 26, 2023</br>
           </div>
The C programming language is replete with features that seemed like a good
idea at the time (and perhaps even were good ideas then) that have not aged
well.  Most would likely agree that string handling, and the use of
NUL-terminated strings, is one of those.  Kernel developers have, for
years, tried to improve the handling of strings in an attempt to slow the
flow of bugs and vulnerabilities that result from mistakes in that area.
Now there is an early discussion on the idea of moving away from
NUL-terminated strings in much of the kernel.
<p>
The biggest problem with NUL-terminated strings is that they carry no
information about the size of the buffer that contains them; that makes it
easy to create buffer overflows.  Over the years, a number of APIs have
been created in an attempt to address this problem, adding functions like
<a
href="https://man7.org/linux/man-pages/man3/strncpy.3p.html"><tt>strncpy()</tt></a>,
<a href="/Articles/612244/"><tt>strlcpy()</tt></a>, and <a
href="/Articles/643376/"><tt>strscpy()</tt></a>, each of which is claimed
to be better than its predecessors.  None of them change the core concept
of a NUL-terminated string, though, and none of them pleases everybody.
<p>
Over the years, the kernel has seen a long series of patches exchanging
calls from one set of string functions for another.  Sometimes those
conversions have introduced bugs of their own, and maintainers have not
always been happy with this work.  Recently, in response to <a
href="/ml/linux-kernel/20231018-strncpy-drivers-nvme-host-fabrics-c-v1-1-b6677df40a35@google.com/">a
patch</a> converting <tt>strncpy()</tt> calls to <tt>strscpy()</tt> in the
NVMe driver subsystem, Christoph Hellwig <a
href="/ml/ksummit-discuss/20231019054642.GF14346@lst.de/">questioned the
value</a> of these changes:
<p>
<blockquote class="bq">
	We need to stop pretending that direct manipulation of
	nul-terminated strings is a good idea.  I suspect the churn of
	replacing one helper with another, maybe slightly better, one
	probably introduces more bugs than it fixes.
</blockquote>
<p>
Truly solving the problem, he said, requires using something better than
NUL-terminated strings.  He described the "seq_buf" API as "<q>a good
start</q>" in this direction.
<p>
Seq_buf was <a href="https://git.kernel.org/linus/3a161d99c43c">introduced
in 2014</a> for the 3.19 kernel release as an improved way to build strings
in the tracing subsystem.  It is organized around this structure:
<p>
<pre>
    struct seq_buf {
	char			*buffer;
	size_t			size;
	size_t			len;
	loff_t			readpos;
    };
</pre>
<p>
There is nothing revolutionary here; <tt>buffer</tt> points to the memory
allocated by the string, and <tt>size</tt> is the size of that buffer.  The
length of the string stored in <tt>buffer</tt> is kept in <tt>len</tt>; the
<tt>readpos</tt> field is used for reading through a string.  The user must
allocate <tt>buffer</tt> separately and attach it to a <tt>seq_buf</tt>
with a call to:
<p>
<pre>
    void seq_buf_init(struct seq_buf *s, char *buf, unsigned int size);
</pre>
<p>
There is a
whole set of functions for working with this structure, most of which have
a fairly obvious purpose:
<p>
<pre>
    void seq_buf_clear(struct seq_buf *s);
    int seq_buf_printf(struct seq_buf *s, const char *fmt, ...);
    int seq_buf_puts(struct seq_buf *s, const char *str);
    /* ... */
</pre>
<p>
There are quite a few more; see <a
href="https://elixir.bootlin.com/linux/v6.6-rc6/source/include/linux/seq_buf.h"><tt>include/linux/seq_buf.h</tt></a>
for the full list.
<p>
Operations on a seq_buf are not allowed to overflow the given buffer;
should an attempt be made to store too much data, a note will be made of
the fact (<tt>len</tt> is set to a value greater than <tt>size</tt>) and
future operations will fail.  A call to <tt>seq_buf_has_overflowed()</tt>
will return a boolean telling whether a seq_buf is in a good condition or
not.  This API allows for a long series of string operations, with only a
single <tt>seq_buf_has_overflowed()</tt> check needed at the end to ensure
that all is well; that simplifies error-handling code significantly.
<p>
There is no accessor function to obtain the string itself; users can just
reach into the structure and use the <tt>buffer</tt> field directly.  That
string is maintained NUL-terminated, so it can be passed to functions
expecting such strings — though they should not modify the buffer directly,
of course.
<p>
The <tt>readpos</tt> field is only used within the tracing code.  As a way
of reducing the memory used by <tt>struct seq_buf</tt> in general, Matthew
Wilcox recently posted <a
href="/ml/linux-kernel/20231019194514.2115506-2-willy@infradead.org/">a
patch</a> removing that field and pushing the concept of a read
position into the code that uses it.  That patch <a
href="/ml/linux-kernel/20231019171439.1c50a16e@gandalf.local.home/">seems
likely</a> to be accepted, so <tt>readpos</tt> will probably not be a part
of this structure going forward.
<p>
Kent Overstreet recently posted an alternative to seq_buf, called "<a
href="/ml/linux-kernel/20220421234837.3629927-1-kent.overstreet@gmail.com/">printbuf</a>",
that takes a somewhat different approach.  In the discussion of that patch
set, he was <a href="/Articles/892611/">advised</a> to improve seq_buf
instead, a suggestion that he has declined to pursue.  So printbuf remains
outside of the kernel, but it does appear in linux-next as part of the
bcachefs series that (presumably) will be merged for 6.7.  Whether printbuf
will then be seen as an alternative to seq_buf is unclear, but the
community is unlikely to want to maintain two similar string abstractions
in the long term.
<p>
Will the kernel switch over to large-scale use of seq_buf (or printbuf) in
the long term?  It is hard to tell how far a conversion might go.  Kees
Cook <a
href="/ml/ksummit-discuss/202310182248.9E197FFD5@keescook/">said</a> that,
while seq_buf "<q>shines</q>" for complex string manipulation, it is more
trouble than it is worth for the simple cases, which can be easily verified
as correct in code using simpler APIs.  Willy Tarreau, though, <a
href="/ml/ksummit-discuss/ZTDUYSBS7AO9pAgm@1wt.eu/">said</a> that strings
with explicit length counters are easier to work with in general, lead to
simpler code, and can yield better performance as well.  Meanwhile, Linus
Torvalds, <a
href="/ml/ksummit-discuss/CAHk-=wj4BZei4JTiX9qsAwk8PEKnPrvkG5FU0i_HNkcDpy7NGQ@mail.gmail.com/">seemed
mostly interested</a> in getting rid of the remaining <tt>strlcpy()</tt>
calls in the kernel and has not expressed an opinion on changing the
kernel's handling of strings in general.
<p>
This conversation might encourage some developers to start using seq_buf in
place of NUL-terminated C strings.  Such a move is likely to start
relatively slowly, though.  If, over time, this approach starts to show
benefits, there may eventually be a push to do conversions on a wider
scale.  But, no matter how it goes, the kernel seems likely to be managing
a lot of NUL-terminated strings for a long time yet.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#String_processing">String processing</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/948408/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor948969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 19:44 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/948969/">Link</a>] (25 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is that in C it's just never going to be ergonomic to use `seq_buf` or something like it; such code will always be harder to read and write (especially for simple cases) than the string functions everyone knows. Rust and even C++ have a definite advantage here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor948984"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 21:41 UTC (Thu)
                               by <b>zaitseff</b> (subscriber, #851)
                              [<a href="/Articles/948984/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm sure far smarter minds than mine have already thought about this: should the kernel's string structures evolve to be exactly the same as Rust's, further facilitating the use of Rust in the kernel?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948984/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor948986"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 22:23 UTC (Thu)
                               by <b>nickodell</b> (subscriber, #125165)
                              [<a href="/Articles/948986/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's essentially what seq_buf is.<br>
<p>
From the Rust docs:<br>
<p>
<span class="QuotedText">&gt;A String is made up of three components: a pointer to some bytes, a length, and a capacity.</span><br>
<p>
The only difference between seq_buf and the structure being discussed is read_pos. If Matthew Wilcox's patch is accepted, the two will have essentially the same structure.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948986/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor948989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 22:40 UTC (Thu)
                               by <b>zaitseff</b> (subscriber, #851)
                              [<a href="/Articles/948989/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The only difference between seq_buf and the structure being discussed is read_pos. If Matthew Wilcox's patch is accepted, the two will have essentially the same structure.</span><br>
<p>
Just so.  But will it have the same in-memory structure layout?  Presumably so!<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 5:40 UTC (Fri)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/949005/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But will it have the same in-memory structure layout? </span><br>
<p>
If you just remove read_pos, the fields size and len are still reversed compared to the rust layout. In rust, len follows the pointer immediately in order to be compatible with the layout of &amp;str. This way, the cast from &amp;String to &amp;str is essentially a no-op.<br>
<p>
But I see no reason, why you cannot simply change the order in seq_buf.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 9:58 UTC (Fri)
                               by <b>njh</b> (subscriber, #4425)
                              [<a href="/Articles/949020/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think the Rust String type follows the seq_buf convention that the string representation is NULL terminated (for compatibility with non-modifying standard C string manipulation functions) though? So conflating the two structures, though they are highly similar, might be a mistake.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 14:14 UTC (Fri)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/949058/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As long as you're converting the pointer to the structure to a "&amp;String" instead of a "&amp;mut String", and the NUL is not counted in the length, there should be no issue since a "&amp;String" (without the "mut") cannot not be used to modify the structure or the contents of the string.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 17:03 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/949083/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>At that point, though, you're better off converting it to &amp;str instead of &amp;String - you can do everything that's possible with &amp;String with &amp;str (which is just start pointer and length). The only reason to want a String is to mutate the contents, which you can't do if it's &amp;String instead of &amp;mut String.



      
          <div class="CommentReplyButton">
            <form action="/Articles/949083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949095"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 18:04 UTC (Fri)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/949095/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, it almost never makes sense to have &amp;String in a function signature. This should always be &amp;str, as &amp;str is more general. But of course, you have String objects. If you take a reference from scuh an object, you have an &amp;String. And this &amp;String can then be coerced into &amp;str. This is what always happens if you have a String object and call a method that takes &amp;str. This is the cast that I talked about.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949095/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949101"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 18:32 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/949101/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>But in this case we're starting with a seq_buf, which should have its own representation in Rust (allowing us to implement seq_buf semantics), but also an implementation of Deref&lt;Target=str&gt; so that it can be treated as an &amp;str. If we could make it an &amp;mut String, not a &amp;String, then it'd be worth making seq_buf safely transmutable to String - but it's not, so it shouldn't be an &amp;String either.


      
          <div class="CommentReplyButton">
            <form action="/Articles/949101/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor949093"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 17:56 UTC (Fri)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/949093/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, rust String type does not have a NUL byte at the end. Of course it makes sense that seq_buf has. I just did not think of it, as the article does not mention. Should not be to hard to create a wrapper type that always adds the 0 after each manipulation on the rust side. And of course having capacity of the underlying vector always at least one more than the length of the string to have room for the 0.<br>
<p>
And there is another incompatibility in the other direction: seq_buf certainly does not have the semantics that it can only contain valid UTF-8.<br>
<p>
It would still be nice to have compatible types on both sides. This would allow for more easy interaction between both languages in the kernel. So we need a different type on the rust side. This has to include the capacity of the buffer for rust safety semantics.seq_buf looks similar enough that it should be possible to change seq_buf in such a way that a rust kernel string type can be compatible. This type is probably not String itself because of the NUL and more importantly because kernel has to accept non UTF-8 strings.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949093/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 19:10 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/949103/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, I can think of a few different ways to do this:<br>
<p>
* Vec&lt;u8&gt; (or Vec&lt;i8&gt;): Has a pointer, length, and capacity, and can hold arbitrary bytes. But not null-terminated, and (much less importantly) the length/capacity are in the wrong order. Also, if mutable, then the pointer can be deallocated and reallocated from the Rust side when trying to append extra bytes, which may be undesirable depending on how the allocation was created. You can make it immutable if that needs to be forbidden, but then it can't be modified in-place either, which might be an unwanted restriction.<br>
* [u8] or [i8]: Has a pointer and length, no capacity, and cannot be reallocated without making an explicit copy (but may be mutated in-place if mutable). Still no null termination invariant. Might be useful for providing "views" into the kernel's data, but probably less useful if you want Rust to create and consume these objects.<br>
* OsString/OsStr: Well, they are specifically designed for emulating regular C strings, which may or may not actually contain valid UTF-8, so at least this would make some logical sense? They also do appear to know their size and capacity. The documentation warns that the string may not be in the same encoding as the OS uses, but it looks like that's just a Windows thing, since the Unix implementation just does mem::transmute()[1] (which is almost equivalent to C++'s reinterpret_cast, but with different "rules" about exactly what you're allowed to do[2]).<br>
* Make your own struct with an extern "C" declaration: The most flexible option. You can impose whatever invariants you want on it from the Rust side, and you can impl various traits/methods (FromIterator, .iter(), etc.) to make it play nice with the rest of the Rust ecosystem. Downside is that you have to write some code, but probably not as much code as you're expecting, since I imagine that many of the more prosaic traits can just be #[derive()]'d.<br>
<p>
[1]: <a href="https://doc.rust-lang.org/src/std/os/unix/ffi/os_str.rs.html#61-70">https://doc.rust-lang.org/src/std/os/unix/ffi/os_str.rs.h...</a><br>
[2]: <a href="https://doc.rust-lang.org/nomicon/transmutes.html">https://doc.rust-lang.org/nomicon/transmutes.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949116"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 20:57 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/949116/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Correcting myself: mem::transmute is actually closer to bit_cast.[1] I was not aware that C++20 had added bit_cast.<br>
<p>
[1]: <a href="https://en.cppreference.com/w/cpp/numeric/bit_cast">https://en.cppreference.com/w/cpp/numeric/bit_cast</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949116/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor949125"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 22:19 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/949125/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; OsString/OsStr: Well, they are specifically designed for emulating regular C strings</span><br>
<p>
I don't think that's quite right - on Windows, OsString emulates LPWSTR (wchar_t* where sizeof(wchar_t)==2). It only emulates regular (non-wide) C strings on Linux. It's specifically designed to losslessly support the native strings of both OS APIs (for filenames, environment variables, etc), which are not really Unicode on either platform.<br>
<p>
std::ffi::CString/CStr look like the ones that are designed to emulate regular C strings.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949125/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949414"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 31, 2023 15:19 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/949414/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We're not on Windows (this whole article is about string handling deep in the guts of Linux), so I don't care about its nonsense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949414/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2023 10:30 UTC (Sat)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/950198/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is not specifically about Windows, it's about a Rust type representing a string that follow OS's string representation instead of it's own internal String. So using that type would probably make sense to represent Linux kernel string representations instead of trying to make the Linux kernel string representation and the native Rust string representation align.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor949197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2023 10:48 UTC (Mon)
                               by <b>epilys</b> (subscriber, #153643)
                              [<a href="/Articles/949197/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust does not have a stable ABI yet so no. In Rust you have you specify a struct will have a C memory layout with the #[repr(C)] attribute. You can read some information here<br>
<p>
<a href="https://doc.rust-lang.org/nomicon/ffi.html#interoperability-with-foreign-code">https://doc.rust-lang.org/nomicon/ffi.html#interoperabili...</a><br>
<p>
and <br>
<p>
<a href="https://doc.rust-lang.org/nomicon/other-reprs.html">https://doc.rust-lang.org/nomicon/other-reprs.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor949134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2023 4:24 UTC (Sat)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/949134/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;&gt;should the kernel's string structures evolve to be exactly the same as Rust's</span><br>
<span class="QuotedText">&gt;That's essentially what seq_buf is</span><br>
<span class="QuotedText">&gt;pointer to some bytes, a length, and a capacity.</span><br>
<p>
Neither Rust nor seq_buf are revolutionary; C++ std::strings (and possibly other languages' string implementations before it) had the {data, length, capacity} idiom practically for a really long time already.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2023 15:23 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/949143/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And yet, the much more fundamental C++ std::string_view (analogous to &amp;str, or at least &amp;[u8]) took until C++ 17.<br>
<p>
The result is that whereas Rust library code which needs some text just has parameters of type &amp;str, only the very modern C++ libraries dare ask for a string_view, as if you have any users who want C++ 14 or earlier that type doesn't exist for them.<br>
<p>
C++ also ended up welding on the C zero-termination rule. In practice the byte after your C++ std::string's actual text must be zero (tricks to avoid this backfire nastily). This means that Rust CompactString (a third party SSO type) fits more text into less space than any of the three popular C++ standard libraries, and as a result Mutex&lt;Option&lt;CompactString&gt;&gt; is a Rust type that's a mutex protected optional string with up to 24 bytes of inline text, in less memory than C++ alternatives need for their std::mutex alone.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2023 18:48 UTC (Sat)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/949151/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The result is that whereas Rust library code which needs some text just has parameters of type &amp;str, only the very modern C++ libraries dare ask for a string_view, as if you have any users who want C++ 14 or earlier that type doesn't exist for them.</span><br>
<p>
If one is OK with the spaghetti, `#if __cplusplus &gt;= …` checks can be used to hide interfaces from clients with older standards available. Well, at least for headers. Modules…probably not so lucky.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor949014"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 9:20 UTC (Fri)
                               by <b>dottedmag</b> (subscriber, #18590)
                              [<a href="/Articles/949014/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OTOH, C string handling is in the library (albeit widely known one), except the support for literals, and replacing one library with another is easier than replacing a built-in string type with a library.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949014/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor949028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 11:13 UTC (Fri)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/949028/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I keep wondering why the kernel even bothers with standard C.<br>
<p>
There's just so much work that seems to go into fighting the compiler.<br>
<p>
It's a big enough project that they could have a Qt style pre-processor to tackle on whatever features might be needed but can't be done elegantly with just what the compiler provides, or even have a special "kernel mode" added to GCC to provide all sorts of special conveniences.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 31, 2023 20:21 UTC (Tue)
                               by <b>jwarnica</b> (subscriber, #27492)
                              [<a href="/Articles/949454/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fighting with someone else's stupid is often easier than creating a new custom stupid to fight with all while maintaining the new stupid.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 2, 2023 14:08 UTC (Thu)
                               by <b>smoogen</b> (subscriber, #97)
                              [<a href="/Articles/949821/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You have made my quote of the week. thanks<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950966"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2023 23:13 UTC (Thu)
                               by <b>fest3er</b> (guest, #60379)
                              [<a href="/Articles/950966/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
XKCD covered this 12 years ago: <a rel="nofollow" href="https://imgs.xkcd.com/comics/standards.png">https://imgs.xkcd.com/comics/standards.png</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950966/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor949031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 11:23 UTC (Fri)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/949031/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C is not ergonomic with null-terminated strings either. The moment one starts to allocate string buffers one really longs for automatic destructors or a linear types.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor948971"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 19:56 UTC (Thu)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/948971/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This needs to be fixed in the language spec. It boggles my mind that there doesn't seem to an interest in solving this tire fire at the standards level.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948971/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor948975"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 20:52 UTC (Thu)
                               by <b>champtar</b> (subscriber, #128673)
                              [<a href="/Articles/948975/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The kernel can be compiled with pretty old versions of GCC, so agree on the new spec, have it ratified, have it implemented in GCC / Clang, wait a good 5 more years for your minimum supported version to support your new secure strings handling and you can start fixing the kernel, that's playing the long game :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948975/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor948977"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 20:54 UTC (Thu)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/948977/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The minimum compiler version is obviously a mutable value.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948977/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949822"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 2, 2023 14:10 UTC (Thu)
                               by <b>smoogen</b> (subscriber, #97)
                              [<a href="/Articles/949822/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A mutable version that has to be agreed by a number of different developers who have different needs. Even if Linus said 'I am only using X on this tree from now on', the linux-next and the various other tree admins would have to agree or there would be a long amount of 'Sorry Linus, you will just have to make the changes to make my patch work with your compiler set. I have to do this my way for my reasons'<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949822/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949823"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 2, 2023 14:16 UTC (Thu)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/949823/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would hope that the rust integration has proven that it's possible to require the use of a compiler more recent than the 90s to build the kernel without inciting a pitchfork yielding mob.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949823/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 2, 2023 15:46 UTC (Thu)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/949865/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I would hope that the rust integration has proven that it's possible to require the use of a compiler more recent than the 90s to build the kernel without inciting a pitchfork yielding mob.</span><br>
<p>
If you're going to attack a strawman, at least get your facts straight.<br>
<p>
Mainline Linux currently requires GCC 5.1 or newer -- and that was released in mid-2015, ie way more modern than "the 90s".   Specific (optional) features require more recent versions.  IIRC mainline linux has suppoted building with LLVM/Clang for a little while now, but I don't know what the requirements there happen to be.<br>
<p>
Meanwhile, Rust-on-Linux currently requires a fairly bleeding-edge Rust compiler; last I checked (which admittedly was a while back) the necessary features hadn't yet landed in a mainline LLVM release.<br>
<p>
Personally I think "wanting to use a &gt;8year old compiler" and "requiring use of the absolute latest [pre-]release of a compiler" are both unreasonable positions.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949903"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 2, 2023 18:13 UTC (Thu)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/949903/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why is requiring a current compiler release a major burden? If your building kernels you are probably either a kernel dev or a distro packager, both audiences that should be able to handle installing a compiler. Compiler updates are exceptionally common (and beneficial) in the go and rust ecosystems. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949903/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 2, 2023 19:07 UTC (Thu)
                               by <b>nevets</b> (subscriber, #11875)
                              [<a href="/Articles/949915/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a kernel maintainer, I have enough on my plate already than having to deal with constantly updating my compiler, and then wondering if the bug I'm debugging is caused by code I wrote, or due to a bug in the new compiler. Yes, compilers come with bugs too!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 2, 2023 19:26 UTC (Thu)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/949922/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, compilers have bugs. So reducing the number of supported compilers should actually make debugging easier.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 16:21 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/950099/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  Sure, compilers have bugs. So reducing the number of supported compilers should actually make debugging easier.</span><br>
<p>
Note that what's actually happening here is the reduction of the number of supported compilers to precisely *one*.<br>
<p>
Also, since Rust has a faster release cadence (~8wk) than Linux, this means that every single Linux kernel release will coincide with one (it not two) Rust compiler releases.<br>
<p>
That does not make debugging _easier_.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950105"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 16:40 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/950105/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a tempest in a teacup.<br>
Doing a kernel with Rust is all very new. Compare it to the Kernel in 1992.<br>
How many gcc choices did you have in 1992? Probably also only one: "What Linus had installed".<br>
<p>
But that doesn't mean it's somehow make the whole thing completely unstable. Rust is pretty mature, after all. Just not exactly in the additional parts that are required for kernel development.<br>
<p>
Yes, you currently need the tip of the compiler development for compiling the tip of the kernel development.<br>
That's how it is for now.<br>
But it is pretty clear that this is not going to stay like this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950105/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor950090"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 16:12 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/950090/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Why is requiring a current compiler release a major burden</span><br>
<p>
First, It's not "a current compiler", it's "the absolute latest version of a compiler." <br>
<p>
As an example, Rust-on-Linux 6.7 now requires Rust 1.73.0, which was released *less than a month ago*.<br>
<p>
This has all sorts of implications for stability.  What if you have five different kernel versions you're dealing with, each with their own Rust version requirement?   What's the backport policy going to be?  Let's say the 6.11 LTS kernel relies on Rust 1.81, but a fix is introduced in the 6.13 kernel, which requires Rust 1.83.  Will backporting a fix bump the 6.11 requirement up to 1.83?  Etc.<br>
<p>
<span class="QuotedText">&gt; Compiler updates are exceptionally common (and beneficial) in the go and rust ecosystems. </span><br>
<p>
It's not common/beneficial so much as *necessary*, because the underlying platforms are still relatively immature and rapidly evolving, making it effectively impossible to stick with an older version.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950090/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950424"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2023 15:45 UTC (Mon)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/950424/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust code that compiles on older compilers still compiles on newer compilers. Rust tries very hard to stay backwards compatible with old code. So in practice you would just need the 1.83 compiler in your example unless you are specifically testing for breakage with an old compiler and for that it is easy to install an older version with rustup.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950424/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2023 16:14 UTC (Mon)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/950448/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Rust tries for backward compatibility but, as I understand it, that compatibility may not be there for the kernel.  The Rust-for-Linux code is using a <i>lot</i> of unstable features; as those are stabilized (assuming they are) they may well evolve.  As a result, the kernel is likely to require a specific Rust version for some time. 



      
          <div class="CommentReplyButton">
            <form action="/Articles/950448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor948987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 22:37 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/948987/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Strictly speaking, you don't need language support for this. I mean, it would definitely be *nice* to have string literals turn into const struct seq_buf * instead of const char *, but you can do that by hand if you really want to. The rest is simply a matter of having the library functions for it, and library functions need not be standardized.<br>
<p>
(Obviously, it would be preferable to have a sensible string manipulation library in libc, but you could say that about a lot of other data structures that are also not supported by libc.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor948997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 3:31 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/948997/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I mean, it would definitely be *nice* to have string literals turn into const struct seq_buf * instead of const char *, but you can do that by hand if you really want to.</span><br>
<p>
That's exactly what I'm doing in haproxy already, as shown in the linked comment above. When I write:<br>
<p>
	if (isteq(name, ist("host")))<br>
		return 1;<br>
<p>
What it does is create a "struct ist" (which is just a register pair) with {pointer,length} for literal "host", and passes that pair to isteq() to compare against &lt;name&gt; which is also a register pair. It's not trivial to come up with a convenient API as the way to use it changes a bit from C strings, but with a bit of practice and intuition it's not bad at all.<br>
<p>
When you start using that, you progressively get to using it more and more and it quickly becomes convenient, and you quickly figure how much time you usually spend looking for that trailing NUL with default C strings! Also, I purposely decided to have static inline functions with trivial loops that the compiler can often figure out itself, and a lot of that code gets replaced by constants or simpler operations when the info is available at the call place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor948995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 1:01 UTC (Fri)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/948995/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That’s C for you.  The standards committee has very little interest in adding new features no matter how long there’s been an obvious problem, and even GCC rarely adds new extensions these days.  (Clang is a little bit more extension-happy but not much.)<br>
<p>
Meanwhile, C++ has finally solved this as of C++20 [1].  Characteristically, its solution is highly flexible (it’s really the ability to perform arbitrary processing of strings at compile time), but bogs down compile time, is strangely complicated, and relies on too many features to be a good reference point for a hypothetical C equivalent.<br>
<p>
[1] <a href="https://stackoverflow.com/a/68790828">https://stackoverflow.com/a/68790828</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949001"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 4:31 UTC (Fri)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/949001/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;That’s C for you. The standards committee has very little interest in adding new features no matter how long there’s been an obvious problem,</span><br>
<p>
Perhaps that was one true, but consider for example a recent CppCast interview with JeanHeyd Meneide:<br>
<p>
<a href="https://cppcast.com/jeanheyd-defer/">https://cppcast.com/jeanheyd-defer/</a><br>
<p>
Most of the features discussed in the interview like a scope-guard for C were not adopted, but the Standards Committee, on which Meneide sits, is decidedly interested in them.   Meneide's blog<br>
<p>
<a href="https://thephd.dev/">https://thephd.dev/</a><br>
<p>
often comments on C-standard activities in an engaging, take-no-prisoners style.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949001/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949022"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 10:29 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/949022/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>If you read JeanHeyd Meneide's social media output, and blog posts like <a href="https://thephd.dev/finally-embed-in-c23">finally. #embed</a>, you'll notice a theme; there's a small subset of the C committee who are genuinely interested in making C a better language, and a large mass who oppose any changes in a relatively toxic manner (when compared to the C++ committee).
<p>The trouble with C having stagnated from C90 to C99 and then to C11, and then having 6 year gaps between standards, is that it's accrued a whole cluster of people who don't want it to change - they think that C90 was an optimal language, and that the changes since then have been bad for the language. And that's a big inertia to overcome.


      
          <div class="CommentReplyButton">
            <form action="/Articles/949022/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2023 17:55 UTC (Sat)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/949148/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it's probably more related to there being 100s of C implementations and 4 C++ implementations. There used to be more, but with C++11 (and especially C++17) more and more in-house compilers seem to be rebasing their frontends on top of Clang instead of doing work themselves. XLC (IBM), OneAPI (Intel), Cray, Fujitsu, and probably more.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2023 8:57 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/949167/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I would say that the C implementation teams think C is optimal - as a language for them to implement as-is, not as a language to write code in. And they don't want changes, because then it would be sub-optimal for them (harder to keep up with the latest standard, customers asking why you don't support the last-but-one standard version).


      
          <div class="CommentReplyButton">
            <form action="/Articles/949167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor949196"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2023 7:34 UTC (Mon)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/949196/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><i>being 100s of C implementations and 4 C++ implementations</i></blockquote>
<p>
Not surprising, given the insane complexity of the modern C++ language. I expect a few years from now there will be just GCC and CLANG, and all the rest are derivatives of these. I recall reading already 20 years ago one C guru noting he has written several C compilers on his own, but thought making a C++ compiler was beyond what one person can do.


      
          <div class="CommentReplyButton">
            <form action="/Articles/949196/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2023 12:24 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/949201/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I expect a few years from now there will be just GCC and CLANG, and all the rest are derivatives of these.</span><br>
<p>
I can see 3, but even that would to be a stretch in my mind. There is significant investment into MSVC and getting all of the backwards compatibility quirks that need to be supported into Clang seems…unlikely given how much of a research project that would be to reach the desired compatibility levels. Visual Studio is also a large portion of the overall C++ "market" (e.g., its project files is reported to be second only to CMake in what is used to build projects and these are most likely MSVC-only projects) and Intellisense uses EDG under the hood.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor949924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 2, 2023 19:30 UTC (Thu)
                               by <b>Kamilion</b> (subscriber, #42576)
                              [<a href="/Articles/949924/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
... and the only reason GCC will still exist will be due to the fact that there are still GNU extensions only it will support, meanwhile everyone else dogpiled on clang/llvm where you don't have to fight a whole mailing list with a minus sign, two parenthesis, some equals signs and a less than.<br>
<p>
-)(====&gt;<br>
<p>
(You now have listp.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor949024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 11:36 UTC (Fri)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/949024/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; This needs to be fixed in the language spec. It boggles my mind that there doesn't seem to an interest in solving this tire fire at the standards level.</span><br>
<p>
There is an interest from some committee members (at least there was in the past), but it usually takes effort to converge to a particular approach.<br>
<p>
Personally, I would like to have slice and string types similar to those from Rust's and C++'s, especially if they make interop with those languages easier.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor948981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 21:15 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/948981/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's worth looking at how "struct strbuf" is used in the implementation of git as an example of what it would look like if this was used pretty much everywhere.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor948998"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 3:34 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/948998/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's a good idea. I remember noticing in the past that the git source code was pretty much straight forward to read in part thanks to its string processing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948998/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor948982"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 21:21 UTC (Thu)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/948982/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      The problem with C string handling is that it's just too low-level and thus, too complicated to use. As an example, the following code concatenates two strings to form a directory name, separating them with a / when necessary:

<pre>
x = strlen(tar_cmd[X_DIR]);
slash = tar_cmd[X_DIR][x - 1] != '/';
x += slash;
x += sizeof(HCA_PATH);
dir = alloca(x);
p = stpcpy(dir, tar_cmd[X_DIR]);
if (slash) *p++ = '/';
memcpy(p, HCA_PATH, sizeof(HCA_PATH));
</pre>

This needs to do three different things: Calculate the size of the combined string, allocate a buffer for it and copy the data into the buffer in the right way. That's equivalent to the following (untested) Perl code:

<pre>
$path = $prefix;
$path .= '/' unless substr($prefix, -1) eq '/';
$path .= SUFFIX;
</pre>

which is only about ⅓ of the equivalent C-code. 



      
          <div class="CommentReplyButton">
            <form action="/Articles/948982/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor948985"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 22:23 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/948985/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>That's approximately:</p>
<pre>
struct strbuf path = STRBUF_INIT;
strbuf_addstr(&amp;path, prefix);
if (path.buf[path.len - 1] != '/')
        strbuf_addch(&amp;path, '/');
strbuf_addstr(&amp;path, suffix);
</pre>
<p>using the library in git that's similar to what's proposed for the kernel.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/948985/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor948991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 23:53 UTC (Thu)
                               by <b>gutschke</b> (subscriber, #27910)
                              [<a href="/Articles/948991/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>For my own code, I always felt that seeking inspiration from <code>sprintf()</code> is the best way to produce less error prone and more readable code, if I need to stay within the confines of the C language and can't make use of C++ features.</p>

<p>Since path-handling is somewhat common in the kernel, I'd probably go beyond just standard format characters though. If I had to design this code, I'd introduce extra flag values for dealing with things like trailing slashes. For the purposes of this example, let's assume I picked <code>'/'</code> as a flag for trailing slash unless already present in that location; let's further assume I picked upper-case <code>'S'</code> as a conversion specifier for <code>struct strbuf</code>:</p>

<pre>struct strbuf path = STRBUF_INIT;
strbuf_fancy_printf(&amp;path, "%/S%S", prefix, suffix)</pre>

<p>This results in much more compact code that conveys the intention much more concisely. It also allows for more static checking. The downside is that for the time being, this type of checking cannot be done by gcc/clang, as we are using non-standard format characters. That's a real problem, as it can introduce security-relevant bugs. But it would hopefully be a relatively minor change to the compilers to make format-string-testing extensible. In the mean-time, a bespoke static analysis tool could fill the the gap.</p>

<p>Also, there is a performance penalty, however minor, for moving string handling from the traditional C-style string methods to more dynamic approaches. Once compilers knew about this new feature, it wouldn't be unreasonable to see optimizer passes that know how to parse format strings and turn them into direct invocations of internal <code>strbuf</code> functions. This could even be done by a pre-processor.</p>

<p>And that opens up a whole new range of options. If the kernel used a custom-built preprocessor while waiting for the C compiler to maybe add support for these features, then we are no longer constraint by legacy language constraints. Technically, that's not a big complication. Politically, it is a much bigger discussion. But if hypothetically, there was agreement for going down this route, then there are much more readable solutions that also work better with static checking. The first thing that would spring to mind would be to seek inspiration from Python's f-strings.</p>





      
          <div class="CommentReplyButton">
            <form action="/Articles/948991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949190"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Use snprintf instead of sprintf</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2023 21:15 UTC (Sun)
                               by <b>jreiser</b> (subscriber, #11027)
                              [<a href="/Articles/949190/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <tt>sprintf</tt> is a poor choice because it offers no protection against exceeding buffer length.  Always use <tt>snprintf</tt> (with correct buffer length) instead.


      
          <div class="CommentReplyButton">
            <form action="/Articles/949190/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949192"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Use snprintf instead of sprintf</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2023 21:29 UTC (Sun)
                               by <b>gutschke</b> (subscriber, #27910)
                              [<a href="/Articles/949192/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No snprintf() needed here, as the function takes care of handling dynamic memory allocation. That's the original motivation for using buffer objects. So, unlike the old school C version, by switching to a more modern representation of strings, we completely eliminate that class of bugs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949192/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor949026"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 11:01 UTC (Fri)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/949026/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Note - if <tt>prefix</tt> is an empty string, <tt>path.buf[path.len - 1]</tt> will read before the start of the buffer.</p>

<p>You still need to be careful to use it safely. That's not to say that <tt>strbuf</tt> isn't an improvement; it clearly is. But you still can't assume it's impossible to get badly wrong.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/949026/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949191"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2023 21:15 UTC (Sun)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/949191/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The code from the original example will only ever run when the string is not empty. Even if this was otherwise, it wouldn't matter: The string is a user-provided (via environment variable) directory suppoed to be used instead of a default one. Users are free to provide nonsense input (like an empty string) but then, the program simply won't work aka "the behaviour is undefined" --- if you break it, you get to keep the parts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949191/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor948990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2023 23:22 UTC (Thu)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/948990/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
typedef struct ctText_rec {<br>
<p>
    uint64_t  maxLen;  // Defined to be bufferSize - 1.<br>
    ctCharPtr buffer;<br>
    uint64_t  len;<br>
    ctText    next;<br>
    bool ok;<br>
    bool overflow;<br>
    bool nullUse;<br>
    bool closed;<br>
    bool ownsSelf;<br>
    bool ownsBuffer;<br>
    bool f7,f8;<br>
<p>
} ctText_rec;<br>
<p>
Functions maintain both len and zero termination.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/948990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor949002"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 4:58 UTC (Fri)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/949002/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A saner string implementation where the length of a string is not defined by an inlined '\0' but by an explicit length is no problem in userspace...<br>
<p>
But it gets ugly and you lose performance as soon as you need to use the syscalls api which uses zero-terminated strings.<br>
<p>
Furthermore, maintaining an invisible '\0' doesn't work at all for slices - you might need to temporarily modify an otherwise readonly buffer or even copy the string into a new buffer just to pass a slice to a syscall. And for returned strings you need to do redundant strlen()...<br>
<p>
And that userspace can work with '\0' in the middle of a string but a kernel api ignores everything after the first '\0' might result in unexpected behavior.<br>
<p>
TLDR: I request new api variants for all syscalls with sane strings not only in direct arguments but also in referenced structures. :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949002/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949006"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 7:28 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/949006/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  Furthermore, maintaining an invisible '\0' doesn't work at all for slices - you might need to temporarily modify an otherwise readonly buffer</span><br>
<span class="QuotedText">&gt;  or even copy the string into a new buffer just to pass a slice to a syscall. And for returned strings you need to do redundant strlen()...</span><br>
<p>
It works well specifically for composing strings, which are potentially passed to C libs. Doesn't cost much performance to add a zero at the end of a string with known length, after any edit operation. And composing is where protection from overflows and NULL parameters is important. <br>
<p>
Parsing externally received strings or partial strings in buffers as a read operation is a different matter. Very situational. However a guaranteed termination is an advantage, I'd say, whenever it is an option.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949006/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949011"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 8:59 UTC (Fri)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/949011/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; &gt;  Furthermore, maintaining an invisible '\0' doesn't work at all for slices - you might need to temporarily modify an otherwise readonly buffer or even copy the string into a new buffer just to pass a slice to a syscall. And for returned strings you need to do redundant strlen()...</span><br>
<p>
<span class="QuotedText">&gt; It works well specifically for composing strings, which are potentially passed to C libs. Doesn't cost much performance to add a zero at the end of a string with known length, after any edit operation.</span><br>
<p>
Yes, its okay most of the time, but still unnecessary code which only exist because of the needs of the Posix interfaces further down the stack. And sometimes it is worse. For example, if you want to implement dirname() for sane strings, you'd need to malloc a new buffer and copy the directory part of the string.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949011/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 9:26 UTC (Fri)
                               by <b>gioele</b> (subscriber, #61675)
                              [<a href="/Articles/949013/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  Yes, its okay most of the time, but still unnecessary code which only exist because of the needs of the Posix interfaces further down the stack. And sometimes it is worse. For example, if you want to implement dirname() for sane strings, you'd need to malloc a new buffer and copy the directory part of the string.</span><br>
<p>
If you implement dirname() as a view on a string, you have to keep the original string with the full path around as long as you reference the directory name. But dirname will be faster and use fewer resources.<br>
<p>
If you malloc a new buffer and copy the derived directory name there, you do not have to keep track of the original string and you can free() the two strings independently. But dirname will be slower, will consume more memory and increase fragmentation.<br>
<p>
It's a common no-free-lunch+it-depends situation in which no solution is better than the other in all cases. In some cases a view is to be preferred, in other cases a separate buffer is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 10:19 UTC (Fri)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/949015/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If you implement dirname() as a view on a string, you have to keep the original string with the full path around as long as you reference the directory name. But dirname will be faster and use fewer resources.</span><br>
<p>
I think I didn't make my point clear or you missed the context. That wasn't about lifetime, it was about the cost of maintaining an extra '\0' for strings with explicit known size, just for the ability to pass them to a Posix interfaces which expects a zero-terminated string.<br>
<p>
For example, if you use something like `typedef struct {size_t len; char *data;} string;` and want to implement `string dirname(string path)`. For the non-edge cases, you could just return a slice/substring pointing directly to the character buffer of `path`. But in that case, the returned string data would not be zero terminated and its `data` pointer couldn't just be passed to thinks like lstat().  If you really want to maintain a '\0' after each string, you'd either need to return a string with a separately allocated character buffer or take ownership of the original string and modify its character buffer to overwrite a '/' with a '\0' (which, of course, doesn't work for a read-only buffer). Or you need to do something more complex like maintaining more state in you string object, like the thing with 6 flags further up the comment thread.<br>
<p>
Unless you have a `lstat(string pathname, struct stat *restrict statbuf);` system call, which I jokingly requested. In that case you just wouldn't need an extra '\0' after the string.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor949018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 9:51 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/949018/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;Yes, its okay most of the time, but still unnecessary code which only exist because of the needs of the</span><br>
<span class="QuotedText">&gt;Posix interfaces further down the stack.</span><br>
<p>
For the kernel it's irrelevant what Posix specifies.<br>
If the kernel communicates with anything that comes from or goes to Posix interfaces, it needs to copy it across the kernel/user boundary anyway and \0 handling can happen at the same time.<br>
The rest of the kernel could use a sane string data structure without \0.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor951547"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2023 20:45 UTC (Wed)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/951547/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One trick I've seen to reduce memory allocations is to have the capacity be at the end of the char data, when it falls to zero, you have NULL termination.  If there's unused capacity then the str can be NULL terminated.<br>
For the strlen the bytes before the str are used, so there's an offset to the traditional str.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951547/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor949010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 8:25 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/949010/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One thing missing from this is automatic growth/shrinking of the underlying buffer.<br>
<p>
It might be tricky for the kernel, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949017"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 9:43 UTC (Fri)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/949017/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just embed gfp_t into "struct kstring" and don't shrink.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949017/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 17:00 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/949084/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Then you would also have to disallow direct access to the buffer/string pointer. Otherwise very hard to track down use-after-free bugs are basically unavoidable.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor949035"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2023 13:08 UTC (Fri)
                               by <b>jemarch</b> (subscriber, #116773)
                              [<a href="/Articles/949035/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Allocate p = malloc (sizeof (size_t) + LENGTH + 1), store the size of the string before the bytes and trailing NULL and give the user p + sizeof (size_t).  That should work well enough for both checked and non-checked string operations 8-)<br>
<p>
If you would reserve a particular range of kernel addresses for checked strings (or even for "sized" memory objects in general) in your memory allocator then you would be able to distinguish between "regular" pointers and "enriched" pointers.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949035/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949137"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2023 8:11 UTC (Sat)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/949137/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Allocate p = malloc (sizeof (size_t) + LENGTH + 1), store the size of the string before the bytes and trailing NULL and give the user p + sizeof (size_t). </span><br>
<p>
If all you string objects are malloced and you are using glibc on Linux userspace, you could also use the non-portable malloc_usable_size() for the capacity. <br>
<p>
The function can't be inlined, though. OTOH your object becomes shorter and you might save a few memcpy if your buffer expands dynamically, because it already is larger then requested size most of the time. Benchmarks would be interesting, but I guess it depends a lot on the use case and malloc_usable_size() would be slower most of the time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949137/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor949142"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2023 15:32 UTC (Sat)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/949142/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, I noticed that my comment didn't really fit your proposal with the string length (not the capacity) stored inline before the actual string data, not in a string descriptor object. Confused it with other comments.<br>
<p>
Addendum to using  malloc_usable_size() to access the capacity of a malloced string buffer to avoid storing the capacity separately: Alternatively realloc() could be used whenever capacity is needed, because realloc() has access to the internal capacity (often bigger than requested) and will avoid unneeded copy operations by itself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949142/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor949180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2023 18:11 UTC (Sun)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/949180/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps we can borrow some ideas from EPOC/Symbian string descriptors?<br>
<p>
(or not: I don't remember much from my faint interactions with strings on Symbian)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor950967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better string handling for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2023 23:40 UTC (Thu)
                               by <b>teh_plague</b> (guest, #95344)
                              [<a href="/Articles/950967/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, given the indirection introduced by seq_buf, I think someone might want to provide zero-copy move-level semantics for it in the future. And what about passing strings to/from userspace? Certainly, one would not want to expose seq_buf to userspace code without breaking ABI compatibility, or would they?<br>
And when dealing with seq_buf you are now forced to ensure that both pointers are accessible at the same time. Additionally, the use of two separate data structures to handle a string might introduce data locality issues.<br>
<p>
I doubt that there is great pressure to change string handling in the kernel on a large scale.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
