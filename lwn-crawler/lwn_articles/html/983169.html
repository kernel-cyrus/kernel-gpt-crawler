        <!DOCTYPE html>
        <html lang="en">
        <head><title>May the FOLL_FORCE not be with you [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/983169/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/983268/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/983169/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>May the FOLL_FORCE not be with you</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>July 26, 2024</br>
           </div>
One of the simplest hardening concepts to understand is that memory should
never be both writable and executable, otherwise an attacker can use it to
load and run arbitrary code.  That rule is generally followed in Linux
systems, but there is a glaring loophole that is exploitable from user
space to inject code into a running process.  Attackers have duly exploited
it.  A new effort to close the hole ran into trouble early in the merge
window, but a solution may yet be found in time for the 6.11 kernel
release.
<p>
The special file <tt>/proc/<i>PID</i>/mem</tt> provides read and write
access to the virtual address space of the process identified by
<tt><i>PID</i></tt>.  It is used primarily by debuggers, but it has a place
in other applications (certain types of user-space hardening, for example)
as well.  Writing to this file will overwrite the process's memory at the
current file offset.  Interestingly, the kernel function that implements
writing to this file — <a
href="https://elixir.bootlin.com/linux/v6.10/source/fs/proc/base.c#L838"><tt>mem_rw()</tt></a> —
uses the <tt>FOLL_FORCE</tt> flag when accessing the target memory.  That
flag causes the write to succeed, regardless of whether the normal
memory protections at the target address would allow writing.  As a result,
<tt>/proc/<i>PID</i>/mem</tt> can be used to overwrite executable memory.
<p>
This sort of capability serves as a sort of giant "welcome" mat to those
who would compromise a system; in this case, it has been present for a long
time.  LWN <a href="/Articles/476947/">covered one exploit</a> that used
<tt>/proc/<i>PID</i>/mem</tt> — in early 2012.  Linus Torvalds <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e268337dfe26dfc7efd422a804dbb27977a3cccc">put
a fix into the mainline</a> in response to that disclosure, but it turned
out to be insufficient; another <a
href="https://issues.chromium.org/issues/40089045">serious exploit</a>
surfaced in 2017.  That time around, Torvalds <a
href="https://git.kernel.org/linus/8ee74a91ac30">applied a patch</a> during
the 4.12 merge window that removed the use of <tt>FOLL_FORCE</tt> from
<tt>mem_rw()</tt> 
on the theory that, perhaps, nobody actually needs that behavior.  The
reality of the situation soon became clear, though, as various users
complained; the <a href="https://git.kernel.org/linus/f511c0b17b08">patch
restoring <tt>FOLL_FORCE</tt></a> that Torvalds merged for 4.12-rc4
included descriptions of some of those users, including the just-in-time
compiler for the Julia language and the <a
href="https://rr-project.org/">rr debugger</a>.  <!-- middle-ad -->
<p>
So <tt>FOLL_FORCE</tt> remained for another seven years.  Surprisingly,
attackers have not gone away over that time either.  So the interest in
closing the <tt>FOLL_FORCE</tt> loophole is still around as well.  Just
before the opening of the 6.11 merge window, Christian Brauner sent <a
href="/ml/all/20240712-vfs-procfs-ce7e6c7cf26b@brauner">a pull request</a>
containing <a
href="/ml/linux-kernel/20240613133937.2352724-2-adrian.ratiu@collabora.com/">a
patch</a> from Adrian Ratiu that tried to improve the situation.  Since
disabling <tt>FOLL_FORCE</tt> entirely has proved to not be possible,
Ratiu's patch added four kernel command-line parameters to allow administrators to
control access to <tt>/proc/<i>PID</i>/mem</tt>:
<p>
<ul class="spacylist">
<li> <tt>proc_mem.restrict_open_read</tt>: controls whether the file
     can be opened for read access.
<li> <tt>proc_mem.restrict_open_write</tt>: controls opening for write
     access. 
<li> <tt>proc_mem.restrict_write</tt>: controls whether writes are allowed
     on an open file descriptor.
<li> <tt>proc_mem.restrict_foll_force</tt>: disables the use
     of <tt>FOLL_FORCE</tt>.
</ul>
<p>
Setting any of these options to "<tt>all</tt>" applies the restriction to
all processes in the system.  If, instead, an option is set to
"<tt>ptracer</tt>", then the given access is allowed only to a process that
has already attached to the target process with <a
href="https://man7.org/linux/man-pages/man2/ptrace.2.html"><tt>ptrace()</tt></a>,
as debuggers tend to do.  The default is to apply no restrictions,
retaining the behavior of current kernels.
<p>
In the pull request, Brauner indicated a lack of enthusiasm for this
approach: "<q>The level of fine-grained management isn't my favorite as it
requires distributions to have some level of knowledge around the
implications of FOLL_FORCE and /proc/&lt;pid&gt;/mem access in
general</q>".  He was able to overcome his reluctance to push the work to
Torvalds, but the request <a
href="/ml/all/CAHk-=wiGWLChxYmUA5HrT5aopZrB7_2VTa0NLZcxORgkUe5tEQ@mail.gmail.com">found
a chillier welcome</a> there: "<q>I pulled this, and looked at it, and then
I decided I can't live with something this ugly</q>".  He had complaints
about the implementation, but also about the complicated set of
command-line options and the logic needed to implement them; he rejected
the pull request and suggested adding a single option to control
<tt>FOLL_FORCE</tt> instead.
<p>
Ratiu <a
href="/ml/linux-kernel/20240717111358.415712-1-adrian.ratiu@collabora.com/">responded</a>
with a patch adding a single kernel-configuration option regulating the use
of <tt>FOLL_FORCE</tt>.  Kees Cook <a
href="/ml/linux-kernel/202407171017.A0930117@keescook/">responded</a> that
a command-line parameter was still needed for developers to be able to test
the restricted mode.  Torvalds <a
href="/ml/linux-kernel/CAHk-=wi3m98GCv-kXJqRvsjOa+DCFqQux7pcmJW9WR8_n=QPqg@mail.gmail.com/">dug
up an old patch</a> from previous iterations that enabled
<tt>FOLL_FORCE</tt> only for the <tt>ptrace()</tt> case, suggesting that it
could be adapted and used now.

On July 23, Ratiu posted <a
href="/ml/all/20240723171753.739971-1-adrian.ratiu@collabora.com">a new
patch</a> adding a boot-time parameter, called
<tt>proc_mem.force_override</tt>, that can be set to "<tt>never</tt>" (to
disable <tt>FOLL_FORCE</tt> entirely), "<tt>ptrace</tt>" (to enable just
the <tt>ptrace()</tt> case), or "<tt>always</tt>" to preserve the existing
behavior.  There is also a build-time configuration option to control the
default behavior in the absence of a command-line parameter.
<p>
Torvalds <a
href="/ml/all/CAHk-=wiJL59WxvyHOuz2ChW+Vi1PTRKJ+w+9E8d1f4QZs9UFcg@mail.gmail.com">was
much happier</a> with this version, though he still pointed out that it
could be "<q>prettied up some more</q>" with a few changes.  Ratiu <a
href="/ml/all/27ea5-66a0c680-3-322bfd00@171174474">agreed</a> with the
suggestions, and posted <a
href="/ml/all/20240726090858.71541-1-adrian.ratiu@collabora.com">a followup
version</a> with minor changes.
<p>
The end of the 6.11 merge window is approaching; there are no guarantees
that this work will be ready and accepted in time to land in this release.
Given that it is a small change, though, and that it addresses a
longstanding security problem, there will be interest in merging it sooner
rather than later if possible.  After that, it will be interesting to see
how distributors set the default; the <tt>ptrace</tt> mode avoids breaking
debuggers like GDB, but does not address all of the other use cases for
<tt>FOLL_FORCE</tt>.  If the damage from restricting <tt>FOLL_FORCE</tt>
proves too painful, it may turn out that this loophole will remain open for
years to come.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Releases-6.12">Releases/6.12</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Vulnerabilities">Security/Vulnerabilities</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/983169/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor983553"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's in a name?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 16:03 UTC (Fri)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/983553/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      I'll bite. What does <code>FOLL_</code> stand for, anyway?



      
          <div class="CommentReplyButton">
            <form action="/Articles/983553/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's in a name?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 16:26 UTC (Fri)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/983554/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Follow", as in the prefix of bitwise-or flag arguments passed to follow_page(), the kernel function that uses page tables to lookup a struct page * given a struct vma and a virtual address.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983568"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's in a name?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 18:26 UTC (Fri)
                               by <b>nickodell</b> (subscriber, #125165)
                              [<a href="/Articles/983568/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      What does <code>FORCE</code> stand for? What check is being ignored?


      
          <div class="CommentReplyButton">
            <form action="/Articles/983568/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983573"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's in a name?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 19:36 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/983573/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; That flag causes the write to succeed, regardless of whether the normal memory protections at the target address would allow writing</span><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983573/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor983643"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What's in a name?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 11:33 UTC (Sat)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/983643/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; follow_page()</span><br>
<p>
Ah, so that’s what was under all those turtles!<br>
<p>
Thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983643/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor983587"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 20:48 UTC (Fri)
                               by <b>rgb</b> (subscriber, #57129)
                              [<a href="/Articles/983587/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Could someone enlighten me what is so special about Julia that it needs this giant security hole to operate properly?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983587/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983598"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 22:12 UTC (Fri)
                               by <b>acarno</b> (subscriber, #123476)
                              [<a href="/Articles/983598/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm no expert by any means, but it looks like Julia allows both interpreted execution (like Python) as well as just-in-time compilation. It's a consequence of being a language designed for high-performance numerical analysis - it aims to support heavy number crunching as well as quick scripts. They presumably want to be able to live-patch a process as it runs (I'm not sure how you could do this otherwise).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983598/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983603"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 22:42 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/983603/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It could operate on its own address space instead of on the address space of another process?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983603/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 20:30 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/983690/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They were already doing that. Specifically, the revert patch linked in the article speaks of opening /proc/self/mem, which is your own memory.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor983604"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 22:53 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/983604/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's for the Julia JIT. JITs want to dynamically generate code and execute it, which happens to be the same thing that exploits want to do. So Julia's JIT allocates some read-only executable pages and then writes to them using /proc/.../mem. That's safer than making the pages directly writable, because it's harder for exploits to make that appropriate write system call than to write to memory directly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983604/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983614"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 0:30 UTC (Sat)
                               by <b>skissane</b> (subscriber, #38675)
                              [<a href="/Articles/983614/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not just write to the page normally, and then change it from writable to executable using mprotect? Wouldn’t that be simpler? I thought that was what most JITs did.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983614/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983616"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 1:35 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/983616/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Flipping pages between writable and executable has a couple of problems. There's performance overhead, since removing prot bits from a page requires IPIs to all other CPUs with the page mapped. And there are security issues, since while the page is writable another thread could modify it to include malicious code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983616/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983628"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 7:09 UTC (Sat)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/983628/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; while the page is writable another thread could modify it to include malicious code.</span><br>
<p>
yes, well. But that's also possible with /proc/self/mem + FOLL_FORCE, as the article explains.<br>
So switching to it doesn't solve that problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983628/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983634"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 8:26 UTC (Sat)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/983634/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The commit message to the commit where Linus reverted his initial patch has a quote presumably from one of the Julia developers which gives some context here (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f511c0b17b08">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/...</a>) :<br>
<p>
"We used these semantics as a hardening mechanism in the julia JIT. By<br>
  opening /proc/self/mem and using these semantics, we could avoid<br>
  needing RWX pages, or a dual mapping approach. We do have fallbacks to<br>
  these other methods (though getting EIO here actually causes an assert<br>
  in released versions - we'll updated that to make sure to take the<br>
  fall back in that case).<br>
<p>
  Nevertheless the /proc/self/mem approach was our favored approach<br>
  because it a) Required an attacker to be able to execute syscalls<br>
  which is a taller order than getting memory write and b) didn't double<br>
  the virtual address space requirements (as a dual mapping approach<br>
  would)."<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983634/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor985924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2024 12:26 UTC (Fri)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/985924/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Nevertheless the /proc/self/mem approach was our favored approach</span><br>
<span class="QuotedText">&gt; because it a) Required an attacker to be able to execute syscalls</span><br>
<span class="QuotedText">&gt; which is a taller order than getting memory write and b) didn't double</span><br>
<span class="QuotedText">&gt; the virtual address space requirements (as a dual mapping approach</span><br>
<span class="QuotedText">&gt; would).</span><br>
<p>
I understand the argument b) to some degree (although if your code section takes up a problematic portion of address space there is a bigger problem than just doubling it), but argument a) is seems moot to me.<br>
You don't protect your process by making the attack surface the whole system (which FOLL_FORCE do), and you don't protect that much against ROP if you have the exact sequence of instructions the attacker would need as part of your initialization (which the interpreter does).<br>
So, it doesn't protect significantly against local exploits and it requires opening up a much bigger (system-wide) exploit space instead. Further, the claim they do have the fallback means also the code to enable the "just modify the memory" approach is one jump away.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/985924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor983638"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 10:11 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/983638/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I already mentioned above that it's generally harder for an exploit to perform a system call with the right parameters than to just write to the desired address.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983638/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor983700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 22:17 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/983700/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't understand why you'd want to flip a page back to writable. You do a preliminary fast JIT to address A, flip the page from writable to executable. Then you decide the function is hot enough and do a more thorough compilation to address B, and change all the references to address A to address B. Once all the CPUs are no longer executing the code in the address A page, free it. Or reuse it. But editing code while it's still cached by another CPU is a very 90s approach to JIT.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983705"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2024 2:01 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/983705/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you're only JITting one function per page then your memory usage is going to be terrible. Yes, in reality you can do more than one function at once but in practice you will seldom be able to fill a page before you need to start executing code in it.<br>
<p>
And the first flip from writable to executable is already a problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983705/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor983885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2024 8:56 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/983885/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; But editing code while it's still cached by another CPU is a very 90s approach to JIT.</font>

<p>And walking on Earth is so last millennium, right?</p>

<p>People are using the best approach that's available. JITs are editing code that's currently executing and there are no plans to change that.</p>

<p>Usually JITs are using two mappings (one readable, one writable) nowadays, but they absolutely do that, because there are no better approach invented yet.</p>

<p>P.S. And yes, code editing is limited in most JITs: they are rewriting jump target addresses and add new code in place where previously there were just NOPs. But these two are not going away any time soon, because they are tightly coupled with the nature of JIT: it's name, quite literally, means “Just In Time” which means, essentially:</p>
<ol><li>We are compiling small pieces of code at time, thus couldn't afford waste the whole page for a tiny amount of code produced.</li>
<li>We are stitching together code “on the fly” which means that calls to “compile-that-code-and-run-it” in the already finished code are replaced with calls to finished, recompiled, code regularly.</li></ol>

<p>If you find a way to beat Oracle Java's JIT, Google's ART JIT, Chrome V8's JIT, Firefox's Warp JIT and all other JITs that are using that approach with something <b>better</b> then it would be time to say that everyone should switch. Saying that everyone should stop doing what they are doing just because you don't like it — without offering any alternative, on the other hand, is just irresponsible.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/983885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor983649"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 14:12 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/983649/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Why not just write to the page normally, and then change it from writable to executable using mprotect? Wouldn’t that be simpler?</font>

<p>You can not do that to code that's already compiled and, more importantly, <b>is currently executing</b>.</p>

<font class="QuotedText">&gt; I thought that was what most JITs did.</font>

<p>Most “serious” JITs also do what Julia does. When you JIT-compiler one function you couldn't be sure that other functions, that are called from the current one needs to be JIT-compiled too: if they are handling some exceptional conditions then they would never be called and JIT-compiler needs to be fast, otherwise it may even be slower than interpreter, in some cases!</p>

<p>That's why instead of putting call to JIT-compiled function they put a call to “compile me later” thunk (or, in some JITs, to the interpreter, I'm not sure what exactly Julia uses).</p>

<p>But when you have fully-optimized version of function that call to “compile me later” thunk is now just pure overhead! You can go eliminate it… but for that you need to patch already compiled (and, presumably, executing!) code.</p>

<p>On x86 CPUs there are special guarantee that it can be done safely if modified part fits fully into 8bytes segment (it probably goes back to 80486 CPUs because I have no idea how to explain that 8bytes limitation), most other CPU don't need this trick because they couldn't embed address into one instruction anyway thus they load address from memory... but that memory have to be in the same page on some CPUs because of limitation of instructions encoding!</p>

<p>You may guess how important is it for performance from just a simple fact: <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/advanced-performance-extensions-apx.html">Intel APX</a> added special new jump format to make that patching easier!</p>

<p>And yes, Julia is not an exception, almost all JITs are doing that, they are just using two mappings because that's simple and cross-platform way of doing that.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/983649/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983661"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 15:04 UTC (Sat)
                               by <b>malmedal</b> (subscriber, #56172)
                              [<a href="/Articles/983661/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; You can not do that to code that's already compiled and, more importantly, is currently executing.</span><br>
<p>
We certainly used to be able to do that. It gave a nice speedup on the 386 when you could save a register by having a mov #immediate, register and<br>
modify the immediate as needed. <br>
<p>
<span class="QuotedText">&gt; On x86 CPUs there are special guarantee that it can be done safely if modified part fits fully into 8bytes segment  </span><br>
<p>
Reference for this? The old rule was you needed a jump or taken branch instruction to be sure the pipeline was clear after you modified executable code, later you could do any "serialising" instruction, like cpuid, instead.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983661/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983662"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Julia</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 15:36 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/983662/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; We certainly used to be able to do that. It gave a nice speedup on the 386 when you could save a register by having a mov #immediate, register and modify the immediate as needed.</font>

<p>386 doesn't even have “executable” bit in its page tables. Were you using segments? I guess this may work with segments since they cache permission in CPU registers. Still sounds very tricky and fragile to me.</p>

<p>Are you even talking about <i>change it from writable to executable using mprotect</i> (and in SMP environment) when you say “we used to be able to do that”?</p>

<font class="QuotedText">&gt; The old rule was you needed a jump or taken branch instruction to be sure the pipeline was clear after you modified executable code, later you could do any "serialising" instruction, like cpuid, instead.</font>

<p>I think we are talking about past each other, again. I'm talking about execution of the code that you are planning to patch by some <b>other</b> CPU core. Were these 386 systems, that you are talking about, even SMP ones? On UP system things are much, <b>much</b>, <b>MUCH</b> simpler. But on SMP systems when you are patching code that other CPU may be executing at this precise moment you need atomicity guarantees or complicated and convoluted scheme that would ensure that code that you are planning to patch is not, currently, executing.</p>

<font class="QuotedText">Reference for this?</font>

<p>Look for the <i>Asynchronous modification</i> under <i>Cross-Modifying Code</i> in the <a href="https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf#page=268">AMD Manual</a>. Intel provides more or less the same guarantees, but I don't remember which section of the manual describes that.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/983662/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983666"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Self-modifying code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 17:03 UTC (Sat)
                               by <b>malmedal</b> (subscriber, #56172)
                              [<a href="/Articles/983666/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      Thank you. 
<p>
So reading page from page 206,  you are talking about asynchronous modification. 8 bytes is not because of 486, it is because 8 bytes is 64 bits, the size that gets atomically updated. Also the 64 bits must be aligned. 
<p>
It is basically warning about the situation where the instruction pointer is in the middle of a 64bit quad word when the quad word gets updated, if the instruction boundary changes so that the IP is not actually at the start of an intended instruction you have a problem.
<p>
They are recommending a sort of RCU like approach to avoid this: 
<blockquote>
     Note that since stores to the instruction stream are observed by the instruction fetcher in program
     order, one can do multiple modifications to an area of the target thread's code that is beyond reach of
     the thread's current control flow, followed by a final asynchronous update that alters the control flow to
     expose the modified code to fetching and execution.
</blockquote>

Reading a bit further, on synchronous modification where the target thread is waiting while the other thread is writing, the rules are the same as before, you can make whatever changes you want, but the target thread must execute a serialising instruction. 
<p>
I don't remember if the 386 had an executable-only mode, but we certainly had writable memory that could be executed.
<p>
It's not a fragile thing to do, it is even supported by ld, see the -N option. Seems that interferes with shared libraries, so if you want that you need to use mprotect. 
<p>
I believe it fell out of favour because the performance advantage became much less when the 486 came with on-chip cache. 





      
          <div class="CommentReplyButton">
            <form action="/Articles/983666/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983682"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Self-modifying code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 20:21 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/983682/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt;  I don't remember if the 386 had an executable-only mode, but we certainly had writable memory that could be executed.</font>

<p>The main issue that we are discussing here revolves around <a href="https://en.wikipedia.org/wiki/NX_bit#x86">NX bit</a> that allows one to create <b>non</b>-executable code!</p>

<p>On 386 the only way to make code non-executable was to play with segments and their limits. On Unix-like OS the best you may do is split 4GB of virtual address space in two: non-excutable area and executable area.</p>

<p>That means that approach that <a href="https://lwn.net/Articles/983614/">skissane talks about</a> is just simply not possible on 386! Except if you use extremely weird OS which doesn't use paging, but uses segments for virtual memory.</p>

<p>Such OSes may exist, in theory, but I certainly know none, that actually did this thing in practice, that's why I have become so excited you said you did that with 386.</p>

<p>But it looks more and more likely that you haven't done what we are talking here about at all and are talking about entirely different situation.</p>

<font class="QuotedText">&gt; They are recommending a sort of RCU like approach to avoid this:

<blockquote>Note that since stores to the instruction stream are observed by the instruction fetcher in program order, one can do multiple modifications to an area of the target thread's code that is beyond reach of the thread's current control flow, followed by a final asynchronous update that alters the control flow to expose the modified code to fetching and execution.</blockquote>
</font>

<p>That just happens with JITs automatically: once you have created optimized version of routine there are rarely the need to go back to intepreter. But yeah, usually only one <code>call</code>/<code>jmp</code> instruction is patched.</p>

<blockquote>It's not a fragile thing to do, it is even supported by ld, see the -N option. Seems that interferes with shared libraries, so if you want that you need to use mprotect.</blockquote>

<p>Again: that's different. Keeping something in the write+execute mode is dangerous WRT exploits, but not fragile, but playing with permissions and flipping from read+write to read+execute and back is pretty fragile because you need to ensure that code that you want to patch is not executed on the other core!</p>

<font class="QuotedText">&gt; I believe it fell out of favour because the performance advantage became much less when the 486 came with on-chip cache.</font>

<p>No, it fell out of favor much later, when people started caring about security and started enforcing <a href="https://en.wikipedia.org/wiki/W%5EX">W^X</a> property.</p>

<p>First with segment limit tricks and then, later, with hardware <a href="https://en.wikipedia.org/wiki/NX_bit#x86">NX bit</a>.</p>

<p>Only Apple and only on iOS enforces it so radically as make JITs simply impossible, other OSes provide ways for JITs to work, that we are discussing here.</p>

<p>But <b>all</b> this discussion is happening in an <a href="https://lwn.net/Articles/983604/">W^X</a> world!</p>

<p>Why do you keep bring W+X examples and keep saying that you can do everything easily if only you remove that restriction… of course it's possible to do, what could be simpler?</p>

<p>That's simply not what we are discussing here! The idea is to ensure that <a href="https://en.wikipedia.org/wiki/W%5EX">W^X</a> is strictly enforced, maybe even teach kernel not to ever provide W+X mappings at all — and yet still keep JITs working, somehow.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/983682/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Self-modifying code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 21:52 UTC (Sat)
                               by <b>malmedal</b> (subscriber, #56172)
                              [<a href="/Articles/983694/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was responding to your earlier statement: <br>
<p>
<span class="QuotedText">&gt; On x86 CPUs there are special guarantee that it can be done safely if modified part fits fully into 8bytes segment (it probably goes back to 80486 CPUs because I have no idea how to explain that 8bytes limitation)</span><br>
<p>
Anyway, for you current statement, just have the kernel to the tricky bit.<br>
<p>
Have the app ask for a writable alloc, fill it with code.<br>
<p>
Then the app tells the kernel make this executable and the safe interrupt point is xxx. <br>
<p>
Then when the time comes to replace the running code the app tells the kernel to write a<br>
processor-specific safe stop sequence to the interrupt point. <br>
<p>
on x86 this would likely be a sequence of eight int 3 instructions.<br>
<p>
This will stop the thread and the app can allocate a new writable alloc and tell the kernel to make it executable and <br>
have the thread continue there. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983701"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Self-modifying code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 22:56 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/983701/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; I was responding to your earlier statement:</font>

<p>Said statement was just a side comment to explain what JITs are doing, why and how what they are dong is guaranteed to work. To show that need of JITs to alter running code while it's running was acute enough and understood enough that even hardware makers already created special JIT-tailored guarantees there.</p>

<font class="QuotedText">&gt; Have the app ask for a writable alloc, fill it with code.</font>

<p>That's possible.</p>

<font class="QuotedText">&gt; Then the app tells the kernel make this executable and the safe interrupt point is xxx.</font>

<p>How exactly do you plan to do that? Would kernel take 10-20 bytes of generated code and allocate whole 4KB (or, worse, 16KB if we are talking about modern ARM) page to make it executable?</p>

<p>This sounds pretty wasteful.</p>

<font class="QuotedText">&gt; Then when the time comes to replace the running code the app tells the kernel to write a processor-specific safe stop sequence to the interrupt point.</font>

<p>So now you want to introduce something like stop-the-world interrupt in place where previously everything was completely lock-free?</p>

<p>Also: JIT doesn't <b>actually</b> replaces running code, it replaces <b>branch target</b> in the running code. Using well-documented and guaranteed approach explicitly described in the CPU manual.</p>

<p>Why do you want to change <b>that</b>?</p>

<font class="QuotedText">&gt; on x86 this would likely be a sequence of eight int 3 instructions.
</font>

<p>Why eight and what would it give us? Except more complications and more places to have bugs?</p>

<font class="QuotedText">&gt; This will stop the thread and the app can allocate a new writable alloc and tell the kernel to make it executable and have the thread continue there.</font>

<p>But app doesn't need that! App just simply wants to replace target of jump! Without all that complicated and useless machinery! Previously there was <code>call COMPILE_ME_FOO</code> and now there would be <code>call FOO_JIT_COMPILED_AND_READY_TO_USE</code>. That's all!</p>

<p>It's useless because eight int 3 instructions don't guarantee anything (x86 includes instructions longer than eight bytes and with redundant prefix you may force almost any instruction to be longer) and it's useless because write via <code>/proc/self/mem</code> (or use of two mappings) <b>already</b> does everything that's needed!</p>

<p>Why adding API that would be more convoluted and slower yet not actually safer then existing API?</p>

<p>It doesn't really makes much sense! You gave us some elaborate solution to some unknown problem, but neglected to say what is the problem that solution is supposed to solve!</p>

<p>It's very hard to understand whether proposal is good or bad if we have no idea what that proposal even supposed to achieve.</p>

<p>As in: what that dane with eight int 3 instructions and additional syscall was supposed to accomplish? What would it do better than write to <code>/proc/self/mem</code> or two separate mappings (one writable, one executable) for the same chunk of memory?</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/983701/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983703"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Self-modifying code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2024 0:38 UTC (Sun)
                               by <b>malmedal</b> (subscriber, #56172)
                              [<a href="/Articles/983703/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's an answer to your previous request: <br>
<p>
<span class="QuotedText">&gt; maybe even teach kernel not to ever provide W+X mappings at all</span><br>
<p>
If you don't want the kernel to provide userspace with a W+X mapping you can have the kernel keep the mapping to itself, but if userspace then can<br>
ask the kernel to do arbitrary changes, or have separate W and X mappings, you haven't gained that much, so you want to limit what the kernel will do to the simplest thing that will work. The point is to stop the old code at a safe location, on some CPUs you can set address-based breakpoints instead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983703/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Self-modifying code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2024 8:40 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/983716/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; If you don't want the kernel to provide userspace with a W+X mapping you can have the kernel keep the mapping to itself, but if userspace then can
ask the kernel to do arbitrary changes, or have separate W and X mappings, you haven't gained that much</font>

<p>Yes, you did. You have made life for attackers harder. As explained <a href="https://en.wikipedia.org/wiki/W%5EX">in the Wikipedia article</a>. And that article even includes section about JITs, too!</p>

<p>Security and usability are always at odds, there exist 100% bullet-proof way to stop any attacks, both local and remote — just turns the computer off and all kinds of attacks are prevented! But this “protection” is not very usable, thus we need something else.</p>

<font class="QuotedText">&gt; you want to limit what the kernel will do to the simplest thing that will work.</font>

<p>Yes, but now we need to determine <b>what</b> is that work even is!</p>

<font class="QuotedText">&gt; The point is to stop the old code at a safe location</font>

<p>Do you actually read what I wrote? Just where have I wrote that JIT wants/needs <b>that</b>? It have no such need. On the contrary, what JIT needs is described precisely under titles <i>Asynchronous modification</i> under <i>Cross-Modifying Code</i> in the <a href="https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24593.pdf#page=268">AMD Manual</a>: <i>the nature of the code
being executed by the target thread is such that it is insensitive to the exact timing of the update</i>.</p>

<p>JIT (or, heck, dynamic loader that resolves symbols lazily) initially inserts jump to the “slow path” because “fast path” doesn't exist, later, when “fast path” does exist jump is replaced. <b>That's all</b>, JIT doesn't care if “slow path” is used a few times after “fast path” is created, it just wants “eventual consistency” where programs stop using “slow path” after a few milliseconds.</p>

<p>And, as I have shown you, with references to AMD manual, CPUs <b>actually offer enough relevant guarantees on the hardware level</b>, description is so precisely tailored to the need of JITs that they could, as well, call it “JIT-friendly code modification” and not “asynchronous modification”.</p>

<p>And yet, you repeatedly invent complication that make things more problematic and AFAICS don't achieve anything security-wise? Why? What's the point?</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/983716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Self-modifying code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2024 9:31 UTC (Sun)
                               by <b>malmedal</b> (subscriber, #56172)
                              [<a href="/Articles/983720/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Why? What's the point?</span><br>
<p>
You asked for this earlier:<br>
<p>
<span class="QuotedText">&gt;&gt; maybe even teach kernel not to ever provide W+X mappings at all</span><br>
<p>
This is an answer, it has a cost, an expensive one, but it is an answer. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983722"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Self-modifying code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2024 10:00 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/983722/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; This is an answer, it has a cost, an expensive one, but it is an answer.</font>

<p>Sure, but <b>as was mentioned in the very beginning</b>, <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f511c0b17b08">seven years ago</a> there are already two other methods (three if you include self-ptrace).</p>

<p>You are proposing third (or fourth) one without explaining why it's better than what we already have.</p>

<p>This looks like “he have to do <b>something</b>” — “this is <i>something</i>” — “let's do it!” logic.</p>

<p>Such logic rarely produces good designs.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/983722/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Self-modifying code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2024 10:57 UTC (Sun)
                               by <b>malmedal</b> (subscriber, #56172)
                              [<a href="/Articles/983726/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; You are proposing third (or fourth) one without explaining why it's better than what we already have.</span><br>
<p>
In discussions like this I believe it is useful to go through many possible options and evaluate their pros and cons without being particularly wedded to any one of them. Since it's an option that meets the specific constraint that you, yourself, chose to highlight, I felt that it should be included in the discussion. This approach appears to be incompatible with your style of arguing, so I'll just be ignoring you from now on. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983732"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Self-modifying code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2024 12:05 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/983732/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; In discussions like this I believe it is useful to go through many possible options and evaluate their pros and cons without being particularly wedded to any one of them.</font>

<p>Why? What have that approach brings to you? What have you achieved doing it?</p>

<p>I find that very strange. Things that we <b>already have</b>, things that <b>exist</b>, by definition, have a priority. They are already here, they are done, that enough. But any change from the status quo need a justification.</p>

<p>Sure, I like to go “back the memory lane” and see <b>why</b> things that we have are like they are. Because situation of today is different from situation of yesterday.</p>

<p>But no matter what, even if the thing that made us to pick original decision is no longer valid or even if the original decision was made on a whim without any rational justifications… things that we have are very-very different from things that we don't have.</p>

<font class="QuotedText">&gt; Since it's an option that meets the specific constraint that you, yourself, chose to highlight, I felt that it should be included in the discussion.</font>

<p>One may invent bazillion crazy schemes if not constrained by anything. Talking about them would take forever unless we would limit these discussions, somehow.</p>

<p>“Anything new should come with an extra justification that explains why should we do that if some other solution already exists” is very good rule if we are talking about something that we plan to implement. I don't know anyone who achieved anything significant while violating it (but note the subtle difference: if we don't yet have a solution <b>at all</b> then someone who doesn't  “know” that “<i>X</i> is simply impossible” may achieve something really cool… but when said <i>X</i> is not just possible in theory but we already know how to do <i>X</i> in practice then situation chances).</p>

<p>Well, maybe fiction writers would be an exception, but even they, when they construct their strange imaginary worlds, still play on that contrast between what “we” have and what “they” have. “Does it exist?” is still very much a central question that governs their decisions even if they imagine a world where something that we already have doesn't exist and where evolution of civilization, as a consequence, goes into a different direction.</p>

<font class="QuotedText">&gt; This approach appears to be incompatible with your style of arguing, so I'll just be ignoring you from now on.</font>

<p>Fine by me. I don't like to waste time on pointless discussions without any practical consequences (even if the consequence is minor like “now that I have wrote that I may just refer people here instead of repeating my arguments again and again”) while you seem to regard these as the only ones worthy of pursuing.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/983732/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor983605"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">thanks for the ptracer option</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2024 22:54 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/983605/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Phew, I'm glad the discussion arrived at a solution that supports unlimited access for ptracers. It would have been hugely problematic if people had to choose between debuggers working and no protection at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983605/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor983671"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">thanks for the ptracer option</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2024 17:21 UTC (Sat)
                               by <b>Heretic_Blacksheep</b> (guest, #169992)
                              [<a href="/Articles/983671/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree.  This is one low hanging fruit down, several left to go, from a security POV.  The compromise is acceptable - and hopefully distros will default to "ptrace" in the future after a transition period thus eventually forcing software that can to clean up their acts and responsibly notify users when they functionally can't how to re-enable the old behavior, much as how it worked with OpenBSD's W^X transition some years back.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983671/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor983782"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">thanks for the ptracer option</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 29, 2024 9:04 UTC (Mon)
                               by <b>gray_-_wolf</b> (subscriber, #131074)
                              [<a href="/Articles/983782/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it possible for program to attach to itself as a debugger satisfying the ptrace requirement?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/983782/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor985923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">thanks for the ptracer option</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 16, 2024 12:19 UTC (Fri)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/985923/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe some do to try to fight attempts to reverse engineering, so I guess it's possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/985923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor989729"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">thanks for the ptracer option</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2024 11:17 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/989729/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Absolutely, though you have to take some special measures to avoid having to stop all your threads in the process of attachment :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/989729/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
