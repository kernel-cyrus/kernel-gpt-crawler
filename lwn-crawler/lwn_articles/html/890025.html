        <!DOCTYPE html>
        <html lang="en">
        <head><title>Negative dentries, 20 years later [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/890025/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/890578/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/890025/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Negative dentries, 20 years later</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 11, 2022</br>
           </div>
Filesystems and the virtual filesystem layer are in the business of
managing files that actually exist, but the Linux "dentry cache", which
remembers the results of file-name lookups, also keeps track of files that
<i>don't</i> exist.  This cache of "negative dentries" plays an important
role in the overall performance of the system but, if it is allowed to grow
too large, its role can become negative in its own right.  As the 2022 <a
href="https://events.linuxfoundation.org/lsfmm/">Linux Storage, Filesystem,
and Memory-Management Summit</a> (LSFMM) approaches, the subject of negative
dentries has come up yet again; whether one can be positive about the
prospects for a resolution this time around remains unclear.
<p>
The kernel's dentry cache saves the results of looking up a
file in a filesystem.  Should the need arise to look up the same file again, the
cached result can be used, avoiding a trip through the underlying
filesystem and accesses to the storage device.  Repeated file-name lookups
are common — consider <tt>/usr/bin/bash</tt> or <tt>~/.nethackrc</tt> — so
this is an important optimization to make.
<p>
The importance of remembering failed lookups in negative dentries may be
less obvious at the outset.  As it happens, repeated attempts to look up a
nonexistent file are also common; an example would be the shell's process of
working through the search path every time a user types "<tt>vi</tt>"
(Emacs users start the editor once and never leave its cozy confines
thereafter, so they don't benefit in the same way).  Even more common are
failed lookups created by the program loader searching for shared libraries
or a compiler looking for include files.  One is often advised to "fail
fast" in this society; when it comes to lookups of files that don't exist,
that can indeed be good advice.
<p>
So negative dentries are a good thing but, as we all know, it is possible
to have too much of a good thing.  While normal dentries are limited by the
number of files that actually exist, there are few limits to the number of
nonexistent files.  As a result, it is easy for a malicious (or simply
unaware) application to create negative dentries in huge numbers.  If
memory is tight, the memory-management subsystem will eventually work to
push some of these negative dentries out.  In the absence of memory
pressure, though, negative dentries can accumulate indefinitely, leaving a
large mess to clean up when memory does inevitably run out.
<p>
Some kernel problems are resolved quickly; others take a little longer.
LWN briefly <a href="/Articles/1511/">reported on</a> a complaint about the
memory consumption of negative dentries back in 2002, nearly exactly 20&nbsp;years
ago.  A more recent attempt to solve the problem was <a
href="/Articles/814535/">covered here</a> in early 2020.  While numerous
developers have taken a stab at the negative-dentry problem over time, the
core problem remains.  Those dentries still take up valuable memory, and
they can create other problems (such as <a
href="/ml/linux-fsdevel/20220209231406.187668-1-stephen.s.brennan@oracle.com/">soft
lockups</a>) as well.
<p>
<h4>A new discussion</h4>
<p>
In mid-March, Matthew Wilcox <a
href="/ml/linux-mm/YjDvRPuxPN0GsxLB@casper.infradead.org/">suggested</a>
that the negative-dentry problem might make a good LSFMM topic:
"<q>maybe some focused brainstorming on the problem would lead to
something that actually works</q>".  Often, simply proposing a topic
like this can elicit the sort of brainstorming needed to work toward a
solution.  That didn't happen this time, but it did lead to the posting of
<a
href="/ml/linux-kernel/20220331190827.48241-1-stephen.s.brennan@oracle.com/">a
patch set</a> by Stephen Brennan showing a new approach to the problem.
<p>
One of the difficulties posed by the negative-dentry problem is that it can
be hard to know when the time has come to start throwing them away.  The
sizes of systems and workloads vary hugely, so any sort of simple limit is
likely to cause performance regressions somewhere.  Providing a knob for the system
administrator to tune the limit can be tempting, but that just pushes the
problem onto the users, and it is generally felt that the kernel should be
able to figure things out by itself.  But, as Brennan noted, that is not
easy:
<p>
<blockquote class="bq">
	It's hard to look at a hash bucket or LRU list and design a
	heuristic for an acceptable amount of negative dentries: it won't
	scale from small to large systems well. But setting up heuristics
	on a per-directory basis will scale better, and it's easier to
	reason about.
</blockquote>
<p>
The specific heuristic proposed by the patch is that the negative dentries
for any given directory should not outnumber the positive dentries by more
than a factor of five.  If there are 20 positive dentries in the cache for
a directory, there can be no more than 100 negative dentries.  It is a nice
idea, with only one small problem: the kernel doesn't keep counts of the
number of dentries (or their types) associated with each directory.
<p>
To get around that, Brennan added code that maintains a "cursor" in the
list of dentries associated with each directory.  Whenever a dentry
operation (creation or deletion) happens, that code will advance the cursor
through the next six dentries in the list; if it does not encounter at
least one positive dentry, it assumes that the limit has been exceeded and
cleans up some negative dentries.  Attaching this work to the dentry
operations themselves means that the penalty will be paid by processes that
are responsible for the creation of a lot of dentries, which seems correct.
<p>
The problem with this approach is, of course, that there is nothing that
forces dentries to be added to a directory's list in any particular order.
Depending on the order in which dentries are created, this algorithm could
come to an incorrect conclusion regarding the real ratio of positive to
negative dentries and do the wrong thing.  Brennan acknowledged this
problem ("<q>This workload-dependence is bad, full stop</q>"), but
has not yet come up with a better idea.  As things stand, this algorithm
seems certain to lead to pathological cases; that may prevent the
acceptance of this patch set even in the absence of other concerns.

<p>
<h4>The bigger problem</h4>
<p>
Back in the general discussion, though, Dave Chinner <a
href="/ml/linux-mm/20220316025223.GR661808@dread.disaster.area/">argued</a>
that the focus on negative dentries was addressing a symptom of the problem
and missing the bigger issue.  The real problem, he said, is that
memory pressure is the only mechanism the kernel has for controlling the
size of the many caches it maintains:
<p>
<blockquote class="bq">
	Yup, the underlying issue here is that memory reclaim does nothing
	to manage long term build-up of single use cached objects when
	*there is no memory pressure*. There's [plenty] of idle time and spare
	resources to manage caches sanely, but we don't. e.g. there is no
	periodic rotation of caches that could lead to detection and
	reclaim of single use objects (say over a period of minutes) and
	hence prevent them from filling up all of memory unnecessarily and
	creating transient memory reclaim and allocation latency spikes
	when memory finally fills up.
</blockquote>
<p>
Rather than worry about the dentry cache, he said, developers should come
up with a mechanism that can manage the size of all in-kernel caches.
Wilcox <a href="/ml/linux-mm/YjnmcaHhE1F2oTcH@casper.infradead.org/">agreed
in principle</a>, but cautioned against making the problem so broad that it
becomes intractable.  Chinner <a
href="/ml/linux-mm/20220322222114.GE1609613@dread.disaster.area/">doubled
down</a>, though, saying that multiple kernel caches have the same problem,
and that a solution for one, based on some sort of periodic scanning to age
items out of the cache, would be instantly applicable to all of them.
<p>
This discussion has mostly wound down without any suggestion that anybody
is setting out to create the more general cache-aging mechanism that
Chinner would like to see.  The problem remains, though, and seems unlikely
to go away by itself.  So the chances of this discussion showing up in an
LSFMM slot seem fairly high.  Perhaps an in-person discussion — the first
in the memory-management and filesystem communites in three years — will lead to some sort
of consensus on a solution, preferably one that will be implemented before another
20&nbsp;years pass.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Dentry_cache">Dentry cache</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/890025/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor890973"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 18:19 UTC (Mon)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/890973/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>It seems to me that a negative dentry is useful only to the extent that it's hit.  So what if the total number of negative dentries was limited to some small number and if that number is exceeded, then either (1) we evict an entry that has never been hit yet (or hit fewer than N times), or (2) we increase the negative dentry cache size by some amount if all negative dentries have been hit at least once (or at least N times).
<p>This means keeping track of how many times a negative dentry is hit.
<p>Caveat: I'm not a kernel programmer and have no idea how this would work in practice with the existing data structures.




      
          <div class="CommentReplyButton">
            <form action="/Articles/890973/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890975"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 18:56 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/890975/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You&#x27;re absolutely correct that never-accessed negative dentries have no value. And we even have a single bit that says whether the dentry has been accessed since the last time it got to the end of the LRU list. The problem is, as Dave says, that we don&#x27;t try to turn the list over to find which ones are and aren&#x27;t used until were under general memory pressure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890975/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890977"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 19:03 UTC (Mon)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/890977/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Right.  I guess limiting the size of the dentry cache so we start evicting before we have general memory pressure is the main idea, but allowing it to expand if by some miracle all entries have been hit so that it scales up if memory is available.


      
          <div class="CommentReplyButton">
            <form action="/Articles/890977/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 19:31 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/890981/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The idea I&#x27;m currently advocating (a little busy with other projects to work on myself) is that after allocating 100 entries, we scan 110 entries at the tail of the list and either return them to the head of the list with their &#x27;referenced&#x27; flag cleared, or free them. That allows the cache to both shrink (if &lt;100 have been referenced) and grow (if &gt;100 have been referenced)<br>
<p>
Obviously those numbers are a bit magic. Why not 150? Or 200? Needs some experimentation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891012"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 7:44 UTC (Tue)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/891012/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not a power of two? ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891012/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor890983"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 20:35 UTC (Mon)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/890983/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; While normal dentries are limited by the number of files that actually exist, there are few limits to the number of nonexistent files.</font><br>
<p>
But there is a limit to the number of _ranges_ of nonexistent files: they are limited by the number of files that actually exist plus one. So a solution could be to, instead of storing the name of the nonexistent file, storing the name of the existent files preceding and following the existent file. There is precedent in the NSEC family of DNS entry types (NSEC and NSEC3), which prove the absence of a record on a DNS zone by signing a record containing both the preceding and following names.<br>
<p>
(You could also make the ranges circular to remove the &quot;plus one&quot; and avoid a couple of special cases.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890983/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890985"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 21:48 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/890985/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; a solution could be to, instead of storing the name of the nonexistent file, storing the name of the existent files preceding and following the existent file</font><br>
<p>
I like this. Automatically bounded, and you can potentially answer many queries with a single negative range. You could even reuse the positive dentries for the preceding and following files, so long as you can ensure they won&#x27;t be freed prematurely, further reducing RAM requirements.<br>
<p>
The main drawback seems to me to be that the current filesystem APIs don&#x27;t provide the preceding and following files in response to failed lookups—which could be changed—and, more importantly, that some filesystems may not be able to provide this information within acceptable performance parameters. For example, consider a FUSE filesystem like &lt;<a href="https://pypi.org/project/simple-httpfs/">https://pypi.org/project/simple-httpfs/</a>&gt; which only responds to requests for specific paths and can&#x27;t be enumerated to find the preceding and following positive entries. (And even if it could, that information could be obsolete before the query finishes; this can even affect simple non-range negative dentries but storing ranges, including names not directly queried, would make it worse.)<br>
<p>
One can imagine using a mix of ranges where filesystem support exists and simple negative entries where it doesn&#x27;t, but then we still need to solve the original problem. Or we could just not cache negative lookups from filesystems that can&#x27;t provide ranges, but that has its own drawbacks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890985/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891057"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 11:37 UTC (Tue)
                               by <b>grawity</b> (subscriber, #80596)
                              [<a href="/Articles/891057/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><p>some filesystems may not be able to provide this information within acceptable performance parameters. For example, consider a FUSE filesystem like &lt;https://pypi.org/project/simple-httpfs/&gt;</p></blockquote>

<p>I think you would have the same problem with ordinary network filesystems like NFS/SMB when accessing a directory where you have +x but not +r. The server knows the nearest two files in that directory, but the client doesn't have the permissions to know that.</p>








      
          <div class="CommentReplyButton">
            <form action="/Articles/891057/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor890986"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 21:49 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/890986/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is my understanding that the dentry cache is currently non-exhaustive, that is, it does not contain every dentry in a given directory, but only those that have been recently accessed. I&#x27;m not clear on how you would go about creating negative dentry ranges in a non-exhaustive cache. I can think of a few ways to do it, but they all seem obviously terrible to me:<br>
<p>
1. Make the dentry cache exhaustive; scan and pre-cache the entire directory when you want to cache any individual dentry. On ext4 and other modern FS&#x27;s, this will result in hilariously large caches in some cases, because directories are allowed to have a very large number of entries. Also, the scan will take a long time to complete.<br>
2. Scan the directory once every time a failed lookup occurs, and make a negative dentry for the range surrounding that failed lookup. This slows down failed lookups by potentially quite a lot, especially on filesystems where dentries are not sorted in any convenient way (e.g. most if not all versions of FAT, ext2).<br>
3. Scan the directory once every time a successful lookup occurs, and make negative dentries for the two ranges adjacent to the successful lookup. This is subject to most of the same problems as (2), except that it slows down successful lookups instead of failed lookups.<br>
4. Periodically identify directories that have a lot of cached negative dentries, scan them, and coalesce their negative dentries into ranges. But it would be far simpler to just expire the negative dentries which have not been recently used; a negative dentry does not correspond to anything on disk, and so negative dentries are always clean and can be unceremoniously discarded without disk access (i.e. discarding is very fast compared to scanning).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890986/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890993"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 23:10 UTC (Mon)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/890993/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I&#x27;m not clear on how you would go about creating negative dentry ranges in a non-exhaustive cache.</font><br>
<p>
It would need help from each filesystem. I can think of three main ways of storing directory entries on a filesystem: they can be an unsorted list of filenames (as you mentioned, FAT and ext2 are good examples), or they can be a more complicated sorted structure (either a linear ordered list or something like a b-tree), or they can be an unsorted hash table.<br>
<p>
For unsorted directories, you already have to scan the whole directory linearly on a cache miss; the only change would be to keep track of the nearest preceding and following names.<br>
<p>
For a sorted structure, the lookup code would have to be modified to return the neighbor entries when the entry is not found. There&#x27;s an extra complication in that the range lookup would have to use the filesystem&#x27;s native concept of order, which could differ from filesystem to filesystem (for instance, the order might be based on a hash of the filename).<br>
<p>
I don&#x27;t have a good solution for filesystems which use a hash table directly, though an approach using directly the low-level details of the hash table might be possible (that is, a negative entry would map to a range of hash buckets).<br>
<p>
The worst case would be remote filesystems (which also includes things like FUSE), since not only their API would have no concept of a negative dentry range, but also a range could become invalid without warning.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890993/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 0:17 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/890999/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; For unsorted directories, you already have to scan the whole directory linearly on a cache miss; the only change would be to keep track of the nearest preceding and following names.</font><br>
<p>
That is probably acceptable.<br>
<p>
<font class="QuotedText">&gt; For a sorted structure, the lookup code would have to be modified to return the neighbor entries when the entry is not found. There&#x27;s an extra complication in that the range lookup would have to use the filesystem&#x27;s native concept of order, which could differ from filesystem to filesystem (for instance, the order might be based on a hash of the filename).</font><br>
<p>
This might require more complicated tree traversal logic, in the case where one of the neighbor leaves is in a different subtree to the other neighbor leaf. At worst, that probably adds an extra O(log n) root-to-leaf traversal, which is likely acceptable in practice.<br>
<p>
<font class="QuotedText">&gt; I don&#x27;t have a good solution for filesystems which use a hash table directly, though an approach using directly the low-level details of the hash table might be possible (that is, a negative entry would map to a range of hash buckets).</font><br>
<p>
Typically, when we characterize the performance of a hash table, we assume that it has some maximum fullness. That is, if there are N buckets, then we assume that there are at most kN elements in the hash table (for some k with, in most cases, 0 &lt; k &lt; 1); if the hash table grows larger than that, it gets rebuilt with more buckets. This periodic rebuilding is necessary if you want a hash table to have O(1) performance on its standard operations - else it will eventually degrade to linear scans (regardless of whether you use open hashing or closed hashing). But this also means that it&#x27;s possible for the hash table to be much, much sparser than k, if it has just been rebuilt (or if you&#x27;ve only added a small number of elements in the first place). As a result, in the worst case you could potentially scan N-1 consecutive buckets to find the boundaries (when there&#x27;s only one occupied bucket). In cases where the hash table was just rebuilt, you could observe up to N - kn consecutive empty buckets, where n is the previous size (n depends on your growth algorithm, but it&#x27;s probably some constant fraction of N, e.g. n = N/2). In both cases, this means our worst case performance has degraded from O(1) to O(N) (where N is the number of buckets, which is proportional to the actual number of dentries). That is likely to be unacceptable, for systems where we decided to use a hash table in the first place, because it defeats the main selling point of a hash table.<br>
<p>
<font class="QuotedText">&gt; The worst case would be remote filesystems (which also includes things like FUSE), since not only their API would have no concept of a negative dentry range, but also a range could become invalid without warning.</font><br>
<p>
That also applies to individual negative dentries. The only way negative dentry caching can possibly work is if it takes place on the server side, and not the client side. Which is rather unfortunate, seeing as the network roundtrip is by far the more expensive operation than the disk lookup (at least in high-latency deployments, anyway).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891000"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 0:24 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/891000/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (where N is the number of buckets, which is proportional to the actual number of dentries)</font><br>
<p>
Correction: Where N is proportional to *the largest number of dentries that the directory has ever had, or the largest number since the last time the filesystem shrank the hash table, if the filesystem does that at all.* This makes things significantly worse, because it means you really can get N - 1 for large N in a non-pathological case (i.e. removing most or all of the contents of a directory, but not rmdir&#x27;ing the directory itself).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891000/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor891059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 12:42 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/891059/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Typically, when we characterize the performance of a hash table, we assume that it has some maximum fullness. That is, if there are N buckets, then we assume that there are at most kN elements in the hash table (for some k with, in most cases, 0 &lt; k &lt; 1); if the hash table grows larger than that, it gets rebuilt with more buckets.</font><br>
<p>
Or you use a modern hash algorithm like, dare I say it, Pick has used for the last 40 years ... I believe it&#x27;s the same one as used by Python and Sleepycat/Berkeley amongst others.<br>
<p>
<a href="https://en.wikipedia.org/wiki/Linear_hashing">https://en.wikipedia.org/wiki/Linear_hashing</a><br>
<p>
tldr;<br>
Given 2^(n-1) &lt; N &lt;= 2^n, if mod(2^n) gives a valid bucket use that otherwise use mod(2^(n-1)). When creating a new bucket N+1, all the records that belong in the new bucket will currently be in bucket (N+1)mod(2^(n-1)), so the cost of growing the hash table by one bucket at a time is constant. So the hash table can be kept at optimal fullness with minimal cost.<br>
<p>
And being a hash table, you can return a definitive yes/no just by scanning the one bucket.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 19:26 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/891092/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And being a hash table, you can return a definitive yes/no just by scanning the one bucket.</font><br>
<p>
You have entirely missed the point. We&#x27;re not trying to figure out whether the bucket is occupied, we&#x27;re trying to find its nearest occupied neighbors so that we can find an empty range of buckets. That requires a linear scan over neighboring buckets.<br>
<p>
Furthermore, if you allow deletions, then a linearly-growing hash table does not help, because you can grow the hash table to be huge, and then depopulate it (e.g. by making lots of entries in a directory, then removing them).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 20:54 UTC (Tue)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/891098/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; We&#x27;re not trying to figure out whether the bucket is occupied, we&#x27;re trying to find its nearest occupied neighbors so that we can find an empty range of buckets.</font><br>
<p>
Actually, now that I thought about it better, not even that might be necessary. A hash bucket itself is already a &quot;range&quot; of directory entries, since it being empty means that none of the entries hashing to that bucket are present. Since the number of hash buckets is limited, that could be enough to limit the number of negative &quot;ranges&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 21:09 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/891099/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, you can do that, but it buys you less than you think:<br>
<p>
* Under open addressing (linear/quadratic probing, cuckoo hashing, etc.), the number of buckets must be greater than the number of dentries, and for performance reasons, it should be significantly greater.<br>
* Under closed addressing (separate chaining), the number of dentries cannot be much more than a small (constant) multiple of the number of buckets, or performance suffers.<br>
<p>
In both cases: Assuming the hash function is a quasi-random oracle, the probability of a hash collision should be quite low, and should become lower as the hash table grows (so that the average number of collisions that each dentry suffers remains bounded above). A cached negative dentry range consisting of a single hash bucket will only help you for other dentries that would have collided with that bucket, which should not be very many in practice, or else the hash function is bad.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor891102"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 21:42 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/891102/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You have entirely missed the point. We&#x27;re not trying to figure out whether the bucket is occupied, we&#x27;re trying to find its nearest occupied neighbors so that we can find an empty range of buckets. That requires a linear scan over neighboring buckets.</font><br>
<p>
Except you completely missed the point I was responding to. cesarb was talking about a hashed directory, and not a cache.<br>
<p>
And in that case, there are NO empty buckets (if you want to use that particular variant of hashing). The variant I&#x27;m used to sticks multiple entries per bucket, but there&#x27;s a variant that has exactly as many buckets as entries, and one entry per bucket.<br>
<p>
And just as it&#x27;s very quick and easy to grow the table, it&#x27;s just as easy to shrink it - the entire bucket you&#x27;re getting rid of just tags on the end of the bucket the (now invalid) old hash hashes to.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891102/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2022 3:00 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/891111/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If every bucket is occupied, then there are no empty buckets to cache.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor891014"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 9:16 UTC (Tue)
                               by <b>pomac</b> (subscriber, #94901)
                              [<a href="/Articles/891014/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You don&#x27;t really want to make things exhaustive... Imagine having users creating single directories with millions of files.<br>
<p>
It&#x27;s already a DoS in terms of memory due to how Linux works but enumerating them all with caches... Nah.. ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891014/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891323"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2022 11:44 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/891323/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You don&#x27;t really want to make things exhaustive... Imagine having users creating single directories with millions of files.</font><br>
<p>
Maildirs do this routinely. It&#x27;s amazing how much trouble it causes (to backup programs in particular, since they have to enumerate every inode in the directory to figure out which ones changed). (INN news tradspools do it too, but they&#x27;re not per-user and they&#x27;re relatively rarely backed up at all.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891323/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor890991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 22:13 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/890991/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
By all means try to implement this, but I think it&#x27;ll be vastly inferior to the current dcache.<br>
<p>
Lookup is currently hash(directory pointer, component) and search the global hash table. What you&#x27;re proposing would be a per-directory data structure to search, so a massive change.<br>
<p>
Also, you&#x27;d need to be able to query the filesystem for the &quot;previous&quot; and &quot;next&quot; entries ... for whatever sort you think needs to be used (filesystem directories are not necessarily sorted in any way you think they are).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor890994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 23:30 UTC (Mon)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/890994/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; By all means try to implement this, but I think it&#x27;ll be vastly inferior to the current dcache.</font><br>
<p>
I don&#x27;t doubt that it would be inferior; still, it&#x27;s an interesting thought experiment.<br>
<p>
<font class="QuotedText">&gt; Lookup is currently hash(directory pointer, component) and search the global hash table. What you&#x27;re proposing would be a per-directory data structure to search, so a massive change.</font><br>
<p>
Actually, it could be a per-filesystem data structure, if the concept of range is extended to include the parent directory; but it would have to be something like hash(directory pointer) || key(component), with the definition of key() depending on the filesystem&#x27;s native on-disk order (if it has one; naïve filesystems with simple unsorted directories could use hash(component) for the key). I agree that it would be a massive change, with potential gains only on an unlikely case (a large amount of lookups to non-existing entries, which could be hits on a negative range cache but would be misses on a negative entry cache).<br>
<p>
<font class="QuotedText">&gt; Also, you&#x27;d need to be able to query the filesystem for the &quot;previous&quot; and &quot;next&quot; entries ... for whatever sort you think needs to be used (filesystem directories are not necessarily sorted in any way you think they are).</font><br>
<p>
Yes, the sort would have to be filesystem-specific; I went into more detail on another comment above.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor890992"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 22:26 UTC (Mon)
                               by <b>MattBBaker</b> (guest, #28651)
                              [<a href="/Articles/890992/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems like there is also a question of how valuable each dentry, negative or not, really is. A lookup on a local SSD is going to be a lot easier on the system if you get the policy wrong than will a bad decision on a NFS filesystem. Is there a way to track the amount of time it took to generate the dentry, and then trash the cheaper ones and keep the more expensive ones?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890992/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891011"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 7:45 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/891011/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Is there a way to track the amount of time it took to generate the dentry, and then trash the cheaper ones and keep the more expensive ones?</font><br>
<p>
That seems like a useful heuristic to weight entries, if you also take into account the number of lookups.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891011/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor890997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2022 23:54 UTC (Mon)
                               by <b>vgoyal</b> (subscriber, #49279)
                              [<a href="/Articles/890997/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Controlling the size of dentry cache without memory pressure can help us in one of the problems we face with virtiofs. As dentry cache is growing, it keeps inodes around, that means it keeps corresponding data structures around in virtiofs daemon. And it keeps O_PATH fd per inode on server. And soon we run out of number of open fd a process can have. If guest has good amount of RAM, it can cache lot of dentries/inodes without memory pressure and create problems for virtiofs daemon. Some notion/knob of controlling the size of dentry cache without memory pressure can possibly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor891005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 4:39 UTC (Tue)
                               by <b>benjamir</b> (subscriber, #133607)
                              [<a href="/Articles/891005/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn&#x27;t the number of open files (sometimes) user defined?<br>
Why not depend on that (in fractions or multiples)?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891080"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 16:06 UTC (Tue)
                               by <b>vgoyal</b> (subscriber, #49279)
                              [<a href="/Articles/891080/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We indeed raise open file limit to 1M by default. But that requires CAP_SYS_RESOURCE. We also have been looking at running virtiofsd unprivileged and don&#x27;t have CAP_SYS_RESOURCE and hence can&#x27;t raise the limit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891080/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor891010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 7:26 UTC (Tue)
                               by <b>dgc</b> (subscriber, #6611)
                              [<a href="/Articles/891010/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi Jon,<br>
<p>
More discussion of the periodic reclaim concept for controlling cache explosions can be found under this thread:<br>
<p>
<a href="https://lwn.net/ml/linux-mm/20220402072103.5140-1-hdanton%40sina.com/">https://lwn.net/ml/linux-mm/20220402072103.5140-1-hdanton...</a><br>
<p>
-Dave.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor891058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Negative dentries, 20 years later</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 12:04 UTC (Tue)
                               by <b>aaronmdjones</b> (subscriber, #119973)
                              [<a href="/Articles/891058/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As it happens, repeated attempts to look up a nonexistent file are also common; an example would be the shell&#x27;s process of working through the search path every time a user types &quot;vi&quot; (Emacs users start the editor once and never leave its cozy confines thereafter, so they don&#x27;t benefit in the same way).</font><br>
<p>
It could also be argued that vi users don&#x27;t benefit either, because they can&#x27;t figure out how to close it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891078"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Intuitive ways to exit text editors</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2022 15:50 UTC (Tue)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/891078/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>It can be hard to get out of emacs too, sometimes.  The emergency cheat-sheet:
<p>vi: <tt>Esc Esc Esc :q!</tt>
<p>emacs: <tt>Ctrl-G Ctrl-G Ctrl-G Ctrl-X Ctrl-C</tt>






      
          <div class="CommentReplyButton">
            <form action="/Articles/891078/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891275"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Intuitive ways to exit text editors</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2022 23:50 UTC (Wed)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/891275/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; emacs: Ctrl-G Ctrl-G Ctrl-G Ctrl-X Ctrl-C</font><br>
<p>
This actually doesn&#x27;t work for me ..... because I deliberately disabled it as I was somehow typing it accidentally.<br>
Now I use : alt-x k i l l - e m a c s enter<br>
I haven&#x27;t yet typed that by mistake.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891275/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891301"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Intuitive ways to exit text editors</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2022 7:40 UTC (Thu)
                               by <b>SiB</b> (subscriber, #4048)
                              [<a href="/Articles/891301/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My way of starting emacs is `emacsclient -c -d &quot;$DISPLAY&quot; --alternate-editor=&#x27;&#x27; &quot;$1&quot;`<br>
<p>
That has the same effect on how to kill the emacs process.  Ctrl-X Ctrl-C just closes the frame.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891301/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor891678"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Intuitive ways to exit text editors</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 17, 2022 22:59 UTC (Sun)
                               by <b>Spack</b> (subscriber, #77556)
                              [<a href="/Articles/891678/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
CTRL+Z<br>
$ killall emacs vi<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891678/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor891749"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Intuitive ways to exit text editors</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2022 20:41 UTC (Mon)
                               by <b>Jandar</b> (subscriber, #85683)
                              [<a href="/Articles/891749/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  CTRL+Z</font><br>
<font class="QuotedText">&gt; $ killall emacs vi</font><br>
<p>
Neither vi in insert-mode nor emacs in x11 mode stops with CTRL-Z ;-)<br>
<p>
vi inserts the CTRL-Z and emacs executes suspend-frame.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/891749/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
