        <!DOCTYPE html>
        <html lang="en">
        <head><title>Integrating and Validating dynticks and Preemptable RCU [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/279077/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/278495/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/279077/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Integrating and Validating dynticks and Preemptable RCU</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="GAByline">
           <p>April 22, 2008</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
<h3>Introduction</h3>

<p>Read-copy update (RCU) is a synchronization mechanism that was added to
the Linux kernel in October of 2002.
RCU is most frequently described as a replacement for reader-writer locking,
but it has also been used in a number of other ways.
RCU is notable in that RCU readers do not directly synchronize with
RCU updaters,
which makes RCU read paths extremely fast, and also
permits RCU readers to accomplish useful work even
when running concurrently with RCU updaters.

</p><p>In early 2008, a preemptable variant of RCU was accepted into
mainline Linux in support of real-time workloads, a variant similar
to the RCU implementations in
<A HREF="http://www.kernel.org/pub/linux/kernel/projects/rt/">
the -rt patchset</A>
since August 2005.
Preemptable RCU is needed for real-time workloads because older
RCU implementations disable preemption across RCU read-side
critical sections, resulting in excessive real-time latencies.
<p>
However, one disadvantage of the -rt implementation was that each grace period
required work to be done on each CPU, even if that CPU is in a low-power
&ldquo;dynticks-idle&rdquo; state,
and thus incapable of executing RCU read-side critical sections.
The idea behind the dynticks-idle state is that idle CPUs
should be physically powered down in order to conserve energy.
In short, preemptable RCU can disable a valuable energy-conservation
feature of recent Linux kernels.
Although Josh Triplett and Paul McKenney
had discussed some approaches for allowing
CPUs to remain in low-power state throughout an RCU grace period
(thus preserving the Linux kernel's ability to conserve energy), matters
did not come to a head until Steve Rostedt integrated a new dyntick
implementation with preemptable RCU in the -rt patchset.

</p><p>This combination caused one of Steve's systems to hang on boot, so in
October, Paul coded up a dynticks-friendly modification to preemptable RCU's
grace-period processing.
Steve coded up <code>rcu_irq_enter()</code> and <code>rcu_irq_exit()</code>
interfaces called from the
<code>irq_enter()</code> and <code>irq_exit()</code> interrupt
entry/exit functions.
These <code>rcu_irq_enter()</code> and <code>rcu_irq_exit()</code>
functions are needed to allow RCU to reliably handle situations where
a dynticks-idle CPUs is momentarily powered up for an interrupt
handler containing RCU read-side critical sections.
With these changes in place, Steve's system booted reliably,
but Paul continued inspecting the code periodically on the assumption
that we could not possibly have gotten the code right on the first try.

</p><p>Paul reviewed the code repeatedly from October 2007 to February 2008,
and almost always found at least one bug.
In one case, Paul even coded and tested a fix before realizing that the
bug was illusory, but in all cases, the &ldquo;bug&rdquo; was in
fact illusory.

</p><p>Near the end of February, Paul grew tired of this game.
He therefore decided to enlist the aid of
<A HREF="http://spinroot.com/spin/whatispin.html">Promela and spin</A>,
as described in the LWN article
<A HREF="http://lwn.net/Articles/243851/">
Using Promela and Spin to verify parallel algorithms</A>.
This article presents a series of seven increasingly realistic
Promela models, the last of which passes, consuming about
40GB of main memory for the state space.

</p>
<div class="tlrw">
<a name="Quick Quiz 1"><b>Quick Quiz 1</b>:</a>
Yeah, that's great!!!
Now, just what am I supposed to do if I don't happen to have a machine with
40GB of main memory???
</div>
<p>More important, Promela and Spin did find a very subtle bug for me!!!

</p>

<p>This article is organized as follows:

</p><ol>
<li>	<a href="#Introduction to Preemptable RCU and dynticks">
	Introduction to Preemptable RCU and dynticks</a>
	<ol>
	<li>	<a href="#Task Interface">Task Interface</a>
	</li><li>	<a href="#Interrupt Interface">Interrupt Interface</a>
	</li><li>	<a href="#Grace-Period Interface">
			Grace-Period Interface</a>
	</li></ol>
</li><li>	<a href="#Validating Preemptable RCU and dynticks">
		Validating Preemptable RCU and dynticks</a>
	<ol>
	<li>	<a href="#Basic Model">Basic Model</a>
	</li><li>	<a href="#Validating Safety">Validating Safety</a>
	</li><li>	<a href="#Validating Liveness">Validating Liveness</a>
	</li><li>	<a href="#Interrupts">Interrupts</a>
	</li><li>	<a href="#Validating Interrupt Handlers">
			Validating Interrupt Handlers</a>
	</li><li>	<a href="#Validating Nested Interrupt Handlers">
			Validating Nested Interrupt Handlers</a>
	</li><li>	<a href="#Validating NMI Handlers">
			Validating NMI Handlers</a>
	</li></ol>
</li></ol>

<p>These sections are followed by
<a href="#Conclusions">conclusions</a> and
<a href="#Answers%20to%20Quick%20Quizzes">answers to the Quick Quizzes</a>.

</p><h3><a name="Introduction to Preemptable RCU and dynticks">
Introduction to Preemptable RCU and dynticks</a></h3>

<p>The per-CPU <code>dynticks_progress_counter</code> variable is
central to the interface between dynticks and preemptable RCU.
This variable has an even value whenever the corresponding CPU
is in dynticks-idle mode, and an odd value otherwise.
A CPU exits dynticks-idle mode for the following three reasons:

</p><ol>
<li>	to start running a task,</li>
<li>	when entering the outermost of a possibly nested set of interrupt
	handlers, and</li>
<li>	when entering an NMI handler.
</ol>

<p>Preemptable RCU's grace-period machinery samples the value of
the <code>dynticks_progress_counter</code> variable in order to
determine when a dynticks-idle CPU may safely be ignored.

</p><p>The following three sections give an overview of the task
interface, the interrupt/NMI interface, and the use of
the <code>dynticks_progress_counter</code> variable by the
grace-period machinery.

</p><h4><a name="Task Interface">
Task Interface</a></h4>

<p>When a given CPU enters dynticks-idle mode because it has no more
tasks to run, it invokes <code>rcu_enter_nohz()</code>:

</p><pre>  1 static inline void rcu_enter_nohz(void)
  2 {
  3   mb();
  4   __get_cpu_var(dynticks_progress_counter)++;
  5   WARN_ON(__get_cpu_var(dynticks_progress_counter) &amp; 0x1);
  6 }
</pre>

<p>This function simply increments <code>dynticks_progress_counter</code> and
checks that the result is even, but first executing a memory barrier
to ensure that any other CPU that sees the new value of
<code>dynticks_progress_counter</code> will also see the completion
of any prior RCU read-side critical sections.

</p><p>Similarly, when a CPU that is in dynticks-idle mode prepares to
start executing a newly runnable task, it invokes
<code>rcu_exit_nohz</code>:

</p><pre>  1 static inline void rcu_exit_nohz(void)
  2 {
  3   __get_cpu_var(dynticks_progress_counter)++;
  4   mb();
  5   WARN_ON(!(__get_cpu_var(dynticks_progress_counter) &amp; 0x1));
  6 }
</pre>

<p>This function again increments <code>dynticks_progress_counter</code>,
but follows it with a memory barrier to ensure that if any other CPU
sees the result of any subsequent RCU read-side critical section,
then that other CPU will also see the incremented value of
<code>dynticks_progress_counter</code>.
Finally, <code>rcu_exit_nohz()</code> checks that the result of the
increment is an odd value.

</p><p>The <code>rcu_enter_nohz()</code> and <code>rcu_exit_nohz</code>
functions handle the case where a CPU enters and exits dynticks-idle
mode due to task execution, but does not handle interrupts, which are
covered in the following section.

</p><h4><a name="Interrupt Interface">
Interrupt Interface</a></h4>

<p>The <code>rcu_irq_enter()</code> and <code>rcu_irq_exit()</code>
functions handle interrupt/NMI entry and exit, respectively.
Of course, nested interrupts must also be properly accounted for.
The possibility of nested interrupts is handled by a second per-CPU
variable, <code>rcu_update_flag</code>, which is incremented upon
entry to an interrupt or NMI handler (in <code>rcu_irq_enter()</code>)
and is decremented upon exit (in <code>rcu_irq_exit()</code>).
In addition, the pre-existing <code>in_interrupt()</code> primitive is
used to distinguish between an outermost or a nested interrupt/NMI.

</p><p>Interrupt entry is handled by the <code>rcu_irq_enter</code>
shown below:

</p><pre>  1 void rcu_irq_enter(void)
  2 {
  3   int cpu = smp_processor_id();
  4 
  5   if (per_cpu(rcu_update_flag, cpu))
  6     per_cpu(rcu_update_flag, cpu)++;
  7   if (!in_interrupt() &amp;&amp;
  8       (per_cpu(dynticks_progress_counter, cpu) &amp; 0x1) == 0) {
  9     per_cpu(dynticks_progress_counter, cpu)++;
 10     smp_mb();
 11     per_cpu(rcu_update_flag, cpu)++;
 12   }
 13 }
</pre>

<p>
<div class="tlrw">
<a name="Quick Quiz 2"><b>Quick Quiz 2</b>:</a>
Why not simply increment <code>rcu_update_flag</code>, and then only
increment <code>dynticks_progress_counter</code> if the old value
of <code>rcu_update_flag</code> was zero???
<p>
<a name="Quick Quiz 3"><b>Quick Quiz 3</b>:</a>
But if line&nbsp;7 finds that we are the outermost interrupt, wouldn't
we <i>always</i> need to increment <code>dynticks_progress_counter</code>?
</div>
Line&nbsp;3 fetches the current CPU's number, while lines&nbsp;4 and 5
increment the <code>rcu_update_flag</code> nesting counter if it
is already non-zero.
Lines&nbsp;6 and 7 check to see whether we are the outermost level of
interrupt, and, if so, whether <code>dynticks_progress_counter</code>
needs to be incremented.
If so, line&nbsp;9 increments <code>dynticks_progress_counter</code>,
line&nbsp;10 executes a memory barrier, and line&nbsp;11 increments
<code>rcu_update_flag</code>.
As with <code>rcu_exit_nohz()</code>, the memory barrier ensures that
any other CPU that sees the effects of an RCU read-side critical section
in the interrupt handler (following the <code>rcu_irq_enter()</code>
invocation) will also see the increment of
<code>dynticks_progress_counter</code>.

</p>

<p>Interrupt entry is handled similarly by
<code>rcu_irq_exit()</code>:

</p><pre>  1 void rcu_irq_exit(void)
  2 {
  3   int cpu = smp_processor_id();
  4 
  5   if (per_cpu(rcu_update_flag, cpu)) {
  6     if (--per_cpu(rcu_update_flag, cpu))
  7       return;
  8     WARN_ON(in_interrupt());
  9     smp_mb();
 10     per_cpu(dynticks_progress_counter, cpu)++;
 11     WARN_ON(per_cpu(dynticks_progress_counter, cpu) &amp; 0x1);
 12   }
 13 }
</pre>

<p>Line&nbsp;3 fetches the current CPU's number, as before.
Line&nbsp;5 checks to see if the <code>rcu_update_flag</code> is
non-zero, returning immediately (via falling off the end of the
function) if not.
Otherwise, lines&nbsp;6 through 11 come into play.
Line&nbsp;6 decrements <code>rcu_update_flag</code>, returning
if the result is not zero.
Line&nbsp;8 verifies that we are indeed leaving the outermost
level of nested interrupts, line&nbsp;9 executes a memory barrier,
line&nbsp;10 increments <code>dynticks_progress_counter</code>,
and line&nbsp;11 verifies that this variable is now even.
As with <code>rcu_enter_nohz()</code>, the memory barrier ensures that
any other CPU that sees the increment of
<code>dynticks_progress_counter</code>
will also see the effects of an RCU read-side critical section
in the interrupt handler (preceding the <code>rcu_irq_enter()</code>
invocation).

</p><p>These two sections have described how the
<code>dynticks_progress_counter</code> variable is maintained during
entry to and exit from dynticks-idle mode, both by tasks and by
interrupts and NMIs.
The following section describes how this variable is used by
preemptable RCU's grace-period machinery.

</p><h4><a name="Grace-Period Interface">
Grace-Period Interface</a></h4>

<p>Of the four preemptable RCU grace-period states shown below
(taken from <A HREF="http://lwn.net/Articles/253651/">
The Design of Preemptable Read-Copy Update</A>),
only the <code>rcu_try_flip_waitack_state()</code>
and <code>rcu_try_flip_waitmb_state()</code> states need to wait
for other CPUs to respond.

</p><p><blockquote>
<img src="https://static.lwn.net/images/ns/kernel/RCUpreemptStates.png" 
alt="Preemptable RCU State Diagram" width=487 height=566>
</blockquote>

</p><p>Of course, if a given CPU is in dynticks-idle state, we shouldn't
wait for it.
Therefore, just before entering one of these two states,
the preceding state takes a snapshot of each CPU's
<code>dynticks_progress_counter</code> variable, placing the
snapshot in another per-CPU variable,
<code>rcu_dyntick_snapshot</code>.
This is accomplished by invoking
<code>dyntick_save_progress_counter</code>, shown below:

</p><pre>  1 static void dyntick_save_progress_counter(int cpu)
  2 {
  3   per_cpu(rcu_dyntick_snapshot, cpu) =
  4     per_cpu(dynticks_progress_counter, cpu);
  5 }
</pre>

<p>The <code>rcu_try_flip_waitack_state()</code> state invokes
<code>rcu_try_flip_waitack_needed()</code>, shown below:
 
</p><pre>  1 static inline int
  2 rcu_try_flip_waitack_needed(int cpu)
  3 {
  4   long curr;
  5   long snap;
  6 
  7   curr = per_cpu(dynticks_progress_counter, cpu);
  8   snap = per_cpu(rcu_dyntick_snapshot, cpu);
  9   smp_mb(); /* force ordering with cpu entering/leaving dynticks. */
 10   if ((curr == snap) &amp;&amp; ((curr &amp; 0x1) == 0))
 11     return 0;
 12   if ((curr - snap) &gt; 2 || (snap &amp; 0x1) == 0)
 13     return 0;
 14   return 1;
 15 }
</pre>

<p>Lines&nbsp;7 and 8 pick up current and snapshot versions of
<code>dynticks_progress_counter</code>, respectively.
The memory barrier on line&nbsp;ensures that the counter checks
in the later <code>rcu_try_flip_waitzero_state</code> follow
the fetches of these counters.
Lines&nbsp;10 and 11 return zero (meaning no communication with the
specified CPU is required) if that CPU has remained in dynticks-idle
state since the time that the snapshot was taken.
Similarly, lines&nbsp;12 and 13 return zero if that CPU was initially
in dynticks-idle state or if it has completely passed through a
dynticks-idle state.
In both these cases, there is no way that that CPU could have retained
the old value of the grace-period counter.
If neither of these conditions hold, line&nbsp;14 returns one, meaning
that the CPU needs to explicitly respond.

</p><p>For its part, the <code>rcu_try_flip_waitmb_state</code> state
invokes <code>rcu_try_flip_waitmb_needed()</code>, shown below:

</p><pre>  1 static inline int
  2 rcu_try_flip_waitmb_needed(int cpu)
  3 {
  4   long curr;
  5   long snap;
  6 
  7   curr = per_cpu(dynticks_progress_counter, cpu);
  8   snap = per_cpu(rcu_dyntick_snapshot, cpu);
  9   smp_mb(); /* force ordering with cpu entering/leaving dynticks. */
 10   if ((curr == snap) &amp;&amp; ((curr &amp; 0x1) == 0))
 11     return 0;
 12   if (curr != snap)
 13     return 0;
 14   return 1;
 15 }
</pre>

<p>This is quite similar to <code>rcu_try_flip_waitack_needed</code>,
the difference being in lines&nbsp;12 and 13, because any transition
either to or from dynticks-idle state executes the memory barrier
needed by the <code>rcu_try_flip_waitmb_state()</code> state.

</p>
<div class="tlrw">
<a name="Quick Quiz 4"><b>Quick Quiz 4</b>:</a>
Can you spot any bugs in any of the code in this section?
</div>
<p>We now have seen all the code involved in the interface between
RCU and the dynticks-idle state.
The next section builds up the Promela model used to validate this
code.

</p>

<h3><a name="Validating Preemptable RCU and dynticks">
Validating Preemptable RCU and dynticks</a></h3>

<p>This section develops a Promela model for the interface between
dynticks and RCU step by step, with each of the following sections
illustrating one step, starting with the process-level code,
adding assertions, interrupts, and finally NMIs.

</p><h4><a name="Basic Model">
Basic Model</a></h4>

<p>This section translates the process-level dynticks entry/exit
code and the grace-period processing into
Promela.
We start with <code>rcu_exit_nohz()</code> and
<code>rcu_enter_nohz()</code>
from the 2.6.25-rc4 kernel, placing these in a single Promela
process that models exiting and entering dynticks-idle mode in
a loop as follows:

</p><pre>  1 proctype dyntick_nohz()
  2 {
  3   byte tmp;
  4   byte i = 0;
  5 
  6   do
  7   :: i &gt;= MAX_DYNTICK_LOOP_NOHZ -&gt; break;
  8   :: i &lt; MAX_DYNTICK_LOOP_NOHZ -&gt;
  9     tmp = dynticks_progress_counter;
 10     atomic {
 11       dynticks_progress_counter = tmp + 1;
 12       assert((dynticks_progress_counter &amp; 1) == 1);
 13     }
 14     tmp = dynticks_progress_counter;
 15     atomic {
 16       dynticks_progress_counter = tmp + 1;
 17       assert((dynticks_progress_counter &amp; 1) == 0);
 18     }
 19     i++;
 20   od;
 21 }
</pre>

<p>Lines&nbsp;6 and 20 define a loop.
Line&nbsp;7 exits the loop once the loop counter <code>i</code>
has exceeded the limit <code>MAX_DYNTICK_LOOP_NOHZ</code>.
Line&nbsp;8 tells the loop construct to execute lines&nbsp;9-19
for each pass through the loop.
Because the conditionals on lines&nbsp;7 and 8 are exclusive of
each other, the normal Promela random selection of true conditions
is disabled.
Lines&nbsp;9 and 11 model <code>rcu_exit_nohz()</code>'s non-atomic
increment of <code>dynticks_progress_counter</code>, while
line 12 models the <code>WARN_ON()</code>.
The <code>atomic</code> construct simply reduces the Promela state space,
given that the <code>WARN_ON()</code> is not strictly speaking part
of the algorithm.
Lines&nbsp;14-18 similarly models the increment and
<code>WARN_ON()</code> for <code>rcu_enter_nohz()</code>.
Finally, line&nbsp;19 increments the loop counter.

</p>
<div class="tlrw">
<a name="Quick Quiz 5"><b>Quick Quiz 5</b>:</a>
Why isn't the memory barrier in <code>rcu_exit_nohz()</code>
and <code>rcu_enter_nohz()</code> modeled in Promela?
<p>
<a name="Quick Quiz 6"><b>Quick Quiz 6</b>:</a>
Isn't it a bit strange to model <code>rcu_exit_nohz()</code>
followed by <code>rcu_enter_nohz()</code>?
Wouldn't it be more natural to instead model entry before exit?
</div>

<p>Each pass through the loop therefore models a CPU exiting
dynticks-idle mode (for example, starting to execute a task), then
re-entering dynticks-idle mode (for example, that same task blocking).

</p>
<p>The next step is to model the interface to RCU's grace-period
processing.
For this, we need to model
<code>dyntick_save_progress_counter()</code>,
<code>rcu_try_flip_waitack_needed()</code>,
<code>rcu_try_flip_waitmb_needed()</code>,
as well as portions of
<code>rcu_try_flip_waitack()</code> and
<code>rcu_try_flip_waitmb()</code>, all from the 2.6.25-rc4 kernel.
The following <code>grace_period()</code> Promela process models
these functions as they would be invoked during a single pass
through preemptable RCU's grace-period processing.

</p><pre>  1 proctype grace_period()
  2 {
  3   byte curr;
  4   byte snap;
  5 
  6   atomic {
  7     printf("MAX_DYNTICK_LOOP_NOHZ = %d\n", MAX_DYNTICK_LOOP_NOHZ);
  8     snap = dynticks_progress_counter;
  9   }
 10   do
 11   :: 1 -&gt;
 12     atomic {
 13       curr = dynticks_progress_counter;
 14       if
 15       :: (curr == snap) &amp;&amp; ((curr &amp; 1) == 0) -&gt;
 16         break;
 17       :: (curr - snap) &gt; 2 || (snap &amp; 1) == 0 -&gt;
 18         break;
 19       :: 1 -&gt; skip;
 20       fi;
 21     }
 22   od;
 23   snap = dynticks_progress_counter;
 24   do
 25   :: 1 -&gt;
 26     atomic {
 27       curr = dynticks_progress_counter;
 28       if
 29       :: (curr == snap) &amp;&amp; ((curr &amp; 1) == 0) -&gt;
 30         break;
 31       :: (curr != snap) -&gt;
 32         break;
 33       :: 1 -&gt; skip;
 34       fi;
 35     }
 36   od;
 37 }
</pre>

<p>Lines&nbsp;6-9 print out the loop limit (but only into the .trail file
in case of error) and model a line of code
from <code>rcu_try_flip_idle()</code> and its call to
<code>dyntick_save_progress_counter()</code>, which takes a
snapshot of the current CPU's <code>dynticks_progress_counter</code>
variable.
These two lines are executed atomically to reduce state space.

</p><p>Lines&nbsp;10-22 model the relevant code in
<code>rcu_try_flip_waitack()</code> and its call to
<code>rcu_try_flip_waitack_needed()</code>.
This loop is modeling the grace-period state machine waiting for
a counter-flip acknowledgment from each CPU, but only that part
that interacts with dynticks-idle CPUs.

</p><p>Line&nbsp;23 models a line from <code>rcu_try_flip_waitzero()</code>
and its call to <code>dyntick_save_progress_counter()</code>, again
taking a snapshot of the CPU's <code>dynticks_progress_counter</code>
variable.

</p><p>Finally, lines&nbsp;24-36 model the relevant code in
<code>rcu_try_flip_waitack()</code> and its call to
<code>rcu_try_flip_waitack_needed()</code>.
This loop is modeling the grace-period state-machine waiting for
each CPU to execute a memory barrier, but again only that part
that interacts with dynticks-idle CPUs.

</p><p>
</p><div class="tlrw">
<a name="Quick Quiz 7"><b>Quick Quiz 7</b>:</a>
Wait a minute!
In the Linux kernel, both <code>dynticks_progress_counter</code> and
<code>rcu_dyntick_snapshot</code> are per-CPU variables.
So why are they instead being modeled as single global variables?
</div>

<p>The resulting
<A HREF="/Articles/279091/">model</A>,
when run with the
<A HREF="/Articles/279092/">runspin.sh</A> script,
generates 691 states and
passes without errors, which is not at all surprising given that
it completely lacks the assertions that could find failures.
The next section therefore adds safety assertions.

</p><h4><a name="Validating Safety">
Validating Safety</a></h4>

<p>A safe RCU implementation must never permit a grace period to
complete before the completion of any RCU readers that started
before the start of the grace period.
This is modeled by a <code>grace_period_state</code> variable that
can take on three states as follows:
 
</p><pre>  1 #define GP_IDLE    0
  2 #define GP_WAITING  1
  3 #define GP_DONE    2
  4 byte grace_period_state = GP_DONE;
</pre>

<p>The <code>grace_period()</code> process sets this variable as it
progresses through the grace-period phases, as shown below:

</p><pre>  1 proctype grace_period()
  2 {
  3   byte curr;
  4   byte snap;
  5 
  6   grace_period_state = GP_IDLE;
  7   atomic {
  8     printf("MAX_DYNTICK_LOOP_NOHZ = %d\n", MAX_DYNTICK_LOOP_NOHZ);
  9     snap = dynticks_progress_counter;
 10     grace_period_state = GP_WAITING;
 11   }
 12   do
 13   :: 1 -&gt;
 14     atomic {
 15       curr = dynticks_progress_counter;
 16       if
 17       :: (curr == snap) &amp;&amp; ((curr &amp; 1) == 0) -&gt;
 18         break;
 19       :: (curr - snap) &gt; 2 || (snap &amp; 1) == 0 -&gt;
 20         break;
 21       :: 1 -&gt; skip;
 22       fi;
 23     }
 24   od;
 25   grace_period_state = GP_DONE;
 26   grace_period_state = GP_IDLE;
 27   atomic {
 28     snap = dynticks_progress_counter;
 29     grace_period_state = GP_WAITING;
 30   }
 31   do
 32   :: 1 -&gt;
 33     atomic {
 34       curr = dynticks_progress_counter;
 35       if
 36       :: (curr == snap) &amp;&amp; ((curr &amp; 1) == 0) -&gt;
 37         break;
 38       :: (curr != snap) -&gt;
 39         break;
 40       :: 1 -&gt; skip;
 41       fi;
 42     }
 43   od;
 44   grace_period_state = GP_DONE;
 45 }
</pre>

<p>
<div class="tlrw">
<a name="Quick Quiz 8"><b>Quick Quiz 8</b>:</a>
Given there are a pair of back-to-back changes to
<code>grace_period_state</code> on lines&nbsp;25 and 26,
how can we be sure that line&nbsp;25's changes won't be lost?
</div>

Lines&nbsp;6, 10, 25, 26, 29, and 44 update this variable (combining
atomically with algorithmic operations where feasible) to
allow the <code>dyntick_nohz()</code> process to validate the basic
RCU safety property.
The form of this validation is to assert that the value of the
<code>grace_period_state</code> variable cannot jump from
<code>GP_IDLE</code> to <code>GP_DONE</code> during a time period
over which RCU readers could plausibly persist.

</p>
<p>The <code>dyntick_nohz()</code> Promela process implements
this validation as shown below:

</p><pre>  1 proctype dyntick_nohz()
  2 {
  3   byte tmp;
  4   byte i = 0;
  5   bit old_gp_idle;
  6 
  7   do
  8   :: i &gt;= MAX_DYNTICK_LOOP_NOHZ -&gt; break;
  9   :: i &lt; MAX_DYNTICK_LOOP_NOHZ -&gt;
 10     tmp = dynticks_progress_counter;
 11     atomic {
 12       dynticks_progress_counter = tmp + 1;
 13       old_gp_idle = (grace_period_state == GP_IDLE);
 14       assert((dynticks_progress_counter &amp; 1) == 1);
 15     }
 16     atomic {
 17       tmp = dynticks_progress_counter;
 18       assert(!old_gp_idle || grace_period_state != GP_DONE);
 19     }
 20     atomic {
 21       dynticks_progress_counter = tmp + 1;
 22       assert((dynticks_progress_counter &amp; 1) == 0);
 23     }
 24     i++;
 25   od;
 26 }
</pre>

<p>Line&nbsp;13 sets a new <code>old_gp_idle</code> flag if the
value of the <code>grace_period_state</code> variable is
<code>GP_IDLE</code> at the beginning of task execution,
and the assertion at line&nbsp;18 fires if the <code>grace_period_state</code>
variable has advanced to <code>GP_DONE</code> during task execution,
which would be illegal given that a single RCU read-side critical
section could span the entire intervening time period.

</p><p>The resulting
<A HREF="/Articles/279094/">model</A>,
when run with the runspin.sh script,
generates 964 states and passes without errors, which is reassuring.
That said, although safety is critically important, it is also quite
important to avoid indefinitely stalling grace periods.
The next section therefore covers validating liveness.

</p><h4><a name="Validating Liveness">
Validating Liveness</a></h4>

<p>Although liveness can be difficult to prove, there is a simple
trick that applies here.
The first step is to make <code>dyntick_nohz()</code> indicate that
it is done via a <code>dyntick_nohz_done</code> variable, as shown on
line&nbsp;26 of the following:
 
</p><pre>  1 proctype dyntick_nohz()
  2 {
  3   byte tmp;
  4   byte i = 0;
  5   bit old_gp_idle;
  6 
  7   do
  8   :: i &gt;= MAX_DYNTICK_LOOP_NOHZ -&gt; break;
  9   :: i &lt; MAX_DYNTICK_LOOP_NOHZ -&gt;
 10     tmp = dynticks_progress_counter;
 11     atomic {
 12       dynticks_progress_counter = tmp + 1;
 13       old_gp_idle = (grace_period_state == GP_IDLE);
 14       assert((dynticks_progress_counter &amp; 1) == 1);
 15     }
 16     atomic {
 17       tmp = dynticks_progress_counter;
 18       assert(!old_gp_idle || grace_period_state != GP_DONE);
 19     }
 20     atomic {
 21       dynticks_progress_counter = tmp + 1;
 22       assert((dynticks_progress_counter &amp; 1) == 0);
 23     }
 24     i++;
 25   od;
 26   dyntick_nohz_done = 1;
 27 }
</pre>

<p>With this variable in place, we can add assertions to
<code>grace_period()</code> to check for unnecessary blockage
as follows:
 
</p><pre>  1 proctype grace_period()
  2 {
  3   byte curr;
  4   byte snap;
  5   bit shouldexit;
  6 
  7   grace_period_state = GP_IDLE;
  8   atomic {
  9     printf("MAX_DYNTICK_LOOP_NOHZ = %d\n", MAX_DYNTICK_LOOP_NOHZ);
 10     shouldexit = 0;
 11     snap = dynticks_progress_counter;
 12     grace_period_state = GP_WAITING;
 13   }
 14   do
 15   :: 1 -&gt;
 16     atomic {
 17       assert(!shouldexit);
 18       shouldexit = dyntick_nohz_done;
 19       curr = dynticks_progress_counter;
 20       if
 21       :: (curr == snap) &amp;&amp; ((curr &amp; 1) == 0) -&gt;
 22         break;
 23       :: (curr - snap) &gt; 2 || (snap &amp; 1) == 0 -&gt;
 24         break;
 25       :: else -&gt; skip;
 26       fi;
 27     }
 28   od;
 29   grace_period_state = GP_DONE;
 30   grace_period_state = GP_IDLE;
 31   atomic {
 32     shouldexit = 0;
 33     snap = dynticks_progress_counter;
 34     grace_period_state = GP_WAITING;
 35   }
 36   do
 37   :: 1 -&gt;
 38     atomic {
 39       assert(!shouldexit);
 40       shouldexit = dyntick_nohz_done;
 41       curr = dynticks_progress_counter;
 42       if
 43       :: (curr == snap) &amp;&amp; ((curr &amp; 1) == 0) -&gt;
 44         break;
 45       :: (curr != snap) -&gt;
 46         break;
 47       :: else -&gt; skip;
 48       fi;
 49     }
 50   od;
 51   grace_period_state = GP_DONE;
 52 }
</pre>

<p>We have added the <code>shouldexit</code> variable on line&nbsp;5,
which we initialize to zero on line&nbsp;10.
Line&nbsp;17 asserts that <code>shouldexit</code> is not set, while
line&nbsp;18 sets <code>shouldexit</code> to the <code>dyntick_nohz_done</code>
variable maintained by <code>dyntick_nohz()</code>.
This assertion will therefore trigger if we attempt to take more than
one pass through the wait-for-counter-flip-acknowledgment
loop after <code>dyntick_nohz()</code> has completed
execution.
After all, if <code>dyntick_nohz()</code> is done, then there cannot be
any more state changes to force us out of the loop, so going through twice
in this state means an infinite loop, which in turn means no end to the
grace period.

</p><p>Lines&nbsp;32, 39, and 40 operate in a similar manner for the
second (memory-barrier) loop.

</p><p>However, running this
<A HREF="/Articles/279096/">model</A>
results in failure, as line&nbsp;23 is checking that the wrong variable
is even.
Upon failure, <code>spin</code> writes out a
<A HREF="/Articles/279097/">&ldquo;trail&rdquo;</a>
file, which records the sequence of states that lead to the failure.
Use the <code>spin -t -p -g -l dyntickRCU-base-sl-busted.spin</code>
command to cause <code>spin</code> to retrace this sequence of states,
<A HREF="/Articles/279098/">
printing the statements executed and the values of variables</A>.
Note that the line numbers do not match the listing above due to
the fact that spin takes both functions in a single file.
However, the line numbers <i>do</i> match the full model.

</p><p>We see that the <code>dyntick_nohz()</code> process completed
at step 34 (search for &ldquo;34:&rdquo;), but that the
<code>grace_period()</code> process nonetheless failed to exit the loop.
The value of <code>curr</code> is <code>6</code> (see step 35)
and that the value of <code>snap</code> is <code>5</code> (see step 17).
Therefore the first condition on line&nbsp;21 above does not hold because
<code>curr != snap</code>, and the second condition on line&nbsp;23
does not hold either because <code>snap</code> is odd and because
<code>curr</code> is only one greater than <code>snap</code>.

</p><p>So one of these two conditions has to be incorrect.
Referring to the comment block in <code>rcu_try_flip_waitack_needed()</code>
for the first condition:

</p><pre>
	/*
	 * If the CPU remained in dynticks mode for the entire time
	 * and didn't take any interrupts, NMIs, SMIs, or whatever,
	 * then it cannot be in the middle of an rcu_read_lock(), so
	 * the next rcu_read_lock() it executes must use the new value
	 * of the counter.  So we can safely pretend that this CPU
	 * already acknowledged the counter.
	 */
</pre>

<p>The first condition does match this, because if <code>curr == snap</code>
and if <code>curr</code> is even, then the corresponding CPU has been
in dynticks-idle mode the entire time, as required.
So let's look at the comment block for the second condition:

</p><pre>
	/*
	 * If the CPU passed through or entered a dynticks idle phase with
	 * no active irq handlers, then, as above, we can safely pretend
	 * that this CPU already acknowledged the counter.
	 */
</pre>

<p>The first part of the condition is correct, because if <code>curr</code>
and <code>snap</code> differ by two, there will be at least one even
number in between, corresponding to having passed completely through
a dynticks-idle phase.
However, the second part of the condition corresponds to having
<I>started</I> in dynticks-idle mode, not having <I>finished</I>
in this mode.
We therefore need to be testing <code>curr</code> rather than
<code>snap</code> for being an even number.

</p><p>The corrected C code is as follows:
 
</p><pre>  1 static inline int
  2 rcu_try_flip_waitack_needed(int cpu)
  3 {
  4   long curr;
  5   long snap;
  6 
  7   curr = per_cpu(dynticks_progress_counter, cpu);
  8   snap = per_cpu(rcu_dyntick_snapshot, cpu);
  9   smp_mb(); /* force ordering with cpu entering/leaving dynticks. */
 10   if ((curr == snap) &amp;&amp; ((curr &amp; 0x1) == 0))
 11     return 0;
 12   if ((curr - snap) &gt; 2 || (curr &amp; 0x1) == 0)
 13     return 0;
 14   return 1;
 15 }
</pre>

<p>Making the corresponding correction in the
<A HREF="/Articles/279100/">model</A>
results in a correct validation with 661 states that passes without
errors.
However, it is worth noting that the first version of the liveness
validation failed to catch this bug, due to a bug in the liveness
validation itself.
This liveness-validation bug was located by inserting an infinite
loop in the <code>grace_period()</code> process, and noting that
the liveness-validation code failed to detect this problem!

</p><p>We have now successfully validated both safety and liveness
conditions, but only for processes running and blocking.
We also need to handle interrupts, a task taken up in the next section.

</p><h4><a name="Interrupts">
Interrupts</a></h4>

<p>There are a couple of ways to model interrupts in Promela:
</p><OL>
<LI>	using C-preprocessor tricks to insert the interrupt handler
	between each and every statement of the <code>dynticks_nohz()</code>
	process, or
<LI>	modeling the interrupt handler with a separate process.
</OL>

<p>A bit of thought indicated that the second approach would have a
smaller state space, though it requires that the interrupt handler
somehow run atomically with respect to the <code>dynticks_nohz()</code>
process, but not with respect to the <code>grace_period()</code>
process.

</p><p>Fortunately, it turns out that Promela permits you to branch
out of atomic statements.
This trick allows us to have the interrupt handler set a flag, and
recode <code>dynticks_nohz()</code> to atomically check this flag
and execute only when the flag is not set.
This can be accomplished with a C-preprocessor macro that takes
a label and a Promela statement as follows:

</p><pre>  1 #define EXECUTE_MAINLINE(label, stmt) \
  2 label: skip; \
  3     atomic { \
  4       if \
  5       :: in_dyntick_irq -&gt; goto label; \
  6       :: else -&gt; stmt; \
  7       fi; \
  8     } \
</pre>

<p>One might use this macro as follows:
</p><pre>
    EXECUTE_MAINLINE(stmt1, tmp = dynticks_progress_counter)
</pre>

<p>Line&nbsp;2 of the macro creates the specified statement label.
Lines&nbsp;3-8 are an atomic block that tests the <code>in_dyntick_irq</code>
variable, and if this variable is set (indicating that the interrupt
handler is active), branches out of the atomic block back to the
label.
Otherwise, line&nbsp;6 executes the specified statement.
The overall effect is that mainline execution stalls any time an interrupt
is active, as required.

</p><h4><a name="Validating Interrupt Handlers">
Validating Interrupt Handlers</a></h4>

<p>The first step is to convert <code>dyntick_nohz()</code> to
<code>EXECUTE_MAINLINE()</code> form, as follows:

</p><pre>  1 proctype dyntick_nohz()
  2 {
  3   byte tmp;
  4   byte i = 0;
  5   bit old_gp_idle;
  6 
  7   do
  8   :: i &gt;= MAX_DYNTICK_LOOP_NOHZ -&gt; break;
  9   :: i &lt; MAX_DYNTICK_LOOP_NOHZ -&gt;
 10     EXECUTE_MAINLINE(stmt1, tmp = dynticks_progress_counter)
 11     EXECUTE_MAINLINE(stmt2,
 12          dynticks_progress_counter = tmp + 1;
 13          old_gp_idle = (grace_period_state == GP_IDLE);
 14          assert((dynticks_progress_counter &amp; 1) == 1))
 15     EXECUTE_MAINLINE(stmt3,
 16       tmp = dynticks_progress_counter;
 17       assert(!old_gp_idle || grace_period_state != GP_DONE))
 18     EXECUTE_MAINLINE(stmt4,
 19       dynticks_progress_counter = tmp + 1;
 20       assert((dynticks_progress_counter &amp; 1) == 0))
 21     i++;
 22   od;
 23   dyntick_nohz_done = 1;
 24 }
</pre>

<p>
<div class="tlrw">
<a name="Quick Quiz 9"><b>Quick Quiz 9</b>:</a>
But what would you do if you needed the statements in a single
<code>EXECUTE_MAINLINE()</code> group to execute non-atomically?
<p>
<a name="Quick Quiz 10"><b>Quick Quiz 10</b>:</a>
But what if the <code>dynticks_nohz()</code> process had &ldquo;if&rdquo;
or &ldquo;do&rdquo;
statements with conditions, where the statement bodies of these constructs
needed to execute non-atomically?
</div>


It is important to note that when a group of statements is passed
to <code>EXECUTE_MAINLINE()</code>, as in lines&nbsp;11-14, all
statements in that group execute atomically.

</p>
<p>The next step is to write a <code>dyntick_irq()</code> process
to model an interrupt handler:

</p><pre>  1 proctype dyntick_irq()
  2 {
  3   byte tmp;
  4   byte i = 0;
  5   bit old_gp_idle;
  6 
  7   do
  8   :: i &gt;= MAX_DYNTICK_LOOP_IRQ -&gt; break;
  9   :: i &lt; MAX_DYNTICK_LOOP_IRQ -&gt;
 10     in_dyntick_irq = 1;
 11     if
 12     :: rcu_update_flag &gt; 0 -&gt;
 13       tmp = rcu_update_flag;
 14       rcu_update_flag = tmp + 1;
 15     :: else -&gt; skip;
 16     fi;
 17     if
 18     :: !in_interrupt &amp;&amp; (dynticks_progress_counter &amp; 1) == 0 -&gt;
 19       tmp = dynticks_progress_counter;
 20       dynticks_progress_counter = tmp + 1;
 21       tmp = rcu_update_flag;
 22       rcu_update_flag = tmp + 1;
 23     :: else -&gt; skip;
 24     fi;
 25     tmp = in_interrupt;
 26     in_interrupt = tmp + 1;
 27     old_gp_idle = (grace_period_state == GP_IDLE);
 28     assert(!old_gp_idle || grace_period_state != GP_DONE);
 29     tmp = in_interrupt;
 30     in_interrupt = tmp - 1;
 31     if
 32     :: rcu_update_flag != 0 -&gt;
 33       tmp = rcu_update_flag;
 34       rcu_update_flag = tmp - 1;
 35       if
 36       :: rcu_update_flag == 0 -&gt;
 37         tmp = dynticks_progress_counter;
 38         dynticks_progress_counter = tmp + 1;
 39       :: else -&gt; skip;
 40       fi;
 41     :: else -&gt; skip;
 42     fi;
 43     atomic {
 44       in_dyntick_irq = 0;
 45       i++;
 46     }
 47   od;
 48   dyntick_irq_done = 1;
 49 }
</pre>

<p>
<div class="tlrw">
<a name="Quick Quiz 11"><b>Quick Quiz 11</b>:</a>
Why are lines&nbsp;44 and 45 (the <code>in_dyntick_irq = 0;</code>
and the <code>i++;</code>) executed atomically?
<p>
<a name="Quick Quiz 12"><b>Quick Quiz 12</b>:</a>
What property of interrupts is this <code>dynticks_irq()</code> process
unable to model?
</div>
The loop from line&nbsp;7-47 models up to <code>MAX_DYNTICK_LOOP_IRQ</code>
interrupts, with lines&nbsp;8 and 9 forming the loop condition and line&nbsp;45
incrementing the control variable.
Line&nbsp;10 tells <code>dyntick_nohz()</code> that an interrupt handler
is running, and line&nbsp;44 tells <code>dyntick_nohz()</code> that this
handler has completed.
Line&nbsp;48 is used for liveness validation, much as is the corresponding
line of <code>dyntick_nohz()</code>.

</p>

<p>Lines&nbsp;11-24 model <code>rcu_irq_enter()</code>, and
lines&nbsp;25 and 26 model the relevant snippet of <code>__irq_enter()</code>.
Lines&nbsp;27 and 28 validate safety in much the same manner as do the
corresponding lines of <code>dynticks_nohz()</code>.
Lines&nbsp;29 and 30 model the relevant snippet of <code>__irq_exit()</code>,
and finally lines&nbsp;31-42 model <code>rcu_irq_exit()</code>.

</p>

<pre>  1 proctype grace_period()
  2 {
  3   byte curr;
  4   byte snap;
  5   bit shouldexit;
  6 
  7   grace_period_state = GP_IDLE;
  8   atomic {
  9     printf("MAX_DYNTICK_LOOP_NOHZ = %d\n", MAX_DYNTICK_LOOP_NOHZ);
 10     printf("MAX_DYNTICK_LOOP_IRQ = %d\n", MAX_DYNTICK_LOOP_IRQ);
 11     shouldexit = 0;
 12     snap = dynticks_progress_counter;
 13     grace_period_state = GP_WAITING;
 14   }
 15   do
 16   :: 1 -&gt;
 17     atomic {
 18       assert(!shouldexit);
 19       shouldexit = dyntick_nohz_done &amp;&amp; dyntick_irq_done;
 20       curr = dynticks_progress_counter;
 21       if
 22       :: (curr == snap) &amp;&amp; ((curr &amp; 1) == 0) -&gt;
 23         break;
 24       :: (curr - snap) &gt; 2 || (curr &amp; 1) == 0 -&gt;
 25         break;
 26       :: else -&gt; skip;
 27       fi;
 28     }
 29   od;
 30   grace_period_state = GP_DONE;
 31   grace_period_state = GP_IDLE;
 32   atomic {
 33     shouldexit = 0;
 34     snap = dynticks_progress_counter;
 35     grace_period_state = GP_WAITING;
 36   }
 37   do
 38   :: 1 -&gt;
 39     atomic {
 40       assert(!shouldexit);
 41       shouldexit = dyntick_nohz_done &amp;&amp; dyntick_irq_done;
 42       curr = dynticks_progress_counter;
 43       if
 44       :: (curr == snap) &amp;&amp; ((curr &amp; 1) == 0) -&gt;
 45         break;
 46       :: (curr != snap) -&gt;
 47         break;
 48       :: else -&gt; skip;
 49       fi;
 50     }
 51   od;
 52   grace_period_state = GP_DONE;
 53 }
</pre>

<p>The implementation of <code>grace_period()</code> is very similar
to the earlier one.
The only changes are the addition of line&nbsp;10 to add the new
interrupt-count parameter and changes to lines&nbsp;19 and 41 to
add the new <code>dyntick_irq_done</code> variable to the liveness
checks.

</p><p>This <A HREF="/Articles/279103/">model</A>
results in a correct validation with roughly half a million
states, passing without errors.
However, this version of the model does not handle nested
interrupts.
This topic is taken up in the next section.

</p><h4><a name="Validating Nested Interrupt Handlers">
Validating Nested Interrupt Handlers</a></h4>

<p>Nested interrupt handlers may be modeled by splitting the body of
the loop in <code>dyntick_irq()</code> as follows:

</p><pre>  1 proctype dyntick_irq()
  2 {
  3   byte tmp;
  4   byte i = 0;
  5   byte j = 0;
  6   bit old_gp_idle;
  7   bit outermost;
  8 
  9   do
 10   :: i &gt;= MAX_DYNTICK_LOOP_IRQ &amp;&amp; j &gt;= MAX_DYNTICK_LOOP_IRQ -&gt; break;
 11   :: i &lt; MAX_DYNTICK_LOOP_IRQ -&gt;
 12     atomic {
 13       outermost = (in_dyntick_irq == 0);
 14       in_dyntick_irq = 1;
 15     }
 16     if
 17     :: rcu_update_flag &gt; 0 -&gt;
 18       tmp = rcu_update_flag;
 19       rcu_update_flag = tmp + 1;
 20     :: else -&gt; skip;
 21     fi;
 22     if
 23     :: !in_interrupt &amp;&amp; (dynticks_progress_counter &amp; 1) == 0 -&gt;
 24       tmp = dynticks_progress_counter;
 25       dynticks_progress_counter = tmp + 1;
 26       tmp = rcu_update_flag;
 27       rcu_update_flag = tmp + 1;
 28     :: else -&gt; skip;
 29     fi;
 30     tmp = in_interrupt;
 31     in_interrupt = tmp + 1;
 32     atomic {
 33       if
 34       :: outermost -&gt;
 35         old_gp_idle = (grace_period_state == GP_IDLE);
 36       :: else -&gt; skip;
 37       fi;
 38     }
 39     i++;
 40   :: j &lt; i -&gt;
 41     atomic {
 42       if
 43       :: j + 1 == i -&gt;
 44         assert(!old_gp_idle ||
 45                grace_period_state != GP_DONE);
 46       :: else -&gt; skip;
 47       fi;
 48     }
 49     tmp = in_interrupt;
 50     in_interrupt = tmp - 1;
 51     if
 52     :: rcu_update_flag != 0 -&gt;
 53       tmp = rcu_update_flag;
 54       rcu_update_flag = tmp - 1;
 55       if
 56       :: rcu_update_flag == 0 -&gt;
 57         tmp = dynticks_progress_counter;
 58         dynticks_progress_counter = tmp + 1;
 59       :: else -&gt; skip;
 60       fi;
 61     :: else -&gt; skip;
 62     fi;
 63     atomic {
 64       j++;
 65       in_dyntick_irq = (i != j);
 66     }
 67   od;
 68   dyntick_irq_done = 1;
 69 }
</pre>

<p>This is similar to the earlier <code>dynticks_irq()</code> process.
It adds a second counter variable <code>j</code> on line&nbsp;5, so that
<code>i</code> counts entries to interrupt handlers and <code>j</code>
counts exits.
The <code>outermost</code> variable on line&nbsp;7 helps determine
when the <code>grace_period_state</code> variable needs to be sampled
for the safety checks.
The loop-exit check on line&nbsp;10 is updated to require that the
specified number of interrupt handlers are exited as well as entered,
and the increment of <code>i</code> is moved to line&nbsp;39, which is
the end of the interrupt-entry model.
Lines&nbsp;12-15 set the <code>outermost</code> variable to indicate
whether this is the outermost of a set of nested interrupts and to
set the <code>in_dyntick_irq</code> variable that is used by the
<code>dyntick_nohz()</code> process.
Lines&nbsp;32-37 capture the state of the <code>grace_period_state</code>
variable, but only when in the outermost interrupt handler.

</p><p>Line&nbsp;40 has the do-loop conditional for interrupt-exit modeling:
as long as we have exited fewer interrupts than we have entered, it is
legal to exit another interrupt.
Lines&nbsp;41-48 check the safety criterion, but only if we are exiting
from the outermost interrupt level.
Finally, lines&nbsp;63-66 increment the interrupt-exit count <code>j</code>
and, if this is the outermost interrupt level, clears
<code>in_dyntick_irq</code>.

</p><p>This <A HREF="/Articles/279104/">model</A>
results in a correct validation with a bit more than half a million
states, passing without errors.
However, this version of the model does not handle NMIs,
which are taken up in the nest section.

</p><h4><a name="Validating NMI Handlers">
Validating NMI Handlers</a></h4>

<p>We take the same general approach for NMIs as we do for interrupts,
keeping in mind that NMIs do not nest.
This results in a <code>dyntick_nmi()</code> process as follows:

</p><pre>  1 proctype dyntick_nmi()
  2 {
  3   byte tmp;
  4   byte i = 0;
  5   bit old_gp_idle;
  6 
  7   do
  8   :: i &gt;= MAX_DYNTICK_LOOP_NMI -&gt; break;
  9   :: i &lt; MAX_DYNTICK_LOOP_NMI -&gt;
 10     in_dyntick_nmi = 1;
 11     if
 12     :: rcu_update_flag &gt; 0 -&gt;
 13       tmp = rcu_update_flag;
 14       rcu_update_flag = tmp + 1;
 15     :: else -&gt; skip;
 16     fi;
 17     if
 18     :: !in_interrupt &amp;&amp; (dynticks_progress_counter &amp; 1) == 0 -&gt;
 19       tmp = dynticks_progress_counter;
 20       dynticks_progress_counter = tmp + 1;
 21       tmp = rcu_update_flag;
 22       rcu_update_flag = tmp + 1;
 23     :: else -&gt; skip;
 24     fi;
 25     tmp = in_interrupt;
 26     in_interrupt = tmp + 1;
 27     old_gp_idle = (grace_period_state == GP_IDLE);
 28     assert(!old_gp_idle || grace_period_state != GP_DONE);
 29     tmp = in_interrupt;
 30     in_interrupt = tmp - 1;
 31     if
 32     :: rcu_update_flag != 0 -&gt;
 33       tmp = rcu_update_flag;
 34       rcu_update_flag = tmp - 1;
 35       if
 36       :: rcu_update_flag == 0 -&gt;
 37         tmp = dynticks_progress_counter;
 38         dynticks_progress_counter = tmp + 1;
 39       :: else -&gt; skip;
 40       fi;
 41     :: else -&gt; skip;
 42     fi;
 43     atomic {
 44       i++;
 45       in_dyntick_nmi = 0;
 46     }
 47   od;
 48   dyntick_nmi_done = 1;
 49 }
</pre>

<p>Of course, the fact that we have NMIs requires adjustments in
the other components.
For example, the <code>EXECUTE_MAINLINE()</code> macro now needs to
pay attention to the NMI handler (<code>in_dyntick_nmi</code>) as well
as the interrupt handler (<code>in_dyntick_irq</code>) by checking
the <code>dyntick_nmi_done</code> variable as follows:

</p><pre>
  1 #define EXECUTE_MAINLINE(label, stmt) \
  2 label: skip; \
  3     atomic { \
  4       if \
  5       :: in_dyntick_irq || in_dyntick_nmi -&gt; goto label; \
  6       :: else -&gt; stmt; \
  7       fi; \
  8     } \
</pre>

<p>We will also need to introduce an <code>EXECUTE_IRQ()</code>
macro that checks <code>in_dyntick_nmi</code> in order to allow
<code>dyntick_irq()</code> to exclude <code>dyntick_nmi()</code>:

</p><pre>
  1 #define EXECUTE_IRQ(label, stmt) \
  2 label: skip; \
  3     atomic { \
  4       if \
  5       :: in_dyntick_nmi -&gt; goto label; \
  6       :: else -&gt; stmt; \
  7       fi; \
  8     } \
</pre>

<p>It is further necessary to convert <code>dyntick_irq()</code>
to <code>EXECUTE_IRQ()</code> as follows:

</p><pre>
  1 proctype dyntick_irq()
  2 {
  3   byte tmp;
  4   byte i = 0;
  5   byte j = 0;
  6   bit old_gp_idle;
  7   bit outermost;
  8 
  9   do
 10   :: i &gt;= MAX_DYNTICK_LOOP_IRQ &amp;&amp; j &gt;= MAX_DYNTICK_LOOP_IRQ -&gt; break;
 11   :: i &lt; MAX_DYNTICK_LOOP_IRQ -&gt;
 12     atomic {
 13       outermost = (in_dyntick_irq == 0);
 14       in_dyntick_irq = 1;
 15     }
 16 stmt1: skip;
 17     atomic {
 18       if
 19       :: in_dyntick_nmi -&gt; goto stmt1;
 20       :: !in_dyntick_nmi &amp;&amp; rcu_update_flag -&gt;
 21         goto stmt1_then;
 22       :: else -&gt; goto stmt1_else;
 23       fi;
 24     }
 25 stmt1_then: skip;
 26     EXECUTE_IRQ(stmt1_1, tmp = rcu_update_flag)
 27     EXECUTE_IRQ(stmt1_2, rcu_update_flag = tmp + 1)
 28 stmt1_else: skip;
 29 stmt2: skip;  atomic {
 30       if
 31       :: in_dyntick_nmi -&gt; goto stmt2;
 32       :: !in_dyntick_nmi &amp;&amp;
 33          !in_interrupt &amp;&amp;
 34          (dynticks_progress_counter &amp; 1) == 0 -&gt;
 35            goto stmt2_then;
 36       :: else -&gt; goto stmt2_else;
 37       fi;
 38     }
 39 stmt2_then: skip;
 40     EXECUTE_IRQ(stmt2_1, tmp = dynticks_progress_counter)
 41     EXECUTE_IRQ(stmt2_2, dynticks_progress_counter = tmp + 1)
 42     EXECUTE_IRQ(stmt2_3, tmp = rcu_update_flag)
 43     EXECUTE_IRQ(stmt2_4, rcu_update_flag = tmp + 1)
 44 stmt2_else: skip;
 45     EXECUTE_IRQ(stmt3, tmp = in_interrupt)
 46     EXECUTE_IRQ(stmt4, in_interrupt = tmp + 1)
 47 stmt5: skip;
 48     atomic {
 49       if
 50       :: in_dyntick_nmi -&gt; goto stmt4;
 51       :: !in_dyntick_nmi &amp;&amp; outermost -&gt;
 52         old_gp_idle = (grace_period_state == GP_IDLE);
 53       :: else -&gt; skip;
 54       fi;
 55     }
 56     i++;
 57   :: j &lt; i -&gt;
 58 stmt6: skip;
 59     atomic {
 60       if
 61       :: in_dyntick_nmi -&gt; goto stmt6;
 62       :: !in_dyntick_nmi &amp;&amp; j + 1 == i -&gt;
 63         assert(!old_gp_idle || grace_period_state != GP_DONE);
 64       :: else -&gt; skip;
 65       fi;
 66     }
 67     EXECUTE_IRQ(stmt7, tmp = in_interrupt);
 68     EXECUTE_IRQ(stmt8, in_interrupt = tmp - 1);
 69 
 70 stmt9: skip;
 71     atomic {
 72       if
 73       :: in_dyntick_nmi -&gt; goto stmt9;
 74       :: !in_dyntick_nmi &amp;&amp; rcu_update_flag != 0 -&gt;
 75         goto stmt9_then;
 76       :: else -&gt; goto stmt9_else;
 77       fi;
 78     }
 79 stmt9_then: skip;
 80     EXECUTE_IRQ(stmt9_1, tmp = rcu_update_flag)
 81     EXECUTE_IRQ(stmt9_2, rcu_update_flag = tmp - 1)
 82 stmt9_3: skip;
 83     atomic {
 84       if
 85       :: in_dyntick_nmi -&gt; goto stmt9_3;
 86       :: !in_dyntick_nmi &amp;&amp; rcu_update_flag == 0 -&gt;
 87         goto stmt9_3_then;
 88       :: else -&gt; goto stmt9_3_else;
 89       fi;
 90     }
 91 stmt9_3_then: skip;
 92     EXECUTE_IRQ(stmt9_3_1, tmp = dynticks_progress_counter)
 93     EXECUTE_IRQ(stmt9_3_2, dynticks_progress_counter = tmp + 1)
 94 stmt9_3_else:
 95 stmt9_else: skip;
 96     atomic {
 97       j++;
 98       in_dyntick_irq = (i != j);
 99     }
100   od;
101   dyntick_irq_done = 1;
102 }
</pre>

<p>Note that we have open-coded the &ldquo;if&rdquo; statements
(for example, lines&nbsp;16-28).
In addition, statements that process strictly local state
(such as line&nbsp;56) need not exclude <code>dyntick_nmi()</code>.

</p><p>Finally, <code>grace_period()</code> requires only a few changes:

</p><pre>
  1 proctype grace_period()
  2 {
  3   byte curr;
  4   byte snap;
  5   bit shouldexit;
  6 
  7   grace_period_state = GP_IDLE;
  8   atomic {
  9     printf("MAX_DYNTICK_LOOP_NOHZ = %d\n", MAX_DYNTICK_LOOP_NOHZ);
 10     printf("MAX_DYNTICK_LOOP_IRQ = %d\n", MAX_DYNTICK_LOOP_IRQ);
 11     printf("MAX_DYNTICK_LOOP_NMI = %d\n", MAX_DYNTICK_LOOP_NMI);
 12     shouldexit = 0;
 13     snap = dynticks_progress_counter;
 14     grace_period_state = GP_WAITING;
 15   }
 16   do
 17   :: 1 -&gt;
 18     atomic {
 19       assert(!shouldexit);
 20       shouldexit = dyntick_nohz_done &amp;&amp;
 21              dyntick_irq_done &amp;&amp;
 22              dyntick_nmi_done;
 23       curr = dynticks_progress_counter;
 24       if
 25       :: (curr == snap) &amp;&amp; ((curr &amp; 1) == 0) -&gt;
 26         break;
 27       :: (curr - snap) &gt; 2 || (curr &amp; 1) == 0 -&gt;
 28         break;
 29       :: else -&gt; skip;
 30       fi;
 31     }
 32   od;
 33   grace_period_state = GP_DONE;
 34   grace_period_state = GP_IDLE;
 35   atomic {
 36     shouldexit = 0;
 37     snap = dynticks_progress_counter;
 38     grace_period_state = GP_WAITING;
 39   }
 40   do
 41   :: 1 -&gt;
 42     atomic {
 43       assert(!shouldexit);
 44       shouldexit = dyntick_nohz_done &amp;&amp;
 45              dyntick_irq_done &amp;&amp;
 46              dyntick_nmi_done;
 47       curr = dynticks_progress_counter;
 48       if
 49       :: (curr == snap) &amp;&amp; ((curr &amp; 1) == 0) -&gt;
 50         break;
 51       :: (curr != snap) -&gt;
 52         break;
 53       :: else -&gt; skip;
 54       fi;
 55     }
 56   od;
 57   grace_period_state = GP_DONE;
 58 }
</pre>

<p>We have added the <code>printf()</code> for the new
<code>MAX_DYNTICK_LOOP_NMI</code> parameter on line&nbsp;11 and
added <code>dyntick_nmi_done</code> to the <code>shouldexit</code>
assignments on lines&nbsp;22 and 46.

</p>
<div class="tlrw">
<a name="Quick Quiz 13"><b>Quick Quiz 13</b>:</a>
Do you always write your code in this painfully incremental manner???
</div>

<p>The <A HREF="/Articles/279105/">model</A>
results in a correct validation with several hundred million
states, passing without errors.

</p>
<h3><a name="Conclusions">Conclusions</a></h3>

<p>This effort provided some lessons (re)learned:

</p><p><b>Promela and spin can validate interrupt/NMI-handler
interactions</b>.

</p><p><b>Documenting code can help locate bugs</b>.
In this case, the documentation effort located
<A HREF="http://lkml.org/lkml/2008/3/16/150">this bug</A>.

</p><p><b>Validate your code early, often, and up to the point
of destruction.</b>
This effort located one subtle
<A HREF="http://lkml.org/lkml/2008/3/21/347">bug</A>
that might have been quite difficult to test or debug.

</p><p><b>Always validate your validation code.</b>
The usual way to do this is to insert a deliberate bug
and verify that the validation code catches it.  Of course,
if the validation code fails to catch this bug, you may also
need to verify the bug itself, and so on, recursing infinitely.
However, if you find yourself in this position,
getting a good night's sleep
can be an extremely effective debugging technique.

</p><p>Finally, if <code>cmpxchg</code> instructions ever become
inexpensive enough to tolerate them in the interrupt fastpath, their use
could greatly simplify this code.
The Promela model for an atomic-instruction-based implementation of
this code has more than an order of magnitude fewer states, and the
C code is much easier to understand.
On the other hand, one must take care when using <code>cmpxchg</code>
instructions, as some code sequences, if highly contended, can result
in starvation.
This situation is particularly likely to occur when part of the
algorithm uses <code>cmpxchg</code>, other parts of the algorithm
use atomic instructions that cannot fail (e.g., atomic increment),
contention for the variable in question is high, and the code is
running on a NUMA or a shared-cache machine.
Sadly, almost all multi-socket systems with either multi-core or
multi-threaded CPUs fit this description.

</p><h3>Acknowledgments</h3>

<p>We are indebted to Andrew Theurer, who maintains the large-memory machine
that ran the full test.
We all owe a debt of gratitude to Vara Prasad for his help in rendering
this article human-readable.
<!-- @@@ reviewers @@@ --&gt;
We are grateful to Dan Frye and Kathy Bennett for their support of this effort.

</p><p>This work represents the view of the author and does not necessarily
represent the view of IBM.

</p><p>Linux is a registered trademark of Linus Torvalds.

</p><p>Other company, product, and service names may be trademarks or
service marks of others.

</p><h3><a name="Answers to Quick Quizzes">
Answers to Quick Quizzes</a></h3>

<p><b>Quick Quiz 1</b>:
Yeah, that's great!!!
Now, just what am I supposed to do if I don't happen to have a machine with
40GB of main memory???

</p><p><b>Answer</b>: Relax, there are a number of lawful answers to
this question:
<OL>
<LI>	Further optimize the model, reducing its memory consumption.
<LI>	Work out a pencil-and-paper proof, perhaps starting with the
	comments in the code in the Linux kernel.
<LI>	Devise careful torture tests, which, though they cannot prove
	the code correct, can find hidden bugs.
<LI>	Tools like
	<A HREF="http://anna.fi.muni.cz/divine/tool/index.html">DeVinE</A>
	are designed to do model checking on a cluster of smaller
	machines.  However, please note that we have not actually used such
	tools myself, courtesy of some large machines that Paul has
	occasional access to.
</OL>

<p>Still better would be to come up with a simpler and faster algorithm
that has a smaller state space.
Even better would be an algorithm so simple that its correctness was
obvious to the casual observer!

</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>

</p><p><b>Quick Quiz 2</b>:
Why not simply increment <code>rcu_update_flag</code>, and then only
increment <code>dynticks_progress_counter</code> if the old value
of <code>rcu_update_flag</code> was zero???

</p><p><b>Answer</b>: This fails in presence of NMIs.
To see this, suppose an NMI was received just after
<code>rcu_irq_enter()</code> incremented <code>rcu_update_flag</code>,
but before it incremented <code>dynticks_progress_counter</code>.
The instance of <code>rcu_irq_enter()</code> invoked by the NMI
would see that the original value of <code>rcu_update_flag</code>
was non-zero, and would therefore refrain from incrementing
<code>dynticks_progress_counter</code>.
This would leave the RCU grace-period machinery no clue that the
NMI handler was executing on this CPU, so that any RCU read-side
critical sections in the NMI handler would lose their RCU protection.

</p><p>The possibility of NMI handlers, which, by definition cannot
be masked, does complicate this code.

</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>

</p><p><b>Quick Quiz 3</b>:
But if line&nbsp;7 finds that we are the outermost interrupt, wouldn't
we <i>always</i> need to increment <code>dynticks_progress_counter</code>?

</p><p><b>Answer</b>: Not if we interrupted a running task!
In that case, <code>dynticks_progress_counter</code> would
have already been incremented by <code>rcu_exit_nohz()</code>,
and there would be no need to increment it again.

</p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>

</p><p><b>Quick Quiz 4</b>:
Can you spot any bugs in any of the code in this section?

</p><p><b>Answer</b>: Read the next section to see if you were correct.

</p><p><a href="#Quick%20Quiz%204"><b>Back to Quick Quiz 4</b>.</a>

</p><p><b>Quick Quiz 5</b>:
Why isn't the memory barrier in <code>rcu_exit_nohz()</code>
and <code>rcu_enter_nohz()</code> modeled in Promela?

</p><p><b>Answer</b>: Promela assumes sequential consistency, so
it is not necessary to model memory barriers.
In fact, one must instead explicitly model lack of memory barriers,
for example, via
<A HREF="http://lwn.net/Articles/243851/"><code>sum_unordered()</code></A>.

</p><p><a href="#Quick%20Quiz%205"><b>Back to Quick Quiz 5</b>.</a>

</p><p><b>Quick Quiz 6</b>:
Isn't it a bit strange to model <code>rcu_exit_nohz()</code>
followed by <code>rcu_enter_nohz()</code>?
Wouldn't it be more natural to instead model entry before exit?

</p><p><b>Answer</b>: It probably would be more natural, but we will need
this particular order for the liveness checks that we will add later.

</p><p><a href="#Quick%20Quiz%206"><b>Back to Quick Quiz 6</b>.</a>

</p><p><b>Quick Quiz 7</b>:
Wait a minute!
In the Linux kernel, both <code>dynticks_progress_counter</code> and
<code>rcu_dyntick_snapshot</code> are per-CPU variables.
So why are they instead being modeled as single global variables?

</p><p><b>Answer</b>: Because the grace-period code processes each
CPU's <code>dynticks_progress_counter</code> and
<code>rcu_dyntick_snapshot</code> variables separately,
we can collapse the state onto a single CPU.
If the grace-period code were instead to do something special
given specific values on specific CPUs, then we would indeed need
to model multiple CPUs.
But fortunately, we can safely confine ourselves to two CPUs, the
one running the grace-period processing and the one entering and
leaving dynticks-idle mode.

</p><p><a href="#Quick%20Quiz%207"><b>Back to Quick Quiz 7</b>.</a>

</p><p><b>Quick Quiz 8</b>:
Given there are a pair of back-to-back changes to
<code>grace_period_state</code> on lines&nbsp;25 and 26,
how can we be sure that line&nbsp;25's changes won't be lost?

</p><p><b>Answer</b>: Recall that Promela and spin trace out
every possible sequence of state changes.
Therefore, timing is irrelevant: Promela/spin will be quite
happy to jam the entire rest of the model between those two
statements unless some state variable specifically prohibits
doing so.

</p><p><a href="#Quick%20Quiz%208"><b>Back to Quick Quiz 8</b>.</a>

</p><p><b>Quick Quiz 9</b>:
But what would you do if you needed the statements in a single
<code>EXECUTE_MAINLINE()</code> group to execute non-atomically?

</p><p><b>Answer</b>: The easiest thing to do would be to put
each such statement in its own <code>EXECUTE_MAINLINE()</code>
statement.

</p><p><a href="#Quick%20Quiz%209"><b>Back to Quick Quiz 9</b>.</a>

</p><p><b>Quick Quiz 10</b>:
But what if the <code>dynticks_nohz()</code> process had &ldquo;if&rdquo;
or &ldquo;do&rdquo;
statements with conditions, where the statement bodies of these constructs
needed to execute non-atomically?

</p><p><b>Answer</b>: One approach, as we will see in a later section,
is to use explicit labels and &ldquo;goto&rdquo; statements.
For example, the construct:

</p><pre>
	if
	:: i == 0 -&gt; a = -1;
	:: else -&gt; a = -2;
	fi;
</pre>

<p>could be modeled as something like:

</p><pre>
	EXECUTE_MAINLINE(stmt1,
			 if
			 :: i == 0 -&gt; goto stmt1_then;
			 :: else -&gt; goto stmt1_else;
			 fi)
	stmt1_then: skip;
	EXECUTE_MAINLINE(stmt1_then1, a = -1; goto stmt1_end)
	stmt1_else: skip;
	EXECUTE_MAINLINE(stmt1_then1, a = -2)
	stmt1_end: skip;
</pre>

<p>However, it is not clear that the macro is helping much in the case
of the &ldquo;if&rdquo; statement, so these sorts of situations will
be open-coded in the following sections.

</p><p><a href="#Quick%20Quiz%2010"><b>Back to Quick Quiz 10</b>.</a>

</p><p><b>Quick Quiz 11</b>:
Why are lines&nbsp;44 and 45 (the <code>in_dyntick_irq = 0;</code>
and the <code>i++;</code>) executed atomically?

</p><p><b>Answer</b>: These lines of code pertain to controlling the
model, not to the code being modeled, so there is no reason to
model them non-atomically.
The motivation for modeling them atomically is to reduce the size
of the state space.

</p><p><a href="#Quick%20Quiz%2011"><b>Back to Quick Quiz 11</b>.</a>

</p><p><b>Quick Quiz 12</b>:
What property of interrupts is this <code>dynticks_irq()</code> process
unable to model?

</p><p><b>Answer</b>: One such property is nested interrupts,
which are handled in the following section.

</p><p><a href="#Quick%20Quiz%2012"><b>Back to Quick Quiz 12</b>.</a>

</p><p><b>Quick Quiz 13</b>:
Do you always write your code in this painfully incremental manner???

</p><p><b>Answer</b>: Not always, but more and more frequently.
In this case, Paul started with the smallest slice of code that included
an interrupt handler, because he was not sure how best to model interrupts
in Promela.
Once he got that working, he added other features.
(But if he was doing it again, he would start with a &ldquo;toy&rdquo; handler.
For example, he might have the handler increment a variable twice and
have the mainline code verify that the value was always even.)

</p><p>Why the incremental approach?
Consider the following, attributed to Brian W. Kernighan:

<blockquote>
	<p>Debugging is twice as hard as writing the code in the first
	place. Therefore, if you write the code as cleverly as possible,
	you are, by definition, not smart enough to debug it.
</blockquote>

<p>This means that any attempt to optimize the production of code should
place at least 66% of its emphasis on optimizing the debugging process,
even at the expense of increasing the time and effort spent coding.
Incremental coding and testing is one way to optimize the debugging
process, at the expense of some increase in coding effort.
Paul uses this approach because he rarely have the luxury of
devoting full days (let alone weeks) to coding and debugging.

</p><p><a href="#Quick%20Quiz%2013"><b>Back to Quick Quiz 13</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Read-copy-update">Read-copy-update</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/279077/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor279620"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Integrating and Validating dynticks and Preemptable RCU</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2008 19:15 UTC (Thu)
                               by <b>ds2horner</b> (subscriber, #13438)
                              [<a href="/Articles/279620/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
There are a few typos that (when fixed ) may help the read follow better:

Interrupt entry is handled similarly by rcu_irq_exit():
should be 
Interrupt exit is handled similarly by rcu_irq_exit():

and in the same section

(preceding the rcu_irq_enter() invocation).
should be
(preceding the rcu_irq_exit() invocation).


the definition of in_interrupt would help (but likely out of scope) as would an explanation of
MNI behaviour (does it complete handing before any masked interupts are enabled?)  

However, the most puzzling to me was why the code (which finally got fixed)
 
 10   if ((curr == snap) &amp;&amp; ((curr &amp; 0x1) == 0))
 11     return 0;
 12   if ((curr - snap) &gt; 2 || (curr &amp; 0x1) == 0)
 13     return 0;

isn't coded as 

 10   if ((curr &amp; 0x1) == 0) || (curr - snap) &gt; 2)
 11     return 0;
 
Which I would read as:
 If we are in dynticks or have passed through dynticks since snapshot this cpu's good to go.

(The simplification occurred to me in the original code, but meant semantically much less due
to the potentially expired snapshot state)

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/279620/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor279623"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">passed through dynticks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2008 19:27 UTC (Thu)
                               by <b>ds2horner</b> (subscriber, #13438)
                              [<a href="/Articles/279623/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
mightn't 

(curr - snap) &gt;= 2

be sufficient to determine if dynticks was entered and a sufficient condition       
to exclude the cpu?
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/279623/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor279803"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">passed through dynticks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2008 1:05 UTC (Sat)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/279803/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Excellent points, all on the money!!!  I clearly should submit more of my code to LWN for
review!!!

I made the changes to spin, and all but the last (big) one completed
successfully.  This last one is in progress, and will take a bit to complete.  I will let you
know how it goes.

Thank you very much for your careful and productive review!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/279803/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor279808"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">passed through dynticks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2008 3:12 UTC (Sat)
                               by <b>ds2horner</b> (subscriber, #13438)
                              [<a href="/Articles/279808/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Thank you for your encouraging words.

I was reluctant to add more - ( still working through the logic and especially the Promela
modeling verification process) - until I got some confirmation that I was grasping the
concepts.

I would like to suggest a further code simplification in rcu_try_flip_waitmb_needed.

  if ((curr == snap) &amp;&amp; ((curr &amp; 0x1) == 0))
    return 0;
  if (curr != snap)
    return 0;

reduces to:

if ((curr &amp; 0x1) == 0 || (curr != snap) )
    return 0;

If we are in dynticks we have not done any RCU activity since entering (and have done the
required memory barrier on entry, so nothing to synch (is there a miniscule race here between
the setting of the dynticks_progress_counter and invoking of the barrier on the remote cpu?))
or we have transitioned dynticks states and therefore invoked the required mb.


And some more editting/profreading corrections:

like blank line 4 in rcu_irq_enter throwing off the description in the following paragraph.
should be 

while lines 5 and 6 ... (not 4 and 5)  
and
Lines 7 and 8 .. (not 6 and 7) 

Do you want me to report such text corrections?

I am still working my way through this.

I greatly appreciate such articles in LWN 
- the description around the code greatly helps in validating possible corrections or
recommendations.  

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/279808/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor279838"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">passed through dynticks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2008 0:13 UTC (Sun)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/279838/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Very good -- much simpler formulation!  (A bit faster as well, but as this is the slow path,
the simplicity is more important.)  Passes Promela/spin, and also rcutorture.

Feel free to post feedback, or email it to me if you prefer.  Don't worry about line-number
mismatches, as they will all change anyway.

Would you be willing to review before publication on the next one?  If so, please drop me an
email.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/279838/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor279841"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RCU reviews</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2008 4:03 UTC (Sun)
                               by <b>ds2horner</b> (subscriber, #13438)
                              [<a href="/Articles/279841/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
I would be honoured to pre-view the next LWN article.
However, I believe I am mostly out of my league here. 
I hope to not disappoint you.

I understand memory barriers are quite expensive (on most current machines that implement
them), so I have some suggestions for optimizations in rcu_try_flip_waitmb_needed and
rcu_try_flip_waitack_needed. 

And I understand mb is both read and write barrier. I plan on looking into the possibility of
using (the potentially) less expensive read (or write) barriers, if you think they may
benefit.

I did not see your email anywhere on LWN - even in the new "GuestArticles index", so I will
look for your email on lkml. Having seen no other posts here, perhaps we are OK going private
correspondence.

Thanks again for these informative (and thought provoking) articles.


</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/279841/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2008, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
