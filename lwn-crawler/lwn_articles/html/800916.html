        <!DOCTYPE html>
        <html lang="en">
        <head><title>PostgreSQL considers seccomp() filters [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/800916/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/800603/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/800916/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>PostgreSQL considers seccomp() filters</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>October 1, 2019</br>
           </div>
<p>
A discussion on the <a
href="https://www.postgresql.org/list/pgsql-hackers/">pgsql-hackers mailing
list</a> at the end of August is another reminder that the suitability of
<a
href="http://man7.org/linux/man-pages/man2/seccomp.2.html"><tt>seccomp()</tt></a>
filters is likely more narrow than was hoped.  Applying filters to 
the PostgreSQL database is difficult for a number of reasons and the
benefit for the project and its users is not entirely clear.  The
discussion highlights the tradeoffs inherent in adding system-call
filtering to a complex software suite; it may help crystallize the thinking
of other projects that are also
looking at supporting <tt>seccomp()</tt> filters.
</p>

<p>
Joe Conway raised the idea in an <a href="/Articles/800922/">RFC
patch posting</a>.
It added a way to filter system calls in the main postmaster process and,
with a separate system-call list, in
the per-session backends.
It also showed how to generate the list of system calls that
are being used by PostgreSQL under various workloads, such as the test
targets in the Makefile or by running a specific application.  Information
on the system calls
made is logged by the audit subsystem; those logs are then processed to
produce the list.  Once there is confidence that the list is complete—which may be a
sticking point—the remaining system calls could be blocked so that
executing them would cause an error.
</p>

<p>
But Peter Eisentraut was <a href="/Articles/800944/">concerned</a> that the
list is going to be incomplete due to the "<q>fantastic test
coverage</q>" needed to generate it and that it will require constant
maintenance to keep up 
with GNU C Library (glibc) and other changes.  Beyond that, PostgreSQL
extensions will need their own lists of allowed system calls.  
Conway <a href="/Articles/800947/">seems to see</a> the support as
something that those interested will maintain for themselves, rather than
having a list that the project will distribute. "<q>Perhaps most people
never use this, but when needed (and 
increasingly will be required) it is available.</q>"
</p>

<p>
Tom Lane <a href="/Articles/800948/">suggested</a> that it made more sense
to use some kind of
static analysis to determine the system calls that PostgreSQL legitimately
makes, rather than simply testing to produce the list.
But he also doesn't quite see what threat model the feature is protecting against.
Since it is PostgreSQL itself that is maintaining and configuring the system-call filter
list, a compromise that allowed privileged code execution in PostgreSQL
could just disable the 
filtering and restart PostgreSQL, making the filters moot:
<div class="BigQuote">
Given that we'll allow
any syscall that an unmodified PG executable might use, it seems
like the only scenarios being protected against involve someone
having already compromised the server enough to have arbitrary code
execution.  OK, fine, but then why wouldn't the attacker just
bypass libseccomp?  Or tell it to let through the syscall he wants
to use?  Having the list of allowed syscalls be determined inside
the process seems like fundamentally the wrong implementation.
</div>
</p>

<p>
Joshua Brindle <a
href="/Articles/800953/">thought</a> that at least blacklisting some
high-risk system calls would help bolster the security of a system running
PostgreSQL.  Systemd has some predefined lists that might be used as a
starting point.  He is also concerned that since the feature is
just one component of a full
solution, looking at it in isolation is not the right approach:
<div class="BigQuote">
The goal is to prevent an ACE [arbitrary code
execution] hole in Postgres from becoming a 
complete system compromise. This may not do it alone, and security
conscious integrators will want to, for example, add seccomp filters
to systemd to prevent superuser from disabling them. The postmaster
and per-role lists can further reduce the available syscalls based on
the exact extensions and PLs being used. Each step reduced the surface
more and throwing it all out because one step can go rogue is
unsatisfying.
</div>
</p>

<p>
The fragility of <tt>seccomp()</tt> filters is also part of what <a
href="/Articles/800954/">concerned</a> Andres Freund.  He noted that there
have already been PostgreSQL bug reports about <tt>seccomp()</tt> because of how it is
used by some container-management systems.  The system-call landscape is
constantly shifting as well, he said, pointing to an <a
href="/Articles/795128/">LWN article</a> about one <tt>seccomp()</tt>-related problem:
<div class="BigQuote">
There's regularly new syscalls (e.g. epoll_create1(), and we'll soon get
openat2()), different versions of glibc use different syscalls
(e.g. switching from open() to always using openat()), the system
configuration influences which syscalls are being used (e.g. using
vsyscalls only being used for certain clock sources), and kernel  
bugfixes change the exact set of syscalls being used.
</div>
</p>

<p>
Lane <a href="/Articles/800955/">wondered</a> why SELinux was not being
used; Brindle <a href="/Articles/800956/">made it clear</a> that while SELinux
cannot be used to do system-call filtering, it is part of the overall
PostgreSQL hardening effort.  As an example of the kind of system call that
could be blacklisted for PostgreSQL using <tt>seccomp()</tt>, Brindle pointed to <a
href="http://man7.org/linux/man-pages/man2/madvise.2.html"><tt>madvise()</tt></a>,
which he said is not preventable by SELinux, not used by PostgreSQL, and
"<q>a clear win in the
dont-let-PG-be-a-vector-for-kernel-compromise arena</q>". 
</p>

<p>
But Freund <a href="/Articles/800957/">cautioned</a> that
<tt>madvise()</tt> <i>is</i> used by glibc as part of its <tt>malloc()</tt>
implementation.  "<q>That's *precisely* my problem with this
approach.</q>"  As Lane <a href="/Articles/800958/">pointed out</a>,
calls that are buried deeply in dependencies of PostgreSQL are not going to
be found easily via testing:
<div class="BigQuote">
So this makes a perfect example for [Peter Eisentraut's] point that testing is
going to be a very fallible way of finding the set of syscalls that
need to be allowed.  Even if we had 100.00% code coverage of PG
proper, we would not necessarily find calls like this.
</div>
</p>

<p>
Yet another instance of <tt>seccomp()</tt> fragility was <a
href="/Articles/800977/">raised</a> by Thomas Munro.  The <a
href="http://man7.org/linux/man-pages/man2/sync_file_range.2.html"><tt>sync_file_range()</tt></a>
system call on PowerPC and Arm has a <tt>sync_file_range2()</tt> variant
with better argument ordering; glibc helpfully remaps calls to that variant
on the relevant architectures.  But Docker and other container managers did
not include <tt>sync_file_range2()</tt> in their whitelists, leading to unexpected errors.
</p>

<p>
While generally acknowledging the problems mentioned, Brindle and Conway
still think it makes sense to provide the hooks for the feature for those
who want it.  Brindle <a href="/Articles/800979/">said</a>:
<div class="BigQuote">
The feature allows
end users to define some sandboxing within PG. Nothing is being forced
on anyone but we would like the capability to harden a PG installation
for many reasons already stated. This is being done in places all
across the Linux ecosystem and is IMO a very useful mitigation.
</div>
</p>

<p>
But even for an optional feature, there is still a cost to PostgreSQL,
Eisentraut <a href="/Articles/800980/">said</a>:
<div class="BigQuote">
Features come with a maintenance cost.  If we ship it, then people are
going to try it out.  Then weird things will happen.  They will report
mysterious bugs.  They will complain to their colleagues.  It all comes
with a cost.
</div>
</p>

<p>
Conway <a href="/Articles/800982/">noted</a> that PostgreSQL is already
being run under <tt>seccomp()</tt> filters, however.  He and Brindle think that it
would be better for the project to proactively implement support:
<div class="BigQuote">
It is our assessment that PostgreSQL will be subject to
seccomp willingly or not (e.g., via docker, systemd, etc.) and the
community might be better served to get out in front and have first
class support.
</div>
</p>

<p>
Conway wondered if just adding the hooks to load the filters would be a
path forward, but Lane <a href="/Articles/800983/">was not in favor</a> of
putting the filter controls inside the PostgreSQL process. That
"<q>seems like a fundamentally incorrect 
architecture</q>", he said.  In order to be a "<q>credible
security improvement</q>", the filters need to be imposed on the
PostgreSQL processes from the outside.
As might be guessed, Brindle and Conway disagreed with that characterization.
Their company (Crunchy Data) has customers that need the feature, so they
will continue to pursue it, Conway said.  For the PostgreSQL mainline, though, it would
seem that the feature is not really welcome—at least in its present form.
</p>

<p>
While the appeal of filtering at the system-call level is strong, it is not
entirely clear that it is the best way forward for everything.  Processes
like a browser's rendering engine, which was an initial <tt>seccomp()</tt>
filtering target, are well suited to the approach.  By their very nature,
database engines—effectively general-purpose programming languages—do not
really fit that mold.  Adding system-call filters to something like Python
(or Perl, Ruby, PHP, ...) is similarly problematic.  Alternatives, at least
for Linux, are not readily available, however, which may be causing people
to try to fit round pegs in square holes.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-seccomp">Security/seccomp</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-Seccomp">Linux kernel/Seccomp</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/800916/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor801025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2019 17:51 UTC (Tue)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/801025/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How can anyone "need" a mechanism to disable something unused? At best, that's a no-op.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2019 18:39 UTC (Tue)
                               by <b>kfox1111</b> (subscriber, #51633)
                              [<a href="/Articles/801028/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nots not:<br>
How can anyone "need" a mechanism to disable something unused? <br>
But:<br>
How can anyone "need" a mechanism to block something unused from getting used? <br>
<p>
The desire is to not only disable something unused (passive) but prevent it from ever being used, as it never should be used in the first place (active).<br>
<p>
What this looks like: "postgres will never make syscall X". Active block rule added to prevent postgres from ever successfully making syscall X. This should not effect a normal postges. An attacker manages to break into postgres and execute their own code. If their own code tries to make syscall X, now it fails while it would normally succeed, preventing a bigger security issue.<br>
<p>
Those needing to harden their systems need that feature.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801035"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2019 19:14 UTC (Tue)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/801035/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That was the point I was trying to make: Nobody needs this feature because it doesn't do anything productive.<br>
<p>
Some people believe this would limit the amount of damage a prospective attacker could do after gaining the ability to inject arbitrary code for execution into a running Postgres process, IOW, they want to use system call filtering because they think it would increases the safety of their operations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801035/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2019 19:18 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/801037/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  That was the point I was trying to make: Nobody needs this feature because it doesn't do anything productive.</font><br>
:facepalm:<br>
<p>
Programs have bugs. Programs in C have A LOT of bugs that easily result in code injection. Mitigating the damage from them is a no-brainer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801039"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2019 20:07 UTC (Tue)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/801039/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The kernel is a program. Consequently, it has bugs and considering that it's a C program, it should have lots of bugs. In absence of any further information, all non-trivial system calls could be equally exploitable, hence, there's no reason to assume that any particular subset of the available system calls is 'safer' than any other subset.  But that's besides the point which was that "we need feature X" and "we are strongly convinced that feature X would be somewhat helpful[*] in hypothetical situation Y" are two very much different things.<br>
<p>
[*] Execute arbitrary code in the context of a database server process is a pretty devastating "security breach" in its own right. If this happens, the organisation on whose behalf the database server was running is going to get some serious and possibly even very public problems (eg, as in "all our customer information just got published on the internet").<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801039/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2019 21:03 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/801050/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The kernel is a program. Consequently, it has bugs and considering that it's a C program, it should have lots of bugs.</font><br>
Indeed. And that's the main motivator for seccomp filtering, to make sure that as little kernel is exposed to a potential attacker as possible.<br>
<p>
<font class="QuotedText">&gt; hence, there's no reason to assume that any particular subset of the available system calls is 'safer' than any other subset.</font><br>
Not quite. Objectively some system calls are exercised much less than others. Additionally, some system calls make no sense at all for Postgres (e.g. vm86) and but present a clear threat because they exercise rarely used codepaths and hardware paths.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor801161"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 18:35 UTC (Wed)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/801161/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, this seems kind of superfluous for something like PostresSQL. That is most likely going to be THE thing that the server is doing anyway. Compromising it means its game over already. It could be useful for small stuff like eg ntpd, to prevent a bug in ntpd being escalated into a compromise of the database process, but the other way is just brain-dead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801161/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 21:19 UTC (Wed)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/801173/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In theory, this would make more sense. But in practice, it's just build on the same, shaky foundation: A single, exploitable bug is sufficient for such a compromise. And for as long as there's no guaranteed way to determine that the code implementing a certain system call has no exploitable bugs and won't ever have exploitable bugs (system call implementations change), there's no way to determine if restricing the set of allowed system calls to a certain subset of the set of available system calls will actually reduce the number of exploitable errors a prospective attacker could try to utilitze, let alone reduce it to zero.<br>
<p>
There's some outright paradoxical reasoning in here: seccomp is supposed to defend against the issue that it's conjectured to be impossible to determine if the implementation of a given system call is free of exploitable errors but in order to use seccomp sensibly, ie not in a "fire a shotgun in the dark at hope that some of the projectiles hit something" mode of operation, this very information would need to be known.<br>
<p>
The best one could sensibly use this for is to block access to system calls known to be exploitable until a fix becomes available. Or for its original purpose: Run unknown code in a sandbox which is supposed to be prohibited from doing certain things, eg, most file system manipulations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 22:21 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/801177/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; there's no way to determine if restricing the set of allowed system calls to a certain subset of the set of available system calls will actually reduce the number of exploitable errors a prospective attacker could try to utilitze, let alone reduce it to zero.</font><br>
This is just nonsense. Reducing amount of code exposed to attacker reduces the chances that an exploitable bug will be accessible to them.<br>
<p>
<font class="QuotedText">&gt; There's some outright paradoxical reasoning in here: seccomp is supposed to defend against the issue that it's conjectured to be impossible to determine if the implementation of a given system call is free of exploitable errors</font><br>
You clearly live in a fantasy world. The seccomp sandboxing is designed to prevent access to as much of the attack surface as possible. This automatically makes sure that the probability of an exploit goes down.<br>
<p>
Note the word "probability". This is not prevention, it's mitigation.<br>
<p>
History shows that this approach actually works in practice. Even the misguided SELinux has prevented multiple exploitable bugs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2019 17:04 UTC (Thu)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/801247/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I seem to live in a fantasy world called 'reality',<br>
<p>
<a href="https://en.wikipedia.org/wiki/Seccomp">https://en.wikipedia.org/wiki/Seccomp</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801278"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2019 8:43 UTC (Fri)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/801278/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The default seccomp rules that Docker/LXC/cri-o/etc specify have blocked more than 95% of kernel 0day exploits in the past 6 years or so[1], purely by blocking esoteric syscalls and strange flags. There is clear and undeniable evidence that even a very generic seccomp profile does help protect systems running untrusted workloads against kernel bugs.<br>
<p>
(As an aside, note that Docker doesn't user user namespaces by default, LXC has been protected against even more exploits. But that's a very different topic.)<br>
<p>
[1]: <a href="https://docs.docker.com/engine/security/non-events/">https://docs.docker.com/engine/security/non-events/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801278/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor803118"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2019 5:42 UTC (Fri)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/803118/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;In absence of any further information, all non-trivial system calls could be equally exploitable, ..</font><br>
<p>
Perhaps, but perhaps not.<br>
<p>
Either way, though, the whole point of having people familiar with a particular code base make a list of system calls that they, to the best of their knowledge, is not needed, and are known to give their caller unnecessary privileges, is a way of adding "further information"<br>
<p>
And, your assumption now being incorrect, the reasoning based on it should be reworked. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/803118/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor801258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2019 22:35 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/801258/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And nobody “needs” side impact airbags in cars, because cars do not drive sideways?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor801029"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2019 18:42 UTC (Tue)
                               by <b>kfox1111</b> (subscriber, #51633)
                              [<a href="/Articles/801029/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think containers may be part of the solution.<br>
<p>
The concern is postgres can be used with arbitrary dependencies and getting a perfect list of what all possible combinations of dependencies with postgres would be next to impossible. That I might agree with.<br>
<p>
But, building a container, so that all its dependencies are fixed in stone, then running the test suite on it recording the syscalls would be much more reliable. The syscall list then would be static along with the static container.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801029/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801043"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2019 19:56 UTC (Tue)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/801043/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Never applying any updates sounds quite counterproductive from security point of view (which was the whole reason for the syscall filtering)...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801043/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801072"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 0:31 UTC (Wed)
                               by <b>kfox1111</b> (subscriber, #51633)
                              [<a href="/Articles/801072/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your assuming updates need to be applied from within, rather then from without.<br>
<p>
You don't upgrade the contents of a container. You launch an upgraded container.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801072/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor803119"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2019 5:45 UTC (Fri)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/803119/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is generally a good idea - but I find the fixed-state model of containers, that works well for well-designed useful, but simple (in a good way) services inflicts a lot of pain when you apply it to a service whose main point is to manipulate complex state in complex ways. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/803119/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor801053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2019 21:29 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/801053/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
running the test suite on it recording the syscalls would be much more reliable.
</blockquote>
As was noted, the testsuite doesn't have anything like 100% coverage, particularly of error paths (not even SQLite's manages that, and it goes to incredible lengths to get closer than anyone else I've ever heard of) -- and even if it did, changes in the syscalls used by dependent libraries would break things anyway (this is not academic and has happened multiple times. Heck, it's happened multiple times to <i>me alone</i>, so I'm sure it's downright common for this to go wrong.)
<p>
Worse yet, PostgreSQL can execute arbitrary syscalls because it can invoke pluggable language interpreters and much else. I see no sane way to sandbox this without a major rearchitecture to move components seen as vulnerable into sandboxable subprocesses that do nothing else -- and even then you'd have the problem that any decent database server with server-side languages is <i>supposed</i> to execute more or less arbitrary code on behalf of users and is useless if it cannot. Diagnosing which arbitrary operations are suspicious and which are not seems a very difficult problem, and one almost certainly unimplementable under the constraints of seccomp sandboxes (which can look at args but cannot dereference pointers if an arg is a pointer, etc).
      
          <div class="CommentReplyButton">
            <form action="/Articles/801053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor801073"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 0:37 UTC (Wed)
                               by <b>KaiRo</b> (subscriber, #1987)
                              [<a href="/Articles/801073/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just that PostreSQL is not very suitable for containerization as there is no good upgrade path between major versions when you just switch containers and not have both an old and new binary installed in parallel on the same system with pg_upgrade having access to them both (which is almost impossible with containers). I hope this will be solved one day, as it will make pg containers a lot more attractive.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801073/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 0:39 UTC (Wed)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/801074/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
PostgreSQL is not really well-mapped to Docker-style application containers, but I run PostgreSQL inside an LXC/LXD container quite well (after all, it's tastes almost exactly like a VM).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor801090"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 8:45 UTC (Wed)
                               by <b>knan</b> (subscriber, #3940)
                              [<a href="/Articles/801090/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The most promising route there is probably using replication from the still running old major version to the new in a new set of containers. Inconvenient but probably workable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801090/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor801069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2019 23:43 UTC (Tue)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/801069/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One important thing to note is that even if you accidentally block a new syscall and your users update, glibc deals with -ENOSYS **exceptionally** well. So the only thing you really need to worry about is what syscalls PostgreSQL itself uses directly.<br>
<p>
It is a shame that seccomp has become such a complicated beast to use for upstream projects, and it feels as though there needs to be more work put into making seccomp profile generation more usable (as a very hand-wavey example, glibc could include information about what syscalls are called by each libc function -- and then consumers could generate seccomp filters based on those lists -- updating glibc would update the lists of syscalls potentially used).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 0:14 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/801070/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
seccomp+bpf is a bad idea in general. It's really better to use other mechanisms. We also have:<br>
1) SELinux which is unusable and should be trashed.<br>
2) AppArmor that is better but is not compatible with unprivileged users.<br>
3) pledge() call that solves most of the issues but is absent on Linux.<br>
...<br>
<p>
Seriously, Linux security at this point is a huge Rube-Goldbergesque machine that probably no single person understands in its entirety. And it's getting worse, not better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801071"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 0:32 UTC (Wed)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/801071/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree in spirit with your point, but the problem is (as it has been for almost the entire history of Linux) that Conway's Law applies to Linux just as much as it applies to any project. Iterative development within subsystems results in subsystem-specific security features which require users to rope everything together themselves -- you can see this with containers just as easily as you can see it with Linux's security story.<br>
<p>
If we had our own hypothetical pledge(2) proposal you would need to hook together all of the existing security primitives together, which would definitely make for a very lively LKML thread. But for the record, I agree that pledge(2) is a much better model for a security API that userspace sees (with the caveat that it probably should be slightly more granular if we ever get it on Linux but that's a fairly minor bike-shed to paint).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801071/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801096"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 10:54 UTC (Wed)
                               by <b>brauner</b> (subscriber, #109349)
                              [<a href="/Articles/801096/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As Kees mentioned I don't think you need a separate syscall for this. You can get this with seccomp() in userspace.<br>
I agree with your earlier point though, that we need an easier way of generating seccomp profiles.<br>
libseccomp does not provide an abstract enough interface to do this easily. It could grow support probably.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801096/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 14:26 UTC (Wed)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/801103/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You can get this with seccomp() in userspace.</font><br>
<p>
Maybe, but the main benefit of pledge(2) is that the kernel knows what syscalls each pledge refers to -- and any new syscalls will be automatically included. Coming up with a userspace wrapper for this will be (AFAICS) quite difficult for any method you pick (and all the complications boil down to trying to work around the fact that we aren't doing it in-kernel), such as:<br>
<p>
 * You just have hard-coded mappings of pledge(3) arguments to syscall sets. This means you're limited to what syscalls your userspace library understands. This results in new syscalls not being included (and if you expose lower-level seccomp primitives to handle unknown syscalls, you're back at manually-managed seccomp filters).<br>
<p>
 * You use some kind of symbol attribute which lists what syscalls a function calls, and then you're limited to the effectiveness (and overhead) of static analysis (which has to be run at at least partially at run-time because shared libraries can be updated -- though we could probably cache the call graph analysis). This is more resilient to changes, but won't work for all programs.<br>
<p>
 * You expose some kind of metadata about available syscalls from the kernel, which includes some kind of grouping or tags for the syscalls (to allow for you to dynamically add all of the syscalls matching a tag to the whitelist). This is much more flexible, but now you're making pledge-grouping decisions in-kernel -- why not do the whole thing in-kernel?<br>
<p>
And an overarching problem is that (for unknown-to-userspace syscalls), the best you can really do is block the syscall outright. But maybe some pledge(2)s should only block certain flags (an obvious example would be a hypothetical socket(2)-like syscall -- how would you implement pledge(2) for "only allow unix sockets" in user-space without having code that knows about socket(2)?). The last proposal might help solve this if you exposed "enough" metadata, but it feels wrong to me to try to expose a bunch of metadata in the hopes that userspace will be able to make sense of it.<br>
<p>
But then again, I might be missing something obvious. If we can solve this problem in a sane way, I'm all for it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801132"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 14:58 UTC (Wed)
                               by <b>brauner</b> (subscriber, #109349)
                              [<a href="/Articles/801132/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
* You expose some kind of metadata about available syscalls from the kernel<br>
<p>
You mean btf...<br>
<p>
And an overarching problem is that (for unknown-to-userspace syscalls), the best you can really do is block the syscall outright. But maybe some pledge(2)s should only block certain flags (an obvious example would be a hypothetical socket(2)-like syscall -- how would you implement pledge(2) for "only allow unix sockets" in user-space without having code that knows about socket(2)?). The last proposal might help solve this if you exposed "enough" metadata, but it feels wrong to me to try to expose a bunch of metadata in the hopes that userspace will be able to make sense of it.<br>
<p>
You mean btf...<br>
<p>
(I'm only partially trolling btw.)<br>
<p>
We don't actually need pledge(2). seccomp(2) could be extended to do this. There's even precedence SECCOMP_SET_MODE_STRICT is restricting you to a very limited set of syscalls. We could extend seccomp(SECCOMP_PLEDGE, 0, "stdio,sendfd,recvfd") and then seccomp would just create a bpf filter or more elaborate for future extensibility :):<br>
<p>
struct seccomp_pledge pledge;<br>
seccomp(SECCOMP_PLEDGE, 0, &amp;pledge);<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801132/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801133"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 15:08 UTC (Wed)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/801133/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You mean btf...</font><br>
<p>
I was thinking of BTF while writing it, though I don't know if BTF currently gives us the details we want -- we don't just want lists of functions and structure layouts. We need to have a way for the kernel to tell userspace "this syscall is part of the net/tcp plege-set" or something similar (and probably a way to indicate "if this flag is set then the syscall is (also?) part the foobar pledge-set").<br>
<p>
<font class="QuotedText">&gt; We could extend seccomp(SECCOMP_PLEDGE, 0, "stdio,sendfd,recvfd") ...</font><br>
<p>
"What's in a name? That which we call [pledge(2)]<br>
By any other name would [provide the same functionality];"<br>
<p>
#define pledge(list) seccomp(SECCOMP_PLEDGE, 0, list)<br>
<p>
But yes, in that case we are in agreement -- let's do it in-kernel (but taking care to be incompatible with OpenBSD, so that we can pretend we came up with the idea :P).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801133/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 20:37 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/801170/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Part of what makes pledge so convenient are the edge cases. For example, say you don't want a network daemon (or an unprivileged subprocess of a network daemon) to have any access to the file system. But what about /etc/resolv.conf? One of the niceties of pledge is that the "dns" privilege permits opening /etc/resolv.conf even if open(2) is otherwise disallowed. seccomp doesn't permit path name filtering at all.<br>
<p>
OpenBSD added the sendsyslog syscall so that processes could be denied socket access but still be able to use the syslog facility. I don't think this could be emulated with seccomp, either, as filtering on the sun.sun_path argument to bind(2) has the same problems as filtering on the path argument to open(2). You could require processes to open the socket before dropping privileges, but what happens if the syslogd daemon restarts?<br>
<p>
There are several little pragmatic tweaks like this that make pledge functional. A fundamental hurdle on Linux is that the project is so large and diverse that there's enormous pressure to prevent leaky abstractions that require far flung tweaks across the system. Such tweaks are especially brittle in the Linux development model, and people are wary of unintended consequences. That's completely understandable, but sometimes such tweaks are simply unavoidable if your goal is maximizing userland convenience and security. Irreducible complexity has to be apportioned among userland and various kernel subsystems somehow; OpenBSD tends to apportion it quite differently than Linux, partly because of the different development models.<br>
<p>
The irony is that the path of least resistance for Linux has been containers--namespaces, cgroups, etc--which has become precisely the slippery slope of complexity and code churn people feared. (Which is why OpenBSD rejected FreeBSD jails.) Not that containers weren't worth it for their own sake, I just find the path dependency and contradictions interesting.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801179"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 23:41 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/801179/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That convenience comes at the price of baking details of specific userspace behavior --- in your example, DNS resolution and /etc/resolve.conf --- into the kernel, which currently is independent of those details. That's acceptable for OpenBSD which largely controls their userspace and is used in far less diverse ways than Linux, but it is a problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801179/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor801182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2019 6:14 UTC (Thu)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/801182/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; One of the niceties of pledge is that the "dns" privilege permits opening /etc/resolv.conf even if open(2) is otherwise disallowed. seccomp doesn't permit path name filtering at all.</font><br>
<p>
In my view, this is actually a good thing -- pathname filtering based on the string value of the path is (in my view) destined to be a bad idea (I explain this further in [1]). I reckon that the right combination of bind-mounts and AppArmor/SELinux would be a far more effective method for doing this without all of the foot-guns.<br>
<p>
<font class="QuotedText">&gt; There are several little pragmatic tweaks like this that make pledge functional.</font><br>
<p>
I agree that these sorts of niceties are very useful for making pledge(2) much easier to use for userspace, but I'm not convinced that we need to do all of them in-kernel. There is no reason why we can't also have a libpledge which can help deal with some of the more peculiar userspace bits (that are separate from the core "these syscalls on this kernel form this pledge-group" feature we need to be in-kernel).<br>
<p>
[1]: <a href="https://lwn.net/Articles/801187/">https://lwn.net/Articles/801187/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2019 8:51 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/801189/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I reckon that the right combination of bind-mounts and AppArmor/SELinux would be a far more effective method for doing this without all of the foot-guns.</font><br>
SELinux is never a solution...<br>
<p>
AppArmor has several problems, though. In particular, it can't be effectively used in unprivileged contexts. For example, you can't run a program that you just compiled with a custom policy. <br>
<p>
It also was not possible to use AppArmor from inside containers (has this changed?).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor801198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2019 10:48 UTC (Thu)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/801198/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hard coding /etc/resolv.conf is a horrible example of putting policy in the kernel. Name resolution is a library level thing, and even there the resolv.conf file is an implementation detail, not specified by any standards. getaddrinfo() is the POSIX standard name resolution interface, and it can, and has, been implemented without the need for /etc/resolv.conf.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor801079"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 3:06 UTC (Wed)
                               by <b>kees</b> (subscriber, #27264)
                              [<a href="/Articles/801079/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd love to see glibc support pledge(). It knows which of its own APIs map to which syscalls, etc. I don't think there is anything missing from the seccomp interface that a glibc pledge() implementation would need. (And if there was, I'd be happy to help get it implemented in seccomp.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801079/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801081"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 5:50 UTC (Wed)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/801081/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Filtering based on path arguments? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801081/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor801094"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 10:51 UTC (Wed)
                               by <b>brauner</b> (subscriber, #109349)
                              [<a href="/Articles/801094/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hm, we discussed this at KSummit and I'm not sure seccomp is the right tool for this.<br>
Not without introducing all kinds of races or moving that part of seccomp into it's own LSM which has it's own problems.<br>
In general path-based filtering seems LSM territory.<br>
However, we intend to bring aspects of deep argument inspection to seccomp eventually.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801094/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor801160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 18:27 UTC (Wed)
                               by <b>kees</b> (subscriber, #27264)
                              [<a href="/Articles/801160/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Let's skip that bit for now; we can do the rest, though, yes?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor801180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2019 23:44 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/801180/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You probably know this but I haven't seen it mentioned: Firefox and Chrome sandboxes implement path filtering by having seccomp filters trigger SIGSYS on path-related syscalls, and having the signal handler fake the syscall using IPC to a trusted broker process.<br>
<p>
It's not great for performance, but a pledge-like sandboxing library/API can take this approach.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor801187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">PostgreSQL considers seccomp() filters</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2019 6:09 UTC (Thu)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/801187/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'll admit that I'm not convinced that pathname-as-a-string filtering is a good idea (though I'd love to know what usecases it would provide real protection in). Unless you restrict the set of syscalls the process can use to be incredibly small (i.e. only allowing open("/foo", O_RDWR) and no other filesystem-related syscalls), there are all sorts of ways you can get around pathname restrictions (symlink races, bind-mounts in mount namespaces, magic-links, and so on).<br>
<p>
If the purpose would be stop malicious programs from doing something bad -- I think it would be more productive to just use mount namespaces and isolate away the rest of the filesystem entirely. Maybe you could make use of path-based filtering in combination with a read-only mount namespace, but I'm still not completely convinced.<br>
<p>
If the purpose is to stop a trusted program from being tricked into operating on the wrong kinds of paths by an attacker, I think openat2 and the stuff I'm working on with libpathrs[1] (which takes advantage of existing tricks involving O_PATH and procfs) would be a better solution.<br>
<p>
[1]: <a href="https://github.com/openSUSE/libpathrs">https://github.com/openSUSE/libpathrs</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/801187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
