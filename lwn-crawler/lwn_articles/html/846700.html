        <!DOCTYPE html>
        <html lang="en">
        <head><title>Lockless patterns: relaxed access and partial memory barriers [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/846700/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/847387/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/846700/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Lockless patterns: relaxed access and partial memory barriers</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>February 26, 2021</p>
           <p>This article was contributed by Paolo Bonzini</p>
           <hr>
<a href="/Articles/844224/">Lockless patterns</a>
</div>
The <a href="/Articles/844224/">first article in this series</a> provided
an introduction to lockless algorithms and the <i>happens before</i>
relationship that allows us to reason about them.  The next step is to look
at the concept of a "data race" and the primitives that exist to prevent
data races.  We continue in that direction with a look at relaxed accesses, memory
barriers, and how they can be used to implement the kernel's seqcount
mechanism.

<p>
Memory barriers are an old acquaintance for some Linux kernel programmers.
The first document vaguely resembling a specification of what one could
expect from concurrent accesses to data in the kernel is, in fact, called
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/memory-barriers.txt"><tt>memory-barriers.txt</tt></a>.
That document describes many kinds of memory barriers, along with the expectations
that Linux has concerning the properties of data and control dependencies.
<!-- note we don't define data/control dependencies -->
It also describes "memory-barrier pairing"; this could be seen as a cousin
of release-acquire pairing, in that it also helps creating cross-thread
<em>happens before</em> edges.

</p><p>
This article will not go into the same excruciating detail as
<tt>memory-barriers.txt</tt>. Instead, we'll look at how barriers compare
with the acquire and release model and how they simplify or enable the
implementation of the seqcount primitive.  Nevertheless, one article
will not be enough to cover even the most common memory-barrier patterns,
so full memory barriers will have to wait for the next
installment.


</p><h4>Data races, relaxed accesses, and memory barriers</h4>

<p>
The concept of a data race, as presented here, was first introduced
in C++11 and, since then, has been applied to various other languages,
notably C11 and Rust.  These language standards are quite strict in how to
approach lockless access to data structures, and they introduce specific
<em>atomic load</em> and <em>atomic store</em> primitives to do so.

</p><p>
A data race occurs when two accesses are concurrent (i.e., not ordered by
the <em>happens before</em> relation), at least one of them is a store,
and at least one of them is not using atomic load or store
primitives.  Whenever a data race occurs, the result (according to C11/C++11)
is undefined behavior, meaning that anything is allowed to happen.
Avoiding data races does not mean that your algorithm 
is free of "race conditions": data races are violations of the language
standards, while race conditions are bugs that stem from incorrect
locking, incorrect acquire/release semantics, or both.

</p><p>
Data races and the consequent undefined behavior are easy to avoid,
however.  As long as one wants to store to a shared data location, which is probably
the case, there are two ways to do so.  The first is to ensure that
accesses are ordered by the <em>happens before</em> relation, using any
pair of acquire and release operations of your choice; the second is to
annotate the loads and stores as atomic.

</p><p>
C11, C++11, and Rust all provide various <em>memory orderings</em>
that the programmer can use for their loads and stores; the three that we are
interested in are acquire (to be used with loads), release (for stores), and
relaxed (for both).  Acquire and release should be self-explanatory by
now, and Linux provides the same concept in its <tt>smp_load_acquire()</tt>
and <tt>smp_store_release()</tt> operations.  Relaxed operations, instead, do not
provide any cross-thread ordering; a relaxed operation does not create a
<i>happens before</i> relationship.  Instead, these operations have
essentially no purpose other than to avoid data races and the undefined
behavior associated with them.

</p><p>
In practice, Linux expects both the compiler and the CPU to allow a bit more
leeway than the language standards do.  In particular, the kernel expects
that regular loads and stores will 
not trigger undefined behavior just because there is a concurrent store.
However, the value that is loaded or stored in such situations is still not
well defined and may well be garbage.
For example, the result could
include parts of an old value and parts of a new value; this means
that, at the very least, dereferencing pointer values loaded from a data
race is generally a bad idea.
</p><p>
In addition, regular loads and stores
are subject to compiler optimizations, which can produce surprises
of their own.  Therefore the idea of a
relaxed-ordering — but guaranteed atomic — memory operation is useful in
Linux too;  this is what the <tt>READ_ONCE()</tt> and
<tt>WRITE_ONCE()</tt> macros provide.  In general the remainder of
this series will always use <tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt> 
explicitly, which nowadays is considered good practice by Linux
developers.

</p><p>
These macros already appeared in an example from part 1:
<a name="mp-with-barriers"></a>
</p><pre>    thread 1                          thread 2
    -----------------------------     ------------------------
    a.x = 1;
    smp_wmb();
    WRITE_ONCE(message, &amp;a);          datum = READ_ONCE(message);
                                      smp_rmb();
                                      if (datum != NULL)
                                        printk("%x\n", datum-&gt;x);
</pre>

<p>
They are used in a similar way to <tt>smp_load_acquire()</tt>
and <tt>smp_store_release()</tt>, but their first argument is the
target of the assignment (an <em>lvalue</em>) rather than a pointer.
Unless other mechanisms ensure that the result of a data
race is thrown away, it is highly recommended to use <tt>READ_ONCE()</tt>
and <tt>WRITE_ONCE()</tt> to load
and store shared data outside a lock.


Typically, relaxed atomics are used together with some other primitive
or synchronization mechanism that has release and acquire semantics;
that "something else" will order the relaxed writes against reads of
the same memory location.
</p><p>
Suppose, for example, that you have multiple work items that
fill certain elements of an array with ones; whoever spawned the
work items will only read the array after calling <tt>flush_work()</tt>.
Similar to <tt>pthread_join()</tt>, <tt>flush_work()</tt> has acquire semantics
and synchronizes with the end of the work item; <tt>flush_work()</tt>
guarantees that reading the array will <em>happen after</em> the completion of
the work items, and the array can be read with regular loads.  However,
if multiple, concurrent work items can store into the same array
element, they must use <tt>WRITE_ONCE(a[x],&nbsp;1)</tt> rather than just
<tt>a[x]&nbsp;=&nbsp;1</tt>.

</p><p>
A more complicated case occurs when the release and acquire semantics are
provided by a memory barrier.  In order to explain this case we will
use the practical example of seqcounts.

</p><h4>Seqcounts</h4>

<p>
<a href="https://lwn.net/Articles/831540/">Seqcounts</a> are a specialized
primitive that allows a consumer to detect that a data structure changed
in the middle of the consumer's access.  While they are only usable in special
cases (small amount of data being protected, no side effects within
read-side critical sections, and writes being quick and relatively rare),
they have various interesting properties: in particular,
readers do not starve writers and the writer can keep <a href="https://en.wikipedia.org/wiki/MOESI_protocol">ownership</a> of
the cache line that holds the seqcount.  Both properties make seqcounts
particularly interesting when scalability is important.

</p><p>
Seqcounts are a single-producer, multiple-consumer primitive.  In order
to avoid multiple concurrent writers, they are usually combined with a
spinlock or mutex, forming the familiar Linux <tt>seqlock_t</tt> type.
Sometimes, outside the kernel, you'll see seqcounts referred to as seqlocks,
however.

</p><p>
Seqcounts are effectively a generation count, where the generation number
is odd if and only if a write is in progress.  Whenever the generation number
was odd at the beginning of a read-side critical section, or it changed during
the read-side critical section, the reader has accessed potentially inconsistent
state and must retry the read.  For a seqcount to work correctly, the reader
must detect correctly the beginning and the end of the write.  This requires
two load-acquire and two store-release operations; here is how one might
write a seqcount reader and writer without any wrapper APIs:

</p><pre>    thread 1 (buggy writer)             thread 2 (buggy reader)
    --------------------------------    ------------------------
    WRITE_ONCE(sc, sc + 1);             do {
    smp_store_release(&amp;data.x, 123);        old = smp_load_acquire(&amp;sc) &amp; ~1;
    WRITE_ONCE(data.y, 456);                copy.y = READ_ONCE(data.y);
    smp_store_release(&amp;sc, sc + 1);         copy.x = smp_load_acquire(&amp;data.x);
                                        } while(READ_ONCE(sc) != old);
</pre>

<p>
This code is similar to the "message passing" pattern shown in the first
part of the series.
There are two pairs of load-acquire and 
store-release operations, one set for <tt>sc</tt> and one for <tt>data.x</tt>.
It is not even that hard to show
why both load-acquire/store-release pairs are necessary:

</p><ul class="spacylist">
  <li>For thread&nbsp;2 to exit the loop, the first read of <tt>sc</tt>
  must see the even value that was written by the second store to <tt>sc</tt>
  in thread&nbsp;1.
  If this happens, <tt>smp_store_release()</tt> and <tt>smp_load_acquire()</tt>
  ensure that the stores to the <tt>data</tt> fields will be visible.

</li><li>If the store to <tt>data.x</tt> is visible when thread&nbsp;2 reads it,
  <tt>smp_store_release()</tt> and <tt>smp_load_acquire()</tt> ensure that
  thread&nbsp;2 will see (at least) the first generation-count update.  Thus, thread&nbsp;2
  will either loop or, if it also sees the second update, retrieve a consistent
  copy of the new data as described above.
</li></ul>

<p>
However, the code has a bug!  Because the writer has no acquire operation
at the top of the sequence, the write to <tt>data.y</tt> might execute
before writing the odd value to <tt>sc</tt>.  [<b>Note</b>: the article
was updated on March 2nd to point out this problem].  Using
load-acquire/store-release 
for all fields would sidestep the issue, but one wonders if this would
be putting lipstick on a pig.  And in fact it is possible to do much
better.

</p><p>
The first article showed that older Linux code may use 
<tt>smp_wmb()</tt> followed by <tt>WRITE_ONCE()</tt> rather than
<tt>smp_store_release()</tt> ; likewise, instead of <tt>smp_load_acquire()</tt>,
sometimes <tt>READ_ONCE()</tt> is followed by <tt>smp_rmb()</tt>.  These
partial barriers create specific types of <i>happens before</i> relations.
Specifically (but informally), <tt>smp_wmb()</tt> turns all the following relaxed
stores into release operations and <tt>smp_rmb()</tt> turns all the
preceding relaxed loads into acquire operations.

</p><p>
Let's try
to apply this replacement to the <tt>data.x</tt> accesses:

</p><pre>    thread 1 (writer)                   thread 2 (reader)
    ------------------------------      ------------------------
    // write_seqcount_begin(&amp;sc)        do {
    <b>WRITE_ONCE(sc, sc + 1);</b>                 // read_seqcount_begin(&amp;sc)
    <b>smp_wmb();</b>                              <b>old = smp_load_acquire(&amp;sc) &amp; ~1;</b>
    WRITE_ONCE(data.x, 123);                copy.y = READ_ONCE(data.y);
    WRITE_ONCE(data.y, 456);                copy.x = READ_ONCE(data.x);
    // write_seqcount_end(&amp;sc)              // read_seqcount_retry(&amp;sc, old)
    <b>smp_store_release(&amp;sc, sc + 1);</b>         <b>smp_rmb();</b>
                                        } while(<b>READ_ONCE(sc) != old</b>);
</pre>

<p>
Leaving aside the question of how barriers work, this already has much
better chances of being wrapped with an easy-to-use API.
Data is accessed entirely with relaxed atomic loads and stores (though
in the Linux kernel memory model non-atomic accesses would be acceptable
too), and the barriers could be hidden within the seqcount primitives
<tt>read_seqcount_retry()</tt> and <tt>write_seqcount_begin()</tt>.

</p><p>
The barriers inserted above split the reads and writes into two
separate groups; this ensures the safety
of seqcount accesses.  However, there are two
complications:

</p><ul class="spacylist">
<li>First, the barriers do not impose an order among the relaxed accesses
  themselves.  It is possible that thread&nbsp;2 sees the update to
  <tt>data.y</tt> and not the update to <tt>data.x</tt>.  This is not
  a problem for seqcounts, because the check on <tt>sc</tt> forces
  thread&nbsp;2 to retry in case it saw only some of the stores.

</li><li>Second, the barriers are weaker than load-acquire and store-release
  operations.  A read with <tt>smp_load_acquire()</tt> happens before
  any loads <em>and stores</em>
  that follow it, and likewise <tt>smp_store_release()</tt> happens after
  not just preceding stores, but also after preceding loads.  Instead,
  for <tt>smp_rmb()</tt>, the ordering is only guaranteed among loads,
  and, for <tt>smp_wmb()</tt>, only among stores.  Load-store ordering however
  rarely matters, which is why Linux developers only used <tt>smp_rmb()</tt>
  and <tt>smp_wmb()</tt> for a long time.
</li></ul>

<p>
In the case of seqcounts, load-store ordering is not a problem, because
the reader does not perform any writes to shared memory in its critical
section, thus there cannot be concurrent changes to shared memory 
between the writer's updates of the generation count.  There's a little
bit of handwaving in this reasoning, but it is actually sound as long
as the code is kept simple and faithful to the pattern.  If the reader
needed to write to shared memory, it would suffice to protect those writes with a
different mechanism than the seqcount.

</p><p>
While informal, the explanation in the previous paragraph highlights
the importance of knowing the common lockless programming patterns.
In short, patterns enable thinking about code at a more coarse
level without losing precision.  Instead of looking at each memory
access individually, you can make statements like "<tt>data.x</tt> and
<tt>data.y</tt> are protected by the seqcount <tt>sc</tt>" or, referring
to the <a href="#mp-with-barriers">earlier message passing example</a>,
"<tt>a</tt> is published to other threads via <tt>message</tt>".  To some
extent, proficiency in lockless programming patterns means being able
to make such statements and take advantage of them to understand the code.
</p><p>
This concludes our initial look at memory barriers.  There is a lot more to
this topic than has been covered so far, naturally; the next installment in
this series will delve into full memory barriers, how they work, and how
they are used in the kernel.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Lockless_algorithms">Lockless algorithms</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_barriers">Memory barriers</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Bonzini_Paolo">Bonzini, Paolo</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/846700/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor847637"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2021 11:57 UTC (Sat)
                               by <b>PengZheng</b> (subscriber, #108006)
                              [<a href="/Articles/847637/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m confused by the first Seqcounts example. Consider the following:<br>
<p>
    thread 1 (writer)<br>
    -------------------------------- <br>
    WRITE_ONCE(sc, sc + 1);  // sc == 1<br>
    smp_store_release(&amp;data.x, 123);<br>
    WRITE_ONCE(data.y, 456);<br>
    smp_store_release(&amp;sc, sc + 1); // sc == 2<br>
<p>
    WRITE_ONCE(sc, sc + 1);  // sc == 3<br>
    smp_store_release(&amp;data.x, 567);<br>
    WRITE_ONCE(data.y, 890);<br>
    smp_store_release(&amp;sc, sc + 1); // sc == 4<br>
<p>
    thread 2<br>
    ------------------------<br>
    do {<br>
        old = smp_load_acquire(&amp;sc) &amp; ~1; // old ==2<br>
        copy.y = READ_ONCE(data.y);<br>
        copy.x = smp_load_acquire(&amp;data.x); // x == 123<br>
    } while(READ_ONCE(sc) != old);<br>
<p>
What forced data.y to be 456 instead of 890? Neither &quot;smp_store_release(&amp;data.x, 567)&quot; nor &quot;smp_store_release(&amp;sc, sc + 1)&quot; prevents WRITE_ONCE(data.y, 890) from moving before them.<br>
<p>
Please enlighten me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847637/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847638"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2021 12:01 UTC (Sat)
                               by <b>PengZheng</b> (subscriber, #108006)
                              [<a href="/Articles/847638/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
thread 2<br>
------------------------<br>
do {<br>
old = smp_load_acquire(&amp;sc) &amp; ~1; // old ==2<br>
copy.y = READ_ONCE(data.y);<br>
copy.x = smp_load_acquire(&amp;data.x); // x == 123<br>
} while(READ_ONCE(sc) != old); // READ_ONCE(sc) == 2<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847638/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847642"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2021 12:30 UTC (Sat)
                               by <b>PengZheng</b> (subscriber, #108006)
                              [<a href="/Articles/847642/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Try to answer my own question after reading the second Seqcounts example:  <br>
1. smp_load_acquire(&amp;data.x) turns READ_ONCE(data.y) into a acquire op.<br>
2. smp_store_release(&amp;data.x, 123) turns WRITE_ONCE(data.y, 456) into a release op.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847642/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847666"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2021 23:11 UTC (Sat)
                               by <b>randomguy3</b> (subscriber, #71063)
                              [<a href="/Articles/847666/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My understanding is that if READ_ONCE(data.y) observes the write of 890, then that means the smp_load_acquire(&amp;sc) before it synchronises with (happens after) smp_store_release(&amp;data.x, 567). That, in turn, means READ_ONCE(sc) will see the write of 3 to sc (or a later write to sc), and we&#x27;ll go round the loop again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847666/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847668"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2021 23:18 UTC (Sat)
                               by <b>randomguy3</b> (subscriber, #71063)
                              [<a href="/Articles/847668/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, no, wait, the wording from the first article suggests the store and load have to refer to the same variable/memory location in order to synchronise, which makes sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847668/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847672"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2021 4:08 UTC (Sun)
                               by <b>PengZheng</b> (subscriber, #108006)
                              [<a href="/Articles/847672/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If READ_ONCE(data.y) observes the write of 890, then READ_ONCE(sc) &gt;= 3. Why? <br>
Because smp_store_release(&amp;data.x, 567) is a stronger form of <br>
<p>
    smp_wmb();                             <br>
    WRITE_ONCE(data.x, 567);<br>
<p>
copy.x = smp_load_acquire(&amp;data.x) is a stronger form of<br>
<p>
    copy.x = READ_ONCE(data.x)<br>
    smp_rmb();<br>
<p>
smp_wmb() makes both WRITE_ONCE(data.x, 567) and WRITE_ONCE(data.y, 890) into release operations, while smp_rmb() makes both READ_ONCE(data.y) and READ_ONCE(data.x) into acquire operations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847672/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847673"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2021 4:19 UTC (Sun)
                               by <b>PengZheng</b> (subscriber, #108006)
                              [<a href="/Articles/847673/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
WRITE_ONCE(data.y, 890) after smp_wmb() sync with READ_ONCE(data.y) before smp_rmb().<br>
<p>
In thread 1 we have<br>
WRITE_ONCE(sc, sc + 1); // sc == 3<br>
happens before <br>
smp_wmb();<br>
WRITE_ONCE(data.y, 890);<br>
<p>
In thread 2 we have<br>
copy.y = READ_ONCE(data.y);<br>
smp_rmb();<br>
happens before READ_ONCE(sc)<br>
<p>
Thus WRITE_ONCE(sc, sc + 1); // sc == 3<br>
happens before READ_ONCE(sc) in thread 2.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847673/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor847674"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uh-oh</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2021 6:33 UTC (Sun)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/847674/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      &gt; "smp_store_release(&amp;data.x, 567)" is a stronger form of "smp_wmb(); WRITE_ONCE(data.x, 567);"

<p>This is not entirely correct, because barriers are bidirectional while store-release is unidirectional.

<p>I tried putting this in <a href="http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/index.html">CPPMEM</a>:

<pre>
int main() {
  atomic_int sc = 2;
  atomic_int x = 123;
  atomic_int y = 456;
  {{{
   {
     sc.store(3, memory_order_relaxed);
     x.store(567, memory_order_release);
     y.store(890, memory_order_relaxed);
     // sc.store(4, memory_order_release);
   }
  |||
   {
     sc.load(memory_order_acquire).readsvalue(2);
     r1 = y.load(memory_order_relaxed);
     r2 = x.load(memory_order_acquire).readsvalue(123);
   }
  }}};
  return 0;
}
</pre>

<p>and you are probably correct. The simplest fix is to use load-acquire/store-release for y as well. I'll write up a fix and ask our editor to update the article.
      
          <div class="CommentReplyButton">
            <form action="/Articles/847674/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">wmb, smp_wmb, and store-release </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2021 3:00 UTC (Mon)
                               by <b>PengZheng</b> (subscriber, #108006)
                              [<a href="/Articles/847711/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This is not entirely correct, because barriers are bidirectional while store-release is unidirectional. </font><br>
<p>
Thanks for correcting my misunderstanding. I read the following for a brief explanation of memory barriers:<br>
<a href="http://bruceblinn.com/linuxinfo/MemoryBarriers.html">http://bruceblinn.com/linuxinfo/MemoryBarriers.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor847723"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uh-oh</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2021 8:41 UTC (Mon)
                               by <b>peda</b> (subscriber, #5285)
                              [<a href="/Articles/847723/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are you sure you&#x27;re not just putting lipstick on a pig?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847723/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Uh-oh</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2021 11:24 UTC (Mon)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/847725/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed. :)<br>
<p>
But memory barriers do work, they are bidirectional.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor847688"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2021 18:02 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/847688/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; A data race occurs when two accesses are concurrent (i.e., not ordered by the happens before relation), at least one of them is a store, and at least one of them is not using atomic load or store primitives.</font><br>
<p>
This definition seems very old, wikipedia quotes a paper from 1991:<br>
<p>
<a href="https://en.wikipedia.org/wiki/Race_condition#Example_definitions_of_data_races_in_particular_concurrency_models">https://en.wikipedia.org/wiki/Race_condition#Example_defi...</a><br>
<p>
<font class="QuotedText">&gt; The concept of a data race, as presented here, was first introduced in C++11 and, since then, has been applied to various other languages, notably C11 and Rust.</font><br>
<p>
The Java memory model was formalized in 2004. How did it not include the concept of a data race?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847688/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2021 18:12 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/847690/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The Java memory model was formalized in 2004. How did it not include the concept of a data race?</font><br>
<p>
The key words are &quot;as presented here&quot;. Java/JVM would, presumably, differ in some details here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847704"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2021 1:23 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/847704/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure and &quot;undefined behavior&quot; is one of the implementation details that seem to differ.<br>
However the lack of references to earlier work makes it very to misinterpreted this paragraph as if the concept of data race was pioneered by C/C++11. I&#x27;m no expert but I suspect the reality is more like C/C++ defined their memory models very late; decades after both memory models _and_ the languages were a thing and that they merely adjusted very old concepts. So hinting at the existence of prior art wouldn&#x27;t hurt. I realize LWN articles are not peer-reviewed IEEE articles but their quality often comes close which naturally raises expectations :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847704/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor847718"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2021 8:33 UTC (Mon)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/847718/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The C++11 memory model indeed came out after Java&#x27;s, but despite being based on the same theoretical framework it&#x27;s quite different; I left it out because most of the material in here is not applicable.<br>
<p>
At a high level, the Java memory model defines synchronize-with relations for higher level constructs, such as &quot;synchronized&quot; blocks, constructors, finalizers etc. C++ (and C/Rust) only define fences and atomic memory operations. It also doesn&#x27;t have undefined behavior, for example data races cannot cause out-of-bounds array accesses.<br>
<p>
The biggest difference however is that it does not have memory orderings or separate fences. Everything is either declared volatile, or writes must not be concurrent with reads. For example, seqcounts cannot be implemented in Java without massive performance issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/847718/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor849910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2021 4:55 UTC (Sat)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/849910/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Reading the article made me wonder how &quot;volatile&quot; itself worked.   Here is &quot;When is a Volatile Object Accessed?&quot; from GCC: <br>
<p>
<a href="https://gcc.gnu.org/onlinedocs/gcc/Volatiles.html#Volatiles">https://gcc.gnu.org/onlinedocs/gcc/Volatiles.html#Volatiles</a><br>
<p>
Short summary is, one should insert an ASM memory barrier to prevent writes and reads from being reordered.  Presumably they compile to the same bits as an rmb().<br>
<p>
Paging device manufacturers! GCC opines that &quot;it is unwise to use volatile bit-fields to access hardware.&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor849923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2021 14:25 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/849923/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Paging device manufacturers! GCC opines that &quot;it is unwise to use volatile bit-fields to access hardware.&quot;</font><br>
<p>
I thought that was the justification for introducing volatile! That other actors *do* have access to that memory location, and *will* be reading/writing to it.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor849925"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2021 15:42 UTC (Sat)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/849925/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hardware can have all kinds of odd access requirements and there is no way to define these with C bitfields, volatile or not.<br>
<p>
Do you read 16 bits, modify 3 of them and write it back? Or is it 32 bits or 8 bits?<br>
<p>
And I believe some hardware does not allow reading. Instead you need to keep a shadow copy and write the whole byte, word, double word or whatever.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849925/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor849924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2021 15:27 UTC (Sat)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/849924/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Short summary is, one should insert an ASM memory barrier to prevent writes and reads from being reordered. Presumably they compile to the same bits as an rmb().</font><br>
<p>
They don&#x27;t - &#x27;asm volatile (&quot;&quot;:::&quot;memory&quot;)&#x27; compiles to zero bits. It&#x27;s only preventing the compiler from reordering memory accesses across the barrier, not the CPU. Specifically it&#x27;s telling the compiler &quot;this (empty) string of assembly code might read or write memory, and I&#x27;m not going to say exactly which parts of memory&quot;, which prevents the compiler making assumptions about the contents of any memory after that point. E.g. it can&#x27;t assume that reading the same variable before and after the barrier will return the same value, regardless of whether it was declared volatile or not, so it can&#x27;t reorder the read across the barrier and it can&#x27;t cache the value in a register.<br>
<p>
The CPU knows nothing about that compiler barrier and may still decide to reorder memory accesses. rmb() etc emit special assembly instructions that will constrain the CPU&#x27;s reordering too.<br>
<p>
<font class="QuotedText">&gt; Paging device manufacturers! GCC opines that &quot;it is unwise to use volatile bit-fields to access hardware.&quot;</font><br>
<p>
I misread that at first, so I think it&#x27;s worth noting that it&#x27;s specifically about volatile bit-fields, not volatile in general. (Typically the bit-field accesses will be translated into read/write sequences over bytes or words. It&#x27;s common for hardware register reads to have side effects and be non-idempotent, so the compiler inserting an implicit read to implement the bit-field semantics may be very surprising to the programmer who thought they were just doing a write. So when accessing hardware registers (instead of normal RAM), you should stick with reading/writing whole bytes/words (depending on architecture) and do the bit manipulation explicitly to avoid surprises. And then use volatile, plus compiler barriers and memory barriers where the hardware is sensitive about the order of operations.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor849942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2021 4:39 UTC (Sun)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/849942/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; They don&#x27;t - &#x27;asm volatile (&quot;&quot;:::&quot;memory&quot;)&#x27; compiles to zero bits. . . . rmb() etc emit special assembly instructions that will constrain the CPU&#x27;s reordering too.</font><br>
<p>
Is rmb() likely to emit the same ASM as &#x27;asm volatile (&quot;&quot;:::&quot;memory&quot;)&#x27; though?   Let me guess that the answer is, it depends on the architecture.<br>
<p>
In a header file I chanced to read today one finds &quot;__asm__ __volatile__&quot;.   Presumably those are compiler directives that result in the other ASM directive?<br>
<p>
<font class="QuotedText">&gt; The CPU knows nothing about that compiler barrier and may still decide to reorder memory accesses. </font><br>
<p>
Does turning off any of the various forms of speculative execution affect memory reordering?   Perhaps reordering has more to do with some accesses coming from the cache or corresponding to TLB hits and others not?<br>
<p>
<font class="QuotedText">&gt;when accessing hardware registers (instead of normal RAM), you should stick with reading/writing whole bytes/words (depending on architecture)</font><br>
<p>
As far as I know, there is not a hardware way to read individual bit unless one includes GPIO output levels.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor849947"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 21, 2021 11:42 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/849947/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Is rmb() likely to emit the same ASM as &#x27;asm volatile (&quot;&quot;:::&quot;memory&quot;)&#x27; though? Let me guess that the answer is, it depends on the architecture.</font><br>
<p>
On e.g. x86 (<a href="https://elixir.bootlin.com/linux/latest/source/arch/x86/include/asm/barrier.h#L22">https://elixir.bootlin.com/linux/latest/source/arch/x86/i...</a>) it combines the mfence/lfence/sfence instruction (to prevent CPU reordering) with the &quot;memory&quot; clobber argument (to prevent compiler reordering). (The important part is the &quot;memory&quot;, not the &quot;asm volatile&quot;). I&#x27;d guess all architectures will do a similar memory clobber because they all need to prevent compiler reordering across the barrier.<br>
<p>
<font class="QuotedText">&gt; Does turning off any of the various forms of speculative execution affect memory reordering? Perhaps reordering has more to do with some accesses coming from the cache or corresponding to TLB hits and others not?</font><br>
<p>
Speculation might have some effect, but even without speculation the CPU may still execute non-dependent instructions out-of-order, so it can reorder two memory instructions if there&#x27;s no implicit dependency (by the architecture specification) or explicit dependency (by a fence/barrier instruction) between them. It might be more likely to do that if the first instruction was a cache miss and it can complete the second instruction while waiting, but there&#x27;s nothing stopping it reordering for any arbitrary reason.<br>
<p>
And even without out-of-order execution of instructions, it might still reorder the RAM operations (and that reordering would be visible to other CPUs accessing the same RAM). E.g. a store instruction will typically write into a per-CPU store buffer, which is not flushed to L1/L2/RAM until some time later. If the same CPU loads a different address from RAM after the store instruction but before the flush, then RAM will see the load before the store. (I think L1/L2 caches can be ignored here since cache coherency means they&#x27;ll behave equivalently to a global shared RAM; the problem is the store buffer which is a kind of cache but doesn&#x27;t participate in the coherency protocol). x86 mostly guarantees sequential consistency, and the store buffer is the main exception to that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849947/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2021 4:34 UTC (Wed)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/850255/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;(I think L1/L2 caches can be ignored here since cache coherency means they&#x27;ll behave </font><br>
<font class="QuotedText">&gt;equivalently to a global shared RAM; the problem is the store buffer which is a kind of cache but &gt;doesn&#x27;t participate in the coherency protocol). x86 mostly guarantees sequential consistency, &gt;and the store buffer is the main exception to that.</font><br>
<p>
J.F. Bastien and Chris Leary just discussed that very topic at their excellent TLB Hits podcast under &quot;Multiprocessing Teaser&quot;:<br>
<p>
<a href="https://tlbh.it/000_mov_fp_sp.html">https://tlbh.it/000_mov_fp_sp.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor850151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 9:51 UTC (Tue)
                               by <b>daenzer</b> (subscriber, #7050)
                              [<a href="/Articles/850151/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C bit-fields are mostly useless for modelling hardware registers for various other reasons as well, in particular if the code needs to work on multiple host architectures (since the memory layout of bit-fields is left as implementation defined in the C spec).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor849070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2021 14:11 UTC (Thu)
                               by <b>jogness</b> (subscriber, #49775)
                              [<a href="/Articles/849070/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What is interesting is that mainline does not implement seqcount as described here. Both write_seqcount_end() and read_seqcount_begin() are using the heavier full write and read memory barriers, respectively. Should this be fixed in mainline or is there perhaps an additional rule implied in the seqcount semantics? For example, perhaps stores after write_seqcount_end() should not be visible to seqcount readers before stores in the writer critical section. Such a rule would require the heavier memory barriers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor849173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2021 14:01 UTC (Fri)
                               by <b>nunojsa</b> (guest, #107530)
                              [<a href="/Articles/849173/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;However, the code has a bug! Because the writer has no acquire operation at the top of the sequence, the write to data.y might execute before writing the odd value to sc&quot;<br>
<p>
I&#x27;m very puzzled by this sentence :D... This refers to the fist seqcount example. Maybe I&#x27;m just misunderstanding the whole thing but how can WRITE_ONCE(data.y, 456) execute before writing the odd value to sc?? As far as I understand (at least on the linux kernel generic implementation), smp_store_release(&amp;data.x, 123) evaluates to something like:<br>
<p>
__smp_mb(); //which is for loads and stores...<br>
WRITE_ONCE(data.y, 456);<br>
<p>
Hence, there&#x27;s no order guarantees between data.x and data.y but shouldn&#x27;t __smp_mb(); guarantee that WRITE_ONCE(data.y, 456) does not get reordered to before this barrier and so the odd value to sc?<br>
<p>
Maybe smp_store_release() here does not imply a barrier? Is that what I&#x27;m missing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor852876"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2021 7:03 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/852876/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      The generic implementation of smp_mb() is stronger than what smp_store_release() requires. See <a href="https://lwn.net/Articles/847674/">here</a> for a CPPMEM test that shows the problem.
      
          <div class="CommentReplyButton">
            <form action="/Articles/852876/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor854436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2021 9:04 UTC (Mon)
                               by <b>nunojsa</b> (guest, #107530)
                              [<a href="/Articles/854436/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;The generic implementation of smp_mb() is stronger than what smp_store_release() requires&quot;<br>
<p>
Yes, I get that :).<br>
<p>
Using CPPMEM I could see the issue on c++ memory model. I guess my problem is that I was only thinking in how could it happen in the kernel (which I think it can&#x27;t)...<br>
<p>
Thanks!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/854436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor851611"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 5, 2021 10:06 UTC (Mon)
                               by <b>naveenmv7</b> (guest, #141627)
                              [<a href="/Articles/851611/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
old = smp_load_acquire(&amp;sc) &amp; ~1;<br>
<p>
Here I assume we are checking if sc is odd or even by looking at the last bit.<br>
<p>
In that case, shouldn&#x27;t this be<br>
<p>
old = smp_load_acquire(&amp;sc) &amp; 1;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/851611/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor851612"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 5, 2021 10:09 UTC (Mon)
                               by <b>naveenmv7</b> (guest, #141627)
                              [<a href="/Articles/851612/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Never mind. We are checking the current sc value against the previous. Not the parity.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/851612/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor882060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lockless patterns: relaxed access and partial memory barriers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2022 12:30 UTC (Fri)
                               by <b>rharjani</b> (subscriber, #87278)
                              [<a href="/Articles/882060/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;Data is accessed entirely with relaxed atomic loads and stores (though in the Linux kernel memory model non-atomic accesses would be acceptable too)&quot;<br>
<p>
Could you throw some light on the comment between brackets? i.e. In Linux kernel memory model, non-atomic accesses would be acceptable too?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/882060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
