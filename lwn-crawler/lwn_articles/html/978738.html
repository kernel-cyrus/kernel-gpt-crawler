        <!DOCTYPE html>
        <html lang="en">
        <head><title>Rust for filesystems [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/978738/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/979085/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/978738/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Rust for filesystems</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>June 21, 2024</br>
           <hr>
<a href="/Articles/lsfmmbpf2024/">LSFMM+BPF</a>
</div>
<p>
At the
2024 <a
href="https://events.linuxfoundation.org/lsfmmbpf/">Linux Storage,
Filesystem, Memory Management, and BPF Summit</a>, Wedson Almeida Filho and
Kent Overstreet led a combined storage and filesystem session on using Rust
for Linux filesystems. Back in December 2023, Almeida had <a
href="/ml/linux-fsdevel/20231018122518.128049-1-wedsonaf@gmail.com/">posted
an RFC patch set</a> with
some Rust abstractions for filesystems, which resulted in <a
href="/Articles/958072/">some disagreement over the approach</a>.  On the
same mid-May day as the session, he <a
href="https://lwn.net/ml/all/20240514131711.379322-1-wedsonaf@gmail.com/">posted</a>
a second version of the RFC patches, which he wanted to discuss along with
other Rust-related topics.
</p>

<h4>Goals</h4>

<p>
After updating attendees on the status of his patches, Almeida listed some
of the goals of the <a href="https://rust-for-linux.com/">Rust-for-Linux
project</a>, which are embodied in the filesystem abstractions that he is proposing.  The first is to express more of the requirements using Rust's
type system in order to catch more mistakes at compile time.  In addition,
the project's developers want to automate some tasks, such as cleaning up
resources, in ways that are not easily
available to C code. The overall idea is to have a more productive
filesystem-development experience, with less time spent on debugging
problems that the compiler could find, and with fewer memory-related
vulnerabilities overall.
</p>

<a href="https://lwn.net/Articles/979161/">
<img src="https://static.lwn.net/images/2024/lsfmb-almeida-sm.png" border=0 hspace=5 align="left"
width=206 height=300 alt="[Wedson Almeida Filho]"
title="Wedson Almeida Filho"> 
</a>

<p>
Overstreet said that he had been a part of too many two-week bug hunts and
has been trying to find ways to avoid those kinds of problems for bcachefs.
The Rust language provides a lot more than what he can do in C; it
eliminates undefined behavior and provides facilities to see what is happening
inside the code. "You can't debug, if you can't see what's going on."  He
believes that kernel development "will get a whole lot easier over the
coming decades" due to using Rust.  It will be possible to prove the
correctness of code written in Rust, which will mean that bugs that can derail
feature development will be much less common.
</p>

<p>
From his <a
href="https://docs.google.com/presentation/d/1dflxtAojRu3mdx19oBHP3vXCXI1vocFIVc5jVaf9FLA/">slides</a>,
Almeida showed an example of how the Rust type system can eliminate certain
kinds of errors.  He noted that the <a
href="https://elixir.bootlin.com/linux/v6.9.5/source/fs/inode.c#L1248"><tt>iget_locked()</tt></a>
function in current kernels has a complicated set of requirements.  Callers
must check to see if the return value is null and, if it is not, then the
contents of the returned <a
href="https://elixir.bootlin.com/linux/v6.9.5/source/include/linux/fs.h#L632"><tt>struct&nbsp;inode</tt></a>
need to be checked to see if it is a new or existing inode. If it is new,
it needs to be initialized before it can be used; if that fails, <a
href="https://elixir.bootlin.com/linux/v6.9.5/source/fs/bad_inode.c#L244"><tt>iget_failed()</tt></a>
needs to be called, he said.
</p>

<p>
There was some discussion of the finer points of what callers of
<tt>iget_locked()</tt> need to do, with Al Viro disagreeing with some of
what Almeida had on his slide.  That went back and forth, with Overstreet
observing that it was exactly that kind of discussion/argument that could
be avoided by encapsulating the rules into the Rust types and abstractions;
the compiler will know the right thing to do.
</p>

<!-- middle-ad -->

<p>
Overstreet noted that Christian
Brauner and Alice Ryhl have helped to improve the abstractions a great deal
since the first posting; in particular, there are things he has learned
about reference counts based on how they are being handled by the Rust
code. "This is going to make all our lives so much easier", Overstreet said.
</p>

<p>
Almeida put up a slide with the equivalent of <tt>iget_locked()</tt> in
Rust, which was called <tt>get_or_create_inode()</tt>.  The important part
is the return type, he said; as with C, callers must check for failure, but
the success case is much different.  If it is successful, the caller either
receives a regular reference-counted inode to use (which has its reference
count automatically decremented when the inode object is no longer
referenced) or it receives  
a new inode, which will 
automatically call the equivalent of <tt>iget_failed()</tt> if it is never initialized.  If
it is ever initialized (which can only be done once), it becomes a regular
inode with the automatic 
reference-count decrement.  All of that is enforced through the type system.
</p>

<p>
Viro seemed somewhat skeptical of how that would work in practice.  He wondered
where in the source code those constraints would be defined.  Almeida said
that the whole idea is to determine what the constraints are from Viro and
other filesystem developers, then to create types and abstractions that can
enforce them.
</p>

<h4>Disconnect</h4>

<p>
Dave Chinner asked about the disconnect between the names in the C API and
the Rust API, which means that developers cannot look at the C code and
know what the equivalent Rust call would be.  He said that the same names
should be used or it would all be completely unfamiliar to the existing
development community.  In addition, when the C code changes, the Rust code
needs to follow along, but who is going to do that work?  Almeida agreed
that it was something that needs to be discussed.
</p>

<p>
As far as the renamed functions goes, he is not opposed to switching the
names to match the C API, but does not think <tt>iget_locked()</tt> is a
particularly good name.  It might make sense to take the opportunity to
create better names. 
</p>

<p>
There was some more discussion of the example, with Viro saying that it was
not a good choice because <tt>iget_locked()</tt> is a library function,
rather than a member function of the superblock object.  Almeida said that
there was no reason <tt>get_or_create_inode()</tt> could not be turned into
a library function; his example was simply meant to show how the
constraints could be encoded in the types.
</p>

<p>
Brauner said that there needs to be a decision on whether the Rust
abstractions are going to be general-purpose, intended for all kernel
filesystems,  or if they will only be focused on the
functionality needed for the simpler filesystems that have been written in Rust.  There is also a longer-term problem in handling
situations where functions like <tt>get_or_create_inode()</tt> encode a lot
more of the constraints than <tt>iget_locked()</tt> does.  As the C code
evolves, which will happen more quickly than with the Rust code, at least
initially, there will be a need to keep the two APIs in sync.
</p>

<p>
It comes down to a question of whether refactoring and cleanup will be done
as part of adding the Rust abstractions, Overstreet said; he strongly
believes that is required. But there is more to it than just that, James
Bottomley said.  The object lifecycles are being encoded into the Rust API,
but there is no equivalent of that in C; if someone changes the lifecycle
of the object on one side, the other will have bugs.
</p>

<p>
There are also problems because the lifecycle of inode objects is
sometimes filesystem-specific, Chinner said. Encoding a single lifecycle understanding
into the API means that its functions will not work for some filesystems.
Overstreet said that filesystems which are not using the VFS API would
simply not benefit, but Chinner said that a VFS inode is just a structure
and it is up to filesystems to manage its lifetime.
Almeida said that the example would only be used by filesystems that
currently call <tt>iget_locked()</tt> and could benefit.  The Rust
developers are not trying to force filesystems to change how they are doing
things. 
</p>

<h4>Allocating pain</h4>

<p>
Part of the problem, Ted Ts'o said, is that there is an effort to get
"everyone to switch over to the religion" of Rust; that will not happen, he
said, because there are 50+ different filesystems in Linux that will not be
instantaneously converted.  The C code will continue to be improved and if
that breaks the Rust bindings, it will break the filesystems that depend on
them. For the foreseeable future, the Rust bindings are a second-class
citizen, he said; broken Rust bindings are a problem for the
Rust-for-Linux developers and not the filesystem community at large.
</p>

<p>
He suggested that the development of the Rust bindings continue, while the
C code continues to evolve.  As those changes occur, "we will find out
whether or not
this concept of encoding huge amounts of semantics into the type system is
a good thing or a bad thing".  In a year or two, he thinks the answer to that will become
clear; really, though, it will come down to a question of "where does the
pain get allocated".  In his mind, large-scale changes like this almost always come down to a
"pain-allocation question". 
</p>

<p>
Almeida said that he is not trying to keep the C API static; his goal is
to get the filesystem developers to explain the semantics of the API so
that they can be encoded into Rust.  Bottomley said that as more of those
semantics get encoded into the bindings, they will become more fragile from
a synchronization standpoint.
Several disagreed with that, in the form of a jumble of "no" replies and
the like. Almeida said that it was the same with any user of an API; if the
API changes, the users need to be updated.  But Ts'o pointedly said that
not everyone will learn Rust; if he makes a change, he will fix all of the
affected C code, but, "because I don't know Rust, I am not going to fix the Rust
bindings, sorry".
</p>

<p>
Viro came back to his objections about the proposed replacement for
<tt>iget_locked()</tt>.  The underlying problem that he sees is the
reliance on methods versus functions; using methods is not the proper way
forward because the arguments are not specified explicitly.  But Overstreet
said that the complaints about methods come from 
languages like C++ that rely too heavily on inheritance, which is "a crap
idea".  Rust does not do so; methods in Rust are largely just a syntactical
element. 
</p>

<p>
There was some discussion of what exactly is being encoded in the types.
Jan Kara said that there is some behavior that goes with the inode, such as
its reference count and its handling, but there is other behavior that is
inherent in the 
<tt>iget_locked()</tt> function.  Overstreet and Almeida said that those
two pieces were both encoded into the types, but separately; other
functions using the inode type could have return values with different
properties. 
</p>

<p>
Viro went through some of his reasoning about why inodes work the way they
do in the VFS.  He agreed with the idea of starting small to see where
things lead.  Overstreet suggested that maybe the example used was not a
good starting point, "because this is the complicated case". "Oh, no it
isn't", Viro replied to laughter as the session concluded.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Internal_API">Filesystems/Internal API</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_Memory-Management_and_BPF_Summit-2024">Storage, Filesystem, Memory-Management and BPF Summit/2024</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/978738/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor979332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Capturing complex requirements in Rust helps evolution</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 22:26 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/979332/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Capturing complex API requirements in the Rust type system is actually a huge *win* when those requirements change. The compiler tells you what needs to be fixed, and whether your fix satisfies the new requirements. It is much easier and safer to make these kinds of sweeping changes than with C or C++, and it is easier to review those changes.<br>
<p>
So, fixing users of Rust abstractions will probably turn out to be less work per user than fixing the C users of the underlying C APIs that have changed. But it does sound like coordinating that work with kernel devs who simply refuse to interact with Rust code in any way is going to be painful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979339"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Capturing complex requirements in Rust helps evolution</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 1:00 UTC (Sat)
                               by <b>python</b> (guest, #171317)
                              [<a href="/Articles/979339/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm excited to see what they come up with. More discipline and scrutiny (which is required when inter-operating multiple languages) will probably reveal a lot of hidden and unintended behaviors. I sincerely hope they find a way to bury some of the really horrible crufty APIs (epoll in userspace come to mind, I am sure something analogous exists in the kernel API) and replace them with something a little more sane.<br>
<p>
It will be interesting to see if the rust bindings (making full use of the type system) could be more secure (or less secure?), despite being a thin wallpaper over raw C calls to an ever changing kernel API. Also will be interesting if it impacts performance, particularly since Rust favors doing/structuring things certain ways that are uncommon in plain C.<br>
<p>
I would be inclined to think that any sort of simple wrapper would be at least minusculely slower, but perhaps it might enable more complex and efficient ways of doing things? (automatically handled in the background by the wrappers)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979339/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979350"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Capturing complex requirements in Rust helps evolution</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 9:11 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/979350/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the Rust compiler is capable of emitting a C .h file, that would make it even better! Unfortunately, it probably can't ingest a .h file because different C compilers could lay things out differently, all C cares about is consistency during the compile so unless the programmer has taken special care a .h can have an ambiguous layout. The Rust compiler could take that care.<br>
<p>
In which case, it's then hopefully (crossed fingers and toes!) a drop-in swap of .h files.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979350/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979353"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Capturing complex requirements in Rust helps evolution</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 9:43 UTC (Sat)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/979353/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the rust compiler is not, but bindgen is (c headers-&gt;rust) and cbindgen does the reverse (rust-&gt;c headers)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979353/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979371"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Capturing complex requirements in Rust helps evolution</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 13:52 UTC (Sat)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/979371/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The thing that doesn't solve though, is how much information you lose going from Rust to C. That's somewhat improving with things like counted_by, but it's a long way off.<br>
<p>
However, even that ultimately doesn't really matter, because the barriers to calling Rust from C aren't primarily technical. It's more the attitude among some people that Rust for Linux is just a temporary blip that is bound to fail, or a hope that it does so you don't have to deal with it. Which becomes significantly harder if C code is allowed to call Rust.<br>
<p>
There will realistically be a pretty long tail of people who need a few more years to be convinced Rust is not going away, and probably not everyone will be. However I think writing C APIs in Rust will be a lot more palatable when, say, the GPU driver you are currently using being removed seems unwelcome enough that Rust is de facto necessary anyway. But it'll be a bit until that happens.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979371/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor982685"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Capturing complex requirements in Rust helps evolution</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2024 15:13 UTC (Sat)
                               by <b>kevincox</b> (guest, #93938)
                              [<a href="/Articles/982685/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; different C compilers could lay things out differently</span><br>
<p>
I don't think this is true. I don't think the C standard cares (other than some basic restrictions on possible layouts) but platform ABIs will strictly define how structs are laid out, just like they define how arguments are laid out, what object files look like and everything else.<br>
<p>
For example if you compile code with Clang and GCC on x86_64 Linux they will be binary compatible as they all follow the same ABI specification (IIRC it is the System V AMD64 ABI). There is no reason why the Rust compiler couldn't follow the same rules for structures that are shared with C (even if it uses a more efficient and unstable layout for internal structures).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/982685/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor982687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust supports platform C ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2024 15:51 UTC (Sat)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/982687/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Just FYI, Rust has <tt><a href="https://doc.rust-lang.org/nomicon/other-reprs.html#reprc">#[repr(C)]</a></tt> to tell the compiler to lay out a data structure in a fashion compatible with the platform's C ABI. <a href="https://github.com/mozilla/cbindgen/blob/HEAD/docs.md">cbindgen (where the source of truth is Rust code)</a> and <a href="https://rust-lang.github.io/rust-bindgen/">bindgen (where the source of truth is C code)</a> make use of this to produce matching representations in C and Rust for the same data structure.


      
          <div class="CommentReplyButton">
            <form action="/Articles/982687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor979354"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 10:41 UTC (Sat)
                               by <b>gray_-_wolf</b> (subscriber, #131074)
                              [<a href="/Articles/979354/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This part has cought my eye:<br>
<p>
<span class="QuotedText">&gt; But Ts'o pointedly said that not everyone will learn Rust; if he makes a change, he will fix all of the affected C code, but, "because I don't know Rust, I am not going to fix the Rust bindings, sorry". </span><br>
<p>
I understand the view point, but I wonder how will this work with regards to the "do not break user space" policy.  Let us say that Ts'o does some change, and updates all C users.  But the Rust binding will break (either compilation, or runtime behavior).  What now?  In ideal world someone from rust-on-linux will step up and promptly resolve the issue.  However we do not live in the ideal world and everyone has full plate already.  What now?  Will Ts'o's change be prevented from being merged?  Will it be merged and  the rust part just be broken (with user-space visible effects) until someone finds the time?<br>
<p>
On similar note, will contributors with less weight behind them have the same priviledge of saying "I am not touching rust code"?<br>
<p>
Regardless of my opinion on rust, this whole thing is really interesting experiment, so I am wondering what is current thinking in the community regarding this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979354/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 12:33 UTC (Sat)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/979369/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What will _actually_ happen is a mix of three things:<br>
<p>
1) APIs are changed in backwards-incompatible ways (e.g. <a href="https://www.spinics.net/lists/intel-gfx/msg349025.html">https://www.spinics.net/lists/intel-gfx/msg349025.html</a>) but they're generally not complicated and you handle them with topic branches as usual.<br>
<p>
2) new APIs are introduced but updating 50 filesystems (or hundreds of anonymous file_operations) does not happen at ones, therefore in practice fallbacks are left in place and Rust bindings can be updated separately. The typical example here is read_iter/write_iter.<br>
<p>
3) most subsystems that have Rust bindings will have no problem adjusting, at which point who's left will have to acknowledge the reality.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979566"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2024 8:42 UTC (Tue)
                               by <b>b7j0c</b> (guest, #27559)
                              [<a href="/Articles/979566/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; What will _actually_ happen is a mix of three things:</span><br>
<p>
treating the migration to Rust as inevitable feels like magical thinking, same as Mozilla experienced with Servo<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979566/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979567"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2024 10:42 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/979567/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not talking of a full-scale migration; a non-trivial or undeniable level of adoption is enough.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979567/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979571"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2024 11:57 UTC (Tue)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/979571/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I'm not talking of a full-scale migration; a non-trivial or undeniable level of adoption is enough.</span><br>
<p>
In other words, "The inevitability of Rust becoming a requirement to build a usable/useful kernel."<br>
<p>
...All it takes is one driver (not even subsystem), and *BAM* you're now a Rust system with a (substantial) pile of C.<br>
<p>
(Or rather, "kernel-Rust" with a pile of "kernel-C")<br>
<p>
<p>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979571/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979572"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2024 12:13 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/979572/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; &gt; I'm not talking of a full-scale migration; a non-trivial or undeniable level of adoption is enough.</span><br>
<p>
<span class="QuotedText">&gt; In other words, "The inevitability of Rust becoming a requirement to build a usable/useful kernel."</span><br>
<p>
Which, if the claims of the speed with which good solid drivers can be written in Rust are true, is inevitable sooner rather than later ...<br>
<p>
I remember reading somewhere, that the speed at which a good programmer could produce good code was measured in LoC, REGARDLESS OF THE LANGUAGE USED. In other words, measured in terms an end user could understand - what a system could do - the choice of language has a major impact on productivity.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979572/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979635"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2024 17:20 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/979635/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I remember reading somewhere, that the speed at which a good programmer could produce good code was measured in LoC, REGARDLESS OF THE LANGUAGE USED. </span><br>
<p>
This is less surprising than it sounds. It basically amounts to "higher level languages allow programmers to write code that does more elaborate things in the same amount of development time," which had darned well better be true considering all of the performance cost of e.g. Python. If Python didn't give you a development speed advantage, there would be no (or at least much less) reason to use it for serious purposes (outside of the classroom).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979635/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor979622"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2024 15:23 UTC (Tue)
                               by <b>b7j0c</b> (guest, #27559)
                              [<a href="/Articles/979622/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
both Microsoft and Google appear to be able to introduce Rust into existing codebases - but they also have the power to promote, deliver bonuses, or alternatively, fire people who aren't aligned with the strategy<br>
<p>
open source projects are different...volunteers can just move on if they are unhappy, and if you don't have suitable replacement volunteers, things stop happening<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979622/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor980616"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2024 2:13 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/980616/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That won't be a problem. Most kernel development is made by employees of companies with the ability to promote, deliver bonuses and firing, and they'd rather have their kernel maintained, be it in C, Rust or Pascal. You are right for the general case though, most open source projects are driven by volunteers. Linux is an exception to that rule.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/980616/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor979454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 24, 2024 6:27 UTC (Mon)
                               by <b>LtWorf</b> (subscriber, #124958)
                              [<a href="/Articles/979454/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"do not break user space" only applies to syscalls basically.<br>
<p>
If a filesystem stops working, that has never counted as "userspace is now broken".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor980617"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How will fixing only C part work with the &quot;do not break user space&quot; policy?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2024 2:16 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/980617/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OTOH, isn't fixing what you break the general etiquette? I don't think "I don't know this" works as an excuse in other cases. You don't get to leave XFS broken if you touch VFS because you don't know XFS. Rust is not even that hard to learn when you come from C (also knowing C++ helps a lot as well, since Rust is pretty much C++ best practices enforced by the compiler), it's not frontend programmers we're dealing with.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/980617/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor979357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 10:54 UTC (Sat)
                               by <b>wsy</b> (subscriber, #121706)
                              [<a href="/Articles/979357/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sometimes it's just easier to wait until older guys retire than to convince them to adapt to new way of doing things.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979359"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 11:41 UTC (Sat)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/979359/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Sometimes it's just easier to wait until older guys retire than to convince them to adapt to new way of doing things.</span><br>
<p>
Change, real change, has _always_ operated on a generational cycle.<br>
<p>
(And this isn't "adapt to the new way", it's "double your congnitive workload maintaining a mission-critical working system before its nominal replacement is ready to be deployed.")<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979359/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor979367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 12:08 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/979367/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://en.wikipedia.org/wiki/Planck%27s_principle">https://en.wikipedia.org/wiki/Planck%27s_principle</a><br>
<p>
"Science advances one funeral at a time"<br>
<p>
I'm disappointed by how resistant some fellow hackers are to Rust. It's the first language in 50 years to be enough of an advantage over C to be worth switching to.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979370"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 12:37 UTC (Sat)
                               by <b>liw</b> (subscriber, #6379)
                              [<a href="/Articles/979370/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If it were only a matter of teaching kernel hackers the Rust language, that'd be a solvable problem. (I say, as someone who does Rust training for free and for money.) But I fear there's usually more resistance to change than just having to learn a new language or a new tool.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979370/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979414"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2024 8:52 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/979414/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But I fear there's usually more resistance to change than just having to learn a new language or a new tool.</span><br>
<p>
It usually involves changing your entire way of thinking.<br>
<p>
Look at that post a few days back over P4 - where the comment was "someone comes along thinking they can rewrite it in C", and several man-years of effort later, they realise that actually, someone using a domain specific language can do double the work in half the time, if not even better.<br>
<p>
Going back even further, someone commented people who've learnt Rust usually make far better C programmers because, even though C doesn't enforce memory safety etc, because Rust insists that you code in memory-safe ways, they code memory-safe in C anyways.<br>
<p>
It's like me and databases - 4th normal form is the best for a whole bunch of reasons, but because my experience is with a database where 4th normal form was the OBVIOUS way to do it, when I'm forced to work with relational I do it without thinking. Unfortunately I'm usually working with stuff designed by others where I'm thinking "what the hell were they thinking?".<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979414/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979427"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2024 17:48 UTC (Sun)
                               by <b>Kaligule</b> (guest, #167650)
                              [<a href="/Articles/979427/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please, what is P4?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979427/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979434"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2024 19:37 UTC (Sun)
                               by <b>softball</b> (subscriber, #160655)
                              [<a href="/Articles/979434/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They are possibly referring to: <a href="https://lwn.net/Articles/977310/">https://lwn.net/Articles/977310/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979434/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor979555"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 24, 2024 22:04 UTC (Mon)
                               by <b>riking</b> (subscriber, #95706)
                              [<a href="/Articles/979555/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://p4.org/">https://p4.org/</a> is a programmable packet processing specification language. You use it to write firewall or routing rules, or queue dropping priorities, or whatever the hardware of the router you bought allows you to load a P4 program to do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979555/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor979608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2024 13:36 UTC (Tue)
                               by <b>zuki</b> (subscriber, #41808)
                              [<a href="/Articles/979608/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I find the attitude of "I don't care about Rust, I'll not learn Rust" annoying and destructive.<br>
<p>
There's also the distinction that there are different levels of "knowing" a language. It's quite easy to get to the level where one can do small modifications to existing code, or to copy existing functionality and extend it to cover additional cases. It's much harder to know which of the many possible ways of structuring code and which abstractions to use for a new problem. But fortunately, for ongoing maintenance, this first easier level is all that is needed. The second higher level is only necessary e.g. to implement or review new Rust abstractions in the kernel or new drivers, but a different set of people can handle that.<br>
<p>
I think it's entirely reasonable to ask maintainers to also care about the Rust code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979615"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2024 14:36 UTC (Tue)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/979615/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I think it's entirely reasonable to ask maintainers to also care about the Rust code.</span><br>
<p>
I agree in principle -- but we're a long, long way from the "ongoing maintenance" phase.  <br>
<p>
The current status quo is that, in order to meaningfully contribute to kernel-Rust, you have to essentially be an expert in all-things-Rust, including living on the bleeding edge of Rust language/feature development.<br>
<p>
<span class="QuotedText">&gt; I find the attitude of "I don't care about Rust, I'll not learn Rust" annoying and destructive.</span><br>
<p>
You may find it annoying but it is an entirely rational (and reasonable!) attitude to take given that hyper-unstable nature of kernel-Rust and the already-overwhelming "just maintaining existing stuff" workload.   <br>
<p>
After all, "Let those who care about X do the work" has been the kernel development philosophy since approximately forever.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979615/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor979620"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2024 14:51 UTC (Tue)
                               by <b>somlo</b> (subscriber, #92421)
                              [<a href="/Articles/979620/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Having never used the Go language, I managed to "cut'n'paste" my way into writing a useful (and also stylistically and functionally correct) patch against Docker. So in principle you *should* be right about your first level of "knowing" a language concept.<br>
<p>
However, unlike Go, I find Rust hard to skim over -- for the lack of a better word, it's too "syntax-y" for my brain :) So your "anyone should be able to deal with it" statement is actually a much bigger ask than you think, depending on the actual language's legibility to newcomers.<br>
<p>
I then tried working my way through "The Rust Programming Language", and was mostly able to follow along and understand what's going on, and even managed to write ok-ish small programs in the process.<br>
<p>
But without being a real, $DAYJOB Rust programmer, when I look at production code a few months later, it's back to a wall-of-syntax "foo::bar =&gt; &lt;blah:::xyz&gt;" incomprehensible gibberish... :D<br>
This may be just an undiagnosed learning disability on my part, or it might be that Rust syntax is simply less legible to a large swath of the otherwise OK programmer population.<br>
<p>
I'm also constantly high-key annoyed at how compiling a program involves downloading crap off the Internet, as part of the compilation process (this is the part where I might just be old and grumpy, and the whole download-crap-from-the-Internet thing is interfering with my lawn care routine).<br>
<p>
Anyhow, if kernel maintainers' experience is anything like mine, I can't blame them for putting a "low pass filter" on this thing: maybe it goes away if they ignore it long enough, and they won't have to waste time on it.<br>
<p>
Now, if based on the description of my pain points above there's a more targeted way of learning Rust in a way that sticks, I'm happy to take hints and advice...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979620/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor994270"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 15, 2024 13:46 UTC (Tue)
                               by <b>Rudd-O</b> (guest, #61155)
                              [<a href="/Articles/994270/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; "foo::bar =&gt; &lt;blah:::xyz&gt;" incomprehensible gibberish... :D</span><br>
<p>
I found this exceedingly difficult to wrap around, the `match` and `if let` constructs felt backwards in a very weird way.<br>
<p>
I got used eventually, but it was a solid month until it "clicked".<br>
<p>
Now it annoys me that other languages don't do this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/994270/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor994373"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 16, 2024 8:20 UTC (Wed)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/994373/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is the way the order of those statements work in all languages I am aware of, from simple assignments over destructuring bind in Common Lisp and pattern matching in languages like Haskell.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/994373/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor979616"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Changing code when you barely understand the language</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2024 15:40 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/979616/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>The other thing to bear in mind is that different languages have different challenge levels when you're not very good at them. At one extreme, you have languages where just about everything you could reasonably consider "language source code" is accepted by implementations as "valid" code, and if you barely understand the language, it's really hard to avoid making mistakes.
<p>At the other extreme, you have languages where the compiler will definitely complain if you make a change that won't work, and thus it's a lot easier to avoid making mistakes because the compiler tells you that what you've implemented is not going to work.
<p>And in the middle of those two extremes, we have real languages, where some things that won't work cause the compiler to complain (such as including a file that doesn't exist like <tt>#include &lt;linus/asm.h&gt;</tt>), while other things that won't work compile and fail later.
<p>The interesting question is whether Rust is strict enough that someone with good C skills and minimal Rust skills can be confident that the Rust toolchain will complain if they make the "obvious" fix, but it's wrong, or whether they have to learn more Rust so that they can do the checks themselves (or ask someone else to check their work).


      
          <div class="CommentReplyButton">
            <form action="/Articles/979616/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor980618"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2024 2:23 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/980618/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  I think it's entirely reasonable to ask maintainers to also care about the Rust code.</span><br>
<p>
I'm not sure if I'm inventing this, but I believe the deal was that maintainers got to decide whether Rust made it into in their subsystems? If that's the case, it's only reasonable to expect them to either reject the patches or commit to keep them working. Otherwise we're in a kind of Seinfeld's car reservation situation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/980618/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor982224"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2024 12:19 UTC (Wed)
                               by <b>that_kca</b> (guest, #172467)
                              [<a href="/Articles/982224/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I find the attitude of "I don't care about Rust, I'll not learn Rust" annoying and destructive.</span><br>
<p>
I mean is it any more annoying or destructive than the "Everything must be written in rust" evangelism that many of the rust fans parrot?<br>
<p>
I imagine if rust spent less of the design/engineering points in being hard to learn the language might find more people willing to pick it up. <br>
<p>
But then the majority of the rust internet community would probably run to something else.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/982224/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor982271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2024 13:40 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/982271/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I mean is it any more annoying or destructive than the "Everything must be written in rust" evangelism that many of the rust fans parrot?</span><br>
<p>
Rust FANS, or Rust PROGRAMMERS.<br>
<p>
Generally you'll find the people who make the most noise, are the people who do the least work. That's not always a bad thing, you need your evangelists (after all, I make a heck of a lot of noise about Pick/MV), but there are too many people who think it's a silver bullet when they've never really used it.<br>
<p>
It DOES sound great. And given that all the evidence says it's not vulnerable to a huge class of errors that regularly bite C/C++, there's good reason to - as a minimum - try it out. But it's noticeable that a lot of people are too busy using it to evangelise it. That to me is a good sign.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/982271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor982294"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2024 16:55 UTC (Wed)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/982294/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wol. You regularly post close to half of the comments here. I'd appreciate if you could try to appreciate the perspective of the readers of the comment section into consideration a bit more. Nobody writes *that* much interesting stuff.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/982294/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor979376"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 14:05 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/979376/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; It's the first language in 50 years to be enough of an advantage over C to be worth switching to.</font>

<p>Sure, but the flip side is that it <b>is</b> the first language in 50 years that offers genuine advantage large enough to switch.</p>

<p>The only way to convince people to switch is to write more good Rust code, ultimately.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/979376/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979377"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Just wait</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 14:21 UTC (Sat)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/979377/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The only way to convince people to switch is to write more good Rust code, ultimately.</span><br>
<p>
Just imagine what bug-for-bug compatible Linux.rs kernel could do...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979377/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor979379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">test suite for complicated cases</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 15:17 UTC (Sat)
                               by <b>aszs</b> (subscriber, #50252)
                              [<a href="/Articles/979379/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm a little surprised there's no mention here about building a test suite for these "complicated cases" -- that's the obvious way to make sure two independent implementations conform. And it has some benefits:<br>
* the grunt work doesn't have to be done by time-constrained core developers<br>
* getting a nice test suite out of this effort could be a good sweetener to motivate Rust-resistant maintainers<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">test suite for complicated cases</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 18:41 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/979389/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How would you write a test suite that verifies that every filesystem conforms to the current VFS locking rules? Particularly when those locking rules are mostly not written down.<br>
<p>
To take an example that I do know...<br>
<p>
When you call folio_mark_dirty(), you must guarantee that the folio will not be concurrently truncated from the file (for values of truncate that include operations like hole-punch).<br>
<p>
Holding the folio lock is one way to do that. But this is a sleeping lock, so you can't always do that. If the folio is currently mapped by a page table, holding that page table lock guarantees truncation will not complete, and some callers rely on this.<br>
<p>
If you have buffer heads attached to the folio, and you have a buffer head locked, then that is also sufficient to prevent truncation. Some callers rely on this.<br>
<p>
Now, encode all that information into a type system? Not sure it can be done. And you certainly can't write a test suite for it. Or any reasonable assertion.<br>
<p>
I'm a huge fan of test suites. But saying "just write a test suite" without understanding the problem space is not helpful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">test suite for complicated cases</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2024 20:06 UTC (Sat)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/979390/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One way would be to have some "token" ZST (zero-size type) that one could retrieve from any of these locking mechanisms. `folio_mark_dirty()` would then require that as one of its parameters. Something like:<br>
<p>
```<br>
let folio_lock = folio.lock();<br>
let mark_dirty_allowed = folio_lock.i_want_to_mark_dirty();<br>
<p>
// <br>
<p>
let buffer_head_lock = buffer_head.lock();<br>
let mark_dirty_allowed = buffer_head_lock.i_want_to_mark_folio_dirty(&amp;folio)?; // better error handling, but checks that it is attached<br>
<p>
// .<br>
<p>
let page_table_lock = page_table.lock();<br>
let mark_dirty_allowed = page_table_lock.i_want_to_mark_folio_dirty(&amp;folio); // similar to above; make sure this page table maps the folio<br>
```<br>
<p>
Techniques from ghost_cell[1] can likely be used to ensure that the "mark_dirty_allowed" proof token is associated with the folio in question and not any folio that might also exist.<br>
<p>
[1] <a href="https://docs.rs/ghost-cell/latest/ghost_cell/">https://docs.rs/ghost-cell/latest/ghost_cell/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor979410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">test suite for complicated cases</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2024 3:53 UTC (Sun)
                               by <b>aszs</b> (subscriber, #50252)
                              [<a href="/Articles/979410/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe I missed something but it didn't seem that the problem being discussed here was how to "verify that every filesystem conforms to the current VFS locking rules" but rather how to make sure the semantics of the Rust APIs for writing file systems match the semantics for the C APIs for writing file systems -- even as those semantics are changed developers that might ignore the Rust bindings. And if it's unrealistic to test all the ways a surface API might impact some internal invariant, well that's what fuzz testing is for. To be clear, I wasn't saying "just" write a test suite, I was saying I'm surprised tests aren't being discussed as part of a solution to a fairly hard problem.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor980619"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">test suite for complicated cases</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2024 2:34 UTC (Thu)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/980619/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Now, encode all that information into a type system? Not sure it can be done.</span><br>
<p>
There's the option to not do that in Rust, too. The type system is quite useful most of the time, but there is a point of diminishing returns and at that point you rely on runtime checks and discipline just like in any other language.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/980619/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor981972"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">test suite for complicated cases</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2024 2:49 UTC (Mon)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/981972/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      ...but do also keep this quote in mind:

<blockquote>
Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence. -- Edsger W. Dijkstra, "The Humble Programmer" (1972)
</blockquote>


      
          <div class="CommentReplyButton">
            <form action="/Articles/981972/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1014446"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">test suite for complicated cases</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2025 20:01 UTC (Mon)
                               by <b>ma4ris8</b> (subscriber, #170509)
                              [<a href="/Articles/1014446/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
With Rust language, formalized reasoning is used increasingly to ensure robustness.<br>
<p>
Kani is one of the tools that could be useful.<br>
https://model-checking.github.io/kani-verifier-blog/<br>
<p>
Following list is quite impressive, to be checked for more tools:<br>
<a href="https://github.com/newca12/awesome-rust-formalized-reasoning">https://github.com/newca12/awesome-rust-formalized-reasoning</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1014446/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
