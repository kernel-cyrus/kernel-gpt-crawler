        <!DOCTYPE html>
        <html lang="en">
        <head><title>mseal() gets closer [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/958438/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/958598/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/958438/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>mseal() gets closer</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 19, 2024</br>
           </div>
The <a href="/Articles/948129/">proposed <tt>mseal()</tt> system call</a>
stirred up some controversy when it was first posted in October 2023.
Since then, it has been evolving in a quieter fashion, and seems to have
reached a point where the relevant commenters are willing to accept it.
Should <tt>mseal()</tt> be merged in a future development cycle, it will
look rather different than it did at the outset.
<p>
As a reminder, <tt>mseal()</tt> was created as a way of preventing changes
to portions of the virtual address space.  It is meant to thwart attacks
that depend on changing memory that is supposed to be read-only or otherwise
messing with a process's idea of how its memory is laid out.  An attacker
who can change memory permissions or mappings may, for example, be able to
circumvent control-flow-integrity protections.  By using <tt>mseal()</tt>,
a process can prevent changes of that type from being made.
The initial
user is expected to be the Chrome browser, where it will be used to further
harden the program against memory-based attacks.
<p>
<tt>mseal()</tt>, as proposed in October, had this prototype:
<p>
<pre>
    int mseal(void *addr, size_t len, unsigned int types, unsigned int flags);
</pre>
<p>
The <tt>types</tt> parameter, which allowed the caller to fine-tune the
changes that <tt>mseal()</tt> would prohibit, was one of the more
controversial features, with a number of people questioning why anything
other than an outright ban on changes would be useful.  Even so, <a
href="/ml/linux-mm/20231017090815.1067790-1-jeffxu@chromium.org/">version&nbsp;2</a>
(posted shortly after the first version) and <a
href="/ml/linux-kernel/20231212231706.2680890-1-jeffxu@chromium.org/">version&nbsp;3</a>
(posted in mid-December) retained that parameter.  In response to the
latter posting, Linus Torvalds <a
href="/ml/linux-kernel/CAHk-=wgn02cpoFEDQGgS+5BUqA2z-=Ks9+PNd-pEJy8h+NOs5g@mail.gmail.com/">reiterated</a>
his dislike of that aspect of the API, and asked: "<q>I want to know why we don't
just do the BSD immutable thing, and why we need this multi-level sealing
thing</q>".
<p>
Chrome developer Stephen Röttger <a
href="/ml/linux-kernel/CAEAAPHZpYXHNPdca+xfj77bwYaL6PY-c_oQ54r+=wtJa6_hmCA@mail.gmail.com/">answered</a>
that Chrome needed the ability to allow <tt><a
href="https://man7.org/linux/man-pages/man2/madvise.2.html">madvise</a>(MADV_DONTNEED)</tt>
in specific places where the region could otherwise be sealed.  This
operation was forbidden in sealed memory because it is essentially a
mapping change; it discards the underlying memory, which (for anonymous
pages) will be refilled with zeroes if it is accessed again.  It is useful
for (for example) discarding unneeded cached data, but it also has the
potential to create surprises.
In the Chrome case, the <tt>type</tt> argument was used to allow
<tt>MADV_DONTNEED</tt> on writable anonymous memory — memory that
the process has the ability to write directly even when it is sealed.
Torvalds <a
href="/ml/linux-kernel/CAHk-=wiVhHmnXviy1xqStLRozC4ziSugTk=1JOc8ORWd2_0h7g@mail.gmail.com/">replied</a>
that the proper solution was for <tt>mseal()</tt> to only allow
<tt>MADV_DONTNEED</tt> if the mapping in question is writable.  Indeed, he
thought that restriction might make sense even in the absence of sealing.
<p>
As a result of that discussion, <a
href="/ml/linux-kernel/20240104185138.169307-1-jeffxu@chromium.org/">version&nbsp;4</a>,
posted in early January, implemented the new semantics with regard to
<tt>MADV_DONTNEED</tt>.  This version also finally dropped the
<tt>types</tt> parameter; memory is now either sealed or not.  Torvalds <a
href="/ml/linux-kernel/CAHk-=wiy0nHG9+3rXzQa=W8gM8F6-MhsHrs_ZqWaHtjmPK4=FA@mail.gmail.com/">was
satisfied</a> by the changes; he declared that "<q>this seems all
reasonable to me now</q>" and withdrew from the discussion.  The <a
href="/ml/linux-mm/20240109154547.1839886-1-jeffxu@chromium.org/">fifth
version</a> brought only small changes, suggesting that the major concerns
have been addressed; Kees Cook <a
href="/ml/linux-mm/202401091144.2C203AA7@keescook/">noted</a> that "<q>this
code is looking to land</q>".  Since then, <a
href="/ml/linux-mm/20240111234142.2944934-1-jeffxu@chromium.org/">version&nbsp;6</a>
was posted with a few more small changes.
<p>
If <tt>mseal()</tt> is merged in this form, its prototype will be:
<p>
<pre>
    int mseal(void *addr, size_t len, unsigned long flags);
</pre>
<p>
The <tt>addr</tt> and <tt>len</tt> describe the range of memory to be
sealed; the <tt>flags</tt> argument is currently unused and must be zero.
It will only be available on 64-bit systems.  <a
href="/ml/linux-mm/20240111234142.2944934-5-jeffxu@chromium.org/">This
documentation patch</a> contains more information about its use.
<p>
So this story may have run its course, but there is still one aspect of it
that has been somewhat swept under the rug.  OpenBSD has a similar system
call, <a href="/Articles/915640/"><tt>mimmutable()</tt></a>, that has been
in place since 2022.  It, too, prevents modifications to a specific range
of the address space.  Over the course of the conversation, simply
implementing <tt>mimmutable()</tt> for Linux has been suggested a number of
times.  Jeff Xu, the developer of <tt>mseal()</tt>, has always shrugged off
that suggestion, to the point that Theo de Raadt, the creator of
<tt>mimmutable()</tt>, <a
href="/ml/linux-kernel/56221.1702566263@cvs.openbsd.org/">suggested</a>
that "<q>maybe this proposal should be using the name chromesyscall()
instead</q>".  It seems that implementing <tt>mimmutable()</tt> for Linux
has never been seriously considered.

<p>
As <tt>mseal()</tt> has gotten simpler, though, the features that
differentiated it from <tt>mimmutable()</tt> have melted away, to the point
that they do almost the same thing.  About the only difference is that
<tt>mimmutable()</tt> allows downgrading permissions (setting memory
read-only even if it has been sealed), while <tt>mseal()</tt> does not;
OpenBSD <a href="/ml/linux-kernel/58421.1702516178@cvs.openbsd.org/">may
yet remove</a> that feature, though, further reducing the difference in
semantics between the two system calls.  Given that, it may be worth
asking, one more time, why Linux doesn't just adopt the existing interface
and add <tt>mimmutable()</tt>.  It is not a question that has been directly
addressed.
<p>
Possible answers do exist.  <tt>mseal()</tt> carries the <tt>flags</tt>
parameter that <a href="/Articles/585415/">long experience</a> says is a
good idea, even if the immediate need for it is not apparent.  It may also
be that the use of this system call will always be so specialized and
low-level that any code using it will need to be system-specific in any
case, in which case there may be little value in using the same name.
Finally, adding an <tt>mimmutable()</tt> wrapper around <tt>mseal()</tt> in
the C library would be an almost trivial undertaking if it were deemed
worthwhile.
<p>
If and when <tt>mseal()</tt> is merged, it will initially only benefit the
Chrome browser (and its small band of users).  As the <tt>mseal()</tt>
cover letter points out, though, Röttger is working on adding support to
the GNU C Library so that most programs would be able to run with a fair
amount of sealing automatically applied.  That would greatly increase the
use of this new system call, and the ability to use it in the C library
would increase confidence that the API is correct.  That seems likely to
truly seal the deal.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Releases-6.10">Releases/6.10</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-System_calls">Security/System calls</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/958438/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor958795"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal() gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2024 20:02 UTC (Fri)
                               by <b>acarno</b> (subscriber, #123476)
                              [<a href="/Articles/958795/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What a pun-derful ending to a very informative article =)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958795/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor958832"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Naming things - mimmutable vs mseal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2024 8:12 UTC (Sat)
                               by <b>fredrik</b> (subscriber, #232)
                              [<a href="/Articles/958832/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Naming things is hard, but I'm curious how it works in this case, and wonder if someone can shed some light on it?<br>
<p>
AFAIU the mseal API has now evolved to become semantically very similar to mimutable in OpenBSD, right? Especially if OpenBSD were to remove the ability to reduce the permissions on a sealed region, and we ignore the currently unused flags argument for mseal.<br>
<p>
So, assuming they are semantically the same at this point, is there any advantage to change the name of mseal to mimmutable now?<br>
<p>
AFAIU, once a new user space API is committed to mainline and released, the name and semantics are more or less set in stone due to Linus' pledge to kernel API stability, right? I.e renaming it is only possible before it goes in.<br>
<p>
Which leaves my question, does it make sense to do so from some point of view, say technically or to indicate to users that they do the same thing?<br>
<p>
I can imagine that one argument against adopting the OpenBSD name would be that if the semantics of the API in Linux were to diverge from OpenBSD at some point in the future, retaining the original name from OpenBSD would muddle the water at that point. OTOH, userspace API:s are expected to semantically stable too, so perhaps that isn't possible anyway.<br>
<p>
What other pros and cons are there to having the same or different names, assuming the API is semantically equal?<br>
<p>
Now, it may very well be that the authors of mseal think that their name simply is a better choice to convey its purpose. And I assume that no libc standards committee was involved in picking the name mimmutable for OpenBSD. Basically the only reason mimmutable would have precedence over mseal is that OpenBSD picked that name before any implementation appeared in the Linux kernel.<br>
<p>
PS. I really do not intend to start a heated bikeshedding debate with these questions. So if anyone else feel an irresistible urge to do so, please raise another thread for that. Thanks! And do consider that the editors of LWN probably would be very happy if you abstained entirely. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958832/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor958848"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Naming things - mimmutable vs mseal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2024 15:58 UTC (Sat)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/958848/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it worth considering that whatever libc API is used to wrap the syscall, does not necessarily need to use the same name as the syscall? Or, libc could present multiple wrappers for the same syscall - including adding a BSD-like mimmutable() that calls mseal() under the hood? (e.g. AIUI glibc open() actually calls openat(2) on Linux these days, ignoring Linux's native open(2) syscall altogether.)<br>
<p>
Of course, glibc devs may be opposed to this for any number of perfectly valid reasons, but that doesn't mean the option isn't there. Or, if not glibc, then another libc might want to.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958848/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor958881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Naming things - mimmutable vs mseal</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2024 20:03 UTC (Sat)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/958881/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
setuid() is one good example where the Linux syscall has different semantics than the libc setuid(). The syscall version only applies to the current thread which is not POSIX compatible. It's then libc which does setuid() for each thread of the process to match POSIX.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor958886"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal() gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2024 20:52 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/958886/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
About naming, I actually started looking up WTF is "mimmu table" when I read the article about mseal/mimmutable several months ago. Can we settle on mseal(), please?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958886/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal() gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2024 5:43 UTC (Wed)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/959246/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But what it has to do with Microsoft eals?<br>
<p>
If you want to misread, you will.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor958924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2024 11:02 UTC (Sun)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/958924/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does a simple app, which plans to do not much else than to allocate more memory via malloc-like functions, have something worth sealing?<br>
<p>
I'd guess a C lib can't just seal everything by default, so I wonder if a "mseal_all()" function would make sense that has no parameters at all.<br>
It could be used by those who wouldn't much about how to use mseal() and its parameters.<br>
<p>
(Of course in addition to mseal(). )<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor958941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2024 22:58 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/958941/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not certain what you propose for mseal_all to do, but there are not a whole lot of options that make sense to me:<br>
<p>
1. mseal the process's whole address space. But then you can't create any new memory mappings, because they would have to fall somewhere within the process's address space, and the whole address space is sealed. You also can't modify the data in any existing memory mapping, so your process is pretty much not allowed to touch anything that is not a register. I guess you can move the instruction pointer around (with nops or branch instructions?), but not much else.<br>
2. mseal all parts of the address space that have mappings. But then you probably break half of libc, because libc has significant amounts of live data it expects to be able to update. Unfortunately, that includes libc malloc, which has free lists, block metadata, etc. that it has to update when you malloc. It also includes a significant amount of unallocated heap memory that malloc currently believes it has the right to hand out (without having to call sbrk or mmap), so even if malloc could somehow return a block of memory, that block might already be sealed. The only way around this is to mmap your own private memory arena and then use a third-party malloc that can be confined to that arena. But even then, you've still broken things like fread/fwrite (which have userspace buffers), and probably lots of other stuff.<br>
3. A library function in libc, that seals all parts of the address space that have mappings, except for anything that would cause libc to break. We can subdivide this into two kinds of memory: Memory that is owned by libc (and that libc is OK with sealing), and memory that is not owned by libc. The former can be sealed by libc automatically for all processes during startup, and so we don't need a function to do it. The latter is potentially dangerous, because if you don't own a given piece of memory, you have no way of knowing whether it is safe to seal (so instead of breaking libc, you'd just end up breaking some other library instead).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor958942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 21, 2024 23:10 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/958942/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Correction: mseal does not prevent you from writing to the memory, so actually this is less of a problem than I thought. Still not sure it's workable, however, because nearly any nontrivial malloc implementation will eventually want to call sbrk or mmap, and that would be prevented by sealing the whole address space. With cooperation from libc, some kind of more restricted sealing might be possible, however.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor958943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2024 0:44 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/958943/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, my understanding is that mseal() fixes the permissions (like read/write/execute) only.<br>
<p>
So the idea is that an app first creates any memory definitions it needs, and then, assuming it arrives at a point where it doesn't want to change or add anymore, at that point it calls mseal_all() to prevent any further unwanted or accidental modifications.<br>
<p>
This assumes that there is way to do this without preventing the mere allocation of more memory. If that currently isn't possible, maybe it can be made possible.<br>
<p>
I'm not sure if a C lib is in the best position to do this, the kernel might have a better overview of the process's resources, and the kernel might be in a better position to do this securely.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor958950"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2024 4:21 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/958950/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; This assumes that there is way to do this without preventing the mere allocation of more memory. If that currently isn't possible, maybe it can be made possible.</span><br>
<p>
There is no general way to do that. To explain why, I'm going to introduce two made-up terms:<br>
<p>
* Some portion of memory is kernel-allocated if it belongs to a valid mapping of some kind. In other words, memory is kernel-allocated if it is possible to dereference a pointer to that memory without segfaulting.<br>
* Some portion of memory is userspace-allocated if it is valid stack memory (as defined by the architecture etc.), if it is statically allocated, or if has been returned by malloc or some malloc-like function and not subsequently freed. In other words, memory is userspace-allocated if it would be "valid" for the program to actually use the memory for some purpose, without needing to do any malloc-like bookkeeping. The term "valid" is intentionally undefined, because the semantics of malloc and malloc-like functions will depend on the implementation and API, but in general, this is roughly synonymous with C's notion of pointer validity (i.e. you are not generally allowed to just make up your own pointers into the heap and do whatever you like with them).<br>
<p>
The basic problem here is that the total amount of kernel-allocated memory is finite. Once the address space is sealed, you cannot add any more mappings, so you cannot kernel-allocate any more memory. Therefore, the only way to create more userspace-allocated memory is to use the kernel-allocated memory you already have, and you will eventually run out.<br>
<p>
The other problem is that, in practice, glibc malloc tacitly assumes it can just mmap whatever it wants, whenever it wants. If you malloc a large amount of memory in one call, it will not fiddle around with the existing heap memory, it will just pass the arguments through to mmap, and give you a whole new mapping. This mapping may later be unmapped if you call free (or maybe it isn't, I haven't actually read the source code). It also calls mmap if it detects thread contention, which is probably difficult to predict in real applications. These are theoretically changeable behaviors, but I doubt the glibc people would be happy with the resulting performance regressions.<br>
<p>
For these reasons, I think it would have to be a libc service, because only libc has the necessary userspace knowledge to figure out which mappings are safe to seal, which ones might need to be created in the future, and which ones might need to be unmapped in the future. But I think that starts to become redundant to "just automatically mseal everything that libc knows it can safely mseal," and you don't need a function for that, it can just automatically happen at startup.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958950/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor958956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2024 6:13 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/958956/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But I think that starts to become redundant to "just automatically mseal everything that libc knows it can safely mseal," </span><br>
<span class="QuotedText">&gt; and you don't need a function for that, it can just automatically happen at startup.</span><br>
<p>
Well at startup the app might first want to create a few mappings (directly or indirectly) that are unknown to the userspace lib, and maybe not directly known to the app either.<br>
<p>
I don't know if you can reliably assume that a userspace lib isn't modified or replaced, in part or whole. I'd probably rather have a kernel function at least for "most", that maybe doesn't prevent additional new mappings, if that wouldn't work. Or perhaps limits future mappings to some degree. <br>
<p>
Maybe the userspace lib would have options like "Use mseal() to prevent new heap and/or stack mappings from being made executable", just for example, if that can't be enforced from the kernel side.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor958960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2024 9:19 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/958960/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe of interest in this context, this text regarding OpenBSD (linked in a previous article) talks about various ways in which both the kernel and the "shared library linker" could automatically apply seals :<br>
<p>
<a href="https://lwn.net/Articles/915662/">https://lwn.net/Articles/915662/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor959043"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2024 20:52 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959043/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Well at startup the app might first want to create a few mappings (directly or indirectly) that are unknown to the userspace lib, and maybe not directly known to the app either.</span><br>
<span class="QuotedText">&gt; </span><br>
<span class="QuotedText">&gt; I don't know if you can reliably assume that a userspace lib isn't modified or replaced, in part or whole. [...]</span><br>
<p>
This is precisely my point. The only piece of code that knows whether a given mapping is safe to seal is the piece of code that actually created that mapping. Neither the kernel, nor the application, nor libc can safely seal a mapping that it does not have direct knowledge of.<br>
<p>
1. The loader can probably(!) seal things like the .text segment and other very basic "this memory is always statically allocated" segments. If the loader is not prepared to do that, then I suppose libc could probably figure it out.<br>
2. libc can seal mappings that it creates during startup or for other internal purposes, but probably not any mappings involved in malloc (because they might need to be unmapped later when freed). Similarly, it can probably seal mappings created with functions like dlopen(3), but then you can't unmap them when you dlclose(3) them, so maybe that's a bad idea?<br>
3. The application can seal mappings that it creates manually, if desired.<br>
4. libfoo can seal mappings that it creates manually, if it somehow(?) knows that those mappings will never be unmapped or remapped. For most libraries, that seems a bit presumptuous, but I suppose some libraries might explicitly say in their API "this function creates a permanent allocation that cannot be freed, so don't call it in a loop or something, because you'll leak memory."<br>
<p>
To the best of my understanding, the kernel is not in a position to distinguish any of these items from each other - it just sees them all as "mappings." So a kernel-side mseal_all() would be very much an all-or-nothing operation, and since that's obviously unworkable (you can't seal random mappings out from under random bits of code without warning them!), it would have to be a userspace function that knows the difference between these mappings and can selectively seal just the mappings that are safe to seal.<br>
<p>
(1) and (2) can be done automatically at startup (or when the mapping is created), so mseal_all() doesn't need to touch them (it would be redundant). It might be nice for mseal_all() to do (3), to save the application writer the trouble of calling mseal() repeatedly, but the problem is that you can't reasonably distinguish (3) from (4) at runtime, and it is certainly not safe for an application to seal (4) behind libfoo's back, because...<br>
<p>
<span class="QuotedText">&gt; Maybe the userspace lib would have options like "Use mseal() to prevent new heap and/or stack mappings from being made executable", just for example, if that can't be enforced from the kernel side.</span><br>
<p>
...the lib would have to refrain from unmapping or re-mapping anything that has been sealed behind its back. Which pretty much means the lib has to be using its own internal malloc-like function (and not libc malloc), and that function has to be designed to never discard or resize a mapping (unlike libc malloc in practice). Of course, you could also have a lib that just uses libc malloc, and never directly creates a mapping itself, and that would be fine if your mseal_all() avoids touching libc-owned mappings. The problem is, what if your lib is itself a custom allocator, but not one that is aware of these funky "don't remap anything" rules? Then you basically can't use mseal_all() when that lib is loaded, or else you will break it. At that point, it's probably cleaner to just tell application writers to manually call mseal() on the specific mappings that are safe to seal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959043/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959061"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2024 22:39 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/959061/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; This is precisely my point. The only piece of code that knows whether a given mapping is safe to seal is </span><br>
<span class="QuotedText">&gt; the piece of code that actually created that mapping. Neither the kernel, nor the application, </span><br>
<span class="QuotedText">&gt; nor libc can safely seal a mapping that it does not have direct knowledge of.</span><br>
<p>
You are surely right in many ways, however I'd like to question this for a simple application that does fancy things only during intialization if at all.<br>
Perhaps, after setting everything up, a simple app can say: From this point on, only simple things should happen:<br>
<p>
For example, no existing mappings that are writable should become executable anymore, and no existing mappings that are executable should become writable anymore. Maybe this requires additional features in mseal() or elsewhere, also glibc should be able to say: this new mapping should not be changeable to 'executable', but it should remain possible to free it.<br>
<p>
In any case, the text I quoted implies that the kernel and the "shared library linker" can automatically seal many mappings, and that would be partial success.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959061/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2024 23:05 UTC (Mon)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/959070/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or something like this: mseal_all() would mean that all existing mappings perhaps have certain unconditional restrictions, yet the additional restriction that other operations on them can only be performed by code that is now sealed and in a read-only memory area. (This would mean the mappings internally receive a timestamp, and any attempt to change a restricted mapping involves comparing the code's seal-timestamp to the mappings seal-timestamp.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2024 1:24 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959074/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; This would mean the mappings internally receive a timestamp, and any attempt to change a restricted mapping involves comparing the code's seal-timestamp to the mappings seal-timestamp.</span><br>
<p>
While I agree that in principle a mechanism like this might prove useful, it is far more complex than the mechanism which is currently proposed, and I'm not sure it would make sense to tie it to this particular API (especially seeing as they just got finished *removing* the concept of different "types" of sealing).<br>
<p>
One thing I do feel obligated to point out, as said by the immortal James Mickens[1]: "Gadgets are eternal. There will always be gadgets, there were gadgets before we got here, there'll be gadgets after we're dead." In other words, you really can't say "this was executed by read-only code, therefore it must be non-malicious," because of ROP-style attacks. No matter how many control flow invariants you try to enforce, sooner or later somebody is going to invent another way of fiddling the instruction pointer into a clever position and exploiting code that already exists.<br>
<p>
[1]: <a href="https://youtu.be/ajGX7odA87k?si=y0eIv5UAtcv28-Zd&amp;t=1874">https://youtu.be/ajGX7odA87k?si=y0eIv5UAtcv28-Zd&amp;t=1874</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959076"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal_all()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 23, 2024 2:00 UTC (Tue)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/959076/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; While I agree that in principle a mechanism like this might prove useful, it is far more complex than the mechanism which is currently proposed, and I'm not sure it would make sense to tie it to this particular API (especially seeing as they just got finished *removing* the concept of different "types" of sealing).</span><br>
<p>
Yes, of course this would be a separate step. And thanks, I guess.<br>
<p>
<span class="QuotedText">&gt; One thing I do feel obligated to point out, as said by the immortal James Mickens[1]: "Gadgets are eternal. There will always be gadgets, there were gadgets before we got here, there'll be gadgets after we're dead." In other words, you really can't say "this was executed by read-only code, therefore it must be non-malicious," because of ROP-style attacks. No matter how many control flow invariants you try to enforce, sooner or later somebody is going to invent another way of fiddling the instruction pointer into a clever position and exploiting code that already exists.</span><br>
<p>
Sure, a high bar which probably can't be reached by any single measure. Any sealing, automatic or explicit, be it from libc, the kernel, the loader, or otherwise, that doesn't require (potentially simple) apps to figure out address ranges, would be another separate step in this sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959076/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor960361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal() gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2024 1:55 UTC (Thu)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/960361/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Röttger is working on adding support to the GNU C Library so that most programs would be able to run with a fair amount of sealing automatically applied.</span><br>
<p>
Did you link to that somewhere or have more details?  I'm curious what glibc would seal by default.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960362"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mseal() gets closer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2024 1:58 UTC (Thu)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/960362/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe <a href="https://patchwork.kernel.org/project/linux-mm/cover/20240131175027.3287009-1-jeffxu@chromium.org/">https://patchwork.kernel.org/project/linux-mm/cover/20240...</a> :<br>
<p>
<span class="QuotedText">&gt; The specific scenario currently in mind is</span><br>
<span class="QuotedText">&gt; glibc's use case of loading and sealing ELF executables. To this end,</span><br>
<span class="QuotedText">&gt; Stephen is working on a change to glibc to add sealing support to the</span><br>
<span class="QuotedText">&gt; dynamic linker, which will seal all non-writable segments at startup.</span><br>
<p>
Ok, interesting.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960362/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
