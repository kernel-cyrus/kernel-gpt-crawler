        <!DOCTYPE html>
        <html lang="en">
        <head><title>Object-oriented design patterns in the kernel, part 1 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/444910/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/444881/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/444910/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Object-oriented design patterns in the kernel, part 1</h1>
</div>
<div class="ArticleText">
<div class="GAByline">
           <p>June 1, 2011</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
Despite the fact that the Linux Kernel is mostly written in C, it
makes broad use of some techniques from the field of object-oriented
programming.
Developers wanting to use these object-oriented techniques receive
little support or guidance from the language and so are left to fend
for themselves.  As is often the case, this is a double-edged sword.
The developer has enough flexibility to do really cool things, and
equally the flexibility to do really stupid things, and it isn't
always clear at first glance which is which, or more accurately: where
on the spectrum a particular approach sits.
</p><p>
Instead of looking to the language to provide guidance, a software
engineer must look to established practice to find out what works well
and what is best avoided.  Interpreting established practice is not
always as easy as one might like and the effort, once made, is worth
preserving.
To preserve that effort on your author's part, this article brings
another installment in an
<a href="/Articles/336224/">occasional series</a> on Linux Kernel Design
Patterns and attempts to set out - with examples - the design patterns
in the Linux Kernel which effect an object-oriented style of
programming.
</p><p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
Rather than providing a brief introduction to the object-oriented
style, tempting though that is, we will assume the reader has a basic
knowledge of objects, classes, methods, inheritance, and similar
terms.  For those as yet unfamiliar with these, there are plenty of
resources to be found elsewhere on the web.
</p><p>
Over two weeks we will look for patterns in just two areas:  method
dispatch and data inheritance.  Despite their apparent
simplicity they lead to some rich veins for investigation.
This first article will focus on method dispatch.
</p>
<h3>Method Dispatch</h3>
<p>
The large variety of styles of inheritance and rules for its usage in
languages today seems to suggest that there is no uniform
understanding of what "object-oriented" really means.  The term is a bit like
"love": everyone thinks they know what it means but when you get down
to details people can find they have very different ideas.

While what it means to be "oriented" might not be clear, what we mean
by an "object" does seem to be uniformly agreed upon.  It is simply an
abstraction comprising both state and behavior.  An object is like a
record (Pascal) or struct (C), except that some of the names of members
refer to functions which act on the other fields in the object.
These function members are sometimes referred to a "methods".
</p><p>
The most obvious way to implement objects in C is to declare a
"struct" where some fields are pointers to functions which take a
pointer to the struct itself as their first argument.  The calling
convention for method "foo" in object "bar" would simply be:
<tt>bar-&gt;foo(bar, ...args);</tt>

While this pattern is used in the Linux kernel it is not the dominant
pattern so we will leave discussion of it until a little later.
</p><p>
As methods (unlike state) are not normally changed on a per-object
basis, a more common and only slightly less obvious approach is to
collect all the methods for a particular class of objects into a
separate structure, sometimes known as a "virtual function table" or
<a href="http://en.wikipedia.org/wiki/Virtual_method_table">vtable</a>.

The object then has a single pointer to this table rather than a
separate pointer for each method, and consequently uses less memory.
</p><p>
This then leads to our first pattern - a <b>pure vtable</b> being a
structure which contains only function pointers where the first argument of
each is a pointer to some other structure (the object type) which itself
contains a pointer to this vtable.

Some simple examples of this in the Linux kernel are the
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1062"><tt>file_lock_operations</tt></a>
structure which contains two function pointers
each of which take a pointer to a <tt>struct file_lock</tt>, and the
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/seq_file.h#L29"><tt>seq_operations</tt></a> vtable which contains four function pointers
which each operate on a <tt>struct seq_file</tt>.

These two examples display an obvious naming pattern - the structure
holding a vtable is named for the structure holding the object
(possibly abbreviated) followed by "_operations".  While this pattern is
common it is by no means universal.   Around the time of 2.6.39
there are approximately 30 "*_operations" structures along with well over
100 "*_ops" structures, most if not all of which are vtables of some
sort. There are also several structs such as <tt>struct mdk_personality</tt>
which are essentially vtables but do not have particularly helpful
names.
</p><p>
Among these nearly 200 vtable structures there is plenty of variability
and so plenty of scope to look for interesting patterns.  In
particular we can look for common variations from the "pure vtable"
pattern described above and determine how these variations contribute
to our understanding of object use in Linux.
</p>
<h4>NULL function pointers</h4>
<p>
The first observation is that some function pointers in some vtables
are allowed to be NULL.  Clearly trying to call such a function would
be futile, so the code that calls into these methods generally
contains an explicit test for the pointer being NULL.  There are a few
different reasons for these NULL pointers.

Probably easiest to justify is the incremental development
reason.  Because of the way vtable structures are initialized, adding
a new function pointer to the structure definition causes all existing
table declarations to initialise that pointer to NULL.  Thus it is
possible to add a caller of the new method before any instance
supports that method, and have it check for NULL and perform a default
behavior.   Then as incremental development continues those vtable
instances which need it can get non-default methods.
</p><p>
A recent example is commit
<a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=77af1b2641faf4">77af1b2641faf4</a> adding
<tt>set_voltage_time_sel()</tt> to <tt>struct regulator_ops</tt> which acts on
<tt>struct regulator_dev</tt>.  Subsequent commit
<a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=42ab616afe8844">42ab616afe8844</a>
defines that method
for a particular device.  This is simply the most recent example of a
very common theme.
</p><p>
Another common reason is that certain methods are not particularly
meaningful in certain cases so the calling code simply tests for NULL
and returns an appropriate error when found.  There are multiple
examples of this in the virtual filesystem (VFS) layer.  For instance,
the <tt>create()</tt> function in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1569"><tt>inode_operations</tt></a>
is only meaningful if the inode in question is a
directory.  So <tt>inode_operations</tt> structures for non-directories
typically have NULL for the <tt>create()</tt> function (and many others) and
the calling code in <tt>vfs_create()</tt> checks for NULL and returns <tt>-EACCES</tt>.
</p><p>
A final reason that vtables sometimes contain NULL is that an element
of functionality might be being transitioned from one interface to
another.  A good example of this is the <tt>ioctl()</tt> operation in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1537"><tt>file_operations</tt></a>.
In 2.6.11, a new method, <tt>unlocked_ioctl()</tt> was added
which was called without the big kernel lock held.  In 2.6.36, when all
drivers and filesystems had been converted to use <tt>unlocked_ioctl()</tt>,
the original <tt>ioctl()</tt> was finally removed.  During this transition a file system
would typically define only one of two, leaving the other defaulting to NULL.
</p><p>
A slightly more subtle example of this is <tt>read()</tt> and <tt>aio_read()</tt>, also in
<tt>file_operations</tt>, and the corresponding <tt>write()</tt> and <tt>aio_write()</tt>.
<tt>aio_read()</tt> was introduced to support asynchronous IO, and if it is
provided the regular synchronous <tt>read()</tt> is not needed (it is effected
using <tt>do_sync_read()</tt> which calls the <tt>aio_read()</tt> method).  In this case
there appears to be no intention of ever removing <tt>read()</tt> - it will
remain for cases where async IO is not relevant such as special
filesystems like procfs and sysfs.  So it is still the case that only one of each
pair need be defined by a filesystem, but it is not simply a transition, it is
a long-term state.
</p><p>
Though there seem to be several different reasons for a NULL function pointer,
almost every case is an example of one simple pattern - that of providing a
default implementation for the method.  In the "incremental development"
examples and the non-meaningful method case, this is fairly straightforward.
e.g. the default for <tt>inode-&gt;create()</tt> is simply to return an error.
In the interface transition case it is only slightly less obvious.  The default for
<tt>unlocked_ioctl()</tt> would be to take the kernel lock and then call
the <tt>ioctl()</tt> method.  The
default for <tt>read()</tt> is exactly <tt>do_sync_read()</tt> and some filesystems such
as <tt><a href="http://lxr.linux.no/#linux+v2.6.39/fs/ext3/file.c#L55">ext3</a></tt>
actually provide this value explicitly rather than using
"NULL" to indicate a default.
</p><p>
With that in mind, a little reflection suggests that if the real goal is to
provide a default, then maybe the best approach would be to explicitly give a
default rather than using the circuitous route of using a default of NULL and
interpreting it specially.
</p><p>
While NULL is certainly the easiest value to provide as a default - as the C
standard assures us that uninitialized members of a structure do get set to
NULL - it is not very much harder to set a more meaningful default.
I am indebted to LWN reader
<a href="https://lwn.net/Articles/437878/">wahern</a> for the observation that
C99 allows fields in a structure to be initialized multiple times with only the
final value taking effect and that this allows easy setting of default values
such as by following the simple model:
</p>
<pre>
    #define FOO_DEFAULTS  .bar = default_bar, .baz = default_baz
    struct foo_operations my_foo = { FOO_DEFAULTS,
	.bar = my_bar,
    };
</pre><p>
This will declare <tt>my_foo</tt> with a predefined default value for <tt>baz</tt> and a
localized value for <tt>bar</tt>.  Thus for the small cost of defining a few "default"
functions and including a "<TT>_DEFAULTS</TT>" entry to each declaration, the
default value for any field can easily be chosen when the field is first
created, and automatically included in every use of the structure.
</p><p>
Not only are meaningful defaults easy to implement, they can lead to a more
efficient implementation.  In those cases where the function pointer actually
is NULL it is probably faster to test and branch rather than to make an
indirect function call.  However the NULL case is very often
the exception rather than the rule, and optimizing for an
exception is not normal practice.  In the more common case when
the function pointer is not NULL, the test for NULL is simply a
waste of code space and a waste of execution time.  If we
disallow NULLs we can make all call sites a little bit smaller and simpler.
</p><p>
In general, any testing performed by the caller before calling a method
can be seen as an instance of the "mid-layer mistake" discussed
<a href="/Articles/336262/">in a previous article</a>.  It shows that the
mid-layer is making 
assumptions about the behavior of the lower level driver rather than simply
giving the driver freedom to behave in whatever way is most
suitable.  This may not always be an expensive mistake, but it
is still best avoided where possible.

Nevertheless there is a clear pattern in the Linux kernel that
pointers in vtables can sometimes be NULLable, typically though not
always to enable a transition, and the call sites should in these
cases test for NULL before proceeding with the call.
</p><p>
The observant reader will have noticed a hole in the above logic
denouncing the use NULL pointers for defaults.  In the case where the
default is the common case and where performance is paramount, the
reasoning does not hold and a NULL pointer could well be justified.
Naturally the Linux kernel provides an example of such a case for our
examination.
</p><p>
One of the data structures used by the VFS for caching filesystem
information is the "dentry".  A "dentry" represents a name in the
filesystem, and so each "dentry" has a parent, being the directory
containing it, and an "inode" representing the named file.  The dentry
is separate from the inode because a single file can have multiple
names (so an "inode" can have multiple "dentry"s).

There is a <tt>dentry_operations</tt> vtable with a number of operations including,
for example, "d_compare" which will compare two names and "d_hash"
which will generate a hash for the name to guide the storage of the
"dentry" in a hash table.  Most filesystems do not need this flexibility.  They
treat names as uninterpreted strings of bytes so the default compare and hash
functions are the common case.  A few filesystems define these to
handle case-insensitive names but that is not the norm.
</p><p>
Further, filename lookup is a common operation in Linux and so
optimizing it is a priority.  Thus these two operations
appear to be good candidates where a test for NULL and an inlined
default operation might be appropriate.  What we find though is that
when such an optimization is warranted it is not by itself enough.

The code that calls <tt>d_compare()</tt> and <tt>d_hash()</tt> (and a couple of other dentry
operations) does not test these functions for NULL directly.  Rather
they require that a few flag bits (DCACHE_OP_HASH, DCACHE_OP_COMPARE)
in the "dentry" are set up to indicate whether the common default
should be used, or whether the function should be called.  As the flag
field is likely to be in cache anyway, and the <tt>dentry_operations</tt>
structure will often be not needed at all, this avoids a memory fetch
in a hot path.
</p><p>
So we find that the one case where using a NULL function pointer to
indicate a default could be justified, it is not actually used; instead, a
different, more efficient,
mechanism is used to indicate that the default method is requested.
</p>
<h4>Members other than function pointers</h4>
<p>
While most vtable-like structures in the kernel contain exclusively
function pointers, there are a significant minority that have
non-function-pointer fields.  Many of these appear on the surface
quite arbitrary and a few closer inspections suggest that some of them
result of poor design or bit-rot and their removal would only improve
the code.
</p><p>
There is one exception to the "functions only" pattern that occurs
repeatedly and provides real value, and so is worth exploring.
This pattern is seen in its most general form in
<a href="http://lxr.linux.no/#linux+v2.6.39/drivers/md/md.h#L348"><tt>struct mdk_personality</tt></a>
which provides operations for a particular software
RAID level.  In particular this structure contains an "owner", a
"name", and a "list".  The "owner" is the module that provides the
implementation.  The "name" is a simple identifier: some vtables have
string names, some have numeric names, and it is often called
something different like "version", "family", "drvname", or
"level".  But conceptually it is still a name.  In the present example
there are two names, a string and a numeric "level".
</p><p>
The "list", while part of the same functionality, is less
common. The mdk_personality structure has a <tt>struct list_head</tt>, as does
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/textsearch.h#L37"><tt>struct ts_ops</tt></a>.
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1793"><tt>struct file_system_type</tt></a> 
has a simple pointer to the next
<tt>struct file_system_type</tt>.

The underlying idea here is that for any particular implementation of
an interface (or "final" definition of a class) to be usable, it must
be registered in some way so that it can be found.  Further, once it
has been found it must be possible to ensure that the module holding
the implementation is not removed while it is in use.
</p><p>
There seem to be nearly as many styles of registration against an
interface in Linux as there are interfaces to register against, so
finding strong patterns there would be a difficult task.  However it
is fairly common for a "vtable" to be treated as the primary handle on
a particular implementation of an interface and to have an "owner"
pointer which can be used to get a reference on the module which
provides the implementation.
</p><p>
So the pattern we find here is that a structure of function pointers
used as a "vtable" for object method dispatch should normally contain
<b>only</b> function pointers.  Exceptions require clear justification.  A
common exception allows a module pointer and possible other fields such
as a name and a list pointer. These fields are used to support
the registration protocol for the particular interface.
When there is no list pointer it is very likely that the entire vtable will
be treated as read-only.  In this case the vtable will often be declared as
a <tt>const</tt> structure and so could even be stored in read-only memory.

</p>
<h4>Combining Methods for different objects</h4>
<p>
A final common deviation from the "pure vtable" pattern that we see in
the Linux kernel occurs when the first argument to the function is not
always the same object type.  In a pure vtable which is referenced by
a pointer in a particular data structure, the first argument of
each function is exactly that data structure.  What reason could there
be for deviating from that pattern?  It turns out that there are few,
some more interesting than others.
</p><p>
The simplest and least interesting explanation is that, for no apparent
reason, the target data structure is listed elsewhere in the argument
list.  For example all functions in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fb.h#L623"><tt>struct
fb_ops</tt></a>
take a <tt>struct fb_info</tt>.  While in 18 cases that structure is the first argument, in
five cases it is the last.  There is nothing obviously wrong with this
choice and it is unlikely to confuse developers.  It is only a problem
for data miners like your author who need to filter it out as an
irrelevant pattern.
</p><p>
A slight deviation on this pattern is seen in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/rfkill.h#L145"><tt>struct rfkill_ops</tt></a>
where two functions take a <tt>struct rkfill</tt> but the third - <tt>set_block()</tt> -
takes a <tt>void *data</tt>.  Further investigation shows that this opaque
<tt>data</tt> is exactly that which is stored in <tt>rfkill-&gt;data</tt>, so <tt>set_block()</tt>
could easily be defined to take a <tt>struct rfkill</tt> and simply to follow
the <tt>-&gt;data</tt> link itself.  This deviation is sufficiently non-obvious
that it could conceivably confuse developers as well as data miners
and so should be avoided.
</p><p>
The next deviation in seen for example in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/suspend.h#L108"><tt>platform_suspend_ops</tt></a>,
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/oprofile.h#L51"><tt>oprofile_operations</tt></a>,
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/security.h#L1375"><tt>security_operations</tt></a>
and a few others.  These
take an odd assortment of arguments with no obvious pattern.  However
these are really very different sorts of vtable structures in that the
object they belong to are singletons.  There is only one active
platform, only one profiler, only one security policy.  Thus the
"object" on which these operations act is part of the global state and
so does not need to be included in the arguments of any functions.
</p><p>
Having filtered these two patterns out as not being very interesting
we are left with two that do serve to tell us something about object
use in the kernel.
</p><p>
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/quota.h#L301"><tt>quota_format_ops</tt></a>
and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/exportfs.h#L167"><tt>export_operations</tt></a>
are two different operations structures that operate on a variety of different
data structures.  In each case the apparent primary object (e.g. a
<tt>struct super_block</tt> or a <tt>struct dentry</tt>) already has a vtable
structure dedicated to it (such as <tt>super_operations</tt> or
<tt>dentry_operations</tt>) and these new structures add new operations.  In
each case the new operations form a cohesive unit providing a related
set of functionality - whether supporting disk quotas or NFS export.
They don't all act on the same object simply because the functionality
in question depends on a variety of objects.
</p><p>
The best term from the language of object-oriented programming for this
is probably the "<a href="http://en.wikipedia.org/wiki/Mixin">mixin</a>".
Though the fit may not be perfect -
depending on what your exact understanding of mixin is - the idea of
bringing in a collection of functionality without using strict hierarchical
inheritance is very close to the purpose of <tt>quota_format_ops</tt> and
<tt>export_operations</tt>.
</p><p>
Once we know to be on the lookout for mixins like these we can find
quite a few more examples.  The pattern to be alert for is not the one
that led us here - an operations structure that operates on a variety
of different objects - but rather the one we found where the functions
in an "operations" structure operate on objects that already have their
own "operations" structure.  When an object has a large number of
operations that are relevant and these operations naturally group into
subsets, it makes a lot of sense to divide them into separate
vtable-like structures.  There are several examples of this in the
networking code where for instance both
<a href="http://lxr.linux.no/#linux+v2.6.39/include/net/tcp.h#L661"><tt>tcp_congestion_ops</tt></a>
and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/net/inet_connection_sock.h#L38"><tt>inet_connection_sock_af_ops</tt></a>
operate (primarily) on a <tt>struct sock</tt>,
which itself has already got a small set of dedicated operations.
</p><p>
So the pattern of a "mixin" - at least as defined as a set of operations
which apply to one or more objects without being the primary
operations for those objects - is a pattern that is often found in the
kernel and appears to be quite valuable in allowing better
modularization of code.
</p><p>
The last pattern which explains non-uniform function targets is
probably the most interesting, particularly in its contrast to the
obvious application of object-oriented programming style.

Examples of this pattern abound with
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/libata.h#L803"><tt>ata_port_operations</tt></a>,
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/tty_driver.h#L243"><tt>tty_operations</tt></a>,
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/nfs_xdr.h#L1125"><tt>nfs_rpc_ops</tt></a>
and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/atmdev.h#L388"><tt>atmdev_ops</tt></a>
all appearing as
useful examples.  However we will focus primarily on some examples
from the filesystem layer, particularly
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1613"><tt>super_operations</tt></a>
and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/fs.h#L1569"><tt>inode_operations</tt></a>.
</p><p>
There is a strong hierarchy of objects in the implementation of a
filesystem where the filesystem - represented by a "super_block" - has a
number of files (<tt>struct inode</tt>) which may have a number of names or
links (<tt>struct dentry</tt>).  Further each file might store data in the page
cache (<tt>struct address_space</tt>) which comprises a number of individual
pages (<tt>struct page</tt>).

There is a sense in which all of these different objects belong to the
filesystem as a whole.  If a page needs to be loaded with data from a
file, the filesystem knows how to do that, and it is probably the same
mechanism for every page in every file.  Where it isn't always the
same, the filesystem knows that too.  So we could conceivably store
every operation on every one of these objects in the
<tt>struct super_block</tt>, as it represents the filesystem and could know what to
do in each case.
</p><p>
In practice that extreme is not really helpful.  It is quite likely
that while there are similarities between the storage of a regular file
and a directory, there are also important differences and being able
to encode those differences in separate vtables can be helpful.
Sometimes small symbolic links are stored directly in the inode while
larger links are stored like the contents of a regular file.  Having
different <tt>readlink()</tt> operations for the two cases can make the code a
lot more readable.
</p><p>
While the extreme of every operation attached to the one central
structure is not ideal, it is equally true that the opposite extreme
is not ideal either.  The <tt>struct page</tt> in Linux does not have a
vtable pointer at all - in part because we want to keep the structure
as small as possible because it is so populous.  Rather the
<tt>address_space_operations</tt> structure contains the operations that act
on a page.  Similarly the <tt>super_operations</tt> structure contains some
operations that apply to inodes, and <tt>inode_operations</tt> contains some
operations that apply to dentries.
</p><p>
It is clearly possible to have operations structures attached to a
parent of the target object - providing the target holds a reference
to the parent, which it normally does - though it is not quite so clear that
it is always beneficial.  In the case of <tt>struct page</tt> which avoids
having a vtable pointer altogether the benefit is clear.  In the case
of <tt>struct inode</tt> which has its own vtable pointer, the benefit of
having some operations (such as <tt>destroy_inode()</tt> or <tt>write_inode()</tt>)
attached to the super_block is less clear.
</p><p>
As there are several vtable structures where any given function
pointer could be stored, the actual choice is in many cases little
more than historical accident.  Certainly the proliferation
of <tt>struct dentry</tt> operations in <tt>inode_operations</tt> seems to be
largely due to the fact that some of them used to act directly
on the inode, but changes in the VFS eventually required this
to change.  For example in 2.1.78-pre1, each of <tt>link()</tt>,
<tt>readlink()</tt>, <tt>followlink()</tt> (and some others which are now
defunct) were 
<a href="http://git.kernel.org/?p=linux/kernel/git/davej/history.git;a=commitdiff;h=5770cca79b11eaf962b41008c2eb1e845c3aae51#patch45">changed</a>
from taking a <tt>struct inode</tt> to
take a <tt>struct dentry</tt> instead.  This set the scene for "dentry"
operations to be in <tt>inode_operations</tt>, so when setattr and getattr
were added for 2.3.48, it probably seemed completely natural to
include them in <tt>inode_operations</tt> despite the fact that they acted
primarily on a dentry.
</p><p>
Possibly we could simplify things by getting rid of
<tt>dentry_operations</tt> altogether.  Some operations that act on dentries
are already in <tt>inode_operations</tt> and <tt>super_operations</tt> - why not move
them all there?  While dentries are not as populous as <tt>struct page</tt>
there are still a lot of them and removing the "d_op" field could save
5% of the memory used by that structure (on x86-64).
</p><p>
With two exceptions, every active filesystem only has a single dentry
operations structure in effect.  Some filesystem implementations like
"vfat" define two - e.g. one with case-sensitive matching and one with
case-insensitive matching - but there is only one active per
super-block.  So it would seem that the operations in
dentry_operations could be moved to <tt>super_operations</tt>, or at
least accessed through "s_d_op".

The two exceptions are ceph and procfs.  These filesystems use
different <tt>d_revalidate()</tt> operations in different parts of the
filesystem and - in the case of procfs - different <tt>d_release()</tt>
operations.  The necessary distinctions could easily be made in
per-superblock versions of these operations.  Do these cases justify the 5%
space cost?  Arguably not.
</p>
<h4>Directly embedded function pointers</h4>
<p>
Finally it is appropriate to reflect on the alternate pattern
mentioned at the start, where function pointers are stored directly in
the object rather than in a separate vtable structure.

This pattern can be seen in
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/blkdev.h#L263"><tt>struct request_queue</tt></a>
which has nine function
pointers,
<a href="http://lxr.linux.no/#linux+v2.6.39/include/linux/efi.h#L251"><tt>struct efi</tt></a>
which has ten function pointers, and
<a href="http://lxr.linux.no/#linux+v2.6.39/include/net/sock.h#L238"><tt>struct sock</tt></a>
which has six function pointers.
</p><p>
The cost of embedded pointers is obviously space.  
When vtables are used, there is only one copy
of the vtable and multiple copies of an object (in most cases) so if
more than one function pointer is needed, a vtable would save space.

The cost of a vtable is an extra memory reference, though cache might
reduce much of this cost in some cases.  A vtable also has a cost of
flexibility.  When each object needs exactly the same set of operations
a vtable is good, but if there is a need to individually tailor some
of the operations for each object, then embedded function pointer can
provide that flexibility.  This is illustrated quite nicely by the
comment with "zoom_video" in <tt>struct pcmcia_socket</tt>
</p>
<pre>
	/* Zoom video behaviour is so chip specific its not worth adding
	   this to _ops */
</pre><p>
So where objects are not very populous, where the list of function
pointers is small, and where multiple mixins are needed,
embedded function pointers are used instead of a separate vtable.
</p>
<h4>Method Dispatch Summary</h4>
<p>
If we combine all the pattern elements that we have found in
Linux we find that:
</p>
<blockquote>
<p>
Method pointers that operate on a particular type of object are
normally collected in a vtable associated directly with that
object, though they can also appear:
</p>
<ul>
<li> In a mixin vtable that collects related functionality which
    may be selectable independently of the base type of the
    object.
<p>
<li> In the vtable for a "parent" object when doing so avoids
    the need for a vtable pointer in a populous object
<p>
<li> Directly in the object when there are few method pointers,
    or they need to be individually tailored to the particular
    object.
</ul>
<p>
These vtables rarely contain anything other than function
pointers, though fields needed to register the object class can
be appropriate.  Allowing these function pointers to be NULL is
a common but not necessarily ideal technique for handling
defaults.
</p>
</blockquote>
<p>
So in exploring the Linux Kernel code we have found that even
though it is not written in an object-oriented language, it
certainly contains objects, classes (represented as vtables),
and even mixins.  It also contains concepts not normally
found in object-oriented languages such as delegating
object methods to a "parent" object.
</p><p>
Hopefully understanding these different patterns and the
reasons for choosing between them can lead to more uniform
application of the patterns across the kernel, and hence make
it easier for a newcomer to understand which pattern is being
followed.

In the second part of our examination of object
oriented patterns we will explore the various ways that 
data inheritance is achieved in the Linux kernel
and discuss the strengths and weaknesses of each approach so
as to see where each is most appropriate.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_model-Patterns">Development model/Patterns</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/444910/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor445597"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 15:35 UTC (Wed)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/445597/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; as the C standard assures us that uninitialized members of a structure do get set to NULL</font><br>
<p>
Is that really true? Does the _standard_ assure it, or is it just an implementation detail that all platforms we care about do?<br>
Also, does the C standard say something about .bss (uninitialized global variables)?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445597/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 15:58 UTC (Wed)
                               by <b>JoeBuck</b> (subscriber, #2330)
                              [<a href="/Articles/445608/">Link</a>] 
      </p>
      
      </div>
      </summary>
      C guarantees that static and global pointers are initialized to null, but local (stack) pointers are uninitialized, and pointers allocated from the heap aren't initialized unless the allocation function explicitly does it.

      
          <div class="CommentReplyButton">
            <form action="/Articles/445608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor445609"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 16:01 UTC (Wed)
                               by <b>JohnLenz</b> (guest, #42089)
                              [<a href="/Articles/445609/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Expanding on Joe Buck's comment, the <a href="http://www.open-std.org/jtc1/sc22/wg14/www/standards.html#9899">C99 standard</a> says the following in section 6.7.8

<p><em>Except where explicitly stated otherwise, for the purposes of this subclause unnamed members of objects of structure and union type do not participate in initialization. Unnamed members of structure objects have indeterminate value even after initialization.</em></p>

<p><em>If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate. If an object that has static storage duration is not initialized explicitly, then:
<ul>
<li> if it has pointer type, it is initialized to a null pointer;</li>
<li> if it has arithmetic type, it is initialized to (positive or unsigned) zero;</li>
<li> if it is an aggregate, every member is initialized (recursively) according to these rules;</li>
<li> if it is a union, the first named member is initialized (recursively) according to these rules.</li>
</ul>
</em>
</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445609/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor445611"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 16:12 UTC (Wed)
                               by <b>nbourdau</b> (subscriber, #68532)
                              [<a href="/Articles/445611/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually the standard guarantees that if an automatic variable is initialized by an initializer list, any subobjects (for example members for a structure) not explicitly initialized "shall be initialized implicitly the same as objects that have static storage duration".<br>
<p>
So assuming you have some declaration like:<br>
struct dummy {<br>
    int a;<br>
    char* p;<br>
    long b;<br>
};<br>
<p>
if you have in a function :<br>
struct dummy smth = {.b = 0};<br>
<p>
You are ensured by the standard that smth.p == NULL and smth.a == 0.<br>
 <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445611/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445622"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 16:58 UTC (Wed)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/445622/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
[citation needed]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445622/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445638"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 18:31 UTC (Wed)
                               by <b>juliank</b> (guest, #45896)
                              [<a href="/Articles/445638/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <h4>WG14/N1256 Committee Draft  Septermber 7, 2007 ISO/IEC 9899:TC3</h4>
<h5>6.7.8 Initialization</h5>

<blockquote>19 The initialization shall occur in
initializer list order,each initializer provided for a
particular subobject overriding any previously listed
initializer for the same subobject; all subobjects that are not initialized explicitly shall be initialized implicitly the same as
objects that have static storage duration.</blockquote>
      
          <div class="CommentReplyButton">
            <form action="/Articles/445638/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445675"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 20:15 UTC (Wed)
                               by <b>arjan</b> (subscriber, #36785)
                              [<a href="/Articles/445675/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
one gotcha; if your structure contains padding (due to alignment requirements of variable types).... it's not uncommon that this padding does not get initialized. In userspace this is often not a big deal.. but if you get this in the kernel you may accidentally leak kernel stack data to userspace....<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445675/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 21:15 UTC (Wed)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/445692/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <p>Interesting... Just curious, has this been observed thus far?  If so, has it been addressed (patch, git commit, etc.)?</p>

<p>Based on the standard, I'm unsure whether the padding you mention needs to be initialized.  Assuming it does, then is the leaked stack data a compiler bug?  Or, if it doesn't, then does this fall into the category of &quot;<a href="http://lwn.net/Articles/443037/">making the compiler more efficient</a>&quot;?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/445692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445727"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 0:26 UTC (Thu)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/445727/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't have a link, but it's a real problem that's been observed in the wild.<br>
<p>
It's not a compiler bug by any means.  It's correct, normal, expected behavior.  There's no reason to initialize padding space in most circumstances, and doing so is just a loss of efficiency for no gain for those overwhelmingly common cases.<br>
<p>
The only cases where this ever comes up as a problem are in security contexts (e.g. kernel stack data leakage) and when you're trying to do "undefined" operations like hashing a chunk of memory representing a struct.  In the former case, you should be more careful and explicitly zero out memory via memset or calloc (or equivalent APIs) which you need to do anything for just about every other data structure you use so it's not a big deal, and in the later case you should be beaten with a stick until you stop doing such stupid things. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445727/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445728"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 0:39 UTC (Thu)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/445728/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I ran into it when writing in-memory structs to disk (to be mmap'd in later). It was a problem that there was random garbage in between the data, since then it was not possible to md5sum two files and tell if they were the same.<br>
<p>
Furthermore, gcc emits *terrible* code when explicitly initializing a bunch of integer members to 0 (especially where some of them are bitfields). My solution was to make a parent class call bzero to clear out sizeof(*this), and not explicitly initialize any of the initially-zero integer members. Made faster code *and* didn't have any padding issues. (But now someone's probably going to tell me that doing that is undefined and that gcc 4.8's optimizer is going to decide to transform my app into nethack, because I invoked some undefined behavior).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445728/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445807"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 13:48 UTC (Thu)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/445807/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe that, unless your class has only plain old data members (the kind you would find in a C struct), doing a bzero of *this has the potential of blowing up. The compiler can add extra hidden members (like the vtable pointer), and you would be overwriting them.<br>
<p>
That is, I believe what you are doing is safe only if:<br>
<p>
- All the integer and bitfield members (and only them) are in the parent class;<br>
- The parent class is zeroing only itself (that is, it is doing the sizeof(*this) itself, instead of being passed that value by the child class);<br>
- The parent class has no virtual member functions or anything else that could make the compiler add C++ magic to it.<br>
<p>
That said, I am no language lawyer, and would not be surprised if several clauses scattered all over the standard combine to say that even then you are still doing something undefined.<br>
<p>
Why not move all these variables into a plain C-style struct, add it to your object as a member, and zero it on the constructor? That way sounds much safer to me, and I doubt the C++ standard would break it (since breaking it would break compatibility with C).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445807/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 11:20 UTC (Fri)
                               by <b>liljencrantz</b> (guest, #28458)
                              [<a href="/Articles/446020/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What makes you assume the parent is talking C++ and not C? Am I missing something or are you?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 13:51 UTC (Fri)
                               by <b>sethml</b> (guest, #8471)
                              [<a href="/Articles/446047/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Presumably because *this means something special in C++, and is not a common thing to write in C.<br>
<p>
I've written this bug in C++ (memset(this, 0, sizeof(*this))) - clobbering your vtable pointer is pretty annoying to debug. My horrible hacky fix was just to zero the data portion of the class: memset(&amp;firstMember, 0, (char *)(&amp;lastMember + 1) - (char *)&amp;firstMember)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2011 10:11 UTC (Sat)
                               by <b>liljencrantz</b> (guest, #28458)
                              [<a href="/Articles/446167/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I always use the name «this» for the object pointer when doing OOP in C. From what I've seen, this is a common convention.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor445878"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 17:49 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/445878/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It's not a compiler bug by any means. It's correct, normal, expected behavior. There's no reason to initialize padding space in most circumstances, and doing so is just a loss of efficiency for no gain for those overwhelmingly common cases.</font><br>
<p>
Performance over security: a very important design choice of C, one to keep in mind at all times. One carried over to C++. One responsible for zillions of security flaws written by thousands of programmers who should rather have used another, safer language (or stayed in bed).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445878/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor445762"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 9:25 UTC (Thu)
                               by <b>juliank</b> (guest, #45896)
                              [<a href="/Articles/445762/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The standard (or my draft) says, in 6.2.6 Representations of types,
6.2.6.1 General:

<blockquote>
6 When a value is stored in an object of structure or union type, including in a member
object, the bytes of the object representation that correspond to any padding bytes take
unspecified values.
</blockquote>
      
          <div class="CommentReplyButton">
            <form action="/Articles/445762/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor445881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 17:49 UTC (Thu)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/445881/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
See <a href="http://lwn.net/Articles/417989/">http://lwn.net/Articles/417989/</a> and the mail it links to<br>
<p>
<font class="QuotedText">&gt; Check commit 1c40be12f7d8ca1d387510d39787b12e512a7ce8 for an example</font><br>
<font class="QuotedText">&gt; (net sched: fix some kernel memory leaks)</font><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor445794"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 13:05 UTC (Thu)
                               by <b>pixelbeat</b> (guest, #7440)
                              [<a href="/Articles/445794/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      I think the standard says the whole object is initialized as it would be in static storage.<br/>I.E. the padding is zeroed too.

<p>I previously did <a rel="nofollow" href="http://www.pixelbeat.org/programming/gcc/auto_init.html">some analysis to verify</a>.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/445794/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 13:08 UTC (Thu)
                               by <b>juliank</b> (guest, #45896)
                              [<a href="/Articles/445796/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I.E. the padding is zeroed too.</font><br>
It's not, read my other comment.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 14:30 UTC (Thu)
                               by <b>pixelbeat</b> (guest, #7440)
                              [<a href="/Articles/445820/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well by my analysis in the above link, GCC does init the padding to zero. I.E. it seems GCC interprets 6.7.8 to trump 6.2.6.<br>
I'd be very interested if there was a counter example in the wild<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445853"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 16:19 UTC (Thu)
                               by <b>juliank</b> (guest, #45896)
                              [<a href="/Articles/445853/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Well by my analysis in the above link, GCC does init the padding to zero.</font><br>
Did you actually enable optimizations when testing?<br>
<p>
<font class="QuotedText">&gt; I'd be very interested if there was a counter example in the wild</font><br>
<p>
<a href="https://lwn.net/Articles/417989/">https://lwn.net/Articles/417989/</a><br>
<a href="https://lwn.net/Articles/417994/">https://lwn.net/Articles/417994/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445853/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445975"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 1:59 UTC (Fri)
                               by <b>pixelbeat</b> (guest, #7440)
                              [<a href="/Articles/445975/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Did you actually enable optimizations when testing?</font><br>
That is immaterial as optimizations may zero the padding.<br>
The interesting case to test is the non optimized case.<br>
<p>
<font class="QuotedText">&gt; <a rel="nofollow" href="https://lwn.net/Articles/417989/">https://lwn.net/Articles/417989/</a></font><br>
<font class="QuotedText">&gt; <a rel="nofollow" href="https://lwn.net/Articles/417994/">https://lwn.net/Articles/417994/</a></font><br>
They concur with my testing I think.<br>
I.E. only in the case where all members are specified<br>
in the initializer list, is the padding not zeroed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445975/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor445880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 18:00 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/445880/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, you could check the code, or (more practically) GCC's intermediate representations, both of which make it fairly clear that GCC emits initializations for every field independently, then subjects them all to optimization just as if you'd written them as separate statements. Sometimes (especially for large structures) this may lead to initializations being merged and blatting over gaps: very often, it does not.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor445852"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 16:17 UTC (Thu)
                               by <b>Spudd86</b> (guest, #51683)
                              [<a href="/Articles/445852/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Automatic variables aren't really relevant to the case of kernel vtables, I imagine they are generally statically allocated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445852/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor445613"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 16:11 UTC (Wed)
                               by <b>dashesy</b> (guest, #74652)
                              [<a href="/Articles/445613/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Very useful article, thanks. I think some inline color-coded code was a definite plus for a newbie like me but was a bookmark-worthy article nevertheless. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445613/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor445679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 20:40 UTC (Wed)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/445679/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Surely one of the most important reasons for using a real function as a default and not a NULL pointer (see [ <a href="http://en.wikipedia.org/wiki/Null_Object_pattern">http://en.wikipedia.org/wiki/Null_Object_pattern</a> ] by the way) is that having every caller check for NULL adds the potential for lots of additional typing mistakes or other errors in the caller code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445707"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 22:32 UTC (Wed)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/445707/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that would fall under Neil's generalization that:<br>
<p>
<font class="QuotedText">&gt; In general, any testing performed by the caller before calling a method can be seen as an instance of the "mid-layer mistake" discussed in a previous article. </font><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445707/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor445695"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 21:15 UTC (Wed)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/445695/">Link</a>] (82 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All right, I can't resist.  I have to ask, "why?"  Why go through all the pain of manually setting up vtables when we have a language that will do it for you?<br>
<p>
Yeah, yeah, I know all about Linus' biases against C++.  He's flat out wrong and being a stick in the mud.  One does not have to use every feature of a language to get good productivity out of the language.  It seems to me simple uses of the C++ inheritance model would clean up code considerably and lead to fewer bugs and more developer hair.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445695/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445697"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 21:31 UTC (Wed)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/445697/">Link</a>] (38 responses)
      </p>
      
      </div>
      </summary>
      <p>Now <i>I</i> can't resist.  Linus' bias against C++ notwithstanding, there are some seriously good reasons to avoid using it for kernel programming:</p>

<ul>
<li>Using C++'s standard library types and features generates a <i>lot</i> of object code bloat.  Trust me, I refactored some of my own programs from C++ back to C and got ELF objects less than half as big.</li>
<li>Generally speaking, use of higher-level language tools (such as the C++ standard library) tends to move the programmer further away from the bare metal (and kernel programming should be as close to the metal as possible).</li>
<li>The use of a single programming language tends to make all participants have a similar mindset of the technical problems being solved, and</li>
<li>Use of a low-level language where it's easy to &quot;shoot your foot off&quot; tends to weed out those without a thorough technical knowledge of kernel programming (Okay, I'm going into generalizations, here, but I'm sure I've read Linus mention something similar to these a while back).</li>
</ul>

<p>Bear in mind that I'm a devout C++ programmer&mdash;I really do love to code in both C and C++.  It's just that I think Linus' arguments against C++ with respect to kernel programming are justified.</p>

<p>Please do <i>NOT</i> read this as an attempt to start a language war&mdash;again I love both languages!</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/445697/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445706"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 22:43 UTC (Wed)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/445706/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C is IMHO also typically easier to debug as function names are typed in full  (= easier to grep/find from large code base) and their meaning doesn't mutate with inheritance / overloading.<br>
<p>
From reading the C++ code you cannot guess what innocent looking lines do, I've seen (bad) C++ programs that malloc() all together nearly 1MB of RAM before they even enter main(), due to there being static objects and their constructors creating innocent looking other object(s) that turn out not to be integers... (And btw. C++ ABI actually defines classes to have several constructors for different purposes, although source code has only one)<br>
<p>
Debugging problems at HW level is already hard, making it harder by selecting too complex language doesn't help.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445706/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor445726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 0:23 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445726/">Link</a>] (36 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can write C++ code without the stdlibc++, it's not that hard - just turn off exceptions, do not use static initializers and off you go.<br>
<p>
It was even possible to use C++ in the Linux kernel some time ago. Unfortunately, after about 2.6.16 a lot of C++ keywords ('template', 'class', etc.) started to appear in the kernel structs so porting became difficult.<br>
<p>
I'm using C++ in Microsoft Windows drivers (via <a href="http://code.google.com/p/ontl/">http://code.google.com/p/ontl/</a> ). It's actually quite nice to use Boost.ScopeExit instead of 'goto error_exit'. And exceptions! One can actually use exceptions in Windows, even in the kernel mode. Oh and real templated containers, of course.<br>
<p>
And advantages of C++ are really visible. Good C++ code is about 30%-50% of corresponding C code in LOCs, and much easier to read.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445735"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 2:28 UTC (Thu)
                               by <b>nevets</b> (subscriber, #11875)
                              [<a href="/Articles/445735/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with saying we should use a subset of C++ is that it will never happen. There's just too many contributors to enforce such a thing. There's too many places that people may use side effects of C++.<br>
<p>
You state that good C++ is easier to read and understand. I'm saying that bad C++ code is much worse to figure out than bad C code. And unfortunately, there just happens to be a lot of bad C code in the kernel. It does get cleaned up over time. But with the huge number of contributors, crap just keeps slipping in.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445735/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor445768"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 9:37 UTC (Thu)
                               by <b>juliank</b> (guest, #45896)
                              [<a href="/Articles/445768/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Good C++ code is about 30%-50% of corresponding</font><br>
<font class="QuotedText">&gt; C code in LOCs, and much easier to read.</font><br>
<p>
Not really know. You always need to work around the C++ language with things like shared_ptr and named constructor idioms, and prevent default constructors and more to produce something useful. In C, you add a reference count field to you struct, create a new, a ref, and an unref function and you're done. Much easier.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445768/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 9:44 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445771/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
LOL.<br>
<p>
In C you _have_ to manually ref/unref things (and get hard-to-detect errors when you unbalance them). In C++ one just uses shared_ptr (or one of other smart pointers) to do it _automatically_ - it's not possible to unbalance shared_ptr (at least without trying hard to do it).<br>
<p>
That's not a workaround - that's a feature, and a wonderfully nice feature at that. A couple of lines in C++ can easily replace 5-10 lines in C. <br>
<p>
Also, why would you suppress default constructors? They work just fine, even with shared_ptrs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 9:58 UTC (Thu)
                               by <b>juliank</b> (guest, #45896)
                              [<a href="/Articles/445775/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Also, why would you suppress default constructors?</font><br>
<font class="QuotedText">&gt; They work just fine, even with shared_ptrs.</font><br>
You may want to restrict users to use only shared_ptr, in order to have a controlled way to reference things. Reference counting just feels completely unnatural in C++.<br>
<p>
Another problem is ABI stability. It might be possible to get some more stability by suppressing anything default and allowing only pointers to objects to be taken. The safer option is to use d-pointers in the classes, but this is all very complicated compared to declaring an incomplete type in C.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445776"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 10:08 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445776/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;You may want to restrict users to use only shared_ptr, in order to have a controlled way to reference things. Reference counting just feels completely unnatural in C++.</font><br>
<p>
Why? A class should not be constricting its users, unless it's necessary. If your class should be used ONLY with refcounting, then intrusive_ptr is a better solution. C++ is just fine with refcounting, just learn to use C++ correctly.<br>
<p>
ABI stability is about on the same level as in C. Just use incomplete classes, they work EXACTLY like in C.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445776/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 10:16 UTC (Thu)
                               by <b>juliank</b> (guest, #45896)
                              [<a href="/Articles/445777/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why? A class should not be constricting its users, unless it's necessary.</font><br>
A user should never know the size of an object, unless it's necessary. C++ just does not allow me to do this in a sane way, so it's already disqualified for long-term library projects.<br>
<p>
<font class="QuotedText">&gt; If your class should be used ONLY with refcounting,</font><br>
<font class="QuotedText">&gt; then intrusive_ptr is a better solution</font><br>
Not part of C++.<br>
<p>
<font class="QuotedText">&gt; C++ is just fine with refcounting, just learn to use C++ correctly.</font><br>
If you like std::shared_ptr&lt;MyObject&gt; everywhere, then yes, it works. But it looks like an ugly peace of shit when compared to a reference counting C library.<br>
<p>
<p>
<font class="QuotedText">&gt; ABI stability is about on the same level as in C. </font><br>
<font class="QuotedText">&gt; Just use incomplete classes, they work EXACTLY like in C.</font><br>
Call a method on an incomplete class.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445778"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 10:26 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445778/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;A user should never know the size of an object, unless it's necessary. </font><br>
Why?? Opaque object pointers are nice for some parts of ABI, but internally they are rarely required.<br>
<p>
<font class="QuotedText">&gt;C++ just does not allow me to do this in a sane way, so it's already disqualified for long-term library projects.</font><br>
C++ allows to do it EXACTLY like in C. You just use forward declarations. C++ won't allow you to use copy constructor unless you have full class definition, so no difference here as well.<br>
<p>
Please, stop spreading FUD.<br>
<p>
<font class="QuotedText">&gt;&gt; If your class should be used ONLY with refcounting,</font><br>
<font class="QuotedText">&gt;&gt; then intrusive_ptr is a better solution</font><br>
<font class="QuotedText">&gt;Not part of C++.</font><br>
<p>
Can you point me where reference counting is described in the C99 Standard?<br>
<p>
<font class="QuotedText">&gt;If you like std::shared_ptr&lt;MyObject&gt; everywhere, then yes, it works. But it looks like an ugly peace of shit when compared to a reference counting C library.</font><br>
<p>
Why would you need it? If you want an opaque interface, then do it exactly like in C. If you want a _sane_ interface then provide full type definitions and let user to decide what to use (shared_ptr, auto_ptr, etc.) and/or provide built-in refcounters and generic AddRef/Release functions.<br>
<p>
<font class="QuotedText">&gt;Call a method on an incomplete class.</font><br>
Pass an incomplete structure by value in C.<br>
<p>
You can't call a method of an incomplete class (duh, it's _INCOMPLETE_). But you can pass it as a parameter to a function/method. Just like in C.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445778/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445780"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 11:12 UTC (Thu)
                               by <b>juliank</b> (guest, #45896)
                              [<a href="/Articles/445780/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      > Why?? Opaque object pointers are nice for some parts of ABI,
> but internally they are rarely required.
In user space code, at least 99% of all ABI should be opaque. There should be no inline code (and thus no templates), no complete types, the only things there should be are functions and incomplete types. 

Everything else is going to fail. Even in Qt, where they try harder to avoid such problems, we still have an ABI that only lasts 4 years (Qt3) or is expected to last 6 years (Qt4). In other parts of the world, we have ABI breaks in every minor release (V8), or all few months (APT). 

C ABIs in contrast can last much longer, as evident by the fact that GLib 2 was released in 2002, and did not have any ABI break yet. Of course, there are also bad C ABIs, such as Python's, which are allowed to break with every release, but C makes it much easier to create a consistent long-term-stable ABI than C++.


> You can't call a method of an incomplete class
> (duh, it's _INCOMPLETE_). But you can pass it
> as a parameter to a function/method. Just like
> in C.
But then you're in C world again, and have no advantage of using C++. 

In C, the struct can be incomplete, yet I can call functions on it which can be virtual (methods) and other functions, all using one common interface, via functions, such as the following two, defined in the my_object.c.

<pre>



struct MyObject {
   int some_internal_int_field;
   void (*method_a)(MyObject *o);
};

int my_object_function_a(MyObject *o)
{
   return o->some_internal_int_field;
}

void my_object_method_a(MyObject *o)
{
   o->method_a(o);
}
</pre>

The external world only sees the header file:

<pre>
typedef struct MyObject MyObject;

int my_object_function_a(MyObject *o)
void my_object_method_a(MyObject *o)
</pre>

The language coming closest to the optimum is Vala. Private fields are not part of an objects ABI, neither is (for callees) whether a method is virtual or not.
      
          <div class="CommentReplyButton">
            <form action="/Articles/445780/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 13:19 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445797/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And you can do this in C++ just as well. What's the problem? Quite a lot of C++ libraries have pure-C interface (often for the reasons of compatibility with another languages).<br>
<p>
Then there is COM. There are COM-interfaces in Windows which are stable since _1993_ (the ones that deal with OLE) and that's kinda hard to beat. And COM maps directly into C++, COM-interfaces are just pure C++ classes. AddRef/Release can be managed using smart pointers and QueryInterface is dynamic_cast&lt;&gt; reimplemented manually.<br>
<p>
Yes, designing stable C++ interfaces requires some forethought. But pure C interfaces require no less forethought.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445907"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 20:14 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/445907/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>I had asked that my earlier post not be construed as an attempt to start a language war, and, guess what? We now have a language war.</p>

<p>Sigh.</p>

<p>At least this one has been fairly tame.  If there's anything nice about the above discussion, it's that I've learned a lot about exception-handling programming.  Thanks! ;-)</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/445907/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 22:24 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445944/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, I actually deeply hate C++ :) But I also can't tolerate FUD for the languages I really hate.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445998"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 8:10 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/445998/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agreed, such FUD and lies are really annoying. I have very little love for C++ but anyone who claims that C++ cannot do something while C can is just making pure noise and calling to be filtered out.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445998/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor446870"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2011 16:29 UTC (Thu)
                               by <b>jd</b> (guest, #26381)
                              [<a href="/Articles/446870/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If we're going to have a language flame-war anyway, I propose rewriting the kernel in Occam. :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446870/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor445939"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 21:46 UTC (Thu)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/445939/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The language coming closest to the optimum is Vala. Private fields are not </font><br>
<font class="QuotedText">&gt; part of an objects ABI, neither is (for callees) whether a method is </font><br>
<font class="QuotedText">&gt; virtual or not.</font><br>
<p>
I'm pretty sure private fields are not part of the ABI in Java, either. Your jar files will continue to work when someone changes private fields in a different jar. It's a nice feature and a lot of modern programming languages have it.<br>
<p>
And as you noted, C has it as well. Private stuff stays private in C (as opposed to C++.)<br>
<p>
C.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445939/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 23:45 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445956/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Java has very loose ABI. It's possible to add new public methods without breaking it or even modify existing methods to some degree.<br>
<p>
There's a nice description here: <a href="http://wiki.eclipse.org/Evolving_Java-based_APIs_2">http://wiki.eclipse.org/Evolving_Java-based_APIs_2</a><br>
<p>
The fact that Java bytecode is essentially a lightly-parsed source code helps immensely. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446672"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2011 19:22 UTC (Wed)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/446672/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linking at start time makes Java very flexible indeed. It is also what makes every Java program insanely slow to start up.<br>
<p>
You cannot have your cake and eat it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446672/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor445798"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 13:16 UTC (Thu)
                               by <b>jond</b> (subscriber, #37669)
                              [<a href="/Articles/445798/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Aren't exceptions one of the best reasons *not* to use C++ for such a thing?  The possibility of exceptions make this pattern impossible:<br>
<p>
void somefunction() {<br>
do_something();<br>
do_something_else();<br>
important_cleanup_code();<br>
}<br>
<p>
More in the "Dark side of C++" talk:<br>
<a href="http://www.fefe.de/c++/c%2B%2B-talk.pdf">http://www.fefe.de/c++/c%2B%2B-talk.pdf</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445798/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445801"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 13:37 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445801/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This kind of code is BAD.<br>
<p>
For this reason:<br>
====================<br>
void somefunction() {<br>
  do_something();<br>
  if (do_something_else())<br>
    return; //Whoopsie!<br>
  important_cleanup_code();<br>
}<br>
====================<br>
<p>
In good C++ one would write something like:<br>
====================<br>
void somefunction() {<br>
  ON_SCOPE_EXIT(&amp;important_cleanup_code);<br>
<p>
  do_something();<br>
  if (do_something_else())<br>
    return; //No whoopses.<br>
  do_something_really_else();<br>
}<br>
====================<br>
<p>
If you use smart pointers it's even nicer:<br>
====================<br>
void shared_ptr&lt;File&gt; somefunction() {<br>
  const std::string &amp;name=compute_file_name();<br>
  if (some_condition(name))<br>
     return shared_ptr(new File(name, FOR_READ));<br>
  if (anotherCondition())<br>
     throw my_exception(F("Something bad happened with the file ")&lt;&lt;name);<br>
  return shared_ptr(new File(name, FOR_WRITE));<br>
}<br>
<p>
//Call site<br>
shared_ptr&lt;File&gt; fl=somefunction(); //that's it!<br>
//One can even do<br>
somefunction(); //For side effects, for example - returned file won't be lost<br>
====================<br>
<p>
In pure C you'll have to do something like:<br>
====================<br>
void int somefunction(file_object_ptr *result_place)<br>
{<br>
  some_string name;<br>
  int res;<br>
  name=compute_file_name();<br>
<p>
  if (some_condition(name))<br>
  {<br>
     //And pray that your numeric error codes do not collide.<br>
     res=file_open_file(name, FOR_READ, result_place);<br>
     //What if we want to pass a verbose message <br>
     //like 'file &lt;NAME&gt; is locked by another process'?<br>
     goto cleanup;<br>
  }<br>
  if (anotherCondition())<br>
  {<br>
     res=E_SOMETHINGBAD;<br>
     //Verbose errors? Forget about it.<br>
     goto cleanup;<br>
  }<br>
  <br>
  res=file_open_file(name, FOR_WRITE, result_place);<br>
<p>
  cleanup:<br>
    free_string(name);<br>
<p>
  return res;<br>
}<br>
<p>
//Call site<br>
file_object_ptr obj=0; //Don't forget to initialize!<br>
int res=somefunction(&amp;obj);<br>
if (res&lt;0) return res; //Hope...<br>
cleanup:<br>
   delete_file(obj);<br>
====================<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445801/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 14:20 UTC (Thu)
                               by <b>Trelane</b> (subscriber, #56877)
                              [<a href="/Articles/445816/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Pardon my ignorance, but where does ON_SCOPE_EXIT come from? I'd really like it in some places. :)<br>
Thanks!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 15:48 UTC (Thu)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/445843/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looks like this: <a href="http://code.google.com/p/scope-exit/">http://code.google.com/p/scope-exit/</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor445844"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 15:56 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445844/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Originally, from Alexandrescu's article. I've been using it since 2001: <a href="http://drdobbs.com/cpp/184403758">http://drdobbs.com/cpp/184403758</a> . It's simple and it works everywhere (even on VisualStudio 6).<br>
<p>
Then there's Boost.ScopeExit: <a href="http://www.boost.org/doc/libs/1_45_0/libs/scope_exit/doc/html/scope_exit/tutorial.html">http://www.boost.org/doc/libs/1_45_0/libs/scope_exit/doc/...</a> which is a bit nicer (it even lists alternatives here: <a href="http://www.boost.org/doc/libs/1_45_0/libs/scope_exit/doc/html/scope_exit/alternatives.html">http://www.boost.org/doc/libs/1_45_0/libs/scope_exit/doc/...</a> ).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445844/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 19:04 UTC (Thu)
                               by <b>Trelane</b> (subscriber, #56877)
                              [<a href="/Articles/445898/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the pointers! (heh) It will make my code suck much less. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 22:42 UTC (Thu)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/445945/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Golang has the "defer" statement, which sets up some statements which will be executed when the current scope exits. So you might do something like this

<pre>
> func foo() {
>     defer fmt.Println("running cleanup");
>    ...
> }
</pre>

Then the printout will happen when you return from the function, whenever that is.<p>

C, of course, has the single exit point idiom, which is used a lot in the kernel. It looks like this:

<pre>
> int foo() {
>     setup_bar();
>     ...
>     if (ret)
>         goto cleanup;
>     ...
> cleanup:
>     shutdown_bar();
>     return ret;
> }
</pre>

Java, Python, and Ruby have try...finally { }<p>

I have to be honest; I don't think dumping that pile of macros and templates into your code will make it "suck less." I think you just need to use the mechanisms C++ gives you, namely try and catch, and RAII. It may be an extra line or two, but the programmers trying to read your code after you've moved on will thank you.<p>

Especially when you're debugging something, flow control macros are not your friends. Alexandrescu may be able to figure it out in gdb, but he probably doesn't work with you.
      
          <div class="CommentReplyButton">
            <form action="/Articles/445945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445950"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 22:53 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445950/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To be fair, ON_SCOPE_EXIT is quite nice. Its functionality is very simple and restricted and it's indispensable when one needs to do something simple, usually with non-C++ resources (like calling fclose on FILE*).<br>
<p>
It's also easy to debug. Though I tend to spend much less time in a debugger when working with C++ code, all this strict typing pays off.<br>
<p>
C++0x has lambdas so it's possible to write analog of 'defer' from Golang (indeed, Boost already has it).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445950/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445968"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 1:16 UTC (Fri)
                               by <b>Trelane</b> (subscriber, #56877)
                              [<a href="/Articles/445968/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks to both of your for the info; I am learning a lot. Yet again LWN proves to be the only place where the comments have value. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445968/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor446013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 9:46 UTC (Fri)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/446013/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>FYI, you can still use shared_ptr with FILE* (and probably any other C API that follows the same pattern.

<pre>shared_ptr&lt;FILE&gt; f (fopen ("whatever", "r"), fclose);</pre>

<p>Now, fclose will be called whenever the last copy of that shared_ptr is destructed. No more single exit points, goto tricks, or leaning towers of if statements!
      
          <div class="CommentReplyButton">
            <form action="/Articles/446013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 12:30 UTC (Fri)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/446038/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's pretty good, and it relies on things that are actually in the standard library. Thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 14:19 UTC (Fri)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/446056/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This and std::vector are the best things in C++! :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor446232"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2011 8:58 UTC (Mon)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/446232/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This kind of code is BAD.</font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt; For this reason:</font><br>
<font class="QuotedText">&gt; ====================</font><br>
<font class="QuotedText">&gt; void somefunction() {</font><br>
<font class="QuotedText">&gt; do_something();</font><br>
<font class="QuotedText">&gt; if (do_something_else())</font><br>
<font class="QuotedText">&gt; return; //Whoopsie!</font><br>
<font class="QuotedText">&gt; important_cleanup_code();</font><br>
<font class="QuotedText">&gt; }</font><br>
<font class="QuotedText">&gt; ====================</font><br>
<p>
In C you can get round that with the following (you don't have to like it if you don't want to!)<br>
<p>
void somefunction_wrapper() {<br>
somefunction_core();<br>
important_cleanup_code();<br>
}<br>
<p>
void somefunction_core() {<br>
do_something();<br>
if (do_something_else())<br>
return; //No whoopses.<br>
do_something_really_else();&gt; return; //Whoopsie!<br>
}<br>
<p>
<font class="QuotedText">&gt; //And pray that your numeric error codes do not collide.</font><br>
<font class="QuotedText">&gt; res=file_open_file(name, FOR_READ, result_place);</font><br>
<font class="QuotedText">&gt; //What if we want to pass a verbose message</font><br>
<font class="QuotedText">&gt; //like 'file &lt;NAME&gt; is locked by another process'?</font><br>
<p>
The devil's advocate in me says: my (admittedly limited) experience is that you can't do that even in C++ without thinking very carefully about error handling before you implement it - including memory management issues, particularly if you may end up handling out of memory conditions using that mechanism.  And if you are going to think about it beforehand anyway you can also return a pointer to an error structure (which can potentially be statically or dynamically allocated) in C rather than just an integer error code.  (That was just an example of course as there are lots of other ways to achieve the same thing.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446232/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2011 14:47 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/446251/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;In C you can get round that with the following (you don't have to like it if you don't want to!)</font><br>
<font class="QuotedText">&gt;void somefunction_wrapper() {</font><br>
<font class="QuotedText">&gt;somefunction_core();</font><br>
<font class="QuotedText">&gt;important_cleanup_code();</font><br>
<font class="QuotedText">&gt;}</font><br>
<p>
That's even worse. You'll have either put resources into global variables (yikes!) or pass around some kind of 'local frame' structure. Essentially reinventing exceptions.<br>
<p>
<font class="QuotedText">&gt;The devil's advocate in me says: my (admittedly limited) experience is that you can't do that even in C++ without thinking very carefully about error handling before you implement it - including memory management issues, particularly if you may end up handling out of memory conditions using that mechanism. </font><br>
OOM conditions are not really worth it to handle in userspace applications.<br>
<p>
In kernel level handling OOM would be mandatory, but not so much different from the current situation. Kernel would just set aside a small pool of RAM and use it during OOM allocations.<br>
<p>
<font class="QuotedText">&gt;And if you are going to think about it beforehand anyway you can also return a pointer to an error structure (which can potentially be statically or dynamically allocated) in C rather than just an integer error code. (That was just an example of course as there are lots of other ways to achieve the same thing.)</font><br>
The problem is that it quickly becomes very cumbersome as each and every function has to pass around pointers to error structures.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446252"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2011 15:00 UTC (Mon)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/446252/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; In C you can get round that with the following (you don't have to like it if you don't want to!)</font><br>
<font class="QuotedText">&gt;&gt; void somefunction_wrapper() {</font><br>
<font class="QuotedText">&gt;&gt; somefunction_core();</font><br>
<font class="QuotedText">&gt;&gt; important_cleanup_code();</font><br>
<font class="QuotedText">&gt;&gt; }</font><br>
&gt;<br>
<font class="QuotedText">&gt; That's even worse. You'll have either put resources into global variables &gt; (yikes!) or pass around some kind of 'local frame' structure. Essentially &gt; reinventing exceptions.</font><br>
<p>
Not quite sure what you mean there.<br>
<p>
[...]<br>
<p>
<font class="QuotedText">&gt;&gt; And if you are going to think about it beforehand anyway you can also return a pointer to an error structure (which can potentially be statically or dynamically allocated) in C rather than just an integer error code. (That was just an example of course as there are lots of other ways to achieve the same thing.)</font><br>
<font class="QuotedText">&gt; The problem is that it quickly becomes very cumbersome as each and every function has to pass around pointers to error structures.</font><br>
<p>
Not really - you just return a pointer where C traditionally returns an integer error code, and pass that on if a function you call returns a non-NULL error pointer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446252/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor447013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2011 13:08 UTC (Fri)
                               by <b>jond</b> (subscriber, #37669)
                              [<a href="/Articles/447013/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This kind of code is BAD.</font><br>
<font class="QuotedText">&gt; For this reason:</font><br>
<font class="QuotedText">&gt; ====================</font><br>
<font class="QuotedText">&gt; void somefunction() {</font><br>
<font class="QuotedText">&gt; do_something();</font><br>
<font class="QuotedText">&gt; if (do_something_else())</font><br>
<font class="QuotedText">&gt; return; //Whoopsie!</font><br>
&amp;#9986;  &amp;#9986;  &amp;#9986;  &amp;#9986;  &amp;#9986;<br>
<p>
That isn't the example code I provided, at all.  You've injected a return which I did not have in my code.  My code, as written, will (in C) guarantee the last line to be executed if the process has not been terminated.  Exceptions in C++ prevent you from making the same assertion, which is why you need RAII and/or<br>
<p>
<font class="QuotedText">&gt; If you use smart pointers it's even nicer:</font><br>
<p>
stuff like smart pointers.<br>
<p>
There's a good overview of using smart pointers and other techniques to ensure deterministic resource management here:<br>
<p>
<a href="http://www.slideshare.net/eplawless/exception-safety-and-garbage-collection-and-some-other-stuff">http://www.slideshare.net/eplawless/exception-safety-and-...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/447013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor447024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2011 13:22 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/447024/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can use single-loops for ultra-light-weight exception handling in any C-syntax-like language:<br>
<p>
<a href="http://bit.ly/j69nwV">http://bit.ly/j69nwV</a><br>
<p>
Obviously the do_final_stuff pattern can be used within the do_exceptional_stuff pattern (inc via helper funcs).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/447024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor447844"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2011 8:11 UTC (Thu)
                               by <b>gowen</b> (guest, #23914)
                              [<a href="/Articles/447844/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <pre>void somefunction() {
  do_something();
  do_something_else();
  important_cleanup_code();
}</pre>

<p>Can do_something() fail for some reason?  If so, why don't you check for it? If not, why do you think you need to worry about it throwing an exception? 

<p>Under what circumstances do you imagine that C++ do_something_cpp() will throw an exception but do_something_c() silently succeed?
      
          <div class="CommentReplyButton">
            <form action="/Articles/447844/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor447853"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2011 9:12 UTC (Thu)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/447853/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's big differences.<br>
<p>
A C-style error handler can fail without bringing down the rest of the system.  An exception cannot.  There's also different definitions of "fail" with different levels of consequences, while an exception is always a fatal error unless you explicitly check for it.<br>
<p>
There's the matter of exception handling logic not being able to be placed where you might want it, too.  With a simplistic C error handling facility I can store an error code and check it later when it matters or is most convenient.  With exceptions, I need to wrap each individual function call (and operator, etc.) in order to ensure that nothing slips past.<br>
<p>
Operator overloading, virtual functions, etc. are all massively useful features that help an unbelievable amount in writing good code.  Exceptions just don't bring any meaningful benefit to large, complex programs that need to keep operating, don't bring any readability/maintainability benefit, and pretty much only appear to be beneficial when you look at tiny little trivial error handling examples compared to very poorly written C APIs.  (Operator overloading is often panned, but anyone who's ever written a game in C with C-style math libraries can tell you that operator loading opponents are full of doody; and anyone who's ever tried a math library in Python/Lua/JavaScript/Ruby/Java/C#/etc. can tell you with five times the conviction that dynamic typing or static typing without local types that C++ critics are full of doody.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/447853/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor447925"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2011 13:46 UTC (Thu)
                               by <b>gowen</b> (guest, #23914)
                              [<a href="/Articles/447925/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><i>There's the matter of exception handling logic not being able to be placed where you might want it, too. With a simplistic C error handling facility I can store an error code and check it later when it matters or is most convenient.</i></blockquote> 

Wow.  I am truly staggered ... just utterly lost for words. Exceptions/RAII automatically propogate non-recoverable errors to the correct level of abstraction, error return values have to be propogated by hand.

<blockquote><i> With exceptions, I need to wrap each individual function call (and operator, etc.) in order to ensure that nothing slips past.</i></blockquote>

Holy living Christ on a bicycle... Do you really think that's how to write code that uses exceptions for error handling? If you do, please stop writing about it, because you don't know what you're talking about.
      
          <div class="CommentReplyButton">
            <form action="/Articles/447925/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor445714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 22:57 UTC (Wed)
                               by <b>brianomahoney</b> (guest, #6206)
                              [<a href="/Articles/445714/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I could not disagree with you more, the biggest problem with C++ is it is just too complicates for most programmers, and fosters cult programming styles<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 8:51 UTC (Thu)
                               by <b>dajoli66</b> (guest, #61914)
                              [<a href="/Articles/445756/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
LOL, this article is an analysis of (some of) the "cult programming styles" in the current kernel! Bear in mind that some cult styles can be helpful in hiding some necessary complexity and making algorithm simplicity more clear, e.g. macros for lock;call;unlock sequences, which can lead to cluttered code (or worse, coding errors) when spelled out in full.<br>
<p>
FWIW, the stats over at langpop.com seem to suggest that "most programmers" find C++ perfectly usable, although C still gets as much or more discussion/committers/work etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor445790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 12:19 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/445790/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, among other things the very article you're responding to provides a number of examples of doing things with vtables which C++ will *not* do automatically for you (e.g. having several different vtables referring to the same object without paying any space cost in that object).<br>
<p>
So you'd either have to take an efficiency hit, or do a lot of this stuff manually in C++ as well, which would lead to an ugly mix of inconsistent coding styles.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446066"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 14:58 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/446066/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe the variants described could be implemented in C++ via virtual functions (overriding operations for specific types), inheritance-style mixins or the Visitor pattern (both used to add operations to an existing type, the latter being more dynamic than the former).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446066/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor445877"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 17:54 UTC (Thu)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/445877/">Link</a>] (38 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Which C++ keywords/features, in your opinion, should one be able to use in kernel code (since we are explicitly talking about using a subset of C++).  Also, how do I, as a C contributor, deal with things like someone accidentally overloading my foo(int) function with foo(char), and other such issues?  Ie. Who is in charge of enforcing the correct subset of C++ on a project with such a wide range of contributors, since compiling in C++ typically gives you access to *all* of C++, not just the subset you prefer?<br>
<p>
Btw, the inheritance model that you tout as a feature (for "simple uses") is arguably one of C++'s *worst* additions to the C language; there is a reason that no one else ever copied it (AFAIK).  Where do you draw the line on how much of it to use?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445877/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445930"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 21:01 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445930/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, other projects manage to do it just fine. For example, see: LLVM, QT, OpenOffice, FireFox, Chrome and so on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445930/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445936"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 22:08 UTC (Thu)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/445936/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Which of those projects started as a large C codebase, and migrated to C++?  I mean, that is what we are discussing, unless you are proposing redesigning the Linux kernel from scratch, using C++.  Do we allow device drivers to be C++, but still use the core C kernel code?  Or do we require the device drivers to be C, but redesign the core with C++?  What subsystems would benefit *immediately* from being rewritten in C++?  These are questions without obvious answers, imo.<br>
<p>
I'd bet a kernel project that was started from scratch using C++, could probably *not* sustain the rate of development that Linux has seen, given the nature of it's contributor base.  Those projects you mentioned all started in C++ (AFAIK), typically with a small focused team of programmers, all commercially funded (except LLVM, which had research funding initially), whereas Linux had an explosion of early volunteer contributors.  And I'm not completely sure, but it seems that Linux still has the widest range of commercial and volunteer contributors compared to any of the other projects you mentioned.  It's just not comparable; a C++ codebase *would* drastically affect the set of contributors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445936/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 22:23 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445941/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Do we allow device drivers to be C++, but still use the core C kernel code? Or do we require the device drivers to be C, but redesign the core with C++? What subsystems would benefit *immediately* from being rewritten in C++? These are questions without obvious answers, imo.</font><br>
<p>
Any real refactoring of Linux-sized codebases MUST be gradual. Hypothetically, I'd first clean up kernel source to allow C++ drivers, introduce kernel-side C++ library and then slowly convert subsystems to it.<br>
<p>
Though by now it might not get us much benefit, I admit. A lot of kernel code is fairly conservative and rewriting it just for the sake of rewriting won't get us anything useful.<br>
<p>
<font class="QuotedText">&gt;I'd bet a kernel project that was started from scratch using C++, could probably *not* sustain the rate of development that Linux has seen, given the nature of it's contributor base. Those projects you mentioned all started in C++ (AFAIK), typically with a small focused team of programmers, all commercially funded (except LLVM, which had research funding initially), whereas Linux had an explosion of early volunteer contributors.</font><br>
<p>
KDE started the same way - an explosion of contributors working on the same goal. By now it's comparable in size with the Linux kernel. Ditto for Haiku OS (though it can't compare with Linux).<br>
<p>
At smaller scales, we're seeing addition of C++ to the Mesa project right now (new shader compiler and optimizer is written in C++) and it seems to be working out fine. Though they use it in C-with-classes fashion, mainly for the 'Visitor' pattern.<br>
<p>
There are some case studies on transitioning large codebases from C to C++: <a href="http://www.bleading-edge.com/Publications/C++Report/v9507/Article1.rtf">http://www.bleading-edge.com/Publications/C++Report/v9507...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445947"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 23:07 UTC (Thu)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/445947/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; KDE started the same way - an explosion of contributors working on the same goal.</font><br>
<p>
But KDE was also a collection of many independent, even orthogonal, applications such that developers could work on their piece without any affect on another (ie. less code merging across larger groups, etc.)  Even the dependent pieces were often linked together by abstractions at a higher level than the language (object brokers, interprocess communication protocols, etc.) right?   So the real core C++ libraries and such, that were linked into programs directly were a much smaller group of developers and contributors (I'm guessing).  And furthermore, a significant portion of that core was based around the commercially developed QT, which started completely as C++ (and hell, even extended it) and was a small tight team.  KDE is definitely a great example of a large and active C++ based project, but still, I think, a *very* different contribution model than a community driven C++ monolithic kernel would be.  It all comes down to merging, and merging lots of separate contributed C++ code and requires a lot more pre-planning, design, discipline, coordination, and review *just at the language level* than C (imo).<br>
<p>
However, my summary of KDE could be wrong, so someone please correct me if so.  I've not used it much personally.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445947/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445954"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 23:20 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/445954/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Kernel is not exactly monolithic as well. It has various loosely-linked subsystems and a lot of code is in drivers. Also, I'd like to point out that the core in Linux initially was quite small as well.<br>
<p>
Ah, and I've forgotten about another large C project switching to C++ -  <a href="http://gcc.gnu.org/wiki/gcc-in-cxx">http://gcc.gnu.org/wiki/gcc-in-cxx</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445954/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445971"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 2:34 UTC (Fri)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/445971/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Kernel is not exactly monolithic as well.</font><br>
<p>
Sure it is.  Certainly in the classic sense of not having memory access isolation between all services, drivers, etc.  The Linux kernel may be modular, and have some kernel threads, but it is "exactly monolithic" by the standard definition, is it not?<br>
<p>
Thus, it isn't paranoia on the part of the developers to use a language that allows one to fairly easily see what memory accesses are occurring on a roughly line per line basis (such as C).<br>
<p>
<font class="QuotedText">&gt; Ah, and I've forgotten about another large C project switching to C++ (gcc)</font><br>
<p>
That's interesting, because the gcc development seems so different from Linux's; things like the copyright assignment provisions may (or may not, I'm speculating) affect the contributor pool in a way that makes the transition more practical.  In any case, compilers work at a different level, so that the memory access abstractions of C++ aren't so objectionable.  In fact, I suspect hey have more data structures and inheritance possibilities that would benefit directly from it, and it's probably a good choice for them.  But I don't think that necessarily translates into a reason for a kernel project to do the same.<br>
<p>
In any case, while I disagree with daglwn's assertion that Linus was "flat out wrong" about C++, it's exciting to see projects that implement a kernel in a language like C++ (or D, or Go, etc.) to know how the language features influence design decisions and ease of implementation, to see if it really matters.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445971/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 14:46 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/446058/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Sure it is. Certainly in the classic sense of not having memory access isolation between all services, drivers, etc. The Linux kernel may be modular, and have some kernel threads, but it is "exactly monolithic" by the standard definition, is it not?</font><br>
<p>
I don't mean 'monolithic' in the sense of 'monolithic vs. microkernels'. I meant it in the sense of 'one giant C file vs. modular code'.<br>
<p>
Linux Kernel is divided into subsystems which are pretty independent: network layer doesn't really care about DRI, for example.<br>
<p>
<font class="QuotedText">&gt;In any case, while I disagree with daglwn's assertion that Linus was "flat out wrong" about C++, it's exciting to see projects that implement a kernel in a language like C++ (or D, or Go, etc.) to know how the language features influence design decisions and ease of implementation, to see if it really matters.</font><br>
<p>
It doesn't look like that C vs. C++ matter much in kernel development (look at L4 kernel, for example).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 17:49 UTC (Fri)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/446083/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I don't mean 'monolithic' in the sense of 'monolithic vs. microkernels'.</font><br>
<p>
Well, that's confusing then.  The term already has meaning in kernel discussions, and you were responding to *my* usage of the term.  But, ok.<br>
<p>
The concerns I mentioned still apply for pretty independent codebases: if you intend to build the whole kernel with C++, you have do deal with all the legacy C code and interaction issues (function namespace, type incompabilities, etc.) so as you said it must be gradual.  But, if it's gradual, you now have a complicated mixed build system and have to worry about how to interact across the C/C++ layers (since there is no agnostic "message passing" layer for the components, like a microkernel would have).  It could be done, I'm sure, it just a matter of what is motivating it.<br>
<p>
It might make sense if there already existed some well tested code bases that were worth integrating; let's say hypothetically that ZFS had been released as GPL years ago, but it's implementation was in C++.  Then I could see dealing with the pain (or attempting it), rather than a rewrite.<br>
<p>
<font class="QuotedText">&gt; It doesn't look like that C vs. C++ matter much in kernel development (look at L4 kernel, for example).</font><br>
<p>
Well, L4/Fiasco *is* a microkernel, with a well defined message passing ABI, built by a small team, and is *tiny*.   But it demonstrates that design of the OS is the much bigger issue than language implementation for the most part.  The language issue really matters more (imo) from a community and potential contributor perspective.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor446003"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Haiku</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 8:48 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/446003/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Haiku is a really terrible example.<br>
<p>
In their kernel they're using a subset of 1990s C++ that gives them much less functionality than the C++ aficionados have been talking about in these comments.<br>
<p>
All non-core components use only C APIs even though they may be in C++. So many of the examples mentioned for Linux would still have to be done the same way since they're available in blessed module APIs for Haiku.<br>
<p>
And despite a decade's work what they have is basically a BeOS clone. Nasty shortcuts to rush BeOS to market before Be Inc. ran out of money, faithfully reproduced. That goes from big picture things like no privilege separation and no power management to little annoyances like no real hot plug (they have a hack that lets them hotplug USB devices by first loading all the drivers they might want...)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446003/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Haiku</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 13:07 UTC (Fri)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/446040/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In their kernel they're using a subset of 1990s C++ that gives them much </font><br>
<font class="QuotedText">&gt; less functionality than the C++ aficionados have been talking about in </font><br>
<font class="QuotedText">&gt; these comments.</font><br>
<p>
*Everyone* is using some kind of subset of C++.<br>
<p>
Firefox and Chrome, as well as Webkit, are using -fnoexceptions and -fnortti. This is a pretty important design choice because it means that you can't do things that can fail in your constructors, since there is no way for them to report errors except throwing exceptions.<br>
<p>
XNU, which later became the basis of the Mac OS kernel, uses a restricted subset of C++ that doesn't allow exceptions, multiple inheritance, or templates.<br>
<p>
If projects do use exceptions, they all do it differently. Some old Microsoft APIs throw pointers to exceptions, which the caller must then manually call delete() on. Most projects roll their own exception hierarchy. Sometimes they inherit from std::exception; other times not. Sometimes they throw other things. I heard from a friend that his team is writing new code that throws ints! Yes, new code, written in 2010, that throws ints.<br>
<p>
Some projects use char* almost everywhere, other projects use std::string. QT has its own string class, which is supposed to be better at internationalization, that a lot of projects use. Some projects use a mix of all of this stuff. Some projects roll their own string class.<br>
<p>
A lot of projects rolled their own smart pointer, or used one from boost, prior to the introduction of tr1::shared_ptr. Some of them work similarly, others not. Some projects barely use smart pointers; other projects use them almost everywhere.<br>
<p>
*Everyone* is using some kind of subset of C++. Everyone is bitterly convinced that they are right and everyone else is wrong. When someone advocates "using C++," a legitimate question is "which C++"? When you add a new person to your team, you can expect to spend quite a bit of time getting him or her up to speed.<br>
<p>
And of course, the different subsets of C++ don't interoperate that well at the library level. So when designing APIs, everyone just uses the lowest common denominator, which is C or something that looks almost exactly like it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Haiku</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 15:43 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/446070/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; *Everyone* is using some kind of subset of C++.</font><br>
<p>
Not true, and if they are, they're Doing It Wrong.<br>
<p>
Boost, for example, places no such restrictions on the project.  Instead, members use vigorous code review to ensure quality.  That is the right way to go because terrible interfaces get designed in every language every day.  Restricting the set of allowed language features doesn't solve that problem, it exacerbates it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446110"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Haiku</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 19:16 UTC (Fri)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/446110/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; *Everyone* is using some kind of subset of C++.</font><br>
&gt;<br>
<font class="QuotedText">&gt; Not true, and if they are, they're Doing It Wrong.</font><br>
<p>
Really? Let me ask you: when was the last time you wrote code that used throw specifications? Or the "export" keyword for templates? Or wide character streams (wchar)? Have you ever used protected inheritance?<br>
<p>
Wake up and smell the coffee. You're programming in a subset of C++. You are no doubt convinced that your subset is "modern" and "progressive", whereas everyone else's is "backwards" and "old-fashioned". But it's still a subset.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446110/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446116"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Haiku</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 21:09 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/446116/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This makes no sense.  If this is your criteria, everyone programs in a subset of their favorite language.  When's the last time you used gets()?<br>
<p>
The point is that the tools to use shouldn't be artificially restricted.  If someone wants to use protected inheritance, let them as long as they can show why it's necessary or beneficial.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446116/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446145"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Haiku</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2011 1:07 UTC (Sat)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/446145/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're mixing apples and oranges. gets() isn't a language feature, it's a library function.<br>
<p>
<font class="QuotedText">&gt; The point is that the tools to use shouldn't be artificially restricted. </font><br>
<font class="QuotedText">&gt; If someone wants to use protected inheritance, let them as long as they </font><br>
<font class="QuotedText">&gt; can show why it's necessary or beneficial.</font><br>
<p>
You didn't answer my question. When was the last time you used those features?<br>
<p>
You say that programmers shouldn't be "artificially restricted" from doing things that are "necessary and beneficial", but those are weasel words. The reality is, you'll just define necessary and beneficial as whatever you've been doing. So if you've been throwing exceptions as pointers, it's  obviously "necessary and beneficial" for the new code to do the same. If you haven't been using throw specs, obviously the new code shouldn't have them. But you're not using a subset of the language, oh no.<br>
<p>
As a side note, what's with the gets() obsession in these programming language debates. I don't think I was even alive the last time someone used gets() in a real program.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446145/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Haiku</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2011 1:11 UTC (Sat)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/446148/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a side note, I found this highly amusing:<br>
<a href="http://stackoverflow.com/questions/214321/what-c-features-do-you-avoid">http://stackoverflow.com/questions/214321/what-c-features...</a><br>
<p>
Literally every comment has a completely different view of which C++ features are "evil." I don't think you can find even two distinct answers that agree. I can only imagine what a novice programmer, fresh out of school, would think after reading this :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Haiku</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2011 5:52 UTC (Sat)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/446159/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It saddens me that it's become the norm to expect a "novice" who's had a full four years worth of a $100,000 education to have his first experience with real-world languages be a StackOverflow posting.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor446069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 15:40 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/446069/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're asking the wrong questions.<br>
<p>
Which parts of C++?  All of it!  But people have to develop smartly, as with any language.<br>
<p>
Specifying a language subset is a losing proposition because there will always be some feature outside of that subset that is the perfect fit for some need in the project.  Artificially restricting developers is the wrong way to go.  Code review, basic rules of thumb and other such things do a much better job of ensuring software quality.<br>
<p>
As to the inheritance model, I have heard this claim many times and never once has anyone explained their objections.  What is wrong with it?  C++ inherited it from Simula, so your claim that nothing else uses it is incorrect.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 18:29 UTC (Fri)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/446097/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You're asking the wrong questions.</font><br>
<p>
Enlighten us as to the right questions.<br>
<p>
<font class="QuotedText">&gt; Which parts of C++? All of it!</font><br>
<p>
On new projects, sure.  C++ (imo) can be quite elegant when you code in the modern style, and not all the legacy predecessors (I started before mature templates, before exceptions, before the Standard Library, etc., and many codebases are still stuck in that age since compilers took *forever* to mature).<br>
<p>
But that isn't what we are discussing.  As I said, unless you plan to rewrite Linux from scratch in C++, any proposal on the table is about using a restricted set of features in some parts of the kernel.<br>
<p>
<font class="QuotedText">&gt; C++ inherited it from Simula, so your claim that nothing else uses it is incorrect.</font><br>
<p>
My claim was that no one copied it from C++, so you're re-statement of what I said is wrong.  And which languages copied C++'s design in this respect?  What other language after C++ uses multiple inheritance, has virtual base classes, uses "protect" or equivalent, allows slicing, etc.?  I'm happy to be enlightened if there is a language out there that said "C++ inheritance is spot on, let's copy it".  Python, bizarrely enough, comes kinda close in some ways (to it's detriment).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446117"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 21:21 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/446117/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Enlighten us as to the right questions.</font><br>
<p>
Does this code or proposed design exhibit sound engineering given the project goals?<br>
<p>
<font class="QuotedText">&gt; As I said, unless you plan to rewrite Linux from scratch in C++, any </font><br>
<font class="QuotedText">&gt; proposal on the table is about using a restricted set of features in some </font><br>
<font class="QuotedText">&gt; parts of the kernel.</font><br>
<p>
Why?  There is nothing magical about the kernel.  It's software.  Even in a project transitioning from one implementation to another, there's no reason to artificial limit what people are allowed to do, especially _a_priori_.<br>
<p>
<font class="QuotedText">&gt; What other language after C++ uses multiple inheritance, has virtual </font><br>
<font class="QuotedText">&gt; base classes, uses "protect" or equivalent, allows slicing, etc.?</font><br>
<p>
Ah, good, some concrete points.<br>
<p>
Multiple inheritance is very useful.  If a language with inheritance doesn't have it, it has a major missing feature.<br>
<p>
Virtual base classes are trickier.  They are painful, I admit, but necessary for some uses of MI.  Many uses of MI don't need them at all.  C++'s possible mistake was to place the decision point at the intermediate class level rather than at the "final" class level.  But it's a convenience/efficiency tradeoff and I'm not totally sure the committee got it wrong..<br>
<p>
By "protect" I assume you mean "protected."  Protected methods certainly are useful.  Protected inheritance, not so much but I'm sure someone has a use case for it.<br>
<p>
Slicing is also a big pitfall.  But I think it's a natural consequence of call-by-value semantics.  One could argue that C++ should have made call-by-reference default but that would have broken C compatibility, a major strength of the language.<br>
<p>
<font class="QuotedText">&gt; I'm happy to be enlightened if there is a language out there that said </font><br>
<font class="QuotedText">&gt; "C++ inheritance is spot on, let's copy it".</font><br>
<p>
I don't think anyone has said that.  I have not said that.  To do so would be to say that the language is perfect, an impossibility in an imperfect world.<br>
<p>
There are valid criticisms of C++.  But to take that to an extreme and proclaim the C++ inheritance model "broken" or "wrong" is, well, wrong.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446117/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446132"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 22:26 UTC (Fri)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/446132/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Multiple inheritance is very useful. If a language with inheritance doesn't have it, it has a major missing feature.</font><br>
<p>
Sort of.  Multiple inheritance in the C++ sense is useful simply because C++ doesn't differentiate between base classes, interfaces, and mixins.  The need for multiple inheritance with multiple base classes is pretty small, and at least every example I've personally seen has been an example of bad interface design rather than a showcase for the need for MI (granted, my experience is not all-encompassing).<br>
<p>
<font class="QuotedText">&gt; Virtual base classes are trickier. They are painful, I admit, but necessary for some uses of MI. Many uses of MI don't need them at all. C++'s possible mistake was to place the decision point at the intermediate class level rather than at the "final" class level.</font><br>
<p>
I will argue that if you start having intermediate classes very often at all, or a diamond tree, you're using inheritance wrong.  Which most object-oriented developers do, unfortunately.  A large part of this I fear is that it's simply taught wrong in schools.  The classical examples of inheritance are things like Mammal-&gt;Dog, or Shape-&gt;Circle, or Vehicle-&gt;Car.  These are attempts at modelling real-world "is-a" relationships inside of algorithmic data structures, which is really really wrong.  It's a very long discussion to explain it in the necessary detail, and I believe Herb Sutter already did some fantastic talks on the topic (I'm having trouble Googling them though; maybe it wasn't Sutter that did them?).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446132/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446137"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 23:32 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/446137/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it's actually a strength that C++ doesn't differentiate among types of classes.  It allows more flexibility and reuse.  I agree with you that there should be a good case made before using MI.<br>
<p>
How would, for example, making "mixin" a special kind of class look in the place of MI?<br>
<p>
I'm not sure about "intermediate classes very often" part, but you certainly are correct about the diamond hierarchy.  A diamond with state in the virtual base is usually poor design and causes countless headaches in constructors.  A diamond without state in the virtual base (i.e. it's a pure interface) is sometimes useful.<br>
<p>
isa inheritance is usually good design.  hasa inheritance is usually bad design.  For the latter, composition is almost always the way to go.  If you can find examples where "isa" is the wrong thing to do, I am very interested.  Myself, I tend to prefer generic code and composition to inheritance but there are obvious cases where inheritance is useful and necessary.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446137/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2011 0:50 UTC (Sat)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/446141/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; How would, for example, making "mixin" a special kind of class look in the place of MI?</font><br>
<p>
The closest you get to what most people would consider a mixin in C++ would be the CRTP, but it's a little gimped because you can't properly specify that the "mixin" is implementing methods in an interface that the class inherits from.<br>
<p>
e.g., if you have class Foo that implements interface IDoStuff, a mixin SimpleDoStuff might include members and methods that implement some or all of the methods of IDoStuff.  There's no direct way to do that in C++, though, and so you end up with either grotesque inheritance trees or diamond inheritance.<br>
<p>
The only way to handle common partial implementations of interfaces in C++ is to create intermediate classes, which then results in you having a ton of intermediate classes, and you start wanting to mix different sets of then, and then you end up with either (a) an uber base object replacing the interface, making all your object bloated and over-complex, (b) a metric crapload of intermediary classes with tons of code duplication, or (c) diamond hierarchies and virtual bases and all the problems those impose.<br>
<p>
<font class="QuotedText">&gt; isa inheritance is usually good design. hasa inheritance is usually bad design. For the latter, composition is almost always the way to go. If you can find examples where "isa" is the wrong thing to do, I am very interested. Myself, I tend to prefer generic code and composition to inheritance but there are obvious cases where inheritance is useful and necessary.</font><br>
<p>
We perhaps are using slightly different definitions of "is-a", as I wasn't including interface derivation in that statement.  Composition is the opposite of what I consider is-a.  Yay for ambiguity in computer terminology.  :)<br>
<p>
(On a related note, composition is super important.  Not understanding composition is the other thing that leads to massive inheritance trees and horribly screwed up architectures.  Composition isn't necessarily trivial in C++ due to a lack of language/syntax support, but it's still possible to do and do well, unlike mixins which are borderline imposssible.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor446130"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 22:56 UTC (Fri)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/446130/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Does this code or proposed design exhibit sound engineering given the project goals?</font><br>
<p>
That is only the right question to ask in that it must always be asked, and is contentless.  Clearly a good designer will start by saying, "What is a good, sound design for this task?"  But knowing how to evaluate a design and implementation requires asking the kind of concrete questions that you claimed were not the right ones.<br>
<p>
<p>
<font class="QuotedText">&gt; Even in a project transitioning from one implementation to another, there's no reason to artificial limit what people are allowed to do, especially _a_priori_.</font><br>
<p>
You started this whole thread by claiming "One does not have to use every feature of a language to get good productivity out of the language.", which implied a conservative approach to feature adoption.  Now you are claiming that if Linux allowed for C++ development, that all features should be available for use without restriction.  Change of heart?<br>
<p>
<p>
<font class="QuotedText">&gt; Ah, good, some concrete points.</font><br>
<p>
You phrase that as though I haven't already been making concrete points.  I disagree, and I think I've been more concrete in my points than you have.  I find Linus's arguments about using C++ for kernel coding to be largely correct (for the Linux kernel), and your defense of your assertion that he is "dead wrong" to be unconvincing.<br>
<p>
<p>
<font class="QuotedText">&gt; But to take that to an extreme and proclaim the C++ inheritance model "broken" or "wrong"</font><br>
<p>
Those quoted proclamations you are apparently attributing to me are also incorrect, btw.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446130/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446138"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 23:43 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/446138/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But knowing how to evaluate a design and implementation requires asking </font><br>
<font class="QuotedText">&gt; the kind of concrete questions that you claimed were not the right ones.</font><br>
<p>
Your overarching question was, "what parts of C++?"  All of your other questions were about dealing with consequences of using a subset, save the one about overloading and that one is equivalent to, "how do we make sure we don't introduce bugs?"<br>
<p>
This is how I look at things.  Given a tool, use it.  Everyone on the project should evaluate how that tool is being used.  If we start with a tool, reduce its functionality by saying we can't do this or that with it, it doesn't eliminate the need to evaluate how we're using it, but it does eliminate the some possibilities of using it better when we find certain cases of poor usage.<br>
<p>
<font class="QuotedText">&gt; You started this whole thread by claiming "One does not have to use </font><br>
<font class="QuotedText">&gt; every feature of a language to get good productivity out of the </font><br>
<font class="QuotedText">&gt; language.", which implied a conservative approach to feature adoption. </font><br>
<font class="QuotedText">&gt; Now you are claiming that if Linux allowed for C++ development, that all </font><br>
<font class="QuotedText">&gt; features should be available for use without restriction. Change of </font><br>
<font class="QuotedText">&gt; heart?</font><br>
<p>
Not at all.  The two statements are entirely consistent.  All the tools should be available and we should make sure we use them correctly.  Of course a project in transition isn't going to use every language feature immediately, simply because not all of the code will transition immediately.  That does not mean that this or that language feature should be off-limits when transitioning any particular piece of code.<br>
<p>
<font class="QuotedText">&gt; You phrase that as though I haven't already been making concrete points.</font><br>
<p>
Forums are a poor way to convey expression.  Believe me, no disrespect was intended.  I was genuinely happy to see examples as I have been asking for them in various places for a long time.<br>
<p>
<font class="QuotedText">&gt; Those quoted proclamations you are apparently attributing to me are also </font><br>
<font class="QuotedText">&gt; incorrect, btw.</font><br>
<p>
Perhaps I misunderstood the intent of your statement:<br>
<p>
  Btw, the inheritance model that you tout as a feature (for "simple <br>
  uses") is arguably one of C++'s *worst* additions to the C language<br>
<p>
If so, I apologize.  It reads to me like a condemnation of the entire C++ inheritance model.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446138/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446142"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2011 0:21 UTC (Sat)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/446142/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This is how I look at things. Given a tool, use it.</font><br>
<p>
I agree.  Projects that adopt a tool like C++, should be prepared to adopt all of it.  Those that don't want to adopt all of it, should seriously consider adopting none of it.  The ones that want to adopt a subset of C++ (ie. "We'll just use it as a 'better' C, or 'C with classes'") should be prepared for the burden of that, and are probably best suited to a fairly small team of developer's (ie. not Linux sized).  I think Linus was right to adopt none of it.<br>
<p>
<font class="QuotedText">&gt; The two statements are entirely consistent.</font><br>
<p>
The statements themselves are not inconsistent with each other, but I feel the argument you are making with them is not, imo.  But let's leave it.  I think it is impractical for a large active codebase with wide collaboration to transition from C only, to fully incorporating and embracing modern C++, without a rewrite essentially from scratch.  I'm not sure of any such examples in the open source world (though gcc was pointed out earlier as a related example), but perhaps I'm wrong.<br>
<p>
<font class="QuotedText">&gt; Perhaps I misunderstood the intent of your statement:</font><br>
<p>
I think you were just restating my intent in your own words, but using the quotes made it appear that I said those words.  I'd say 20+ years of C++ inheritance experience has shown it to be flawed: it's difficult for many to understand all the ramifications and options, carelessness leads to the fragile base class syndrome despite it's encapsulation features, people have devised the ugly "pimpl idiom" to deal with other compiler and encapsulation issues, it has multiple inheritance :), and so on and so on.  I think C++ has been a useful experiment, and hopefully something better will now come to prevalence that has learned from it's flaws (disregarding Java et al; I mean a language w/ pointers).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446142/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor446160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2011 7:14 UTC (Sat)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/446160/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      > There is nothing magical about the kernel. It's software.<p>

This got me thinking about something else.  There are about 5000 uses of kmalloc() in the linux kernel, but kmalloc() takes a flag argument.  So, to replace these uses with idiomatic C++ would require widespread use of placement new().<p>

However, using placement new requires care when deleting objects.  So, rather than just using delete, you have to both manually call the class destructor, and then operator delete() with the right arguments to invoke the proper delete function (I suppose the kernel C++ stdlib could kludge the delete operator so that it works for placement new; now you are writing non-conformant C++)<p><p>


ie.

<pre>
struct T *p = kmalloc(sizeof(struct T), GFP_KERNEL | GFP_DMA);
some_init_function(p);
kfree(p);
</pre>

becomes something like:

<pre>
T *p = new (GFP_KERNEL | GFP_DMA) T;
p->~T();
operator delete(p, GFP_KERNEL | GFP_DMA);  // Or whatever it takes to match the call signature
</pre>

This unorthodox usage is necessary because the kernel is not just like other software.  Not when it comes to things like memory allocation.  And what about a std::vector of struct *T?  How do you allocate those objects with the right memory flags?<p>

Perhaps there is an elegant solution to this, most likely by eschewing bare pointers in the kernel and always using some templated smart pointer class.  A fairly radical change for kernel development.  What are your thoughts on it?

      
          <div class="CommentReplyButton">
            <form action="/Articles/446160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446162"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2011 7:19 UTC (Sat)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/446162/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I feel your argument is a little weak.<br>
<p>
Video games are almost certainly "just another piece of software" and we deal with the exact same memory management types of issues.  Many game engines outright ban the use of new and delete because of the problems they cause, requiring instead that specialized factories and memory managers be used, especially on console titles and mobile games.  It's every last bit as complex of a set of interfaces as the kernel, if not more so.  And they're still just software, and they still mostly all use C++.  :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446162/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2011 7:36 UTC (Sat)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/446163/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Whereas the existing kmalloc/kfree idiom is quite straightforward.  So where is the gain?  If the most basic memory allocation features of the language have to be banned from use, it's hardly a sales point for adopting the language.  You use it *in spite* of these deficiencies, just as Linux does with C.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446216"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2011 19:32 UTC (Sun)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/446216/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C++ has problems.  The thing is, no other language is better.  Sure, C is clearer about memory allocation.  But it lacks critical things like templates.  Which also have problems, but without them it's literally impossible to write a sane container library, generic algorithm library, or even a simple sort that doesn't end up making logN function calls.  Dynamic languages or languages like C#/Java almost manage this, but either screw up safety or just totally screw up performance and memory usage in their generics implementation.<br>
<p>
And then there's user-defined value types.  Trying to do basic graphics work in any language other than C/C++ is a nightmare, because your vectors are referece types.  In games, I use vec3's and vec4's more often than I use int's and float's.  Now imagine if every number in your language of choice was a reference type.  That's what doing games (or just about any other interesting mathematical application) in every single popular language besides C/C++ is like.  C's failing here is the lack of operator overloading for user-defined types, which just makes doing simple expressions with vec's and such a total pain.  Even languages supposedly focused towards games or systems programming, like C#, utterly fail when it comes to user defined types.<br>
<p>
And then in the C/C++ realm, C++ actually solves the very memory management problems we started talking about through it's ability to let users define their own handle types.  Raw pointers in C++ present a lot of problems that also exist in C, but C lacks the ability to solve those problems at a language/API level like you can in C++.<br>
<p>
So yeah, C++ fails in many ways, and fails hard.  Every other language just fails even harder (for certain classes of application, that is).  D comes closest to being a viable replacement, but it's not better enough to justify breaking compatibility with all the excellent C++ libraries out there.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446216/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446303"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2011 19:17 UTC (Mon)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/446303/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In my opinion, video games are a great example of a place where you *should* use C++. Kernels and systems-level software are a great example of a place where you should *never* use C++.<br>
<p>
Why do I say this? Well, C++ was designed to increase the speed of development and allow you to mix high-level and low-level code easily. It is very good at doing those things. At the same time, a clever programmer can get reasonable performance out of C++ by spending a little time optimizing.<br>
<p>
When writing a video game, you don't care that much about long-term maintainability or safety. An exciting game that crashes a few times a month will sell many more copies than a boring game which is rock-solid. Stuff gets rewritten from scratch every few years to take advantage of the latest and greatest hardware. If things are not written in the absolute most efficient way, who cares? You just keep tweaking things until the game runs all right on the target hardware.<br>
<p>
Kernels are the opposite. There are still pieces of code in the Linux kernel that go back to the early 1990s. Maintainability and stability are much more important than features or speed of development. It's important to use a simple style, in a simple programming language, that many different contributors can understand and use. Efficiency is key-- we don't have extra cycles to burn on things like std::string or std::map. In some structures, people are reluctant to enlarge the structure even by 4 bytes for performance reasons.<br>
<p>
A lot of people claim that C++ is somehow safer than C. But this is ridiculous. C++ has all of the different flavors of undefined behavior that C does, plus many, many more. C++ has a lot of "generated code"-- default copy constructors, default destructors, and so on, that will burn you if you're not careful. Again, it's about speed of development, *not* safety.<br>
<p>
Claiming that C++ is faster than C, or even as fast, is equally ridiculous. Even the most basic operations in C++, like iostreams, are much slower than the C equivalents like printf. Maybe some kind of theoretical perfect programmer could write equally fast, or even faster, code in C++ than C. But in the real world, programmers will take shortcuts if they exist. Let me draw an analogy-- if your wife bakes a cheesecake for you every night, you're going to get fat. Yes, in theory you could not eat the cheesecake, but it's right there.<br>
<p>
So we're left with the real C++ advantage-- speed of development. I want to be fair here. C++ is good at doing what it does. But let's not get confused here-- it's not the right choice for a lot of projects. Use the right tool for the job.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446303/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2011 3:40 UTC (Tue)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/446372/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're making a few claims I have to disagree strongly with, but in few words as ive got to walk out the door in a few.  First, I don't think you are quite in tune with game development, at least not professional game development.  Stability and even security are quite important - nobody wants to be Fallout New Vegas.  Second, game engines are not rewritten that often.  All of the popular engines are well over a decade old, and the majority of the code has not changed in architecture at all.  Most crashes you see in games are actually video driver crashes, save a few particularly poorly engineered titles.<br>
<p>
C++ is very much a safer language.  You bring up hidden code and such as if that makes it unsafe, which is silly.  C++ doesnt just magically do things wrong behind your back anymore than C does.  Yes, a destructor runs "automatically" but never ever unexpectedly.  On the other hand, C requires programmers to cut-n-paste large swaths of boilerplate code, leading to a much higher bug count in general.<br>
<p>
Simple fact is that there are kernels written in C++ which work very very well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2011 6:13 UTC (Tue)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/446380/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; First, I don't think you are quite in tune with game development, at least </font><br>
<font class="QuotedText">&gt; not professional game development. Stability and even security are quite </font><br>
<font class="QuotedText">&gt; important - nobody wants to be Fallout New Vegas</font><br>
<p>
Look, I'm not trying to trash game development or game developers. I know you guys have a difficult and challenging job.<br>
<p>
But let's be realistic. If I'm the project manager and I have a choice of releasing with a crashing bug or two or releasing a game that is dull or outdated, I am going to release with the bugs. If I don't, I'm going to get fired. Nobody wants a game that looks like it should have come out last year.<br>
<p>
On the other hand, the economics are different for some other kinds of software.<br>
<p>
<font class="QuotedText">&gt; C++ is very much a safer language. You bring up hidden code and</font><br>
<font class="QuotedText">&gt; such as if that makes it unsafe, which is silly</font><br>
<p>
It's not silly at all. Every time I write class with any kind of non-trivial destructor, I have to remember to hide the copy constructor and assignment operator. If I fail to do this, a simple typo later in the program-- say typing use_foo(Foo f) instead of use_foo(Foo &amp;f)-- could bring the program to its knees.<br>
<p>
Or take conversion constructors or default parameters. Here's a true story of something that happened very recently. Someone on our project decided to change a function prototype from foo(int i) to foo(const MyObject &amp;o). What he didn't realize was that there was a conversion constructor from an int to a MyObject. So when he overlooked this little gem:<br>
<font class="QuotedText">&gt; foo(0)</font><br>
<p>
The compiler happily generated this:<br>
<font class="QuotedText">&gt; foo(MyObject(0))</font><br>
<p>
Needless to say, the results were not what he intended at all.<br>
<p>
Implicitly generated code hurts. Default constructors hurt. Default parameters hurt even more. You might disagree, but I've had a lot of time to come to this opinion.<br>
<p>
<font class="QuotedText">&gt; Simple fact is that there are kernels written in C++ which work very very </font><br>
<font class="QuotedText">&gt; well.</font><br>
<p>
Well, as I already mentioned, there is XNU, which has no templates, no RTTI, and no exceptions, but is "technically C++". Apparently the Windows NT kernel also has some kind of C++ support-- again, I think exceptions are left out, as well as who knows what else.<br>
<p>
I would say a bigger C++ success story is the success of the LLVM project. They managed to write a very capable compiler in C++, which has been gaining a lot of momentum. One of my friends who works on the project is also one of the few people who can stump me with a C++ question. I guess it's hard to out language-lawyer the language implementers!<br>
<p>
But oh, they don't use exceptions :) And the LLVM library is 20MB when compiled, whereas /usr/bin/gcc is 262kb.<br>
<p>
C++ has been the inspiration for a lot of other languages like Java and Golang, and I respect it for that. It got a lot of things right, and it's still the language that I know the best. But can't we have some new ideas after all these years?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2011 6:24 UTC (Tue)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/446385/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, there's cases where C++ bites you.  There are cases where C does this, too, and there are many ways in which C++ helps you.<br>
<p>
I doubt I'll convince you to change your opinion with anything short of a small novel, though.  :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor446399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2011 7:46 UTC (Tue)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/446399/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And the LLVM library is 20MB when compiled, whereas /usr/bin/gcc is 262kb</font><br>
<p>
Are you sure you're not looking at just the GCC driver that invokes the actual compiler?<br>
<p>
jezuch@zx-spectrum-1:~$ du -shc /usr/lib/gcc/x86_64-linux-gnu/4.6/{cc1,cc1plus,lto1}<br>
11M     /usr/lib/gcc/x86_64-linux-gnu/4.6/cc1<br>
12M     /usr/lib/gcc/x86_64-linux-gnu/4.6/cc1plus<br>
11M     /usr/lib/gcc/x86_64-linux-gnu/4.6/lto1<br>
33M     razem<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446505"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2011 18:54 UTC (Tue)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/446505/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I stand corrected. I thought that binary was way too small... but ldd didn't tell me anything useful.<br>
<p>
It's been a long time since I built gcc. Even back when I did embedded stuff, we always seemed to use prebuilt toolchains.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446505/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor446824"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2011 14:21 UTC (Thu)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/446824/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Implicitly generated code hurts. Default constructors hurt. Default parameters hurt even more. You might disagree, but I've had a lot of time to come to this opinion.</font><br>
<p>
Sorry but C++ poor mix of features doesn't mean that those features are always bad..<br>
Plus C's lack of initialisation also hurt a lot, no?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446824/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446872"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2011 16:56 UTC (Thu)
                               by <b>jd</b> (guest, #26381)
                              [<a href="/Articles/446872/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, no. Implicit code is (IMHO) always a Bad Thing because when the specs or compiler change, the resultant binaries will change behaviour when given the same source.<br>
<p>
The source is a specification document, to all practical intents and purposes, which the compiler uses to generate a program. If the program can change in nature for the same specification, the specification is incomplete and insufficient.<br>
<p>
In other words, by depending on something external (in this case, the compiler) you cannot do reliable testing. There are too many external parameters that you can never reliably take account of. Good engineering practice is to always work to reduce or eliminate the unknowables. If the compiler is any good, it'll ignore initializing to the compiler's defaults since the instructions generated by the compiler's default will already be present. If the compiler isn't any good, you really shouldn't be trusting it to be doing the Right Thing anyway.<br>
<p>
If you explicitly initialize, you always know the state of a variable, no matter what new C or C++ standard is produced. This is guaranteed safe.<br>
<p>
Compiler-tolerant software is necessarily well-engineered software. Yes, it's more work, but if you wanted to avoid work, you'd not be using C or C++, you'd be using a fourth- or fifth-generation language instead. The only reason to use anything in the C family is to be able to balance development efficiency with code efficiency. Higher levels of language offer better development efficiency, lower levels (Fortran, assembly, etc) offer better code efficiency. Neither is useful on its own for something like an OS kernel, which is why nobody writes general-purpose kernels on the scale of Linux in either Erlang or IA64 assembly.<br>
<p>
(Kernels do exist in both those, and indeed in Occam, but because of tradeoffs are almost always much more special-purpose.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446872/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor447234"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2011 0:20 UTC (Mon)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/447234/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Plus C's lack of initialisation also hurt a lot, no?</font><br>
<p>
I remember a thread here on LWN a while back where people were complaining about a performance regression in the kernel caused by zeroing struct page. So it seems that at least in some corner cases, not initializing memory is a feature. In a perfect world, non-initialization probably should be something that the programmer has to ask for specifically, rather than the default. But C was designed in the 1970s-- give it a break already.<br>
<p>
When C++ was designed, in the mid-1980s, the decision was made to keep all the old uninitialized variable behavior and add some more. So if you create a C++ class with some primitives, and forget to initialize them in one of the constructors, they'll be uninitialized. This also applies to copy constructors. The rationale was that programmers shouldn't have to pay for what they didn't use.<br>
<p>
Luckily there is some relief in sight, in the shape of Coverity and similar static analysis tools. These can catch most uninitialized variables.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/447234/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor445626"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">When in doubt, add another layer of indirection</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 21:25 UTC (Wed)
                               by <b>sethml</b> (guest, #8471)
                              [<a href="/Articles/445626/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      Curious question from a non-kernel-hacker: it seems like the kernel could save a lot of memory (particularly on 64-bit systems) by replacing vtable pointers by smaller array indices.  For example, every inode in the system contains an <tt>inode_operations</tt> pointer, occupying 64 bits:

<pre>
struct inode {
        /* RCU path lookup touches following: */
        umode_t                 i_mode;
        uid_t                   i_uid;
        gid_t                   i_gid;
        const struct inode_operations   *i_op;
        struct super_block      *i_sb;
        ...
}

... foo->i_op->bar(...);
</pre>

It'd be possible to save 52 bits per inode, which could add up if you have a lot of inodes in memory:

<pre>
struct inode {
        ...
        uint16_t i_op_idx;
        ...
}

struct inode_operations inode_ops[MAX_INODE_OPS];

... inode_ops[foo->i_op_idx].bar(...);
</pre>

The same technique could be used for a lot of structure members which aren't vtable pointers - for example, <tt>i_sb</tt> seems like a potential candidate.

Disadvantages: need to set an upper limit on the number of inode_operations structures, a bit slower (extra indirection), complicates the code.  Given appropriate infrastructure, the code complication could be centralized in some helper functions/macros.

Thoughts?  Could this be worthwhile?  Are the potential memory gains too minimal to care about?
      
          <div class="CommentReplyButton">
            <form action="/Articles/445626/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445719"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">When in doubt, add another layer of indirection</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2011 23:37 UTC (Wed)
                               by <b>darthscsi</b> (guest, #8111)
                              [<a href="/Articles/445719/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Doing this without language level support for appending arrays gets really ugly.  That said, the kernel plays linker script magic other places to create appending arrays.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445719/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor445755"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">When in doubt, add another layer of indirection</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 8:33 UTC (Thu)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/445755/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In order to make it work with modules you'd need to generate the idx at runtime, which would actually solve both problems...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445755/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor445997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">When in doubt, add another layer of indirection</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 7:57 UTC (Fri)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/445997/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Most of the time, only one copy of those structures exists, so saving a few bits doesn't seem worth the extra complexity and the extra indirection.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">When in doubt, add another layer of indirection</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2011 7:44 UTC (Thu)
                               by <b>kevinm</b> (guest, #69913)
                              [<a href="/Articles/446773/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The savings are per inode, not per inode_ops.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor446004"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">When in doubt, add another layer of indirection</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 9:04 UTC (Fri)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/446004/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But the 52 saved bits might be spent again in extra instructions to calculate the pointer from the extra offset that you then would have.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446004/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446036"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">When in doubt, add another layer of indirection</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 12:15 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/446036/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
but if you have thousands or millions of these in memory the space savings may add up<br>
<p>
also, since the cpu runs so much faster than memory does, you can actually do quite a lot of processing in the time saved by avoiding a memory fetch.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446036/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor446772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">When in doubt, add another layer of indirection</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2011 7:43 UTC (Thu)
                               by <b>kevinm</b> (guest, #69913)
                              [<a href="/Articles/446772/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This seems like a reasonable idea, although the hit to readability and simplicity is such that you'd only want to do it in places where it would make a real memory difference.<br>
<p>
Why not try it and see?<br>
<p>
(By the way, it'd be 48 bits that you'd save replacing a 64 bit pointer with a 16 bit index).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor445723"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 0:13 UTC (Thu)
                               by <b>linusw</b> (subscriber, #40300)
                              [<a href="/Articles/445723/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fun that my two regulator commits are used as vtable illustration, I vaguely knew the term vtable before, now I know I'm doing such.<br>
<p>
I'm anticipating the follow-on articles to elaborate on how the outspaced macro container_of() performs the analog mechanism to super() from OOP...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445723/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 9:07 UTC (Fri)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/446005/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
container_of is e.g. used for linked lists, where it merely gives the surrounding actual object to the linked list head, in other words, it is used like (Java)"class mydevice implements list_head" rather than "extends list_head", so it would not be quite like "super" :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2011 13:25 UTC (Fri)
                               by <b>linusw</b> (subscriber, #40300)
                              [<a href="/Articles/446042/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, extends or super or whatever. The point is that it is in the object orient.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor446224"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2011 3:56 UTC (Mon)
                               by <b>jmm82</b> (guest, #59425)
                              [<a href="/Articles/446224/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is also used in many kernel subsystems when the base struct will have a pointer to a private struct where the driver can hold variables Specific to that driver.  The base struct is like a super in this case and if all you have is a pointer to the private struct you can use container_of() to get the base struct.<br>
<p>
Also, container_of is used with the kref code when deleting the struct which has embedded a kref for refence counting.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/446224/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor445732"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Object-oriented design patterns in the kernel, part 1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2011 2:19 UTC (Thu)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/445732/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This was an interesting article. I was always curious about the use of NULL in kernel vtable structures.<br>
<p>
The idea of associating multiple vtables with a single object-- to collect related functionality-- reminds me of Google Go's structural subtyping. Why force all the class methods to be in one .h or .java file? We should be able to group the methods in whatever way makes the most sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/445732/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor446204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ah, Google Go</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2011 11:23 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/446204/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Well, the Google Go structural subtyping is crippled and limited version of <a href="http://en.wikipedia.org/wiki/Common_Lisp_Object_System">ages old</a> idiom.</p>

<p>Of course it does not mean Google Go is bad language: it's version is simpler and less flexible - but as consequence it's less dangerous too. But still... it's funny how people are becoming excited when fashionable language presets something from languge veteran they forever disliked for some reason.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/446204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor447756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ah, Google Go</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2011 0:15 UTC (Thu)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/447756/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There have been a lot of dynamically typed languages in recent years that have implemented what's called "duck typing." Python and Ruby come to mind, but I'm sure there are others. What is different about Google Go is that it is statically typed. Common Lisp is dynamically typed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/447756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
