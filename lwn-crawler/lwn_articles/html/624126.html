        <!DOCTYPE html>
        <html lang="en">
        <head><title>ACCESS_ONCE() and compiler bugs [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/624126/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/622145/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/624126/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>ACCESS_ONCE() and compiler bugs</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>December 3, 2014</br>
           </div>
The <tt>ACCESS_ONCE()</tt> macro is used throughout the kernel to ensure
that code generated by the compiler will access the indicated variable once
(and only 
once); see <a href="/Articles/508991/">this article</a> for details on how
it works and when its use is necessary.  When that article was written
(2012), there were 200 invocations of <tt>ACCESS_ONCE()</tt> in the kernel;
now there are over 700 of them.  Like many low-level techniques for
concurrency management, <tt>ACCESS_ONCE()</tt> relies on trickery that is
best hidden from view.  And, like such techniques, it may break if the
compiler changes behavior or, as has been seen recently, contains a bug.
<p>
Back in November, Christian Borntraeger <a href="/Articles/624144/">posted
a message</a> regarding the interactions between <tt>ACCESS_ONCE()</tt> and
an obscure GCC bug.  To understand the problem, it is worth looking at 
the macro, which is defined simply in current kernels (in
<tt>&lt;linux/compiler.h&gt;</tt>): 
<p>
<pre>
    #define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))
</pre>
<p>
In short, <tt>ACCESS_ONCE()</tt> forces the variable to be treated as being
a <tt>volatile</tt> type, even though it (like almost all variables in the
kernel) is not declared that way.  The problem reported by Christian is
that GCC 4.6 and 4.7 will drop the <tt>volatile</tt> modifier if the
variable passed into it is not of a scalar type.  It works fine if
<tt>x</tt> is an <tt>int</tt>, for example, but not if <tt>x</tt> has a
more complicated type.

For example, <tt>ACCESS_ONCE()</tt> is often used with page table entries,
which are defined as having the <tt>pte_t</tt> type:
<p>
<pre>
    typedef struct {
	unsigned long pte;
    } pte_t;
</pre>
<p>
In this case, the <tt>volatile</tt> semantics will be lost in buggy
compilers, leading to buggy kernels.  Christian started by looking for ways
to work around the problem, only to be informed that normal kernel practice
is to avoid working around compiler bugs whenever possible; instead, the buggy
versions should simply be blacklisted in the kernel build system.  But 4.6
and 4.7 are installed on a lot of systems; blacklisting them would
inconvenience many users.  And, as Linus <a href="/Articles/624148/">put
it</a>, there can be reasons for approaches other than blacklisting:
<p>
<div class="BigQuote">
	So I do agree with Heiko that we generally don't want to work
	around compiler bugs if we can avoid it. But sometimes the compiler
	bugs do end up saying "you're doing something very fragile". Maybe
	we should try to be less fragile here.
</div>
<p>
One way of being less fragile would be to change the affected
<tt>ACCESS_ONCE()</tt> calls to point to the scalar parts of the relevant
non-scalar types.  So, if code does something like:
<p>
<pre>
    pte_t p = ACCESS_ONCE(pte);
</pre>
<p>
It could be changed to something like:
<p>
<pre>
    unsigned long p = ACCESS_ONCE(pte-&gt;pte);
</pre>
<p>
This type of change requires auditing all <tt>ACCESS_ONCE()</tt> calls,
though, to find the ones using non-scalar types; that would be a lengthy
and error-prone process that would not prevent the addition of new bugs in
the future.  
<p>
Another approach to the problem explored by Christian was to remove a
number of problematic <tt>ACCESS_ONCE()</tt> calls and just put in a
compiler barrier with <tt>barrier()</tt> instead.  In many cases, a barrier
is sufficient, but in others it is not.  Once again, a detailed audit is
required, and there is nothing preventing new code from adding buggy
<tt>ACCESS_ONCE()</tt> calls.
<p>
So Christian headed down the path of changing <tt>ACCESS_ONCE()</tt> to
simply disallow the use of non-scalar types altogether.  In <a
href="/Articles/623046/">the most recent version of the patch set</a>,
<tt>ACCESS_ONCE()</tt> looks like this:
<p>
<pre>
    #define __ACCESS_ONCE(x) ({ \
	       __maybe_unused typeof(x) __var = 0; \
	       (volatile typeof(x) *)&amp;(x); })
    #define ACCESS_ONCE(x) (*__ACCESS_ONCE(x))
</pre>
<p>
This version will cause compilation failures if a non-scalar type is passed
into the macro.  But what about the situations where a non-scalar type
needs to be used?  For these cases, Christian has introduced two new
macros, <tt>READ_ONCE()</tt> and <tt>ASSIGN_ONCE()</tt>.  The definition of
the former looks like this:
<p>
<pre>
    static __always_inline void __read_once_size(volatile void *p, void *res, int size)
    {
    	switch (size) {
    	case 1: *(u8 *)res = *(volatile u8 *)p; break;
    	case 2: *(u16 *)res = *(volatile u16 *)p; break;
    	case 4: *(u32 *)res = *(volatile u32 *)p; break;
    #ifdef CONFIG_64BIT
    	case 8: *(u64 *)res = *(volatile u64 *)p; break;
    #endif
        }
    }
    
    #define READ_ONCE(p) \
          ({ typeof(p) __val; __read_once_size(&amp;p, &amp;__val, sizeof(__val)); __val; })
</pre>
<p>

Essentially, it works by forcing the use of scalar types, even if the
variable passed in does not have such a type.  Providing a single access macro
that worked on both the left-hand and right-hand sides of an assignment
turned out to not be trivial, so the separate <tt>ASSIGN_ONCE()</tt> was
provided for the left-hand side case.  
<p>
Christian's patch set replaces <tt>ACCESS_ONCE()</tt> calls with
<tt>READ_ONCE()</tt> or <tt>ASSIGN_ONCE()</tt> in cases where the latter
are needed.  Comments in the code suggest that those macros should be
preferred to <tt>ACCESS_ONCE()</tt> in the future, but most existing
<tt>ACCESS_ONCE()</tt> calls have not been changed.  Developers using
<tt>ACCESS_ONCE()</tt> to access non-scalar types in the future will get an
unpleasant surprise from the compiler, though.
<p>
This version of the patch has received few comments and seems likely to
make it into the mainline in the near future; backports to the stable
series are also probably on the agenda.  There are times when it is best to
simply avoid versions of the compiler with known bugs altogether.  But, as
can be seen here, compiler bugs can also be seen as a signal that things
could be done better in the kernel, leading to more robust code overall.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#ACCESS_ONCE">ACCESS_ONCE()</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/624126/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor624461"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Strict aliasing violation?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 10:03 UTC (Thu)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/624461/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure I really understand C's aliasing rules, but isn't this a strict aliasing violation?<br>
<p>
<font class="QuotedText">&gt; *(u32 *)res = *(volatile u32 *)p;</font><br>
<p>
Unless "p" points to an int or unsigned int, or on 32-bit long or unsigned long, I believe the compiler is allowed to think "it's not the same variable", and reorder the accesses or even delete your code.<br>
<p>
As a degenerate example, if you have<br>
<p>
struct two_shorts { u16 s[2] };<br>
struct two_shorts left, right;<br>
int global;<br>
<p>
void bozo(void)<br>
{<br>
        global = 1;<br>
        *(u32 *)&amp;left = *(volatile u32 *)&amp;right;<br>
}<br>
<p>
If my understanding is correct, the compiler is free to assume that, since accessing an u16 as an u32 is not possible due to the strict aliasing rules, that line can never be reached (because it's undefined code), and so the function could be optimized to:<br>
<p>
void bozo(void)<br>
{<br>
}<br>
<p>
What's wrong with my analysis here?<br>
<p>
(If my analysis is correct, my workaround would be to sprinkle a few OPTIMIZER_HIDE_VAR, because OPTIMIZER_HIDE_VAR is my hammer, and this problem looks like a nail.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624461/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor624472"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Strict aliasing violation?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 11:01 UTC (Thu)
                               by <b>cborni</b> (subscriber, #12949)
                              [<a href="/Articles/624472/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The kernel is always build with strict-aliasing disabled (fno-strict-aliasing)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624472/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor624735"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Strict aliasing violation?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2014 7:40 UTC (Fri)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/624735/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Strict aliasing refers to accessing the same area of memory via pointers of two different types. So if you assign you an int pointer and to a short pointer, the compiler is allowed to assume the pointers are distinct and hence reorder the assignments. char and void pointers are considered to alias with any other pointer. Example:<br>
<p>
void foo(int *a, short *b) {<br>
    *a = 1;<br>
    *b = 2;<br>
}<br>
<p>
Strict aliasing means the compiler is allowed to reorder those two writes since they clearly can't be the same pointer. If one of the two were a char or void pointer then the compiler cannot assume this.<br>
<p>
Where this usually trips people up is when people try to optimise structure copying by casting the pointer to an int* and looping. Since the compiler sees an int* and a struct* it assumes the pointers are distinct and chaos occasionally ensues.<br>
<p>
So your program is fine, because type casts are legal. But if you're doing tricky pointer arithmetic with non-char/void pointers you need to be careful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624735/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor624501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 13:39 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/624501/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's surprising that there isn't something equivalent to ACCESS_ONCE in the latest C standard.  Have the standards committee considered it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor624532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 15:30 UTC (Thu)
                               by <b>sorokin</b> (guest, #88478)
                              [<a href="/Articles/624532/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Have the standards committee considered it?</font><br>
<p>
Both C and C++ standards already has mechanism for that. You just need to mark your data as volatile or atomic, depending on your use case.<br>
<p>
I don't understand why in Linux kernel there is a need in using ACCESS_ONCE instead of marking corresponding variable as volatile or atomic.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor624543"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 15:47 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/624543/">Link</a>] 
      </p>
      
      </div>
      </summary>
      See <a rel="nofollow" href="/Articles/233479/">The trouble with volatile</a> from 2007.  
      
          <div class="CommentReplyButton">
            <form action="/Articles/624543/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor624669"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 21:51 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/624669/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is.  It's atomic_load and atomic_store with relaxed memory ordering.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624669/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor624744"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2014 8:47 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/624744/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So... obvious follow-up question... what is the reason why the Linux code doesn't use these primitives instead of casting to and from volatile?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624744/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor624745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2014 8:58 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/624745/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Because the Linux kernel has needed these way before they were standardized. The primitives are also new and many details would have to be hashed out before Linux could use them.  See this LWN article: <a href="http://lwn.net/Articles/586838/">http://lwn.net/Articles/586838/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor624670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 21:56 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/624670/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      I wonder if ACCESS_ONCE could be defined as

<pre>
#define ACCESS_ONCE(x)                                             \
   __builtin_choose_expr(sizeof(x) == 1, *(volatile u8 *)&amp;x,       \
        __builtin_choose_expr(sizeof(x) == 2, *(volatile u16 *)&amp;x, \
        __builtin_choose_expr(sizeof(x) == 4, *(volatile u32 *)&amp;x, \
        __builtin_choose_expr(sizeof(x) == 8, *(volatile u64 *)&amp;x, \
        (void)0))))
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/624670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor624698"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 23:27 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/624698/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not put an error in the tail-end case?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624698/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor624700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 23:30 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/624700/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A void expression will give an error if used as either lvalue or rvalue.<br>
<p>
ut I found the gotcha after posting: my definition is not type safe when used with non-scalar types, unlike the old ACCESS_ONCE.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor624703"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2014 23:44 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/624703/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, right. For some reason I read it as "(void*)0"â€¦which is also an error for non-pointer types.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/624703/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor624931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ACCESS_ONCE() and compiler bugs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2014 19:31 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/624931/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
<blockquote>
Maybe we should try to be less fragile here. 
</blockquote>
One way of being less fragile
</blockquote>
<p>
I don't see these approaches as making the kernel less fragile.  This is just a workaround for a particular compiler bug.  A bug that matters because the kernel is fragile, perhaps.
<p>
If you have a glass bicycle, you make it less fragile by replacing the frame with a steel one, not by riding around a bump in the road.

      
          <div class="CommentReplyButton">
            <form action="/Articles/624931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
