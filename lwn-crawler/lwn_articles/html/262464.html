        <!DOCTYPE html>
        <html lang="en">
        <head><title>What is RCU, Fundamentally? [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/262464/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/262091/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/262464/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>What is RCU, Fundamentally?</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="GAByline">
           <p>December 17, 2007</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
[<i>Editor's note: this is the first in a three-part series on how the
read-copy-update mechanism works.  Many thanks to Paul McKenney and
Jonathan Walpole for allowing us to publish these articles.  The remaining
two sections will appear in future weeks.</i>]
<p>
<P>Part 1 of 3 of <b>What is RCU, Really?</b>

<p><I>Paul E. McKenney, IBM Linux Technology Center</I>
<br><I>Jonathan Walpole, Portland State University Department of Computer
Science</I> 

</p><H3>Introduction</H3>

<P>Read-copy update (RCU) is a synchronization mechanism that was added to
the Linux kernel in October of 2002.
RCU achieves scalability
improvements by allowing reads to occur concurrently with updates.
In contrast with conventional locking primitives that ensure mutual exclusion
among concurrent threads regardless of whether they be readers or
updaters, or with reader-writer locks that allow concurrent reads but not in
the presence of updates, RCU supports concurrency between a single
updater and multiple readers.
RCU ensures that reads are coherent by
maintaining multiple versions of objects and ensuring that they are not
freed up until all pre-existing read-side critical sections complete.
RCU defines and uses efficient and scalable mechanisms for publishing
and reading new versions of an object, and also for deferring the collection
of old versions.
These mechanisms distribute the work among read and
update paths in such a way as to make read paths extremely fast. In some
cases (non-preemptable kernels), RCU's read-side primitives have zero
overhead.

<P><A NAME="Quick Quiz 1"><B>Quick Quiz 1</B>:</A>
But doesn't seqlock also permit readers and updaters to get work done
concurrently?

<P>This leads to the question "what exactly is RCU?", and perhaps also
to the question "how can RCU <I>possibly</I> work?" (or, not
infrequently, the assertion that RCU cannot possibly work).
This document addresses these questions from a fundamental viewpoint;
later installments look at them from usage and from API viewpoints.
This last installment also includes a list of references.

<P>RCU is made up of three fundamental mechanisms, the first being
used for insertion, the second being used for deletion, and the third
being used to allow readers to tolerate concurrent insertions and deletions.
These mechanisms are described in the following sections, which focus
on applying RCU to linked lists:

<OL>
<LI>	<A HREF="#Publish-Subscribe Mechanism">
	Publish-Subscribe Mechanism</A> (for insertion)
<LI>	<A HREF="#Wait For Pre-Existing RCU Readers to Complete">
	Wait For Pre-Existing RCU Readers to Complete</A> (for deletion)
<LI>	<A HREF="#Maintain Multiple Versions of Recently Updated Objects">
	Maintain Multiple Versions of Recently Updated Objects</A>
	(for readers)
</OL>

<P>These sections are followed by
<A HREF="#Conclusion">concluding remarks</A> and the
<A HREF="#Answers to Quick Quizzes">answers to the Quick Quizzes</A>.

</p><H3><A NAME="Publish-Subscribe Mechanism">
Publish-Subscribe Mechanism</A></H3>

<P>One key attribute of RCU is the ability to safely scan data, even
though that data is being modified concurrently.
To provide this ability for concurrent insertion,
RCU uses what can be thought of as a publish-subscribe mechanism.
For example, consider an initially <code>NULL</code> global pointer
<code>gp</code> that is to be modified to point to a newly allocated
and initialized data structure.
The following code fragment (with the addition of appropriate locking)
might be used for this purpose:

<PRE>
  1 struct foo {
  2   int a;
  3   int b;
  4   int c;
  5 };
  6 struct foo *gp = NULL;
  7 
  8 /* . . . */
  9 
 10 p = kmalloc(sizeof(*p), GFP_KERNEL);
 11 p-&gt;a = 1;
 12 p-&gt;b = 2;
 13 p-&gt;c = 3;
 14 gp = p;
</PRE>

<P>Unfortunately, there is nothing forcing the compiler and CPU to execute
the last four assignment statements in order.
If the assignment to <code>gp</code> happens before the initialization
of <code>p</code>'s fields, then concurrent readers could see the
uninitialized values.
Memory barriers are required to keep things ordered, but memory barriers
are notoriously difficult to use.
We therefore encapsulate them into a primitive
<code>rcu_assign_pointer()</code> that has publication semantics.
The last four lines would then be as follows:

<PRE>
  1 p-&gt;a = 1;
  2 p-&gt;b = 2;
  3 p-&gt;c = 3;
  4 rcu_assign_pointer(gp, p);
</PRE>

<P>The <code>rcu_assign_pointer()</code>
would <i>publish</i> the new structure, forcing both the compiler
and the CPU to execute the assignment to <code>gp</code> <i>after</i>
the assignments to the fields referenced by <code>p</code>.

<P>However, it is not sufficient to only enforce ordering at the
updater, as the reader must enforce proper ordering as well.
Consider for example the following code fragment:

<PRE>
  1 p = gp;
  2 if (p != NULL) {
  3   do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);
  4 }
</PRE>

<P>Although this code fragment might well seem immune to misordering,
unfortunately, the
<A
HREF="http://www.rdrop.com/users/paulmck/scalability/paper/ordering.2007.09.19a.pdf">DEC
Alpha CPU [PDF]</A>
and value-speculation compiler optimizations can, believe it or not,
cause the values of <code>p-&gt;a</code>, <code>p-&gt;b</code>, and
<code>p-&gt;c</code> to be fetched before the value of <code>p</code>!
This is perhaps easiest to see in the case of value-speculation
compiler optimizations, where the compiler guesses the value
of <code>p</code>, fetches <code>p-&gt;a</code>, <code>p-&gt;b</code>, and
<code>p-&gt;c</code>, then fetches the actual value of <code>p</code>
in order to check whether its guess was correct.
This sort of optimization is quite aggressive, perhaps insanely so,
but does actually occur in the context of profile-driven optimization.

<P>Clearly, we need to prevent this sort of skullduggery on the
part of both the compiler and the CPU.
The <code>rcu_dereference()</code> primitive uses
whatever memory-barrier instructions and compiler
directives are required for this purpose:

<PRE>
  1 rcu_read_lock();
  2 p = rcu_dereference(gp);
  3 if (p != NULL) {
  4   do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);
  5 }
  6 rcu_read_unlock();
</PRE>

<P>The <code>rcu_dereference()</code> primitive can thus be thought of
as <i>subscribing</i> to a given value of the specified pointer,
guaranteeing that subsequent dereference operations will see any
initialization that occurred before the corresponding publish
(<code>rcu_assign_pointer()</code>) operation.
The <code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code>
calls are absolutely required: they define the extent of the
RCU read-side critical section.
Their purpose is explained in the
<A HREF="#Wait For Pre-Existing RCU Readers to Complete">next section</A>,
however, they never spin or block, nor do they prevent the
<code>list_add_rcu()</code> from executing concurrently.
In fact, in non-<code>CONFIG_PREEMPT</code> kernels, they generate
absolutely no code.  

<P>Although <code>rcu_assign_pointer()</code> and
<code>rcu_dereference()</code> can in theory be used to construct any
conceivable RCU-protected data structure, in practice it is often better
to use higher-level constructs.
Therefore, the <code>rcu_assign_pointer()</code> and
<code>rcu_dereference()</code>
primitives have been embedded in special RCU variants of Linux's
list-manipulation API.
Linux has two variants of doubly linked list, the circular
<code>struct list_head</code> and the linear
<code>struct hlist_head</code>/<code>struct hlist_node</code> pair.
The former is laid out as follows, where the green boxes represent
the list header and the blue boxes represent the elements in the
list.

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/Linux_list.jpg" ALT="Linux list" width=503 height=103>
</blockquote>
<P>Adapting the pointer-publish example for the linked list gives
the following:

<PRE>
  1 struct foo {
  2   struct list_head list;
  3   int a;
  4   int b;
  5   int c;
  6 };
  7 LIST_HEAD(head);
  8 
  9 /* . . . */
 10 
 11 p = kmalloc(sizeof(*p), GFP_KERNEL);
 12 p-&gt;a = 1;
 13 p-&gt;b = 2;
 14 p-&gt;c = 3;
 15 list_add_rcu(&amp;p-&gt;list, &amp;head);
</PRE>

<p>Line&nbsp;15 must be protected by some synchronization mechanism (most
commonly some sort of lock) to prevent multiple <code>list_add()</code>
instances from executing concurrently.
However, such synchronization does not prevent this <code>list_add()</code>
from executing concurrently with RCU readers.

<P>Subscribing to an RCU-protected list is straightforward:

<PRE>
  1 rcu_read_lock();
  2 list_for_each_entry_rcu(p, head, list) {
  3   do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);
  4 }
  5 rcu_read_unlock();
</PRE>

<P>The <code>list_add_rcu()</code> primitive publishes
an entry into the specified list, guaranteeing that the corresponding
<code>list_for_each_entry_rcu()</code> invocation will properly
subscribe to this same entry.

<P><A NAME="Quick Quiz 2"><B>Quick Quiz 2</B>:</A>
What prevents the <code>list_for_each_entry_rcu()</code> from
getting a segfault if it happens to execute at exactly the same
time as the <code>list_add_rcu()</code>?

<P>Linux's other doubly linked list, the hlist,
is a linear list, which means that
it needs only one pointer for the header rather than the two
required for the circular list.
Thus, use of hlist can halve the memory consumption for the hash-bucket
arrays of large hash tables.

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/Linux_hlist.jpg" ALT="Linux hlist"
width=423 height=63>
</blockquote>

<P>Publishing a new element to an RCU-protected hlist is quite similar
to doing so for the circular list:

<PRE>
  1 struct foo {
  2   struct hlist_node *list;
  3   int a;
  4   int b;
  5   int c;
  6 };
  7 HLIST_HEAD(head);
  8 
  9 /* . . . */
 10 
 11 p = kmalloc(sizeof(*p), GFP_KERNEL);
 12 p-&gt;a = 1;
 13 p-&gt;b = 2;
 14 p-&gt;c = 3;
 15 hlist_add_head_rcu(&amp;p-&gt;list, &amp;head);
</PRE>

<P>As before, line&nbsp;15 must be protected by some sort of synchronization
mechanism, for example, a lock.

<P>Subscribing to an RCU-protected hlist is also similar to the
circular list:

<PRE>
  1 rcu_read_lock();
  2 hlist_for_each_entry_rcu(p, q, head, list) {
  3   do_something_with(p-&gt;a, p-&gt;b, p-&gt;c);
  4 }
  5 rcu_read_unlock();
</PRE>

<P><A NAME="Quick Quiz 3"><B>Quick Quiz 3</B>:</A>
Why do we need to pass two pointers into
<code>hlist_for_each_entry_rcu()</code>
when only one is needed for <code>list_for_each_entry_rcu()</code>?

<P>The set of RCU publish and subscribe primitives are shown
in the following table, along with additional primitives to
"unpublish", or retract:

<table>
<tr class="Odd"><th>Category</th>
	<th>Publish</th>
		<th>Retract</th>
			<th>Subscribe</th>
</tr>
<tr class="Even"><th>Pointers</th>
	<td><code>rcu_assign_pointer()</code></td>
		<td><code>rcu_assign_pointer(..., NULL)</code></td>
			<td><code>rcu_dereference()</code></td>
</tr>
<tr class="Odd"><th>Lists</th>
	<td><code>list_add_rcu()</code> <br>
	    <code>list_add_tail_rcu()</code> <br>
	    <code>list_replace_rcu()</code></td>
		<td><code>list_del_rcu()</code></td>
			<td><code>list_for_each_entry_rcu()</code></td>
</tr>
<tr class="Even"><th>Hlists</th>
	<td><code>hlist_add_after_rcu()</code> <br>
	    <code>hlist_add_before_rcu()</code> <br>
	    <code>hlist_add_head_rcu()</code> <br>
	    <code>hlist_replace_rcu()</code></td>
		<td><code>hlist_del_rcu()</code></td>
			<td><code>hlist_for_each_entry_rcu()</code></td>
</tr>
</table>

<p>Note that the <code>list_replace_rcu()</code>, <code>list_del_rcu()</code>,
<code>hlist_replace_rcu()</code>, and <code>hlist_del_rcu()</code>
APIs add a complication.
When is it safe to free up the data element that was replaced or
removed?
In particular, how can we possibly know when all the readers
have released their references to that data element?

<P>These questions are addressed in the following section.

</p><H3><A NAME="Wait For Pre-Existing RCU Readers to Complete">
Wait For Pre-Existing RCU Readers to Complete</A></H3>

<P>In its most basic form, RCU is a way of waiting for things to finish.
Of course, there are a great many other ways of waiting for things to
finish, including reference counts, reader-writer locks, events, and so on.
The great advantage of RCU is that it can wait for each of
(say) 20,000 different things without having to explicitly
track each and every one of them, and without having to worry about
the performance degradation, scalability limitations, complex deadlock
scenarios, and memory-leak hazards that are inherent in schemes
using explicit tracking.

<P>In RCU's case, the things waited on are called
"RCU read-side critical sections".
An RCU read-side critical section starts with an
<code>rcu_read_lock()</code> primitive, and ends with a corresponding
<code>rcu_read_unlock()</code> primitive.
RCU read-side critical sections can be nested, and may contain pretty
much any code, as long as that code does not explicitly block or sleep
(although a special form of RCU called
"<A HREF="http://lwn.net/Articles/202847/">SRCU</A>"
does permit general sleeping in SRCU read-side critical sections).
If you abide by these conventions, you can use RCU to wait for <I>any</I>
desired piece of code to complete.

<P>RCU accomplishes this feat by indirectly determining when these
other things have finished, as has been described elsewhere for
<A HREF="http://www.rdrop.com/users/paulmck/RCU/whatisRCU.html">
RCU Classic</A> and
<A HREF="http://lwn.net/Articles/253651/">realtime RCU</A>.

<P>In particular, as shown in the following figure, RCU is a way of
waiting for pre-existing RCU read-side critical sections to completely
finish, including memory operations executed by those critical sections.

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/GracePeriodGood.png" width=525 height=261 
ALT="Grace
periods extend to contain pre-existing RCU read-side critical sections.">
</blockquote>

<P>However, note that RCU read-side critical sections
that begin after the beginning
of a given grace period can and will extend beyond the end of that grace
period.

<P>The following pseudocode shows the basic form of algorithms that use
RCU to wait for readers:
<OL>
<LI>	Make a change, for example, replace an element in a linked list.
<p>
<LI>	Wait for all pre-existing RCU read-side critical sections to
	completely finish (for example, by using the
	<code>synchronize_rcu()</code> primitive).
	The key observation here is that subsequent RCU read-side critical
	sections have no way to gain a reference to the newly removed
	element.
<p>
<LI>	Clean up, for example, free the element that was replaced above.
</OL>

<P>The following code fragment, adapted from those in the
<A HREF="#Publish-Subscribe Mechanism">previous section</A>,
demonstrates this process, with field <code>a</code> being the search key:
<A NAME="Canonical Replacement Example"> </A>

<PRE>
  1 struct foo {
  2   struct list_head list;
  3   int a;
  4   int b;
  5   int c;
  6 };
  7 LIST_HEAD(head);
  8 
  9 /* . . . */
 10 
 11 p = search(head, key);
 12 if (p == NULL) {
 13   /* Take appropriate action, unlock, and return. */
 14 }
 15 q = kmalloc(sizeof(*p), GFP_KERNEL);
 16 *q = *p;
 17 q-&gt;b = 2;
 18 q-&gt;c = 3;
 19 list_replace_rcu(&amp;p-&gt;list, &amp;q-&gt;list);
 20 synchronize_rcu();
 21 kfree(p);
</PRE>

<P>Lines&nbsp;19, 20, and 21 implement the three steps called out above.
Lines&nbsp;16-19 gives RCU ("read-copy update") its name: while permitting
concurrent <I>reads</I>, line&nbsp;16 <I>copies</I> and lines&nbsp;17-19
do an <I>update</I>.

<P>The <code>synchronize_rcu()</code> primitive might seem a bit
mysterious at first.
After all, it must wait for all RCU read-side critical sections to
complete, and, as we saw earlier, the
<code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code> primitives
that delimit RCU read-side critical sections don't even generate any
code in non-<code>CONFIG_PREEMPT</code> kernels!

<P>There is a trick, and the trick is that RCU Classic read-side critical
sections delimited by <code>rcu_read_lock()</code> and
<code>rcu_read_unlock()</code> are not permitted to block or sleep.
Therefore, when a given CPU executes a context switch, we are guaranteed
that any prior RCU read-side critical sections will have completed.
This means that as soon as each
CPU has executed at least one context switch, <I>all</I>
prior RCU read-side critical sections are guaranteed to have completed,
meaning that <code>synchronize_rcu()</code> can safely return.

<P>Thus, RCU Classic's <code>synchronize_rcu()</code>
can conceptually be as simple as the following:

<PRE>
  1 for_each_online_cpu(cpu)
  2   run_on(cpu);
</PRE>

<P>Here, <code>run_on()</code> switches the current thread to the
specified CPU, which forces a context switch on that CPU.
The <code>for_each_online_cpu()</code> loop therefore forces a
context switch on each CPU, thereby guaranteeing that all prior
RCU read-side critical sections have completed, as required.
Although this simple approach works for kernels in which preemption
is disabled across RCU read-side critical sections, in other
words, for non-<code>CONFIG_PREEMPT</code> and <code>CONFIG_PREEMPT</code>
kernels, it does <i>not</i> work for <code>CONFIG_PREEMPT_RT</code>
realtime (-rt) kernels.
Therefore, <A HREF="http://lwn.net/Articles/253651/">realtime RCU</A> uses
a different approach based loosely on reference counters.

<P>Of course, the actual implementation in the Linux kernel
is much more complex, as it is required
to handle interrupts, NMIs, CPU hotplug, and other hazards of
production-capable kernels, but while also maintaining good performance and
scalability.
Realtime implementations of RCU must additionally help provide good
realtime response, which rules out implementations (like the simple
two-liner above) that rely on disabling preemption.

<P>Although it is good to know that there is a simple conceptual
implementation of <code>synchronize_rcu()</code>, other questions remain.
For example, what exactly do RCU
readers see when traversing a concurrently updated list?
This question is addressed in the following section.

</p><H3><A NAME="Maintain Multiple Versions of Recently Updated Objects">
Maintain Multiple Versions of Recently Updated Objects</A></H3>

<P>This section demonstrates how RCU maintains multiple versions of
lists to accommodate synchronization-free readers.
Two examples are presented showing how an element
that might be referenced by a given reader must remain intact
while that reader remains in its RCU read-side critical section.
The first example demonstrates deletion of a list element,
and the second example demonstrates replacement of an element.

<H3><A NAME="Example 1: Maintaining Multiple Versions During Deletion">
Example 1: Maintaining Multiple Versions During Deletion</A></H3>

<P>To start the "deletion" example,
we will modify lines&nbsp;11-21 in the
<A HREF="#Canonical Replacement Example">example in the previous section</A>
as follows:

<PRE>
  1 p = search(head, key);
  2 if (p != NULL) {
  3   list_del_rcu(&amp;p-&gt;list);
  4   synchronize_rcu();
  5   kfree(p);
  6 }
</PRE>

<P>The initial state of the list, including the pointer <code>p</code>,
is as follows.

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersion1.jpg" ALT="Initial list
state." width=429 height=111>
</blockquote>

<P>The triples in each element represent the values of fields <code>a</code>,
<code>b</code>, and <code>c</code>, respectively.
The red borders on
each element indicate that readers might be holding references to them,
and because readers do not synchronize directly with updaters,
readers might run concurrently with this entire replacement process.
Please note that 
we have omitted the backwards pointers and the link from the tail
of the list to the head for clarity.

<P>After the <code>list_del_rcu()</code> on
line&nbsp;3 has completed, the <code>5,6,7</code>&nbsp;element
has been removed from the list, as shown below.
Since readers do not synchronize directly with updaters,
readers might be concurrently scanning this list.
These concurrent readers might or might not see the newly removed element,
depending on timing.
However, readers that were delayed (e.g., due to interrupts, ECC memory
errors, or, in <code>CONFIG_PREEMPT_RT</code> kernels, preemption)
just after fetching a pointer to the newly removed element might
see the old version of the list for quite some time after the
removal.
Therefore, we now have two versions of the list, one with element
<code>5,6,7</code> and one without.
The border of the <code>5,6,7</code>&nbsp;element is
still red, indicating
that readers might be referencing it.

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersionDelete2.jpg" ALT="After
deletion." width=429 height=138>
</blockquote>

<P>Please note that readers are not permitted to maintain references to
element&nbsp;<code>5,6,7</code> after exiting from their RCU read-side
critical sections.
Therefore,
once the <code>synchronize_rcu()</code> on
line&nbsp;4 completes, so that all pre-existing readers are
guaranteed to have completed,
there can be no more readers referencing this
element, as indicated by its black border below.
We are thus back to a single version of the list.

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersionDelete3.jpg" ALT="After deletion."
width=429 height=138>
</blockquote>

<P>At this point, the <code>5,6,7</code>&nbsp;element may safely be
freed, as shown below:

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersionDelete4.jpg" ALT="After deletion."
width=429 height=49>
</blockquote>

<P>At this point, we have completed the deletion of
element&nbsp;<code>5,6,7</code>.
The following section covers replacement.

<H3>Example 2: Maintaining Multiple Versions During Replacement</H3>

<P>To start the replacement example,
here are the last few lines of the
<A HREF="#Canonical Replacement Example">example in the previous section</A>:

<PRE>
  1 q = kmalloc(sizeof(*p), GFP_KERNEL);
  2 *q = *p;
  3 q-&gt;b = 2;
  4 q-&gt;c = 3;
  5 list_replace_rcu(&amp;p-&gt;list, &amp;q-&gt;list);
  6 synchronize_rcu();
  7 kfree(p);
</PRE>

<P>The initial state of the list, including the pointer <code>p</code>,
is the same as for the deletion example:

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersion1.jpg" ALT="Initial list state."
width=429 height=111>
</blockquote>

<P>As before,
the triples in each element represent the values of fields <code>a</code>,
<code>b</code>, and <code>c</code>, respectively.
The red borders on
each element indicate that readers might be holding references to them,
and because readers do not synchronize directly with updaters,
readers might run concurrently with this entire replacement process.
Please note that 
we again omit the backwards pointers and the link from the tail
of the list to the head for clarity.

<P>Line&nbsp;1 <code>kmalloc()</code>s a replacement element, as follows:

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersion2.jpg" ALT="List state after
allocation." width=492 height=168>
</blockquote>

<P>Line&nbsp;2 copies the old element to the new one:

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersion3.jpg" ALT="List state after
copy." width=429 height=168>
</blockquote>

<P>Line&nbsp;3 updates <code>q-&gt;b</code> to the value "2":

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersion4.jpg" ALT="List state after
update of b." width=429 height=168>
</blockquote>

<P>Line&nbsp;4 updates <code>q-&gt;c</code> to the value "3":

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersion5.jpg" ALT="List state after
update of c." width=429 height=168>
</blockquote>

<P>Now, line&nbsp;5 does the replacement, so that the new element is
finally visible to readers.
At this point, as shown below, we have two versions of the list.
Pre-existing readers might see the <code>5,6,7</code> element, but
new readers will instead see the <code>5,2,3</code> element.
But any given reader is guaranteed to see some well-defined list.

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersion6.jpg" ALT="List state after
replacement." width=429 height=171>
</blockquote>

<P>After the <code>synchronize_rcu()</code> on line&nbsp;6 returns,
a grace period will have elapsed, and so all reads that started before the
<code>list_replace_rcu()</code> will have completed.
In particular, any readers that might have been holding references
to the <code>5,6,7</code> element are guaranteed to have exited
their RCU read-side critical sections, and are thus prohibited from
continuing to hold a reference.
Therefore, there can no longer be any readers holding references
to the old element, as indicated by the thin black border around
the <code>5,6,7</code> element below.
As far as the readers are concerned, we are back to having a single version
of the list, but with the new element in place of the old.

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersion7.jpg" ALT="List state after
grace period." width=429 height=171>
</blockquote>

<P>After the <code>kfree()</code> on line 7 completes, the list will
appear as follows:

<P>
<blockquote>
<IMG src="https://static.lwn.net/images/ns/kernel/rcu/MultiVersion8.jpg" ALT="List state after
grace period." width=429 height=109>
</blockquote>

<P>Despite the fact that RCU was named after the replacement case,
the vast majority of RCU usage within the Linux kernel relies on
the simple deletion case shown in the
<A HREF="#Example 1: Maintaining Multiple Versions During Deletion">
previous section</A>.

<H3>Discussion</H3>

<P>These examples assumed that a mutex was held across the entire
update operation, which would mean that there could be at most two
versions of the list active at a given time.

<P><A NAME="Quick Quiz 4"><B>Quick Quiz 4</B>:</A>
How would you modify the deletion example to permit more than two
versions of the list to be active?

<P><A NAME="Quick Quiz 5"><B>Quick Quiz 5</B>:</A>
How many RCU versions of a given list can be active at any given time?

<P>This sequence of events shows how RCU updates use multiple versions
to safely carry out changes in presence of concurrent readers.
Of course, some algorithms cannot gracefully handle multiple versions.
There are
<A
HREF="http://www.rdrop.com/users/paulmck/RCU/RCUdissertation.2004.07.14e1.pdf">techniques
[PDF]</A>
for adapting such algorithms to RCU,
but these are beyond the scope of this article.

</p><H3><A NAME="Conclusion">Conclusion</A></H3>

<P>This article has described the three fundamental components of RCU-based
algorithms:

<OL>
<LI>	a publish-subscribe mechanism for adding new data,
<p>
<LI>	a way of waiting for pre-existing RCU readers to finish, and
<p>
<LI>	a discipline of maintaining multiple versions to permit
	change without harming or unduly delaying concurrent RCU readers.
</OL>

<P><A NAME="Quick Quiz 6"><B>Quick Quiz 6</B>:</A>
How can RCU updaters possibly delay RCU readers, given that the
<code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code>
primitives neither spin nor block?

<P>These three RCU components
allow data to be updated in face of concurrent readers, and
can be combined in different ways to
implement a surprising variety of different types of RCU-based algorithms,
some of which will
be the topic of the next installment in this "What is RCU, Really?"
series.

<H3>Acknowledgements</H3>

<P>We are all indebted to Andy Whitcroft, Gautham Shenoy, and Mike Fulton,
whose review of an early draft of this document greatly improved it.
We owe thanks to the members of the Relativistic Programming project
and to members of PNW TEC for many valuable discussions.
We are grateful to Dan Frye for his support of this effort.
Finally, this material is based upon work supported by the National Science
Foundation under Grant No. CNS-0719851.

<P>This work represents the view of the authors and does not necessarily
represent the view of IBM or of Portland State University.

<P>Linux is a registered trademark of Linus Torvalds.

<P>Other company, product, and service names may be trademarks or
service marks of others.

<H3><A NAME="Answers to Quick Quizzes">
Answers to Quick Quizzes</A></H3>

<P><B>Quick Quiz 1</B>:
But doesn't seqlock also permit readers and updaters to get work done
concurrently?

<P><B>Answer</B>:
Yes and no.
Although seqlock readers can run concurrently with
seqlock writers, whenever this happens, the <code>read_seqretry()</code>
primitive will force the reader to retry.
This means that any work done by a seqlock reader running concurrently
with a seqlock updater will be discarded and redone.
So seqlock readers can <I>run</I> concurrently with updaters,
but they cannot actually get any work done in this case.

<P>In contrast, RCU readers can perform useful work even in presence
of concurrent RCU updaters.


<P><B>Quick Quiz 2</B>:
What prevents the <code>list_for_each_entry_rcu()</code> from
getting a segfault if it happens to execute at exactly the same
time as the <code>list_add_rcu()</code>?

<P><B>Answer</B>: On all systems running Linux, loads from and stores
to pointers are atomic, that is, if a store to a pointer occurs at
the same time as a load from that same pointer, the load will return
either the initial value or the value stored, never some bitwise mashup
of the two.
In addition, the <code>list_for_each_entry_rcu()</code> always proceeds
forward through the list, never looking back.
Therefore, the <code>list_for_each_entry_rcu()</code> will either see
the element being added by <code>list_add_rcu()</code>, or it will not,
but either way, it will see a valid well-formed list.

<P><A HREF="#Quick Quiz 2"><B>Back to Quick Quiz 2</B>.</A>

<P><B>Quick Quiz 3</B>:
Why do we need to pass two pointers into
<code>hlist_for_each_entry_rcu()</code>
when only one is needed for <code>list_for_each_entry_rcu()</code>?

<P><B>Answer</B>: Because in an hlist it is necessary to check for
NULL rather than for encountering the head.
(Try coding up a single-pointer <code>hlist_for_each_entry_rcu()</code>.
If you come up with a nice solution, it would be a very good thing!)

<P><A HREF="#Quick Quiz 3"><B>Back to Quick Quiz 3</B>.</A>

<P><B>Quick Quiz 4</B>:
How would you modify the deletion example to permit more than two
versions of the list to be active?

<P><B>Answer</B>:
One way of accomplishing this is as follows:

<PRE>
spin_lock(&amp;mylock);
p = search(head, key);
if (p == NULL)
	spin_unlock(&amp;mylock);
else {
	list_del_rcu(&amp;p-&gt;list);
	spin_unlock(&amp;mylock);
	synchronize_rcu();
	kfree(p);
}
</PRE>

<P>Note that this means that multiple concurrent deletions might be
waiting in <code>synchronize_rcu()</code>.

<P><A HREF="#Quick Quiz 4"><B>Back to Quick Quiz 4</B>.</A>

<P><B>Quick Quiz 5</B>:
How many RCU versions of a given list can be active at any given time?

<P><B>Answer</B>:
That depends on the synchronization design.
If a semaphore protecting the update is held across the grace period,
then there can be at most two versions, the old and the new.

<P>However, if only the search, the update, and the
<code>list_replace_rcu()</code> were protected by a lock, then
there could be an arbitrary number of versions active, limited only
by memory and by how many updates could be completed within a
grace period.
But please note that data structures that are updated so frequently
probably are not good candidates for RCU.
That said, RCU can handle high update rates when necessary.

<P><A HREF="#Quick Quiz 5"><B>Back to Quick Quiz 5</B>.</A>

<P><B>Quick Quiz 6</B>:
How can RCU updaters possibly delay RCU readers, given that the
<code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code>
primitives neither spin nor block?

<P><B>Answer</B>:
The modifications undertaken by a given RCU updater will cause the
corresponding CPU to invalidate cache lines containing the data,
forcing the CPUs running concurrent RCU readers to incur expensive
cache misses.
(Can you design an algorithm that changes a data structure <I>without</I>
inflicting expensive cache misses on concurrent readers?
On subsequent readers?)

<P><A HREF="#Quick Quiz 6"><B>Back to Quick Quiz 6</B>.</A><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Read-copy-update">Read-copy-update</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/262464/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor262913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">example code nitpicks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 20, 2007 21:15 UTC (Thu)
                               by <b>ntl</b> (subscriber, #40518)
                              [<a href="/Articles/262913/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Shouldn't the list_head and hlist_node structs be embedded in struct foo, instead of pointers?  That is,

<pre>
struct foo {
-   struct list_head *list;
+   struct list_head list;
   ...
}
</pre>

Also, no need to cast the return value of kmalloc :)

      
          <div class="CommentReplyButton">
            <form action="/Articles/262913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor262930"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">example code nitpicks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 21, 2007 1:03 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/262930/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Good catch in both cases!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/262930/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor262993"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">example code nitpicks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 21, 2007 17:08 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/262993/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
And many thanks to Jon Corbet for applying the fixes for these problems!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/262993/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor263107"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Problem with ex 2 ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 23, 2007 23:23 UTC (Sun)
                               by <b>xav</b> (guest, #18536)
                              [<a href="/Articles/263107/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
It looks to me that example 2 is wrong: access to p is unlocked, so it can changed under its
feet if preempted: *q = *p can access freed memory.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263107/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor263219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Problem with ex 2 ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 27, 2007 18:57 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/263219/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Indeed!  As with the preceding example, there must be some sort of mutual exclusion in play,
and as in the preceding example, this mutual exclusion is not shown explicitly.

One approach, as you say, would be to add locking, perhaps similar to that described in the
answer to Quick Quiz 4 (but for the deletion example).  Another approach would be to hold a
mutex (in the old style, "semaphore") across the entire code segment.  Yet a third approach
would be to permit only a single designated task to do updates (in which case the code would
remain as is).  There are other approaches as well.

In any case, I am glad to see that people are sensitized to the need for mutual exclusion in
parallel code!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor263168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What is RCU, Fundamentally?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 26, 2007 12:54 UTC (Wed)
                               by <b>union</b> (guest, #36393)
                              [<a href="/Articles/263168/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Since nobody else said it. 

Thanks for a great article.
I liked the articles about memory and this looks like another great miniseries. While I spend
most of my days programming python and Java,
I believe that understanding such lower level concepts makes me better programmer. 

I hope that there will be more such background or fundamentals articles in the future.

Luka
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor263221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What is RCU, Fundamentally?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 27, 2007 19:04 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/263221/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Glad you liked it!!!  ;-)

Garbage-collected languages such as Java implement RCU's "wait for pre-existing RCU readers to
complete" implicitly via the garbage collector.  However, in Java, you must make careful use
of atomic variables in order to correctly implement the publish-subscribe mechanism.  Last I
knew, Java would emit memory barriers for the subscribe operation, even when unnecessary, but
perhaps that has changed by now.  However, in many cases, the memory-barrier overhead might
well be acceptable (e.g., when avoiding contention).

So you might well be able to use RCU techniques in Java!  (For whatever it is worth, Kung and
Lehman described the gist of using garbage collectors in this fashion in their paper entitled
"Concurrent Maintenance of Binary Search Trees" in "ACM Transactions on Database Systems" back
in September 1980.)
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor263268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What is RCU, Fundamentally?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 27, 2007 23:47 UTC (Thu)
                               by <b>scottt</b> (guest, #5028)
                              [<a href="/Articles/263268/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      A <a href=http://portal.acm.org/citation.cfm?id=320619>link</a> to the paper.

<p>
With people doing all these advanced concurrent algorithms in the eighties I wonder why we're only just now getting a formal memory model for the C/C++ programming languages.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/263268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor263283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What is RCU, Fundamentally?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 28, 2007 15:22 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/263283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Thank you for providing the link -- much better than my old hard copy!  It is very good indeed
to see some of these older papers becoming available on the web.

There was indeed some memory-consistency-model research done some decades ago.  Although I
cannot claim comprehensive knowledge of memory-model research, as near as I can tell, almost
all of this older research was swept aside by the notion of sequential consistency in 1979.
The lion's share of later research assumed sequential consistency, which rendered this research
less than helpful on weakly-ordered machines, where "weakly ordered" includes x86.  Algorithms
that fail to work on x86 cannot be said to have much practical value, in my opinion.

There were nevertheless some fundamental papers published in the 90s (e.g., Sarita Adve and
Kourosh Gharachorloo, among others), but many of the researchers focused on "how to emulate
sequential consistency on weak-memory machines" as opposed to "how best to express
memory-ordering constraints while allowing efficient code to be generated for systems with a
wide variety of memory consistency models".  It is this latter statement that the C/C++
standards committee must address.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor263280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Backlinks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 28, 2007 12:37 UTC (Fri)
                               by <b>mmutz</b> (guest, #5642)
                              [<a href="/Articles/263280/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
I'm wondering whether the omission of the backlinks in the examples is a 
good thing. The omission makes the technique trivial, since publishing 
only involves one replacing one pointer.

What about the second, back, one? Without support for atomic two-pointer 
updates, how can both the p-&gt;prev-&gt;next = q and p-&gt;next-&gt;prev = q updates 
be performed without risking clients to see an inconsistent view of the 
doubly linked list? Or is that not a problem in practice?

Thanks for the article, though. Looking forward to the next installment!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor263285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Backlinks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 28, 2007 15:35 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/263285/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Glad you liked the article, and thank you for the excellent question!  I could give any number of answers, including:

<OL>
<LI> In production systems, trivial techniques are a very good thing.
<LI> Show me an example where it is useful to traverse the -&gt;prev pointers under RCU protection.  Given several such examples, we could work out how best to support this.
<LI> Consistency is grossly overrated.  (Not everyone agrees with me on this, though!)
<LI> Even with atomic two-pointer updates, consider the following sequence of events: (1) task 1 does p=p-&gt;next (2) task 2 inserts a new element between the two that task 1 just dealt with (3) task 1 does p=p-&gt;prev and fails to end up where it started!  Even double-pointer atomic update fails to banish inconsistency!  ;-)
<LI> If you need consistency, use locks.
</OL>

<P>Given the example above, we could support a level of consistency equivalent to the double-pointer atomic update simply by assigning the pointers in sequence -- just remove the prev-pointer poisoning from list_del_rcu(), for example.  But doing this would sacrifice the ability to catch those bugs that pointer-poisoning currently catches.

<P>So, there might well come a time when the Linux kernel permits RCU-protected traversal of linked lists in both directions, but we need to see a compelling need for this before implementing it.
      
          <div class="CommentReplyButton">
            <form action="/Articles/263285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor263412"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Forcing the compiler and CPU to execute assignment statements in order ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 30, 2007 16:51 UTC (Sun)
                               by <b>Brenner</b> (guest, #28232)
                              [<a href="/Articles/263412/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Thanks for the article;

In the 'Publish-Subscribe Mechanism', the article states : "Unfortunately, there is nothing
forcing the compiler and CPU to execute the last four assignment statements in order."

This breaks my mind. I understand concurrency problems with multiple tasks, but here only one
task is considered (or did I misunderstand something ?). Why would the CPU not execute the
last four assignment statements in the order given by the compiler, and why would the compiler
not keep the order given by the programmer ???

Even with multiple tasks, I thought that the order was guaranteed (I agree that many things
can happen between two code lines of one given task if other tasks are running though).

Can anyone enlighten me ?

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263412/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor263561"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Forcing the compiler and CPU to execute assignment statements in order ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 1, 2008 23:10 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/263561/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <P>You are welcome!

<P>Your question about ordering is a good one, and code reordering by both CPU and compiler can be grossly counter-intuitive at times.  So an explanation is indeed in order.  Let's start with the compiler.  The code was as follows:

<pre>
 11 p-&gt;a = 1;
 12 p-&gt;b = 2;
 13 p-&gt;c = 3;
 14 gp = p;
</pre>

<P>It is possible that the compiler holds the value of <code>gp</code> in a register, but that it will need to spill that value in order to generate the code for lines&nbsp;11-14.  What to do?  Well, as long as the compiler can prove that <code>p</code> and <code>gp</code> do not point to overlapping regions of memory, the compiler is within its rights to generate the code for line&nbsp;14 before generating the code for the other lines.  In this case, rearranging the code in this manner reduces code size, probably increases performance, and hurts no one.  That is, it hurts no one <I>in the absence of concurrency</I>.  However, please keep in mind that the C standard currently does not allow concurrency, strange though that may seem to those of us who have been writing concurrent C programs for decades.

<P>So special non-standard compiler directives (<code>barrier()</code> in the Linux kernel, or, when used properly, <code>volatile</code>) are required to force the compiler to maintain ordering.  Note that such directives are included, either directly or indirectly, in primitives that require ordering, for example, the <code>smp_mb()</code> memory barrier in the Linux kernel.

<P>On to the CPU.  Suppose that the compiler generates the code in order, and that the CPU executes it in order.  What could possibly go wrong?

<P>The store buffer.  The CPU will likely commit the new values of <code>p-&gt;a</code>, <code>p-&gt;b</code>, <code>p-&gt;c</code>, and <code>gp</code> to the store buffer.  If the cache line referenced by <code>p</code> happens to be owned by some other CPU (for example, if the memory returned by the preceding <code>kmalloc()</code> had been <code>kfree()</code>ed by some other CPU) and if the cache line containing <code>gp</code> is owned by the current CPU, the first three assignments will be flushed from the store buffer (and thus visible to other CPUs) long after the last assignment will be.

<P>In addition, superscalar CPUs routinely execute code out of order.  Such beasts might become less common as power-consumption concerns rise to the fore, but there are still quite a few such CPUs out there, dating from the mid-1990s for commodity microprocessors and to the mid-<I>1960s</I> for supercomputers.  For example, <A HREF="http://en.wikipedia.org/wiki/Tomasulo_algorithm">Tomasulo's Algorithm</A>, dating from the mid-1960s, is specifically designed to allow CPUs to execute instructions out of order.  And there were super-scalar supercomputers pre-dating Tomasulo's Algorithm.

<P>In short, if ordering is important to you, use primitives to enforce ordering.  Such primitives include locking primitives (e.g., <code>spin_lock()</code> and <code>spin_unlock()</code> in the Linux kernel), the RCU publish-subscribe primitives called out in this article, and of course explicit memory barriers.  (I would recommend avoiding explicit memory barriers where feasible -- they are difficult to get right.)

<P>Hey, you asked!!!  And Happy New Year!!!
      
          <div class="CommentReplyButton">
            <form action="/Articles/263561/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor263567"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Forcing the compiler and CPU to execute assignment statements in order ?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 2, 2008 0:09 UTC (Wed)
                               by <b>Brenner</b> (guest, #28232)
                              [<a href="/Articles/263567/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Thanks a lot for your very informative answer. And Happy New Year!!!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263567/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor263810"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Userland</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2008 4:06 UTC (Fri)
                               by <b>eduardo.juan</b> (guest, #47737)
                              [<a href="/Articles/263810/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Thanks for this excellent article!

I have a fundamentally question! :D

Is any way to use RCU on userland programs? I mean, any lib or implementation of this
constraints in userland?

Thanks and regards!

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263810/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor263880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Using RCU in userland</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2008 18:13 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/263880/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      RCU has been used experimentally in user-mode code, and one benchmarking framework may be found at <A HREF="http://www.cs.toronto.edu/~tomhart/perflab/ipdps06.tgz">U. of Toronto</A>.

<P>In addition, I vaguely recall at least one user-level RCU implementation being posted on LKML as a programming/debugging aid.  There are some others that I am unfortunately unable to release at this time.

<P>As noted in an earlier comment, garbage-collected languages automatically provide much of the wait-for-reader functionality for free -- however, it is still necessary to correctly handle the publish-subscribe operation correctly.  One way to do this in Java is to use the recently added "volatile" field specifier (no relation to "volatile" in C/C++) for the pointer that is being published.  In other words, instead of using the Linux-kernel rcu_assign_pointer() and rcu_dereference() to publish and subscribe, you instead mark the pointer itself using Java's "volatile" keyword.
      
          <div class="CommentReplyButton">
            <form action="/Articles/263880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor263905"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Using RCU in userland</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2008 20:08 UTC (Fri)
                               by <b>eduardo.juan</b> (guest, #47737)
                              [<a href="/Articles/263905/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Thanks Paul for answering! I'll be trying it!

Regards
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263905/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor263963"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Using RCU in userland</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2008 16:26 UTC (Sat)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/263963/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Very cool!  Please let me know how it goes!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/263963/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor264005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle"> Some usages of RCU in the kernel code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2008 10:42 UTC (Sun)
                               by <b>fbh</b> (guest, #49754)
                              [<a href="/Articles/264005/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Hi,

I'm probably missing something but I looked at users of RCU in the kernel and found that
kernel/kprobes.c doesn't call rcu_read_lock() function before entering in a critical section.
Does it have any good reasons to do so ?

Another point in include/linux/list.h: sometimes it seems that RCU API is not used for no good
reasons. For example __list_add_rcu() does not use rcu_dereference(). However by using it, the
code could have clearly showed which pointer is RCU protected...

The Alpha memory ordering and value-speculation compiler optimizations done in this
architecture sounds incredibely weird to me. Any avalaible pointers on this subject ?

Anyways, thanks for this article.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/264005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor264021"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle"> Some usages of RCU in the kernel code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2008 19:04 UTC (Sun)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/264021/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <P>The reason that kernel/kprobes.c does not use <code>synchronize_rcu()</code> is that it instead uses <code>synchronize_sched()</code>.  The read-side primitives corresponding to <code>synchronize_sched()</code> include <code>preempt_disable()/preempt_enable()</code>, <code>local_irq_save()/local_irq_restore()</code> -- in short, any primitive that disables and re-enables preemption, including entry to hardware irq/exception handlers.  The third article in this series will cover these and other nuances of the RCU API.

<P>The reason that <code>__list_add_rcu()</code> does not use <code>rcu_dereference()</code> is that <code>__list_add_rcu()</code> is an update-side primitive, and therefore must be protected by appropriate locking.  This means that the list cannot change while the lock is held, and this in turn means that the memory barriers implied by lock acquisition suffice.  That said, it is permissible (but again, not necessary) to use <code>rcu_dereference()</code> in update-side code -- in fact, in some situations, doing so promotes code reuse and in some cases readability.

<P>The discussion of Figure 2 in <A HREF="http://www.rdrop.com/users/paulmck/scalability/paper/ordering.2007.09.19a.pdf">this article</A> and its bibliography is a good place to start on Alpha's memory ordering.  I am not all that familiar with value-speculation compiler-optimization research, but one place to start might be <A HREF="http://www-plan.cs.colorado.edu/diwan/pldi02.pdf">here</A>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/264021/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor264053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle"> Some usages of RCU in the kernel code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2008 10:14 UTC (Mon)
                               by <b>fbh</b> (guest, #49754)
                              [<a href="/Articles/264053/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Regarding the second point, I'm sorry, my fingers typed rcu_dereference() whereas my brain was
thinking to rcu_assign_pointer(). rcu_dereference() could be used in update-side code, as you
pointed out, but obviously not in __list_add_rcu().

Therefore __list_add_rcu() could be:

        new-&gt;next = next;
        new-&gt;prev = prev;
        rcu_assign_pointer(prev-&gt;next, new);
        next-&gt;prev = new;

The main advantage of this is readability IMHO.

You said that __list_add_rcu() must be protected by appropriate locking, and a memory barrier
is implied by lock acquisition which should be enough. But __list_add_rcu() has a memory
barrier in its implementation.

Thanks.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/264053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor264067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle"> Some usages of RCU in the kernel code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2008 15:28 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/264067/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Good point!  Would you like to submit a patch?
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/264067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor264069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle"> Some usages of RCU in the kernel code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2008 16:03 UTC (Mon)
                               by <b>fbh</b> (guest, #49754)
                              [<a href="/Articles/264069/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Well, I actually raised 2 points and I'm not sure which one is the good one...

Could you please clarify ?

To answer your question, I don't have any problems for submitting a patch.

---
PS: This interface is pretty hard for discussing on an article. It's like bottom-posting
except we loose all its advantages... Just my 2 cents.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/264069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor264087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle"> Some usages of RCU in the kernel code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2008 16:52 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/264087/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
I was inviting a patch for incorporating the smp_wmb() into the rcu_assign_pointer.

The lock acquisition makes rcu_dereference() unnecessary, but cannot enforce the ordering
provided by the smp_wmb()/rcu_assign_pointer().
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/264087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor264164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle"> Some usages of RCU in the kernel code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2008 11:02 UTC (Tue)
                               by <b>jarkao2</b> (guest, #41960)
                              [<a href="/Articles/264164/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Thanks for this (next) great article too! BTW, probably 'a' tiny fix needed:
"Maintain Multiple Versions of Recently Updated Objects
[...] Two examples are presented showing how a an element [...]"
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/264164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor264181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle"> Some usages of RCU in the kernel code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2008 14:13 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/264181/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Good eyes!!!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/264181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor454293"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What is RCU, Fundamentally?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2011 10:47 UTC (Sat)
                               by <b>stock</b> (guest, #5849)
                              [<a href="/Articles/454293/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"One key attribute of RCU is the ability to safely scan data, even<br>
though that data is being modified concurrently. To provide this<br>
ability for concurrent insertion, RCU uses what can be thought of<br>
as a publish-subscribe mechanism."<br>
<p>
Does this not read like that once announced Microsoft Filesystem called<br>
WinFS ? From the WinFS wikipedia penal records :<br>
<p>
<a rel="nofollow" href="http://en.wikipedia.org/wiki/WinFS">http://en.wikipedia.org/wiki/WinFS</a><br>
<p>
"WinFS (short for Windows Future Storage)[1] is the code name for a<br>
cancelled[2] data storage and management system project based on<br>
relational databases, developed by Microsoft and first demonstrated<br>
in 2003 as an advanced storage subsystem for the Microsoft Windows<br>
operating system, ...<br>
[ ... ]<br>
WinFS includes a relational database for storage of information,<br>
and allows any type of information to be stored in it, provided<br>
there is a well defined schema for the type."<br>
<p>
It's funny to see IBM, amongst others, explain the 'dirty' details about 'RCU'<br>
here on LWN.<br>
<p>
Robert<br>
--<br>
Robert M. Stockmann - RHCE<br>
Network Engineer - UNIX/Linux Specialist<br>
crashrecovery.org  stock@stokkie.net<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454293/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454299"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What is RCU, Fundamentally?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2011 13:51 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/454299/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Does this not read like that once announced Microsoft Filesystem called WinFS ?
</blockquote>
No. WinFS was a 'store everything in a relational database' thing. This is utterly different, nothing relational at all.
      
          <div class="CommentReplyButton">
            <form action="/Articles/454299/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor645747"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What is RCU, Fundamentally?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2015 12:50 UTC (Sun)
                               by <b>firolwn</b> (guest, #96711)
                              [<a href="/Articles/645747/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I really didn't understand Quick Quiz 5.<br>
Why does semaphore affect the numbers of RCU  version list?   <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/645747/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor647511"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What is RCU, Fundamentally?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2015 18:32 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/647511/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      In the following code, we have at most two versions:

<blockquote>
<pre>
mutex_lock(&amp;my_mutex);
p = find_an_element(key);
list_del_rcu(&amp;p-&gt;list);
synchronize_rcu();
kfree(p);
mutex_unlock(&amp;my_mutex);
</pre>
</blockquote>

Only one task at a time may hold <code>my_mutex</code>, so there can be at most two versions of the list, the new one with the element deleted, and for pre-existing readers, the old one with that element still in place.  (When this article was written, the Linux kernel used semaphores for sleeplocks, but it now uses mutexes.)

<p>
In contrast, suppose that the mutex is held only across the deletion:

<blockquote>
<pre>
mutex_lock(&amp;my_mutex);
p = find_an_element(key);
list_del_rcu(&amp;p-&gt;list);
mutex_unlock(&amp;my_mutex);
synchronize_rcu();
kfree(p);
</pre>
</blockquote>

In this case, many updaters could be waiting for grace periods in parallel, so there could be many concurrent versions of the list.
      
          <div class="CommentReplyButton">
            <form action="/Articles/647511/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor976510"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What is RCU, Fundamentally?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2024 6:57 UTC (Mon)
                               by <b>summergift</b> (guest, #171661)
                              [<a href="/Articles/976510/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you for your explanation!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/976510/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor988153"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Links to later articles in the series</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2024 8:23 UTC (Sun)
                               by <b>fraetor</b> (subscriber, #161147)
                              [<a href="/Articles/988153/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Links to the other two parts of the series:</p>
<ul>
<li><a href="https://lwn.net/Articles/263130/">Part 2: Usage</a></li>
<li><a href="https://lwn.net/Articles/264090/">Part 3: The RCU API</a></li>
</ul>


      
          <div class="CommentReplyButton">
            <form action="/Articles/988153/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2007, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
