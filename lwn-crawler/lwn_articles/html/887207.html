        <!DOCTYPE html>
        <html lang="en">
        <head><title>Random numbers and virtual-machine forks [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/887207/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/887491/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/887207/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Random numbers and virtual-machine forks</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>March 11, 2022</br>
           </div>
One of the key characteristics of a random-number generator (RNG) is its
unpredictability; by definition, it should not be possible to know what the
next number 
to be produced will be.  System security depends on this unpredictability
at many levels.  An attacker who knows an RNG's future output may be able
to eavesdrop on (or interfere with) network conversations, compromise
cryptographic keys, and more.  So it is a bit disconcerting to know that
there is a common event that can cause RNG predictability: the forking or
duplication of a
virtual machine.  Linux RNG maintainer Jason Donenfeld is working on a
solution to this problem.
<p>
The kernel's RNG maintains an "entropy pool" from which random numbers are
derived.  As randomness from the environment is harvested, it is mixed into
the pool, keeping the level of entropy up.  Every running system has its
own pool, naturally, with its own internal state.  If two systems were to
somehow end up with their entropy pools containing the same data, they
would produce the same sequence of random numbers, for a while at least.
That is something that should never happen.
<p>
But, as Donenfeld pointed out in <a
href="/ml/linux-kernel/20220223131231.403386-1-Jason@zx2c4.com/">a patch
set</a> first released in February, there is a way that two systems can end
up with the same entropy-pool content.  If a running virtual machine is somehow
duplicated, the entropy pool will be duplicated with it.  This can happen
if a machine is checkpointed and restored, or if it forks for any reason.
Once the restored or forked machine starts running, it will reproduce the
sequence of random data created by the previous instance until the addition
of new entropy perturbs the pool.

<p>
Microsoft, it seems, has already addressed this concern in Windows; the
solution takes the form of a "virtual-machine ID" made available via the
ACPI firmware.  When a virtual machine forks or is restarted, the
ID is changed.  The kernel can watch this value and, on
noticing that it has changed, conclude that some sort of virtual-machine
fork has occurred and that action is necessary to keep the random-data
stream unique.  Some virtualization systems, including QEMU, have implemented this
functionality, so it makes sense for Linux to make use of it as well.
<p>
The patch set thus adds a new "vmgenid" driver that makes the
virtual-machine ID available to the kernel.  When this driver is notified
(by the ACPI 
firmware) of a change, it checks the ID and, if that has
changed, calls a new function (<tt>crng_vm_fork_inject()</tt>) to inform
the RNG that it needs to muddy up the entropy pool.  This is done by mixing
in that same virtual-machine ID.  It is not claimed to be the ultimate in
security, but it does 
address the immediate problem; Donenfeld intends to merge this work for 5.18.
<p>
This project does not stop there, though; in a later email, Donenfeld <a
href="/ml/linux-kernel/Yh4+9+UpanJWAIyZ@zx2c4.com/">described</a> the
changes he would like to make next.  He started by complaining about the
design of Microsoft's solution, which has a race condition designed into
it.  The kernel cannot respond to a virtual-machine fork until it notices
that the generation ID has changed; the new virtual machine could run for
some time before that happens, and it will generate duplicate random
numbers during that time.  It would have been better, he said, to provide a
simple "generation counter" that could be quickly polled by the CPU every
time random data is requested; that would allow a change to be caught
immediately.  "<q>But that's not what we have, because Microsoft didn't
collaborate with anybody on this, and now it's implemented in several
hypervisors</q>".
<p>
Having gotten that off his chest, he proceeded to the real task at hand:
propagating the news about a virtual-machine fork to other interested
kernel subsystems.  He originally envisioned creating a new
power-management event to serve as a sort of notifier, but that was seen as
an awkward fit; a virtual-machine fork isn't really related to power
management in the end.  So Donenfeld <a
href="/ml/linux-kernel/20220301231038.530897-1-Jason@zx2c4.com/">posted a
new solution</a> creating a separate notifier (using the kernel's existing
notifier mechanism) to inform subsystems.  The <a
href="/ml/linux-kernel/20220301231038.530897-4-Jason@zx2c4.com/">first
user</a> is, unsurprisingly, the WireGuard VPN, which needs to know about
such events:
<p>
<blockquote class="bq">
	When a virtual machine forks, it's important that WireGuard clear
	existing sessions so that different plaintext is not transmitted
	using the same key+nonce, which can result in catastrophic
	cryptographic failure.
</blockquote>
<p>
User-space code may benefit from knowing about virtual-machine forks as
well; for example, the Samba server may want to reset sessions in that
situation.  For user space, Donenfeld <a
href="/ml/linux-kernel/20220309215907.77526-1-Jason@zx2c4.com/">proposes</a>
adding a new virtual file that programs can poll for VM-fork notifications.
This file is currently located in <tt>/proc/sys</tt>, even though it is not
a true sysctl knob in that it cannot be written to as a way of tuning
system behavior.

<p>
Response to this work has been positive, overall; kernel developers tend to
have little appetite for catastrophic cryptographic failure.  That said,
Greg Kroah-Hartman did <a 
href="/ml/linux-kernel/Yh8wjrf7HVf56Anw@kroah.com/">observe</a>: "<q>It
seems crazy that the 'we just were spawned as a new vm' notifier is based
in the random driver, but sure, put it here for now!</q>"  So this work,
too, seems destined for merging for the 5.18 kernel release.  That should
help to close a vulnerability that many of us may not have ever been aware
existed.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Random_numbers">Random numbers</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Random_number_generation">Security/Random number generation</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Virtualization">Virtualization</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/887207/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor887672"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2022 18:43 UTC (Fri)
                               by <b>bof</b> (subscriber, #110741)
                              [<a href="/Articles/887672/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmmm. I understand checkpoint+restore as a migration concept, but my mind&#x27;s coming up blank with scenarios where a virtual machine would actually be forked into two completely identical copies (that now notice they are to be not so identical in a growing number of ways?)<br>
<p>
I mean, duplicate MACs? Duplicate IPs? Huh? What do I miss?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887672/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887681"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2022 21:14 UTC (Fri)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/887681/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fast startup: boot your VM to the point where it&#x27;s about to invoke userspace, then fork it.<br>
<p>
Fast per-client VMs: boot your VM to the point where it&#x27;s listening for connections, then fork it.<br>
<p>
You don&#x27;t need to worry about IPs or MAC addresses if your VMM is handling routing and giving your VM an internal-use-only IP.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887681/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor887686"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2022 0:58 UTC (Sat)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/887686/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Could be good for software upgrades for services that have state. Before you start, fork the VM; after you&#x27;ve done the upgrade and tested the system, you can decide which fork to keep.<br>
<p>
There are various applications for checkpoint+restore+restore+..., where the copies are mostly not contemporaneous; it&#x27;s really nice for being able to produce test environments that aren&#x27;t full of the remains of previous testing, for example, but you generally don&#x27;t need to have your pristine copy running all the time and being forked into new copies while live.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887686/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor887685"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2022 0:00 UTC (Sat)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/887685/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Too many connotations are dropped on &quot;random numbers.&quot;  Some folks refer to them as &quot;randumb.&quot;  NIST has been pushing on expanding definitions to clarify things for those who already understand.  I&#x27;m not aware of any effort to reach general understanding, but this also is **NOT** my area beyond being a user in a few disparate applications.<br>
<p>
There are &quot;true&quot; random numbers.  Defining that (to me) is as difficult as defining true.<br>
<p>
There are &quot;cryptographic&quot; random numbers.  Far, far outside my bailiwick.<br>
<p>
There are &quot;sufficient&quot; but reproducible random numbers.  A climate simulation may depend on random numbers for everything from error bounds to intermediate perturbations.  If you cannot reproduce the results across a variety of hardware, using those results in international negotiations is, um, tricky.  Similar for software debugging where it is my problem.<br>
<p>
And certainly there are more.<br>
<p>
Randomness is our construct.  In our views of nature, sometimes random becomes a pattern.  The issue in my uneducated opinion is defining what &quot;random&quot; means in each context.  I work with randomized algorithms, so I understand *a few* of those contexts.  It ain&#x27;t easy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887685/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2022 1:14 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/887687/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There are &quot;true&quot; random numbers. Defining that (to me) is as difficult as defining true.</font><br>
<p>
Here&#x27;s my attempt: A number X is &quot;truly&quot; random if:<br>
<p>
1. We know that X follows some specific distribution. For example, we know that &quot;the number of radioactive decay events in an hour&quot; (or a minute, or a second) follows a Poisson distribution with the lambda parameter determined by the quantity of the radioactive element and its half-life (as well as the length of the period sampled). Similarly, &quot;the number of heads when you flip ten fair coins&quot; follows a binomial distribution with p=0.5 and n=10.<br>
2. We know that CDF(X) is not correlated with any quantity that can be physically measured, other than X itself. For radioactive decay events, this is believed to be true under our current theory of physics. For coin flips, it may be correlated with the initial orientation of the coin as well as other physical factors, but those are certainly very *hard* to measure.<br>
3. Nobody knows the value of X (yet).<br>
<p>
<font class="QuotedText">&gt; There are &quot;cryptographic&quot; random numbers. Far, far outside my bailiwick.</font><br>
<p>
To a rough approximation, &quot;cryptographically secure&quot; means &quot;close enough to truly random that it&#x27;s unrealistic an attacker will be able to predict the value in practice.&quot; Depending on the application, there may be an allowance for &quot;the attacker can make limited predictions, but they are not accurate enough to be useful for real, plausible cryptanalytic attacks against a particular algorithm.&quot; For example, AES-256 provides 256-bit security, meaning that a naive brute-force attack would require trying 2^256 possible keys. If the key was generated in such a way that the attacker can imperfectly predict 2 bits of it, then it still has at least 254-bit security, and 2^254 is still stupidly huge. In practice it&#x27;s more complicated than that, because you don&#x27;t actually do a brute force attack, instead you do various more complicated attacks which I don&#x27;t fully understand, and those don&#x27;t require the full 2^256 attempts in the first place. But that&#x27;s OK, because even a much &quot;smaller&quot; number like 2^100 is still too big for a practical attack.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor887694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2022 7:02 UTC (Sat)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/887694/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s always only a matter of the difficulty to predict these numbers. True randomness today will only be considered as moderately predictable today. What we qualify as random is something which behaves in a way that depends on too many factors for us to analyze, model and predict. For example, a century ago, some might have decided that shooting stars could be a perfect source of random numbers. Nowadays with good observation and modeling these could be considered as highly predictable for some. Today we consider radioactive decay as a good random source. Maybe in 100 years someone comes with a model that makes them highly predictable.<br>
<p>
That&#x27;s why in the end it&#x27;s important to combine as many dependencies as possible. Even if some are observable by some, as long as you mix as many different ones as possible, you progressively remove the ability for any observer to observe the whole model.<br>
<p>
In the situation here, I think that jitter entropy and general system activity will quickly make the pools diverge. Probably that after a few seconds to minutes the two systems will be completely independent. But for the short initial time one could be vulnerable to the analysis performed on the other one, especially if the target hardware is known and allows the observer to try to mimmick it very closely and limit the divergence.<br>
<p>
Thus overall Jason&#x27;s work on this is definitely useful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887808"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2022 14:31 UTC (Mon)
                               by <b>plugwash</b> (subscriber, #29694)
                              [<a href="/Articles/887808/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In the situation here, I think that jitter entropy and general system activity will quickly make the pools diverge. Probably that after a few seconds to minutes the two systems will be completely independent. But for the short initial time one could be vulnerable to the analysis performed on the other one, especially if the target hardware is known and allows the observer to try to mimmick it very closely and limit the divergence.</font><br>
<p>
One immediate question that springs to mind is &quot;what about userland&quot;?<br>
<p>
As you say the kernel RNGs will likely diverge quickly, so the window of opportunity for failure is fairly narrow. OTOH RNGs in userland that are rarely or never re-seeded and are used in a predictable way may remain in sync for much longer. <br>
<p>
Crypto libraries often already have code in place to defend against  fork calls, but presumably cloning the whole VM would go unnoticed by such countermeasures.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887808/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor890050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 2, 2022 7:05 UTC (Sat)
                               by <b>sammythesnake</b> (guest, #17693)
                              [<a href="/Articles/890050/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Today we consider radioactive decay as a good random source. Maybe in 100 years someone comes with a model that makes them highly predictable.</font><br>
<p>
What you&#x27;re describing here is what&#x27;s called a &quot;hidden variable model&quot; in which there are unknown substrates below the observed behaviour that could (in principle) become known, modelled, and predicted (you&#x27;d still have the challenge of making suitable observations in the face of engineering limitations and the Heisenberg uncertainty principle of course...)<br>
<p>
I understand that there are proofs for various quantum phenomena that preclude the possibility of such hidden variables. Off the top of my head, I&#x27;m not 100% certain that nuclear decay is one of the phenomena covered by these proofs, but I think it is.<br>
<p>
I once tried to follow a description of such a proof, but ended up glassy eyed and needing a nap...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor887711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2022 20:47 UTC (Sat)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/887711/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One should not speak about random numbers, but about random numbers generators (RNG).<br>
They are:<br>
1/ ideal RNG: each bit is an independent random variable. We have no way to build that.<br>
<p>
2/ hardware RNG: each bit is given by a physical process we expect to be random (slow)<br>
<p>
3/ Pseudo-RNG (PRNG): deterministic state machine that produce output that look statically like an ideal RNG for batchs of length at most something (e.g 2^32) (usually fast) <br>
<p>
4/ Cryptographicaly-secure PRNG: a PRNG where it is believed it is computationnaly impossible to recover the state from a batch of outputs. (Note that If you have unlimited computational power, you can break it by trying all possible state). <br>
<p>
5/ Backdoored PRNG: as 4, but there is a key that allow to recover the state from a medium-sized batch of output.<br>
<p>
6/ Mixed RNG: mix of 2/ and 3/ as used by the kernel. A physical process is used to change the state of the PRNG from time to time. Compromise between speed, security and hardware integrity.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887727"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2022 5:04 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/887727/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another way of characterizing a PRNG: PRNGs &quot;stretch out&quot; a small amount of entropy (the seed) over a large number of bits (the output). This creates the intuitive concern that, if you have too little entropy in the seed, even the best PRNG algorithm will struggle to produce high-quality randomness from it (because you can&#x27;t manufacture entropy out of thin air) - and that is indeed a real (solvable) problem! The solution is, essentially, &quot;don&#x27;t do that&quot; - you have to put enough entropy into the seed initially, and periodically re-seed with HRNG output often enough, or else the PRNG will eventually become predictable based on its past outputs. This turns out to be sufficiently complicated, difficult, and hardware-specific that it&#x27;s worth building into the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887727/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887728"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2022 9:06 UTC (Sun)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/887728/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For reference, if I&#x27;m looking at the right numbers, the amount of rng iterations you&#x27;d need to read from the current kernel crng for the seeding entropy not to be sufficient is roughly 2^232, which should be more than enough to extract thousands of petabytes for every atom on earth. If you&#x27;re interested in reading any less than that, reseeding isn&#x27;t really relevant from a cryptographic or entropy perspective. Of course it doesn&#x27;t really hurt to just mix some more bits into the pool before that point in case the original pool was compromised via other means (side channels, vulnerabilities, vm forks), but that&#x27;s really just a defense in depth measure.*<br>
<p>
* I am not a cryptographer, this is not cryptography advice<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887728/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887752"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2022 22:39 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/887752/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I haven&#x27;t looked into the Linux kernel&#x27;s implementation in particular, but that sounds implausible to me. The problem is that we have two conflicting goals here:<br>
<p>
1. We want each individual output to be as unpredictable as possible. That means it should contain the maximum possible amount of entropy.<br>
2. We want each individual output to provide as little information about the PRNG&#x27;s internal state as possible. That means it should contain the *minimum* possible amount of entropy.<br>
<p>
Obviously, you can&#x27;t satisfy both goals, so you have to compromise on one or the other, or else you have to use something other than the PRNG&#x27;s internal state (e.g. RDRAND, jitter, etc.) to increase the entropy of each individual output from a non-PRNG-derived source. Now, I&#x27;m assuming that the kernel does use such a non-PRNG source, but that&#x27;s mathematically equivalent to expanding the entropy pool to include other factors outside the control of the PRNG itself - so you still run into the same &quot;we&#x27;re running out of entropy&quot; problem as before. The net amount of entropy entering the entire system as a whole must equal or exceed the net amount of entropy leaving the system via PRNG outputs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887752/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887768"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2022 11:20 UTC (Mon)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/887768/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think your analysis is strictly mathematically correct. However it does also illustrate why using the concept of entropy in the context of random number generation creates huge misunderstandings and further mistakes like blocking /dev/random.<br>
<p>
Cryptographic hash functions are designed such that if you have a hash function of size n you need on the order of 2^n inputs to determine any bit of the plaintext with odds &gt;50%. For BLAKE-256 the best known attack is 2^232, which is the number I was citing. So while it is mathematically true that entropy is leaving the pool through the hash function, cryptography means that entropy is infeasible to recover. Every bit is so heavily entangled with every other bit that you get no information until you&#x27;ve broken effectively the entire hash.<br>
<p>
If you like, although it&#x27;s not completely accurate, you can think of it like the bits of information gained from the output of the cryptographic hash function being smeared very thin across it&#x27;s layers and layers of hidden inputs and outputs, never thick enough to get over 50% at the output until you collect a truly extraordinary number of them.<br>
<p>
Another way to think about it is via encryption. If you encrypt 16 bytes with a key and the output is 16 bytes, that output must appear random to an outside observer, otherwise the algorithm would leak information. If you used that to encrypt the pool with itself and handed that out, would you be removing 16 bytes from the pool? The bits are correlated, sure, but what does that mean you if you can not determine the correlation? Tracking entropy &quot;movement&quot; isn&#x27;t really a useful concept at that point.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887768/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor887769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2022 11:23 UTC (Mon)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/887769/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Now, I&#x27;m assuming that the kernel does use such a non-PRNG source, but that&#x27;s mathematically equivalent to expanding the entropy pool to include other factors outside the control of the PRNG itself - so you still run into the same &quot;we&#x27;re running out of entropy&quot; problem as before. The net amount of entropy entering the entire system as a whole must equal or exceed the net amount of entropy leaving the system via PRNG outputs.</font><br>
<p>
The trick is that, even though you might have in theory exhausted the entropy of the system, the only known way to take advantage of it is a brute force search. With a large enough state (around a couple hundred bits), brute force search becomes infeasible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor887770"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2022 13:25 UTC (Mon)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/887770/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Conceptually it&#x27;s useful to consider RNGs on the basis of: what&#x27;s my chance of guessing the next value given some information X.<br>
<p>
Ideal RNGs are unpredictable, no matter what information you have. That&#x27;s why cryptographers love them: the proofs become very simple.<br>
<p>
CS-PRNGs are intended to be totally predicable if you know the internal state, but not if you just know some of the output. <br>
<p>
So in the case of forked VMs, supposed you started one VM up and got a bunch of random numbers. Then you start a second fork. If you are given the two VMIDs, plus the first stream of random numbers, can you predict the random numbers for the new VM? In principle: sure. But you need to think about the computing power required. And you need to decide on a computing model: does it matter if you have a quantum computer?<br>
<p>
Like the discussions about mixing in timing information. Maybe it&#x27;s predictable, but it matters only if the attacker knows what&#x27;s being mixed in. So you&#x27;re better off just mixing everything in and soon as there&#x27;s one source that the attacker doesn&#x27;t know exactly, you&#x27;ve already made it computationally impossible to reverse.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887770/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor887838"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2022 20:19 UTC (Mon)
                               by <b>wittenberg</b> (subscriber, #4473)
                              [<a href="/Articles/887838/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
1/ ideal RNG: each bit is an independent random variable. We have no way to build that.<br>
<p>
We do.  You can buy off-the-shelf random number generators which depend on quantum processes for their randomness.  The first google hit for one is:  <a href="https://www.quintessencelabs.com/products/qstream-quantum-true-random-number-generator/">https://www.quintessencelabs.com/products/qstream-quantum...</a> which claims to offer 1 Gb/sec (after whitening, 8 Gb/sec before whitening).  If quantum processes are not random, we have a huge hole in our understanding of the physics which underlies chips.  Possible, but unlikely.<br>
<p>
I don&#x27;t know about this particular device, but last I checked, similar devices cost about $5000 (US).<br>
<p>
--David<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887838/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor887689"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2022 4:25 UTC (Sat)
                               by <b>Otus</b> (subscriber, #67685)
                              [<a href="/Articles/887689/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How much of a problem is this really? On current (5.16) kernels every call to the CRNG will use a different nonce from RDRAND.<br>
<p>
Sure, there are CPUs that don&#x27;t support it, but how many of them are being used for VM cloning? Seems to me that just mixing in the cycle counter in that case would solve things.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887689/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887750"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2022 22:32 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/887750/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unfortunately, there are/were CPUs that don&#x27;t properly implement RDRAND, but lie and say they do: <a href="https://arstechnica.com/gadgets/2019/10/how-a-months-old-amd-microcode-bug-destroyed-my-weekend/">https://arstechnica.com/gadgets/2019/10/how-a-months-old-...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887750/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887762"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2022 6:06 UTC (Mon)
                               by <b>Otus</b> (subscriber, #67685)
                              [<a href="/Articles/887762/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe the kernel marks those as not supporting RDRAND these days? Again, even a cycle counter would be enough here, since it&#x27;s not about the entropy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887762/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2022 8:43 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/887765/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Read the article. It&#x27;s NOT enough.<br>
<p>
All it takes is an application (which doesn&#x27;t know) to access RDRAND directly, and you&#x27;re in trouble.<br>
<p>
The article gives the example of Wireguard, which when it hits one of these, locks the system HARD. Actually, that could possibly be behind why my system locks up every now and then ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887826"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2022 16:11 UTC (Mon)
                               by <b>Otus</b> (subscriber, #67685)
                              [<a href="/Articles/887826/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah yes, it&#x27;s combining two things. The CRNG reseed could be done differently. The application reseed must happen and requires new functionality.<br>
<p>
I do wonder if the latter should be something more generic (not tied to vmid), since I can easily imagine other cases where you might want to tell everyone to reseed. For example, if you are using something like systemd-random-seed.service to feed entropy you trust more than the kernel&#x27;s entropy collection during boot.<br>
<p>
But anyway, that&#x27;s just academical, clearly something like this is required. Thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887826/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor887692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2022 5:58 UTC (Sat)
                               by <b>mtthu</b> (subscriber, #123091)
                              [<a href="/Articles/887692/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Never really thought about this scenario. One other way to mix in entropy would be to get a random number from the hypervisor somehow. This could also be made available via a driver but would of course not resolve the problem with notification about a fork. A &quot;real&quot; system has more sources of entropy than a VM, thus a mix in into the VMs could make sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor887702"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2022 16:45 UTC (Sat)
                               by <b>rwmj</b> (subscriber, #5474)
                              [<a href="/Articles/887702/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
virt-sysprep can reinject a new random seed into guest disk images: <a href="https://libguestfs.org/virt-sysprep.1.html#random-seed">https://libguestfs.org/virt-sysprep.1.html#random-seed</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887702/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor888183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2022 7:42 UTC (Thu)
                               by <b>gasche</b> (subscriber, #74946)
                              [<a href="/Articles/888183/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We had a similar problem in the OCaml standard library, which is to decide how to evolve the Random Number Generator (RNG) state when spawning a new thread. The Random library exposes a &quot;global random generator&quot;, but in fact there is one random state per thread; the question is how to initialize the random state of a new thread.<br>
<p>
RNG algorithm designers have devised &quot;splittable&quot; generators, which make it possible to separate a single RNG state into two states that look independent. Our solution was to change our PRNG algorithm to use a &quot;splittable&quot; one (we chose LXM: <a href="https://dl.acm.org/doi/abs/10.1145/3485525">https://dl.acm.org/doi/abs/10.1145/3485525</a> ). On `spawn`, the parent thread &quot;splits&quot; its PRNG state, keeps one state and passes the other to the child.<br>
<p>
This has the very good property that the if threads are created (and create threads themselves etc.) and consume random numbers without communication/synchronizing with each other, then the PRNG states and random numbers produced are deterministic -- for a given tree of spawns and draws, the results depend only on the initial PRNG state of the ancestor thread. So, for example, debugging strategies involving fixing a random seed at program startup for reproducibility still work in a multi-threaded scenario. (In contrast, if you initialize new threads PRNG states by re-seeding, or if you maintain a single PRNG state protected by a mutex, the results will depend on reseeding input or the non-deterministic scheduling of the threads with respect to each other.)<br>
<p>
Of course, this works because we have full control of the OCaml runtime: we can add specific code when a new thread is spawned, that is run on the parent at spawn time. In the situations of VMs as described, this would correspond to notifying the VM that it is about to be cloned, and giving it the ability to change its own state and also decide parts of the new clone state. There is no mechanism providing this amount of control, and working around this is the main point of the article. Unfortunately, the vmgenid approach means that the child will find out after the fact that it was cloned, but the parent is never told, so the &quot;splitting&quot; approach is not applicable -- the splitting operation modifies both the parent and the child PRNG state.<br>
<p>
Some PRNG generators support a &quot;jump&quot; primitive where the PRNG state advances by many iterations (for example 2^128) at once. Upon finding out that it is a cloned child, a VM could &quot;jump&quot; by a fixed amount. Unfortunately, this does not solve the problem of guaranteeing independence of PRNG states. It works if you clone a VM (1 jump), then clone the cloned VM again (2 jumps), etc., but it does not work if you clone the original VM several time: all copies will have jumped the same amount, so they end up in the same state. With this little amount of control over the cloning protocol, it looks like reseeding is the only option.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/888183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor895983"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2022 8:29 UTC (Mon)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/895983/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This &#x27;vm generation id&#x27; value can be of use to userspace as well. For instance, Active Directory Domain Services use it to ensure the correctness of replicated &amp; uniqueness of generated data in the event of a virtualized domain controller being snapshotted &amp; rolled back.<br>
<p>
<a href="https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/get-started/virtual-dc/virtualized-domain-controller-architecture">https://docs.microsoft.com/en-us/windows-server/identity/...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/895983/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor919709"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Random numbers and virtual-machine forks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 12, 2023 4:22 UTC (Thu)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/919709/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We added a similar vmgenid driver in FreeBSD recently (2019), too.[1].  VM generation change events are published to the rest of the system via the FreeBSD EVENTHANDLER subsystem's acpi_vmgenc_event event.  I'm super pleased to see all of the work Donenfeld has been doing to improve the Linux RNG lately.<br>
<p>
[1]: <a href="https://github.com/freebsd/freebsd-src/commit/ffac39deae0a2e50aa8d1197d15b8d0bb7e778fd">https://github.com/freebsd/freebsd-src/commit/ffac39deae0...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919709/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
