        <!DOCTYPE html>
        <html lang="en">
        <head><title>Solid-state storage devices and the block layer [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/408428/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/408340/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/408428/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Solid-state storage devices and the block layer</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 4, 2010</br>
           </div>
Over the last few years, it has become clear that one of the most pressing
scalability problems faced by Linux is being driven by solid-state storage
devices (SSDs).  The rapid increase in performance offered by these devices
cannot help but reveal any bottlenecks in the Linux filesystem and block
layers.  What has been less clear, at times, is what we are going to do
about this problem.  In his LinuxCon Japan talk, block maintainer Jens
Axboe described some of the work that has been done to improve block layer
scalability and offered a view of where things might go in the future.
<p>
While workloads will vary, Jens says, most I/O patterns are dominated by
random I/O and relatively small requests.  Thus, getting the best results
requires being able to perform a large number of I/O operations per second
(IOPS).  With a high-end rotating drive (running at 15,000&nbsp;RPM), the
maximum rate possible is about 500&nbsp;IOPS.  Most real-world drives, of
course, will have significantly slower performance and lower I/O rates.
<p>
SSDs, by eliminating seeks and rotational delays, change everything; we
have gone from hundreds of IOPS to hundreds of thousands of IOPS in a very
short period of time.  A number of people have said that the massive
increase in IOPS means that the block layer will have to become more like
the networking layer, where every bit of per-packet overhead has been
squeezed out over time.  But, as Jens points out, time is not in great
abundance.  Networking technology went from 10Mb/s in the 1980's to 10Gb/s

<a href="/Articles/408449/"><img
src="https://static.lwn.net/images/conf/2010/LC-Tokyo/JensAxboe2-sm.jpg" width=125 height=161
alt="[Jens Axboe]" border=0 align="right"></a>

now, the better part of 30 years later.  SSDs have forced a similar jump
(three orders of magnitude) in a much shorter period of time - and every
indication suggests that devices with IOPS rates in the millions are not
that far away.  The result, says Jens, is "a big problem."
<p>
This problem pops up in a number of places, but it usually comes down to
contention for shared resources.  Locking overhead which is tolerable at
500 IOPS is crippling at 500,000.  There are also problems with contention
at the hardware level too; vendors of storage controllers have been caught
by surprise by SSDs and are having to scramble to get their performance up
to the required levels.  The growth of multicore systems naturally makes
things worse; such systems can create contention problems throughout the
kernel, and the block layer is no exception. So much of the necessary work
comes down to avoiding contention.
<p>
Before that, though, some work had to be done just to get the block layer
to recognize that it is dealing with an SSD and react accordingly.
Traditionally, the block layer has been driven by the need to avoid head
seeks; the use of quite a bit of CPU time could be justified if it managed
to avoid a single seek.  SSDs - at least the good ones - care a lot less
about seeks, so expending a bunch of CPU time to avoid them no longer makes
sense.  There are various ways of detecting SSDs in the hardware, but they
don't always work, especially with the lower-quality devices.  So the block
layer exports a flag under
<p>
<pre>
    /sys/block/<i>&lt;device&gt;</i>/queue/rotational
</pre>
<p>
which can be used to override the system's notion of what kind of storage
device it is dealing with.
<p>
Improving performance with SSDs can be a challenging task.  There is no
single big bottleneck which is causing performance problems; instead, there
are numerous small things to fix.  Each fix yields a bit of progress, but
it mostly serves to highlight the next problem.  Additionally, performance
testing is hard; results are often not reproducible and can be perturbed by
small changes.  This is especially true on  larger systems with more CPUs.
Power 
management can also get in the way of the generation of consistent results.
<p>
One of the first things to address on an SSD was queue plugging.  On a
rotating disk, the first I/O operation to show up in the request queue will
cause the queue to be "plugged," meaning that no operations will actually
be dispatched to the hardware.  The idea behind plugging is that, by
allowing a little time for additional I/O requests to arrive, the block
layer will be able to merge adjacent requests (reducing the operation
count) and sort them into an optimal order, increasing performance.
Performance on SSDs tends not to benefit from this treatment, though there
is still a little value to merging requests.  Dropping (or, at least,
reducing) plugging not only 
eliminates a needless delay; it also reduces the need to take the queue
lock in the process.
<p>
Then, there is the issue of request timeouts.  Like most I/O code, the
block layer needs to notice when an I/O request is never completed by the
device.  That detection is done with timeouts.  The old implementation
involved a separate timeout for each outstanding request, but that clearly
does not scale when the number of such requests can be huge.  The answer
was to go to a per-queue timer, reducing the number of running timers
considerably.
<p>
Block I/O operations, due to their inherently unpredictable execution
times, have traditionally contributed entropy to the kernel's random number
pool.  There is a problem, though: the necessary call to
<tt>add_timer_randomness()</tt> has to acquire a global lock, causing
unpleasant systemwide contention.  Some work was done to batch these calls
and accumulate randomness on a per-CPU basis, but, even when batching 4K
operations at a time, the performance cost was significant.  On top of it
all, it's not really clear that using an SSD as an entropy source makes a
lot of sense.  SSDs lack mechanical parts moving around, so their
completion times are much more predictable.  Still, for the moment, SSDs
contribute to the entropy pool by default; administrators who would
like to change that behavior can do so by changing the
<tt>queue/add_random</tt> sysfs variable.
<p>
There are other locking issues to be dealt with.  Over time, the block
layer has gone from being protected by the big kernel lock to a block-level
lock, then to a per-disk lock, but lock contention is still a problem.  The
I/O scheduler adds contention of its own, especially if it is performing
disk-level accounting.  Interestingly, contention for the locks themselves
is not 
usually the problem; it's not that the locks are being held for too long.
The big problem is the cache-line bouncing caused by moving the lock
between processors.  So the traditional technique of dropping and
reacquiring locks to reduce lock contention does not help here - indeed, it
makes things worse.  What's needed is to avoid taking the lock altogether.
<p>
Block requests enter the system via <tt>__make_request()</tt>, which is
responsible for getting a request (represented by a BIO structure) onto the
queue.  Two lock acquisitions are required to do this job - three if the
CFQ I/O scheduler is in use.  Those two acquisitions are the result of a
lock split done to reduce contention in the past; that split, when the
system is handling requests at SSD speeds, makes things worse.  Eliminating
it led to a roughly 3% increase in IOPS with a reduction in CPU time on a
32-core system.  It is, Jens says, a "quick hack," but it demonstrates the
kind of changes that need to be made.
<p>
The next step for this patch is to drop the I/O request allocation batching
- a mechanism added to increase throughput on rotating drives by allowing
the simultaneous submission of multiple requests.  Jens also plans to drop
the allocation accounting code, which tracks the number of requests in
flight at any given time.  Counting outstanding I/O operations requires
global counters and the associated contention, but it can be done without
most of the time.  Some accounting will still be done at the request queue
level to ensure that some control is maintained over the number of
outstanding requests.   Beyond that, there is some per-request accounting
which can be cleaned up and, Jens thinks, request completion can be made
completely lockless.  He hopes that this work will be ready for merging
into 2.6.38.
<p>
Another important technique for reducing contention is keeping processing
on the same CPU as often as possible.  In particular, there are a number of
costs which are incurred if the CPU which handles the submission of a specific I/O request is
not the CPU which handles that request's completion.  Locks are bounced
between CPUs in an unpleasant way, and the slab allocator tends not to
respond well when memory allocated on one processor is freed elsewhere in
the system.  In the networking layer, this problem has been addressed with
techniques like <a href="http://lwn.net/Articles/362339/">receive packet
steering</a>, but, unlike some networking hardware, block I/O controllers
are not able to direct specific I/O completion interrupts to specific
CPUs.  So a different solution was required.
<p>
That solution took the form of <tt>smp_call_function()</tt>, which performs
fast cross-CPU calls.  Using <tt>smp_call_function()</tt>, the block I/O
completion code can direct the completion of specific requests to the CPU
where those requests were initially submitted.  The result is a relatively
easy performance improvement.  A dedicated administrator who is willing to
tweak the system manually can do better, but
that takes a lot of work and the solution tends to be fragile.  This
code - which was merged back in 2.6.27 and made the default in 2.6.32 -
is an easier way that takes away a fair amount of the pain of cross-CPU 
contention.  Jens 
noted with pride that the block layer was not chasing the networking code
with regard to completion steering - the block code had it first.
<p>
On the other hand, the <a
href="http://lwn.net/Articles/346219/">blk-iopoll</a> interrupt mitigation
code was not just inspired by the networking layer - some of the code was
"shamelessly stolen" from there.  The blk-iopoll code turns off completion
interrupts when I/O traffic is high and uses polling to pick up completed
events instead.  On a test system, this code reduced 20,000
interrupts/second to about 1,000.  Jens says that the results are less
conclusive on real-world systems, though.
<p>
An approach which "has more merit" is "context plugging," a rework of the
queue plugging code.  Currently, queue plugging is done implicitly on I/O
submission, with an explicit unplug required at a later time.  That has
been the source of a lot of bugs; forgetting to unplug queues is a common
mistake to make.  The plan is to make plugging and unplugging fully
implicit, but give I/O 
submitters a way to inform the block layer that more requests are coming
soon.  It makes the code more clear and robust; it also gets rid of a lot
of expensive per-queue state which must be maintained.  There are still
some problems to be solved, but the code works, is "tasty on many levels,"
and yields a net reduction of some 600 lines of code.  Expect a merge in
2.6.38 or 2.6.39.
<p>
Finally, there is the "weird territory" of a multiqueue block layer - an
idea which, once again, came from the networking layer.  The creation of
multiple I/O queues for a given device will allow multiple processors to
handle I/O requests simultaneously with less contention.  It's currently
hard to do, though, because block I/O controllers do not (yet) have
multiqueue support.  That problem will be fixed eventually, but there will
be some other challenges to overcome: I/O barriers will become
significantly more complicated, as will per-device accounting.  All told,
it will require some major changes to the block layer and a special I/O
scheduler.  Jens offered no guidance as to when we might see this code
merged. 
<p>
The conclusion which comes from this talk is that the Linux block layer is
facing some significant challenges driven by hardware changes.  These
challenges are being addressed, though, and the code is moving in the
necessary direction.  By the time most of us can afford a system with one
of those massive, 1&nbsp;MIOPS arrays on it, Linux should be able to use it
to its potential.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Block_layer-Solid-state_storage_devices">Block layer/Solid-state storage devices</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Solid-state_storage_devices">Solid-state storage devices</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#LinuxCon_Japan-2010">LinuxCon Japan/2010</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/408428/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor408466"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2010 23:38 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/408466/">Link</a>] (30 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Still, for the moment, SSDs still contribute to the entropy pool by default; administrators who would like to change that behavior can do so by changing the <tt>queue/add_random</tt> sysfs variable.
</blockquote>

Well, yes, but this isn't in any released kernel yet.

      
          <div class="CommentReplyButton">
            <form action="/Articles/408466/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408512"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 5:24 UTC (Tue)
                               by <b>shemminger</b> (subscriber, #5739)
                              [<a href="/Articles/408512/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually many types of devices also bogusly report that they provide<br>
entropy when they do not.  For example, Xen drivers are purely virtual<br>
and therefore deterministic.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408512/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408519"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 6:03 UTC (Tue)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/408519/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"For example, Xen drivers are purely virtual and therefore deterministic."<br>
<p>
What does that matter, if they ultimately connect to underlying physical devices which are not?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408519/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408527"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 6:42 UTC (Tue)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/408527/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
_If_. They might not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408527/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408846"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 17:01 UTC (Wed)
                               by <b>drag</b> (guest, #31333)
                              [<a href="/Articles/408846/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I know that I have had problems with ssh hanging on new nodes on xen due lack of entropy. But I think this is no longer a problem. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408846/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor408548"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 10:25 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/408548/">Link</a>] (25 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And many devices which often do provide entropy (e.g. the network) were specified to never provide any, because an attacker can sometimes control *some* of the packets on it. I never understood that, and now my headless and virtual systems have next to no entropy at all (or did, until I got an entropy key, and now I don't care where the kernel gets its entropy sources from :) )<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408548/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408587"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 15:51 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408587/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <P>Off-topic rant:
</P><P>
I don't understand why more processors don't include a proper hardware random number generator.  It's a classic case of something that is <I>significantly</I> easier to do in hardware, I'd think.
</P><P>
I mean, sure, you could try to derive a few bits of entropy here, an few bits there from what is otherwise a deterministic system.  It's maddeningly frustrating, though, and you have to apply new thought and new techniques every time your system assumptions change.  Your case is just such a case, and it sounds like you just punted to a dedicated hardware solution.
</P><P>
Modern CPUs have accelerators for all sorts of things as standard equipment.  Why not random numbers?  We spend countless millions of transistors on ever larger caches and datapaths.  Surely they could spare a few for a really high quality true random number generator.
</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/408587/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408614"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 17:09 UTC (Tue)
                               by <b>strappe</b> (guest, #53440)
                              [<a href="/Articles/408614/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      All VIA x86-compatible processors since the C3 (introduced 2003?) have included a hardware random number generator based on quantum effects; it produces millions of random bits each second, and is accessible with a non-privileged instruction. AFAIK, their opcode choice is unused by either AMD or Intel, so those companies could implement similar functionality (an infinitesimal bit of silicon) and we would have a standard solution at least across the x86 architecture going forward.
      
          <div class="CommentReplyButton">
            <form action="/Articles/408614/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408627"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 17:22 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408627/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I was aware of VIA's accelerator.  It boggles me that Intel and AMD bothered to put AES acceleration on their chips without getting something more basic and generic like random numbers on there too.  Is it a verification issue?  What's holding them back?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408627/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408640"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 18:24 UTC (Tue)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/408640/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not as easy as it seems.  You can generate random bits, but they are highly skewed, with different skews depending on the temperature, etc.  You need to extract a more regular randomness from them, and extractors can require a good bit of space.  The extractors I know (theory, not actual architecture) also must be running continually, sucking power.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408640/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408652"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 19:10 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408652/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <P>VIA's approach on the C3 doesn't sound too unwieldy.  This <A HREF="http://www.via.com.tw/en/downloads/whitepapers/initiatives/padlock/evaluation_padlock_rng.pdf">white paper analyzing the generator's output</A> makes for an informative read.  The punch line is that it looks like a pretty reasonable source of entropy as long as you do appropriate post processing.  The random numbers it generates aren't caveat free, but they're heckuva lot better than disk seeks and keypresses.</P>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408652/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 8:40 UTC (Wed)
                               by <b>pcampe</b> (guest, #28223)
                              [<a href="/Articles/408785/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't understand why they didn't follow the guidelines in NIST Standard 800-22 (rev 1a), "A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications".<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408811"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 13:56 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408811/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>Probably because they didn't have a time machine.  ;-)  The document you reference was written this year.  The white paper I reference was written in 2003.  And if you meant Rev 1, that didn't come out until 2008.
</P><P>
Maybe you meant the original 800-22?  <I>That</I> one came out in 2001.
</P><P>
(Dates came from <A HREF="http://csrc.nist.gov/publications/PubsSPArch.html">here.</A>)
</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/408811/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor408638"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 18:26 UTC (Tue)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/408638/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      The AES accelerator probably lets them tick a required-feature box for some government programme or other.
      
          <div class="CommentReplyButton">
            <form action="/Articles/408638/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408648"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 18:46 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408648/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>If anything, it would make it harder for them to export the chips outside of the United States without getting special approval from the Feds.  Cryptographic hardware is a <A HREF="http://www.fas.org/spp/starwars/offdocs/itar/p121.htm#C-XIII">munition under ITAR.</A>  
</P><P>
I remember there was some concern awhile back when we put our AES implementation in ROM on some devices, because it calculated AES "too quickly" for some peoples' taste.  We ended up making that part of the ROM protected (ie. not user accessible) so that it was only used for boot authentication.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/408648/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor408799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 11:27 UTC (Wed)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/408799/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; without getting something more basic and generic like random numbers on there too.</font><br>
<p>
The solution has always been obvious to cryptographers. Use a solid cryptographical pseudorandom RNG; as long as there is _some_ truly random data in its input -- 128 or so bits worth -- the output will always be irreversible. As long as this randomness exists, it doesn't matter that the attacker can predict all other input.<br>
<p>
In fact, hardware RNGs should _never_ be used directly, because there may be manufacturing flaws or deliberate sabotage. And unlike deterministic algorithms like AES, non-deterministic hardware RNG sources are almost impossible to verify completely. Also it's really quite easy to replace the hw RNG with a deterministic PRNG that passes all randomness tests, yet whose output is entirely predictable to its designer.<br>
<p>
So at most, the hw RNG is just one of several randomness sources on any system. As such cryptographers in general don't consider it worthwhile -- only on diskless embedded systems where there really aren't any entropy sources.<br>
<p>
Unfortunately /dev/random is a poor legacy choice in Linux that goes against this concept.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2010 12:24 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/408999/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Diskless embedded systems" of course includes "all virtual machines". So there are a lot of them.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor409004"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2010 12:48 UTC (Thu)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/409004/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For virtual machines you already have a paravirtual RNG device called 'virtio-rng' (CONFIG_HW_RANDOM_VIRTIO).<br>
<p>
But in general, virtual machine disk I/O still reaches a physical disk sooner or later, so entropy can be successfully gathered from interrupt timings. In some virtualization scenarios, you wouldn't want the VM to access host-CPU-specific features anyway.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/409004/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor408655"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 19:01 UTC (Tue)
                               by <b>patrick_g</b> (subscriber, #44470)
                              [<a href="/Articles/408655/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      >>> <i>I don't understand why more processors don't include a proper hardware random number generator. It's a classic case of something that is significantly easier to do in hardware, I'd think.</i><br><br>

I think Intel will is working on this.<br>
See these link : http://www.technologyreview.com/computing/25670/
      
          <div class="CommentReplyButton">
            <form action="/Articles/408655/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 3:36 UTC (Wed)
                               by <b>PaulWay</b> (subscriber, #45600)
                              [<a href="/Articles/408765/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Purely an anecdote, but the other day I had the occasion to use shred to shred two disks at once.  The machine was a modern Intel Core Quad system, and the disks were writing at 60MBytes/sec with 3% CPU load.  Since modern shred just writes a number of layers of pure random data from /dev/urandom, I have to assume that there was either hardware crypto or randomness generation going on there.  Who knew?!<br>
<p>
Have fun,<br>
<p>
Paul<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408767"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 3:47 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408767/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <P>Well, <TT>/dev/urandom</TT> <A HREF="https://secure.wikimedia.org/wikipedia/en/wiki//dev/random">doesn't block when the kernel entropy pool runs out.</A>  The hardware crypto acceleration may've been getting used, but that's orthogonal to the question of gathering entropy.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/408767/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408903"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 19:34 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/408903/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hehe, so shred was using entropy collected from the disk controllers, collected from shred writing to disks..<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408903/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor408700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 21:58 UTC (Tue)
                               by <b>nowster</b> (subscriber, #67)
                              [<a href="/Articles/408700/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I don't understand why more processors don't include a proper hardware random number generator.</font><br>
<p>
It's actually a hard problem to provide a cheap reliable hardware random number generator. If you look at the effort that a device like Simtec's Entropy Key takes to ensure that each chunk of randomness it delivers is truly random, you'll see why a random number generator is not something that a CPU designer should drop on a spare corner of a CPU die last thing on a Friday afternoon. Semiconductor junction noise generators can be affected by environmental influences: an RNG on a CPU die running hot might have a bias compared with the same one when the CPU is idle and cooler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408768"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 3:51 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408768/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <P>I linked <A HREF="http://www.via.com.tw/en/downloads/whitepapers/initiatives/padlock/evaluation_padlock_rng.pdf">this whitepaper above</A> on the technique VIA used on its C3.  They used multiple free-running oscillators to gather entropy.  The resulting output varies in quality, from 0.75 to 0.99 bits of entropy per output bit, depending on the decimation factor used and whether or not you enable von Neumann whitening.</P>
<P>Given that it generates entropy in the megabits/second range, this is several orders better than you can get from hard disk seeks and user keystrokes, even if you have to throw most of the numbers away.  And, given the high apparent entropy of the raw bits, you don't really need to throw many away at all.</P>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408768/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor409000"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2010 12:28 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/409000/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From all accounts I've read, the entropy of the numbers derived from the C3's RNG hardware sucks rather badly, probably because there are so many sources of regular noise in a CPU that it's hard to stop some of them leaking in. The figures I've heard are *well* below 0.75, more like 0.4 if you're lucky. And IIRC the C3 doesn't bother to validate them either (certainly from the description in the whitepaper they don't), and because the pair of oscillators comprise a single system, if it breaks down or becomes coupled to something external you *also* cannot tell.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/409000/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor479664"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 21:33 UTC (Mon)
                               by <b>tconnors</b> (guest, #60528)
                              [<a href="/Articles/479664/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Modern CPUs have accelerators for all sorts of things as standard equipment. Why not random numbers? We spend countless millions of transistors on ever larger caches and datapaths. Surely they could spare a few for a really high quality true random number generator.</font><br>
<p>
Because random number generators are only used for cryptography, and only terrorists use cryptography.  Are you a terrorist?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479664/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479666"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 21:40 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479666/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
some chips do have high quality random number generators built in.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479666/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor479747"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 7:50 UTC (Tue)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/479747/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Windows 8 Hardware Certification Requirements demand that "Connected Standby"-capable device (i.e., mobile ones) have encryption acceleration and a RNG.<br>
<p>
<font class="QuotedText">&gt; Business Justification:</font><br>
<font class="QuotedText">&gt; Core cryptographic functions are used in Windows to provide platform integrity as well as protection of user data.</font><br>
(note the priorities)<br>
<p>
In completely unrelated news, all recent AMD and Intel processors support AES-NI, and Intel has announced that Ivy Bridge processors will have a RNG.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479747/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor409039"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">bogus random entropy sources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2010 14:34 UTC (Thu)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/409039/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Most network controllers now implement interrupt moderation (deferring interrupts so that multiple packets can be handled at once).  With a high enough packet rate, they will interrupt at regular and predictable intervals.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/409039/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor409406"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Getting more entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2010 11:55 UTC (Sun)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/409406/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A while back just for the fun of it I wrote a kernel driver whose goal was to extract entropy from the timer interrupt. After all, if anything is predictable, then it'd have to be the timer interrupt.<br>
<p>
The point is that while the interrupt is predictable, between the time that the interrupt fires and the driver finally gets run you have cache misses at various levels, PCI bus transfers, DRAM refresh cycles and even just hyperthreading making things very unpredictable. Conclusion: if there's predictability here, I couldn't find it (there's a toolkit for estimating randomness, it concluded that the output was indistinguishable from real random data).<br>
<p>
The basic idea was to just use the last few bits of the cycle counter, don't worry about the high order bits. The last bit was enough, but even taking the last four bits didn't show any patterns. It might be worth making such a driver for the purpose of giving otherwise entropy starved machines something to work with. I imagine within VMs the cycle counter becomes even more variable, due to contention with things outside the VM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/409406/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor409431"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Getting more entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2010 21:56 UTC (Sun)
                               by <b>man_ls</b> (guest, #15091)
                              [<a href="/Articles/409431/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I guess that the problem is to prove that an attacker cannot influence the timers so that the result is predictable. For example a guy on a different VM doing odd things with the same CPU. As it is hard to prove a negative statement of this kind, then people may tend to distrust such a source of entropy, even if it sounds really interesting.
      
          <div class="CommentReplyButton">
            <form action="/Articles/409431/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor408475"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 1:19 UTC (Tue)
                               by <b>dgc</b> (subscriber, #6611)
                              [<a href="/Articles/408475/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting read. It looks like we are finally getting towards the sort of sort of infrastructure I thought is necessary to support high end SSDs. From the presentation I gave at the 2008 Filesystems and IO workshop (cut-n-paste from my slides, so please excuse lack of formatting):<br>
<p>
<p>
The IOPS Challenge<br>
<p>
o SSDs<br>
  - Ready for 50,000 IOPS/s per disk?<br>
    + &gt;200,000 ctxsw/s per disk<br>
    + 50,000 intr/s per disk<br>
    + Does not scale to many disks<br>
  - Raw IOP capacity per HBA<br>
    + will be a limiting factor<br>
    + driver design will need to focus on IOPS optimisations,<br>
      not achieving max bandwidth<br>
  - CPU overhead will be high<br>
<p>
o Looks more like the network problem<br>
  - similar packet rates to gigabit ethernet per disk<br>
    many, many more interfaces than a typical network stack<br>
  - HBAs with multiple disks will have to handle packet rates<br>
    closer to 10Gb ethernet<br>
  - similar interrupt scaling tricks will be needed<br>
    + MSI-X directed interrupts<br>
        + one vector per disk behind the HBA?<br>
    + polling rather than interrupt driven<br>
<p>
o Will require both hardware and software to evolve<br>
o Not going to happen overnight<br>
o Two orders of magnitude increase in performance is a big<br>
  disconnect<br>
o Optimisations being made for current (cheap) SSDs have a<br>
  short life<br>
  - random write performance is not a limiting factor at<br>
    the high end....<br>
<p>
I think this shows the value we have been getting from these workshops - cross pollination of ideas, challenges, techniques, etc across the wider community. We might not see results immediately, but they are eventually appearing...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408475/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor408537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 8:59 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/408537/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Networking technology went from 10Mb/s in the 1980's to 10Gb/s now, the better part of 30 years later. SSDs have forced a similar jump (three orders of magnitude) in a much shorter period of time - and every indication suggests that devices with IOPS rates in the millions are not that far away. </font><br>
<p>
Probably the main reason why such an unfortunate IOPS jump has been forced in networking is backward compatibility. Jumbo frames? Fail because of backward compatibility. Evolving TCP/IP to ease hardware assistance? Fail because of backward compatibility. Etc.<br>
<p>
That is because the backward compatibility requirement is nowhere as strong as in networking. You can easily upgrade your PC. It is even reasonably easy to upgrade your company-wide software. But good luck trying to upgrade the Internet. Or even just Ethernet. See IPv6 for instance: it comes as a brand new feature practically not touching anything already in place, but even such a smooth "upgrade" is a hard sell!<br>
<p>
One of the unfortunate consequences is that transferring a DVD image on the network requires millions of IOPS all across the path.<br>
<p>
In comparison, the need for backward compatibility in storage is basically inexistent. So this network/storage analogy must stop somewhere. Please someone from the storage camp tell us where exactly. Surely reading or writing a DVD image to disk does not/will not require millions of IOPS. Or will it still?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408555"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 11:13 UTC (Tue)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/408555/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sequential IO will of course use larger IO sizes. The IOPS quest is largely for the mainly randomized IO workloads.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408555/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor408639"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 18:21 UTC (Tue)
                               by <b>angdraug</b> (subscriber, #7487)
                              [<a href="/Articles/408639/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>See IPv6 for instance: it comes as a brand new feature practically not touching anything already in place, but even such a smooth "upgrade" is a hard sell!</blockquote>

<p>Have you seen <a href="http://arstechnica.com/business/news/2010/09/there-is-no-plan-b-why-the-ipv4-to-ipv6-transition-will-be-ugly.ars">this article at ArsTechnica</a>? It goes to some lengths to explain the problems with IPv6 transition. If it's to be believed, IPv6 transition is quite far from "smooth".</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/408639/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408731"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 23:30 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/408731/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If it's to be believed, IPv6 transition is quite far from "smooth".</font><br>
<p>
Yes but it would have been much worse (read: impossible) if IPv6 deployment ever required substantial changes to IPv4.<br>
<p>
This is an interesting article. Except they are wrong when they pretend it is easy to break backward-compatibility with Ethernet or TCP. It is not easy but only "less impossible" than breaking IPv4 backward compatibility.<br>
<p>
Note: the focus of the article is obviously neither on Ethernet nor on TCP.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408731/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor409311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2010 23:48 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/409311/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Probably the main reason why such an unfortunate IOPS jump has been forced in networking is backward compatibility.
<p>
...
<p>
In comparison, the need for backward compatibility in storage is basically inexistent.
</blockquote>
<p>
Well, the the whole reason SSDs exist is backward compatibility with rotating media, and it does slow things down considerably.  If not for backward compatibility, we wouldn't use SCSI or even Linux block devices to access solid state storage.  Write amplification by read-modify-write wouldn't be a problem if the device weren't trying to emulate a 512-byte-sectored disk drive.
<p>
Existence of SSDs tells me people aren't willing to replace the entire system at once -- they want to replace just the disk drives.
<p>
Not knowing the network issues, though, I can believe that backward compatibilty hinders performance less in storage than for ethernet.

      
          <div class="CommentReplyButton">
            <form action="/Articles/409311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor408547"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 10:24 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/408547/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is rather nice that most of the performance work looks like undoing tricks to make rotational media work faster.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408547/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408550"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 10:49 UTC (Tue)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/408550/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unless you're the owner of rotational media, and the optimizations are being permanently undone (instead of being just disabled for non-rotational media).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408550/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 10:57 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/408552/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Unless you're the owner of rotational media, and the optimizations are being permanently undone (instead of being just disabled for non-rotational media).</font><br>
Is that really the case?  I have trouble imagining that they are willing to drop support for rotational media quite this fast.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 11:13 UTC (Tue)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/408554/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't know.  I sure hope it isn't the case, we will need fast, optimized support for rotational media for a few years yet...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor408556"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 11:15 UTC (Tue)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/408556/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Optimizations for rotating media are not dropped. Some of the early SSD work was centered around detecting them properly, that gives you a way to make informed decisions on these optimizations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408556/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor408593"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 15:54 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408593/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Out of curiosity:  Do we ever see SSDs start looking a more like RAM and a less like disks?  Already mmap() and friends blur the line between what's RAM and what's disk.  What if this relationship became shallower?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408593/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408622"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 17:29 UTC (Tue)
                               by <b>strappe</b> (guest, #53440)
                              [<a href="/Articles/408622/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      A "universal" memory technology has been the holy grail for decades: fast as SRAM, density and non-volatility of Flash, and cost of DRAM. There are various technologies that combine at least some of these characteristics: Magneto-resistive (MRAM), ferroelectric  (FRAM), phase-change memory (PCM), programmable metalization cell (PMC) and resistive (RRAM). Whether any of these will be commercially viable is still unknown.
<P>
I can easily imagine that flash will displace hard drives in most laptops and desktops, but server farms are still going to need massive amounts of cheap storage. Rotating media still has a huge lead in $/bit (100X) so I don't think it will be displaced in there any time soon. 
      
          <div class="CommentReplyButton">
            <form action="/Articles/408622/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408630"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 18:04 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408630/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <P>I was thinking more in terms of treating flash specifically as less like an "I/O" device and more like a slow memory.  I have no doubt that spinning rust will be around for awhile--a decade or more at least.  It just seems like wrapping the flash behind a "disk drive" abstraction in hardware puts some artificial upper limits on how well it can perform.  It's acceptable with spinning rust because the electronics are so much faster.  When you go all solid-state, it just feels like a bottleneck.</P>
<P>Imagine what would happen if the immense creativity of the kernel crowd were unleashed on the problem of load balancing writes, erases and reads across a parallel array of raw flash modules?</P>
<P>Approaches such as UBI/UBIFS sound rather promising.  I generally like the idea of owning the problem in kernel space, where it seems like we ought to be able do much more deliberate and proactive scheduling.</P>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408630/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408644"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 18:36 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/408644/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the thing is that flash is not random access memory.<br>
<p>
the requirement to do bulk deletes makes it far more like spinning disks than ram.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408644/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408663"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 19:27 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408663/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <P>It certainly <I>is</I> random access.  I can generally send a command for address X followed by a command for address Y to the same chip, where the response time is <I>not</I> a function of the distance between X and Y, except when they overlap.  Instead, the performance is most strongly determined by what commands I sent[*].  Reads are much faster than writes, and both are much, much faster than sector erase.</P>
<P>The opposite is generally true of disks.  There, the cost of an operation is more strongly determined by whether it triggered a seek (and how far the seek went) than if the operation was a read or a write.  Both reads and writes require getting the head to a particular position on the platter, ignoring any cache that might be built into the drive.  Also, under normal operation, spinning-rust drives don't really have an analog to "sector erase."  (Yes, there's the old "low-level format" commands, but those aren't generally used during normal filesystem operation.)</P>
<HR>
<P>[*] Ok, so that's not 100% true, but essentially true in the current context.  NAND flash has a notion of "sequential page read" versus "random page read".  If you're truly reading random bytes a'la DRAM w/out cache, you'll see noticeably slower performance if the two reads are in different pages.  But, if you're doing block transfers, such as 512-byte sector reads, you're reading the whole page.  Hopping between any two sectors always costs about the same.  Here, <A HREF="http://www.datasheetcatalog.org/datasheet/SamsungElectronic/mXvvrxv.pdf">read a data sheet!</A>  For this particular flash, a random sector read is 10us, sector write is 250us, and page erase is 2ms.  The whole page-open/page-close architecture makes it look much more like modern SDRAM than disk.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/408663/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408672"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 19:42 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/408672/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
flash allows for random access reads, but is much more limited for writes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408672/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 20:38 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/408679/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <P>You can do random writes to random empty sectors.  Again, that's nothing like how a hard disk works.  I'm still strenuously disagreeing with your earlier statement that flash's properties make it more like a disk than like RAM.  It's really an entirely different beast worthy of separate consideration, which is why I think wrapping it up in an SSD limits its potential.</P>
<P>With flash, you need entirely new strategies that apply neither to disks nor RAM to get the full benefit from the technology.  Much of the effort spent on disks revolves (no pun intended) around eliminating seeks.  No such effort is required with RAM or with flash.  Flash <I>does</I> require you to think about how you pool your free sectors, though, and how you schedule writing versus erasing.  I won't deny that.  Rather, I say it only further invalidates your original conjecture that it makes flash <I>more like disks</I>.  (I will agree it makes it <I>less like RAM</I> though.)</P>
<P>Because seeks are "free", I could totally see load balancing algorithms of the form "write this block to the youngest free sector on the first available flash device", so that a new write doesn't get held up by devices busy with block erases.  That looks <I>nothing</I> like what you'd want to do with a disk.  It takes advantage of the "free seek" property of the flash while helping to hide the block erase penalty it imposes.  Neither property is a property of a disk drive.  Of course, neither property is a property of RAM, either.</P>
<P>Am I splitting hairs over semantics here?  Let me step back and summarize, and see if you agree:  Raw flash's random access capability and relatively low access time can make it much more like RAM than disk, especially in terms of bandwidth and latency.  Raw flash's limitations on writes, however, require the OS to have flash-specific write strategies.  They prevent the OS from treating flash identically to RAM, and will require careful thought to be handled correctly.  This is similar to how we had to put careful thought into disk scheduling algorithms, even if flash requires entirely different algorithms to address its unique properties.</P>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor409337"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2010 14:10 UTC (Sat)
                               by <b>joern</b> (guest, #22392)
                              [<a href="/Articles/409337/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Flash does require you to think about how you pool your free sectors, though, and how you schedule writing versus erasing.</font><br>
<p>
Intriguing.  Can you elaborate a bit?  What difference does it make vs. the nave approach of erasing before writing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/409337/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor409340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2010 14:55 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/409340/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the issue is that you have to erase large chunks (on the order of 128K bytes), if you are then writing in small chunks (say the 512 byte sectors that are the default, or even the 4K byte filesystem blocks) you can't just erase just before writing.<br>
<p>
you also have the problem that erasing takes a significant amount of time and power to accomplish, so you don't want to wait until you need to erase to do so and you don't want to erase when you don't need to and are on battery<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/409340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor409341"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2010 15:03 UTC (Sat)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/409341/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>Note:  I'm not an expert.  Please do not mistake me for one.  :-)  Here are my observations, though, along with things I've read elsewhere.</P>
<P>Flash requires wear leveling in order to maximize its life.  For the greatest effect, you want to wear level across the entire device, which means picking up and moving otherwise quiescent data so that each sector sees approximately the same number of erasures.  That's one aspect.</P>
<P>Another aspect is that erase blocks are generally much larger than write sectors.  So, when you <I>do</I> erase, you end up erasing quite a lot.  Furthermore erasure is about an order of magnitude slower than writing, and writing is about an order of magnitude slower than reading.  For a random flash device whose data sheet I just pulled up, a random read takes 25us, page program takes 300us, and block erase takes 2ms.  Pages are 2K bytes, whereas erase blocks are 128K bytes.</P>
<P>(Warning:  This is where I get speculative!)  And finally, if you have multiple flash devices (or multiple independent zones on the same flash device), you can take advantage of that fact and the fact that "seeks are free" by redirecting writes to idle flash units if others are busy.  That's probably the most interesting area to explore algorithmically, IMO.  Given that an erase operation can take a device out of commission for 2ms, picking which device to start an erase operation on and when to do it can have a pretty big impact on performance.  If you can do background erase on idle devices, for example, then you can hide the cost.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/409341/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor409006"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2010 12:38 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/409006/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
NAND flash has a notion of "sequential page read" versus "random page read". If you're truly reading random bytes a'la DRAM w/out cache, you'll see noticeably slower performance if the two reads are in different pages.
</blockquote>
That sounds just like normal RAM: if you don't have to specify the row *and* column, you save on one CAS/RAS select cycle. Of course this is hidden behind the MMU and CPU cache management code and so on, so we don't often notice it, but it <i>is</i> there.

      
          <div class="CommentReplyButton">
            <form action="/Articles/409006/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor408633"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">application impact</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 18:07 UTC (Tue)
                               by <b>wingo</b> (guest, #26929)
                              [<a href="/Articles/408633/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder what these capabilities mean for user-space. I spend some time optimizing disk access in my programs, and for what?<br>
<p>
I asked Michael Meeks a couple of Fosdems ago about how his iogrind disk profiler was coming, and he said that he totally dropped it, because ssds will kill all these issues. Sounds easier than fixing OpenOffice.org^WLibreOffice issues in code...<br>
<p>
Is the "best practice" going to shift away from implementing things like GTK's icon cache and other purely seek-avoiding caches?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408633/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">application impact</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 22:29 UTC (Tue)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/408716/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I sure hope not.<br>
<p>
GTK applications' current "best practice" of "ignore the RAM use, they can buy more" has already destroyed the usefulness of old hardware with a modern Linux software stack.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408751"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">application impact</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 0:16 UTC (Wed)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/408751/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      Eight Megabytes And Constantly Swapping. This is not a new phenomenon.
      
          <div class="CommentReplyButton">
            <form action="/Articles/408751/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">application impact</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 1:23 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/408756/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the problem is that system resources have increased by 1000x (or close to it) and people trying to do very similar work find themselves in almost the same situation.<br>
<p>
yes we are doing more with our systems, but nowhere near that much more.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">application impact</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 9:23 UTC (Wed)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/408790/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I doubt that hard drive performance (as considered in this article) has increased 1000x. Has it? The memory hierarchy looks more and more stretched.<br>
<p>
(Here I am ignoring SSDs, still too new to be part of The History)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor408797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">application impact</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 11:04 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/408797/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it depends on what you are measureing<br>
<p>
in terms of size, drives have grown at least 1000x<br>
<p>
in terms of sequential I/O speeds they have improved drastically (I don't think quite 1000x, but probably well over 100x, so I think it's in the ballpark)<br>
<p>
in terms of seek time, they've barely improved 10x or so<br>
<p>
this is ignoring things like SSDs, high-end raid controllers (with battery backed NVRAM caches) and so on which distort performance numbers upwards.<br>
<p>
byt yes, the performance difference between the CPU registers and disk speeds is being stretched over time.<br>
<p>
jut the difference in speed between the registers and ram is getting stretched to the point where people are seriously talking that it may be a good idea to start thinking of ram as a block device, accessed in blocks of 128-256 bytes (the cache line size for the CPU), right now the CPU hides this from you by 'transparently' moving the blocks in and out of the cache of the various processors for you so that if you choose to you can ignore this.<br>
<p>
but when you are really after performance, a high end system starts looking very strange. You have several sets of processors that share a small amount of high-speed storage (L2/L3 cache) and have  larger amount of lower speed storage (the memory directly connected to that CPU), plus a network to access the lower speed storage connected to other CPUs. Then you have a lower speed network to talk to the southbridge chipset to interact with the outside world (things like you monitor/keyboard/disk drives, PCI-e cards, etc).<br>
<p>
This is a rough description of NUMA and the types of things that you can run into on large multi-socket systems, but the effect starts showing up on surprisingly small systems (which is why per-cpu variables and such things are used so frequently)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor410038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">application impact</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2010 19:29 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/410038/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's fine until they're on a system like mine ...<br>
<p>
Three slots, max capacity 256Mb per slot, three 256Mb chips in the machine.<br>
<p>
"That's no problem, they can just buy a new machine ..."<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/410038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor408653"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 18:48 UTC (Tue)
                               by <b>jmm82</b> (guest, #59425)
                              [<a href="/Articles/408653/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I enjoyed the article and most of the ideas seem very logical.  Is there any plans to generalize any of the code between the networking and block io or would that be too complex to maintain?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408653/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor408690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">iSCSI, Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2010 21:17 UTC (Tue)
                               by <b>jhhaller</b> (guest, #56103)
                              [<a href="/Articles/408690/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is using iSCSI to use Solid State disks mounted on a file server part of the testing and improvement plan? I can imagine this stresses both worlds, namely network interrupt steering along with block devices, all interacting in less than obvious ways.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor408918"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2010 22:05 UTC (Wed)
                               by <b>eds</b> (guest, #69511)
                              [<a href="/Articles/408918/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good article.<br>
<p>
At the extreme high end of PCIe SSDs, a system trying to do lots of small (4k) reads with high parallelism will be limited by having any queue locking at all.  Running without a request queue remains an attractive option for these devices.<br>
<p>
Another future improvement to watch out for is MSI-X interrupts.  With MSI-X, it is possible to statically assign an interrupt to a single CPU core in such a way that an I/O retirement could interrupt the originating CPU directly; over about 600K IOPS it becomes important to spread out the interrupt/retirement workload as much as possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/408918/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor409312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices: most I/O patterns</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2010 0:00 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/409312/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
While workloads will vary, Jens says, most I/O patterns are dominated by random I/O and relatively small requests.
</blockquote>
<p>
There are so many ways to count "most" that this fact is pretty useless.  Jens should just say, "some important I/O patterns are ...," which is reason enough to do this work.
<p>
I see a lot of thought wasted prioritizing things based on arbitrary "mosts": Most I/Os are reads, most files are under 4K, most computers are personal workstations.

      
          <div class="CommentReplyButton">
            <form action="/Articles/409312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor410140"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 15, 2010 17:42 UTC (Fri)
                               by <b>jmy3056</b> (guest, #70648)
                              [<a href="/Articles/410140/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the analogy presented misses the mark.  Instead of equating block IO with Network improvements consider this.<br>
<p>
Media that stores electronic information that used to spin but now doesn't is a closer parallel with RAM.  Optimzations for "disk" IO need to follow a similar path as OS/kernels when dealing with RAM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/410140/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor411321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Solid-state storage devices and the block layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 22, 2010 22:04 UTC (Fri)
                               by <b>eds</b> (guest, #69511)
                              [<a href="/Articles/411321/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are many good reasons to treat NAND flash storage more like disk than like DRAM.<br>
<p>
1. Addressing: DRAM is byte/word addressable; NAND flash is not.  NAND flash pages are currently 4KB in size and must be read/written<br>
2. Flash management: flash sucks.  It has long erase times, needs wear-leveling, needs lots of ECC and redundancy to be reliable.  Dealing with flash requires a lot of careful management that nobody's going to want on a DRAM-like path.<br>
3. Speed: flash is a lot faster than disk.  But it's still a lot slower than DRAM (a write to a busy NAND part may have to wait up to 1ms).<br>
4. Size: it's very expensive to try to address a terabyte of DRAM.  64-bit CPUs don't actually implement a full 64-bit address space.  It's much cheaper to just address huge storage devices in blocks, like a disk.<br>
<p>
If in a few more years phase-change memory becomes big and cheap enough to give NAND flash a run for its money, then it may be time to start treating nonvolatile memory sort of like DRAM.  But that day isn't quite here yet.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/411321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2010, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
