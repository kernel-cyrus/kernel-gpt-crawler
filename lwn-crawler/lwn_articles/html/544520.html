        <!DOCTYPE html>
        <html lang="en">
        <head><title>Widening ext4's readdir() cookie [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/544520/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/543794/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/544520/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Widening ext4's readdir() cookie</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Michael Kerrisk</b><br>March 27, 2013</br>
           </div>
<p> In <a href="/Articles/544298/">a separate article</a>, we explained how
an ext4 change to the kernel-user-space ABI in Linux 3.4 broke the
GlusterFS filesystem; here, we look in detail at the change and why it was
needed.  The change in question was <a
href="http://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=d1f5273e9adb40724a85272f248f210dc4ce919a">a
patch</a> by Fan Yong that widened the <tt>readdir()</tt> "cookies"
produced by ext4 from 32 to 64 bits.  Understanding why Fan's patch was
necessary first requires a bit of background on the <tt>readdir()</tt> API.

<p> The <tt>readdir</tt> API consists of a number of functions that allow
an application to walk through the entries in a directory list. The <a
href="http://man7.org/linux/man-pages/man3/opendir.3.html"><tt>opendir()</tt></a>
function opens a directory stream for a specified directory.  The <a
href="http://man7.org/linux/man-pages/man3/readdir.3.html"><tt>readdir()</tt></a>
function returns the contents of a directory stream, one entry at a
time. The <a
href="http://man7.org/linux/man-pages/man3/telldir.3.html"><tt>telldir()</tt></a>
and <a href="http://man7.org/linux/man-pages/man3/seekdir.3.html">
<tt>seekdir()</tt></a> functions provide lseek-style functionality: an
application can remember its current position in a directory stream using
<tt>telldir()</tt>, scan further entries with <tt>readdir()</tt>, and then
return to the remembered position using <tt>seekdir()</tt>.

<p> It turns out that supporting the <tt>readdir</tt> API is a source of
considerable pain for filesystem developers. The API was designed in a
simpler age, when directories were essentially linear tables of filenames
plus inode numbers. The first of the widely used Linux filesystems, ext2,
followed that design. In such filesystems, one can meaningfully talk about
an offset within a directory table.

<p> However, in the interests of improving performance and supporting new
features, modern filesystems (such as ext4) have long since adopted more
complex data structures&mdash;typically B-trees (<a
href="http://www.cs.aau.dk/~simas/aalg06/UbiquitBtree.pdf">PDF</a>)&mdash;for
representing directories.  The problem with B-tree structures, from the
point of view of implementing the <tt>readdir()</tt> API, is that the nodes
in a tree can undergo (sometimes drastic) rearrangements as entries are
added to and removed from the tree. This reordering of the tree renders the
concept of a directory "offset" meaningless. The lack of a stable offset
value is obviously a difficulty when implementing <tt>telldir()</tt> and
<tt>seekdir()</tt>. However, it is also a problem for the implementation of
<tt>readdir()</tt>, which must be done in such a way that a loop using
<tt>readdir()</tt> to scan an entire directory will return a list of all
files in the directory, without duplicates.  Consequently,
<tt>readdir()</tt> must internally also maintain some kind of stable
representation of a position within the directory stream.
 
<p> Although there is no notion of an offset inside a B-tree, the
implementers of modern filesystems must still support the
<tt>readdir</tt> API (<a href="/Articles/544237/">albeit
reluctantly</a>); indeed, support for the API is a POSIX
requirement. Therefore, it is necessary to find some means of supporting
"directory position" semantics. This is generally done by fudging the
returned offset value, instead returning an internally understood "cookie"
value. The idea is that the kernel computes a hash value that encodes some
notion of the current position in a directory (tree) and returns that value
(the cookie) to user space.  A subsequent <tt>readdir()</tt> or
<tt>seekdir()</tt> will pass the cookie back to the kernel, at which point
the kernel decodes the cookie to derive a position within the directory.

<p> Encoding the directory position as a cookie works, more or less, but
has some limitations.  The cookie has historically been a 31-bit hash
value, because older NFS implementations could handle only 32-bit
cookies. (The hash is 31-bit because the <tt>off_t</tt> type used to
represent the information is defined as a signed type, and negative offsets
are not allowed.) In earlier times, a 31-bit hash was not too much of a
problem: filesystem limitations meant that directories were usually small, so
the chance that two directory entries would hash to the same value was
small.

<p> However, modern filesystems allow for large directories&mdash;so large
that the chance of two files producing the same 31-bit hash is
significant. For example, in a directory with 2000 entries, the chance of a
collision is around 0.1%. In a directory with 32,768 entries (the
historical limit in ext2), the chance is somewhat more than 20%. (For the
math behind these numbers, see <a
href="http://en.wikipedia.org/wiki/Birthday_paradox">the Wikipedia article
on the Birthday Paradox</a>.) Modern filesystems have much higher limits on
the number of files in a directory, with a corresponding increase in the
chance of hash collisions; in a directory with 100,000
entries, the probability is over 90%.

<p> Two files that hash to the same cookie value can lead to problems when
using <tt>readdir()</tt>, especially on NFS. Suppose that we want to scan
all of the files in a directory. And suppose that two files, say
<tt>abc</tt> and <tt>xyz</tt>, hash to the same value, and that the
directory is ordered such that <tt>abc</tt> is scanned first. When an NFS
client <tt>readdir()</tt> later reaches the file <tt>xyz</tt>, it will
receive a cookie that is exactly the same as for <tt>abc</tt>. Upon passing
that cookie back to the NFS server, the next <tt>readdir()</tt> will
commence at the file following <tt>abc</tt>. The NFS client code has some logic
to detect this situation; that logic causes <tt>readdir()</tt> to give the
(somewhat counter-intuitive) error <tt>ELOOP</tt>, "Too many levels of
symbolic links".

<p> This error can be fairly easily reproduced on NFS with older
kernels. One simply has to create an ext4 directory containing enough
files, mount that directory over NFS, and run any program that performs a
<tt>readdir()</tt> loop over the directory on the NFS client. When working
with a local filesystem (no NFS involved), the same problem exists, but in
a different form. One does not encounter it when using <tt>readdir()</tt>,
because of the way in which that function is implemented on top of the
<tt>getdents()</tt> system call.  Essentially, <tt>opendir()</tt> opens a
file descriptor that is used by <tt>getdents()</tt>; the kernel is able to
internally associate a directory position with that file descriptor, so
cookies play no part in the implementation of <tt>readdir()</tt>. By
contrast, because NFS is stateless, each
<tt>readdir()</tt> over NFS requires that the NFS server explicitly locate
the directory position corresponding to the cookie sent by the client.

<p> On the other hand, the problem can be observed with a local ext4
filesystem when using <tt>telldir()</tt>, because that function explicitly
returns the directory "offset" cookie to the caller. If two directory
entries produce the same "offset" cookie when calling <tt>telldir()</tt>,
then a call to <tt>seekdir()</tt> after either of the <tt>telldir()</tt>
calls will go back to the same location. A user-space loop such as the
following easily reveals the problem, encountering a difficulty analogous
to a <tt>readdir()</tt> loop over NFS:

<pre>
    dirp = opendir("/path/to/ext4/dir");
    while ((dirent = readdir(dirp)) != NULL) {
        ...
        seekdir(dirp, telldir(dirp));
        ...
   }
</pre>

<p> The <tt> seekdir(dirp, telldir(dirp))</tt> call is a seeming no-op,
simply resetting the directory position to its current location. However,
where a directory entry hashes to the same value as an earlier
directory entry, the effect of the call will be to reset the directory
position to the earlier entry with the same hash. An infinite loop thus
results. Real programs would of course not use <tt>telldir()</tt> and
<tt>seekdir()</tt> in this manner. However, every now and then programs
that use those calls would obtain a surprising result: a <tt>seekdir()</tt>
would reposition the directory stream to a completely unexpected location.

<p> Thus, the cookie collision problem needed to be fixed for the benefit
of both ext4 and (especially) NFS. The simplest way of reducing the
likelihood of hash collisions is to increase the size of the hash
space. That was the purpose of Fan's patch, which increased the size of the
hash space for the offset cookies produced by ext4 from 31 bits to 63.  (A
<a
href="http://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=http://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=d7dab39b6e16d5eea78ed3c705d2a2d0772b4f06">similar
change</a> has also been merged for ext3.) With a 63-bit hash space, even a
directory containing one million entries would have less than one chance in
four million of producing a hash collision. Of course, a corresponding
change is required in NFS, so that the NFS server is able to deal with the
larger cookie sizes. That change was provided in <a
href="http://git.kernel.org/cgit/linux/kernel/git/stable/linux-stable.git/commit/?id=06effdbb49af5f6c7d20affaec74603914acc768">a
patch</a> by Bernd Schubert.

<a name="XFS"></a>
<p> Reading this article and the GlusterFS article together, one might
wonder why GlusterFS doesn't have the same problems with XFS that it has
with ext4. The answer, as <a href="/Articles/544386/">noted</a> by Dave
Chinner, is that XFS uses a rather different scheme to produce
<tt>readdir()</tt> cookies. That scheme produces cookies that require only
32 bits, and the cookies are produced in such a way as to guarantee that no
two files can generate the same cookie.  XFS is able to produce unique
32-bit cookies due to the virtual mapping it overlays onto the directory
index; adding such a mapping to ext4 (which does not otherwise need it)
would be a large job.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-ext4">Filesystems/ext4</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/544520/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor544820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 8:58 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/544820/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      It's interesting to read of the readdir offset debate, and read the hate for it. Most interesting is the "reluctantly" link in the article, http://lwn.net/Articles/544237/ - where Ted seems to make 2 claims:
<p><ol>
<li>The readdir/telldir offset is a legacy problem (NFS), and if not for that it would not be in the kernel.

<li>It would not generally be practical for userspace to keep directories in memory while walking them for telldir/readdir.
</ol>
<p>
Aren't these claims potentially contradictory? If it is not practical to keep directories in memory for telldir/readdir, why would it be practical for any other API? How would a dir-walking API work that didn't require userspace to keep a shadow copy (or didn't require the kernel to keep a shadow copy)? Is this perhaps a fundamental problem of a trade-off of where to keep state, rather than anything particular to readdir?
<p>
Also strange is the language in the SUSv3 spec which Ted quotes in another email (http://lwn.net/Articles/544257/):
<p>
<blockquote>
"   One of the perceived problems of implementation is that returning
    to a given point in a directory is quite difficult to describe
    formally, in spite of its intuitive appeal, when systems that use
    B-trees, hashing functions, or other similar mechanisms to order
    their directories are considered."
</blockquote>
<p>
Difficult to describe formally? That's odd. Surely it is quite trivial? You define that directory entries have an absolute ordering (lexical, numberical, whatever you want - it doesn't matter). Why are B-trees a problem? B-trees are defined to provide an index over absolutely ordered objects. Given, say, a B-tree and a rank in that order (e.g. the cookie of a previous dirent), there should be no problem to determine what the next dirent in the order is - even if the B-tree has been changed or re-balanced, even if the dirent for the cookie no longer exists! Surely? All ordered indices should have this property (I.e. hash tables do not, but pretty much all commonly used trees would, no?), surely?
<p>
Basically, I'm puzzled, because the issues as stated don't fully make sense (either not issues, or potentially not consistent) to me. So I'm wondering what the deeper issues are, that the developers and spec writers havn't explained; or else whether perhaps the developers have gotten so "in" to the details of the problem that they're overlooking some things that'd be clearer if they stepped back? (Or it could just be me having one of my amazingly stupid moments ;) - in which case, my apologies tentatively in advance).
      
          <div class="CommentReplyButton">
            <form action="/Articles/544820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544830"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 9:07 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/544830/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>
And further, this bit of the article made me scratch my head and wonder which of my understanding, the description of the issues involved in the article, and/or the code is suboptimal:
<p>
<blockquote>
"Although there is no notion of an offset inside a B-tree, the implementers of modern filesystems must still support the readdir API (albeit reluctantly); indeed, support for the API is a POSIX requirement. Therefore, it is necessary to find some means of supporting "directory position" semantics. This is generally done by fudging the returned offset value, instead returning an internally understood "cookie" value. The idea is that the kernel computes a hash value that encodes some notion of the current position in a directory (tree) and returns that value (the cookie) to user space.
</blockquote>
<p>
Encoding the position in the tree in the cookie through a <i>hash</i>? But the tree is indexing something with an absolute order - the very node in the true MUST be associated with a unique value already (e.g. the name), surely? Why would you then hash this?
<P>
(I'm assuming I'm having a pre-morning-caffeine stupid moment :) ).

      
          <div class="CommentReplyButton">
            <form action="/Articles/544830/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544831"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 9:13 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/544831/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess the issue must be the order the B-tree is indexing is ephemeral (e.g. it's of the index in the number of entries). But then, is there no way to make that order more stable?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544831/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor544837"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 9:23 UTC (Thu)
                               by <b>dark</b> (guest, #8483)
                              [<a href="/Articles/544837/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      I think the problem here is that the underlying ordered data entries are simply too big (they're whole filenames) and telldir() returns a long. No matter how you plan to map the names to long offsets, you'll find some combination of mutations to the directory that makes the offset invalid.

      
          <div class="CommentReplyButton">
            <form action="/Articles/544837/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544839"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 9:32 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/544839/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, names would be too big. Cpurse, you don't need an index into the space of all possible names. You need an index into the entries (not necessarily names) that existed and have existed in this directory. I wonder is there not a way to get a stable order, with a reliable "next" operation, out of that?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544839/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544846"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 9:57 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/544846/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
remember, the OS has no idea when (or even if) the application is going to make it's next request. The spec allows the application to read one filename a week and still be guaranteed to see all files that existed when it started the read with no duplicates.<br>
<p>
If there were no resource constraints, the system could use RCU type strategies to make a copy of the directory and just use the token as a numeric offset into this copy, but since the system has no way of ever knowing when it could release this copy, it would have to keep it forever.<br>
<p>
remember that with NFS, a server is required to be consistent even across reboots.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544846/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor544842"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 10:24 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/544842/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
E.g. why not make the order a ring? Store last created ID with the directory. Use an index into that order that is easily capable of answering "What is the next value in the order?" - tree indices typically are capable of this.<br>
<p>
To create an entry:<br>
<p>
- locate the ID in your ordered index (B-tree, whatever)<br>
- Determine the next free ID by walking the index to the next existing ID<br>
- Create your entry with that free ID, update your index<br>
- Update the directory's last created ID<br>
<p>
Insertions have to be done atomically wrt directory and index and any readers. Removals do not need to modify the last-created ID in the directory though. But it does not matter a jot how the internal structure of the index changes.<br>
<p>
No collisions, no hashes, no encoding the structure of indices into cookies. No nasty hacks. Just work with the grain by making the underlying order you're indexing have the properties you want.<br>
<p>
You are limited to # of directory entries being the size of the ring, but it seems NFS compatibility would allow that ring to be (2^64)-1.<br>
<p>
Why wouldn't that work?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544842/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 11:31 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/544864/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually the ring isn't necessary. Any way to pick a free ID will do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor545840"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 4, 2013 1:56 UTC (Thu)
                               by <b>vasi</b> (subscriber, #83946)
                              [<a href="/Articles/545840/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
HFS+ could do this. Each directory entry has a unique ID (the "catalog node ID"), which fits in a long. You can lookup the CNID to get the file name, and then use that name as your position in the directory.<br>
<p>
This is still imperfect. Because each CNID is associated with a file name, hard links require an extra level of indirection. And obviously if the file at the current position is deleted, or renamed, things won't work as expected.<br>
<p>
This is all moot, since Linux's HFS+ driver just uses the offset as f_pos, I'm not sure why. Maybe the f_pos values are required to be increasing? CNIDs are not.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/545840/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor544833"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 9:18 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/544833/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the big problem is that the directory contents may be changed by something else while you are going through the list of files.<br>
<p>
So your b-tree or other complex structure may change, potentially significantly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544833/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544840"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 9:41 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/544840/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It doesn't matter if the ordered index gets changed, even significantly, if the order it is indexing remains stable. I just wonder if there's some better way to manufacture a stable order from directory entries, rather than hash the name?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544840/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 9:46 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/544843/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The filesystem authors have been looking for a good way to deal with this ordering problem for years. If there was a simple answer I would have expected that _someone_ would have found it and everyone else would copy them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544853"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 10:25 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/544853/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why wouldn't a ring work? (see other comment too).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544853/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor544870"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 11:59 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/544870/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do any filesystems other than ext3/4 have this problem?<br>
<p>
Some address it with by having two indexes - one by name and one by cookie.  It is more expensive, bit is actually reliable (rather than only being stochastically reliable).<br>
<p>
My preference is internal-chaining.  This adds a little more book-keeping for the case when hashes collide, but I believe that is preferable to strange errors when hashes collide.  And they really don't collide often even with 32bit hashes.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544870/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544873"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 12:17 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/544873/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was going to post again to speculate whether or not the root of this problem was a desire to avoid keeping any index other than the name-based one! :)<br>
<p>
A simple index over a finite, ordered ID space, with 2 operations "get unused ID" and "get next used ID in the order" would solve this problem trivially, it really seems to me. ("get unused ID" could be done efficiently in a number of ways, e.g. picking a random ID in a ringed space, then using the "next unused" operation'd probably work well in a sparsely used space).<br>
<p>
Trying to bodge the properties of an order in a finite space out of the properties of an index of (effectively) infinite IDs seems doomed to failure and/or strange corner-cases. <br>
<p>
Hacking the internal structure of the index also seems potentially fragile and needlessly complex - though I don't know exactly what you mean by internal chaining. It sounds possibly like adding indices inside the index. In which case, why not just keep a separate, simpler index?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544873/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 14:14 UTC (Thu)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/544914/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In which case, why not just keep a separate, simpler index?</font><br>
<p>
There is an obvious index, which is the index of the inode in the directory as written to the hard disk sectors - but all index are worse than cookies because if you are currently using file 4 (out of 10), and someone removes the file number 2, when you will ask for file 5, you will skip a file...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor544923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 14:27 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/544923/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Because you've changed the ID of file 5, because you made its ID dependent on an ephemeral order.<br>
<p>
If you make the IDs stable, so they never change so long as the entry exists, then the problem is gone. The IDs are stable, and so the ordering between them is stable. You can do this through an additional index (in the data-structure sense).<br>
<p>
The "pain" seems to be that the ext3+ devs are trying to achieve this stable order by hacking around in the details an existing index of an ID that does NOT have an absolute order (the hashes of names). That wouldn't be necessary at all if they'd just add an additional stable, absolutely ordered, finite ID with its own index. The namespace-hash and the finite-ID could each have their own, simple index - no nasty hacks needed.<br>
<p>
(It seems to me, but I could be dreadfully wrong, or perhaps there are some critical details missing from the reporting ;) ).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/544923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor545078"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2013 2:56 UTC (Fri)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/545078/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"jfs" has a fairly simple second index.  Each directory entry contains a stable index number, and there is a table indexed by this number that leads to the name in the btree.  Look for "modify_index" in jfs_dtree.c and explore uses of "struct dir_table_slot".<br>
<p>
Some problems with this are:<br>
 - readdir will not return names in natural b-tree order, so you will get lots of seeking.  Not a problem when the whole directory fits easily in cache, may be a problem for v.large directories.<br>
 - every B-tree modification (page-split, page-delete) requires updating random entries in the index table.<br>
<p>
i.e. there is a genuine IO cost here.<br>
<p>
Having readdir return entries in natural B-Tree order is clearly appealing, and a separate table doesn't really allow this.<br>
<p>
By "Internal chaining" I mean that if a particular hash value is in use, you add 1 and try again.  When you find a hash value to use, you store it (or the difference between the hash of the name and the chosen value, which can probably be stored with fewer bits) with the name.  When you delete entries you need to be careful to leave place-holders if any subsequent entries are part of an internal chain leading from here.<br>
<p>
In the common case of no collisions there is zero IO overhead (where as with the jfs approach there is always IO overhead).  In the rarer case were there are collisions, there is an overhead that probably gets substantially worse as the chain length increases.  As long as any internal chain is within one block there is a processing overhead but no IO overhead.  Once it crosses a block boundary you get a real overhead, but probably comparable with the JFS overhead.  Once you have a chain touching three blocks it probably gets a lot worse.  But that should be extremely unlikely.<br>
<p>
So it seems like a solution with excellent common-case performance, which degrades only in rare circumstances.  Worst case performance (where all names hash to the same value) is probably not much worse than a linear search.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/545078/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor544901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 13:42 UTC (Thu)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/544901/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>Do any filesystems other than ext3/4 have this problem?</blockquote>

<p>I haven't heard any.

<p>And, yes, I suspect there are any number of solutions.  Just pick one of them, turn it into a patch that's bulletproof and backwards compatible, and we're done.
      
          <div class="CommentReplyButton">
            <form action="/Articles/544901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor544856"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">telldir() and seekdir()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 28, 2013 10:43 UTC (Thu)
                               by <b>meuh</b> (guest, #22042)
                              [<a href="/Articles/544856/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Surprisingly, <tt><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/telldir.html">telldir()</a></tt> and <tt><a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/seekdir.html">seekdir()</a></tt> use a <tt>long int</tt> (instead of a <tt>off_t</tt>) as the location (offset) value. So, from a userspace point of view, going from 32bits to 64bits to reduce the collision problem seen in NFS, seems rather strange.



      
          <div class="CommentReplyButton">
            <form action="/Articles/544856/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor545087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why am I seeing a security exploit?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2013 4:10 UTC (Fri)
                               by <b>jmorris42</b> (guest, #2203)
                              [<a href="/Articles/545087/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The details of hashes are known, because the kernel source is public.<br>
<p>
So why can't someone precompute carefully constructed directory entries that will cause a collision, even with 63 bit hashes?  Once you have those, drop them somewhere and wait for the infinite loop.  Do believe that is called 'denial of service'  Is there a good reason these puppies can't be injected in all sorts of places?  How many Linux mail servers unpack zipped attachments to perform malware detection?  Is everyone CERTAIN none will ever traverse the unpacked directory in a way that will trigger this?<br>
<p>
No, this is bogus.  Designing a filesystem that will work most of the time isn't any way to write code for production use.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/545087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor545155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why am I seeing a security exploit?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2013 13:49 UTC (Fri)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/545155/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>So why can't someone precompute carefully constructed directory entries that will cause a collision, even with 63 bit hashes?</blockquote>

<p>Looks like the hash algorithm takes a seed, which is per-superblock, generated at mkfs time, and should be unknown to an unprivileged user; grep for s_hash_seed in kernel and e2fsprogs source.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/545155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor545212"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why am I seeing a security exploit?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2013 16:37 UTC (Fri)
                               by <b>jmorris42</b> (guest, #2203)
                              [<a href="/Articles/545212/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok, at least they were on the ball.  Still just doesn't seem right to design a filesystem that only works almost all the time.  Computers are generally expected to be more deterministic that that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/545212/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor545775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why am I seeing a security exploit?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2013 20:26 UTC (Wed)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/545775/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The odds of a random 64 bit collision are worse than 10^18.  Since you'll win the lottery thousands of times before that happens, you'll be too rich to care about two gobbledlygook filenames colliding.  (But then, you've probably also been fried by lightning and crushed twice by the International Space Station...)<br>
<p>
More seriously, there are other sources of error in your computer that are far more worthy of your attention: <a href="http://en.wikipedia.org/wiki/Soft_error">http://en.wikipedia.org/wiki/Soft_error</a><br>
<p>
It's true that all bets are off if an attacker can break the hash.  But, if/when that happens, the fix will probably be a straightforward kernel patch.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/545775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor545987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why am I seeing a security exploit?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 4, 2013 16:20 UTC (Thu)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/545987/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The odds of two hashes colliding may be 1 in 10^18, but this grows with the number of files.  With 60,000 files it's 1 in 10^10.  Make up a use case where you're frequently creating or recreating directories with that many files, and it's not far fetched to expect someone to run into a collision pretty soon.<br>
<p>
(numbers from <a href="http://preshing.com/20110504/hash-collision-probabilities">http://preshing.com/20110504/hash-collision-probabilities</a>)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/545987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor545143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2013 11:32 UTC (Fri)
                               by <b>magnus</b> (subscriber, #34778)
                              [<a href="/Articles/545143/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If a new opendir/readdir option was introduced that allowed returning the same directory entry twice, would that be easier to implement? Then you could go back to the earliest known node you have already passed if the tree gets rebalanced, which at least feels to me like a simpler problem to solve. And for extreme cases like an NFS server restart you could go back to the start of the dir. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/545143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor545166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2013 13:54 UTC (Fri)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/545166/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Off the top of my head one objection is that there's no guarantee of forward progress for readers.
      
          <div class="CommentReplyButton">
            <form action="/Articles/545166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor545278"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 30, 2013 5:40 UTC (Sat)
                               by <b>Mog</b> (subscriber, #29529)
                              [<a href="/Articles/545278/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; a directory with 32,768 entries (the historical limit in ext2)</font><br>
<p>
Is it correct ? I remember a limitation on the number of subdirs due to the nlink field in the stat structure being a short, but not on the total number of entries (sudirs+files+...).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/545278/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor546021"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Widening ext4's readdir() cookie</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 4, 2013 19:40 UTC (Thu)
                               by <b>aakef</b> (subscriber, #38030)
                              [<a href="/Articles/546021/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; adding such a mapping to ext4 (which does not otherwise need it) would be &gt; a large job. </font><br>
<p>
I think "which does not otherwise need it" is not absolutely correct. Ext4s HTREE/dirindex readdir has another issue. Entries are not returned in inode, but in hash order and for example for 'ls -l' (readdir + stat) or 'rm -rf dir' that causes lots of random disk access. Recent core utils try to eliminate this by sorting results returned by readdir(), but that logic is not used by everything. Depending on the implementation "such a mapping" from above would also eliminate the random access problem at all.<br>
<p>
Bernd<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/546021/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
