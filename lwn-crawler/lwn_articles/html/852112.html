        <!DOCTYPE html>
        <html lang="en">
        <head><title>Comparing SystemTap and bpftrace [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/852112/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/851953/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/852112/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Comparing SystemTap and bpftrace</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="GAByline">
           <p>April 13, 2021</p>
           <p>This article was contributed by Emanuele Rocca</p>
           </div>
<p>There are times when developers and system administrators need to diagnose
problems in running code. The program to be examined can be a user-space
process, the kernel, or both. Two of the major tools available on Linux to
perform this sort of analysis are
<a href="https://sourceware.org/systemtap/wiki">SystemTap</a> and
<a href="https://github.com/iovisor/bpftrace">bpftrace</a>. SystemTap has been available
since 2005, while bpftrace is a more recent contender that, to some,
may appear  to
have made SystemTap obsolete. However, SystemTap is still the preferred
tool for
some real-world use cases.
</p>

<p>Although dynamic instrumentation capabilities, in the form of <a
href="/Articles/132196/">KProbes</a>, were added to Linux <a
href="/Articles/100332/">as early as 2004</a>, the functionality was hard
to use and not particularly well known. Sun released <a
href="https://www.usenix.org/legacy/event/usenix04/tech/general/cantrill.html">DTrace</a>
one year later, and soon that system became <a href="/Articles/244536/">one
of the highlights of Solaris</a>.
Naturally, Linux users started <a
href="/Articles/162701/">asking for something similar</a>, and SystemTap
quickly emerged as the most promising answer.
But SystemTap was
criticized as being difficult to get working, while DTrace
on Solaris could be expected to simply work out of the box.
</p>

<p>
While DTrace came with both kernel and user-space tracing capabilities, 
it wasn't until
2012 that Linux gained support for user-space tracing in the form of <a
href="/Articles/499190/">Uprobes</a>. Around 2019, bpftrace <a
href="/Articles/793749/">gained significant traction</a>, in part due to the
general attention being paid to the <a href="/Articles/740157/">various use cases for
BPF</a>. More recently, Oracle has been working on a <a
href="/Articles/840113/">re-implementation of DTrace</a>,  for Linux, based on
the latest tracing facilities in the kernel, although, at this point,
it may be too late for DTrace given the options that are already
available in this space.  </p>

<p>The underlying kernel infrastructure used by both SystemTap and bpftrace is
largely the same: KProbes, for dynamically tracing kernel functions,
<a href="/Articles/346470/">tracepoints</a> for static
kernel instrumentation, Uprobes for dynamic instrumentation of user-level
functions, and <a href="/Articles/753601/">user-level statically defined tracing
(USDT)</a> for static user-space
instrumentation. Both systems allow instrumenting the kernel and user-space
programs through a "script" in a high-level language that can be used to specify what needs
to be probed and how. 
</p>

<p>
The important design distinction between the two is that
SystemTap translates the user-supplied script into C code, which is then
compiled and loaded as a module into a running Linux kernel. Instead, bpftrace
converts the script to <a href="https://llvm.org/">LLVM</a> intermediate representation,
which is then compiled to BPF. Using BPF has several advantages: creating and
running a BPF program is significantly faster than building and loading a
kernel module. Support for data structures consisting of key/value pairs can be
easily added by using BPF maps. The <a
href="https://www.spinics.net/lists/xdp-newbies/msg00185.html">BPF 
verifier</a> ensures that BPF programs will not
cause the system to crash, while the kernel module approach used by SystemTap implies
the need for implementing various safety checks in the runtime. On the other
hand, using BPF makes certain features hard to implement, for example,
a custom stack walker, as we shall see later in the article.
</p>

<p>The following example shows the similarity between the two systems from the
user standpoint. A simple SystemTap program to instrument the kernel function
<tt>icmp_echo()</tt> looks like this:
</p>

<pre>
    probe kernel.function("icmp_echo") {
        println("icmp_echo was called")
    }
</pre>

<p>The equivalent bpftrace program is:
</p>

<pre>
    kprobe:icmp_echo {
        print("icmp_echo was called")
    }
</pre>

<p>We will now look at the differences between SystemTap and bpftrace in
terms of installation procedure, program structure, and features.
</p>

<h4>Installation</h4>

<p>Both SystemTap and bpftrace are packaged by all major Linux distributions and
can be installed easily using the familiar package managers. SystemTap requires
the Linux kernel headers to be installed in order to work, while bpftrace does
not, as long as the kernel has <a
href="https://www.kernel.org/doc/html/latest/bpf/btf.html">BPF Type
Format</a> (BTF) support enabled.
Depending on whether the user wants to analyze a user-space program or the
kernel, there might be additional requirements. For user-space
software, both SystemTap and bpftrace require the debugging symbols of the
software under examination. The details of how to install the symbol data depend
on the distribution.
</p>

<p>
On systems with elfutils 0.178 or later, SystemTap makes
the process of finding and installing the right debug symbols fully automatic
by using a <a href="/Articles/847256/">remote debuginfod server</a>. For
example, on Debian systems:
</p>

<pre>
    # export DEBUGINFOD_URLS=https://debuginfod.debian.net
    # export DEBUGINFOD_PROGRESS=1
    # stap -ve 'probe process("/bin/ls").function("format_user_or_group") { println(pp()) }'
    Downloading from https://debuginfod.debian.net/
    [...]
</pre>

<p>This feature is <a href="https://github.com/iovisor/bpftrace/issues/1774">not yet
available</a> for bpftrace.
</p>

<p>
For kernel instrumentation, SystemTap requires the kernel debugging
  symbols to be installed in order to use the advanced features of the
  tool, such as looking up the arguments or local variables of a
  function, as well as instrumenting specific lines of code within the
  function body. In this case, too, a remote debuginfod server can be
  used to automate the process.
</p>

<h4>Program structure</h4>

<p>Both systems provide an <a href="/Articles/820829/">AWK</a>-like language,
inspired by DTrace's
<a href="https://docs.oracle.com/cd/E18752_01/html/819-5488/gcfqr.html">D</a>, to describe
predicates and actions. The bpftrace language is pretty much the same as D,
and follows this general structure:
</p>

<pre>
    probe-descriptions
    /predicate/
    {
        action-statements
    }
</pre>

<p>That is to say: when the probes fire, if the given (optional) predicate
matches, perform the specified actions.
</p>

<p>The structure of SystemTap programs is slightly different:
</p>

<pre>
    probe PROBEPOINT [, PROBEPOINT] {
        [STMT ...]
    }
</pre>

<p>In SystemTap there is no support for specifying a predicate built into the
language, but conditional statements can be used to achieve the same goal.
</p>

<p>For example, the following bpftrace program prints all <a
href="https://man7.org/linux/man-pages/man2/mmap.2.html"><tt>mmap()</tt></a> calls issued by
the process with PID 31316:
</p>

<pre>
    uprobe:/lib/x86_64-linux-gnu/libc.so.6:mmap
    /pid == 31316/
    {
        print("mmap by 31316")
    }
</pre>

<p>The SystemTap equivalent is:
</p>

<pre>
    probe process("/lib/x86_64-linux-gnu/libc.so.6").function("mmap") {
        if (pid() == 31316) {
            println("mmap by 31316")
        }
    }
</pre>

<p>Data aggregation and reporting in bpftrace is done exactly the same way
as it is done in DTrace. For example, the following program does a by-PID
sum and aggregation of the number
of bytes sent with the <tt>tcp_sendmsg()</tt> kernel function:
</p>

<pre>
    $ sudo bpftrace -e 'kprobe:tcp_sendmsg { @bytes[pid] = sum(arg2); }'
    Attaching 1 probe...
    ^C
    
    @bytes[58832]: 75
    @bytes[58847]: 77
    @bytes[58852]: 857
</pre>

<p>Like DTrace, bpftrace defaults to automatically printing aggregation results
when the program exits: no code had to be written to print the breakdown by PID
above. The downside of this implicit behavior is that, to avoid automatic
printing of all data structures, users have to explicitly <tt>clear()</tt> those that
should not be printed. For instance, to change the script above and only print
the top 5 processes, the <tt>bytes</tt> map must be cleared upon program termination.
</p>

<pre>
    kprobe:tcp_sendmsg {
        @bytes[pid] = sum(arg2);
    }
    
    END {
        print(@bytes, 5);
        clear(@bytes);
    }
</pre>

<p>Some powerful facilities for <a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#8-hist-log2-histogram">generating
histograms</a>
are available too, allowing for terse scripts such as the following, which
operates on the number of bytes read in calls to <tt>vfs_read()</tt>:
</p>

<pre>
    $ sudo bpftrace -e 'kretprobe:vfs_read { @bytes = hist(retval); }'
    Attaching 1 probe...
    ^C
    
    @bytes: 
    (..., 0)             169 |@@                                                  |
    [0]                  206 |@@@                                                 |
    [1]                 1579 |@@@@@@@@@@@@@@@@@@@@@@@@@@@                         |
    [2, 4)                13 |                                                    |
    [4, 8)                 9 |                                                    |
    [8, 16)             2970 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
    [16, 32)              45 |                                                    |
    [32, 64)              91 |@                                                   |
    [64, 128)            108 |@                                                   |
    [128, 256)            10 |                                                    |
    [256, 512)             8 |                                                    |
    [512, 1K)             69 |@                                                   |
    [1K, 2K)              97 |@                                                   |
    [2K, 4K)              37 |                                                    |
    [4K, 8K)              64 |@                                                   |
    [8K, 16K)             24 |                                                    |
    [16K, 32K)            29 |                                                    |
    [32K, 64K)            80 |@                                                   |
    [64K, 128K)           18 |                                                    |
    [128K, 256K)           0 |                                                    |
    [256K, 512K)           2 |                                                    |
    [512K, 1M)             1 |                                                    |
</pre>

<p>Statistical aggregates are <a
href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/arrayops-aggregates.html">also
available in SystemTap</a>.  The <tt>&lt;&lt;&lt;</tt> operator allows
adding values to a statistical aggregate. SystemTap does not automatically
print aggregation results when the program exits, so it needs to be done
explicitly.  </p>

<pre>
    global bytes
    probe kernel.function("vfs_read").return {
        bytes &lt;&lt;&lt; $return
    }
    
    probe end {
        print(@hist_log(bytes))
    }
</pre>

<h4>Features</h4>

<p>A very useful feature of DTrace-like systems is the ability to obtain a stack
trace to see which sequence of function calls lead to a given probe point.
Kernel stack traces can be obtained in bpftrace as follows:
</p>

<pre>
    kprobe:icmp_echo {
        print(kstack);
        exit()
    }
</pre>

<p>Equivalently, with SystemTap:
</p>

<pre>
    probe kernel.function("icmp_echo") {
        print_backtrace();
        exit()
    }
</pre>

<p>An important problem affecting bpftrace is that it cannot generate user-space
stack traces unless the program being traced was built with <a href="https://en.wikipedia.org/wiki/Call_stack#Stack_and_frame_pointers">frame pointers</a>. For
the vast majority of cases, that means that users must recompile the software
under examination in order to instrument it.
</p>

<p>SystemTap's <a href="https://sourceware.org/systemtap/SystemTap_Beginners_Guide/ustack.html">user-space stack backtrace mechanism</a>, instead, provides a full stack trace by
making use of debug information to walk the stack. This means that no
recompilation is needed.
</p>

<pre>
    probe process("/bin/ls").function("format_user_or_group") {
        print_ubacktrace();
        exit()
    }
</pre>

<p>The script above produces a full backtrace, here shortened for readability:
</p>

<pre>
     0x55767a467f60 : format_user_or_group+0x0/0xc0 [/bin/ls]
     0x55767a46d26a : print_long_format+0x58a/0x9f0 [/bin/ls]
     0x55767a46d840 : print_current_files+0x170/0x3e0 [/bin/ls]
     0x55767a465d8d : main+0x62d/0x1a00 [/bin/ls]
</pre>

<p>The same feature is <a href="https://github.com/iovisor/bpftrace/issues/1744">unlikely to be added to
bpftrace</a>, as it would need to
be implemented either by the kernel or in BPF bytecode.
</p>

<h4>Real world uses</h4>

<p>Consider the following example of a practical production investigation that
could not proceed further with bpftrace due to the backtrace limitation, so
SystemTap needed to be used to track it down. At Wikimedia we ran into <a
href="https://github.com/apache/trafficserver/issues/7423">an interesting
problem</a> with 
<a href="https://luajit.org/">LuaJIT</a> — after observing
high system CPU usage on behalf of <a
href="https://trafficserver.apache.org/">Apache Traffic Server</a>, we
could confirm that 
it was due to <tt>mmap()</tt>
being called unusually often: 
</p>

<pre>
    $ sudo bpftrace -e 'kprobe:do_mmap /pid == 31316/ { @[arg2]=count(); } interval:s:1 { exit(); }'
    Attaching 2 probes...
    @[65536]: 64988
</pre>

<p>That is where the investigation would have stopped, had it not been possible to
generate user-space backtraces with SystemTap. Note that in this case the issue
affected the Lua JIT component: rebuilding Apache Traffic Server with frame
pointers to make bpftrace produce a stack trace would not have been sufficient,
we would have had to rebuild LuaJIT too.
</p>

<p>Another important advantage of SystemTap over bpftrace is that it allows 
accessing function arguments and local variables by their name.
With bpftrace, arguments can only be accessed by name when instrumenting the
kernel, and specifically when using <a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#6-tracepoint-static-tracing-kernel-level-arguments">static kernel
tracepoints</a>
or the <a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#15-kfunckretfunc-kernel-functions-tracing">experimental kfunc feature</a> that is available
for recent kernels. The kfunc feature is based on <a href="/Articles/804937/">BPF
trampolines</a> and seems
promising. When using regular kprobes, or when instrumenting user-space
software, bpftrace can access arguments only by position (arg0, arg1,
... argN).
</p>

<p>SystemTap is also able to list available probe points by source file, and to
match by filename in the definition of probes too. The feature can be used to
focus the analysis only on specific areas of the code base.
For instance, the following command can be used to list (<tt>-L</tt>) all
of the functions defined
in Apache Traffic Server's <tt>iocore/cache/Cache.cc</tt>:
</p>

<pre>
    $ stap -L 'process("/usr/bin/traffic_server").function("*@./iocore/cache/Cache.cc")
</pre>

<p>It is often necessary to probe a specific point somewhere in the body of a
function, rather than limiting the analysis to the function entry point or
to the return statement. This can be done in SystemTap using <a
href="https://sourceware.org/systemtap/langref/langrefse4.html#x6-370004.2">statement 
probes</a>; the following will list the probe points available along with the
variables available at each point:
</p>

<pre>
    $ stap -L 'process("/bin/ls").statement("format_user_or_group@src/ls.c:*")'
    process("/bin/ls").statement("format_user_or_group@src/ls.c:4110") \
        $name:char const* $id:long unsigned int $width:int
    process("/bin/ls").statement("format_user_or_group@src/ls.c:4115") \
        $name:char const* $id:long unsigned int $width:int
    process("/bin/ls").statement("format_user_or_group@src/ls.c:4116") \
        $width_gap:int $name:char const* $id:long unsigned int $width:int	
    process("/bin/ls").statement("format_user_or_group@src/ls.c:4118") \
        $pad:int $name:char const* $id:long unsigned int $width:int
    [...]
    process("/bin/ls").statement("format_user_or_group@src/ls.c:4131") \
        $name:char const* $id:long unsigned int $width:int $len:size_t
</pre>

<p>The full output shows that there are ten different lines that can be
probed inside the function <tt>format_user_or_group()</tt>, together with the various
variables available in scope. By looking at the source code we can see which
one exactly needs to be probed, and write the SystemTap program accordingly.
</p>

<p>To try to achieve the same goal with bpftrace we would need to <a
href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#3-uprobeuretprobe-dynamic-tracing-user-level">disassemble 
the function and specify the right offset</a>
to the Uprobe based on the assembly instead, which is cumbersome at best.
Additionally, bpftrace <a
href="https://github.com/iovisor/bpftrace/issues/1632">needs to be
explicitly built</a> with <a
href="https://en.wikipedia.org/wiki/Binary_File_Descriptor_library">Binary
File Descriptor</a> (BFD)
support for this feature to
work.
</p>

<p>While all software is sooner or later affected by bugs, issues affecting
debugging tools are particularly thorny. <a
href="https://github.com/iovisor/bpftrace/issues/1305">One specific
issue</a> affects bpftrace on systems with certain LLVM versions, and it
seems worth mentioning. Due to <a
href="https://bugs.llvm.org/show_bug.cgi?id=47591">an LLVM bug</a> causing
load/store instructions in the intermediate representation to be reordered
when they should not be, valid bpftrace scripts can <a
href="https://github.com/iovisor/bpftrace/issues/1332">misbehave</a> in
ways that are difficult to figure out. Adding or removing unrelated code
might work around or trigger the bug.  The same underlying LLVM bug <a
href="https://github.com/iovisor/bpftrace/issues/1304">causes other
bpftrace scripts to fail</a>. The problem has recently been fixed in
LLVM&nbsp;12; bpftrace users should ensure they are running a recent LLVM
version that is not affected by this issue.  </p>

<h4>Conclusions</h4>

<p>SystemTap and bpftrace offer similar functionality, but differ
significantly in their design choices by using loadable kernel module in one
case and BPF in the other. The approach based on kernel modules offers greater
flexibility, and allows implementing features that are hard if not impossible
to do using BPF. On the other hand, BPF is an obviously good choice for
tracing tools, as it provides a fast and safe environment to base observability
tools on.
</p>

<p>
For many use cases, bpftrace just works out of the box, while
SystemTap generally requires installing additional dependencies in order to
take full advantage of all of its features. Bpftrace is generally faster, and
provides various facilities for quick aggregation and reporting that are
arguably simpler to use than those provided by SystemTap. On the other hand,
SystemTap provides several distinguishing features such as: generating
user-space backtraces without the need for frame pointers, accessing function
arguments and local variables by name, and the ability to probe arbitrary
statements.  Both would seem to have their place for diagnosing problems in
today's Linux systems.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Kernel_tracing">Development tools/Kernel tracing</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Rocca_Emanuele">Rocca, Emanuele</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/852112/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor852546"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing SystemTap and bpftrace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2021 20:46 UTC (Tue)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/852546/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One note for anyone trying out bpftrace, that unfortunately makes the out-of-the-box experience a little bit more difficult than described here, is that it will fail with an permission denied error when kernel lockdown is enabled, as more distributions are doing automatically. In that case, lockdown must be disabled using a sysrq shortcut, /proc/sysrq-trigger, or a reboot with different lockdown kernel parameter.<br>
<p>
I hope in the future some solution can be found to not have to compromise between security and debuggability in production systems in this way, but with the deep reach that kprobes have into the kernel it seems somewhat unlikely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/852546/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor852558"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing SystemTap and bpftrace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2021 23:50 UTC (Tue)
                               by <b>fuhchee</b> (guest, #40059)
                              [<a href="/Articles/852558/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you for this fair &amp; balanced comparison!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/852558/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor852575"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">dwarf stacktrace in bpf</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2021 9:02 UTC (Wed)
                               by <b>seanyoung</b> (subscriber, #28711)
                              [<a href="/Articles/852575/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BPF is pretty powerful nowadays. Loops are allowed; instruction set is complete (you can work around the missing signed div) and instruction limits are high. I don&#x27;t understand why dwarf stacktraces can&#x27;t be generated in BPF.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/852575/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor852592"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">dwarf stacktrace in bpf</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2021 13:27 UTC (Wed)
                               by <b>fuhchee</b> (guest, #40059)
                              [<a href="/Articles/852592/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Loops are allowed</font><br>
<p>
Last I heard, this was compile-time bounded, implemented by unrolling.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/852592/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor852593"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">dwarf stacktrace in bpf</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2021 14:14 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/852593/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This article[1] is the latest I can find. You can have bounded loops now, but they must be verifiable. Validating that there is an end to the stack is data-dependent and likely not allowed. One could get up to a fixed stack size though I presume.<br>
<p>
[1]<a href="https://lwn.net/Articles/794934/">https://lwn.net/Articles/794934/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/852593/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor852580"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing SystemTap and bpftrace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2021 10:07 UTC (Wed)
                               by <b>hazmat</b> (subscriber, #668)
                              [<a href="/Articles/852580/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
thanks to the author for posting bpftrace issues noted in the article to the upstream<br>
<a href="https://github.com/iovisor/bpftrace/issues/created_by/ema">https://github.com/iovisor/bpftrace/issues/created_by/ema</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/852580/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor852584"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing SystemTap and bpftrace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2021 11:03 UTC (Wed)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/852584/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is good to see,  LWN should always link to the bug reports authors file in the relevant articles.  For those interested in the issues, having a place to followup is important. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/852584/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor853115"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing SystemTap and bpftrace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 17, 2021 4:08 UTC (Sat)
                               by <b>ghane</b> (guest, #1805)
                              [<a href="/Articles/853115/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Emanuele,<br>
<p>
I do not use either debugging tool, or debug compiled code, but this article was a pleasure to read for its clarity.<br>
<p>
It provides an excellent overview of the *different use cases* where one might use these tools.  There are too few of these articles, I think. <br>
<p>
Thank you<br>
-- <br>
Sanjeev<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853115/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing SystemTap and bpftrace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2021 7:35 UTC (Tue)
                               by <b>ema</b> (subscriber, #17750)
                              [<a href="/Articles/853518/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you for your kind words Sanjeev. Without the suggestions and the editing work from the LWN folks it would not have been half as clear, believe me. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor853503"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing SystemTap and bpftrace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2021 1:21 UTC (Tue)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/853503/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Some key operational distinctions exist too, especially for userspace tracing, which is where my interests lie.<br>
<p>
The TL;DR is that in practice the effective, reliable use of any of these tools tends to require that you be able to plan ahead in order to install necessary debuginfo, kernel headers, utilities etc well ahead of time, before they age out of repositories. For best results you&#x27;ll want a much newer kernel than the enterprise-y distro defaults too. So they work best in tightly controlled farms of machines where the people who care about tracing can control how the systems are installed and updated.<br>
<p>
* SystemTap kmod mode needs kernel headers and prefers kernel debuginfo. Both age out of repos quickly.<br>
* SystemTap dyninst runtime requires restarting the target so it can LD_PRELOAD, and is more limited than kmod runtime<br>
* Effective eBPF userspace tracing in practice requires quite new kernels, so bpftrace, bcc, etc are hard or impractical to apply to older kernels common in the wild<br>
* SystemTap bpf runtime is limited by the same kernel version concerns as bcc etc *and* its own systemtap-specific limitations.<br>
* SystemTap doesn&#x27;t usually work on kernels newer than the systemtap release due to internal kernel API changes. It spews compile errors. So you usually need to get a newer systemtap to work with newer kernels.<br>
* bpftrace and bcc don&#x27;t currently handle detached DWARF debuginfo, and don&#x27;t even handle binaries built with the x64 default -fomit-frame-pointer compile flag properly.<br>
* The rich debuginfo based access to userspace state available in systemtap is mostly absent from bpf tooling targeting userspace, so access to your program state is very painful with bpf. <br>
<p>
So on older kernels you can use systemtap, except you probably can&#x27;t get the kernels headers and debuginfo installed. And you&#x27;re generally not going to encounter newer bpf-friendly kernels in the wild on production systems unless you&#x27;re managing your own clusters of systems. If you do have a newer kernel and want to use bpf, you get to fight with its lack of DWARF based unwinding and its primitive to nonexistent ability to understand userspace memory contents.<br>
<p>
I find this intensely frustrating, as I get a great deal of value out of both tools in my own debugging and performance work. But systemtap sometimes breaks when I update my kernel on my laptop, and I need a bleeding-edge bcc for even some of the basic functionality I needed for simple userspace tracers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853503/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor853506"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Comparing SystemTap and bpftrace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2021 1:22 UTC (Tue)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/853506/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I split the details into a child comment so the main one wouldn&#x27;t be too long.<br>
<p>
SystemTap is widely available even for older systems, though the packaged versions are usually older so it&#x27;s a bit of a pain to write scripts that work with them. It&#x27;s easy to compile if you&#x27;re allowed to install the needed toolchain and dependencies on the target and you have the time, but that adds to the hassle. Especially when you&#x27;re not hands-on and you just want the other end (customer, or whatever) to run a tapscript for you.<br>
<p>
Additionally, for its most fully featured and default runtime (kmod) SystemTap requires kernel headers and preferably debuginfo. These are frequently unavailable for whatever older kernel point release happens to be running on the target system at the time you need to run some tracing tools. Or at best you have to go digging manually through some archive of old packages that have aged out of the main repositories for the OS. The stap-prep tool can&#x27;t usually find them for you. So to reliably use systemtap&#x27;s kmod runtime you need to plan ahead and install kernel headers and debuginfo whenever you update the kernel, which nobody ever does. This drastically limits its practical utility.<br>
<p>
But lots of eBPF features and helper functions are only available in much newer kernels. On widely deployed &quot;enterprise&quot; system kernels it&#x27;s basically useless for nontrivial userspace tracing and analysis. eBPF is quite fragile in the face of kernel version changes as soon as you step outside the canned tracepoints, and the set of helper functions is extremely limited.<br>
<p>
Even if you can run your bpf scripts, your userspace stacks are going to look like &quot;-&quot; most of the time, because everything is compiled with -fomit-frame-pointer. AFAICS most bpf tools don&#x27;t handle external DWARF debuginfo or use tools like libunwind to help them out. So you land up having to recompile with -fno-omit-frame-pointer and use unstripped binaries with debuginfo in the main binary. This basically means you can&#x27;t do much tracing of packaged userspace binaries as are the norm on production systems.<br>
<p>
SystemTap on the other hand will not only get you your userspace stacks using DWARF detached debuginfo, it&#x27;ll now even talk to a debuginfod to download symbols for you during probe compilation. It&#x27;ll walk userspace pointers chains, examine struct members, recursively print structs, handle unions and so much more using simple built-in syntax. So it&#x27;s currently infinitely more powerful for userspace probing and analysis ...<br>
<p>
... or it would be if only you could find and install the kernel headers.<br>
<p>
SystemTap also has &#x27;dyninst&#x27; and &#x27;bpf&#x27; runtimes, which entirely avoid the need for kernel headers and can often be used without kernel debuginfo. But a considerable number of the built-in systemtap &quot;tapsets&quot; rely on embedded-C code written for kernelspace, which simply won&#x27;t work for a dyninst or bpf tapscript. Or they rely on helper functions exported by the kmod runtime that are not implemented for the dyninst or bpf runtimes. So in practice most of your existing systemtap scripts won&#x27;t work, and scripts are more difficult to write for the dyninst or bpf runtimes.<br>
<p>
Additionally, the dyninst runtime requires that you wrap the target using LD_PRELOAD. So it&#x27;s cool for development and QA work but for a production system it&#x27;s often impractical, as you frequently want to non-intrusively trace an already-server running process.<br>
<p>
This means you can&#x27;t usually apply eBPF or use SystemTap with any of its runtimes to any system you encounter in the wild.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/853506/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
