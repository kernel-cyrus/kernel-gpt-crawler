        <!DOCTYPE html>
        <html lang="en">
        <head><title>Ticket spinlocks [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/267968/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/267331/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/267968/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Ticket spinlocks</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 6, 2008</br>
           </div>
Spinlocks are the lowest-level mutual exclusion mechanism in the Linux
kernel.  As such, they have a great deal of influence over the safety and
performance of the kernel, so it is not surprising that a great deal of
optimization effort has gone into the various (architecture-specific)
spinlock implementations.  That does not mean that all of the work has been
done, though; a patch merged for 2.6.25 shows that there is always more
which can be done.
<p>

On the x86 architecture, in the 2.6.24 kernel, a spinlock is represented by
an integer value.  A value of one indicates that the lock is available.  
The <tt>spin_lock()</tt> code works by decrementing the value (in a
system-wide atomic manner), then looking to see whether the result is
zero; if so, the lock has been successfully obtained.  Should, instead, the
result of the decrement option be negative, the <tt>spin_lock()</tt> code
knows that the lock is owned by somebody else.  So it busy-waits ("spins")
in a tight loop until the value of the lock becomes positive; then it goes
back to the beginning and tries again.
<p>
Once the critical section has been executed, the owner of the lock releases
it by setting it to&nbsp;1.
<p>
This implementation is very fast, especially in the uncontended case (which
is how things should be most of the time).  It also makes it easy to see
how bad the contention for a lock is - the more negative the value of the
lock gets, the more processors are trying to acquire it.  But there is one
shortcoming with this approach: it is unfair.  Once the lock is released,
the first processor which is able to decrement it will be the new owner.
There is no way to ensure that the processor which has been waiting the
longest gets the lock first; in fact, the processor which just released the
lock may, by virtue of owning that cache line, have an advantage should it
decide to reacquire the lock quickly.
<p>

One would hope that spinlock unfairness would not be a problem; usually, if
there is serious contention for locks, that contention is a performance
issue even before fairness is taken into account.  Nick Piggin recently
revisited this issue, though, after noticing:
<p>
<div class="BigQuote">
	On an 8 core (2 socket) Opteron, spinlock unfairness is extremely
    	noticable, with a userspace test having a difference of up to 2x
    	runtime per thread, and some threads are starved or "unfairly"
    	granted the lock up to 1&nbsp;000&nbsp;000&nbsp;(!)  times.
</div>
<p>
This sort of runtime difference is certainly undesirable.  But lock
unfairness can also create latency issues; it is hard to give latency
guarantees when the wait time for a spinlock can be arbitrarily long.
<p>

Nick's <a
href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=314cdbefd1fd0a7acf3780e9628465b77ea6a836">response</a>
was a new spinlock implementation which he calls "ticket 
spinlocks."  Under the initial version of this patch, a spinlock became a
16-bit quantity, split into two bytes:
<p>
<blockquote>
	<img src="https://static.lwn.net/images/ns/kernel/ticket-spinlock.png" width=202
	     height=23 alt="[ticket spinlock]">
</blockquote>
<p>
Each byte can be thought of as a ticket number.  If you have ever been to a
store where customers take paper tickets to ensure that they are served in
the order of arrival, you can think of the "next" field as being the number
on the next ticket in the dispenser, while "owner" is the number appearing
in the "now serving" display over the counter.
<p>
So, in the new scheme, the value of a lock is initialized (both fields) to
zero.  <tt>spin_lock()</tt> starts by noting the value of the lock, then
incrementing the "next" field - all in a single, atomic operation.  If the
value of "next" (before the increment) is equal to "owner," the lock has
been obtained and work can continue.  Otherwise the processor will spin,
waiting until "owner" is incremented to the right value.  In this scheme,
releasing a lock is a simple matter of incrementing "owner."
<p>

The implementation described above does have one small disadvantage in that
it limits the number of processors to 256 - any more than that, and a
heavily-contended lock could lead to multiple processors thinking they had
the same ticket number.  Needless to say, the resulting potential for
mayhem is not something which can be tolerated.  But the 256-processor
limit is an unwelcome constraint for those working on large systems, which
already have rather more processors than that.  So the add-on <a
href="http://git.kernel.org/git/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=3a556b26a2718e48aa2b6ce06ea4875ddcd0778e">"big
ticket" patch</a> - also merged for 2.6.25 - uses 16-bit values when the
configured maximum number of processors exceeds 256.  That raises the
maximum system size to 65536 processors - who could ever want more than
that?

<p>

With the older spinlock implementation, all processors contending for a
lock fought to see who could grab it first.  Now they wait nicely in line
and grab the lock in the order of arrival.  Multi-thread run times even
out, and maximum latencies are reduced (and, more to the point, made
deterministic).  There is a slight cost to the new implementation, says
Nick, but that gets very small on contemporary processors and is
essentially zero relative to the cost of a cache miss - which is a common
event when dealing with contended locks.  The x86 maintainers clearly
thought that the benefits of eliminating the unseemly scramble for
spinlocks exceeded this small cost; it seems unlikely that others will disagree.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Spinlocks">Spinlocks</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/267968/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor268060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 1:57 UTC (Thu)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/268060/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p><i>The x86 maintainers clearly thought that the benefits of eliminating the unseemly scramble for spinlocks exceeded this small cost; it seems unlikely that others will disagree.</I></p>

<p>Not only do I not disagree, I'd love to run a kernel that has this cost, well actually I want the advantages, not so much the disadvantages.</P>

<p>It sounds like a really nice improvement.</P>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor268072"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Beautiful</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 4:01 UTC (Thu)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/268072/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Seeing algorithms like these come into being is nothing short of beautiful.

Is this an old trick just now brought to the Linux kernel, or something new Nick came up with?
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268072/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Beautiful</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 5:06 UTC (Thu)
                               by <b>walken</b> (subscriber, #7089)
                              [<a href="/Articles/268083/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
I think the "lamport's bakery" algorithm is similar to this. There may be subtle differences
though, I'm not an expert in locking algorithms...
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor268211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">20 years too late?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 18:33 UTC (Thu)
                               by <b>cpeterso</b> (guest, #305)
                              [<a href="/Articles/268211/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
I believe DEC implemented a similar lock queue algorithm in the Topaz operating system for
their Firefly multiprocessor system in the 1980s. I think their system avoided polling the
spinlock, thus eliminating memory bus contention. They had some sort of cascading queue of
locks.

If your spinlocks have this much contention, maybe they should sleep (in a wait queue) instead
of spinning?
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor268457"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Beautiful</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2008 7:40 UTC (Sat)
                               by <b>Nick</b> (guest, #15060)
                              [<a href="/Articles/268457/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Hi, this is Nick,

I must say first that Jon's writeup is very good, much better than my own attempts to explain
the problem/solution! :)

Secondly, I cannot take credit for the basic algorithm. I didn't actually look at any ticket
lock implementations before implementing this one, however the basic idea of implementing a
fifo using a continually incrementing head and tail index is not new at all.

If anything, I might take credit for distilling it down to somewhere close to the optimal x86
implementation. This is based just on the fact that I had a famous CPU designer ask if they
could use it as their company's reference ticket lock assembly sequence! (but I don't consider
myself an x86 guru, so I wouldn't be surprised if someone else coded this up well before me!)

The main trick I use, as Jon's article points to, is to increment the "next" part of the lock
and load the "owner" part in a single instruction. I do this by using 16 bit wide memory
operations on the 8+8 bit wide ticket lock.

The basic implementation of the algorithm would first increment the next part, and then load
the owner part. Doing it like this is probably fine, but it will increase the load on the L1
cache or on some CPUs it might have to invoke the store forwarding logic or even have to stall
until the store exists the store queue.

To answer cpeterso's question, yes in most situations, if you have enough contention on your
lock that starvation is a problem then sure you have a larger problem with your algorithm.
However, what can happen is that you have a common-case-uncontended lock but 0.001% of your
users will actually generate a lot of contention on that lock. Even if the critical section
itself is very tiny, the cost of transferring the lock cacheline will end up being a limiting
factor as the frequency of acquisition and the core count increases. It is, IMO, better to
survive the corner cases gracefully than to squeeze another couple of cycles out of the
algorithm in the case that you expect. (Also don't forget that often sleeping locks are
implemented using a spinlock)

I could easily be mistaken, but I believe it will result in a better kernel. We'll see.

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268457/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor268092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 6:08 UTC (Thu)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/268092/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Isn't there a naming inconsistency in the algorithm description as it now stands (at 05:59:44 UTC)? The box diagram and the following paragraph refer to fields "next" and "owner", but the next paragraph after that talks about "next" and "current". I assume "owner" and "current" refer to the same thing?

      
          <div class="CommentReplyButton">
            <form action="/Articles/268092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 14:28 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/268157/">Link</a>] 
      </p>
      
      </div>
      </summary>
      They do refer to the same thing; I've fixed it.  Sorry.
      
          <div class="CommentReplyButton">
            <form action="/Articles/268157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor268117"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 9:25 UTC (Thu)
                               by <b>and</b> (guest, #2883)
                              [<a href="/Articles/268117/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
<font class="QuotedText">&gt; That raises the maximum system size to 32768 processors. </font>

hm, why is this a signed 16 bit number when the "small" version of the 
patch uses unsigned 8 bit values? Unsigned 16 bit integers allow up to 
65536 processors...
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268117/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268153"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 13:13 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/268153/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Are there other structures that limit Linux to 32768?  Perhaps that's the context of the
comment.  I looked at the patch and didn't see anything that really tied it to signedness,
since the comparisons are all equals compares.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268153/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor268155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Processor limit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 14:20 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/268155/">Link</a>] 
      </p>
      
      </div>
      </summary>
      That was a slip of the brain as I was running out of time to get the article done.  Of course the limit is 65536; the article has been fixed.  Sorry for the confusion.
      
          <div class="CommentReplyButton">
            <form action="/Articles/268155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor268241"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 21:10 UTC (Thu)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/268241/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
<font class="QuotedText">&gt;That raises the maximum system size to 65536 processors - who could ever want more than that?</font>

SGI.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268241/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 23:01 UTC (Thu)
                               by <b>brianomahoney</b> (guest, #6206)
                              [<a href="/Articles/268276/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
While I suspect it will be a little while before tightly clustered
systems begin to feel this limitation, history is littered with 
_this_should_be_enough_ comments however the algorithm obviously
extends to u_64 (next|current) with little extra cost and that will surely 
do
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2008 6:51 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/268325/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Right, no one could ever need more than 4G processor cores. :)
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor268335"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2008 10:43 UTC (Fri)
                               by <b>rvfh</b> (guest, #31018)
                              [<a href="/Articles/268335/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
I think you missed the ironical reference to Bill Gates' alleged comment "640K of memory
should be enough for anybody." :)

Bill Gates claims this is a urban legend though.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268335/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor268391"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2008 19:04 UTC (Fri)
                               by <b>jd</b> (guest, #26381)
                              [<a href="/Articles/268391/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      The more sophisticated the spinlock allocation mechanism, the greater the overheads. Simply having a wide enough table (and it can be as wide as the UPID mechanism) would be fast, but costly on memory. Spinlocks are also not going to be under equal demand. Perhaps spinlocks can be created with a given ticket width (to reflect expected demand) or have the ticket width grow once a high water mark is exceeded (to reflect actual demand).
<p>
There's also the problem of what to do if a maximum of N processes can control something. Do you allocate N spinlocks? That ruins any quality of service you're trying to attain. Or if a process has claimed one spinlock, do you bar it from reclaiming it (or claiming one of the other N) until some sort of fair service guarantee has been achieved?
<p>
There seem to be many semi-independent problems involved here, with spinlocks ending up used for 1:1, 1:N, M:1 and M:N situations. in practice, some of these may never really apply, but even if one of the other options applies once, you've a candidate for leading the Department of Headaches.
<p>
Do we need smarter spinlocks? Something on top of "dumb" spinlocks to add any extra capabilities? Something that divides the problem-space up such that smarter spinlocks aren't needed? Big spinlocks, such that they can stay as they are and survive in more generalized situations?
      
          <div class="CommentReplyButton">
            <form action="/Articles/268391/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268475"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2008 14:09 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/268475/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
For N processes, you would use a semaphore initialised to N, not a spinlock.  If you wanted N
cpus to be able to do something, then I guess we could introduce a counting spinlock, similar
to a semaphore.  But we've not needed one yet, and I doubt we will.

We have many things implemented on top of spinlocks -- the BKL, semaphores, mutexes, rwlocks,
rwsems and the late and unlamented brwlock (obsoleted by RCU).  Then there's specialised
beasts such as bitlocks and seqlocks.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268475/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor268476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2008 14:07 UTC (Sat)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/268476/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
I have to ask...  What happens if a task is interrupted/NMIed/whatever-ed just as its turn
arrives?  Especially given a long-running handler?  Or is this scenario sufficiently rare so
as to have little or no performance impact?
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268621"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2008 9:00 UTC (Mon)
                               by <b>Nick</b> (guest, #15060)
                              [<a href="/Articles/268621/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
That's a good point. And yes I guess if that happens, then that will cause all other waiters
to spin longer as well.

Although I'm not sure that it is a problem in practice. The theory is that most of the time we
have no contention, then FIFO locks are no worse than unfair locks. Actually we could have up
to 1 process spinning on the lock, and NMI/IRQ delay behaviour shouldn't be any different than
unfair locks. It is only when you start getting more contention that it could start to be a
problem...

But the heavily contended case often means performance has tanked anyway, and we are actually
willing to sacrifice some performance to ensure fairness and forward progress.

In short -- I'm hoping that the situation you ask about should not be a real problem.

Unfortunately, as with a lot of these tricky interactions and uncommon workloads, it may be a
release or two before we hear anything about it. But ticket locks are definitely something for
kernel devs to keep in mind if investigating some unusual performance regression in future ;)

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268621/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268669"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2008 15:27 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/268669/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Indeed, you do have to have two tasks spinning on the lock before the NMI/IRQ delay could
possibly cause a problem.  So I also hope that this effect is not a problem in practice, but
as you say, testing and experience will be required.

And ticket locks do have nice real-time properties, as they get rid of the possibility of
starvation!
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268669/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 12, 2008 17:45 UTC (Tue)
                               by <b>bgamsa</b> (guest, #33057)
                              [<a href="/Articles/268931/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      Has anyone looked at <a href=http://www.cs.rice.edu/~johnmc/papers/asplos91.pdf>MCS</a> locks recently in the context of Linux and modern hardware.  I believe it has more requirements in terms of hardware primitives, but it does provide queueing and local spinning.
      
          <div class="CommentReplyButton">
            <form action="/Articles/268931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 12, 2008 18:08 UTC (Tue)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/268942/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
We did take a look a few years ago.  Of course, pure MCS locks have an incompatible API, but
the K42 folks at IBM Research came up with a variant of MCS locks that matched the
Linux-kernel spin_lock() primitives.  If I remember correctly, MCS locks outperformed the
various NUMA-aware locking primitives, but were outperformed by simple spinlocks.

I would expect that ticket locks would out-perform MCS locks at low contention levels (the
common case in modern Linux kernels).  I am not sure how MCS locks and ticket locks would
compare at high levels of contention -- the ticket locks avoid the "thundering herd" problem,
so might do quite well.

Any benchmark results out there?
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor291829"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2008 22:35 UTC (Mon)
                               by <b>okeydoke</b> (guest, #46751)
                              [<a href="/Articles/291829/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Ticket spinlocks perform terribly for uncontested and highly contested cases. Test cases on
LKML do not show any of this (a very trivial test case was done that does not show lock *and*
unlock cost).

Here are relevant numbers on 16-core (8x2) AMD64 machine:
Highly contested, MCS has 30724 a/s (average) and ticket locks have 6315 a/s (average). In the
uncontested case, MCS has 836744 a/s (average) and ticket locks have 688817 a/s (average).
Both implement FIFO fairness, anyways, so I do not expect relevance WRT "thundering herd"
problem.

MCS will perform better than the Anderson locks implemented under the name of "Fairlocks" and
"J-Locks" for Linux, also (I assume these are the NUMA-aware locking primitives you are
talking about?).

There are other implementations that perform better than both of these. Ticket lock with
proportional back-off helps alleviate performance issues in the highly contested case.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/291829/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor291830"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2008 22:37 UTC (Mon)
                               by <b>okeydoke</b> (guest, #46751)
                              [<a href="/Articles/291830/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
This is my MCS implementation and an optimized (for pipeline) Linux ticket lock
implementation. The results are not for the K42-variant MCS locks originally provided to
Linux.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/291830/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor366326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2009 9:44 UTC (Sat)
                               by <b>bankkus</b> (guest, #62476)
                              [<a href="/Articles/366326/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; And ticket locks do have nice real-time properties, as they get rid of </font><br>
<font class="QuotedText">&gt;&gt; the possibility of starvation!</font><br>
<p>
Is that a correct statement? Not an x86 guru but whatever instruction is used to atomically increment the 16bit number is that guaranteed to complete in hw? In other words consider a 16 way processor if all threads incremented simulataneously is there a guarantee all 16 threads increment (in whatever order) or is it possible that on some of them the thread can context switch out before execution. If such is true then it does not guarantee no starvation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/366326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor268978"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks and MP-guest kernels</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 12, 2008 19:51 UTC (Tue)
                               by <b>eSk</b> (guest, #45221)
                              [<a href="/Articles/268978/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
There is also the case for multi-vCPU guests running in a VM.  For regular spinlocks you have
the problem that a guest vCPU may be preempted while holding a spinlock, thereby potentially
causing large delays for other vCPUs (i.e., think spinlock wait times in the order of hundreds
of milliseconds rather than nanoseconds).  A guest vCPU0 is preempted while holding a
spinlock.  Guest vCPU1 is scheduled and spends its whole timeslice wating for the usually
shortly held spinlock to be released; not knowing that the holder of the spinlock is not
really running at the time.

One might argue that it's stupid to run an MP guest system on a single physical processor, but
the above scenario is also present for MP guests running on multiple physical processors.  You
only get around the problem if you perform strict gang-scheduling of all the vCPUs.  The other
option is to add heuristics to prevent prempting guest vCPUs holding spinlocks.

Using ticket spinlocks the problem with preempting lock-holders is increased.  Not only do you
have the problem that preempting a lock-holder is bad for performance, but since all the
waiters must be granted the lock in FIFO order one had better make sure that the different
lock contenders are scheduled in the proper order.  Failure to do so will massively increase
the lock waiting time.  With regular spinlocks you have the chance that any one of the waiting
vCPUs can grab the lock and be done with it quicky.  With ticket spinlocks you don't have this
option.

I would expect that anyone trying to run a multi-MP guest kernel will run into this
performance problem rather quickly (subject to number of vCPUs and kernel workload, of
course).
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268978/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor269326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks and MP-guest kernels</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 14, 2008 7:53 UTC (Thu)
                               by <b>goaty</b> (guest, #17783)
                              [<a href="/Articles/269326/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
You could get a lovely cascade going. VCPU0 grabs the spinlock, then is pre-empted. VCPU1
spends its whole time slice waiting for the spinlock. VCPU2 is scheduled, and starts queuing
for the spinlock. VCPU0 is scheduled, releases the spinlock, goes to sleep. The host scheduler
looks for another thread to schedule. VCPU1 and VCPU2 have just been busy-waiting so they get
penalised. VCPU3, VCPU4, VCPU5, etc., each get scheduled in turn, each run until they hit the
spinlock in question, and start busy waiting. The cascade can continue until we run out of
virtual CPUs. If the rate at which CPUs manage to acquire the lock is slower than the rate at
which CPUs attempt to acquire the lock, the cascade can continue forever!

Although on a general-purpose system the likelihood that all the CPUs would keep trying to
acquire the same spinlock is pretty small, virtual guests are often used to run specific
workloads. Since all the virtual processors are doing the same kind of work, it is quite
likely that they would all keep contending the same spinlock. Which is exactly the situation
that ticket spinlocks are supposed to help with!

Probably anyone who's running MP guest kernels had already got each virtual CPU locked to a
different real CPU, or is running with realtime scheduling, precisely to avoid this kind of
problem. If not, then ticket spinlocks should provide them with all the motivation they need!
:-)
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/269326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor269395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks and MP-guest kernels</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 14, 2008 16:38 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/269395/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Gang scheduling within the hypervisor would be one way to avoid this issue, and without the
need to lock the VCPUs to real CPUs.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/269395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor269696"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ticket spinlocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2008 22:38 UTC (Sat)
                               by <b>xorbe</b> (guest, #3165)
                              [<a href="/Articles/269696/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
FINALLY!  I have always wondered why an approach like this wasn't attempted earlier.  This is
the good stuff, my friends.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/269696/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor307080"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not 1 byte tickets?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2008 0:17 UTC (Fri)
                               by <b>orangetide</b> (guest, #47730)
                              [<a href="/Articles/307080/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Limit yourself to 16 processors and cram the whole works into two nybbles. Sort of the opposite direction as the 65536 cpu version.<br>
<p>
Not sure what the advantages of the 8-bit or 16-bit version are over putting everything in a 32-bit value. Most of my systems like to talk to RAM in 32-bit chunks (or larger). And all of my linux systems have 32-bit registers (or larger).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/307080/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2008, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
