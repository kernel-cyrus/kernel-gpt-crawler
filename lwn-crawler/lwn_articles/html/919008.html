        <!DOCTYPE html>
        <html lang="en">
        <head><title>A vDSO implementation of getrandom() [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/919008/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/919119/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/919008/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A vDSO implementation of getrandom()</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 6, 2023</br>
           </div>
Most developers probably do not see the generation of random numbers as
being a performance bottleneck for their programs, but there are seemingly
exceptions.  Over the last few years, Jason Donenfeld has brought a new
level of energy to the development of the kernel's random-number generator;
he is now directing his efforts toward improving performance for user space
with <a
href="/ml/linux-kernel/20230101162910.710293-1-Jason@zx2c4.com/">this patch
series</a> that provides an implementation of the <a
href="https://man7.org/linux/man-pages/man2/getrandom.2.html"><tt>getrandom()</tt></a>
system call in the kernel's <a href="/Articles/615809/">"virtual dynamic
shared object" (vDSO)</a> area.  The result is, indeed, better performance,
but not all developers see this benefit as being worth the additional
complexity required to achieve it.
<p>
Traditionally, user-space processes on Linux systems have obtained random
data by opening <tt>/dev/urandom</tt> (or <tt>/dev/random</tt>) and reading
data from it.  More recently, <a href="/Articles/606141/">the addition of
<tt>getrandom()</tt></a> simplified access to random data; a
call to <tt>getrandom()</tt> will fill a user-space buffer with random
data from the kernel without the need to open any files.  This random data
is provided with all of the guarantees that the kernel
can make, including doing its best to ensure that the data is actually
random and <a href="/Articles/887207/">preventing repeated data
sequences</a> when, for example, a virtual machine forks.
<p>
It's worth noting that, in the BSD world, it is more common to call the <a
href="https://man.openbsd.org/arc4random.3"><tt>arc4random()</tt></a>
library function.  The <a href="/Articles/903556/">2.36 release</a> of the
GNU C Library included an 
implementation of <tt>arc4random()</tt> that, in its pre-release form,
included a fair amount of its own logic for the generation and management
of random data.  In July
2022, Donenfeld <a
href="/ml/libc-alpha/Ytwg8YEJn+76h5g9@zx2c4.com/">questioned the need</a>
for this function, noting that "<q>getrandom() and /dev/urandom are
extremely fast</q>".  Supporting <tt>arc4random()</tt> makes code more
portable, though, so that function stayed in the library.  The version that
was eventually released <a
href="/ml/libc-alpha/20220726195822.1223048-1-Jason@zx2c4.com/">was
significantly simplified by Donenfeld</a>, to the point that it essentially
a wrapper around <tt>getrandom()</tt> when that system call is available.
As a result, the performance of <tt>getrandom()</tt> also determines how
fast <tt>arc4random()</tt> will be.
<p>
<h4>The vDSO API</h4>
<p>
As "<q>extremely fast</q>" as <tt>getrandom()</tt> may be, some users have
apparently complained that it still is not fast enough. In
response, Donenfeld is now working to 
create a vDSO implementation.  The vDSO is a special range of kernel memory
that is mapped into each user-space process; it contains code that can be
called to perform system-call-like functions that can be carried out
without actually entering the kernel, thus avoiding the cost of a context
switch.  System calls implemented in this way 
can include <a
href="https://man7.org/linux/man-pages/man2/getcpu.2.html"><tt>getcpu()</tt></a>
and <a
href="https://man7.org/linux/man-pages/man3/clock_gettime.3.html"><tt>clock_gettime()</tt></a>
— both of which come down to simply reading some data out of the kernel.
<p>
Moving <tt>getrandom()</tt> into the vDSO has the potential to improve
performance for applications that need a lot of random data, but it will
clearly need to involve more than just reading some kernel data if the
guarantees made by that system call are to be upheld.  As a result, the
patch series implementing this functionality touches 59&nbsp;files and adds
some 1,200 lines of code.  It also complicates the
interface somewhat, in that there are now two (virtual) system calls
involved.  The first must be called at least once prior to requesting any
random data: 
<p>
<pre>
    void *vgetrandom_alloc(unsigned int *num, unsigned int *size_per_each,
                           unsigned long addr, unsigned int flags);
</pre>
<p>
The caller (likely to be the C library) should specify, in <tt>*num</tt>,
the number of "opaque 
states" needed; that number is likely to correspond to the
number of threads that are expected to run.  This call will allocate a
range of memory, returning its address.  The number of states actually
allocated will be stored in <tt>*num</tt>, and the size of each state in
<tt>*size_per_each</tt>.  The other two arguments are currently unused and
must be zero.
<p>
The library is expected to assign one of the returned states to each thread
in a process; the pointer to any given state can be had by offsetting the base
address by a multiple of the value returned in <tt>*size_per_each</tt>.
The kernel uses this space to track the state of the random-number
generator for the thread; user space should not access its contents.
Should more state-storage space be needed, more calls can be made to
<tt>vgetrandom_alloc()</tt>. 
<p>
With the state space in hand, random data can be obtained with:
<p>
<pre>
    ssize_t vgetrandom(void *buffer, size_t len, unsigned int flags,
    		       void *opaque_state);
</pre>
<p>
The first three arguments are the same as for <tt>getrandom()</tt>, while
<tt>opaque_state</tt> points to one of the states returned by
<tt>vgetrandom_alloc()</tt>.  The intent is for this function to behave
just as <tt>getrandom()</tt> would, only faster.  Applications would not
normally call it directly; instead, it would be invoked from the C
library's <tt>getrandom()</tt> wrapper.  Donenfeld said (in the cover
letter) that
"<q>performance is pretty stellar (around 15x for uint32_t generation), and
it seems to be working</q>".  
<p>
<h4><tt>VM_DROPPABLE</tt></h4>
<p>
While some developers are clearly unconvinced about the need to optimize
<tt>getrandom()</tt>, most of the patch series is relatively
uncontroversial at this point.  There is one significant exception, though:
the management of the "opaque state" data.  This data is used by the kernel
to ensure that each caller to <tt>vgetrandom()</tt> gets a unique stream of
random data, that each thread's random-number generator is reseeded as
needed, and so on; it can be thought of as a sort of per-thread entropy
storage that 
can be consulted without entering the kernel.  For the curious, each state
entry is defined (in the kernel) as:
<p>
<pre>
    struct vgetrandom_state {
	union {
	    struct {
		u8	batch[CHACHA_BLOCK_SIZE * 3 / 2];
		u32	key[CHACHA_KEY_SIZE / sizeof(u32)];
	    };
	    u8		batch_key[CHACHA_BLOCK_SIZE * 2];
        };
    	vdso_kernel_ulong	generation;
    	u8			pos;
    	bool 			in_use;
    };
</pre>
<p>
This structure occupies 256 bytes, which is not huge, but a system running
a lot of threads could have quite a few of them.  This is kernel-allocated
memory that, in effect, must be locked into RAM; writing it out to secondary
storage could expose the state of the random-number generator, potentially
creating security problems.  The state memory must thus be treated
specially. 
<p>

Earlier versions of the patch set used <a
href="https://man7.org/linux/man-pages/man2/mlock.2.html"><tt>mlock()</tt></a>
to ensure that this memory would stay in place.
There were some problems with that approach, though, starting with the fact
that locked memory is subject to resource limits.  If the kernel and C
library start using some of a process's allowed locked memory for
random-number generation, once-working programs could start failing.
Locked memory will also become unlocked in the child process after a fork.
So using <tt>mlock()</tt> is not an ideal solution.
<p>
The memory used for states has another interesting characteristic, though:
it can simply vanish at any time with minimal consequences.  Since it is,
at its core, a cache of random data, it can be replaced with more random
data.  This can already happen if, for example, the thread forks.  In the
worst case, should the state memory not be available at all, the vDSO
function can just make a proper call to 
<tt>getrandom()</tt> to get its job done (albeit more slowly).  So, while
the state memory 
should be locked in the sense of not being written to swap, it does not
need to be absolutely nailed down in RAM; it can be thrown away if need be.
<p>
Donenfeld decided to take advantage of the disposable nature of this
memory.  Rather than using <tt>mlock()</tt>, the current patch set adds a
new (kernel-internal) memory flag called <tt>VM_DROPPABLE</tt>.  Memory
marked with this flag will never be written to swap or a core dump, and the
memory-management subsystem can, if memory is tight, just reclaim it for
other uses.  <tt>VM_DROPPABLE</tt> memory is demand-paged, in that it is
not actually allocated until an attempt is made to access it; normally the
failure to allocate a page in this circumstance will be fatal for the
process involved.  With <tt>VM_DROPPABLE</tt> memory, instead, failures are
simply ignored and any attempted writes are simply dropped — an outcome that
is effected with some low-level, architecture-specific magic that simply
skips the instruction attempting the write.
<p>
<h4>Dropping <tt>VM_DROPPABLE</tt></h4>
<p>
Ingo Molnar <a
href="/ml/linux-kernel/Y7QIg%2FhAIk7eZE42@gmail.com/">objected strongly</a>
to this patch, saying that it adds complexity to a subsystem that needs a
high level of trust.  It would be better, he said, to just make
<tt>mlock()</tt> work as needed or simply let the vDSO allocate a few pages
outside of the existing resource limits.  Donenfeld <a
href="/ml/linux-kernel/Y7RDQLEvlLM0o4cp@zx2c4.com/">reacted poorly</a>,
questioning Molnar's motives.  Molnar then <a
href="/ml/linux-kernel/Y7Rw1plb%2FpqPiWgg@gmail.com/">vetoed the patch</a>,
leading to more <a
href="/ml/linux-kernel/Y7R5OokY7P+H2vuD@zx2c4.com/">complaints</a> from
Donenfeld, who did point out, though, that a process can
make an arbitrary number of calls to <tt>vgetrandom_alloc()</tt>, so care
needs to be taken to prevent it from being used to circumvent the limits on
locked memory.  Simply tweaking <tt>mlock()</tt> would not be a sufficient
solution.
<p>
Andy Lutomirski also <a
href="/ml/linux-kernel/CALCETrWdw5kxrtr4M7AkKYDOJEE1cU1wENWgmgOxn0rEJz4y3w@mail.gmail.com/">disliked
<tt>VM_DROPPABLE</tt></a>, saying that Donenfeld was "<q>trying to shoehorn
all kinds of bizarre behavior into the core mm</q>".  He suggested that
Donenfeld could, instead, create
a special type of mapping, with its own local implementation, to obtain
the needed semantics; the kernel provides the infrastructure needed to do
this.  There would then be no need to modify the core 
memory-management subsystem.  Donenfeld had <a
href="/ml/linux-kernel/Y7R8Zq6sIKAIprtr@zx2c4.com/">a relatively positive
reaction to this suggestion</a> and seemed ready to proceed in that
direction.  Linus Torvalds, though, <a
href="/ml/linux-kernel/CAHk-=wg_6Uhkjy12Vq_hN6rQqGRP2nE15rkgiAo6Qay5aOeigg@mail.gmail.com/">argued</a>
that none of this effort was worth it.  Speeding up random-number
generation, beyond a point, is not the kernel's job, he said; instead, that
should be left to the C library.  After some discussion, Torvalds <a
href="/ml/linux-kernel/CAHk-=wi4gshfKjbhEO_xZdVb9ztXf0iuv5kKhxtvAHf2HzTmng@mail.gmail.com/">made
his position clear</a>:
<p>
<blockquote class="bq">
	I'm NAK'ing making invasive changes to the VM for something this
	specialized. I really believe that the people who have this issue
	are *so* few and far between that they can deal with the VM forking
	and reseeding issues quite well on their own.
</blockquote>
<p>
Donenfeld has also been clear in his disagreement with Torvalds's
assessment of the need for this feature, though; he <a
href="/ml/linux-kernel/Y7SDgtXayQCy6xT6@zx2c4.com/">claimed</a> that it
just isn't possible to create a safe random-number generator in user space
(the patch cover letter also covers that ground in depth).  He later <a
href="/ml/linux-kernel/Y7dV1lVUYjqs8fh0@zx2c4.com/">went on to say</a>:
<p>
<blockquote class="bq">
	I think the moral of yesterday's poo-poo'ing all over this cool new
	idea is that the Linux innercircle doesn't really care for
	"security things" as a motivator and just takes the shortest and
	easiest route toward swatting it away like a gadfly, assuming that
	the concerns are unreal or niche or paranoid or whatever.
</blockquote>
<p>
It will probably come as little surprise that Torvalds <a
href="/ml/linux-kernel/CAHk-=wijEC_oDzfUajhmp=ZVnzMTXgjxHEcxAfaHiNQm4iAcqA@mail.gmail.com/">disagreed
with this view</a>.
<p>
In the end, though, there do appear to be valid arguments, from both
performance and security points of view, for a vDSO
<tt>getrandom()</tt> implementation.  
So work on the vDSO patches is likely to
continue, but the <tt>VM_DROPPABLE</tt> flag is clearly not going
to clear the bar.  Donenfeld will almost certainly return with an
implementation based on Lutomirski's suggestions; that should address the
main concerns that have been raised about this work.  At that point, its
chances of getting upstream are probably reasonably good, even if some
developers remain unconvinced about how necessary it really is.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Random_numbers">Random numbers</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Random_number_generation">Security/Random number generation</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/919008/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor919236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM_DROPPABLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 17:25 UTC (Fri)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/919236/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
VM_DROPPABLE seems like a necessary (though perhaps insufficient) primitive for doing this in userspace, anyway. All the arguments Jason set out for why it's needed - e.g., the memory should not be swapped out, but it's okay if under memory pressure it just disappears because you can repopulate it from normal getrandom(), so it shouldn't count as mlocked - seem like they'd apply equally well to a userspace RNG as to a kernelspace one.<br>
<p>
I'm actually kind of surprised to see so much objection to it; is it because it's not being exposed to userspace and so it feels like complexity? A MAP_DROPPABLE mmap() flag seems like it would genuinely be useful to userspace, all the more so if this patchset as a whole is nacked.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM_DROPPABLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 20:59 UTC (Fri)
                               by <b>mwsealey</b> (guest, #71282)
                              [<a href="/Articles/919266/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would on the face of it be a ridiculously good thing to use for any and all kinds of application cache where you're really trying to keep data in memory but to be honest wouldn't care if it wasn't - a quick glance at any web browser where the original resources may as well be on disk or over the network but would work best if they were available in memory in a form a browser needs it. I'm not considering that you could just open a file and hope the kernel fills the page cache with bits of files, but say.. decoded or decompressed images. What about compiled GPU shaders or transient texture data for open world games or mapping software which shuffle this data in and out all the time?<br>
<p>
One thing it's probably not all that good for is random number storage, if that's the only use case anyone managed to come up with. But, per comments, the Linux folk do seem to swat away things if they only have one use case, and they can't use their gigas brains to come up with one other potential user for it. Things have to be in the kernel for userspace to take advantage of it, you won't see 50 userspace applications using an MM feature if it doesn't exist yet.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM_DROPPABLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 21:18 UTC (Fri)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/919272/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I remember reading the LWN articles on <a href="https://lwn.net/Kernel/Index/#Volatile_ranges">volatile ranges</a> from years ago.  Not sure if that work was ever merged, but madvise(MADV_FREE) does exist.


      
          <div class="CommentReplyButton">
            <form action="/Articles/919272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor919332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM_DROPPABLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2023 15:40 UTC (Sat)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/919332/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I mean, this is essentially how the page cache (ie, the cache for data read from files) works today.  Its contents can be evicted arbitrarily and will be refilled as needed from the backing file.  That covers the main need for userspace I think.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM_DROPPABLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 16:54 UTC (Sun)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/919372/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
VM_DROPPABLE as defined here does something different, if I'm understanding the patchset comments correctly: if it's evicted, it reads in as zeroes (it doesn't automatically refill) and more interestingly if there isn't enough room to allocate pages for it, writes are just silently dropped, meaning you never segfault or OOM-kill from either reads or writes.<br>
<p>
I think the use case for userspace is caches of calculations where it doesn't make sense to allocate a file on disk - not only is the disk space wasteful, you'd prefer to just be told "the data is lost" and recalculate it instead of doing disk I/O, because the calculation takes less time than paging from disk.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor919251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM_DROPPABLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 22:14 UTC (Fri)
                               by <b>saladin</b> (subscriber, #161355)
                              [<a href="/Articles/919251/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Later comments in the thread were talking about a VM_DROPPABLE flag that would send a signal to userspace when the dropped page was accessed. The dropping could be due to memory pressure, process/VM forks, or what have you.<br>
<p>
This use case would be harder for glibc to plumb than Jason's current patch, but would be much more generally applicable for uses like in-memory caching, storing secrets, or something more esoteric (emulators often use custom SIGSEGV  handlers already). I think that that's a better approach, if there's some big program that could use the flag.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919293"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">VM_DROPPABLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2023 2:40 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/919293/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One other thing, it might be good to integrate this with hypervisors, so that the random pools are dropped on hypervisor-based fork/restore.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919293/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor919239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 17:27 UTC (Fri)
                               by <b>Manifault</b> (guest, #155796)
                              [<a href="/Articles/919239/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;I think the moral of yesterday's poo-poo'ing all over this cool new idea is that the Linux innercircle doesn't really care for "security things" as a</span><br>
<span class="QuotedText">&gt;motivator and just takes the shortest and easiest route toward swatting it away like a gadfly, assuming that the concerns are unreal or niche or</span><br>
<span class="QuotedText">&gt;paranoid or whatever.</span><br>
<p>
Yikes, IMO that is just not the right attitude at all. We're talking about mapping random numbers to VDSO? Come on, requiring that kind of performance for random numbers is a niche use case (at least at this point) whether you want to admit it or not. That doesn't mean it isn't valuable, but _everything_ is a complexity tradeoff, and pretending like this is just a matter of people not caring about security really feels like a poor-faith reading of the room more than anything.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 21:33 UTC (Fri)
                               by <b>wittenberg</b> (subscriber, #4473)
                              [<a href="/Articles/919274/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fast random number generation will be required by many users in the next few years.<br>
<p>
When quantum computers get big enough (estimates are the mid 2030s), they will break our asymmetric cryptography.  That includes signatures, as well as PKI, and key exchange.  In short, almost everything.  In July 2022, has announced replacement algorithms (but not the parameters and protocols needed to use them).  The replacement algorithms require many more random bits than current algorithms.<br>
<p>
There are already requirements for government systems to start using the new algorithms (as soon as NIST announces the parameters and protocols required, which they say will be 2024.)  The deadlines for completing the transition are all 2035 or earlier.  I expect that commercial entities that need cryptography (certainly banks, block-chain systems, and other financial institutions) will also want to start their transition soon.<br>
<p>
There will be a mad rush in 2024 when the protocols are published, so we're trying to do as much as we can now.<br>
<p>
--David<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919296"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2023 4:04 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/919296/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A VDSO implementation of getrandom() only matters when you need to call getrandom() very frequently. If you just need more bits per call, it doesn't help at all. Quantum-resistant algorithms that need more key bits will be the latter case, not the former.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919296/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor919307"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 14:58 UTC (Sun)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/919307/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The reason getrandom() being faster is important, which I'm a bit disappointed was never brought up in the discussion (perhaps Donenfeld took it for granted) is not because anything needs secure random numbers that fast, but because it removes reasons *not* to use cryptographically random numbers.<br>
<p>
We've seen this pattern happen again and again:<br>
- Someone discovers that using the kernel RNG is kind of slow and decides to make their own in userspace<br>
- That RNG is weak, either deliberately (e.g. mersenne twister), accidentally (debian keypocalypse) or due to technical limitations (VM fork/checkpoint oblivious)<br>
- Someone inevitably accidentally ends up using those numbers in a security critical context, carnage ensues<br>
<p>
The solution here is the same as what most cryptographic improvements in the last decade have come from: Make one random number generator, make it as secure as possible, make it faster than you could write it yourself, and make it the default in everything. That's the only way to fix this, would fix it everywhere, far beyond just the kernel, and it's why Cryptography people get upset when people say it isn't necessary.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919307/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919377"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 20:11 UTC (Sun)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/919377/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That suggests that it might be best to separate the state management from the number production. There are applications where you want to get the same sequence in each clone (think duplicate bridge or reproducible tests), and it would be good if these applications didn't result in RNGs being around that were weakened in ways other than an explicit "generate from a captured seed" method.<br>
<p>
Maybe the right thing is to have the kernel support exclusively around making sure that nobody can ever see your per-thread primary RNG states and that they get created with data nobody could have predicted, and have the number production code in the standard library (with an occasional system call to ask for more entropy if needed and if the RNG instance is not supposed to be reproducible).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919377/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor919382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 20:45 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/919382/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is not reasonable to assume only kernel code can be trusted to be correct.<br>
<p>
"Concentrate effort on a small number of high quality RNGs", sure. But that number doesn't have to be 1; we have to evaluate cost-benefit tradeoffs.<br>
<p>
"Kernel support needed to protect RNG state", sure. Please do solve that problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 12:31 UTC (Mon)
                               by <b>judas_iscariote</b> (guest, #47386)
                              [<a href="/Articles/919403/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; It is not reasonable to assume only kernel code can be trusted to be correct.</span><br>
<p>
Nobody expects it to be perfect . One does expect to fix ONLY this one, if it has a problem.. all components benefiting from this fix.. move along. this argument of "only trusted and correct" can only be made by someone that has never looked at the alternatives or the sheer amount of work that is reviewing, fixing and maintaining all the userspace stuff. it is really scary.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor919383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 22:59 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/919383/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The solution here is the same as what most cryptographic improvements in the last decade have come from: Make one random number generator, make it as secure as possible, make it faster than you could write it yourself, and make it the default in everything. That's the only way to fix this, would fix it everywhere, far beyond just the kernel, and it's why Cryptography people get upset when people say it isn't necessary.</span><br>
<p>
The other problem, for people who aren't experts in the field, is that documentation of random numbers is hard to find. Personally, I've been looking for a PRNG with certain properties. I remember seeing it demonstrated in my maths classes (as an example of a bad random number generator) but I can't find it - after so many cycles, each number had appeared the same number of times. I'm trying to smear mirrored raid data across disks, to reduce rebuild stress (okay, it increases the risk of a double failure causing data loss, but it reduces the risk of recovery from a single failure triggering further failures). So far, pretty much everything I've tried has not managed to smear the data, rebuilding one failed disk means reading from two other disks max ... :-(<br>
<p>
If I could find this PRNG, maybe it would help - or maybe not ... but at least I'll have tried.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 23:38 UTC (Sun)
                               by <b>kschendel</b> (subscriber, #20465)
                              [<a href="/Articles/919385/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps you're thinking of RANDU()?  Xn+1 = 65539 Xn mod 2^31<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919391"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 3:38 UTC (Mon)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/919391/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, linear congruential generators of the form x_{n+1} = (a*x_n) % b have a period of at most b, and don't repeat any numbers before it reaches the period.  If a,b are chosen appropriately then it has period equal to b, then the output is simply a permutation of 0,1,2,...,(n-1).   If you want to use this for striping data over N devices then you might be able to find a constant a such that it has period N.  But why would that be better than writing them in some other specified sequence?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919391/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 9:09 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/919394/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem I have at the moment, is that for every block written to device a, EVERY mirror block ends up on either device b, or device c, whether I have 3 drives or 30 drives.<br>
<p>
I was looking for a generator that would break that property (while still guaranteeing that the mirror of a would not end up on a). I shall have to play, but if I can find arguments to the congruential generator that satisfy both properties, I will be well pleased :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 13:04 UTC (Mon)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/919405/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The low order bits of LCG's are notoriously non-random, eg the lowest bit alternating between 0 and 1.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor919409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 14:33 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/919409/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not do Tetris-style "bag of pieces" randomization?<br>
<p>
N: number of disks<br>
M: mirroring level<br>
<p>
- Take a list 1…N and permute it randomly<br>
- When writing to disk X, find X in the list at index K and mirror it to the disks at indices (K+n mod N, n from 1 to M) in the list<br>
- Permute the list whenever you want (each block write, reboot, 10 minutes, whatever).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 14:44 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/919410/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; - Permute the list whenever you want (each block write, reboot, 10 minutes, whatever).</span><br>
<p>
Because that would turn my Data Storage Device into a Data Shredding Device?<br>
<p>
I could generate a random lookup table, fix it up, and store it in the array metadata, but that's more stuff to fill up the disk space, any damage to it will destroy the array, and it will impact array creation. This needs to have the same lifetime as the array layout, which is why I'd rather a PRNG.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919465"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 18:58 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/919465/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This seems like a purely ephemeral data structure to me; why would it need to be stored with the array? Granted, I'm not super familiar with the use case and don't see how it turns into a shredding device.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919465/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 20:12 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/919470/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      Because it defines the layout of the blocks on the disk. Think of a drive, mapping the LBA numbers to the disk sectors. By default, LBA = platter,cylinder,head, sector. Scramble that mapping, like when you relocate bad blocks, and if you lose that mapping your data is gone.
<p>
Let's look at your standard Raid 1+0 ...
<pre><br>
sda sdb sdc sdd<br>
 1   2   1   2<br>
 3   4   3   4<br>
 5   6   5   6<br>
</pre><br>
So we have sda and b striped, c and d striped, and each pair mirrored. If one drive fails, we need a straight copy from the mirror to recover. If that drive fails under load, we're stuffed.
<p>
Now let's look at a linux Raid 10.
<pre><br>
sda sdb sdc sdd sde<br>
 1   1   2   2   3<br>
 3   4   4   5   5<br>
 6   6   7   7   8<br>
</pre><br>
Note that whichever drive fails, it's only the two drives, one each side, that gets hammered in the recovery. It's reduced the load a little, but not much, still inviting another disk failure.
<p>
I'm thinking more along the lines of a raid-51 or raid-61, but the crucial thing I want to avoid is only a couple of drives being hammered in a rebuild. But you see, the whole point of my PRNG, is to tell the raid which drive each block goes on. Lose that, and the data is scrambled ...
<p>
Cheers,<br>Wol





      
          <div class="CommentReplyButton">
            <form action="/Articles/919470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919491"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 22:52 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/919491/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      Oh, it's a one-time thing. Hmm. How about something like using a well-known number (e, pi, gamma, etc.) in base (N-1) to tell you how which other drive to select for the next block. Probably needs tweaking in case on drive fills up (maybe count empty slots not on the current drive?) or for redundancy &gt;2. So, say you have pi in base 4 for 5 drives and redundancy of 2:

3.0210033312222020201122030020310222

<pre>
sda sdb sdc sdd sde
 1   2   2   3   1
 4   5   3   4   5
 6   6   7   8   9
 A   7   A   9   8
</pre>




      
          <div class="CommentReplyButton">
            <form action="/Articles/919491/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919494"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 23:46 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/919494/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This looks well interesting ...<br>
<p>
I'm not going to try making something like raid-51 work across different size drives so I'm not going to address a drive filling up.<br>
<p>
And I'm not going to run the algorithm that far - the computational cost will be far too much. But if I can make it scramble 4 or 5 stripes, I can then just repeat that pattern.<br>
<p>
The only problem I have is I can't work out what you've done :-) <br>
<p>
Oh - and you've missed something which may or may not be important, in that we have the number of physical drives, and the number of logical drives. I don't think it will make a difference actually, it just affects the number of stripes I need to scramble. (I might have a 4-drive raid-5, mirrored and spread across 6 drives. But I think that's just making sure the number of stripes is a lowest common multiple, here it would be 12 ...)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919494/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2023 0:52 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/919495/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The only problem I have is I can't work out what you've done :-) </span><br>
<p>
3.0210033312222020201122030020310222<br>
<p>
Step 1: Find empty slot (sda/0)<br>
Step 2: Take next digit (3) and use the next slot on disk not_sda[3] (sde/0)<br>
Step 3: Repeat<br>
<p>
sda/0 - 3 -&gt; sde/0<br>
sdb/0 - 0 -&gt; sdc/0<br>
sdd/0 - 2 -&gt; sdb/1 (well, seems I messed up here, but this should be enough to make something more robust)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor919496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2023 0:58 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/919496/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Probably needs tweaking … for redundancy &gt;2.</span><br>
<p>
For R == 3 use digits from base N-2 to select the sector from the drives not already selected for that stripe. Keep reducing the base to get a "new" set of digits that are (essentially) random, but deterministic for the next drive to hold a new copy.<br>
<p>
This still runs into the "drive fills up" problem (where you just end up getting "unlucky" and hammer a specific drive all the time. In that case, maybe use an offset into the number's digits and try again?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919499"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2023 7:08 UTC (Tue)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/919499/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I still don't get why you want this to be random.  Am I understanding right that you want to mirror blocks of data onto N disks, such that each block gets written onto a pair of disks, and you want them distributed evenly, so that you don't end up with (for an example with N = 4) half the blocks mirrored on disks 1,2 and the other blocks mirrored on disks 3,4?<br>
<p>
In this N=4 example, there are 6 possible pairs ( = N(N-1)/2): 1:2, 1:3, 1:4, 2:3, 2:4, 3:4.  Each disk appears exactly 3 times in that list, so if you just allocated blocks round-robin to pairs of disks in that sequence you will end up with evenly distributed data, and if one disk fails then the other mirror pair of each block will be split evenly among the other drives.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919499/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919502"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2023 8:45 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/919502/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh the joys of a fresh pair of eyes ... :-) That's an excellent PRNG that looks like it does exactly what's required ...<br>
<p>
Thank you very much ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919502/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919509"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2023 13:38 UTC (Tue)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/919509/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could also order the sequence to minimize (or potentially eliminate, depending on the number of disks and number of mirrors) successive writes to the same disk(s).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919509/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor919500"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2023 7:10 UTC (Tue)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/919500/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, my reply above should have been to the parent of the post.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919500/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor919567"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2023 17:23 UTC (Tue)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/919567/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I'm thinking more along the lines of a raid-51 or raid-61, but the crucial thing I want to avoid is only a couple of drives being hammered in a rebuild.</span><br>
<p>
Might parity declustering be the thing you're looking for?<br>
<p>
<a href="https://www.pdl.cmu.edu/PDL-FTP/Declustering/ASPLOS.pdf">https://www.pdl.cmu.edu/PDL-FTP/Declustering/ASPLOS.pdf</a><br>
<p>
Unfortunately Linux mdadm/DM doesn't support it, AFAIU.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919567/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2023 21:33 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/919583/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm... very interesting reading...<br>
<p>
Actually, linux does support something like this, it's called raid-10. The number of logical disks in the array does not match the number of physical disks, and provided those two numbers are relatively prime, if I understand the paper correctly you will get exactly what they are describing with no effort. But linux doesn't support parity raid with differing logical and physical disk counts. No reason why not ...<br>
<p>
But I'm looking at raid-51 or raid-61, which means I don't care about parity - I should have a mirror somewhere. So I've massively reduced both i/o and computation relative to this paper. Assuming four logical drives, according to the paper I have to read 3 drives' worth of data for raid-5. I only need to read one drive's worth as I'm mirrored, but everything I've tried so far says it comes from just two physical drives. To reduce stressing the disks as per the paper, that means I need at least NINE physical drives - that's the first number that (a) means I need to read less than half a drive, and (b) is uniquely prime to my four logical drives to decluster it.<br>
<p>
So I'm unfortunately forced to the conclusion that - provided I'm not desperate to squeeze every usable byte of capacity out of my drives - even my flawed raid-51 algorithm is better than this declustered parity ... don't get me wrong, this is a very good tactic for a straight raid-5 or 6, but not for a mirrored one.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor919389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 3:24 UTC (Mon)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/919389/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are a few different concepts here that you might be conflating.  There are many different ways of generating random numbers, and they have very different properties.  So how you generate them depends a lot on what you need them for.<br>
<p>
If you want simple random numbers for a game, then you don't really care, you could use pretty much anything.  A simple linear congruential generator (LCG) such as suggested by kschendel below will probably do fine.<br>
<p>
If you are doing a simulation of some physical process that uses random dynamics (Monte Carlo simulation) then you want random numbers with very good statistical properties.  Simple random number generators, including older rand(3) implementations, won't cut it as statistical biases in the output will skew the results.  LCG's are notoriously bad for this.  These days the Mersenne Twister is the most common algorithm for these purposes.<br>
<p>
Then there are cryptographic uses for random numbers.  This comes with a completely different set of requirements, for example the numbers should be truly unpredictable; given a (possibly large) sequence of numbers it is impossible to predict the next number.  For the LCG, this is trivial (the 'internal state' of the RNG is simply the previous output, and even if you don't know the constants a,b in x_{n+1} = (x_n*a) % b it is pretty easy to work them out).  For the Mersenne Twister this is also fairly easy, eg <a href="https://github.com/fx5/not_random">https://github.com/fx5/not_random</a> .  Something like AES in counter mode (CTR) passes this test; the n'th random number x_n is given by AES(n).  Given any set of past output, you cannot calculate the internal state without breaking AES.  But this fails other desirable properties for cryptographic uses, in particular if you are able to get hold of the internal state of the RNG (the counter and the encryption key, in the case of AES-CTR) then you can determine all of the previous output.  You can make it 'forward secure' by mixing some of the output of x_n into the internal state.  Ideally you also want some entropy injection, so that even if an attacker gets hold of the internal state of the RNG at some time, they cannot predict the output indefinitely into the future.<br>
<p>
If you want to distribute data across a raid cluster, then I don't think you want any of the above algorithms.  You probably don't even want random numbers, or at least, not statistically independent random numbers.  The reason being that if you distribute data truly randomly, then there will be some chance that you get a distribution of data that is very bad.  Eg, if you want to distribute data evenly across disks, then you wouldn't want to do it completely randomly, because if you roll a dice 6N times, the probabiliy of getting each number appearing exactly N times goes to zero for large N.  There are other algorithms that you can use that give pseudo-random output but are correlated in such a way as to produce the desired distribution.  That is what you want to determine - what statistical properties do you want in your numbers.  In general it is a difficult problem to produce random numbers that have specified correlations, so you'll need to look for domain specific algorithms.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 10:06 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/919398/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If you want to distribute data across a raid cluster, then I don't think you want any of the above algorithms. You probably don't even want random numbers, or at least, not statistically independent random numbers. The reason being that if you distribute data truly randomly, then there will be some chance that you get a distribution of data that is very bad. Eg, if you want to distribute data evenly across disks, then you wouldn't want to do it completely randomly, because if you roll a dice 6N times, the probabiliy of getting each number appearing exactly N times goes to zero for large N. There are other algorithms that you can use that give pseudo-random output but are correlated in such a way as to produce the desired distribution. That is what you want to determine - what statistical properties do you want in your numbers. In general it is a difficult problem to produce random numbers that have specified correlations, so you'll need to look for domain specific algorithms.</span><br>
<p>
Yup. And all the algorithms currently in use have the bad property that the data on one disk is mirrored on at most two others.<br>
<p>
My main aim is to reduce raid stress, but it also might increase rebuild speed (the more drives the data is spread across, the more the rebuild speed tends towards the write speed of the replacement drive). And while disk damage is far less common than disk loss, it increases resilience in the face of that.<br>
<p>
Plus, of course, it's the mental challenge :-)<br>
<p>
But this is where I think the cryptographers (as mentioned by atnot) are making the exact same mistake they are accusing others of. "Secure cryptographic random" in my use case is an anti-feature. Let's have one callable function, where you're forced to specify which features are important TO YOU on setup, and then the actual function you get is determined by that. Even here, I doubt I could specify my requirements :-) which is why I *need* - not necessarily a "roll your own" - but a custom function for my purposes.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919503"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2023 8:52 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/919503/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The attitude of the cryptographers is probably that you should figure out which distribution you want, and then use inverse transform sampling to sample from it, starting from a "good" random number generator.<br>
<p>
But that wouldn't even solve your issue, because your issue is more fundamental. What you are asking for is not something that can reasonably be done with randomness,  regardless of distribution. Any distribution will, for large N, eventually exhibit whatever pattern you don't want it to in at least one case (unless you pick a trivial distribution). This is a simple corollary of the law of large numbers. You can probably get around it by wrapping the randomness up in some kind of stateful algorithm or data structure, but at that point, the random generator is not the problem, and you can very well use a "proper" one.<br>
<p>
In short: You don't want randomness, you want a deterministic permutation or cycle that, in the past, someone may have inaccurately described as "random." Cryptographers are, perhaps understandably, not interested in dealing with such historical curiosities.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919503/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919544"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2023 14:30 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/919544/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The attitude of the cryptographers is probably that you should figure out which distribution you want, and then use inverse transform sampling to sample from it, starting from a "good" random number generator.</span><br>
<p>
Which doesn't address the problem of "You want three? Pick two. Pick any two. But you can't have three". If someone wants speed over security (and there are good reasons for that), telling them they should accept the speed hit of a secure random function will simply get you laughed at. If cryptographers really do have that attitude, then they're living in a fool's paradise. Life is *ALWAYS* a compromise, and insisting that *YOUR* compromise is the only viable one is simply causing pain for everyone.<br>
<p>
<span class="QuotedText">&gt; In short: You don't want randomness, you want a deterministic permutation or cycle that, in the past, someone may have inaccurately described as "random." Cryptographers are, perhaps understandably, not interested in dealing with such historical curiosities.</span><br>
<p>
So why are *cryptographers* trying to hijack *random numbers*? I've been completely open I want a *P*RNG.<br>
<p>
This is the pain point. Random numbers, and cryptography, are two separate domains with considerable interaction. And until cryptographers stop pretending they are one and the same, we'll continue having fruitless discussions about "why aren't random numbers secure?". Because, just maybe, like in my case, security is one feature I *DON'T* want - in fact, it would be completely disastrous to me.<br>
<p>
(At which point, I have to say thanks to all the cryptographically minded people who've contributed and provided me with some great ideas :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919544/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor919250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 18:23 UTC (Fri)
                               by <b>saladin</b> (subscriber, #161355)
                              [<a href="/Articles/919250/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Having been watching this argument in the mailing lists over the last few days, I've been waiting for lwn (or phoronix) to cover it. Well done in beating Michael to it with a very high quality article. This is why I subscribe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor919257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 19:30 UTC (Fri)
                               by <b>anadav</b> (subscriber, #99427)
                              [<a href="/Articles/919257/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My hat off to Andy, who (almost) always comes with practical and pragmatic solutions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor919258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 19:35 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/919258/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Donenfeld has also been clear in his disagreement with Torvalds's assessment of the need for this feature, though; he claimed that it just isn't possible to create a safe random-number generator in user space (the patch cover letter also covers that ground in depth). He later went on to say: </span><br>
<p>
And why do you *need* a secure random number generator? Some people do, but surely they should just scrap all the user-exposed generators, and replace them with ONE new generator that has *mandatory* arguments to specify security, rng or prng, speed, whatever. That way people are forced to pay attention to what they get ... :-)<br>
<p>
Some hope :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919270"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 21:19 UTC (Fri)
                               by <b>dvrabel</b> (subscriber, #9500)
                              [<a href="/Articles/919270/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't see how the implementation of the random number generator helps with problems caused by virtual machine snapshots/forks. If a process fills a buffer with randomness, and then the VM is forked, all the VMs are going to see the same random data regardless of how "safe" the random number generation was.<br>
<p>
A mechanism to notify userspace of VM forks is needed, so userspace can discard or regenerate secrets/keys/whatever. If this mechanism exists then userspace random number generators can be made safe and need only be (periodically) seeded from the kernel's entropy pool (as per the original glib's arc4random() implementation).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919270/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919297"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2023 4:17 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/919297/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, exactly. It seems like vDSO getrandom() doesn't really solve anything. You might as well call getrandom() less frequently, but with larger buffers. That increases your vulnerability to VM cloning but it was already nonzero with vDSO getrandom().<br>
<p>
OTOH the issues of protecting userspace memory regions that must not get persisted anywhere are real.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919297/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2023 11:51 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/919312/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, maybe I'm wrong about the VM-cloning threat.<br>
<p>
Considering key generation: imagine a VM generates a key using random bits and no other inputs. Clearly there is no way to ensure the VM and its clone always produce different keys --- the clone can happen after the key was generated.<br>
<p>
On the other hand, image a VM generates a key based on random bits and some non-random input. We might want the property that if the non-random inputs are different, the VM and its clone will use different random bits. We *can* guarantee this by calling getrandom() after we have acquired the non-random inputs, and ensuring cloning the VM causes future getrandom()s to return different data than in the original VM. This would be broken by pregenerating random bits as I suggested.<br>
<p>
This is subtle. If you're worried about this threat you have to order operations carefully even if you have access to a suitable getrandom(). An easy-to-implement option would be to expose a fixed number of "VM UID" bits via shared memory in the vDSO that could be mixed into a userspace PRNG at the point where you want VMs to diverge.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor919284"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2023 23:23 UTC (Fri)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/919284/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      I'm left wonding how an <tt>io_uring</tt> implementation of <tt>getrandom()</tt> might compare to both the traditional syscall, and this proposed vDSO variant, in terms of both speed and complexity.


      
          <div class="CommentReplyButton">
            <form action="/Articles/919284/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919288"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2023 0:55 UTC (Sat)
                               by <b>judas_iscariote</b> (guest, #47386)
                              [<a href="/Articles/919288/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It does not help, this is one of the suggestions that show some people refuse to understand the needs of userspace components. It has to be something that <br>
- Fast, really fast without any significant syscall overhead that can be used anywhere for every random number number need without having to come up with ad-hoc algorithms. something that allow us to drop most if not all userspace prngs with dubious caracteristics. <br>
- It has to be async signal safe, thread safe, $whatever safe .<br>
- It must account for all the cases where the state needs to dropped and recreated, you cannot do that in userspace.<br>
- It must not block.<br>
- It must be usable from the dynamic linker up to high level components.<br>
<p>
<p>
<p>
<p>
  <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919288/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor919333"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2023 15:47 UTC (Sat)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/919333/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
io_uring is mostly about asynchronicity and potentially stacking up of multiple calls.  It is likely of no help for a necessarily synchronous call where you need that specific result immediately.  (Also getrandom() is, I believe, faster than the old fd based interface, which io_uring would use.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919333/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919374"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 18:04 UTC (Sun)
                               by <b>sbaugh</b> (guest, #103291)
                              [<a href="/Articles/919374/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many users of randomness are heavily threaded anyway (e.g. encrypted network communications). An io_uring-based getrandom() would probably improve performance for them, by allowing many calls from many threads to be performed at once. Or at least, because it much improves locality: <a href="http://catern.com/flexsc.html">http://catern.com/flexsc.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919374/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919375"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 18:19 UTC (Sun)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/919375/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The bigger problem is that it's unsuitable as a default implementation of random numbers, because it'll involve a whole bunch of program-specific effort to use<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919375/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor919334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2023 16:23 UTC (Sat)
                               by <b>compudj</b> (subscriber, #43335)
                              [<a href="/Articles/919334/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not do this as an RSEQ extension instead?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919335"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2023 16:38 UTC (Sat)
                               by <b>compudj</b> (subscriber, #43335)
                              [<a href="/Articles/919335/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
More precisely: let the kernel populate a per task struct random state, and copy it to extended RSEQ per thread structure fields on return to userspace. This would remove most of the complexity from this vDSO proposal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919335/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor919379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 20:00 UTC (Sun)
                               by <b>caliloo</b> (subscriber, #50055)
                              [<a href="/Articles/919379/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have to admit the 2 steps dance to initiate the thing and all the complexity around thread and fork safety make me wonder if that is a sane trade off. I wonder if the time spent into this wouldn’t have been better spent writing a good user space prng. And or perhaps a mechanism to alert user space about “plane of existence duplication” weather that is process forking, vm sibbling spin off, or whatever else.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 20:04 UTC (Sun)
                               by <b>caliloo</b> (subscriber, #50055)
                              [<a href="/Articles/919380/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And of course I have to wonder what is the use case for a high bandwidth random number consumer that forks or duplicate itself. Intuitively I’d think those high bandwidth thing tend to be highly isolated and compartmentalised from the rest of your infra thus not too sensitive to vm copy or fork situations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2023 23:28 UTC (Sun)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/919384/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
High-performance computing: simulations needing "randomness" require that the streams of numbers be independent.<br>
<p>
Also, sometimes utterly reproducible. Particularly if public policy / international relations are involved.<br>
<p>
These points are, erm, not well-addressed in general.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor919710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 12, 2023 4:25 UTC (Thu)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/919710/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Glibc will add arc4random for portability/compatibility, but still refuses to add strlcpy?  Jeez.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919998"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 14, 2023 19:23 UTC (Sat)
                               by <b>judas_iscariote</b> (guest, #47386)
                              [<a href="/Articles/919998/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
real life software includes its own full copy of the bsd arc4random* thing if not found in the C library. You *really* do not want that. it is ery different from a simple string function.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919998/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor920171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A vDSO implementation of getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2023 22:43 UTC (Mon)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/920171/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; includes its own full copy of the bsd arc4random* thing if not found in the C library</span><br>
<p>
Huh, why would anyone do that? Surely it's easier and makes more sense to detect arc4random and fall back to getrandom if former is not available, than to ship a full copy of arc4random.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/920171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
