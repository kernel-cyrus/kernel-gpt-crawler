        <!DOCTYPE html>
        <html lang="en">
        <head><title>ioctl() forever? [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/897202/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/896898/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/897202/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>ioctl() forever?</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>June 8, 2022</br>
           <hr>
<a href="/Articles/lsfmm2022/">LSFMM</a>
</div>
<p>
In a combined storage and filesystem session at the
<a
href="https://events.linuxfoundation.org/lsfmm/">2022 Linux Storage,
Filesystem, Memory-management and BPF Summit</a> (LSFMM), Luis Chamberlain
and James Bottomley led a discussion about the use of <a
href="https://man7.org/linux/man-pages/man2/ioctl.2.html"><tt>ioctl()</tt></a>
as a mechanism for configuration.  There are plenty of downsides to the use
of <tt>ioctl()</tt> commands, and alternatives exist, but in general kernel
developers have chosen to continue using this multiplexing system
call.  While there is interest in changing things, at least in some
quarters, the discussion did not seem to indicate major changes on the horizon.
</p>

<h4>Problems</h4>

<p>
Chamberlain began with a history lesson with "some rants" thrown in.
<tt>ioctl()</tt> is still used a lot by filesystems and the block layer in Linux,
but the wireless-networking subsystem, which he used to work on,  successfully shifted away
from <tt>ioctl()</tt>.  The system call "wasn't really originally designed for what
we think it was", he said; it is "essentially a hack".  In  <a
href="https://www.cs.dartmouth.edu/~doug/reader.pdf">Douglas McIlroy's history of Unix</a>,
it was called "a closet full of skeletons" that was mainly used to prevent
the addition of too many new system calls.  Those things should be kept in
mind when thinking about <tt>ioctl()</tt>, he said.
</p>

<a href="/Articles/897262/">
<img src="https://static.lwn.net/images/2022/lsfmm-bottomley-sm.png" border=0 hspace=5
align="left" alt="[James Bottomley]" title="James Bottomley" width=251
height=250>
</a>

<p>
The first version of Linux did not have <tt>ioctl()</tt>; it was added in
Linux-0.96a in May&nbsp;1992.  A small patch in&nbsp;1993 changed a type
from <tt>unsigned int</tt> to <tt>unsigned long</tt>, which eventually led
to compatibility headaches for 32-bit <tt>ioctl()</tt> calls
issued on 64-bit systems.  The Unix idea that everything is a file is
useful because it allows for flexibility, but it also allows for lazy API
design, he said.  Beyond that, <tt>ioctl()</tt> commands are not well
documented and the interface does not allow for introspection
</p>

<p>
Lack of introspection abilities is not a problem that Chamberlain has
encountered directly, so he asked Bottomley to elaborate on that.  The
problem crops up in the container world, Bottomley said, and it is not just
for <tt>ioctl()</tt> commands but also introspection for system calls. For
example, securing a Docker container by limiting the system calls it can
make does not really secure anything if there are opaque <tt>ioctl()</tt>
commands that can be used to circumvent the restrictions.  So there is a
lot of concern about non-introspective interfaces because they "can't be
policed properly by the tools we usually use for containers, like seccomp
and even eBPF".
</p>

<p>
The specific problem with <tt>ioctl()</tt> is that there is a "dense binary
packet" that gets passed into the call, which makes it difficult for
external tools to deduce what the packet contains.  In theory, the
kernel could switch to using XML or JSON, but that does not really change
the underlying problem much, he said.  The introspection problem remains
"almost regardless of which interface we choose".
</p>

<p>
There are other problems with <tt>ioctl()</tt>, Chamberlain said. For
example, he asked Arnd
Bergmann about <tt>ioctl()</tt> support for different architectures.  He
got back an itemized list of caveats. "The world is not peachy for
architecture support as well".
</p>

<h4>Greener grass</h4>

<p>
The Linux wireless-networking configuration underwent a shift from the
<tt>ioctl()</tt>-based
wireless extensions to the netlink-based nl80211 interface.  Chamberlain
invited attendees to compare <a
href="https://elixir.bootlin.com/linux/v5.18.2/source/include/uapi/linux/wireless.h"><tt>include/uapi/linux/wireless.h</tt></a>
with <a
href="https://elixir.bootlin.com/linux/v5.18.2/source/include/uapi/linux/nl80211.h"><tt>include/uapi/linux/nl80211.h</tt></a>
to see how much cleaner the new interface is.  The netlink interface is not
designed to be generic, so it may not be the right choice for filesystems
and the block layer.  But he is sure that that it is possible to find something better than the
<tt>ioctl()</tt>-based interface we have now.
</p>

<p>
Chamberlain handed the microphone back to Bottomley so that he could talk about <a
href="/Articles/809125/">configfd</a> as a possibility.   But Bottomley
said that he was not going to promote configfd, though he did describe it a
bit.  It came out of his efforts on the <a href="/Articles/718639/">shiftfs
filesystem</a>, which was eventually supplanted by <a
href="/Articles/896255/">ID-mapped mounts</a>.
Configfd was based on the
<tt>fsconfig()</tt> system call, which allows setting a bunch of
configuration information on a filesystem atomically, but configfd was
bidirectional.  David Howells, who developed <tt>fsconfig()</tt> and the
related <a href="/Articles/759499/">new mounting API</a>, interjected that
<tt>fsconfig()</tt> was originally bidirectional as well, though Al Viro
removed that piece before it was merged.
</p>

<p>
Instead of defending configfd, Bottomley said, he wanted to talk about the
necessity of <tt>ioctl()</tt>.  When there is a need for "an exception to
the normal semantic order of things", an <tt>ioctl()</tt> command can
provide it.  And there will always be a need for exceptions, no matter how tightly
regulated that semantic order is.  There will always be a requirement that
two parties be able to 
communicate data that cannot be structured using the existing mechanisms—an
exception. Whether that data is sent as JSON, XML, or binary data, it is,
effectively, an <tt>ioctl()</tt>.
</p>

<p>
The introspection problem is real, but is one that he thinks could be
handled with documentation.  Christian Brauner said that the problem goes
beyond just <tt>ioctl()</tt>; there are a number of different problems with
<a
href="https://www.man7.org/linux/man-pages/man2/seccomp.2.html"><tt>seccomp()</tt></a>
filtering because of the need to <a href="/Articles/822256/">inspect the
system call arguments</a> to help make filtering decisions.  Pointer
arguments have been discouraged for new system calls because
<tt>seccomp()</tt> cannot follow the pointers.  But using pointers to
structures is a technique for <a href="/Articles/830666/">creating
extensible system calls</a>, so <tt>seccomp()</tt> also needs to change.
It is a problem "slightly to the side" of the <tt>ioctl()</tt> problem, 
but it needs to be solved as well, he said.
</p>

<p>
Bottomley said that this shows that even if it were decreed that
<tt>ioctl()</tt> commands should all move to new system calls, the problem
with introspection would just move with it.  Ted Ts'o said that kernel
developers rightly keep a tight grip on new system calls and their
interfaces.  So adding a
new system call involves an enormous bikeshedding exercise with lots of
additional 
requirements, including documentation and working with features like
<tt>seccomp()</tt> filtering.  Often, the feature developer does not care
about the container use case, even if they should, so they move it to an <tt>ioctl()</tt>
command "so they can dodge the bikeshedding".  
</p>

<p>
The more perfect the kernel community tries to make the system call
interface, the more incentive there is for developers to route around it,
Ts'o said.
He has heard people talk about adding a feature via a filesystem-specific
<tt>ioctl()</tt> command as a way to avoid the "fsdevel bikeshed party".
That is unfortunate, since there is plenty of useful architectural review
that might come with trying to make the feature more widely usable, but
it is understandable that people take the expedient approach.  No one has
infinite resources, Ts'o said.
</p>

<h4>Alternatives</h4>

<p>
Josef Bacik asked what the alternative is. "You're going to pry <tt>ioctl()</tt>s
from my cold dead hands unless you give me something else."  The Btrfs
developers have "wasted a lot of time" in grand architectural discussions
that ended up with the community saying that a feature should just be put
into an <tt>ioctl()</tt> command—after a year of discussion.  Bottomley
said that he would argue <tt>ioctl()</tt> commands, used judiciously, are just
fine.
</p>

<p>
Kent Overstreet said that <tt>ioctl()</tt> commands are simply a
driver-specific system call; there is a real need for that.  It provides a
mechanism to try out a feature 
in a more private way before it gets promoted to a system call, where it
becomes permanent.  Amir Goldstein agreed, noting that the "chattr"
<tt>ioctl()</tt> command was implemented by two different filesystems
before it was determined to be a generally useful feature and moved into
the virtual filesystem (VFS) layer.
</p>

<p>
There are multiple existing mechanisms for configuration in the kernel,
Ts'o said. <tt>ioctl()</tt> commands are just system calls in disguise,
both of which provide ways to do configuration, 
but procfs and sysfs files can also be used for that.  Beyond
those, the new mount API or configfd provide other configuration
mechanisms. But which gets used depends in part on how much pain there is
in trying to change the mechanism for a new task, he said.  If the pain of
adding <tt>ioctl()</tt> commands rises to the same level as for system
calls, developers will simply find a "different escape hatch".
</p>

<p>
But Chamberlain said that adding new wireless commands did not require
additional system calls or <tt>ioctl()</tt> commands because it uses
netlink.  Those changes can be 
made in a domain-specific place without all of the problems that come from the
other mechanisms.  Brauner said that he had a hard time seeing what could
replace the <tt>ioctl()</tt> interface, however; he wondered if Chamberlain
was suggesting switching to something netlink-based.  Chamberlain said that
it was just one idea, but Howells noted that netlink could not be used
because it depends on networking being configured into the kernel, which is
not always the case.
</p>

<p>
There was some discussion of alternatives, but it is clear that
<tt>ioctl()</tt> itself is not going away and that it fills a need.
Finding ways to make the <tt>ioctl()</tt> arguments more introspectable would be useful, as
would better documentation. But if requiring those things causes the friction level
for adding new commands to rise too much, it will have the opposite of its
intended effect.  No real solution seemed to be forthcoming from the discussion, though no one
seems entirely satisfied with the status quo either.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#ioctl">ioctl()</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_Memory-Management_and_BPF_Summit-2022">Storage, Filesystem, Memory-Management and BPF Summit/2022</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/897202/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor897306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 14:48 UTC (Wed)
                               by <b>rincebrain</b> (subscriber, #69638)
                              [<a href="/Articles/897306/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
People might also use ioctl because they&#x27;re developers on something out of tree, the existing syscalls and ioctls have artificial limitations, and LKML has been actively hostile to anyone suggesting anything happen or not to improve things for projects which are unlikely to ever be mainlinable.<br>
<p>
So, since you can&#x27;t easily add custom syscalls to everyone ever, ioctl it is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor898296"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2022 21:33 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/898296/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is a stunning level of hostility, regardless of licence.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/898296/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor897308"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 15:18 UTC (Wed)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/897308/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One other issue with ioctl: it can mean different things to different devices, and there&#x27;s no guarantee of non-overlap (even though the kernel does attempt to avoid it).<br>
<p>
So if a filter mechanism needs to allow a particular ioctl, used with a particular device, it might also be allowing other unrelated and problematic ioctls on other devices that use the same ioctl number.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897308/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor897309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 15:52 UTC (Wed)
                               by <b>tau</b> (subscriber, #79651)
                              [<a href="/Articles/897309/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is also a tendency to crowbar a kernel&#x27;s API semantics into the language of a virtual filesystem, with virtual directories containing virtual text files. A compromise between machine readable and human friendly while being a poor fit for both.<br>
<p>
For relatively high-overhead and semantically complicated &quot;system calls&quot; I think that it would be nice if there was some sort of unified standard for user space and kernel space message passing that had a strong emphasis on message schemas and extensibility. Something like dbus. Or gRPC without all of the horrible HTTP/2 trappings. Or something with a design more suited to asynchronous communication like Wayland. Good luck getting a useful number of people to agree on what such a protocol should look like though. Of course it is very easy to say &quot;it would be nice if&quot; on a message board.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 18:34 UTC (Wed)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/897318/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A solution similar to gRPC doesn&#x27;t sound unreasonable. Protobufs, as an API specification, are much easier to machine process than the entirety of the C language. Protobufs also support schema evolution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 20:07 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/897327/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Protobufs, as an API specification, are much easier to machine process than the entirety of the C language.</font><br>
<p>
With CTF/BTF symbols, sticking to C would be easier and simpler for all involved, especially when you begin to look at what would be the most difficult part of structured, compound, nested data type filtering--actual filter specifications and execution. The obvious solution is a BPF program, which is precisely why BTF symbols were added to the kernel--so BPF programs could introspect kernel data types.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 20:25 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/897332/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even with CTF you still have problems with strings.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897381"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 13:37 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/897381/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, but that&#x27;s neither CTF nor BTF&#x27;s fault: that&#x27;s the same problem with dereferencing pointers (and finding a way to do that while not allowing attackers to modify the thing and sneak bad stuff past you via TOCTTOU races, *without* incurring horrible overhead by forcing every such pointed-to thing to be CoWed on modification).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897381/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 18:44 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/897436/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s why just marshalling all the data into variable-length structures that can be simply copied into the kernel space is the right way to do it. Yes, you have some overhead duet to packing and copying, but both are pretty efficient.<br>
<p>
Also, ioctl()s shouldn&#x27;t be performance-critical anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897458"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 23:14 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/897458/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
With CTF symbols you could easily write a simple function to recursively copy a data structure into kernel space. So you end up in the same place, but with a fraction of the complexity and code. For C string members you can trivially implement constraint checking during the copy. Similarly, for dependent pointer and size members you can include simple qualifiers in the structure definition that the copy routine can validate. (There was a proposal, effectively implementing a simple dependent type system for this case, which came close to passing muster for the next C2x revision. It seems to have failed for lack of real-world implementation experience, but strictly speaking it should be quite simple to implement.)<br>
<p>
Alternatively, you could implement a type-safe unpacking API. (If you only care about memory safety, you might not even need CTF.) For example, &quot;give me the next member, which I expect to be a NUL-terminated string&quot;. This may be more or less ergonomic than the above, but either way would provide the same effective interface as generic deserializers--even &quot;zero copy&quot; serialization formats typically cannot be exposed as plain C data structures, even when the serialization and deserialization code is generated a la Cap&#x27;n Proto. The difference between `string_t getNamedField(object_t)` and `string_t copy_in_string(userstruct_t *, cursor_t *)` is purely syntactical when you can&#x27;t completely trust the input to be well formed, which we can&#x27;t.<br>
<p>
In any event, simple intermediations, with or without CTF, provide avenues to enjoying all the same safety guarantees, without creating both kernel and userland dependencies on enormous (10-100+k SLoC) libraries. Microkernels tend to heavily rely on serialized message passing and/or RPC code generators. I&#x27;m sure they work well, but there&#x27;s a steep upfront cost, especially when it comes to tooling.<br>
<p>
Maybe even a simpler alternative is it avoid variable length strings entirely. Briefly looking at existing ioctls, it seemed like most string fields within structures are fixed-sized arrays. Variable length strings seemed more likely to be passed directly as an argument. (But please feel free to set me straight on that account as I didn&#x27;t look very hard and certainly didn&#x27;t write any tools to analyze the types.) To the extent the latter are a problem, they could be fixed with a very thin intermediating interface. There&#x27;s something to be said for simply using fixed-sized arrays. During the heyday of writing GNU replacements for proprietary tools, there was an emphasis on removing arbitrary limitations and permitting every conceivable type of input to be variable length and unbounded; that emphasis became pervasive and reflected in even trivial, internal interfaces removed from user input. That&#x27;s rarely needed, and rarely warranted given the resulting complexity, *especially* for kernel interfaces. Even file paths (or more specifically, file path arguments) have a fixed upper bound in the Linux kernel. Recently I discovered this was true even in Solaris, despite Solaris have a complicated kernel syscall facility for unbounded-length input and output syscall arguments. If you step away from trying to making everything configurable and unbounded, then it becomes much easier to limit complexity. Usually you can set an upper bound that is good enough and move on; and for many of the exceptions, you can switch to semantics that let you trade time for space (i.e. trade serial processing for discrete buffers). Or to put it another way, for the rare cases where setting fixed-bound arguments is too cumbersome, use netlink instead of ioctl. Problem solved. One doesn&#x27;t need to become the other, or replaced with something fancier; just make the choice more clear.<br>
<p>
If you want to make it easier to prevent people from accidentally doing the wrong thing, and to identify places where that might be likely, you can add type annotations to structures and other types used by kernel ioctl interfaces, complemented with a GCC module pass that identifies code that directly access members. IOW, you can implement something akin to Rust&#x27;s type checker that prevents normal code from reading pointers in an unstructured manner, forcing that code to go through a &quot;safe&quot; API.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897458/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor897317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 18:41 UTC (Wed)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/897317/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There is also a tendency to crowbar a kernel&#x27;s API semantics into the language of a virtual filesystem, with virtual directories containing virtual text files</font><br>
<p>
I don&#x27;t remember who said this, but the lesson should not have been &quot;everything is a file&quot; being good, but &quot;everything is a file descriptor&quot; being good. There is great value in having a unified way of representing kernel resources and associated access capabilities, one that can easily be shared between subsystems and passed between processes. But the part where you usually need to obtain those file descriptors by painfully funneling everything through hundreds of snprintf() and open() calls on hardcoded paths isn&#x27;t actually that valuable. In fact it often only undermines those valuable properties.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897341"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 0:53 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/897341/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Meh, snprintf isn&#x27;t the kernel&#x27;s fault, it&#x27;s C&#x27;s fault for being terrible at finagling strings. Stringly-typed interfaces are bad because they are difficult or impossible to validate, not because snprintf is painful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897341/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897342"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 1:35 UTC (Thu)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/897342/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This wasn&#x27;t at all meant to be a dig at snprintf(), feel free to insert your preferred mechanism. I just don&#x27;t think string formatting is something that should be regularly involved at the very core of OS APIs at all, even if C&#x27;s string handling wasn&#x27;t as uniquely terrible as it is. Although that fact doesn&#x27;t help of course.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897342/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor897319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 18:38 UTC (Wed)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/897319/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What is the functional difference between an ioctl() and an undocumented / unreviewed system call?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 13:33 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/897379/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Ability to avoid clashes. Even if out-of-tree device uses the same number as another out-of-tree device they don't affect each other because, well, they are different devices.</p>

<p>Syscall numbers are globals, on the other hand.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/897379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor897324"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 19:12 UTC (Wed)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/897324/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here&#x27;s my ioctl v2 proposal that came out of that discussion - something lightweight and minimal that would make ioctls more like normal function/syscalls:<br>
<p>
<a href="https://lore.kernel.org/lkml/20220520161652.rmhqlvwvfrvskg4w@moria.home.lan/">https://lore.kernel.org/lkml/20220520161652.rmhqlvwvfrvsk...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897324/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897333"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 20:32 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/897333/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For rr we really want to be able to determine, from the parameters and results of a syscall, all the userspace memory locations that a syscall writes to. Other tools (e.g. fuzzers) need the memory locations read as well. This is particularly hard for ioctls. The current ioctl op format is supposed to tell us the size of the data pointed to by the pointer, and whether it&#x27;s read or written or both, but this information is often incomplete or plain wrong. In the worst cases, the data in that struct is just the root of some elaborate data structure with many other userspace pointers in it. So it would be great if an ioctlv2 design solves this. One way would be to provide metadata allowing us to parse the layout *and making the correctness of that metadata testable by automated tests*. Another way would just be to require that the data be a single contiguous buffer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897333/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 21:24 UTC (Wed)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/897334/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
hey, I was just trying rr for my first time today!<br>
<p>
I&#x27;m not sure how practical it&#x27;ll be to solve this problem in general. My approach was to try and make ioctls more like syscalls - i.e. something that looks like a normal function call. That would make the simple cases simpler, by getting rid of ioctl structs entirely for the simple cases.<br>
<p>
But this won&#x27;t do anything for the more complex cases you brought up. The problem in those cases is just that C is a very low level language, and anything that&#x27;s complex enough to handle those cases isn&#x27;t going to feel natural and simple in C. This is my complaint with those advocating netlink as a wholesale replacement for ioctls - it&#x27;s more complicated than it needs to be for the simple cases. But for the more complicated cases maybe it&#x27;s the right approach.<br>
<p>
There&#x27;s another possibility that just occurred to me because I saw you were using it today - cap&#x27;n proto. If the problem is that defining complex data structures in a portable, ABI independent way sucks, this is exactly what cap&#x27;n proto is intended for. When I last looked at it the story for using it from C seemed incomplete, but maybe this has changed - might be worth another look.<br>
<p>
For those unfamiliar: cap&#x27;n proto [1] is a schema language for defining ABI independent types. Crucially, unlike things like protobufs, it doesn&#x27;t have pack/unpack operations - the wire format is the in memory format. It&#x27;s like defining types in C using only standard sized integers, only without all the razor sharp edges and some really useful features.<br>
<p>
1: <a href="https://capnproto.org/">https://capnproto.org/</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897337"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2022 21:32 UTC (Wed)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/897337/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In case it&#x27;s useful, here is a concrete example of a complex ioctl:<br>
<p>
<a href="https://sg.danny.cz/sg/sg_v40.html">https://sg.danny.cz/sg/sg_v40.html</a><br>
<p>
The sg driver has ioctls for sending generic SCSI commands, so it supports read-type, write-type, and bidirectional commands, direct I/O, pointers to arrays of iovecs of userspace buffers like readv/writev, pointers to buffers to contain error information, async I/O, and lots of other complex features, and it has to be high-performance.  It&#x27;s sort of like io_submit() and io_getevents() for SCSI commands in an ioctl().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897337/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor897347"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 5:43 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/897347/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unix has had a standardized serialization format for decades: XDR. <a href="https://en.wikipedia.org/wiki/External_Data_Representation">https://en.wikipedia.org/wiki/External_Data_Representation</a><br>
An encoder/decoder has been in the Linux source tree since almost the beginning: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/net/sunrpc/xdr.c">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/...</a><br>
<p>
If better serialization formats sufficiently resolved these issues then presumably ioctl would already be gone, replaced by something using XDR or one of the other dozen similar formats that have come and gone over the years. The marginal benefit of these formats over plain C data structures is manifestly not that great, at least for local IPC.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897347/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897348"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 6:39 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/897348/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many ioctls were invented before rr or fuzzers or security mattered, and then all the other ioctls were added because that&#x27;s just how things are done.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897348/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor897350"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 6:55 UTC (Thu)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/897350/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think a lot of the problem is that the kernel refuses to define its ABI in any other way than &quot;here&#x27;s a pile of header files, and if you&#x27;re lucky also some documentation&quot;. This is a pain for any case except &quot;I&#x27;m a C program&quot;. ioctl isn&#x27;t the only offender here either -- setsockopt is another &quot;feed arbitrary data structures via a generic-looking interface&quot; mechanism.<br>
<p>
QEMU&#x27;s user-mode emulation runs into trouble with these things because we have to convert from guest architecture struct layout and endianness to host layout and endianness; without a machine-readable definition of what&#x27;s being passed around by ioctl and similar syscalls we have to hand-roll support for every new ioctl somebody cares about. And every so often we run into one that&#x27;s just straight-up not even documented.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897350/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897351"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 7:33 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/897351/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We really should come up with a shared description of the syscall ABI that can be used by QEMU, rr, fuzzers, ASAN, Valgrind, etc. I think we&#x27;re all duplicating work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897351/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897352"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 7:35 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/897352/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Syzkaller has an abstract description of syscalls: <a href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md">https://github.com/google/syzkaller/blob/master/docs/sysc...</a><br>
It&#x27;s fairly fuzzer-specific of course.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897352/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor897359"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 11:38 UTC (Thu)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/897359/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And ship it with kernel: mount -t abi ... !<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897359/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor897405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 15:11 UTC (Thu)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/897405/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To paraphrase the bard, &quot;That way [formal methods] lie; let me shun that.&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897629"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2022 0:16 UTC (Sun)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/897629/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Such is the pervading wisdom in software.<br>
<p>
It was yesterday I was commented that modern security practice is to layer incomplete speedbumps one by one and call it &quot;defense in depth.&quot; This was in response to new bypass of the M1&#x27;s hardware pointer checking, a &quot;last line of defense.&quot;<br>
<p>
None of these half-baked measures qualify as defense in depth. Anyone who calls it that is kidding themselves. They&#x27;re deployed one by one with large time spans inbetween, reactively to whatever attackers currently favor. It should come as no surprise that attackers have no problem paying a low continual cost to work around each new measure, in return for continued ability to exploit hosts.<br>
<p>
Meanwhile, we plaster over the undefined behavior that makes C/C++ static analysis impractical. We don&#x27;t even talk about how CPUs work. We continue to ignore that actual exploit *theory* exists, like the Weird Machine whose wikipedia page starts: &quot;Exploits exist empirically, but were not studied from a theoretical perspective prior to the emergence of the framework of weird machines.&quot; This makes it impossible to analyze systems holistically, and to find and shut out entire classes of exploits.<br>
<p>
Civil engineering eventually got past &quot;I think we can cut a small hole in this wall&quot; and reached &quot;lets calculate the loads and strains.&quot; Electrical engineering stopped electrocuting frogs and developed Maxwell&#x27;s laws. Right now computing is still far behind all others and until formal methods and theory take over, we won&#x27;t ever make statements like &quot;this bridge will stand for 100 years.&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897629/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897631"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2022 1:15 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/897631/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Electrical engineering stopped electrocuting frogs and developed Maxwell&#x27;s laws. </font><br>
<p>
Open the NEC and look for any mentions of Maxwell&#x27;s equations. If anything, modern safety engineering is built on installing as many &quot;speedbumps&quot; as possible, rather than on making everything perfectly safe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897631/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897640"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2022 9:01 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/897640/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>The NEC (and its international equivalents) are guides to safe installation, not to electrical engineering. It says that if you purchase products that have been engineered to a suitable standard, and then install them following this guide, you will be safe enough.
<p>The components you install when you buy the things that the NEC requires are engineered with things like Maxwell's laws as guidance - a GFCI or an AFCI or an ELCB or an overcurrent breaker, or even a simple switch is not just empirically designed to work as specified, but rather designed around the known laws of physics and then tested against the specification.
<p>It's just that we need the NEC rules because the possible range of components is not as wide as we'd like - and thus we need to allow for known physical issues when we install. For example, we need overcurrent breakers because wires have resistance and thus heat up when carrying current; a significant chunk of the NEC is describing the different ways you can install wires that meet a given standard, then place a breaker on the source end so that the wire cannot heat up enough to start a fire.


      
          <div class="CommentReplyButton">
            <form action="/Articles/897640/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897643"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2022 15:01 UTC (Sun)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/897643/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The main problem is that the market for electrical engineers actually *designing* these things is relatively static or slowly growing.  Meanwhile, companies are absolutely desperate to fill programming seats.<br>
<p>
And if it ain&#x27;t Python or Matlab/Octave, many students don&#x27;t know it until maybe their third year.  Maybe.  If type checking is not mentally established, the core of current formal methods that include interactive proofs is going nowhere.  (For the audience:  Making a program compile without type errors *is* working with an interactive proof system called the compiler.  The correct program is a proof of its being well-typed given the language&#x27;s rules / axioms.)<br>
<p>
I also suspect you underestimate how often &quot;throw it at the wall and see if it sticks&quot; applies even in engineering fields.  Or more appropriately &quot;this worked for something kinda similar, so it&#x27;ll work here.&quot;<br>
<p>
I recently learned of a wonderful text that can illustrate the kind of knowledge needed on the practical hardware side: D. M. Russinoff, Formal Verification of Floating-Point Hardware Design, <a href="https://doi.org/10.1007/978-3-030-87181-9_3">https://doi.org/10.1007/978-3-030-87181-9_3</a> .  It *appears* to be available gratis; I don&#x27;t think I was redirected through an institutional subscription.<br>
<p>
Software potentially could be simpler in some areas, but the OS/device level requires a similar level of skill in finding the right model.  That&#x27;s a polite way of saying the kind of infinite bike-shedding that was happening with btrfs.  If some research group can hit it out of the park like the formalization of RISC-V, sure, but people with product-like deadlines don&#x27;t have that time.  (I&#x27;ve been on both sides.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897643/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897645"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2022 15:37 UTC (Sun)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/897645/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You were in fact directed there by an institutional subscription :(<br>
<p>
For me, that link goes to a website run by Springer Nature, where I am informed that, as a private individual in the United Kingdom of Great Britain and Northern Ireland, I would have to pay £19.95 for a PDF of the Logical Operations chapter (pp 35-44) of ISBN 978-3-030-87181-9, £95.50 for the whole of ISBN 978-3-030-87181-9 as an eBook, or £119.99 for the whole of ISBN 978-3-030-87181-9 as a physical hardcover book (all prices inclusive of applicable VAT).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897645/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897795"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2022 21:57 UTC (Mon)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/897795/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
AUGH.  Drat.  Sorry!  I was hoping, and I didn&#x27;t see how I was already logged in.  There is no RTL in the book at all but rather proofs based around integers.  That&#x27;s kinda how I think of circuits, so I like it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897795/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor897825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2022 12:54 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/897825/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is archived by sci-hub.se, depending on what you think of that kind of thing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor897647"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2022 16:06 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/897647/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>And underlying that is that electrical safety is a mature and well-understood field. The physics involved in a GFCI or an overcurrent breaker have been well-understood since the 19th century, and the physics required for an AFCI were fully settled before World War I in 1914. There's nothing in any NEC-compliant installation that a good physicist from 1920 couldn't fully understand and explain - although they'd be amazed by the manufacturing techniques involved (and would be seriously shocked by the IC in an AFCI, even though they could explain the physical principles that underpin its operation).
<p>In contrast, logic design (both software and hardware) is a rapidly evolving field even today - Rust's type system is based atop affine logic from the 1970s, and there's mathematics I'm aware of that's probably relevant to programming language design that was only formulated rigorously in the last 20 years, and where there's active leading-edge research trying to determine if it's useful, and if so, how.
<p>I'd also agree on the "throw it at the wall and see if it sticks" thing - the only time, IME, that engineers actually seriously bother with the rigorous analysis that's possible for something like a GFCI is when you're cost-optimizing it. Otherwise, it's considered too much work, when you can take a design that's probably overkill but meets requirements and ship it.



      
          <div class="CommentReplyButton">
            <form action="/Articles/897647/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor897424"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 17:33 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/897424/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This sort of thing is why CTF was added to the toolchain :) abigail has support for it now, too... of course ioctls don&#x27;t all specify which structures they manipulate, but for those that *do*...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897424/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897595"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2022 7:50 UTC (Sat)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/897595/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How does CTF help here? I read <a href="https://lwn.net/Articles/795384/">https://lwn.net/Articles/795384/</a> which seems to describe it as basically a more compact debug info format, which leaves me unsure how it would be useful for describing the kernel ABI in a more machine-readable way. I guess in theory you could build the whole kernel and then fish out the debug info, but that would take forever and only have the info for the specific binary that got built...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897595/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor897355"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 11:02 UTC (Thu)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/897355/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;that netlink could not be used because it depends on networking being configured into the kernel</font><br>
<p>
Perhaps when someone ponders its use for a component, what they really had in mind was just the serialization format, without the AF_NETLINK socket. You could still hand in a netlink-formatted stream via ioctl.<br>
<p>
Netlink has its own share of issues. One is the asynchronous model and the programming that this entails; you need to do two at least two calls (send/recv). Another is the 16-bit size fields in its serialization format. If you can&#x27;t fit your stuff into one message because of that limit, you have to go on a multi-roundtrip endeavour from userspace. The kernel part meanwhile may need to keep extra state to logically tie the individual netlink messages together. That&#x27;s kinda terrible.<br>
<p>
Speaking of ioctl, setsockopt is just the same.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897355/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor897358"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 11:42 UTC (Thu)
                               by <b>jazzy</b> (subscriber, #132608)
                              [<a href="/Articles/897358/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Has someone considered copying Windows?<br>
<p>
BOOL DeviceIoControl(<br>
  [in]                HANDLE       hDevice,<br>
  [in]                DWORD        dwIoControlCode,<br>
  [in, optional]      LPVOID       lpInBuffer,<br>
  [in]                DWORD        nInBufferSize,<br>
  [out, optional]     LPVOID       lpOutBuffer,<br>
  [in]                DWORD        nOutBufferSize,<br>
<p>
Basically it allows for invoking an IOCTL and pass in and/or pass out a continous buffer. To me this seems extendable and avoids the need to embed pointers. It also clearly specifies what is readable and writable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897358/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897439"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 19:02 UTC (Thu)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/897439/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I imagine they would rather eat their own hats.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897439/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897442"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 19:25 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/897442/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I like how the metadata is &quot;optional&quot; when it probably means &quot;nullable&quot;. I doubt calling this without those arguments at all works out that well in practice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897442/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897443"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 19:27 UTC (Thu)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/897443/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I looked it up - the rules are documented. Which combination of nulls are allowed - if you go the overlapped (async) route you can leave the number of bytes out null and vice versa.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897443/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor897444"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 19:47 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/897444/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It works fine for IOCTLs that don&#x27;t need input or output parameters.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897444/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor897404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 15:00 UTC (Thu)
                               by <b>karim</b> (subscriber, #114)
                              [<a href="/Articles/897404/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just on the discoverability front, it would be great if there was a way to query any ioctl() interface for the commands it accepts and the parameters expected. A sort of obligatory man_ioctl() call on any kernel party that wants to expose ioctl(). I could then do something like &quot;$ ioman /dev/foobar&quot; and get a list of list of parameters, etc. Maybe even gate access to register an ioctl() on having said man_ioctl() registered along with it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897407"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 15:43 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/897407/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So, uh, what format will this communicate the requirements in? Snippets of C headers? ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897407/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 15:54 UTC (Thu)
                               by <b>karim</b> (subscriber, #114)
                              [<a href="/Articles/897409/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
man pages may have good examples. If you do a &quot;man 2 open&quot;, for instance, it lists all possible open flags with a description. Maybe something like that?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897413"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 16:27 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/897413/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From `ioman(1)`, sure. But what will `man_ioctl(2)` use to communicate whatever gets converted into groff format (or is the kernel going to speak groff directly?).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897413/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897414"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 16:39 UTC (Thu)
                               by <b>karim</b> (subscriber, #114)
                              [<a href="/Articles/897414/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Very good question. I can&#x27;t say I thought it all the way through. Maybe another inspiration could be online help output from commands that print options when you provide &quot;-h&quot; ... i.e. just some free-form text to be printed on screen when invoked. It&#x27;s a rough cut of an idea. Definitely requires some more forethought to be useful. But, personally, I&#x27;d love to have a way to ask about the ioctl()s available for any /dev/foo and even have a tool to invoke them from the command line if it makes sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897414/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 17:04 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/897416/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can&#x27;t force people to write documentation. If you try, you just end up with something like the following:<br>
<p>
<font class="QuotedText">&gt; int FrobnicateSprocket(Sprocket *s)</font><br>
<font class="QuotedText">&gt; Frobnicates a sprocket.</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; Arguments:</font><br>
<font class="QuotedText">&gt; s: The sprocket to frobnicate.</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; Returns:</font><br>
<font class="QuotedText">&gt; Zero if no error, or nonzero and sets errno.</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; Errno values:</font><br>
<font class="QuotedText">&gt; EPERM - Frobnicating this sprocket is not permitted.</font><br>
<p>
IMHO if you&#x27;re going to do something like this, it should be a machine-readable enumeration of commands, not a man page.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897611"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() forever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2022 12:26 UTC (Sat)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/897611/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you&#x27;re the kernel maintainers you absolutely can force people to write documentation -- just refuse to merge any patch that adds a new syscall or ioctl and doesn&#x27;t include documentation as part of the patchset. You can set the quality bar at any level you like. If stuff slips through the code review stage without sufficient documentation, you can revert it.<br>
<p>
In other words, allowing or not allowing undocumented new interfaces is a choice, just as allowing or not allowing changes that break userspace is a choice.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897611/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
