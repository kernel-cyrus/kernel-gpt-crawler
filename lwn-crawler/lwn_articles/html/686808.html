        <!DOCTYPE html>
        <html lang="en">
        <head><title>Two approaches to x86 memory encryption [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/686808/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/686393/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/686808/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Two approaches to x86 memory encryption</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>May 11, 2016</br>
           </div>
Techniques for hardening the security of running systems often focus on
access to memory.  An attacker who can write (or even read) arbitrary
memory regions will be able to take over the system in short order; even the
ability to access small regions of memory can often be exploited.  One
possible defensive technique would be to encrypt the contents of memory so
that an attacker can do nothing useful with it, even if access is somehow
gained; this type of encryption clearly requires hardware support.  Both Intel
and AMD are introducing such support in their processors, and patches to
enable that support have been posted for consideration; the two
manufacturers have taken somewhat different approaches to the problem,
though.
<p>
<h4>Intel's Software Guard Extensions</h4>
<p>

Intel's offering is called "Software Guard Extensions," or SGX; details can
be found on <a href="https://software.intel.com/en-us/sgx">the SGX web
page</a>.  SGX is built around the idea of creating "enclaves" of protected
code and data.  One or more ranges of physical memory are set aside as the
"enclave page cache"; the contents of that memory (whether data or code)
are only accessible to code that is, itself, located within the enclave.
That code is callable from outside the enclave, but only via a set of entry
points defined when the enclave is set up.
<p>
Memory within the enclave is encrypted using an engine built
into the processor itself; the key that is used is generated at power-on
and is not available to any
running code.  As a result, according to Intel's page, the contents of the
enclave are "<q>protected even when the BIOS, VMM, OS, and drivers are
compromised</q>".  Those will certainly be appealing words for anybody
who has despaired of ever preventing the compromise of any of those
components.
<p>
This mechanism seems to be aimed at protecting relatively small ranges of
memory; its overhead is apparently too high to do more than that.  So, for
example, one might load a private key and the code to sign data with that
key into an enclave.  Thereafter, it will be possible for an application to
use the key to create signatures, but nobody can gain access to the key
itself, even if the kernel itself is compromised.
<p>
The <a href="/Articles/685045/">SGX patch set</a>, posted by Jarkko
Sakkinen, creates a new device (<tt>/dev/sgx</tt>) which supports a number
of <tt>ioctl()</tt> calls to control the feature.  Interestingly, there are
no capability checks on the <tt>ioctl()</tt> calls themselves; anybody who
can open the device can set up enclaves — and the default permissions allow
access to everybody.

A new enclave is created
with <tt>SGX_IOCTL_ENCLAVE_CREATE</tt>, and pages of data are added to it
with <tt>SGX_IOCTL_ENCLAVE_ADD_PAGE</tt>.  Things are then made ready to
run with <tt>SGX_IOCTL_ENCLAVE_INIT</tt>.  That last operation requires
passing in an initialization token containing a hash of the enclave data and an
appropriate signature.  There does not appear to be a way to delete an
enclave once it has been established.
<p>
The "appropriate signature" part turns out to be a bit of a sticking point,
in that said signature must come from Intel itself.  In other words, it is
not currently possible for the owner of a system to set up and use an
enclave without getting Intel's approval and agreeing to <a
href="https://software.intel.com/en-us/articles/intel-sgx-product-licensing">a
set of conditions</a>. 
That means, as Ingo Molnar <a href="/Articles/686810/">put it</a>, that
"<q>it only allows the execution of externally blessed static binary
blobs</q>".  Needless to say, there is no shortage of opposition to that
idea in the kernel community; Ingo went on to say:
<p>
<div class="BigQuote">
	I don't think we can merge any of this upstream until it's clear
	that the hardware owner running open-source user-space can also
	freely define/start his own secure enclaves without having to sign
	the enclave with any external party. I.e.  self-signed enclaves
	should be fundamentally supported as well.
</div>
<p>
The discussion on the list <a href="/Articles/686811/">suggests</a> that
Intel does plan to eventually make the feature work without the need for
third-party signatures, but it is not clear when that might happen.
Meanwhile, there is another roadblock, in that the patches do not actually
work — one cannot actually run code in a protected enclave under Linux.
Instead, enclaves can only run in the "debug mode," where it's possible to
read and manipulate data inside the enclave from the rest of the system.
That, obviously, detracts from the utility of the feature.  It's not
entirely clear why this limitation is in place.

<p>
Jarkko had wanted to place the code into the staging tree, where developers
could play with it until it was actually made to work, but there is no
visible community interest in going along with that plan.  So the SGX
patches are going to have to wait for some time until (1)&nbsp;they
actually work, and (2)&nbsp;the hardware can support enclaves signed by
arbitrary parties.
<p>
<a name="sme"></a>
<h4>Secure Memory Encryption</h4>
<p>
AMD's technology is called "Secure Memory Encryption" (or SME); a
description can be found in <a
href="http://amd-dev.wpengine.netdna-cdn.com/wordpress/media/2013/12/AMD_Memory_Encryption_Whitepaper_v7-Public.pdf">this
white paper [PDF]</a>.  The <a href="/Articles/685215/">patch set</a> from
Tom Lendacky 
adding support for SME came out, by some coincidence, one day after the SGX
patches were posted.
<p>
SME is, in a sense, a simpler mechanism.  Rather than establishing
enclaves, a system with SME simply marks a range of memory (even all of
memory) for encryption by setting a bit in the relevant page-table entries.
The memory controller will then encrypt all data 
stored to those pages using a key generated at power-on time; all data read
from the range will be transparently decrypted.  No code running on the
processor (not even the kernel) has access to the encryption key.  Enabling
encryption is said to slightly increase memory latency, but the white paper
suggests that the performance impact will normally be quite small.
<p>
The SME approach, thus, will not protect memory from an attacker who has
compromised the kernel; from the point of view of a running system, the
memory might as well not be encrypted at all.  Instead, it is intended to
protect against cold-boot attacks, snooping on the memory bus, and the
disclosure of transient data stored in persistent-memory arrays.
<p>
SME can  be used as the base for another feature, though, called
"Secure Encrypted Virtualization" (SEV),
where each virtual machine gets its own key.  At that point, the value of
the feature will, if it functions as advertised, be significantly higher;
it can protect virtual machines 
from each other, keeping their contents secure even if one of them manages
to compromise the host system.  Indeed, it should be able to protect
virtual machines from the hypervisor itself.  In a world where everything
seems to be moving toward virtual machines running on shared cloud
infrastructure, this kind of protection would be a useful enhancement to
the security of the cloud as a whole.
<p>
The current patch set only implements SME, though, leaving SEV for the
future.  If the system is booted with the <tt>mem_encrypt=on</tt>
command-line parameter, encryption will be enabled for all of
physical memory, with a few exceptions.  Video memory, for example, should
not be encrypted; the device tree loaded at boot, if any, will also need to
be accessed in the clear.  Beyond that, encrypted memory will be used
throughout, with most of the system being entirely unaware that the feature
is in use.
<p>
The SME patches do not have the signature-related issues that came up with SGX,
but this feature was not universally acclaimed either.  Andy Lutomirski
detailed <a href="/Articles/686812/">several ways</a> that he thinks the
feature could be broken before concluding: "<q>But I guess it's better
than nothing.</q>"  Paolo Bonzini <a href="/Articles/686813/">added</a>
that the SEV feature is "<q>very limited unless you paravirtualize
everything</q>" and worried that it is being oversold as a general
mechanism for the securing of virtual machines.  He suggested that the work
should maybe not be merged in its current form.
<p>
Tom <a href="/Articles/686814/">acknowledged</a> that the technology has
limitations in its current form, saying:
<p>
<div class="BigQuote">
	In this first generation of SEV, we are targeting a threat model
	very similar to the one used by SMEP and SMAP. Specifically, SEV
	protects a guest from a benign but vulnerable hypervisor, where a
	malicious guest or unprivileged process exploits a
	system/hypervisor interface in an attempt to read or modify the
	guest's memory.  But, like SMEP and SMAP, if an attacker has the
	ability to arbitrarily execute code in the kernel, he would be able
	to circumvent the control. AMD has a vision for this generation of
	SEV to be foundational to future generations that defend against
	stronger attacks.
</div>
<p>
There have been no statements from the x86 maintainers regarding whether
the SME patches would be merged, but it would not be surprising if their
approach were similar to the one they have taken with the SGX patches: they
will be seriously considered when the full functionality is present and
that "vision" has been implemented.
<p>
The end result of all this discussion is that we will probably not see
support for either manufacturer's memory-encryption technology in a
near-term kernel.  But the direction that hardware development is taking
offers some encouragement.  Those of us who have despaired of ever truly
securing our software may well be right; we need levels of defense that
come into play when the software has failed.  Done right, hardware-based
defenses can come to the rescue here without taking away our power to
secure and control our own systems.  Once the hardware reaches that point,
Linux will certainly be able to take advantage of those capabilities.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Memory_encryption">Security/Memory encryption</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/686808/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor686945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2016 8:34 UTC (Wed)
                               by <b>mst@redhat.com</b> (subscriber, #60682)
                              [<a href="/Articles/686945/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The SME patches do not have the signature-related issues that came up with SGX, but this feature was not universally acclaimed either. Andy Lutomirski detailed several ways that he thinks the feature could be broken ...</font><br>
<p>
IIUC Andy's comments are about ways to break SEV, not SME.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/686945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor686962"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2016 11:11 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/686962/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Correct, and so was my request for advice about the viability of SEV in its current form. SEV patches actually have not been posted.<br>
<p>
Also, it is not really necessary to "paravirtualize everything". Tom explained how to support non-paravirtualized devices and acknowledged that the AMD manual is unclear on this detail.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/686962/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor686957"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2016 9:56 UTC (Wed)
                               by <b>linuxrocks123</b> (guest, #34648)
                              [<a href="/Articles/686957/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Loop-AmnESia, which is my work against the cold boot attack, will be obsolete on machines with SME enabled.  And, unlike Loop-AmnESia and TRESOR, SME will defend against reading SSH/SSL session keys, defend against sectors of the disk copied into the page cache, etc.<br>
<p>
I like SME.  SGX is also ... nice, sort of ... but its design is obviously geared mostly just for hardware-supported DRM.<br>
<p>
Oh, here's a nice review of SGX from 2013: <a href="http://theinvisiblethings.blogspot.com/2013/08/thoughts-on-intels-upcoming-software.html">http://theinvisiblethings.blogspot.com/2013/08/thoughts-o...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/686957/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor686976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2016 13:31 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/686976/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wow, SGX really does show its apparent heritage as an extension of the part of the odious closed-source-with-access-to-everything Management Engine that implements the DRM protected path, doesn't it? How to make a feature more or less useless in one easy lesson :( here's hoping it gets more useful in future, though the fact that it only works by virtue of a component that is, in itself, a huge gaping security hole that should never have existed is not a good sign.<br>
<p>
SME looks sufficiently less odious that, once it is really useful, it might in itself tempt me away from Intel CPUs back to AMD...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/686976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor687048"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2016 16:20 UTC (Wed)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/687048/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not at all clear to me that the ME has much to do with SGX.  The MEE does, but that's a different thing entirely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687048/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor687005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2016 15:19 UTC (Wed)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/687005/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have no problem with supporting SME in its current incarnation.  I just think that SEV is a bit dangerous in that people might thing it provides guarantees that it does not provide.<br>
<p>
The problem with supporting SGX in its current incarnation is that it's a closed ecosystem.  (In fact, it's so closed that there appears to be no public way to use it on Linux *at all* right now.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor687041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2016 15:47 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/687041/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok, good that we agree then. I will ask again for advice when the SEV patches are posted.  Thanks!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor687058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2016 17:13 UTC (Wed)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/687058/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess the SEV feature also has the disadvantage of making kernel same-page merging between VMs impossible.  Or not?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor687074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2016 20:10 UTC (Wed)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/687074/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also within the same VM (this is nice to have if you run Windows, because it zeros pages in the background).  But it's not a big deal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor687753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2016 19:58 UTC (Tue)
                               by <b>robbe</b> (guest, #16131)
                              [<a href="/Articles/687753/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Also within the same VM </font><br>
<p>
Why? Does the virtual address somehow figure into the encryption key?<br>
<p>
<font class="QuotedText">&gt; But it's not a big deal.</font><br>
<p>
Do you mean same-page merging does not give much benefits?<br>
<p>
<p>
FWIW, VMware ESXi had sharing of pages between VMs off by default for about two years, now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor687991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 19, 2016 10:08 UTC (Thu)
                               by <b>oldtomas</b> (guest, #72579)
                              [<a href="/Articles/687991/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Does the virtual address somehow figure into the encryption key?</font><br>
<p>
Most probably it is mixed in, as an initialization vector. You don't want two identical blocks to encrypt identically, because that gives clues to an eavesdropper.<br>
<p>
If you are encrypting sequentially, you typically use some hash of the last material as IV for the next; if you want random access, the address has to enter somehow (via a hash again).<br>
<p>
This page [1] has the gory details (for the TL;DR just look at the cute penguins ;-)<br>
<p>
[1] <a rel="nofollow" href="https://en.wikipedia.org/wiki/Cipher_block_chaining">https://en.wikipedia.org/wiki/Cipher_block_chaining</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor687091"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2016 23:00 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/687091/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Passing information between the hypervisor and guest will get interesting if the memory is encrypted with different keys (SEV).<br>
<p>
But it's probably a good thing as it will force the interface between the two to be well defined or break.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687091/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor687107"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 12, 2016 3:02 UTC (Thu)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/687107/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 (Disclaimer: I work for Intel, and I'm involved with the project to enable Open Source use of SGX.)<br>
<p>
<font class="QuotedText">&gt; This mechanism seems to be aimed at protecting relatively small ranges of memory; its overhead is apparently too high to do more than that.</font><br>
<p>
SGX supports arbitrarily large enclaves.  The encrypted region of physical memory has to be reserved during early boot (using the PRMRR_BASE and PRMRR_MASK MSRs), so typically it's a small portion of physical memory to avoid taking too much memory from the OS; however, that could be configured to be larger if needed.  Also, SGX supports the kernel paging memory in and out of the enclave (encrypting it before giving it to the kernel to store), which allows for arbitrarily large enclaves regardless of the amount of reserved physical memory.  Typically you do want to minimize the amount of code that you put inside the enclave to minimize your attack surface and the amount of code you trust, but there isn't any architectural limitation on size.<br>
<p>
<font class="QuotedText">&gt; The discussion on the list suggests that Intel does plan to eventually make the feature work without the need for third-party signatures,</font><br>
<p>
Specifically, we're introducing a new CPU feature to specify a key used to sign the Launch Enclave, which serves as the root of trust. This is already documented in the Intel Software Developer's Manual (<a href="http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-manual-325462.pdf">http://www.intel.com/content/dam/www/public/us/en/documen...</a>): in table 35-2, "Architectural MSRs", there are four MSRs, IA32_SGXLEPUBKEYHASH{0,1,2,3}, which together provide a SHA256 hash of the public key used to sign the launch enclave.  That same section also documents the CPUID bits that indicate the availability of those MSRs.<br>
<p>
The launch enclave specified by this hash then implements the policy that determines what enclaves can run (using any policy you choose), providing the root of trust; the hardware architecture then enforces isolation of enclaves.  Individual enclaves, in turn, can choose how much to trust each other, and would typically communicate between each other with cryptographic verification.  For instance, your ssh-agent enclave wouldn't trust someone else's ssh-agent enclave, but two isolated components run by the same user might, such as a secret-storage enclave and an enclave maintaining a TLS connection.<br>
<p>
See section 39.1.4, ""Intel SGX Launch Control Configuration", for more on how the launch control handles launch policy for other enclaves.<br>
<p>
<font class="QuotedText">&gt; Meanwhile, there is another roadblock, in that the patches do not actually work — one cannot actually run code in a protected enclave under Linux. Instead, enclaves can only run in the "debug mode," where it's possible to read and manipulate data inside the enclave from the rest of the system. That, obviously, detracts from the utility of the feature. It's not entirely clear why this limitation is in place.</font><br>
<p>
The CPU keeps the root of trust as simple as possible: within the CPU, it's just the hash of a key used to sign the launch enclave; code running in that enclave can then implement the security policy for loading other enclaves.  Debug mode is designed for development and proof-of-concept work (including of the launch enclave itself), before producing a production enclave and using production keys and signatures.  Debug mode doesn't require a signature that chains back to the root of trust.  Effectively, this makes it possible to use Skylake as a development platform for enclaves that will also run on future hardware in production mode with an owner-controlled root of trust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687107/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor687349"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 13, 2016 12:11 UTC (Fri)
                               by <b>malor</b> (guest, #2973)
                              [<a href="/Articles/687349/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; for enclaves that will also run on future hardware in production mode with an owner-controlled root of trust.</font><br>
<p>
So, in other words, it's not going to be under owner control in this chip generation.<br>
<p>
Personally, I wouldn't touch that with a fifty-meter pole.  That's just Trusted Computing writ large.  It means Intel or any authorized agent can trust my computer, and protect it, even against me. <br>
<p>
It has nothing to do with my benefit at all.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687349/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor687108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 12, 2016 3:19 UTC (Thu)
                               by <b>TRS-80</b> (guest, #1804)
                              [<a href="/Articles/687108/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      Does SME protect against Rowhammer?
      
          <div class="CommentReplyButton">
            <form action="/Articles/687108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor687111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 12, 2016 4:33 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/687111/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
not really (although it makes it a bit harder)<br>
<p>
rowhammer is a hardware bug where repeated access at one address can flip a bit at another address. the fixes are to make it harder to know the exact alignment of important memory<br>
<p>
encrypting the memory makes such attacks harder because you don't know what bits are being stored (without some other way of watching from the outside, which may exist)<br>
<p>
but there are only so 256 possible bit patterns, so it doesn't block it entirely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor687122"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 12, 2016 8:00 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/687122/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Alteration of the ciphertext will completely randomize the plaintext. So if you use rowhammer to flip a bit of ciphertext, the contents of the other location will change randomly.<br>
<p>
So rowhammer can still be used with SME (e.g. you could affect a key generation operation and produce non-prime p and q), but the result is much less controlled and thus the applicability is smaller.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687122/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor687225"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 12, 2016 16:11 UTC (Thu)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/687225/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If p or q is not prime, then standard RSA signature check/decryption will not work either, so it is not so easy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687225/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor687136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 12, 2016 9:34 UTC (Thu)
                               by <b>jsakkine</b> (subscriber, #80603)
                              [<a href="/Articles/687136/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just a minor correction. There is ioctl for destroying the enclave.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor687152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 12, 2016 11:20 UTC (Thu)
                               by <b>NAR</b> (subscriber, #1313)
                              [<a href="/Articles/687152/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <I>Thereafter, it will be possible for an application to use the key to create signatures, but nobody can gain access to the key itself, even if the kernel itself is compromised.</I>
<P>
The ability to create signatures isn't nearly as useful as actually having the key? So e.g. if a build system of a Linux distribution is compromised, the attacker can't obtain the key and sign packages on his own system, but is able to create and sign malicious packages on the compromised system itself, doesn't he?
<P>
<I>Indeed, it should be able to protect virtual machines from the hypervisor itself.</I>
<P>
I'm not familiar with these technologies, but isn't it possible for the hypervisor to somehow fake the CPU while SEV is turned on? The guest will happily assume that everything is encrypted, while it isn't.
      
          <div class="CommentReplyButton">
            <form action="/Articles/687152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor687340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 13, 2016 10:46 UTC (Fri)
                               by <b>bytelicker</b> (guest, #92320)
                              [<a href="/Articles/687340/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I like AMD's implementation the most. It is transparent and does not rely on external configuration. Intel's implementation remind me of a application level type of encryption. You could just as well manage your memory as encrypted in your application. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor687618"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2016 20:33 UTC (Mon)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/687618/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They do different things. AMD protects the OS, Intel protects the application (for DRM purposes, more or less).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687618/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor687951"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 18, 2016 22:50 UTC (Wed)
                               by <b>anguslees</b> (subscriber, #7131)
                              [<a href="/Articles/687951/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How do these compare to arm's TrustZone?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/687951/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor688108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Two approaches to x86 memory encryption</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 19, 2016 20:06 UTC (Thu)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/688108/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Like apples compare to oranges ;)&nbsp;&ndash; they are both fruits.<p>
ARM TrustZone just provides signals on the bus saying whether the CPU is in the &ldquo;trusted&rdquo; mode or not. (Actually, other bus masters&mdash;such as the GPU&mdash;generate the same signals as well). And bus slaves then enforce some separation between secure and non-secure memories, all strictly by address comparisons.<p>
<em>Some</em> ARM-based devices also implement memory encryption (as an extra layer, on top of TrustZone)&nbsp;&ndash; but this is far from being the norm.
      
          <div class="CommentReplyButton">
            <form action="/Articles/688108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2016, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
