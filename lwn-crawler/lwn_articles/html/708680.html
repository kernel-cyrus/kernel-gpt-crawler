        <!DOCTYPE html>
        <html lang="en">
        <head><title>The LPC Android microconference, part 2 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/708680/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/709349/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/708680/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The LPC Android microconference, part 2</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="GAByline">
           <p>December 21, 2016</p>
           <p>This article was contributed by John Stultz and Sumit Semwal</p>
           <hr>
<a href="/Archives/ConferenceByYear/#2016-Linux_Plumbers_Conference">Linux Plumbers Conference</a>
</div>
The Linux Plumbers Android microconference was held in Santa Fe on November
3rd; this is the second in a series of two articles covering the
discussions held at that event.  <a
href="/Articles/708679/">Part&nbsp;1</a> looked at the staging tree,
background updates, memory management, graphics, and more.  Read on for a
summary of the other discussions held that day.
 
<p>
<h4>OP-TEE and Trusty</h4>

<p>
Jens Wiklander from Linaro shared an overview on
secure-world implementations,  OP-TEE and Trusty in particular (<a
href="https://www.linuxplumbersconf.org/2016/ocw//system/presentations/3675/original/LPC%202016%20-%20OP-TEE.pdf">slides
[PDF]</a>). Jens works on
<a href="http://www.linaro.org/initiatives/op-tee/">OP-TEE</a>, which
provides an open-source trusted execution environment (TEE) that has been a
valuable reference implementation for research and education; most other TEE
implementations are proprietary. He noted that Google also
has its <a href="https://source.android.com/security/trusty/">Trusty
TEE</a> environment that is also open source, and that he 
would try to provide some comparison between the two where he could in his
presentation. 
<p>
He provided an outline of how TEEs and the secure-world
applications interact with the kernel and user space, applicable to both
OP-TEE and Trusty.  OP-TEE's implementation, in particular,
tries to implement a generic TEE API that user-space applications and the
TEE supplicant can interact with; it forwards commands to the
secure world via secure monitor calls (SMCs). Jens noted that Trusty's
approach is similar, but it uses a virtio driver to communicate with the
secure world.
<p>
One interesting aspect of the secure world is that there isn't necessarily
any persistent storage that it can use, so OP-TEE implements secure storage by
having trusted applications in the secure world encrypt and sign data that
they want
to persist. It passes that data out through the kernel to the
TEE supplicant, which stores the encrypted data in a database in
the filesystem.
<p>
Another aspect of the TEEs that he covered is how they do
scheduling. Entry into the secure world is normally done via an SMC or via
an <a href="https://en.wikipedia.org/wiki/Fast_interrupt_request">FIQ
interrupt</a> but, for OP-TEE, the work is done only via SMC calls, so 
all the scheduling done in the secure world is done as part of a command or
request from the kernel in the normal world. Trusty, instead, includes an
integrated scheduler which is triggered by the FIQ.  Communication between
the TEE and normal world is done via shared memory, which is implemented
via a reserved contiguous memory region. That region must then be set up
with the same cache settings in both secure and non-secure world.
<p>
OP-TEE currently supports a set of devices, including a
number of arm and arm64 devices. He also covered the xtest test suite that
OP-TEE uses for validation, which can be extended to support the
<a
href="http://www.globalplatform.org/specificationsdevice.asp">GlobalPlatform</a>
TEE compliance test suite.
<p>
Rom Lemarchand asked how much of the GlobalPlatform
API is supported with OP-TEE.  The answer was that both 
the internal and client APIs are supported. There was also a question as to
which crypto IP blocks are supported; currently none are.  When asked
if secure memory is supported on any of the supported devices, Jens's answer
was all except HiKey.  Rom was asked if he could further contrast
Trusty and OP-TEE to call out anything that wasn't covered. He clarified
that Trusty doesn't support GlobalPlatform at all, and that Trusty needs
crypto block and secure memory functionality to work. Jens noted that, while
OP-TEE is scheduled by the Linux side, Trusty can take some cores away for
exclusively secure execution. At that point the discussion died down and the
session moved on.
<p>
<h4>Multiple devices in AOSP</h4>

<p>
Rob Herring from Linaro discussed efforts to improve
support for multiple devices in the Android open-source project (AOSP) (<a
href="https://www.linuxplumbersconf.org/2016/ocw//system/presentations/3663/original/LPC2016%20-%20Supporting%20Multiple%20Devices%20in%20AOSP.pdf">slides
[PDF]</a>).  His larger goal is to try to
consolidate the hardware abstraction layers (HALs) that Android uses, and
allow vendors to develop kernel 
support for a device once and have it work on Android, ChromeOS, as well
as traditional Linux distributions. Vendors could then avoid the effort of
developing custom HALs when they don't bring new value.  This would make
upgrading to newer Android releases easier, allow devices with mainline
kernel support to "just work", and would allow for an upstream community
for Android devices to grow.
<p>
Currently if one wants to bring up Android on a new device, the seemingly
"standard" approach is to copy over the device directory for a system that
seems similar and rename all the files and variables with the new
product's name. This trivial renaming of code has the unfortunate
side effect of making diffs between implementations impossible. Then one
might scan through other devices to find any needed missing functionality
and copy-and-paste those in before building and testing.  This is pretty
poor.  Determining what's actually different 
between two builds for different devices is quite complicated; Rob
recalled a time where he tweaked the build system to generate multiple
megabytes
of configuration logs just so he could diff two builds. Another problem
facing the Android ecosystem is how to quickly upgrade devices to new
Android releases, which now come out monthly. This problem compounds if
you're trying to support more than one device.
<p>
The solution he's working on is trying to allow multiple devices to be
supported from a single build target, ideally moving to supporting devices
of the same architecture with a single filesystem image. He has implemented
this using Kconfig, which is used to generate <tt>BoardConfig.mk</tt> and
<tt>device.mk</tt> 
files. This provides a nice UI to allow configurations to be more
discoverable, and allows higher-level features that otherwise require
multiple configuration settings to be wrapped under a single element.
<p>
His build target currently supports DB410c, HiKey, Nexus 7, RaspberryPi&nbsp;3,
and QEMU (for x86_64, arm, and arm64).  He gave a brief demo of the Kconfig
options and outlined what he sees as the next steps: trying to push this to
AOSP, adding any missing Kconfig options as device supports grows,
supporting custom compilers or compiler flags, integrating a kernel build,
as well as supporting other features like <tt>malloc()</tt> or filesystem
selections. He then 
provided some input for folks who want to contribute, specifying that there
should not be device-specific configurations but, instead,  more fine-grained 
configuration options as needed, along with using device-specific default
configuration ("defconfig") files to
provide an easy way for folks to get a build for a specific device.
<p>
He also outlined some drawbacks with Kconfig.  It doesn't integrate
nicely with the top-level Android build,  so some stale files can be
left in the build tree when a configuration changes.  The defconfig
files also have 
to be kept current or they can grow stale as new configurations are
added. The Google developers in the crowd thought this effort was
interesting, but they suggested that Rob talk with the developer who is
reworking the Android build system to get his feedback.
<p>
<h4>HiKey in AOSP</h4>

<p>
John Stultz provided an update on support for HiKey boards
in AOSP (<a
href="https://www.linuxplumbersconf.org/2016/ocw//system/presentations/3669/original/HiKey%20in%20AOSP%20-%20Update.pdf">slides
[PDF]</a>).  HiKey is an arm64 board that was included as a target in AOSP 
back in March. Since then, work has continued and many features added,
including moving to the 4.4 kernel and updating to Android 7.0 (Nougat).  Recent
work has been done on integrating the <a
href="/Articles/706374/">energy-aware scheduler</a>, which is a 
collaboration between folks at Google, ARM, and Linaro. Integration of
OP-TEE and Trusty so that they can coexist as build-time options has been
worked on. Since most Android devices don't have to deal with dynamic
peripherals on buses that cannot be probed, work has been done on creating a
device-tree overlay manager so that different device-tree fragments can be
selectively applied, depending on boot arguments. Since downloading and
building Android can take multiple hours (or days), pre-built factory images
have been created so that developers can more easily get started using
HiKey boards with the latest Android release.
<p>
There has been a lot of work related to HiKey in the generic
Android <tt>common.git</tt> kernel tree: adding new features, cleaning up unused
ones, and prepping for an android-4.9 branch. John pointed out <a
href="https://www.youtube.com/watch?v=IX14Y6IG4Aw">Amit Pundir's talk
[YouTube]</a> on the status of the Android common tree, as Amit couldn't
present it in person. He also mentioned that HiKey was a target for Rob
Herring's generic-build effort discussed earlier.
<p>
Since HiKey will be supported for another year and a half in AOSP, there is
still a fair amount of planned work on things like moving forward to the
android-4.9 kernel (and beyond), finishing the OP-TEE/Trusty integration,
enabling A/B style updates, and enabling memory reductions.  John considers
this work useful, because devices released over the last few years often
use a kernel version that is one or sometimes two years old, and
stick with them.
<p>
HiKey's immediate migration to the latest LTS-based Android kernel allows
for testing and validation to help make those kernels more stable and
reliable.  That should result in less work to do when vendors do migrate to
newer 
kernels, hopefully allowing it to be done more quickly.  Further, since
HiKey development follows upstream kernels as well, testing and validating
mainline has caught a number of regressions, allowing them to be reverted
or fixed quickly, keeping those issues out of future LTS releases.
<p>
Many of the kernel changes needed for HiKey have been upstreamed recently,
with a handful of patches related to USB, HDMI-audio, and HDMI-output
reliability issues being pushed upstream but not yet merged. Of course,
there is still the large issue of Mali GPU support being based on
proprietary user-space code, so upstreaming that kernel driver (which makes
up by far the majority of the out-of-tree HiKey code) isn't an option, but
the dream of an open-source Mali
driver persists. 
<p>
John emphasized why this HiKey effort is so important: it's because we
really have two separate communities.  One of those is the AOSP and hardware
vendor community, which focuses on shipping a fully enabled, single device
quickly, where the specific kernel version used doesn't really matter that
much. The other is the upstream kernel community, where the priorities are
on long-term maintenance and common solutions that allow multiple devices
to work with a single binary, utilizing the mainline or linux-next. These
different focuses both make sense, but they also make communication between
the two communities difficult.  So HiKey enables a small but useful
area of overlap by providing an affordable device that works against the
latest upstream kernels and is also supported by the latest AOSP user
space. Thus, the device becomes a shared concern between the two
communities, and hopefully will bring them closer together, allowing for
more prototyping and validation between the communities.


<p>
<h4>Systems-level programming in Java</h4>
<p>
Elliott Hughes from Google shared recent
developments to enable systems-level programming using the
Java language in AOSP (<a
href="https://www.linuxplumbersconf.org/2016/ocw//system/presentations/3741/original/Android%20Systems%20Programming%20in%20Java%20(linux%20plumbers%202016).pdf">slides
[PDF]</a>). He talked a bit about his own history with the Android
project, working on native (C/C++ based) tools and libraries, as well as
<a href="https://source.android.com/devices/tech/dalvik/">ART</a>, but
specifically his early efforts focused on cleaning up much of the native code
in Android.
<p>
The libcore code was initially written in C and suffered lots
of leaks and issues. His group switched to C++ and used tools to help clean up a
lot of leaks and crashes, but still left a fair amount of native code,
which can be problematic due to the semantic differences between Java and
Unix. So instead the developers decided to expose POSIX to Java, leaving the native
code to just marshal the data back and forth from the POSIX API
calls. This allowed for easier debugging in Java, but also allowed for more
flexibility.
<p>
With a few examples he showed how simple the
code was, along with how some of the complexity POSIX imposes with
error conditions returned via the global <tt>errno</tt> variable is handled.
This code has started seeing use outside
of the libcore code, as it allowed folks to avoid having to write their own
Java Native Interface logic (which is difficult to do correctly), and soon normal apps in the
Play Store wanted to use these interfaces too. So with Android Lollipop
(5.0), Google introduced <tt>android.system</tt>, which makes POSIX generally
available.
<p>
Some design choices were needed in its implementation;
for example in the translation of C types (such as choosing when to make a
<tt>char&nbsp;*</tt> a 
<tt>String</tt> and when to make it an <tt>Object</tt>) and creating Java
classes to match 
C&nbsp;structures.  Another example was how to handle <tt>errno</tt>, using
exceptions 
which return the <tt>errno</tt> value as well as the string name of the
function, 
which provides nice output for debugging like "open failed: ENOENT (No such
file or directory)". The group also provided <tt>OsConstants</tt>, which allows
the Java 
code to look much like&nbsp;C.
<p>
He covered a number of other miscellaneous design
choices made.  For example, functions always return new structures
rather than 
filling in existing ones, as it's safer and not that expensive. All of this
functionality is used in areas like networking code for DHCP, or
<tt>dup()</tt> and <tt>lseek()</tt> usage in media code, extended-attribute
usage, etc. Elliott  
concluded by saying that, while this isn't a particularly new feature, he
mostly wanted to use this talk to advertise it, as he thinks it will be
useful.
<p>
<h4>Using Clang in AOSP</h4>
<p>
The last speaker of the day was Bernhard (Bero)  Rosenkränzer from Linaro,
speaking about the use of the LLVM Clang compiler in AOSP (<a
href="https://www.linuxplumbersconf.org/2016/ocw//system/presentations/3681/original/LPC16%20-%20AOSP's%20switch%20to%20Clang(2).pdf">slides
[PDF]</a>). Since the release of Nougat,
Clang is now used instead of GCC to build Android's user space. This effort
required mostly small changes like making the code stick closer to
C&nbsp;standards, 
but there were some more difficult areas like variable-length arrays in
structures and differing semantics in the definition of
<tt>extern</tt>.
Several real 
bugs were found and fixed thanks to Clang's extra warnings.
<p>

The performance
of the system is unchanged, but build times are nicely reduced. GCC is now only
used for the kernel and some older device HAL implementations. However,
work to get the kernel building with Clang is also happening. Bero and
others at Linaro have been working on getting the HiKey kernel building with
Clang. That work is a little outdated and will be updated soon to 4.9. 
While some of the patches needed are on their way upstream, there are still
quite a few bad hacks involved.
<p>
Bero went over a number of the issues they encountered and
workarounds they needed in this project and pointed to a Docker image
he developed to make it easy for folks to get the proper toolchain
environment and kernel source to try it themselves.  Currently, the system
runs well, but there are a few odd bugs like crashes in Firefox.  While
Bero wasn't sure if there was much interest from Google in moving to Clang
for the kernel, the Google developers in attendance did say there was
interest, but they had been working on this in earnest for just a few
weeks, and suggested they sync up and collaborate to avoid duplicate work.
<p>
Now that the Clang patches needed to build AOSP user space have been
merged, Linaro is working to stay on top of the latest
Clang.  He outlined the testing efforts done to build AOSP master with the
latest Clang snapshots using continuous integration.  He pointed out some of the
new warnings and errors that Clang&nbsp;4.0 is producing and noted that, while
they aren't seeing too many compiler bugs in testing development branches
of Clang, there are the occasional issues that have to be reported.  As for
the future of GCC in AOSP: AOSP is using GCC&nbsp;4.9 and Bero suspects that is
not likely to change. However, Linaro continues to do testing building AOSP
master with GCC 6.x releases;  since different toolchains report
different warnings, building with both can help uncover issues that one
toolchain might miss. However, he worries that the Android build system
might someday depend too strongly on Clang plugins, preventing this
effort from being useful.
<p>
<h4>Conclusion</h4>
<p>
With that, after the microconference concluded, somehow on schedule
despite the huge number of sessions. Many thanks to all the speakers
and organizers for putting a great session together. Its really great
to see all the participation between community members and Android
developers.  Its quite likely there will be another Android microconference
at next year's Plumbers, which we look forward to.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Android">Android</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Stultz_John">Stultz, John</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2016">Linux Plumbers Conference/2016</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/708680/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor710112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The LPC Android microconference, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 24, 2016 7:03 UTC (Sat)
                               by <b>darwish</b> (guest, #102479)
                              [<a href="/Articles/710112/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is very high-quality coverage; thanks a lot! :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/710112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor710125"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CLang vs GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 24, 2016 10:19 UTC (Sat)
                               by <b>xav</b> (guest, #18536)
                              [<a href="/Articles/710125/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can someone tell me the motivation behind the effort towards getting rid of GCC ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/710125/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor710130"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CLang vs GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 24, 2016 12:40 UTC (Sat)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/710130/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not GPL therefore allows proprietary forks.<br>
<p>
(It's also a nicer codebase to work with, but that's not really relevant to end-users using it to compile stuff)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/710130/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor710134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CLang vs GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 24, 2016 17:38 UTC (Sat)
                               by <b>karkhaz</b> (subscriber, #99844)
                              [<a href="/Articles/710134/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Clang comes with several tools (like Clang Formatter, the Clang Static Analyzer, libfuzzer, and the Saninitizers) which are really nice to have around. They "just work" if you are able to compile your codebase with Clang.<br>
<p>
Folks who work with Go will tell you how much of a difference it makes, to have a first-class formatting tool as part of the official compiler. No more arguing about whether curly brackets go on the next line or whatever. Most people just use the default settings of gofmt and don't need to think about it.<br>
<p>
The Clang codebase is great to work with. It doesn't take too long to understand the data structures that represent the target program's Abstract Syntax Tree and to write tools that walk over the AST and manipulate it. End users don't care, but they will care when more and more cool tools are written that are not available if the codebase can only be compiled with GCC.<br>
<p>
I don't know that anybody wants to "get rid" of GCC for that reason (there may be other reasons). But it's nice to ensure that you can compile your codebase with both GCC and Clang.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/710134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2016, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
