        <!DOCTYPE html>
        <html lang="en">
        <head><title>Checksum offloads and protocol ossification [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/667059/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/666737/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/667059/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Checksum offloads and protocol ossification</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>December 8, 2015</br>
           </div>
Given the processing requirements for high-speed networking, it is not
surprising that there is interest in offloading some of that work to
dedicated hardware.  Linux has always carefully limited the support
provided for such offloading, though; it has been just over ten years since
support for TCP offload engines was
<a href="/Articles/148697/">definitively blocked</a> from entering the
Linux network stack.  That rejection was driven by a number of concerns,
with a reluctance to entrust network-protocol processing to closed-source,
unextendable,
unfixable software being near the top of the list.  Nearly ten years later,
offload engines are again the topic of fierce discussion.  The hardware has
changed, but the concerns have not; indeed, some of the problems being
worked around now show why those concerns were valid in the first place.
<p>
<h4>Encapsulation and ossification</h4>
<p>
Recent years have seen a large increase in the use of tunneling protocols,
especially those that use UDP as a mechanism to encapsulate and transport
packets for other protocols.  Tunneling has a lot of attractive features;
it allows the creation of virtual private networks on the large scale, and
virtual overlay networks to support virtualized systems on the smaller
scale.  The choice of UDP as the transport protocol may not seem entirely
obvious until one takes an important fact into account: of all the
protocols out there, only two, TCP and UDP, are widely supported by network
routers and 
protocol offload engines in network interfaces.  Tunneling protocols use
UDP because they have to if they are to get the performance they need.
<p>
Full-protocol offloading, as was discussed in 2005, is generally not
present in current hardware; if nothing else, the lack of Linux support for
that feature made it unappealing for hardware manufacturers.  But that does
not mean that modern network cards lack offload support; it is just more
specialized.  Most reasonable hardware can handle the calculation of packet
checksums (a relatively expensive operation on the host), packet
segmentation, and more.  These cards also support performance-enhancing
techniques like <a
href="https://www.kernel.org/doc/Documentation/networking/scaling.txt">receive-side
scaling</a> and <a
href="https://en.wikipedia.org/wiki/Equal-cost_multi-path_routing">equal-cost
multipath routing</a> — but only for a small subset of protocols.
<p>
Advanced hardware support has some obvious appeal, but it also has the
effect of setting protocols into stone — a process that is becoming known
as "protocol ossification."  We increasingly find ourselves on an Internet
that can only manage TCP and UDP, and relatively unchanging versions of TCP
and UDP at that. A great deal of the work behind the
development of the <a href="/Articles/544399/">multipath TCP protocol</a>
has gone into making it look like regular TCP so that it can be routed
efficiently and not be blocked by middleboxes that don't understand it.
The <a href="https://tools.ietf.org/html/draft-davie-stt-01">Stateless
Transport Tunneling protocol</a> takes things further by disguising a
stateless protocol behind (what looks like) TCP packets.  We have slowly
optimized ourselves into a situation where the development and deployment
of new protocols (or even significant enhancements to existing protocols)
is increasingly difficult;  even well defined protocols like <a
href="https://en.wikipedia.org/wiki/Stream_Control_Transmission_Protocol">SCTP</a>
and <a
href="/Articles/149756/">DCCP</a>
are hard to deploy in real-world settings.  
<p>
<h4>Tunneling offload</h4>
<p>
With regard to tunneling in particular, some hardware has, over the years,
grown support for some tunneling protocols.  The kernel now has support for
interfaces that can offload some aspects of <a
href="https://en.wikipedia.org/wiki/Virtual_Extensible_LAN">VXLAN</a>, for
example.  But that support doesn't extend to other tunneling protocols,
even VXLAN extensions like <a
href="https://datatracker.ietf.org/doc/draft-quinn-vxlan-gpe/">VXLAN-GPE</a>.
It is an attempt to expand this support that has raised some opposition in
the networking community.
<p>
Anjali Singhai Jain, representing Intel, recently posted <a
href="/Articles/667067/">a patch set</a> meant to generalize the kernel's
support for UDP tunnels and, in particular, add offload support for the <a
href="https://tools.ietf.org/html/draft-gross-geneve-00">GENEVE</a>
tunneling protocol to the i40e driver.  To that end, Anjali removed the
VXLAN-specific low-level network device operations, replacing them with
more generic versions that would have the actual encapsulation type passed
into them.  Nobody will mourn the VXLAN-specific code, but replacing that
code with multiplexer code that handles a multitude of tunneling protocols
was not seen as helping the cause.
<p>
One might wonder how offload comes into play with tunneling, given that the
whole point is hiding a network packet in another packet's payload where
the network interface shouldn't care about it.  Once again, it comes down
to checksum generation and verification.  Packets tunneled within
another protocol still carry their own checksums, and those checksums must be
valid.  If the hardware cannot generate or verify that internal checksum,
then the host system must do it.  One way to enable checksum offloading is
for the hardware to understand both the tunneling protocol and the protocol
being tunneled so that it can manage the checksums for both.  That has
been, for the most part, the approach that has been taken by hardware
manufacturers thus far.
<p>
The networking developers, though, do not want to see a world where each
network interface has support for its own special subset of tunneling
protocols, and where the kernel has to cope with all of them.  They are,
instead, developing a simpler, protocol-independent mechanism by which the
hardware can support any protocol with checksum offloading.  Those who want
the details can look at <a
href="http://people.netfilter.org/pablo/netdev0.1/papers/UDP-Encapsulation-in-Linux.pdf">this
paper by Tom Herbert [PDF]</a> and <a href="/Articles/666178/">this patch
set</a>.  The executive summary of the technique for the rest of us would
be:
<p>
<ul>
<li> For packet transmission, things are straightforward: the hardware
     accepts, with each packet, a range of data to be checksummed and the
     location within the packet where the checksum should be written.  The
     tunneling protocol can set that range to indicate the encapsulated
     packet and its own checksum field, and everything just works.  (Note
     that, in situations like this, the outer UDP checksum is just left as
     zero, since it is redundant anyway).
<p>
<li> For packet reception, verifying the inner checksum requires an
     awareness of the tunneling protocol itself.  Rather than bury such
     awareness in the hardware, though, the networking developers would
     rather that the interface simply calculate a checksum for the packet
     as a whole.  It is then a relatively cheap operation for the kernel to
     "subtract out" the portion of the checksum corresponding to the outer
     headers and arrive at the correct inner checksum.  Hardware that
     operates in this way can support any tunneling protocol without a lot
     of protocol-specific code at the driver level.  There have also been
     <a href="/Articles/667163/">suggestions</a> that Berkeley Packet
     Filter (BPF) programs could be used for more complicated processing.
</ul>
<p>
Given that the kernel developers want to go in this direction, it is not
surprising that Tom <a href="/Articles/667071/">pushed back against
Anjali's patches</a>, saying that they encourage manufacturers to implement
more protocol-specific awareness into their interfaces rather than
implementing the protocol-independent mechanism he would like to see.
Networking maintainer David Miller was <a href="/Articles/667072/">quick
to state</a> that he would not be merging code that takes things in the
wrong direction.
<p>
<h4>What happens next?</h4>
<p>
The problem with that position, of course, is that cards with, for example,
GENEVE support are shipping now, and users will want to make use of them.
At best, blocking support for that hardware condemns those users to slower
tunneling performance.  A worse scenario, <a href="/Articles/667073/">put
forward</a> by Alexander Duyck, is that users would move to out-of-tree
binary drivers or user-space protocol stacks — though, it must be said, the
rejection of TCP offload engine support ten years ago created no such
stampede.  In any case, keeping users from getting the most out of their
hardware has never really been the Linux way, so it's not surprising that
David did eventually <a 
href="/Articles/667075/">moderate his position</a> a bit:
<p>
<div class="BigQuote">
	Pushing back is different from blocking entirely.
	<p>
	That means I'm
	going to be very difficult and make a lot of noise until I see the
	message has seeped in.
	<p>
	It doesn't mean that I won't allow a means to use existing hardware
	offloads.  You'll just have to bear with me, be patient, and
	survive my tantrum on this matter.
</div>
<p>

He would appear to be serious about waiting until he sees that the message
has been received, though.
<p>
Meanwhile, Anjali's current patches seem unlikely to go in without some
changes, even after David's tantrum has been duly survived.  The attempt to
generalize low-level tunneling support in the networking stack will
probably have to be dropped in favor of a set of GENEVE-specific device
operations.  Doing things that way limits the temptation to expand support
to other tunneling protocols; it also makes it easy for the tunneling
software itself to determine whether hardware support is available.  Making
those changes will be straightforward enough; convincing the networking
maintainer that the hardware designers have heard his complaint may take a
little longer.
<p>
An attempt to push hardware designers in a different direction may seem a
bit like throwing Linux's weight around.  But it is an important exercise,
not only for the long-term maintenance of the kernel, but also for the net
as a whole.  If hardware can be made to support important offloading
features with less protocol awareness then, maybe, the problem of protocol
ossification can be softened up a bit.  The net must certainly evolve in
the coming years; adding flexibility to our networking systems is one of
the most important ways of making that possible.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking-Protocols">Networking/Protocols</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/667059/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor667166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 19:12 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/667166/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; convincing the networking maintainer that the hardware designers have heard his complaint may take a little longer. </font><br>
<p>
That's going to cause problems if the only acceptable indication of "heard his complaint" is "decided he's right and done what he's demanding".  If the answer turns out to be "no", I expect an ongoing demonstration of selective hearing difficulties towards any answer that doesn't sound like "yes".  And even if the answer is "yes", hardware development cycles are long; hopefully all work on hardware offload won't stall until a new generation of hardware exists with these features.<br>
<p>
To quote another mail from the thread (<a href="http://thread.gmane.org/gmane.linux.network/388085/focus=388135">http://thread.gmane.org/gmane.linux.network/388085/focus=...</a>):<br>
<p>
"So we (as a kernel community) have users *NOW* who want this<br>
feature, and hardware that is available *now* that has this feature.<br>
Do you think we should wait for a unicorn to arrive that has a fully<br>
programmable de-ossified checksum engine?  How long?<br>
<p>
[...]<br>
<p>
I think that trying to force an agenda with no fore-warning and also<br>
punishing the users in order to get hardware vendors to change is the<br>
wrong way to go about this.  All you end up with is people just asking<br>
you why their hardware doesn't work in the kernel.<br>
<p>
You have a proposal, let's codify it and enable it for the future, and<br>
especially be *really* clear what you want hardware vendors to<br>
implement so that they get it right."<br>
<p>
The statement in the article that the networking developers "are, instead, developing a simpler, protocol-independent mechanism by which the hardware can support any protocol with checksum offloading." does not give any indication of the degree of overlap or discussion between the developers of that mechanism and the set of people who design networking hardware.  Developing a mechanism for offloading functionality to networking hardware without working with hardware developers is like developing a specification for a new syscall without talking to kernel developers.<br>
<p>
One question that Linux networking needs to be dealing with is "why are an increasing number of users bypassing the Linux networking stack entirely, such as to get more performance or smaller size?".  DPDK and its performance, and lwIP/uIP and their size, are demonstrations that the Linux networking stack fails to meet the requirements of many potential users.  In an ideal world, either those shouldn't exist at all because Linux already meets their requirements, or the Linux network stack should be designed to better integrate frameworks like those and bring them into the fold.<br>
<p>
I don't see an *obvious* reason why Linux's networking stack needs to be significantly larger than lwIP, or significantly slower than DPDK.  Today it is, but that doesn't seem like an innate property.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667186"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 19:28 UTC (Tue)
                               by <b>SEJeff</b> (guest, #51588)
                              [<a href="/Articles/667186/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And DPKT isn't even the only one. Mellanox's VMA (from before it bought Voltaire), and Solarflare's OpenOnload, both have been around much longer than DPDK. There are entire industries (finance) which rely on things like this for extremely low latency.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667186/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2015 15:01 UTC (Wed)
                               by <b>nysan</b> (guest, #81015)
                              [<a href="/Articles/667276/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Don't forget 6WIND.<br>
And there is now an open source project at www.openfastpath.org<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor667187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 19:34 UTC (Tue)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/667187/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I don't see an *obvious* reason why Linux's networking stack needs to be significantly larger than lwIP, or significantly slower than DPDK. Today it is, but that doesn't seem like an innate property.</font><br>
<p>
For a good discussion of why, look up what happened with Van Jacobson channels.<br>
<p>
In short, Linux's stack is bigger and/or slower than some alternatives because it does [much] more than those alternatives, and by the time you add $FeatureX to the alternatives it's no longer as small or fast as it used to be.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 21:35 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/667204/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; For a good discussion of why, look up what happened with Van Jacobson channels.</font><br>
<p>
I found the LWN article presenting those, but the only reference I have on their disposition suggests that the code never got published and remained slideware.<br>
<p>
<font class="QuotedText">&gt;  In short, Linux's stack is bigger and/or slower than some alternatives because it does [much] more than those alternatives, and by the time you add $FeatureX to the alternatives it's no longer as small or fast as it used to be.</font><br>
<p>
That's not an argument that the Linux stack *can't* match the size or performance of those alternatives.  Given that people successfully use those alternatives, clearly $FeatureX is not essential for them.<br>
<p>
For example, matching the size of lwIP would clearly require compiling out large parts of the stack.  And matching the performance of DPDK would require large parts of the kernel to stop touching packets, and the moment you touch a packet in a way that requires additional software processing, performance properties would nosedive.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor667221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2015 12:38 UTC (Wed)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/667221/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you want low latency, bypassing the kernel entirely will always save you some milliseconds, some there is incentive to do it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667523"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2015 0:03 UTC (Fri)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/667523/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The latency differences are in the microseconds. But aside from latency, it is also possible to achieve much higher packet rates with a more restricted user-space network stack.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667523/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor667188"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 20:12 UTC (Tue)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/667188/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Keeping everything but generic number-crunching in the kernel is probably a very good idea, for much the same reasons as RAID.<br>
<p>
I was experimenting with `ethtool -k` settings on my LAN the other day; the hardware doesn't have much of a feature set and it's all off-by-default, but on one end (a RTL8168e) enabling any of the interesting offloading features it claims to support... breaks everything. Nothing more fun than silent failures caused by buggy hardware!<br>
<p>
Admittedly that experience is based on $0.10 desktop Realtek chips, but at the same time, paying 10-1000× more for any type of hardware doesn't have a linear correlation to quality.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667188/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor667199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 21:19 UTC (Tue)
                               by <b>yootis</b> (subscriber, #4762)
                              [<a href="/Articles/667199/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<p>
Is there even value in checksums in headers anymore?  All of the transport mechanisms like ethernet already have much more powerful CRCs.  I've never heard of packets getting delivered with bad checksums, so why are they even used?  <br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667206"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 21:45 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/667206/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bad checksums do happen; among other things, I've seen case studies of them happening due to memory errors.  Also see <a href="http://dinaburg.org/bitsquatting.html">http://dinaburg.org/bitsquatting.html</a> , and notice the mentions that bit errors at some phases of the process will get rejected due to checksums.<br>
<p>
Some protocol in the stack needs to have *cryptographic* integrity; for instance, TLS provides cryptographic integrity guarantees.  However, at the lower levels, a quick checksum to confirm valid packet delivery allows the network stack to say "didn't get that, send it again", transparently to the application, as part of the normal ACK/NAK process.<br>
<p>
Also see <a href="https://en.wikipedia.org/wiki/End-to-end_principle">https://en.wikipedia.org/wiki/End-to-end_principle</a> .<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667206/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor667252"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2015 9:13 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/667252/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They can protect against bugs in between the checksum being calculated and the packet passing through the L2 CRC engine.<br>
<p>
I've seen weird driver bugs where chunks of packets were being dropped after being sent by userspace. The L2 CRC was fine, but the kernel applied header checksum was wrong. Turned out to be a subtle bug in the proprietary forwarding hardware driver, on raw sockets, iirc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667252/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor667242"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2015 3:49 UTC (Wed)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/667242/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd love to see some focus shift from extremely weak checksums like UDP's to stronger ones like CRC.  CRC has all the magic properties needed: it's linear, so you can subtract parts off, and it can be shifted, so you can take a CRC of some suffix or middle chunk of a packet and extend it to the CRC of the whole thing.<br>
<p>
And yes, I have seen bad packets over TCP that survive the checksum check.  It's just too weak.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667242/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667260"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2015 9:49 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/667260/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agreed on the TCP checksum. E.g., it doesn't detect re-ordering. Which has bitten me in the past with dodgy hardware.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667260/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor667248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2015 7:46 UTC (Wed)
                               by <b>alexl</b> (subscriber, #19068)
                              [<a href="/Articles/667248/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Would it not be possible to use the GPU to offload some of these calculations?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2015 9:50 UTC (Wed)
                               by <b>xav</b> (guest, #18536)
                              [<a href="/Articles/667257/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nope. Passing data to/from the GPU has an enormous fixed cost, and GPUs are slow for non-parallel computations, so this is the exact case of what NOT to offload to a GPU.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2015 9:21 UTC (Thu)
                               by <b>alexl</b> (subscriber, #19068)
                              [<a href="/Articles/667399/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The cost is not that huge for a shared memory architecture like the intel gpus. And if you're doing crc32 for instance you could run parallel crcs on different substrings and then combine on the CPU (like crc32_combine from zlib).<br>
<p>
Still, I dunno if it is faster, it may be memory bandwidth bound.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor667262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2015 11:00 UTC (Wed)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/667262/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the kernel just provided a full generic software stack which let driver override selected parts in hardware at minimal complexity cost to the kernel stack, is there anecdotal evidence that people are likely to limit their use of protocols to ones which are accelerated in hardware?  Especially if finding out which those are for any particular network set-up requires additional effort on their part, and things just work (slightly more slowly) for their preferred choice?  Of course if pieces of hardware along the network actively prevented use of protocols that would be a different matter, but I don't see how not allowing selected hardware acceleration would prevent that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2015 4:33 UTC (Thu)
                               by <b>eternaleye</b> (guest, #67051)
                              [<a href="/Articles/667389/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      That's pretty much exactly what the <a href="http://www.barrelfish.org/ma-antoinek-dragonet.pdf">Dragonet networking architecture</a> is about; it's a fascinating design at least in part because, from the perspective of userspace, the kernel can then be viewed as just such a NIC.
      
          <div class="CommentReplyButton">
            <form action="/Articles/667389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor668482"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 18, 2015 13:34 UTC (Fri)
                               by <b>moltonel</b> (guest, #45207)
                              [<a href="/Articles/668482/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To me that looks like the right thing to do. Open up the network hardware like has been done for graphic cards. CPU, GPU... NPU ? It might be a big initial R&amp;D investment for network hardware manufacturers, but the software development savings should make up for it quickly enough. Plus, whoever's first to market gets to design the generic API that just happens to fit their hardware best :p<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/668482/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor667396"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 10, 2015 8:38 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/667396/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; We increasingly find ourselves on an Internet that can only manage TCP and UDP, and relatively unchanging versions of TCP and UDP at that.</font><br>
<p>
Of course you meant HTTP.<br>
<p>
<a href="https://tools.ietf.org/html/rfc3093">https://tools.ietf.org/html/rfc3093</a> Firewall Enhancement Protocol (FEP)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667396/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667539"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2015 7:34 UTC (Fri)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/667539/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The RFC is supposed to be a joke, but it's surprisingly close to the truth. Basically, you have people using websockets over HTTPS to open tunnels between services. Bypasses firewalls, proxies, load balancers, everything. Evolution in action: by punishing anything that looks out of the ordinary, all network traffic evolves to becoming indistinguishable from eachother.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667539/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667545"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 11, 2015 11:19 UTC (Fri)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/667545/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Basically, you have people using websockets over HTTPS to open tunnels between services.</font><br>
<p>
Though my professor at the university was not really amused when I started insisting that the Internet's protocol stack is 8-layer (instead of the "traditional" 7 layers), where HTTP(S) is the top-most layer :) And it was a nontrivial number of years ago already.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667545/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor668690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 21, 2015 8:53 UTC (Mon)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/668690/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Dan Kaminsky did a talk ones about using HTTP to transport packets:<br>
<a href="https://www.youtube.com/watch?v=YwbpnZe74ds">https://www.youtube.com/watch?v=YwbpnZe74ds</a><br>
<p>
;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/668690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor667616"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2015 5:26 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/667616/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; so that it can be routed efficiently and not be blocked by middleboxes that don't understand it [... ] We have slowly optimized ourselves into a situation where the development and deployment of new protocols (or even significant enhancements to existing protocols) is increasingly difficult; even well defined protocols like SCTP and DCCP are hard to deploy in real-world settings.</font><br>
<p>
I think one of the main reasons, and maybe even the main one, is the complete "black box" aspect of IP networking. More opaque than the most closed source software.<br>
<p>
The end to end principle was great and all but it did not anticipate that the network would fight back and grow a lot of smarts (firewalls et al.) anyway even when it was not supposed to. Since they never were and are still not supposed to exist, these smarts are not required to provide any feedback, so when they fail they just fail silently/stealthily and can be neither identified nor pinpointed. This tends to please network administrators in their basement more than happy to dodge support calls[*] since they can't even be located.<br>
<p>
When even the most opaque application fails, one can typically still dig out somewhere some error message than can be Googled. Worst case the behaviour can be described. With networking it's dead end road every way. Hidden so well, IP networking never changes, never gets fixed,... ossifies.<br>
<p>
[*] <a href="https://www.youtube.com/watch?v=rksCTVFtjM4">https://www.youtube.com/watch?v=rksCTVFtjM4</a><br>
<p>
<font class="QuotedText">&gt; An attempt to push hardware designers in a different direction may seem a bit like throwing Linux's weight around</font><br>
<p>
Turning things around just once.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667616/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor667648"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2015 7:02 UTC (Sun)
                               by <b>drag</b> (guest, #31333)
                              [<a href="/Articles/667648/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This was posted a while ago to a lwn comments. Sorry I forget who posted it, but it's a good one:<br>
<p>
<a href="http://highscalability.com/blog/2013/5/13/the-secret-to-10-million-concurrent-connections-the-kernel-i.html">http://highscalability.com/blog/2013/5/13/the-secret-to-1...</a><br>
<p>
<p>
Basically: <br>
<p>
If you want to 'really scale' then the best thing you can do is ignore the kernel and perform as much networking as possible in your application.  Other people have mentioned some of the userspace network drivers that by-pass the kernel implementation in the comments in this article already. <br>
<p>
Seems to me that if people really want the 'bestest fastest lowest latencinest performance' from their TCP stack for specialized application then going about it by a hardware-based offload of TCP/IP seems to be the wrong approach.  The right approach is to use a application-level network driver and let the application due the calculations. If you want to throw hardware acceleration at the problem then have it be something that applications can use to help accelerate the calculations they need to do rather then something that hides in a nic card. <br>
<p>
Then if the kernel is involved at all then all it should do is provide a reasonable method for those applications to access the 'acceleration hardware' via some sort of mechanism like DRM drivers do.<br>
<p>
As far as tunneling goes.. as much as I love things like vxlan they really seem to be mostly used to work around IPv4 addressing limits. A much better approach seems to be things like let your virtualmachines/containers/etc get their own ipv6 address automatically and then rely on level 3 routing to deliver packets to everything.  Any tunneling going on should just be IPv6 over IPv4 udp as a stop gap solution to deal with shitty 'cloud' networks. Otherwise you can just end up with tunnels in tunnels in tunnels and nobody wants that. Anything 'container/virt' infrastructure that doesn't integrate service discovery (and/or 'VIPS' or whatever) to help services and clients find things automatically is just a half-assed solution anyways, which means that it makes the difficulty of dealing with 'static' ipv6 addresses and dhcp mute.  If done correctly there is no reason at all that end users should be aware that they are using ipv6 or ipv4. <br>
 <br>
oh well.  Never had good luck with 'offload engines' anyways.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667648/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor671815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Checksum offloads and protocol ossification</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 14, 2016 6:53 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/671815/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If you want to 'really scale' then the best thing you can do is ignore the kernel and perform as much networking as possible in your application. Other people have mentioned some of the userspace network drivers that by-pass the kernel implementation in the comments in this article already. </font><br>
<p>
Another (closed source) example: <a href="http://ats.aeroflex.com/virtualized-ip-test-solutions/product-overview/tvm-standard-hardware">http://ats.aeroflex.com/virtualized-ip-test-solutions/pro...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/671815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
