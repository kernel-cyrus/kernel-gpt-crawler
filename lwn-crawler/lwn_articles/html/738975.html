        <!DOCTYPE html>
        <html lang="en">
        <head><title>KAISER: hiding the kernel from user space [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/738975/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/738536/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/738975/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>KAISER: hiding the kernel from user space</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>November 15, 2017</br>
           </div>
Since the beginning, Linux has mapped the kernel's memory into the address
space of every running process.  There are solid performance reasons for
doing this, and the processor's memory-management unit can ordinarily be
trusted to prevent user space from accessing that memory.  More recently,
though, some more subtle security issues related to this mapping have come
to light, leading to the rapid development of a new patch set that ends this
longstanding practice for the x86 architecture.
<p>
<h4>Some address-space history</h4>
<p>
On 32-bit systems, the address-space layout for a running process dedicated
the bottom 3GB (0x00000000 to 0xbfffffff) for user-space use and the top 1GB
(0xc0000000 to 0xffffffff) for the kernel.  Each process saw its own memory
in the bottom 3GB, while the kernel-space mapping was the same for all.  On
an x86_64 system, the user-space virtual address space goes from zero to
0x7fffffffffff (the bottom 47 bits), while kernel-space mappings are
scattered in the range 
above 0xffff880000000000.  While user space can, in some sense, see the
address space reserved for the kernel, it has no actual access to that
memory.
<p>
This mapping scheme has caused problems in the past.  On 32-bit systems, it
limits the total size of a process's address space to 3GB, for example.
The kernel-side problems are arguably worse, in that the kernel can only
directly access a bit less than 1GB of physical memory; using more memory
than that required the implementation of a complicated "high memory"
mechanism.  32-Bit systems were never going to be great at using large
amounts of memory (for a 20th-century value of "large"), but keeping the kernel
mapped into user space made things worse.
<p>
Nonetheless, this mechanism persists for a simple reason: getting rid of it
would make the system run considerably slower.  Keeping the kernel
permanently mapped eliminates the need to flush the processor's translation
lookaside buffer (TLB) when switching between user and kernel space, and it
allows the TLB entries for kernel space to never be flushed.  Flushing the
TLB is an expensive operation for a couple of reasons: having to go to the
page tables to repopulate the TLB hurts, but the act of performing the
flush itself is slow enough that it can be the biggest part of the cost.
<p>
Back in 2003, Ingo Molnar <a href="/Articles/39283/">implemented</a> a
different mechanism, where user space and kernel space each got a full 4GB
address space and the processor would switch between them on every context
switch.  The "4G/4G" mechanism solved problems for some users and was
shipped by some distributors, but the associated performance cost ensured
that it never found its way into the mainline kernel.  Nobody has seriously
proposed separating the two address spaces since.

<p>
<h4>Rethinking the shared address space</h4>
<p>
On contemporary 64-bit systems, the shared address space does not constrain the
amount of virtual memory that can be addressed as it used to, but there is
another problem that is
related to security.  An important technique for hardening the system is
kernel address-space layout randomization (KASLR), which randomizes the
placement of the kernel in the virtual address space at boot time.  By
denying an attacker the knowledge 
of where the kernel lives in memory, KASLR makes many types of attack
considerably more difficult.  As long as the actual location of the kernel
does not leak to user space, attackers will be left groping in the dark.
<p>
The problem is that this information leaks in many ways.  Many of those
leaks date back to simpler days when kernel addresses were not sensitive
information; it even turns out that your editor <a
href="https://git.kernel.org/linus/277642dcca765a1955d4c753a5a315ff7f2eb09d">introduced
one such leak</a> in 2003.  Nobody was worried about exposing that
information at that time.  More recently, a concerted effort has been
made to close off the 
direct leaks from the kernel, but none of that will be of much benefit if
the hardware itself reveals the kernel's location.  And that would appear
to be exactly what is happening.
<p>
<a href="https://gruss.cc/files/kaiser.pdf">This paper from Daniel Gruss et
al. [PDF]</a> cites a number of hardware-based attacks on KASLR.  They use
techniques like exploiting timing differences in fault handling, observing
the behavior of prefetch instructions, or forcing faults using the Intel
TSX (transactional memory) instructions.  There are rumors circulating that
other such channels
exist but have not yet been disclosed.
In all of these cases, the processor responds differently to a memory
access attempt
depending on whether the target address is mapped in the page tables,
regardless of whether the running process can actually access that location.
These differences can be used to find where the kernel has been placed â€”
without making the kernel aware that an attack is underway.  
<p>
Fixing information leaks in the hardware is difficult and, in any case,
deployed systems are likely to remain vulnerable.  But there is a viable
defense against these information leaks: making the kernel's page tables
entirely inaccessible to user space.  In other words, it would seem that
the practice of mapping the kernel into user space needs to end in the
interest of hardening the system.
<p>
<h4>KAISER</h4>
<p>
The paper linked above provided an implementation of separated address
spaces for the x86-64 kernel; the authors called it "KAISER", which
evidently stands for "kernel address isolation to have side-channels
efficiently removed".  This implementation was not suitable for inclusion
into the mainline, but it was picked up and heavily modified by Dave
Hansen.  The <a href="/Articles/738997/">resulting patch set</a> (still
called "KAISER") is in its third revision and seems likely to find its way
upstream in a relatively short period of time.
<p>
Whereas current systems have a single set of page tables for each process,
KAISER implements two.  One set is essentially unchanged; it includes both
kernel-space and user-space addresses, but it is only used when the system
is running in kernel mode.  The second "shadow" page table contains a copy
of all of the user-space mappings, but leaves out the kernel side.
Instead, there is a minimal set of kernel-space mappings that provides the
information needed to handle system calls and interrupts, but no more.
Copying the page tables may sound inefficient, but the copying only happens
at the top level of the page-table hierarchy, so the bulk of that data is
shared between the two copies.
<p>
Whenever a process is running in user mode, the shadow page tables will be
active.  The bulk of the kernel's address space will thus be completely
hidden from the process, defeating the known hardware-based attacks.
Whenever the system needs to switch to kernel mode, in response to a system
call, an exception, or an interrupt, for example, a switch to the other
page tables will be made.  The code that manages the return to user space
must then make the shadow page tables active again.
<p>

The defense provided by KAISER is not complete, in that a small amount of
kernel information must still be present to manage the switch back to
kernel mode.  In the patch description, Hansen wrote:
<p>
<div class="BigQuote">
	The minimal kernel page tables try to map only what is needed to
	enter/exit the kernel such as the entry/exit functions, interrupt
	descriptors (IDT) and the kernel trampoline stacks.  This minimal
	set of data can still reveal the kernel's ASLR base address.  But,
	this minimal kernel data is all trusted, which makes it harder to
	exploit than data in the kernel direct map which contains loads of
	user-controlled data.
</div>
<p>
While the patch does not mention it, one could imagine that, if the
presence of the remaining information turns out to give away the game, it
could probably be located separately from the rest of the kernel at its own
randomized address.
<p>
The performance concerns that drove the use of a single set of page tables
have not gone away, of course.  More recent processors offer some help,
though, in the form of process-context identifiers (PCIDs).  These
identifiers tag entries in the TLB; lookups in the TLB will only succeed if
the associated PCID matches that of the thread running in the processor at
the time.  Use of PCIDs eliminates the need to flush the TLB at context
switches; that reduces the cost of switching page tables during system
calls considerably.  Happily, the kernel got support for PCIDs during the
4.14 development cycle.
<p>
Even so, there will be a performance penalty to pay when KAISER is in use:
<p>
<div class="BigQuote">
	KAISER will affect performance for anything that does system calls
	or interrupts: everything.  Just the new instructions (CR3
	manipulation) add a few hundred cycles to a syscall or interrupt.
	Most workloads that we have run show single-digit regressions.  5%
	is a good round number for what is typical.  The worst we have seen
	is a roughly 30% regression on a loopback networking test that did
	a ton of syscalls and context switches.
</div>
<p>
Not that long ago, a security-related patch with that kind of performance
penalty would not have even been considered for mainline inclusion.  Times
have changed, though, and most developers have realized that a hardened
kernel is no longer optional.  Even so, there will be options to enable or
disable KAISER, perhaps even at run time, for those who are unwilling to
take the performance hit.
<p>
All told, KAISER has the look of a patch set that has been put onto the
fast track.  It emerged nearly fully formed and has immediately seen a lot
of attention from a number of core kernel developers.  Linus Torvalds is
clearly in support of the idea, though he naturally has pointed out a
number of things that, in his opinion, could be improved.  Nobody has
talked publicly about time frames for merging this code, but 4.15 might not be
entirely out of the question.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-User-space_layout">Memory management/User-space layout</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Meltdown_and_Spectre">Security/Meltdown and Spectre</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/738975/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor739075"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2017 5:54 UTC (Wed)
                               by <b>jreiser</b> (subscriber, #11027)
                              [<a href="/Articles/739075/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <i>(CR3 manipulation) add a few hundred cycles to a syscall or interrupt.</i>  That's a couple L3 cache misses [CAS latency on SDRAM has been ~60ns for decades] which probably is tolerable on a syscall.  But hundreds of cycles is <b>horrible</b> for an interrupt.  [33MHz is a common bus clock, so just generating an interrupt already requires an average latency of ~15ns.]  Some architectures have a special interrupt context (and/or separate small locked caches) exactly for this reason.
      
          <div class="CommentReplyButton">
            <form action="/Articles/739075/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739119"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2017 15:39 UTC (Wed)
                               by <b>hansendc</b> (subscriber, #7363)
                              [<a href="/Articles/739119/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interrupts are already a small number of thousands cycles, even for a quick one.  The entry plus IRET costs alone probably eclipse the (new) CR3 manipulation cost.  So, while this CR3 manipulation makes things worse, it does not fundamentally change the speed of an interrupt.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739119/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor774398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2018 15:58 UTC (Sun)
                               by <b>dembego3</b> (guest, #129120)
                              [<a href="/Articles/774398/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you for caring for my safety:-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/774398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor739087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2017 8:19 UTC (Wed)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/739087/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; a number of hardware-based attacks on KASLR. They use techniques like exploiting timing differences in fault handling, </font><br>
<p>
I find timing-based attacks fascinating.<br>
<p>
In order to grow, computer performance has become less and less deterministic. On one hand this makes real-time and predictions harder. On the other hand this leaks more and more information about the system.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2017 14:19 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/739112/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If these timing-based attacks involve accessing a page in the kernel address space and getting some kind of memory protection fault, can't the kernel add a small random delay each time such a fault is hit before control returns to user space?  The delay could even increase with subsequent faults, imposing a ceiling on how many faults the process can generate.  That is, provided there's a way to do this while not imposing that same delay on processes that are using these faults for other things, like memory-mapped files.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739122"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2017 15:55 UTC (Wed)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/739122/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This will not work as todays CPUs provide the possibility to trigger a pagefault without involving the kernel (e.g. TSX instructions). These instructions simply fail if the memory is not mapped or not accessible unlike usual memory accesses that would involve the kernels pagefault handler.<br>
<p>
I did also not know this before, but several of these attacks are described in the linked paper.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739122/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor740018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2017 15:46 UTC (Mon)
                               by <b>abufrejoval</b> (guest, #100159)
                              [<a href="/Articles/740018/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd like to see CPUs turn to randomized instruction timings to implement power control and throw a punch at timing based attacks this way.<br>
These days where CPUs constantly vary their speeds to either exploit every bit of thermal headroom they can find or re-adjust constantly to hit an energy optimum for a limited value workload, it seems almost stupid to try sticking to a constant speed.<br>
<p>
If instead you set a randomization bias you can run CPUs at say 5GHz logical clock and then add random delays to hit say 3, 2 or 1 GHz on average depending on the workload. Every iteration of an otherwise pretty identical loop would wind up a couple of clocks different, throwing off snoop code without much of an impact elsewhere. Of course it shouldn't be one central clock overall, but essentially any clock domain could use its own randomization source and bias. I guess CPUs have vast numbers of clock synchronization gates these days anyway, so very little additional hardware should be required.<br>
<p>
Stupid, genius or simply old news?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/740018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor740057"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2017 16:55 UTC (Mon)
                               by <b>NAR</b> (subscriber, #1313)
                              [<a href="/Articles/740057/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It might hinder optimization if running the same code under same circumstances results in different execution speed...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/740057/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 8:26 UTC (Fri)
                               by <b>clbuttic</b> (guest, #121058)
                              [<a href="/Articles/743158/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ATLAS (Automatically Tuned Linear Algebra Software) does a lengthy tuning step that expects consistent CPU performance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743368"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 16:02 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/743368/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Of course, that tuning step already requires sysadmin intervention to turn off CPU frequency changes, ideally hyperthreading, etc: adding one more intervention isn't likely to be terribly difficult.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743368/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor740060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2017 17:43 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/740060/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What stops an attacker from just running their test thousands or millions of times, to average out the randomisation that you've added?<br>
<p>
For example, the KAISER paper says the "double page fault attack" distinguishes page faults taking 12282 cycles for mapped pages and 12307 cycles for unmapped pages, i.e. a difference of 25 cycles. If I remember how maths works: You could add a random delay to the page fault handler (or randomly vary the CPU speed or whatever) so it has a mean and standard deviation of (M, S) for mapped pages and (M+25, S) for unmapped. If S &gt; 25 (very roughly) then the attacker can measure a page fault but can't be sure whether it belongs to the first category or the second.<br>
<p>
But if they repeat it 10,000 times (which only takes a few msecs) and average their measurements, they'd expect to get a number in the distribution (M, S/100) for mapped pages or (M+25, S/100) for unmapped. You'd have to make S &gt; 2500 to stop them being able to distinguish those cases easily. At that point it's much more expensive than the KAISER defence, and it would still be useless against an attacker who can repeat the measurement a million times. And that's for measuring a relatively tiny difference of 25 cycles in an operation that takes ~12K cycles; it's harder to protect the TSX or prefetch attacks where the operation only takes ~300 cycles.<br>
<p>
It seems much safer to ensure operations will always take a constant amount of time, rather than adding randomness and just hoping the statistics work in your favour.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/740060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor739091"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2017 9:27 UTC (Wed)
                               by <b>sorokin</b> (guest, #88478)
                              [<a href="/Articles/739091/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Most workloads that we have run show single-digit regressions. 5% is a good round number for what is typical.</font><br>
<p>
A single change may not affect performance significantly (although 5% slow down is too much for my taste). But multiple changes can stack up over time. In the past this has been seen both for performance improving and for performance regression changes. A performance regression example is how compilers' performance regressed overtime (although since GCC 6 the trend has reversed). A performance improving example is sqlite.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739091/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor739100"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2017 11:25 UTC (Wed)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/739100/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Since the beginning, Linux has mapped the kernel's memory into the address space of every running process. </font><br>
<p>
IIRC this is not true on SPARC, is it ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739100/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2017 14:05 UTC (Wed)
                               by <b>arjan</b> (subscriber, #36785)
                              [<a href="/Articles/739111/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you might mean s390<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739114"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2017 14:56 UTC (Wed)
                               by <b>cborni</b> (subscriber, #12949)
                              [<a href="/Articles/739114/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think both SPARC (I am sure about Solaris, but not Linux) and s390 (here I am sure for Linux) have separate kernel and user address spaces.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739114/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 2:06 UTC (Thu)
                               by <b>jamesmorris</b> (subscriber, #82698)
                              [<a href="/Articles/739198/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Correct for SPARC.  The user and kernel address spaces are separate.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor739200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 2:10 UTC (Thu)
                               by <b>jamesmorris</b> (subscriber, #82698)
                              [<a href="/Articles/739200/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, it's an architectural feature, so it's true on Linux.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739231"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 12:52 UTC (Thu)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/739231/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So maybe pushing this will motivate architecture designers to provide this feature, like it was done for virtualization.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739231/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor739210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 4:57 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/739210/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can KAISER be made optional on process-level? Perhaps through a croup?<br>
<p>
I would definitely like to protect my browser and anything started by it, but I would like my gcc started from a terminal to run at full speed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739347"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 20:40 UTC (Thu)
                               by <b>hansendc</b> (subscriber, #7363)
                              [<a href="/Articles/739347/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, this could be done, at least theoretically.  But, the contexts where we have to decide to "do KAISER" or not are very tricky.  We don't have a stack and don't have registers to clobber, so it's tricky to pull off.<br>
<p>
You would essentially need to keep a bit of per-cpu data that was consulted very early in assembly at kernel entry.  It would have to be updated at every context switch, probably from some flag in the task_struct.  Again, doable, but far from trivial.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739347/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739561"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2017 6:16 UTC (Sun)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/739561/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It could be TIF_KAISER, no?<br>
<p>
But this is definitely not a v1 feature.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739561/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor739215"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 7:21 UTC (Thu)
                               by <b>alkbyby</b> (subscriber, #61687)
                              [<a href="/Articles/739215/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looks like something bad is coming. Such as mega-hole maybe in hardware that can be mitigated by hiding kernel addresses.<br>
<p>
Otherwise I cannot see why simply hiding kernel addresses better, suddenly becomes important enough to spend massive amount of cpu on it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739215/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739220"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 8:08 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/739220/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Kernel address hiding is needed to protect the kernel in case there's a bug that allows code execution in the kernel mode.<br>
<p>
But it looks like software-based hiding is ineffective by itself with the current model.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739220/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739228"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 9:29 UTC (Thu)
                               by <b>alkbyby</b> (subscriber, #61687)
                              [<a href="/Articles/739228/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"in case" doesn't seem enough justification to pay such a massive price.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739228/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739235"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 10:41 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/739235/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sigh. The kernel root holes are being found every month or so. But in order to exploit them reliably you need to know the kernel memory layout. And Most obvious software leaks of this information are now closed.<br>
<p>
The problem is that hardware simply makes all software countermeasures irrelevant without something like KAISER.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739235/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor739355"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 18:34 UTC (Thu)
                               by <b>ttelford</b> (guest, #44176)
                              [<a href="/Articles/739355/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <i> Just the new instructions (CR3 manipulation) add a few hundred cycles to a syscall or interrupt</i><br/><br/>

A few hundred cycles to a syscall or interrupt is vaguely similar to the <a href=http://l4hq.org/docs/performance.php>basic IPC cost</a> of the L4 microkernel. (200-300 cycles for amd64).<br/><br/>

Kernels are not my area of expertise, so I have to ask:  if a syscall is about to become as expensive as IPC on L4... would the (theoretical) performance of the respective kernels be similar after KAISER?<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/739355/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739366"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2017 20:52 UTC (Thu)
                               by <b>hansendc</b> (subscriber, #7363)
                              [<a href="/Articles/739366/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  if a syscall is about to become as expensive as IPC on L4... would the (theoretical) performance of the respective kernels be similar after KAISER?</font><br>
<p>
Most of the KAISER performance impact is purely from the cost of manipulating the hardware.  L4 and other kernels would pay the same cost Linux would.<br>
<p>
It's not fair to compare a non-hardened kernel to a hardened one, though.  It's apples-to-oranges.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739366/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor739440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2017 17:45 UTC (Fri)
                               by <b>valarauca</b> (guest, #109490)
                              [<a href="/Articles/739440/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Timing attacks are becoming the bane of x64.<br>
<p>
AVX512 adds explicit flags to suppress memory errors on scatter/gather load/store vectorized instructions which will just add another method to exploit this. The ways of _accessing_ memory you can't access on x64 just continue to grow. I really don't see how AMD64 can fix this without breaking either the page table or the debug timers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor739483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2017 0:09 UTC (Sat)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/739483/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I read some performance caveats about vmaskmovps (AVX, not sure if there is an SSE equivalent) that make me think that this instruction can be used for such purposes, too.

<p>Concerning the article, hyperbole is the standard in security news, but "a hardened kernel is no longer optional" seems to be a little extreme even so.  I very much hope that stuff like this will be optional.

<p>A possibly less costly way to mitigate attacks that try to defeat KASLR might be to map additional inaccessible address space that would respond to the attacks just like real kernel memory.
      
          <div class="CommentReplyButton">
            <form action="/Articles/739483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor740281"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">wordage nuance</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 30, 2017 1:32 UTC (Thu)
                               by <b>Garak</b> (guest, #99377)
                              [<a href="/Articles/740281/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>Concerning the article, hyperbole is the standard in security news, but "a hardened kernel is no longer optional" seems to be a little extreme even so. I very much hope that stuff like this will be optional. </blockquote>

My reaction for a couple seconds as well till I read the next sentence.  I agree that sentence is not the best way to describe things.  I think it's important to highlight that security-vs-performance tradeoffs is a vast spectrum of subtle choices that *depend on the situation/deployment*.  There are many different situations.  Quite often a performance hit from enabling SELinux or whatever new hardening-with-five-percent-hit tactic, is absolutely not worth it.  Other times your computers are trying to secure millions of dollars of cryptocurrency/etc.  Most users should be taught about such nuance versus the "more secure equals always better" narrative.  If something is useful to lots of people, sure it should be available as an option.  But leave it to the distributors and then the end users to figure out when and where various options should be tuned.
      
          <div class="CommentReplyButton">
            <form action="/Articles/740281/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor739815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2017 10:40 UTC (Wed)
                               by <b>mlankhorst</b> (subscriber, #52260)
                              [<a href="/Articles/739815/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can't it be done for nearly free using SMAP + SMEP?<br>
<p>
Put the kernel mapping at ring3, and make the remainder of the upper 64-bits mapped RWX at ring 1 or 2.<br>
<p>
Try to exploit timing differences then from RING 0!<br>
<p>
Or am I thinking too simple?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/739815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor742677"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2018 16:55 UTC (Wed)
                               by <b>EdRowland</b> (guest, #120787)
                              [<a href="/Articles/742677/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Couldn't you map a dummy page into the holes to prevent timing differences between populated memory that's unreadable at ring 3 and unpopulated memory that now references a dummy page?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742677/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor742686"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2018 17:30 UTC (Wed)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/742686/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess the main problem with that idea is that page tables take 8 bytes of physical memory per 4KB of virtual address space. If you want to fill up the whole ~48-bit virtual address space with distinct PTEs, you'd need 512GB of page tables.<br>
<p>
You could try to reduce the size by e.g. using a single dummy PTE table that's shared by all the higher-level tables, instead of keeping them distinct. But an attacker can likely measure the timing difference between a page walk that fetches the PTE from cache, vs one that fetches it from RAM. If you access address A, then address A+4096, and the second one is fast (i.e. the PTE is already in the cache), you know that's using the dummy PTE, so it's still leaking information about where the kernel is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/742686/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">KAISER: hiding the kernel from user space</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 0:26 UTC (Sat)
                               by <b>ridethewave</b> (guest, #121115)
                              [<a href="/Articles/743314/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;I guess the main problem with that idea is that page tables take 8 bytes of physical memory &gt;per 4KB of virtual address space</font><br>
Couldn't you just map each virtual address to the same physical address then?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
