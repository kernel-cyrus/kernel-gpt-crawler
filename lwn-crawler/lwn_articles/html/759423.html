        <!DOCTYPE html>
        <html lang="en">
        <head><title>Spectre V1 defense in GCC [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/759423/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/759139/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/759423/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Spectre V1 defense in GCC</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>July 10, 2018</br>
           </div>
In many ways, Spectre variant 1 (the bounds-check bypass vulnerability) is
the ugliest of the Meltdown/Spectre set, despite being relatively difficult
to exploit.  Any given code base could be filled with V1 problems, but they
are difficult to find and defend against.  Static analysis can help, but
the available tools are few, mostly proprietary, and prone to false
positives.  There is also a lack of efficient, architecture-independent
ways of addressing Spectre V1 in user-space code.  As a result, only a
limited effort (at most) to find and fix Spectre V1 vulnerabilities has
been made in most projects.  An effort to add some defenses to GCC may help
to make this situation better, but it comes at a cost of its own.

<p>
Spectre V1, remember, comes about as the result of an incorrect branch
prediction by the processor.  Given code like:
<p>
<pre>
    if (index &lt; structure-&gt;array_size)
        do_something_with(structure-&gt;array[index]);
</pre>
<p>
The processor would likely predict that <tt>index</tt> would indeed be less
than the given size since, in normal execution, it almost always is.  It
will then go on to speculatively execute the code that uses
<tt>array[index]</tt> with an <tt>index</tt> value that may, instead, be
far out of bounds.  If this speculative access leaves traces elsewhere in
the system (by pulling data into the cache, for example), it can be
exploited to leak data that, in a correct execution of the code, would be
protected.
<p>
In the kernel, the <tt>array_index_nospec()</tt> macro has been
<a
href="/Articles/746551/">introduced</a> as a way to prevent incorrect
speculative loads of this type. 
These macro calls must be introduced manually, though, in places where
somebody has determined that a Spectre V1 vulnerability may exist.  That
has been happening, but slowly; there are about 60 invocations in the
4.18-rc4 kernel.  Less work has been done in user space, though, for a
number of reasons, including the lack of a primitive like
<tt>array_index_nospec()</tt>. 
<p>

GCC may soon address that final problem, thanks to <a
href="/Articles/759438/">this 
patch set</a> from Richard Earnshaw, based on a technique first <a
href="https://docs.google.com/document/d/1wwcfv3UV9ZnZVcGiGuoITT_61e_Ko3TmoCS3uXLcJR0/edit#heading=h.phdehs44eom6">published</a>
by Chandler Carruth.  These patches add a new intrinsic that behaves much
like <tt>array_index_nospec()</tt>:
<p>
<pre>
    __builtin_speculation_safe_value(value, fallback)
</pre>
<p>
In the absence of speculation, this function will simply return <tt>value</tt>.
When speculative execution is happening, instead, it <i>might</i> still
return <tt>value</tt>, but it could also return the <tt>fallback</tt>
value, which defaults to zero.  It can thus be used to ensure that
speculative execution cannot happen with out-of-range index values.
A simple implementation would just use a 
barrier unconditionally to prevent speculation outright, but barriers can
be expensive.  It may be more
efficient to just clamp the range of the index value while allowing
speculation in general to continue.
<p>
<h4>Detecting incorrect speculation</h4>
<p>
A look at how this new intrinsic works yields some insight into why it is
specified the way it is.  
The core of that implementation is a trick to detect when incorrect 
speculative execution is occurring and to prevent out-of-bounds accesses
from happening in such situations.  Doing so requires instrumenting the
code as it is built by the compiler.  In this scheme, the above <tt>if</tt>
statement would be modified to look something like this:
<p>
<pre>
    void *all_ones = ~0;
    void *all_zeroes = 0;
    void *correct = all_ones;

    if (index &lt; structure-&gt;array_size) {
        correct = (index &gt;= structure-&gt;array_size) ? all_zeroes : correct;
	index &amp;= correct;
	do_something_with(structure-&gt;array[index]);
    }
</pre>
<p>

The key is the assignment of <tt>correct</tt> inside the body of the
<tt>if</tt>:
<p>
<pre>
        correct = (index &gt;= structure-&gt;array_size) ? all_zeroes : correct;
</pre>
<p>
That assignment tests whether the <i>inverse</i> of the
branch condition is true; if that is the case, the body 
is being speculatively executed when it should not be and evasive action
is required.  Since
<tt>correct</tt> will have been set to zero if (and only if) incorrect
speculation is taking place, said evasive
action can take the form of using <tt>correct</tt> as a mask against
<tt>index</tt>:
<p>
<pre>
	index &amp;= correct;
</pre>
<p>
In normal execution, this operation will change nothing; when incorrect
speculative execution has been detected, instead, <tt>index</tt> will be
reset to zero.  At that point, it can no longer be used to speculatively
access out-of-bounds memory.
<p>
The question that may come to mind here is: if the condition is
mispredicted in the <tt>if</tt> statement, won't the same thing happen with
the ternary expression used to set the value of <tt>correct</tt>?  As it
happens, almost all architectures have some sort of compare-and-assign
operation that (1)&nbsp;is a single instruction without a branch, so the
branch predictor does not enter the picture, and (2)&nbsp;is defined by the
architecture to not be subject to
speculation in its own right.  So the assignment of <tt>correct</tt> will be
done with non-predicted values; it will be an accurate indicator of whether
incorrect speculative execution is taking place.
<p>
Note that the <tt>correct</tt> flag is initialized once, but updated after
every branch as shown above.  It will, thus, carry the prediction state
through multiple branches if need be.  With enough cleverness, it can even
be used to communicate this state across function calls.  Since speculation
can sometimes run hundreds of instructions ahead of anything known to be
correct, this ability to track and communicate the state of execution is
important. 

<p>
<h4>Adding support to GCC</h4>
<p>

As noted above, implementing <tt>__builtin_speculation_safe_value()</tt>
can be as simple as injecting a barrier into the generated code.  But if
the compiler could also add 
the ability to detect incorrect speculation, other possibilities would open
up.  To that end, the GCC patch set under consideration adds a new
<tt>-mtrack-speculation</tt> option for compilation that turns on this
mechanism.   <a
href="https://lwn.net/ml/gcc-patches/1531154299-28349-7-git-send-email-Richard.Earnshaw@arm.com/">This
patch</a>, in particular, adds speculation tracking for the arm64
architecture.  As described in that patch, a simple equality test might
(after the comparison to set the condition code) look like:
<p>
<pre>
        B.EQ	&lt;dst&gt;
        ...
    &lt;dst&gt;:
</pre>
<p>
With <tt>-mtrack-speculation</tt>, that code would be made to look more
like this:
<p>
<pre>
        B.EQ	&lt;dst&gt;
	CSEL	tracker, tracker, XZr, ne
        ...
    &lt;dst&gt;:
        CSEL	tracker, tracker, XZr, eq
</pre>
<p>
Here, <tt>tracker</tt> is the name of the register that has been dedicated
to holding the <tt>correct</tt> flag.  The <a
href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0802a/CSEL.html"><tt>CSEL</tt>
instruction</a> will set 
<tt>tracker</tt> to either itself or <tt>XZr</tt> (the register holding all
zeroes) depending on the real value of the condition, without speculation.
It is, in other words, implementing the ternary operator we saw in the
example above.
<p>
This operation will cause the <tt>tracker</tt> register to be zero when
incorrect speculation is 
happening.  That allows it to be used to implement
<tt>__builtin_speculation_safe_value()</tt>; with the default
<tt>fallback</tt> value of zero, a logical AND between the <tt>tracker</tt>
register and the value in question will suffice.  In the case of the arm64
architecture, though, it is possible to do a little better.  When
speculation tracking is turned on, the compiler will simply insert a
<tt>CSDB</tt> speculation barrier when incorrect speculation is detected.
<p>
It's worth noting in passing that things become more complicated when
function calls are involved.  Speculative execution can involve function
calls, so it is important to track incorrect speculation across those
calls.  If a register could be dedicated program-wide
to the <tt>tracker</tt> value, life would be easy, but that would require a
flag-day change to the arm64 ABI.  Instead, the stack pointer is used in a
tricky way to encode the correctness state on function call and return; see
the above-linked patch for details.
<p>
Overall, this approach may seem like the best of all worlds; barriers can
be expensive, so a 
mechanism that only executes them when they are known to be necessary would
be ideal.  The downside, of course, is that the speculation tracking itself
is not cheap.  It requires setting aside two registers to track the state
and the instrumentation of every branch.  No benchmark results have been
posted with the code, but this level of overhead must have an impact.  The
cost is high enough to
rule out otherwise interesting ideas like automatically protecting all
bounds checks.
<p>
In any case, this sort of speculation tracking may come across as a strange
mechanism; code running on the processor
can detect that the processor has speculated incorrectly, but the processor
itself still takes some time to figure that out.  But that is the world we
have found ourselves living in.  The best that can be done is to find ways
of protecting our code while minimizing the cost.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Meltdown_and_Spectre">Security/Meltdown and Spectre</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Meltdown_and_Spectre">Meltdown and Spectre</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/759423/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor759465"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 23:08 UTC (Tue)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/759465/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure if I understand the semantics:<br>
<p>
“When speculative execution is happening, instead, it _might_ still return value, but it could also return the fallback value, which defaults to zero. ”<br>
<p>
So if it does indeed return value, can't the CPU do the harmful speculation? “Maybe, maybe not” sounds like an incredibly weak specification.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759465/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759466"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 23:50 UTC (Tue)
                               by <b>lambda</b> (subscriber, #40735)
                              [<a href="/Articles/759466/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>
The docs part of the patches provide a better description of the actual behavior. It always returns the given value when executing non-speculatively. When executing speculatively, it either blocks until all speculation is resolved, or if the architecture supports it, returns the fallback value if there is outstanding speculation that could turn out to be incorrect. This basically means that in the speculative scenarios that could cause issues, you will just work with the dummy value, and the speculation will be useless but safe.
<p>
<blockquote><pre>
+(speculation_safe_value,
+"This target hook can be used to generate a target-specific code\n\
+ sequence that implements the @code{__builtin_speculation_safe_value}\n\
+ built-in function.  The function must always return @var{val} in\n\
+ @var{result} in mode @var{mode} when the cpu is not executing\n\
+ speculatively, but must never return that when speculating until it\n\
+ is known that the speculation will not be unwound.  The hook supports\n\
+ two primary mechanisms for implementing the requirements.  The first\n\
+ is to emit a speculation barrier which forces the processor to wait\n\
+ until all prior speculative operations have been resolved; the second\n\
+ is to use a target-specific mechanism that can track the speculation\n\
+ state and to return @var{failval} if it can determine that\n\
+ speculation must be unwound at a later time.\n\
+ \n\
+ The default implementation simply copies @var{val} to @var{result} and\n\
+ emits a @code{speculation_barrier} instruction if that is defined.  If\n\
+ @code{speculation_barrier} is not defined for the target a warning will\n\
+ be generated.",
</pre></blockquote>
<p>
There are some examples later in the thread that shows how this can be used, such as the following. This is written with the assumption that mem[0] is a safe, if potentially incorrect, value to return:
<p>
<blockquote><pre>
void *mem;

void* f(unsigned untrusted)
{
  if (untrusted &lt; 100)
    return mem[__builtin_speculation_safe_value (untrusted)];
  return NULL;
}
</pre></blockquote>
      
          <div class="CommentReplyButton">
            <form action="/Articles/759466/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759468"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2018 0:21 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/759468/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The assumption that element[0] is a safe value is fragile and I'm sure it's going to burn people sooner or later. It happens to work in the kernel most of the time because its empty arrays typically have NULL base addresses but in lots of code, that's not the case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759468/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759469"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2018 0:41 UTC (Wed)
                               by <b>lambda</b> (subscriber, #40735)
                              [<a href="/Articles/759469/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>
There is <a href="https://lwn.net/ml/gcc-patches/759977ff-d19c-732a-68c3-fddfb961e8e5@arm.com/">another example</a> which uses <code>return *__builtin_speculation_safe_value (mem + untrusted);</code> so that it will speculate a NULL pointer dereference instead, if you can't afford to leak <code>mem[0]</code>, or are in code where you can't tell if leaking <code>mem[0]</code> is safe.
<p>
Point taken that the first example isn't necessarily good if you, say, have a zero-length slice that you're bounds checking against, or something of the sort.
<p>
Luckily, this intrinsic should only need to be used in relatively few places, which can be intensively code reviewed; anything which allows code to execute within a process but shouldn't have access to all of the data in the process, such as a JavaScript or wasm engine. I feel like it shouldn't be too hard to encapsulate most such bounds checks into a relatively small number of functions, which could be thoroughly checked.
      
          <div class="CommentReplyButton">
            <form action="/Articles/759469/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2018 13:13 UTC (Wed)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/759495/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Luckily, this intrinsic should only need to be used in relatively few places, which can be intensively code reviewed; anything which allows code to execute within a process but shouldn't have access to all of the data in the process, such as a JavaScript or wasm engine.</font><br>
<p>
I am less optimistic. Actually this affects all parts of code that deal with user input, not only scripting languages. A JPEG image needs to be interpreted to be printed on screen. If I tamper with the image, I might trigger speculative execution in the JPEG library. Certainly harder to exploit than using JavaScript, but is it impossible? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759497"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2018 14:16 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/759497/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it could only be exploited if there were other code running which could sniff for the effects of speculation (changes in the cache state).  That code could be in another userland process if it has addresses which happen to share the same cache lines -- I think?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759497/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor759577"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 10:06 UTC (Thu)
                               by <b>edeloget</b> (subscriber, #88392)
                              [<a href="/Articles/759577/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The assumption that element[0] is a safe value is fragile and I'm sure it's going to burn people sooner or later.</font><br>
<p>
It's more or less required by the C standard unless I'm mistaken (for element[n] to be a valid expression, element shall be a valid pointer). gcc developers are not that interested in non-standard code :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759577/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759580"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 11:17 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/759580/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could write code like in lambda's comment where 'mem' is guaranteed to be a valid pointer if untrusted &lt; 100, but otherwise is invalid. C is perfectly happy with that, because there is no possible code path where you're either calculating or dereferencing the pointer &amp;mem[n] when mem is invalid. But the CPU doesn't care about your idea of code paths, it'll (speculatively) execute whatever arbitrary instructions it feels like, so it might execute instructions to read mem[n] when mem or n or both are invalid.<br>
<p>
(As a more realistic example, you could have some kind of dynamic array which stores a size and a pointer to the storage, but that pointer is an uninitialised value if size is 0. Speculatively reading from the 'safe' index 0 could be bad, and the CPU might do that even if the C code always checks size before accessing the storage.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759580/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor759817"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2018 4:50 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/759817/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The C standard only requires element[n] to be a valid expression if it's evaluated during regular (non-speculative) program execution.<br>
<p>
It's completely plausible that element[0] is uninitialized and the program never touches it during non-speculative execution, therefore is completely OK w.r.t. the C standard, but the CPU reads element[0] speculatively, leaking information about the uninitialized data.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759817/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor759496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2018 14:15 UTC (Wed)
                               by <b>nathan</b> (subscriber, #3559)
                              [<a href="/Articles/759496/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
notice that the sequence:<br>
  if (index &lt; structure-&gt;array_size) {<br>
        correct = (index &gt;= structure-&gt;array_size) ? all_zeroes : correct;<br>
requires the compiler's value-range-propagation optimization not function here.  After all, because we're inside the if body, C abstract machine semantics tells us that index is indeed less than the array size.  so a test for it to be greater-or-equal must be false.  Thus C language semantics tells us we can reduce that conditional assignment to 'correct = correct' (and then eliminate it entirely).  That of course would defeat the whole point.<br>
<p>
That's one of the horrible bits of these vulnerabilities.  Not only do they confuse human programmers, you often can't fix them without turning off optimizers.  And you only want to do that as locally as possible.  Hence the need for a compiler builtin that hides these semantics from the optimizers.<br>
<p>
[above deduction presumes lack of volatile objects]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Compiler optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2018 15:13 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/759526/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      That would indeed be the case if the defense were done in C code, but that code is there for illustrative purposes. The actual implementation is inserted by the compiler, as described further down in the article.
      
          <div class="CommentReplyButton">
            <form action="/Articles/759526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Compiler optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 7:06 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/759569/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was confused by that too.  I think pseudocode needs to look less like C -- at least in articles like this, where the difference between C source code and generated assembly is so significant.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor759594"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware-level micro-op optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 13:33 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/759594/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The compiler won't emit instructions to perform the comparison again -- the result is still in a status bit, so it only needs to issue a conditional move instruction.  But the chip has its own peephole optimizer, and knows that it just used that status bit two instructions back. Could it not, itself, replace the conditional-move micro-op, in its decoded-instruction cache, with the unconditional version? Or are we confident that both have the same cycle-level cost, so that the hardware micro-op optimizer would have no reason to make such a substitution? Or, have we direct assurance from (all?) manufacturers that no such hardware-level optimization is done?<br>
<p>
It is a strange world we live in, now, where we cannot have any confidence that the machine instructions we see correctly describe the machine behavior they will evoke.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759594/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759642"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware-level micro-op optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 14:51 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/759642/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Instructions like <tt>CSEL</tt> are defined by the architecture to not execute speculatively.  That is, as I understand it, a requirement to be able to do things like constant-time crypto operations.  So its use of the condition code is different from the test immediately above, which can be speculated.  Assuming the processor behaves as specified, the result should be correct.
<p>
Or that's how I understand it, at least.
      
          <div class="CommentReplyButton">
            <form action="/Articles/759642/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759652"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware-level micro-op optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 18:49 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/759652/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is how I understand it, also.  However, a hardware-level optimization to make a conditional move unconditional because the optimizer knows nothing has changed the status bit since its last use is not speculation.<br>
<p>
Some background, for those catching up... In prehistory, each instruction mapped to a specific series of machine states, and you knew everything about the machine just from the instructions you could see. When we got microcode, at first each instruction mapped to a specific sequence of microcode operations. With various caches, register renaming, and out-of-order execution scheduling "functional units" opportunistically, the sequence of machine states is a matter of speculation. With speculative execution, we got even less determinism, because now operations not even asked for ("yet") happen.<br>
<p>
Early on, the translation from instructions to microcode sequences lost its direct mapping. Now, that mapping results in micro-ops for various nearby instructions interleaved, operating on physical registers chosen by the scheduler according to data flow dependencies it tracks. The translation to micro-ops can take into account knowledge of the actual run-time state of the machine, invisible to programmer and compiler. For example, the chip can know a divisor in a register is a power of two, and is not updated during a loop, and so substitute a shift or mask operation for the division. memcpy is a frequent bottleneck in real programs, so the chip may watch for instruction sequences that compilers emit for it, and substitute something smarter, instead, maybe based on the actual number of bytes and the actual alignment of the pointers.<br>
<p>
At issue here is that the micro-op optimizer also knows which micro-ops change status bits, and so could know that the micro-op sequence following a status-bit-controlled branch can be shortened. There's nothing speculative about this.  Chip vendors don't typically reveal this sort of detail, so the best we can do is measure whether the move and conditional move seem always to happen at the same speed, and suppose that, therefore, there would be no reason to do it. Of course, measurements don't tell us about the next release.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759652/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759663"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware-level micro-op optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 18:57 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/759663/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However, a hardware-level optimization to make a conditional move unconditional because</font><br>
<font class="QuotedText">&gt; the optimizer knows nothing has changed the status bit since its last use is not speculation.</font><br>
<p>
If said "last use" was speculative, and thus the state of the condition code is speculative, then using that code for optimization *is* speculation, instead.  The whole point is what happens during speculative execution; the instruction is a no-op in the real world.  But an instruction that is defined as not being executed speculatively cannot be elided as the result of a speculative branch prediction.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759663/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware-level micro-op optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 23:27 UTC (Thu)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/759687/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
+1<br>
<p>
Jon is right in his summary. But the point about uop caching and optimization is still a good one. Multiple efforts are underway in the industry to analyze this part of the front end in more detail for side channels. There are quite a few interesting possibilities I can think of, in particular with abuse of value prediction. I've asked a few research teams to consider looking at how badly people screwed up value predictors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor759686"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware-level micro-op optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 23:44 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/759686/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree, but the op that set the status flag was not a speculative op (unless it was in a block that is itself speculative*); it was a regular check that was supposed to be guarding the block where we inserted the conditional move, with, most likely, no micro-ops between it and the conditional move, thus ideally situated to be made unconditional.<br>
<p>
(*Speculation may pile upon speculation, up to the limit of microarchitectural resources.)<br>
<p>
Ultimately we will need assurances from vendors that the conditional nature of the move is not, and won't ever be, optimized away. Later, we will want another version of conditional move that we specifically allow to be micro-optimized; but first things first.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759686/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor759767"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2018 16:46 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/759767/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
almost all architectures have some sort of compare-and-assign operation that (1) is a single instruction without a branch, so the branch predictor does not enter the picture, and (2) is defined by the architecture to not be subject to speculation in its own right.
</blockquote>

2) is extremely doubtful.  Speculation is a microarchitectural feature (i.e., it differs in different implementations of the same architecture, because it is not architecturally visible (except in timings)), and architecture handbooks are normally silent about it.

<p>However, it is quite likely that these conditional instructions are not subject to speculation, because a major reason for introducing them was to avoid the cost of misprediction in cases where the programmer/compiler knows that the condition is hard to predict; so speculativing on the condition outcome would be counterproductive for typical uses of these instructions.  Also, while value prediction has been subject of academic papers for quite a while, I am not aware that it has arrived in commercially available CPUs yet.  But then, some CPU manufacturers are no longer marketing their CPUs by talking about the microarchitecture, so they might have introduced value prediction under the radar. 

<p>Otherwise, the article is pretty weak IMO:

<ul>
<li>It does not show me an example of the use of the new builtin.
<li>The article claims that preserving <code>correct</code> from one branch to the next is important, but fails to explain why, and it's certainly not obvious.  Unless this is about always checking the same index bounds, I fail to see what this achieves.
</ul>
      
          <div class="CommentReplyButton">
            <form action="/Articles/759767/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2018 17:08 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/759771/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      I'm sorry you didn't like the article.
<p>
Propagating <tt>correct</tt> is important because speculation can go through numerous branches; as soon as one has gone wrong, you know that any others down the chain are suspect too.
      
          <div class="CommentReplyButton">
            <form action="/Articles/759771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2018 17:28 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/759774/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Maybe, but in what way does that help?  One has to add protection to the other branches anyway.  If the next index is outside the bounds, the protection will make sure it is squashed, so it does not help there.  If the next index is inside the bounds, propagating correct will squash it on the speculative path when it otherwise would not, but what does that gain?
      
          <div class="CommentReplyButton">
            <form action="/Articles/759774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759780"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2018 17:44 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/759780/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Once speculation has gone off the rails, just about anything can happen.  Subsequent branches could well assume that previous bounds checks had been done correctly and do the wrong thing when the invariant no longer holds.  Branches and calls can also be nested, of course, which makes such problems more likely.
<p>
Why would you <i>not</i> clamp sensitive accesses when you know that the assumptions the code was written under do not actually hold?
<p>
That's how I understand it, anyway.
      
          <div class="CommentReplyButton">
            <form action="/Articles/759780/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759783"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2018 18:04 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/759783/">Link</a>] 
      </p>
      
      </div>
      </summary>
      If the next branch is after the if ends, the compiler cannot make such assumptions, but for nested ifs, it can.  But still, it would be sufficient to make sure that the conditional move that checks the index and squashes it if necessary is not subject to such range-propagating optimizations, just like the conditional move that squashed the index of the first access.  So, it's still not clear what the advantage of this propagation is.
      
          <div class="CommentReplyButton">
            <form action="/Articles/759783/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor760397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2018 23:16 UTC (Thu)
                               by <b>mcortese</b> (guest, #52099)
                              [<a href="/Articles/760397/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I have some doubts, too.

<p>Let me take the article's example and add a second condition further down the code (I'll not use a syntax too similar to C to avoid suggesting that it could be subject to the compiler's transformations and optimizations).
<pre>
correct := all_ones

/* first conditional block */
if condition
    correct := condition ? correct : all_zeros
    use correct as a mask
    ...
end if

/* second conditional block */
if condition
    correct := condition ? correct : all_zeros
    use correct as a mask
    ...
end if
</pre>

<p>My understanding is that the variable 'correct' must be propagated between the two conditional blocks. But if the variable 'correct' must be recalculated anyway, why do we have to carry it along between the two block? In other words, wouldn't this work just the same?
<pre>
/* first conditional block */
if condition
    correct := condition ? all_ones : all_zeros
    use correct as a mask
    ...
    free correct /* don't need it anymore */
end if

/* second conditional block */
if condition
    correct := condition ? all_ones : all_zeros
    use correct as a mask
    ...
    free correct /* don't need it anymore */
end if
</pre>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor798059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2019 17:03 UTC (Sun)
                               by <b>smadu2</b> (guest, #54943)
                              [<a href="/Articles/798059/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Has anybody started to use this __builtin ? Curious.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/798059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor798076"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spectre V1 defense in GCC</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2019 2:36 UTC (Mon)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/798076/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A quick check of my gentoo distfiles dir (i.e. `rg --binary -zF __builtin_speculation_safe_value`) only turns up GCC itself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/798076/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
