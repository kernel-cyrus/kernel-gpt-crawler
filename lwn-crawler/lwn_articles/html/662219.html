        <!DOCTYPE html>
        <html lang="en">
        <head><title>Kernel security: beyond bug fixing [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/662219/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/661776/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/662219/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Kernel security: beyond bug fixing</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 28, 2015</br>
           <hr>
<a href="/Articles/KernelSummit2015/">2015 Kernel Summit</a>
</div>
As kernel security maintainer James Morris noted in the introduction to a
2015 Kernel Summit session, a lot of progress has been made with regard to
kernel security in the last 10-15 years.  That said, there are lot of
things we could be doing better, and one could make the case that we have
fallen behind the state of the art in a number of areas, including
self-protection and hardening.  On that note, he stepped aside and let Kees
Cook 
give the group the bad news about what needs to be done to improve the
kernel's security.
<p>
Kees started by making the claim that security needs to be more than just
access control and attack-surface reduction.  Crucially, it also needs to be
more than just fixing bugs.  The kernel needs to learn to protect itself
better in the presence of inevitable security bugs, even if that means
imposing some pain on kernel developers.
<p>
There are, Kees said, one billion Android devices in circulation.  Most of
them are running 3.4 kernels, with the (still old) 3.10 kernel running a
distant second.  That, he said, is "completely terrifying."  The lifetime
of critical security bugs is huge; bugs are often found many years after

<a href="/Articles/662227/"><img
src="https://static.lwn.net/images/conf/2015/klf-ks/KeesCook-sm.jpg" width=250 height=312
alt="[Kees Cook]" title="Kees Cook" border=0 hspace=3 vspace=3
align="right"></a> 

they have been introduced into the kernel.  But attackers are often finding
these bugs right away and exploiting them for most of those years while
they remain in the kernel.
<p>
We <i>are</i> finding bugs, especially with the introduction of more
checkers and such.  We are fixing the bugs.  But there will always be bugs
because we keep writing them.  It's a whack-a-mole situation, but playing
whack-a-mole is not the solution.  Instead, we need to get to a point where
we can handle failures safely.  It is not overstating things to say that,
in an era of things like self-driving cars, lives depend on our solving
this problem.
<p>
The best way to deal with security problems is to kill entire classes of
exploits at a time.  Getting there involves eliminating targets, methods of
attack, information leaks, or anything else that helps attackers.  We have
to do that, even if it makes life more difficult for developers.  This
stuff <i>will</i> get in people's way; that makes it a hard sell.
<p>
To eliminate classes of attack, we need to understand how typical exploit
chains work.  Most attacks exploit more than one flaw in the target
system.  At various times they need to know where the targets are, inject
malicious code into the system, find where that code ended up, and redirect
control to that code.  Each of those may require exploiting a different
flaw.  Attackers often have a number of flaws that can be exploited to
carry out any given step in the chain; if one flaw is fixed, another can be
used instead.
<p>
<h4>Dealing with vulnerabilities</h4>
<p>
So what can we do?  Kees launched into a series of vulnerabilities and
steps that might be taken to find and eliminate entire classes of them.
<p>
First on the list was stack overflows.  A classic approach for the
detection of stack overflows is putting a canary on the stack, but there
are some exploits that write far beyond the end of the stack, skipping over
the canary entirely.  Stack location randomization can help here, as can
shadow stacks — parallel stacks where important values like return
addresses are stored.
<p>
Integer overflows and underflows are the source of many vulnerabilities.
For these, it is possible to instrument the compiler to detect overflows at
run time.  This process is not free of pain; sometimes overflows are expected,
so the compiler must be told that the code is correct.  Interestingly, this
instrumentation can, at times, actually improve the performance of the
code.
<p>
Heap overflows can be addressed by runtime validation of variable sizes in
the <tt>copy_*_user()</tt> functions and elsewhere.  Placement of guard
pages can catch heap-overflow exploits.  Runtime validation of linked lists
is also a useful technique here.
<p>
For format-string injection problems, the best thing to do would be to drop
the <tt>%n</tt> format specifier entirely.  (That specifier causes the
number of characters written to be stored in a variable; it's worth noting
that the kernel's format-string handling already ignores <tt>%n</tt>).
<p>
Kernel pointer leaks are everywhere; the <a
href="/Articles/420403/"><tt>kptr_restrict</tt></a> mechanism is far too
weak.  It requires developers to explicitly opt in to prevent pointer
leaks, so many 
don't.  A more useful technique would be, for example, to instrument the <a
href="/Articles/22355/">seq_file subsystem</a> to detect use of <tt>%p</tt>
(used to format pointers) and simply block output when somebody tries to
use it.
<p>
Uninitialized variables can be mitigated by clearing the kernel stack
between system calls.  As Kees described in <a
href="https://outflux.net/slides/2011/defcon/kernel-exploitation.pdf">a
talk [PDF]</a> some years ago, uninitialized variables on the stack can be
exploitable.
<p>
<h4>Blocking exploits</h4>
<p>
Many exploits require finding the location of the kernel in physical
memory, so anything 
that can be done to make the kernel harder to find will make those exploits
harder.  This can be done by hiding symbols and avoiding the leaking of
kernel pointers to user space.  <a href="/Articles/569635/">Kernel address-space
layout randomization</a> is not a perfect shield, but it can still help to
make finding the kernel harder.  Setting memory protections so that
executable pages cannot be read (if the hardware supports this) can be a
good technique.  Kees also suggested build-time structure layout
randomization.
<p>
Exploits can overwrite kernel text directly — something that, Kees said,
should not be possible at all.  Ensuring that executable pages are not
writable would help.  There are techniques in the kernel (jump labels, for
example) that depend on being able to overwrite code; they can still be
used by mapping in new pages or simply turning on write permissions for as
long as it takes to make the change.  Moving away from situations where a
single write instruction can compromise the kernel will make us more
secure.
<p>
Overwriting of function pointers can be blocked by making tables (and
structures) of function pointers <tt>const</tt>.  This has been done in
parts of the kernel, but there are many more opportunities for improvement
there.
<p>
The ability to make the kernel execute code in user-space memory is
exploitable.  The best solution here can be hardware segmentation; Intel's
"supervisor-mode execution prevention" and ARM's "privileged execute never"
can both block execution from user-space memory.  Instrumenting the
compiler to set the high address bit on all kernel function calls can block
calls into user-space memory (since the kernel's address space is at the
upper end of the virtual address range, while user space is at the bottom).
Kees also suggested emulating segmentation by 
using separate page tables for user mode and kernel mode; Linus jumped in
at this point to say that this is the kind of idea that makes security
people look crazy; such an approach would never perform well.  He suggested
avoiding talking about ideas that will 
clearly never make it into the mainline.
<p>
<a
href="https://en.wikipedia.org/wiki/Return-oriented_programming">Return-oriented
programming</a> can be used to piece together desired functionality
out of chunks of existing code.  This kind of code-chunk reuse can be
fought with compiler instrumentation to ensure "control-flow integrity."
<p>
<h4>Challenges</h4>
<p>
Even if we know how to deal with many classes of exploits, there are
non-technical challenges that get in the way.  At the top of this list is
conservatism.  It took 16 years, for example, to get basic <a
href="/Articles/390323/">symbolic link protections</a> into the kernel, and
that was just providing a defense for user space.  We as a community have
to accept that we need these features, even though some of them are going
to be a burden.
<p>
Another challenge is the additional complexity that comes with many
security technologies.  But, Kees said, we have done many complex things
over the years; we can handle this one as well.
<p>
Finally, there is the challenge of resources.  To get this work done we
need developers, testers, backporters, and more.  These need to be people
who are dedicated to those roles, meaning that it needs to be paid work.
This is an industry-wide problem; companies working in this
industry need to support work on the solutions.
<p>
The kernel community has often been hostile to changes that increase
security if they  decrease usability or performance, or if they make
development harder.  But this 
particular talk led to a lot of discussion among the attendees.  It would
seem that the kernel development community is coming around to the idea
that some sacrifices may need to be made to provide the level of security
that our users need.  The real test will come when the patches start to
arrive; if, as Kees suggested, developers manage to avoid reflexively
rejecting security patches, things will have started moving in the right
direction.
<p>
[Your editor would like to thank the Linux Foundation for supporting his
travel to the Kernel Summit].<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security">Security</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Hardening">Hardening</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/662219/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor662360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 9:28 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/662360/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The kernel community has often been hostile to changes that increase security if they decrease usability or performance, or if they make development harder.</font><br>
<p>
I have always found that programmers tend have a slightly irrational attitude towards performance.  An extreme example would be added complexity to speed up code containing a bug which could cause a crash.  The user gains a few cycles every time the code is executed, and loses work every time the crash occurs.  What is the overall benefit to the user?  But then again, perhaps what the programmer wants is not really performance but fun writing (and reading?) the code.  Which is perhaps slightly more rational.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662371"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 10:21 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/662371/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
After a decade on Gentoo, I've figured out all the compiler switches in the world are no substitute for simply throwing out bad software when a better tool comes along.<br>
<p>
("Compiler switches" can be used interchangeably with "angry forum posts" in the above.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662371/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662660"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 31, 2015 20:49 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/662660/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; After a decade on Gentoo, I've figured out all the compiler switches in the world are no substitute for simply throwing out bad software when a better tool comes along.</font><br>
<p>
C was a "stroke of genius" at the time it was invented, and OK-ish in a very poorly connected world. As this article demonstrates once again, it's beyond fixable from a security perspective. All the new checkers and other fancy tools in the world will never be enough to fix a deeply ingrained culture, one where for instance performance is preferred over security almost every time.<br>
<p>
It will be a very slow transition and projects like kernels which stand the most in critical paths will be last; but C will eventually and gradually fade away. It will happen much, much faster if/when some companies will finally be found liable for the security of the software they make money from - as opposed to be the first to market able to decode 4K videos on a 5" screen.<br>
<p>
It took decades (one generation?) but even BIOS recently dropped assembly, so there is hope. At least for our children.<br>
<p>
PS: of course alternatives to C are not silver bullets. They're "only" one or two orders of magnitude safer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662660/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663174"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 10:52 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/663174/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It took decades (one generation?) but even BIOS recently dropped assembly, so there is hope. At least for our children.</font><br>
<p>
Which BIOS is that? I understood that at least one major BIOS was written in Forth, and has been that way for what, all of this century?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663174/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor663212"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 14:56 UTC (Thu)
                               by <b>ortalo</b> (guest, #4654)
                              [<a href="/Articles/663212/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I do not really think the programming language is such a critical concern, neither the language level (Oz/ML vs Python vs C vs assembly language).<br>
Why? Because it really seems possible to write a bad program in any language. And some people seem pretty good at that, whatever the programming environment cleverness.<br>
And also because some of the best programs that never failed [1] were written in a mixture of assembly language and custom languages, but surely finely crafted by pretty good "coders" (who, btw, probably agree with you with respect to high-order languages safety advantage).<br>
<p>
The problem when thinking about our children is the fact that you may neglect to assess what our grand-parents did (right).<br>
<p>
[1] Look around Apollo or the shuttle flight system for top-class examples. Sorry for not having more recent examples. *That* is annoying I agree.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663212/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663631"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2015 18:06 UTC (Sat)
                               by <b>geek</b> (guest, #45074)
                              [<a href="/Articles/663631/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, TEX is written in Pascal and is widely held to be the best example of a large, widely used program with NO bugs.<br>
<p>
And if it takes Ken Thompson and Dennis Ritchie to write large bug-free programs in C, um, how many programmers like that are there?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663631/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor664111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2015 21:20 UTC (Wed)
                               by <b>robbe</b> (guest, #16131)
                              [<a href="/Articles/664111/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don’t think TeX being largely bug-free owns much to its implementation language.<br>
<p>
A better explanation is that it’s in rigid bugfix-only mode for more than 20 years now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/664111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor663711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2015 2:16 UTC (Mon)
                               by <b>xman</b> (guest, #46972)
                              [<a href="/Articles/663711/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Because it really seems possible to write a bad program in any language. And some people seem pretty good at that, whatever the programming environment cleverness.</font><br>
<p>
While undeniably people are great at writing bad code, there are languages/interfaces/apis/designs/whatever that are less error prone than others, and make it easier to see and correct bugs once you find them. Sparse demonstrates that even relatively subtle enhancements to the expressiveness of the kernel's code, you can significantly reduce the overhead lost to bugs.<br>
<p>
That allows for a much, much more targeted approach to addressing security.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor663188"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">userspace drivers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 12:37 UTC (Thu)
                               by <b>Zolko</b> (guest, #99166)
                              [<a href="/Articles/663188/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This performance -vs- speed is also the argument to not have drivers in userspace. Which means that there is kernel code running that is completely unknown to the developers. We are not talking about bugs or security flaws, but built-in backdoors by the manufacturer. For example, Broadcom is a US company, who wants to bet that their closed binary drivers contain backdoors requested by the NSA under gagging legislation ? <br>
<p>
What use is there for a firewall if the first line of defense is a traitor ? What use is there for sandboxing if the X driver installs keyloggers and then phones home ?<br>
<p>
Talking about kernel security with a monolithical kernel and binary drivers is pointless crap (TM Linus) !!!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663188/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663671"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">userspace drivers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2015 12:43 UTC (Sun)
                               by <b>JanC_</b> (guest, #34940)
                              [<a href="/Articles/663671/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't see how those binary drivers being in userspace would help against an NSA backdoor at all (especially in case of e.g. network drivers)?<br>
<p>
And I think you are wrong in case of most Broadcom drivers, which are open source but have to upload a closed source firmware into the network hardware, because they don't have a closed source firmware in ROM/flash like some others do.  Both uploaded &amp; saved in ROM/flash firmwares could contain a backdoor, so kernel vs. userspace doesn't even come into play there.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663671/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor668440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">userspace drivers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 18, 2015 4:22 UTC (Fri)
                               by <b>Rudd-O</b> (guest, #61155)
                              [<a href="/Articles/668440/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's this thing called "Direct Memory Access" in modern computers.  Drivers can use that to access any sort of main memory or other devices in the same bus.<br>
<p>
Thus, while you think your (possibly compromised) network driver is oblivious to your password keystrokes because your connection to this site is SSL, your (possibly compromised) network driver is in fact stealing your keystrokes as you go.<br>
<p>
(I say possibly compromised, but with DMA, it's a juicy target for a compromise.  There are videos of people doing this sort of thing, by the way.  It's not something esoteric.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/668440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor668441"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">userspace drivers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 18, 2015 4:29 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/668441/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  There's this thing called "Direct Memory Access" in modern computers. Drivers can use that to access any sort of main memory or other devices in the same bus.</font><br>
Not anymore: <a href="https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit">https://en.wikipedia.org/wiki/Input%E2%80%93output_memory...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/668441/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor663708"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2015 2:10 UTC (Mon)
                               by <b>xman</b> (guest, #46972)
                              [<a href="/Articles/663708/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It may seem like developers are insane about this, but when you contemplate just how much performance is left on the table with our security measures and abstractions right now, there is actually a LOT developers already have sacrificed on the pillars of performance.<br>
<p>
With systems programming in particular, inefficiency itself often leads to its own bugs and security compromises farther up the stack. Developers *and* end users naturally route around inconvenient security systems and abstractions.<br>
<p>
Heck, we can have drastically improved security and privacy on the Internet right now, if we're just willing to absorb a 5x increase in latency and decrease in throughput (which, if you think about it, we had to suffer with right now), but hardly anyone is willing to make that compromise.<br>
<p>
At a higher level, the whole "remember my credit card" feature is an exercise in forgoing the minimal protections of an at least somewhat random and monitored credit card number that they carry with them everywhere for protection from what is almost always not-at-all-random and trivially crackable, not terribly well monitored, memorized password. Ask anyone who works in e-commerce how much more money they make with that feature.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663708/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor662382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 10:45 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/662382/">Link</a>] (30 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On return-address overwrites, why not have the compiler put the return address /before/ the locals?<br>
<p>
I know that'd be difficult to do for user-space - it'd be a new ABI - but the kernel is much less constrained here. Is it viable? What am I missing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 11:07 UTC (Thu)
                               by <b>dunlapg</b> (guest, #57764)
                              [<a href="/Articles/662385/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well first, because that's the way a stack goes -- it starts at the top and works its way down.<br>
<p>
But even if that could be arranged, it wouldn't actually help, because now the return address for the *parent* is in front of your buffer; you can overwrite that one instead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 11:24 UTC (Thu)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/662392/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, the only way this could be fixed would be to have a separate return stack. Not that THAT wouldn't come with its own set of problems and vulnerabilities...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662449"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 17:39 UTC (Thu)
                               by <b>Nahor</b> (subscriber, #51583)
                              [<a href="/Articles/662449/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's what is called a shadow stack and is mentioned in the article<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662449/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2015 4:14 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/662496/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's also what ia64 did, and it wasn't fun to handle...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662649"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 31, 2015 16:33 UTC (Sat)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/662649/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm. What problems does it cause? Mill does all of the stack setup and return address storing as part of the "call" instruction (it also handles argument passing automatically though). The stack is also 0-initialized and not necessarily anywhere near the parent's stack (I believe a stack overflow would just be a hard segfault).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662649/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor662391"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 11:27 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/662391/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess my wording was a bit bad (particularly 'before' [I meant 'before' in the 'looking back up the stack' sense, which doesn't make sense in terms of the order they're written or the order of the addresses] ;) ). <br>
<p>
Yeah, the stack frames grow down, and ebp is saved to the stack first, so overflows of the local vars can write to it. Why not have the compiler create frame-generation code that first allocates the local var space and /then/ pushes the base pointer to the stack? So ebp is at a lower address and can't be written to by local var overflows?<br>
<p>
(No doubt there's a reason why this isn't possible, I'm just curious what it is).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662391/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 12:42 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/662409/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One quick thought is that negative overflows are sometimes possible as well.  Maybe even often possible, or easily achievable in practice - that might explain why your idea has not been adopted.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor662483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 23:31 UTC (Thu)
                               by <b>Gollum</b> (guest, #25237)
                              [<a href="/Articles/662483/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The idea that the stack starts at the top, and grows downwards seems to be the fundamental problem here. You write something important on the stack (e.g. a return address), then move to a new space some distance further back, so that any excessive steps forward trample on the important information.<br>
<p>
Defining a stack that grows upwards seems like one reasonable approach to deal with this problem. Perhaps swapping the heap (which currently grows upwards, I believe?) with the stack (which grows downwards) is the answer?<br>
<p>
Or would that simply swap one set of problems (stack-based overflows) for a new version of heap-based overflows, where a heap overflow overwrites the heap metadata?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662546"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2015 14:01 UTC (Fri)
                               by <b>dunlapg</b> (guest, #57764)
                              [<a href="/Articles/662546/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Look, even if you could change the direction, that doesn't actually fix the problem.<br>
<p>
Right now, if you call foo() which calls bar() which calls zot(), you get:<br>
[foo local variables]<br>
[bar -&gt; foo return address]<br>
[bar local variables]<br>
[zot -&gt; bar return address]<br>
[zot local variables]<br>
<p>
So if you can overflow a zot local variable, you can overwrite the zot-&gt;bar return address.<br>
<p>
Now suppose we switch it.  What do we get?<br>
[foo local variables]<br>
[bar local variables]<br>
[bar -&gt; foo return address]<br>
[zot local variables]<br>
[zot -&gt; bar return address]<br>
<p>
So now if you can overflow a zot local variable, you can't overwrite the zot-&gt;bar return address, but you can still overwrite the bar-&gt;foo address.<br>
<p>
Changing the direction of the stacks won't help.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662546/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662566"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2015 18:04 UTC (Fri)
                               by <b>Gollum</b> (guest, #25237)
                              [<a href="/Articles/662566/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you may have misunderstood me. My suggestion is more like:<br>
<p>
[zot local variables]<br>
[zot -&gt; bar return address]<br>
[bar local variables]<br>
[bar -&gt; foo return address]<br>
[foo local variables]<br>
<p>
So, if you are in zot, and you overflow a zot local variable, you write into unused space, and don't "overwrite" anything at all. That is, because zot-&gt;bar return address is at a lower address than the zot local variables, and overflows write "upwards" using incrementing addresses, the opportunity to overwrite return addresses is eliminated. <br>
<p>
It doesn't protect the rest of the zot local variables, of course, so overwriting something otherwise uncontrollable by yourself may result in a successful comparison when previously it would have been unsuccessful.<br>
<p>
And as I say, changing the heap to grow downwards may simply be changing one set of problems for another.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662566/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2015 1:54 UTC (Wed)
                               by <b>ploxiln</b> (subscriber, #58395)
                              [<a href="/Articles/662991/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's very common for a buffer to be allocated in a parent stack frame and then used in a child function. For example<br>
<p>
    foo() {<br>
        char buf[16];<br>
        bar(buf, 16);<br>
        ...<br>
    }<br>
<p>
So if bar could overflow a buffer in its stack frame, or in foo's stack frame, no matter how you arrange them, one of them could hit the return address.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663007"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2015 12:30 UTC (Wed)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/663007/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So if bar could overflow a buffer in its stack frame, or in foo's stack frame, no matter how you arrange them,</font><br>
<p>
"No matter how you arrange them" is not correct: if you have separated variable and address stack, you cannot use a buffer overflow to override a return address.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663007/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2015 23:47 UTC (Wed)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/663143/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
why not? you first overwrite a local variable of pointer type then let the rest of the function write through that pointer to overwrite the return address on the other stack.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 9:31 UTC (Thu)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/663163/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm sorry but I didn't understand how your example would work.<br>
<p>
Can you explain it again or do you have a link with an article explaining how it could work?<br>
Thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 10:36 UTC (Thu)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/663171/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
void foo(char *in, long s)<br>
{<br>
 long *p;<br>
 char out[8];<br>
 memcpy(out, in, 1024);<br>
 *p = s;<br>
}<br>
<p>
assume the attacker controls the data behind 'in' and that the memcpy overwrites both 'p' and 's' on the stack, the last line will then be able to write anything anywhere. in short, there are many ways a memory corruption bug can be exploited, overwriting the return address of the current frame is just one and perhaps the most popularized textbook example but by far not the only way. this is the reason why having a proper threat model helps avoiding mistakes in devising defenses.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 10:45 UTC (Thu)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/663173/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, it's able to write anything anywhere the process can, but it doesn't necessarily makes its possible to overwrite the return address, which makes it harder to exploit the flaw (especially if you have w^x and randomisation).<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663179"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 11:25 UTC (Thu)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/663179/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the return address is writable by the process and therefore by the arbitrary write primitive too. whether there're defenses that make it harder or not is orthogonal to your original statement 'you cannot use a buffer overflow to override a return address'.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663179/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 12:25 UTC (Thu)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/663180/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the return address is writable by the process and therefore by the arbitrary write primitive too. whether there're defenses that make it harder or not is orthogonal to your original statement 'you cannot use a buffer overflow to override a return address'.</font><br>
<p>
The 'arbitrary write' can overwrite the return address only if the address of the return address is known, which can be quite difficult if there is randomisation.<br>
<p>
Also for the Mill CPU(unfortunately paperware only currently) I think that the separated address stack is managed directly by the CPU, so an 'arbitrary write' cannot overwrite a return address.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663192"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 12:46 UTC (Thu)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/663192/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it seems to me that you're mixing up defense techniques with exploit techniques, which one are you arguing about now? ;) your original post made a blanket statement about something which is demonstrably false, that's all i wanted to point out. how you can make exploit techniques fail with deterministic or probabilistic methods is irrelevant for that discussion. case in point, my simple example may very well be non-exploitable if the compiler places some of those variables into registers which by definition are not subject to memory corruption, but that of course was not the point of the example.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663192/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor663187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 12:28 UTC (Thu)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/663187/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The only defense against THAT would be "only the CALL instruction can write on the return stack".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2015 12:52 UTC (Thu)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/663195/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
there're other defenses against that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2015 16:39 UTC (Tue)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/663915/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Care to elaborate? If any instruction can write to the return stack, it's always possible to point the return address to an address of my choosing, and that way calling anything the current function's security context has the right to call. Which is mostly everything, because proper security contexts are a pain in the arse.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2015 17:29 UTC (Tue)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/663922/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
there's a whole bunch of public research on control flow integrity, some of which also addresses protecting the return address despite its being writable by the attacker. i also recently presented my ideas on this at H2HC, see the slides for more details. in short, all these defenses boil down to restricting the 'address of my choosing' to the point that at least privilege escalation is no longer possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor665648"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 24, 2015 13:43 UTC (Tue)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/665648/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I couldn't find the slides. Link, please? :D<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665648/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor665663"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 24, 2015 16:25 UTC (Tue)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/665663/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://pax.grsecurity.net/docs/PaXTeam-H2HC15-RAP-RIP-ROP.pdf">https://pax.grsecurity.net/docs/PaXTeam-H2HC15-RAP-RIP-RO...</a> (there's some small errata in there that i'll fix eventually so better check the doc page for the updated version)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665663/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor663411"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2015 3:38 UTC (Fri)
                               by <b>ploxiln</b> (subscriber, #58395)
                              [<a href="/Articles/663411/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, I did mean "if using a single stack" :) Dual stacks are nifty (but as pointed out by another comment not 100% bulletproof).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663411/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor662519"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2015 13:28 UTC (Fri)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/662519/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could change the ABIs to make the stack ascending, from low to high addresses.  It's a lot of retooling, but there isn't any reason why it can't be done.  ARM LDM and STM instructions have ascending modes, so the change wouldn't cost performance, though I have no idea about x86 and other architectures.<br>
<p>
However, while such an ABI might make buffer overruns a little harder to exploit, because the overrun would generally be into the unused stack space, but I don't think it solves the problem; underuns or malicious code can still find return addresses in predictable read/write memory locations on the stack.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662519/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662544"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2015 13:54 UTC (Fri)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/662544/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When an interrupt is raised, the CPU automatically pushes some registers (at least the program counter) onto the stack, so it is not possible to change the stack direction without hardware support, which most architectures do not have.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662544/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662547"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2015 14:32 UTC (Fri)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/662547/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the CPU automatically pushes some registers</font><br>
<p>
Is that an x86 thing?<br>
<p>
On ARM, there are some shadow registers that backup the PC and the processor doesn't touch the stack itself - and rightly so!  It's most efficient for the interrupt handler writer to decide what state needs to be saved and restored, particularly if the interrupt routine isn't going to do very much.<br>
<p>
If a CPU did automatically push something on IRQ entry, you could still engineer an ABI that uses an 'empty ascending' stack where the stack pointer is maintained to point to the first unused word at the stack top.  <br>
<p>
I'm pretty sure you could run an ascending stack on ARM, probably other architectures too, but it would be for limited security benefits so moot.  <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662547/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662550"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2015 15:28 UTC (Fri)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/662550/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>ARM is pretty much the <a rel="nofollow" href="http://stackoverflow.com/questions/664744/what-is-the-direction-of-stack-growth-in-most-modern-systems">only architecture</a> where software can choose the stack direction.</p>
<p>There are many other architectures with optimized interrupt handling, but they do not have the same flexibility for normal function calls.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/662550/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor662404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 12:29 UTC (Thu)
                               by <b>cov</b> (guest, #84351)
                              [<a href="/Articles/662404/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Kees also suggested emulating segmentation by using separate page tables for user mode and kernel mode; Linus jumped in at this point to say that this is the kind of idea that makes security people look crazy; such an approach would never perform well. He suggested avoiding talking about ideas that will clearly never make it into the mainline.</font><br>
<p>
Isn't this exactly what ARMv8 hardware and the arm64 kernel code do, basically interpreting addresses as signed and using TTBR0 or TTBR1 accordingly?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2015 0:56 UTC (Tue)
                               by <b>thestinger</b> (guest, #91827)
                              [<a href="/Articles/662843/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SMEP (Ivy Bridge) and PXN (PAE on ARMv7, ARMv8) provide that subset of the KERNEXEC functionality and SMAP (Broadwell) and PAN (ARMv8.1 - i.e. it's not around yet) provide that subset of the UDEREF functionality. Note that there's more to the features than simply software emulation of those hardware features. KERNEXEC also includes mass-constification (the GCC CONSTIFY plugin is part of that umbrella), including for things that are only *mostly* read-only like the SELinux state via toggling it to writeable in tiny scopes with preemption disabled (can't simply flip it off via one tiny write to the enforcing boolean, etc.).<br>
<p>
PaX has very good implementations of KERNEXEC/UDEREF via segmentation on 32-bit and memory domains on 32-bit ARM though. The overhead is very small, regardless of the incorrect assumptions Linus has about it. It's significantly cheaper than security features they already support like SSP (-fstack-protector).<br>
<p>
The x86_64 implementation of UDEREF is expensive (slower system calls and page faults), but it's important for covering all of the existing hardware without SMAP. For many workloads it's insignificant (anything CPU / GPU bound with minimal system calls in hot paths like scientific computing and gaming) while for others it's a pretty big deal (web servers, etc.).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2015 2:02 UTC (Wed)
                               by <b>ploxiln</b> (subscriber, #58395)
                              [<a href="/Articles/662994/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, if your hardware supports segmentation or something like it, you don't have to swap the page tables (and invalidate the TLB) and performance isn't too bad.<br>
<p>
Kees was suggesting swapping the page tables, for each system call or interrupt, when the hardware does not support something like segmentation. That would certainly involve a lot of overhead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663528"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2015 18:19 UTC (Fri)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/663528/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That would certainly involve a lot of overhead.</font><br>
<p>
how about you actually try it out instead of speculating about it? PaX/UDEREF/PCID/amd64 at your service.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663528/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663535"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2015 19:25 UTC (Fri)
                               by <b>patrick_g</b> (subscriber, #44470)
                              [<a href="/Articles/663535/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; how about you actually try it out instead of speculating about it?</font><br>
<p>
No need to try. There is a usenix paper with perf comparisons here =&gt; <a href="https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final143.pdf">https://www.usenix.org/system/files/conference/usenixsecu...</a><br>
<p>
The paper is about kGuard but they do perf tests against vanilla and PaX.<br>
For latency in syscalls (in microseconds) they wrote :<br>
<p>
<font class="QuotedText">&gt; The PaX-protected kernel exhibits a latency ranging between 5.6% and 257% (average 84.5%) on the x86, whereas on x86-64, the latency overhead ranges between 19% and 531% (average 172.2%). Additionally, (..) overhead for process creation (in both architectures) lies between 8.1% to 56.3%.</font><br>
<p>
For sockets and pipes bandwith degradation agains vanilla they wrote :<br>
<p>
<font class="QuotedText">&gt; PaX’s  overhead lies  between  19.9%  –  58.8%  on  x86  (average  37%),and 21.7% – 78% on x86-64 (average 42.8%).</font><br>
<p>
But the slowdown is much less noticeable on macro benchmarks. For instance the test to build a vanilla kernel :<br>
<p>
<font class="QuotedText">&gt; On  the  x86,  the  PaX-protected  kernel incurs a 1.26% run-time overhead, while on the x86-64 the overhead is 2.89%.</font><br>
<p>
And sql-bench slowdown agains vanilla :<br>
<p>
<font class="QuotedText">&gt; PaX  lies between 1.16% (x86) and 2.67% (x86-64).</font><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663535/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663546"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2015 19:56 UTC (Fri)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/663546/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
that paper is useless, don't believe anything in it. like i said, go try the code yourself, especially because PCID support was added in 2013 only whereas the paper is from research done in 2010 or so.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663546/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor663521"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2015 17:42 UTC (Fri)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/663521/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux 4.3 added emulation of PAN on ARMv7 (CONFIG_CPU_SW_DOMAIN_PAN), again based on memory domains. It's even enabled by default. Unfortunately it's not compatible with LPAE.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663521/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663531"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2015 18:50 UTC (Fri)
                               by <b>kees</b> (subscriber, #27264)
                              [<a href="/Articles/663531/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I'm glad to see that working. For people that want to see what their kernels protect against, check out CONFIG_LKDTM, which creates /sys/kernel/debug/provoke-crash/DIRECT. Just echo into it to test various things (like EXEC_USERSPACE to check your SMEP or PXN):<br>
<p>
# cat /sys/kernel/debug/provoke-crash/DIRECT <br>
Available crash types:<br>
PANIC<br>
BUG<br>
WARNING<br>
EXCEPTION<br>
LOOP<br>
OVERFLOW<br>
CORRUPT_STACK<br>
UNALIGNED_LOAD_STORE_WRITE<br>
OVERWRITE_ALLOCATION<br>
WRITE_AFTER_FREE<br>
SOFTLOCKUP<br>
HARDLOCKUP<br>
SPINLOCKUP<br>
HUNG_TASK<br>
EXEC_DATA<br>
EXEC_STACK<br>
EXEC_KMALLOC<br>
EXEC_VMALLOC<br>
EXEC_USERSPACE<br>
ACCESS_USERSPACE<br>
WRITE_RO<br>
WRITE_KERN<br>
# echo EXEC_USERSPACE &gt; /sys/kernel/debug/provoke-crash/DIRECT<br>
[2594952.708824] lkdtm: Performing direct entry EXEC_USERSPACE<br>
[2594952.708852] lkdtm: attempting ok execution at ffffffffad5b2422<br>
[2594952.708878] lkdtm: attempting bad execution at 00007f739d328000<br>
[2594952.708907] unable to execute userspace code (SMEP?) (uid: 0)<br>
[2594952.708920] BUG: unable to handle kernel paging request at 00007f739d328000<br>
[2594952.708939] IP: [&lt;00007f739d328000&gt;] 0x7f739d328000<br>
[2594952.708958] PGD 254a3f067 PUD 2732b0067 PMD 255bba067 PTE 248510067<br>
[2594952.708981] Oops: 0011 [#1] SMP <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663531/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor662452"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2015 18:24 UTC (Thu)
                               by <b>minipli</b> (guest, #69735)
                              [<a href="/Articles/662452/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The proposed mitigation list reads like an incomplete feature set description of the PaX/grsecurity patches.<br>
It's sad, neither Kees nor Jon mentioned the origin of those ideas.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662452/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662485"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2015 0:10 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/662485/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Kees did not mention those patches in this session, though they were discussed in other settings (writeups to come).  It looks like there will be yet another attempt to go through those patches and upstream that which can be upstreamed.  There is also a lot of interest in looking at their GCC extensions and seeing if they can be worked into the normal development process.
      
          <div class="CommentReplyButton">
            <form action="/Articles/662485/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor662567"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2015 18:13 UTC (Fri)
                               by <b>mricon</b> (subscriber, #59252)
                              [<a href="/Articles/662567/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://twitter.com/kees_cook/status/658973606743949312">https://twitter.com/kees_cook/status/658973606743949312</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662567/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor662573"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 30, 2015 19:14 UTC (Fri)
                               by <b>mtaht</b> (subscriber, #11087)
                              [<a href="/Articles/662573/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the system is rotten to the cpu cores, which is why, when I have spare time, for the past year, I've work on millcomputing's cpu design.<br>
<p>
Their cpu is largely immune to stack smashing attacks, browsing in heap rubble, calloc is a 0 cost operation, and it has memory protection down to the byte. It's still a long way from realizable hardware, but I am strongly encouraged with where the design stands today. <br>
<p>
For some details on these security features, see: <a href="http://millcomputing.com/wiki/Protection">http://millcomputing.com/wiki/Protection</a><br>
<p>
and the preso linked to it down at the bottom is both informative and entertaining.<br>
<p>
Porting linux to it will not be hard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662573/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662597"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 31, 2015 0:36 UTC (Sat)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/662597/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Speaking of overwriting the stack, Martin Sustrik's new C concurrency library does so on purpose to switch contexts rapidly:<br>
<p>
<a href="https://twit.tv/shows/floss-weekly/episodes/358?autostart=false">https://twit.tv/shows/floss-weekly/episodes/358?autostart...</a><br>
<p>
Sounds pretty fascinating.  Sustrik is the guy behind ZeroMQ and has implemented Go-like lockless thread management semantics.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662597/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662654"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 31, 2015 19:04 UTC (Sat)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/662654/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, so that's unportable to Mill as-is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662654/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor662610"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 31, 2015 9:13 UTC (Sat)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/662610/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      It's really sad that the major mitigations proposed for blocking exploits are only KASLR and structure layout randomization&nbsp;&ndash; both of which, as things stand, are (IMO) long-term incompatible with the Internet-of-Things.<p>
KASLR is only useful together with very strict pointer leak prevention; even then, its value is bounded by the size of the area within which the kernel can be moved. IoT devices are often built with very slim margins, so they have only as much RAM as their applications require&mdash;leaving precious little wiggle room for KASLR.<br>
Structure layout randomization, on the other hand, only occurs at build time&hellip; so when millions of devices are shipped with the same kernel, this mechanism also loses much of its value. (Sure, it can be better than today's situation&nbsp;&mdash; at least attacks will need to be tailored to different devices.)<p>
<p>
To end on a more positive note, a couple of ideas (not orthogonal, nor necessarily practical):
<ul>
<li>Revive TCCBOOT in some form, so devices will build their own kernels at boot time (and thus employ per-device, per-boot randomizations).
<li>Store the kernel as an archive library (<tt>.a</tt> file) on the device, and make the boot loader complete the link process&mdash;and randomize the order of sections/functions while doing so. This can add much more &ldquo;noise&rdquo; to kernel addresses than plain KASLR.
</ul>
      
          <div class="CommentReplyButton">
            <form action="/Articles/662610/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662681"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 1, 2015 8:08 UTC (Sun)
                               by <b>JdGordy</b> (subscriber, #70103)
                              [<a href="/Articles/662681/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Revive TCCBOOT in some form, so devices will build their own kernels at boot time (and thus employ per-device, per-boot randomizations).<br>
Store the kernel as an archive library (.a file) on the device, and make the boot loader complete the link process—and randomize the order of sections/functions while doing so. This can add much more “noise” to kernel addresses than plain KASLR."<br>
<p>
Both of those need a good source of randomness at boot time, which IoT devices wont have (or if they have they will be assumed to be backdoored)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662681/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662682"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 1, 2015 8:37 UTC (Sun)
                               by <b>alonz</b> (subscriber, #815)
                              [<a href="/Articles/662682/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">
&gt; Both of those need a good source of randomness at boot time, which IoT devices wont have<br>
&gt; (or if they have they will be assumed to be backdoored)<br>
</font>
<p>How pessimistic :)<p>
Many chipsets already provide hardware RNGs; I can hope that there will be more of those as time goes by.<p>
As for these RNGs being backdoored... I know the ones I designed were not (alas, I'm not certain what chipsets still use those). I believe this is the case for at least most of the devices: contrary to popular belief, most companies designing IoT devices truly care about their customers' security (or, at least, they truly are afraid of the backlash if they're revealed to have put backdoors in place without advertising them).
      
          <div class="CommentReplyButton">
            <form action="/Articles/662682/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662718"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 2, 2015 9:51 UTC (Mon)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/662718/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with quite a few built-in RNGs is that they are completely undocumented ("trust us"), or when they are documented, that they turn out to have weaknesses.<br>
<p>
For example, Atmel's ATSHA204* and some other chips appear to have a very poor random source, and try to paper over this with a PRNG based on a unique serial number. They do store the current state in their EEPROM, so you have to choose between repeated values, or risking to wear out the EEPROM.<br>
<p>
A very common error is trying to use a von Neumann extractor to remove correlations (this extractor is guaranteed to work only on data that has no correlations to begin with). Lots of software, and Intel's 82802 and Via's Padlock RNGs have this error.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662718/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662851"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2015 5:24 UTC (Tue)
                               by <b>JdGordy</b> (subscriber, #70103)
                              [<a href="/Articles/662851/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"A very common error is trying to use a von Neumann extractor to remove correlations (this extractor is guaranteed to work only on data that has no correlations to begin with)."<br>
<p>
pardon?! <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662851/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662853"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">von Neumann extractor is not useful</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2015 7:42 UTC (Tue)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/662853/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A von Neumann extractor requires that the pairs "01" and "10" are equally likely in its input. This is true for a Bernoulli sequence (which, in toy examples, can be generated with a biased coin), but this has no relation with most random data occuring in the real world.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662853/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor664531"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">von Neumann extractor is not useful</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2015 4:10 UTC (Mon)
                               by <b>kevinm</b> (guest, #69913)
                              [<a href="/Articles/664531/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How exactly do you get two consecutive 01 transitions without an intervening 10 transition?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/664531/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor664535"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">von Neumann extractor is not useful</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2015 5:55 UTC (Mon)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/664535/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
0101<br>
(You cannot use the same bit for two decisions; that would break the output, too.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/664535/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor662856"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2015 9:23 UTC (Tue)
                               by <b>Darkmere</b> (subscriber, #53695)
                              [<a href="/Articles/662856/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Why only at boot?   <br>
Why not build something similar to Minix3's  <a href="http://wiki.minix3.org/doku.php?id=developersguide:liveupdate" >"Live rerandomization" (halfway down)</a> which will re-generate a link time randomized service, and then swap internal state over to it.  <br>
<p>
If there is live kernel patching, then there might be a possibility to re-randomize address space and move things around as well. 
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/662856/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor662984"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2015 0:22 UTC (Wed)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/662984/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Regarding conservatism: has any consideration been given to creation of a security tree, in similar fashion to the realtime tree?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662984/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2015 12:30 UTC (Wed)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/663008/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Regarding conservatism: has any consideration been given to creation of a security tree, in similar fashion to the realtime tree?</font><br>
<p>
And then spend a couple of decades trying to merge it back? :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663094"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2015 19:39 UTC (Wed)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/663094/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, maybe, but hopefully not:)<br>
My thoughts were that having a place where security was the overriding factor would increase the pool of potential contributors, demonstrate the worth (and cost) of said changes (thereby mitigating concerns about performance/bugs rather than having such concerns stop development prematurely), and, in the meantime, act as the upstream for security related work (the later might be useful for folks interested in running such a kernel just as the rt branch is preferred by audio engineers).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663094/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2015 19:45 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/663097/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
isn't the grsecurity paxteam stuff an attempt to run a separate kernel security project?<br>
<p>
what would be differetn about what you are proposing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor663112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2015 21:36 UTC (Wed)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/663112/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be something you could actually mention at conferences:)<br>
More seriously, it would be very much like the rt branch where the intent is to upstream everything that can be upstreamed. In order to do this they'd need to have a good relationship with upstream.<br>
Frankly, starting with the pax/grsec patches may not be a bad idea, but the work would need to be separated out into the smallest, useful components so as to make upstreaming more likely (I haven't examined there patches, so this work may already be in place).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor663405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond bug fixing</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2015 3:25 UTC (Fri)
                               by <b>fest3er</b> (guest, #60379)
                              [<a href="/Articles/663405/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seems to me that a lot of what is desired cannot be done efficiently or reliably without hardware support. Like 9-bit memory where that extra bit determines whether or not the other 8 bits are writable. The best we could do today is to leave unwritable page holes in the address space to limit out-of-bounds writing; but this solution still has the resolution of a crayon. And only 64-bit (with 48 bits usable on x86_64) has enough virtual address space to waste.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor663530"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel security: beyond legacy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2015 18:53 UTC (Fri)
                               by <b>igodard</b> (guest, #105242)
                              [<a href="/Articles/663530/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am the chief architect of the Mill CPU architecture, whose threat-mitigation aspects were mentioned several times in the comments here. I'd welcome an invitation to meet, formally or informally, with the Linux security community. While it is true that the Mill is paperware as yet, it is a commercial product en route to hardware. There's no better time than now to explore what Linux could be, and should be, when given a clean-slate legacy-free platform underneath. Once the hardware is frozen it will be too late for your concerns - and ideas - to be reflected. You can reach me as ivan at millcomputing dt com.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/663530/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
