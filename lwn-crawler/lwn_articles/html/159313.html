        <!DOCTYPE html>
        <html lang="en">
        <head><title>On binary drivers and stable interfaces [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/159313/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/158399/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/159313/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>On binary drivers and stable interfaces</h1>
<div class="Byline">[Posted November 9, 2005 by corbet]
               <p>
               </div>
</div>
<div class="ArticleText">
There has recently been a surge of discussion, once again, on whether the
Linux kernel should support closed-source drivers.  The debate was driven,
perhaps, by the <a
href="http://www.kroah.com/log/2005/11/03/">suspicion</a> (later <a
href="http://www.kroah.com/log/2005/11/07/#osdl_gkai2">put to rest</a>)
that OSDL was supporting the creation of a stable binary driver ABI for
Linux.  So perhaps the time has come to review the reasons why the kernel
developers are opposed to closed-source drivers.  Our apologies to all of
you who have seen this before.
<p>

Support for binary-only drivers seems, on the surface, like it could be a
good idea.  Companies could provide Linux drivers for their hardware
without exposing their "valuable intellectual property" to the world.
Users would have a higher degree of assurance that their hardware would
simply work.  All of the current hardware hassles would go away, and
everybody would be happy.  What could be wrong with that?  <p>

One obvious problem is that, with a proprietary driver, a Linux system
loses one of its best characteristics: independence from vendors.  A user
of a proprietary driver depends on the vendor for fixes and updates, but
the vendor is under no obligation to provide them.  Computing hardware has
a notoriously short product life; if the vendor drops driver support when a
product hits the end of its life, there is little that a user can do.  If
the vendor goes out of business, there will be no further support for the
driver.  If the vendor decides to start charging for driver updates, the
user has little option but to pull out the wallet.
If the driver has a bug which affects the stability of the system,
only the vendor can fix it.
<p>

And history shows that proprietary drivers tend to have plenty of bugs.
They are often written by developers with little time and even less
expertise with the Linux kernel.  The code does not go through any sort of
peer review, so obvious problems will persist into the final product.  And,
since only the vendor can fix the driver, bugs can last for a long time. 
<p>

Binary drivers are brittle.
The kernel API can and does change; that aspect of the kernel is not going
away.  Freezing an API would limit the developers' ability to fix poor
interfaces, improve how the kernel works, and remove cruft.  So binary
drivers will always be likely to break between kernel releases, and users
will have to wait for the vendor to get around to catching up with the
current API.
<p>

Linux kernel developers will not help users who have proprietary drivers
loaded into their systems.  That is not because the developers want to be
petty and vengeful (well, perhaps one or two of them do); it is simply that
the developers have no way to track down problems when closed-source code
is running.
<p>

Even if a vendor offers top-quality drivers and support, it is unlikely
that said vendor supports all of the architectures that run Linux.  Freedom
to run on something other than i386 is one of the great advantages of
Linux; proprietary code takes that freedom away.
<p>

Finally, proprietary drivers may constitute copyright infringement.
Certainly some developers feel that kernel modules are derived products of
the kernel itself, and thus required to carry the kernel's (GPL) license.
Whether the module interface constitutes a boundary which the GPL cannot
cross can only, in the end, be determined by the courts.  Until then, every
proprietary driver carries with it a degree of legal uncertainty.
<p>

None of this is new; here's what <a
href="http://lwn.net/1999/0211/a/lt-binary.html">Linus Torvalds said</a>
back in 1999:
<p>
<div class="BigQuote">
	Basically, I want people to know that when they use binary-only
	modules, it's THEIR problem.  I want people to know that in their
	bones, and I want it shouted out from the rooftops.  I want people
	to wake up in a cold sweat every once in a while if they use
	binary-only modules.
</div>
<p>
The alternative to cold sweats is to stick with hardware which comes with
free drivers.  In most areas, finding such hardware is not a challenge.  In
the cases where it can be a problem (video adapters, some wireless network
cards), the solution is not to weigh down the kernel with some sort of
set-in-stone ABI.  As Linux continues to grow in popularity - and
proprietary drivers get harder to write and maintain - recalcitrant vendors
should eventually come around.  That's exactly what has tended to happen
thus far.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Copyright_issues">Copyright issues</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/159313/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor159363"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 2:31 UTC (Thu)
                               by <b>mattdm</b> (subscriber, #18)
                              [<a href="/Articles/159363/">Link</a>] 
      </p>
      
      </div>
      </summary>
      It's also a problem for open source projects with Free but incompatible licenses. The CDDL from the story above this one comes to mind, but it's also a problem for (or "problem with", depending on your point of view) OpenAFS, which is licensed under IBM's IPL.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159363/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor159377"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 4:08 UTC (Thu)
                               by <b>bignose</b> (subscriber, #40)
                              [<a href="/Articles/159377/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Top quality presentation of the issues. Thanks, Jon; this is what I pay my subscription for.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159377/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor159372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 4:31 UTC (Thu)
                               by <b>subhasroy</b> (guest, #325)
                              [<a href="/Articles/159372/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>
The current policy of Linux kernel maintainers is kernel developer friendly perhaps but neither user-friendly nor device driver developer friendly. I think it is impractical and nonscalable to forever carry around numerous historical driver code for all the old and obsolete devices in the kernel. I am not a kernel dev but all the usual arguments against stable ABI/API seem unconvincing to me.<br>
<p>
I wish the kernel devs force themselves to think hard on designing a stable driver model and an API instead of going their merry ways.  A driver model and API designed cleanly and thoughtfully can be published as stable. OS theory and practice is already mature enough to be able to do that. A new stable version can be published every 3 years for example. Such documented stable interface would help both open-source driver authors as well as proprietary driver authors. It should not impede innovation. Of course Linux kernel devs write code for fun and so they don't feel responsible for user's plights as much.<br>
<p>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 5:52 UTC (Thu)
                               by <b>drag</b> (guest, #31333)
                              [<a href="/Articles/159390/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Well it depends what you want.<br>
<p>
Do you only want new kernel releases every 3 years? Because that's pretty much exactly what would happen.<br>
<p>
For instance I like to use Ingor's 'realtime' latency patch. I wouldn't be able to use that if the last 'stable kernel abi' was released around mid-2.4.x. Stuff like that requires modifications to drivers and other related items. I need support for softirqs, changes in DMA access, make everything preemptive, etc etc.<br>
<p>
What about power management or other things like that? It seems very obvious that nowadays that you'd want to have a mechanism for almost all kernel drivers, server-related, network-related, desktop-related, laptop-related, so that they would support more advanced power management. But how practical or plausable was that 3 years ago?  And even right now there are lots of problems that need to be worked out, do you realy want no improvement in suspend-to-ram, suspend-to-sleep, and other items for the next 3 years? Thats what would happen because any improvements or changes in the code related to power management is going to have to have the support of driver-level code.<br>
<p>
And there are other things. Like the more advanced filesystem VFS stuff and generic 802.11x protocol stack. Those things make driver developer's lives much easier and improve performance and stability for everybody, but they wouldn't be avaible to be used in new drivers with a stable ABI. Also not to mention that if you pick a stable ABI you're going to be stuck with the same bad ideas, potentionally obsolete interfaces, and such for the next 3 years.<br>
<p>
But we'll see. OpenSolaris people love stable ABI. They like stable kernel interfaces and have no problem using closed source drivers. Once they figure out the legal hurdles of GPL software on CDDL base then the only real difference between 'Linux' and 'Solaris' will be the kernel and some other low-level stuff. <br>
<p>
Personally I feel that the only real solution for a 'stable abi' is a Microkernel, or at least a very microkernel-like setup were you run modules in userspace seperate from the kernel itself.<br>
<p>
So in the future hopefully it will be easy to select (just picking on debian for right now) Debian/GNU/Solaris or Debian/GNU/Linux or Debian/GNU/Hurd. Then it'll be easy for us to pick 'stable kernel ABI' vs 'rapid developement kernel' vs 'microkernel' and get the 'best tool for the job' irregardless of the actual software we want to run on it. Then the best kernel developement method will win.<br>
<p>
I like Linux. It's fast, generally stable, and improves rapidly. It gives me all sorts of neat stuff to play with, but I have no very special attatchment to it. I do have strong attatchments to the Free software I use everyday, however. If something better comes along and is Free software like Linux, Mozilla, or BSD is then I'll use it.<br>
<p>
(Although actually, I would like to see a specialized Free Software Single-User OS just for simple desktop and embedded applications. Something along the lines of BeOS or Windows 95 (obviously stable of course). Not every system needs to be able to run a entire Unix enterprise-ready enviroment.)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159400"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 6:47 UTC (Thu)
                               by <b>cventers</b> (guest, #31465)
                              [<a href="/Articles/159400/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Just addressing your last point about a single-user OS.   <br>
   <br>
Convex predicted many years ago that the market for specialty computer   <br>
hardware would diminish as technology moved forward.   <br>
   <br>
I see the same thing with software, and I think it's really evident. Why   <br>
have a special wireless-router OS when it can run Linux? Wireless routers   <br>
certainly don't need a full "enterprise UNIX" - VFS, etc...    <br>
   <br>
The stock 2.6 kernel already runs on everything from embedded devices   <br>
like wireless routers, TiVOs, cell phones to huge supercomputers, and   <br>
save for some places it hasn't fully innovated yet, it shines on every   <br>
platform. I'd rather have all the interesting work going into one or a  <br>
few open source operating systems than many specialized ones. By having <br>
one Linux kernel, for example, you have lots and lots of developers <br>
working on one product. Compare that to (and please don't let this turn <br>
into a flame war) BSD, where you have OpenBSD, NetBSD and FreeBSD all <br>
working towards somewhat different goals and quite obviously *not* moving <br>
at the pace of Linux. <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159400/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159629"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2005 2:03 UTC (Fri)
                               by <b>bk</b> (guest, #25617)
                              [<a href="/Articles/159629/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I agree. The single-user OS idea is valid and a good niche to explore, however there's no reason why the Linux kernel can't be part of it. Linux is a *general purpose* kernel, not a Unix operating system in and of itself.<br>
<p>
It's a problem of userspace engineering. Although I'm going to be booed for saying it, Lindows (or whatever they're calling it now) tried to fulfill the ideal of a simple consumer desktop OS and got nothing but skepticism from the majority of people. It was single user (root), simple, largely non-configurable, point-and-click everything and so on. You could argue the *implementation* of the idea was sub-optimal (I would agree), but that says nothing about the merit of the core ideal.<br>
<p>
Perhaps Lindows didn't go far enough; it still exposed enough of its Linux underpinnings that people reviewed it as if it were just another Linux distribution. Linux 2.6 has the facilities to completely replace the classic Unix user/group security scheme, if one had a lot of ambition and venture capital another attempt at a mass market single-user OS might be worthwhile.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159629/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor159474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 13:59 UTC (Thu)
                               by <b>wookey</b> (guest, #5501)
                              [<a href="/Articles/159474/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      That was a generally excellent post (thank you) spoilt by one little thing which I feel compelled to nitpick: There is no such word as 'irregardless'. You mean regardless, or irrespective.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159712"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OT: non-standard, and American, but still a word</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2005 18:08 UTC (Fri)
                               by <b>illtyd</b> (guest, #2124)
                              [<a href="/Articles/159712/">Link</a>] 
      </p>
      
      </div>
      </summary>
      irre'gardless, a. and adv.<br>
Chiefly N. Amer.<br>
<p>
In non-standard or humorous use: regardless.<br>
<p>
[Prob. blend of irrespective and regardless.] <br>
<p>
912 in WENTWORTH Amer. Dial. Dict. 1923 Lit. Digest 17 Feb. 76 Is there such a word as irregardless in the English language? 1934 in WEBSTER (labelled Erron. or Humorous, U.S.). 1938 I. KUHN Assigned to Adventure xxx. 310, I made a grand entrance and suffered immediate and complete obliteration, except on the pay-roll, which functioned automatically to present me with a three-figure cheque every week, irregardless, as Hollywood says. 1939 C. MORLEY Kitty Foyle xxvii. 267 But she can take things in her stride, irregardless what's happened. 1955 Publ. Amer. Dial. Soc. XXIV. 19, I don't think like other people do and irregardless of how much or how little dope would cost me [etc.]. 1970 Current Trends in Linguistics X. 590 She tells the pastor that he should please quit using the word irregardless in his sermons as there is no such word. 1971 M. MCSHANE Man who left Well Enough iv. 96 The sun poured down on Purity irregardless of the fact that it received no welcome.<br>
<p>
from the OED online<br>
(note that quite a few of the textual references are quotes suggesting it isn't a word, but then I'm not a linguistic prescriptivist)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159712/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor159594"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 22:25 UTC (Thu)
                               by <b>hazelsct</b> (guest, #3659)
                              [<a href="/Articles/159594/">Link</a>] 
      </p>
      
      </div>
      </summary>
      There's a lot to pick on in your post, but I'll focus on "historical" hardware.  Tons (thousands of tons?) of perfectly good electronics hardware goes to waste because of dropped software support.  The Linux model prevents that from happening; from PPC Macs which will all be drop-kicked by Apple in a couple of years, to older PCI cards which vendors haven't supported in Windows since NT.<br>
<p>
Where have you seen drivers for old hardware break, or slow down development, under Linux?  Did you report the bug?  I've never seen it, and I have some hardware as old as a 1990 Amiga 2000 and a 1997 Motorola StarMax (603e Power Mac clone) which still run Debian just fine -- long after the vendors dropped support.  (Modern GNOME/KDE desktop performance is even quite good on the StarMax.)  I really don't see the problem for users here, and in fact, freedom from planned obsolescence is a huge benefit *for* Linux users.<br>
<p>
Put somewhat differently, there's far too much electronics scrap in the world as things stand.  Do you really want to accelerate the disposal of lead-tainted hardware -- and prevent schools, developing nations, and poor entrepreneurs from using perfectly good computers -- just because the vendors of new equipment want it to be so?<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159594/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor159386"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Truly Free drivers could use a stable API too</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 5:00 UTC (Thu)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/159386/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      Let's take a really simple situation:<br>
<p>
1) User has Distro 4.0 installed on their machine, which has kernel 2.6.14.<br>
2) Distro 4.0 will never provide an update to any other kernel version, because kernels need to be tested and patched and stabilized and all that effort is going into Distro 4.1 to be released in six months.<br>
3) New hardware comes out, and it has a driver which has been included into the kernel... versions 2.6.16 and onward, anyways.<br>
4) User buys said new hardware but has no way to get it to work without manually downloading, possibly patching, and installing the kernel, and also thereby giving up automatic security updates from the vendor.<br>
5) User is screwed.<br>
<p>
A stable ABI isn't really necessary, I'll note.  A stable API is.  With a stable API, at the very least, a tool like DKMS can do its magic and users can pop in that new GPLd driver for that new hardware, wait a couple seconds while a nice GUI install tool shows a little progress bar while GCC compiles the driver, and then have working hardware.<br>
<p>
There are cases for stable ABIs even with purely GPLd drivers, mostly for installer needing to write to disks that lack drivers for the controller in the install image, but I suppose installers could start offering minimalistic in-memory compiler toolchains to work around that.<br>
<p>
Today's Linux userbase can probably deal with shopping around for hardware that's several months/years old to ensure their bleeding-edge development distribution will support it, but the mainstream market just won't accept that.  I'm not personally sold on the idea that we have to get the mainstream market to accept it, but there are vendors who do think so (Canonical, Linspire, etc.), so for their sake I hope the kernel developers can find some kind of solution.<br>
<p>
I guess another way of putting it is that the kernel needs better support for out-of-tree (even 100% GPL) drivers, because in-tree drivers aren't always available to users running older systems.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159386/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Stable interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 6:43 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/159397/">Link</a>] 
      </p>
      
      </div>
      </summary>
      There's already a stable ABI (for ia32, anyhow): it's called NDIS.  It's not very satisfying.  There's little reason to think a stable API would be much more satisfying, however much it also succeeded in inconveniencing proprietary-driver maintainers.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor159427"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Truly Free drivers could use a stable API too</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 9:06 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/159427/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>You can shorten your tirade to this:</p>

<p>1) New hardware comes out, and it has a driver which has been included into the kernel... versions 2.6.16 and onward, anyways.<br />
2) User is screwed.</p>

<p>Why ? Easy: it's common practice to only support "certified hardware" - and I fail to see why it's so much easier for vendor to certify some alien driver then it is to certify 2.6.16 (or to backport driver to vendor-patched 2.4.14).</p>

<p>This is not a hoax, you know, this is from server on our work:<br />
$ uname -a<br />
Linux mccme.ru 2.6.14 #1 PREEMPT Sat Nov 5 00:00:31 MSK 2005 i686 unknown<br />
$ cat /etc/redhat-release<br />
Red Hat Linux release 6.2 (Zoot)<br />
</p>

<p>I fail to see the need to separate drivers and kernel. <b>Supported</b> drivers - are included in kernel, the way to get new drivers is to install new version of kernel. All other drivers are <b>unsupported</b> and <b>experimental</b> - use on your own risk, but YMMV. 3 years is clearly not enough (system discussed above was installed back in 1997 and while moved two times from one hardware set to another is still in active use). Interfaces between kernel and userspace are stable enough, in-kernel interfaces are in constant flux. This is how it always was, why should we change this ?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159427/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159434"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Truly Free drivers could use a stable API too</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 10:09 UTC (Thu)
                               by <b>simlo</b> (guest, #10866)
                              [<a href="/Articles/159434/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      To install a new kernel you have to reboot - very Windoze like :-(<br>
<p>
I totally agree with the long comment above: What is needed is a "micro-kernel" approach. Drivers should be able to run in user-space. The stable driver API should be in user-space. Hardware vendors can use that to write their close source drivers. That way experiments like Ingo's realtime-patch would still work since no closed source module have access to any kernel internals - only a few system calls. If hardware vendors complain over performance: Release the driver under GPL and move it into the kernel.<br>
If a company do not want to do that, someone could trace what is going on between the driver and the kernel and thus more easily write a free driver.<br>
<p>
I have dropped the smb/cifs drivers in the kernel and use smbnetfs which is build on top of fuse. Now a bug in the smb implementation can't crash my machine. I can even use Kerberos as authentification. Moving stuff into userspace _works_ - at least sometimes. Please, don't go into religious war between microkernel vs. monolitic kernels. As I see it Linux should be a _mixture_ using both techniques where they fit best weighing performance, stability, ease of development, flexibility and licensing issues.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159434/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Truly Free drivers could use a stable API too</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 15:19 UTC (Thu)
                               by <b>kfiles</b> (subscriber, #11628)
                              [<a href="/Articles/159496/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt;  To install a new kernel you have to reboot - very Windoze like :-(</font><br>
<p>
Well, to install a new card you have to reboot too, so it doesn't seem so strange to reboot to a new kernel at the same time. :)<br>
<p>
Now for USB stuff and network protocols, DKMS hotpluggable drivers certainly seem more appropriate. I have installed 3 different versions of the PPTP module via DKMS without rebooting.<br>
<p>
Thanks,<br>
  --kirby<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159536"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">kexec()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 18:26 UTC (Thu)
                               by <b>AnswerGuy</b> (guest, #1256)
                              [<a href="/Articles/159536/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Depending on your precise definition of "reboot" it's also possible with newer kernels to run the kexec wrapper around the kexec() system call<br>
and thus load a new kernel without a firmware reboot.  (Also available<br>
with the old 2-kernel monte patches and utility).<br>
<p>
Of course all user processes are killed through a kexec() ... and all<br>
devices are re-initialized by the new kernel.  Thus this is a "reboot"<br>
in that sense of the term.<br>
<p>
Combine that with some Mosix and Xen like process checkpointing and suspension and you could very well devise a Linux system that would not<br>
have to be "rebooted" in order to switch in a new kernel.<br>
<p>
But it's quibbling to compare the necessity of rebooting into a new kernel<br>
with the infamous reboots required for trivial system settings in earlier versions of MS Windows.  I used to have a poster with a genuine appearing MS Windows GUI dialog that read:<br>
<p>
<p>
                   You have moved your mouse.<br>
   A system reboot is required for this change to take effect. <br>
                              [Ok]<br>
<p>
<p>
JimD<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159536/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor159604"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Truly Free drivers could use a stable API too</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 22:52 UTC (Thu)
                               by <b>Duncan</b> (guest, #6647)
                              [<a href="/Articles/159604/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt;&gt; To install a new kernel you have </font><br>
<font class="QuotedText">&gt;&gt; to reboot - very Windoze like :-( </font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt; Well, to install a new card you </font><br>
<font class="QuotedText">&gt; have to reboot too[.] </font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt; Now for USB stuff and network protocols[...] </font><br>
 <br>
Actually, for hotpluggable stuff like USB, there are kernel modules.  <br>
Kernel modules can be compiled separately, against the codebase used to <br>
compile the running kernel, and can then be modprobed, without rebooting. <br>
 <br>
As for closer to the core hotpluggability, memory and CPUs and the like, <br>
the kernel isn't quite there yet, but support is actively being worked up <br>
and is already there to some degree.  For this sort of support, modules <br>
aren't generally needed, because support for a base level will be compiled <br>
in and additional CPUs or memory use the existing support. <br>
 <br>
Of course, one still has to reboot (or kexec) to a new kernel if switching <br>
to hardware of a different architecture.  However, I don't know if <br>
anything supports that, and the call for such support isn't that great, <br>
anyway, tho it could be useful in certain high availability situations. <br>
 <br>
BTW, the user mode drivers comments someone made are a good idea, as well.  <br>
There's nothing stopping that (tho more integrated/direct kernel support <br>
in some cases would be very useful, think fuse implementation before and <br>
after the kernel support for it), and indeed, the kernel's GPL preamble <br>
specifically states that the restrictions of the GPL do NOT apply to <br>
userspace, so binary drivers are with no controversy completely legal <br>
there (altho there remains disagreement of whether they are /moral/, but <br>
it's the usual controversy of whether /any/ binary-only code is /moral/).  <br>
The problem of course is the performance bite.  It's fine in some cases, <br>
particularly where there's direct kernel support for the userspace drivers <br>
as with fuse, but would suck for something like NVidia's video drivers.  <br>
Very good point made, none-the-less. <br>
 <br>
Duncan <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159604/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159627"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Truly Free drivers could use a stable API too</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2005 1:48 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/159627/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Actually, for hotpluggable stuff like USB, there are kernel modules.
Kernel modules can be compiled separately, against the codebase used to
compile the running kernel, and can then be modprobed, without rebooting. 
</blockquote>
<p>
In this thread, we're talking about unstable APIs.  You probably cannot just separately compile the loadable kernel module against the currently running kernel because the base kernel / device driver LKM interface has changed.

<p>The original poster makes the point that with a stable API, your method would work.  But without one, you need to upgrade your entire kernel in order to use a new loadable kernel module.  And a reboot is just one of the pains of doing that.

<p>User space drivers solves the problem only if we assume that the user space interface is stable like user space interfaces we know today.

      
          <div class="CommentReplyButton">
            <form action="/Articles/159627/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor160569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Truly Free drivers could use a stable API too</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2005 19:11 UTC (Thu)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/160569/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I would say this to be an exellent reason to backup /home/, change to a  <br>
better distro and restore the backup + do a bit of reconfiguring.  <br>
  <br>
Or maybe start using Knoppix and /home/ on a USB-stick...  <br>
  <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/160569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor159411"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 7:50 UTC (Thu)
                               by <b>bangert</b> (subscriber, #28342)
                              [<a href="/Articles/159411/">Link</a>] 
      </p>
      
      </div>
      </summary>
      this issue coming up again and again shows one thing in particular: <br>
vendors are looking at writing drivers for linux (and at an easy way out). <br>
 <br>
good stuff - keep them coming  <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159411/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor159439"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 10:50 UTC (Thu)
                               by <b>Quazatron</b> (guest, #4368)
                              [<a href="/Articles/159439/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      I think that the OSS community does not need the vendors to provide GPL drivers.<br>
<p>
If the vendors want to protect their "valuable intellectual property", all they have to do is to publish the specifications of the product, how to interface with it. The OSS community can then write the GPL driver.<br>
<p>
That way, both sides win. Users get solid drivers, vendors get happy costumers and don't need to spend a cent to suport OSS OSes.<br>
<p>
Of there's that other problem of the drivers that have to load firmware into the devices before working, but I think that could be solved with a combination of userspace firmware loading tools and GLP drivers. That would also require the vendors to allow distribution of the (closed) firmware binaries.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159439/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159443"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 11:33 UTC (Thu)
                               by <b>drag</b> (guest, #31333)
                              [<a href="/Articles/159443/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      The thing about firmware (also known as microcode, which is more familar to some people) is that it's not 'software' so much. It's code alright, but it's not designed to actually do anything except run on hardware's proccessor/dsp/whatever.<br>
<p>
It's completely independant from the OS and any hardware platform. For all practical purposes it is part of the actual hardware on whatever card it's used for. That's why Linux is able to have firmware images in it's source code tree and not violate the GPL, even though if you look at it a certain way the firmware is 'closed source'.<br>
<p>
This is why firmware is different from a 'binary blob' that is used by stuff like madwifi and nvidia drivers. This 'binary blob' is system specific, written in a regular programming language, runs on the regular cpu and is platform specific. For instance I can't run nvidia drivers or madwifi drivers on my powerpc computer, but with firmware it will work fine.<br>
<p>
Realy though... manufacturers should have the firmware on the actual device on non-volitile ram or rom or whatever instead of having the OS load it via the drivers. It's a bit of a hack to save a bit of money, but it makes things more inconvienent for their customers.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159443/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159539"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 18:33 UTC (Thu)
                               by <b>arafel</b> (guest, #18557)
                              [<a href="/Articles/159539/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Leaving aside the rest of it, I think you'll find it's not usually to save memory so much as it is to allow firmware updates to work around bugs, add new features etc. Harder to do that in ROM; they could use flash, I guess...<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159539/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor159648"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2005 4:30 UTC (Fri)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/159648/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Microcode is actually something different -- it is the glue on top of the lowest levels of hardware to create the "native" machine language instruction set.  Some firmware is microcode and some is not.  In many cases, microcode can't be "uploaded" at all (though that isn't the case with Intel CPUs).  Also, nothing actually limits firmware to "just" driving the hardware.  Entire Linux distributions are loaded as firmware in some cases.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159648/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159719"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">what is microcode?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2005 19:33 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/159719/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Thanks for making a point that needed to be made.
<p>
We should clarify though, that people (IBM engineers are the only ones I've heard do it) <em>do</em> often use the term "microcode" to refer to any software built into a device.  They're all wrong.
<p>
Also for the sake of precision, microcode isn't just for CPUs.  Any machine can be driven by microcode -- it's really just a style of software; a class of instruction set.  In days when CPUs were expensive, many machines were implemented with microcode.  I don't know how much microcode is in use today, but I imagine communication processors (e.g. inside a network switch or TCP Offload Engine) get some use out of it go faster than any conventional CPU could go.
<p>
I found a pretty good definition at http://www.webopedia.com/TERM/M/microcode.html .
<p>
"firmware," unfortunately, isn't the right word either.  That just means instructions that are somewhat permanent, as in a ROM chip.  The permanence isn't really what we're talking about here; in fact, I think we're specifically talking about software that has to be loaded every time the device powers up.  I'd just call it "the device control program."

      
          <div class="CommentReplyButton">
            <form action="/Articles/159719/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor159685"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2005 14:22 UTC (Fri)
                               by <b>N0NB</b> (guest, #3407)
                              [<a href="/Articles/159685/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      As I understand it, not all firmware or binary blobs exist solely because a hardware manufacturer is unwilling to release specs for the interface.  As I understand it, in the USA at least, the FCC mandates that wireless devices be tamper proof.  A user is prohibited by law from tweaking such things as RF power, carrier frequency, or the coding protocol.  To get a device certified for sale by the FCC the control interface must be restricted to only those the FCC allows.<br>
<p>
So here we have the Free Software philosophy and US law at odds with each other (not for the first or only time).  How can this be resolved?<br>
<p>
I have two laptops with Atheros based 802.11b/g adapters.  Madwifi works very well even though I must build the package manually on my Debian systems.  The kernel complains of "tainting" when loading the modules and otherwise works flawlessly.<br>
<p>
Do I understand correctly that the binary blob of Madwifi is code the CPU executes?  Yet it still is controlling the Atheros chipset.  I guess the only difference is that it occupies the main memory of my computer rather than being loaded into RAM on the device, correct?  Still, I don't see how the blob affects the kernel directly as it doesn't seem to be a part of it.  The wrapper is definitely connected to the kernel and it talks to the blob.  <br>
<p>
It seems the real issue is the location of the firmware code.  Why is it bad if the proprietary blob happens to occupy main memory and is executed by the CPU, but things are just fine if that same blob were encoded onto the firmware and the kernel is controlling the hardware in the same way?<br>
<p>
I'm not trolling.  I genuinely want to know the difference.  With Madwifi it appears we have a manufacturer working as well as they can with the kernel while adhering to USA law.  I don't think they are necessarily "tainting" the kernel.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159685/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159741"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2005 21:07 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/159741/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      no, the firmware blob is what in older devices would be in the ROM soldered to the device (which nobody object to useing)<br>
<p>
it's not just a simple matter of getting specs of the device to recreate this, and it's definantly not something that is likly to run on any other device (even a nre revision of a card will frequently require a different version of the firmware)<br>
<p>
vendors do this for a couple reasons.<br>
<p>
1. it's cheaper to leave the ROM/Flash off of the card.<br>
<p>
2. it's more flexible as it allows for updates and bugfixes<br>
<p>
as long as the API to talk to the device once the firmware is loaded is documented people should not have much grounds to fuss about it.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159741/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor160251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2005 13:33 UTC (Wed)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/160251/">Link</a>] 
      </p>
      
      </div>
      </summary>
      "no, the firmware blob is what in older devices would be in the ROM soldered to the device (which nobody object to useing)"<br>
<p>
Actually, I object (although in practical terms my objection is mostly meaningless since I use them anyway ;-).<br>
<p>
Let's assume for example that I wanted to conduct covert surveillance of someone else's machine, and I don't want to get caught.  I'd want to be able to bypass any software they might have on the machine that might detect such surveillance, or worse, put a stop to it.  So viruses, worms, and trojans targeted at the main OS won't work--they'll all be caught by the usual rootkit detection methods.<br>
<p>
Solution?  Attack some software that is running in the machine, but not in the OS.  Even better if that software can transparently access some sort of communication device, so I can receive data from it.  Best of all if I don't have to physically modify the target machine to do it.<br>
<p>
What better place to find such software than in a network device?  A wireless card would be even better--with a wired network card, my victim could plug their machine into a LAN where I don't control all of the network devices, and see a bunch of data unexpectedly flowing somewhere with traceroute.  A wireless card could quietly radiate data that I could pick up with a suitable long-range antenna.<br>
<p>
A bus-mastering card has routine access to the entire system RAM through DMA, since Intel CPU's don't have an IOMMU--although in practice I don't see why even having an IOMMU would necessarily be a barrier unless the user also uses a fully virtualized OS.  From a bus-mastering card under my control, I can remotely browse through my victim's RAM and retrieve encryption keys, cleartext, and other goodies.<br>
<p>
Some other devices, like video outputs connected to a CRT, can do a similar function--modulate the hsync signal slightly, and a CRT will broadcast a fairly powerful signal (although it may be so powerful that it resonates audibly in nearby bits of metal).  Disk device drivers can squirrel away data in the HPA or other parts of the disk, then pretend that the disk has failed so the drive can be captured on its way to warranty replacement (even better if the disk itself can participate in the pretense--that way all of the diagnostic utilities--free or proprietary--will present a consistent view of disk failure, until I get the disk and send it my covert-data-retrieval key).  ACPI BIOSes can do some *very* interesting things with proprietary PCI bridge interfaces and various OS callbacks.  The threat is not just from network device firmware.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/160251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor159628"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2005 1:57 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/159628/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
If the vendors want to protect their "valuable intellectual property", all they have to do is to publish the specifications of the product, how to interface with it. The OSS community can then write the GPL driver.
</blockquote>
<p>
So you're assuming the valuable intellectual property is the driver software (copyright)?
<P>
It's not.  The company doesn't sell drivers.  The valuable intellectual property is the trade secrets about how the device works.  Publishing specs would be worse than shipping source code in that respect.

      
          <div class="CommentReplyButton">
            <form action="/Articles/159628/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159809"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 12, 2005 19:38 UTC (Sat)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/159809/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Revealing the programming interface for their device is not the same as publicly documenting how their device works.  The more compliated the device the less similar that information is.<br>
<p>
The only plausible excuse I've heard is that it allows other companies to make work-alikes without having to write their own drivers or have them certified by Microsoft.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159809/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159810"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 12, 2005 20:26 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/159810/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Good point.  I was vague when I said the trade secret in question is "how the device works."  The trade secret is the programming interface, and your explanation is the best I've heard for why the company perceives that secret as valuable.

      
          <div class="CommentReplyButton">
            <form action="/Articles/159810/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor159447"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 11:58 UTC (Thu)
                               by <b>hanwen</b> (subscriber, #4329)
                              [<a href="/Articles/159447/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I think the issue with binary drivers revolves around the wrong point.
The real problem is
<p>
<em>proprietary drivers tend to have plenty of bugs. They are often written by developers with little time and even less expertise with the Linux kernel</em>
<p>
No amount of standards, conventions, ABIs, APIs, etc. is going to solve this. Having a driver ABI just makes it easier for vendors to put crappy drivers up, and add a cute Penguin logo to their packaging.

      
          <div class="CommentReplyButton">
            <form action="/Articles/159447/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 13:12 UTC (Thu)
                               by <b>fenrus</b> (guest, #31654)
                              [<a href="/Articles/159464/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      this wasn't so much about proprietary drivers.. those are illegal anyway in many of the existing cases.<br>
<p>
the point was about drivers shipped in binary form (even though the source may well be available). Some vendors only want to ship "certified" binaries..  even when they are older and more buggy than newer, not yet certified drivers<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor159487"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 15:04 UTC (Thu)
                               by <b>coopj</b> (subscriber, #1139)
                              [<a href="/Articles/159487/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I often have to deal with drivers which while written under GPL, are<br>
very poorly written.  Sometimes they may perform well enough, and<br>
not be very buggy, but they use all kinds of hacks to work with<br>
only one or a few kernel releases, and are almost impossible to<br>
port forward to even minor changes in kernel API and headers.<br>
<p>
Overall I think this is a good thing -- by releasing under GPL<br>
they at least give kernel developers a start and an opportunity<br>
to push a better driver upstream.  However, I wish rather than <br>
producing these hacks they'd put a little more effort into <br>
respecting kernel practices and standards -- in many cases it<br>
would be less work, not more.<br>
<p>
The "you can do anything you want as long as it is GPL" attitude<br>
is very widespread in the corporate culture, and while it is<br>
better than promotion of binary drivers, further education is needed.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159487/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor159448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">It's the Freedom stupid!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 12:20 UTC (Thu)
                               by <b>gallir</b> (guest, #5735)
                              [<a href="/Articles/159448/">Link</a>] 
      </p>
      
      </div>
      </summary>
      OK, nice explaination of why FOSS drivers are desired and better than   <br>
close one. Good legal argument, the kernel is GPL and binary drivers   <br>
could violate the license. It's all nice.   <br>
   <br>
But there is something missing in the article and also obviously ignored   <br>
or misunderstood by some comments' authors.   <br>
   <br>
Why the kernel ios free? why it is GPLed? There are two explicit reasons   <br>
among the community of kernel developers:   <br>
   <br>
1. Those that think, like Linus Torvalds, that FOSS is the way to get   <br>
better OS and software in general. They thinks that developing free   <br>
software in a community is fun.   <br>
   <br>
2. Those that think, like Alan Cox, that proprietary software lead to a   <br>
moral dilemmas and that the free software is THE way to avoid those   <br>
dilemmas and the exclusionary relationships established around   <br>
proprietary software. They tend to think that developing free software in   <br>
general and a OS kernel in particular is also fun.   <br>
   <br>
Why should kernel developers spend efforts to establish an API that limit   <br>
thenselves just for making easy the coexistence of Linux and propietary   <br>
drivers if the latter are a clearly againsts the [two] reasons of the   <br>
very existence of Linux?   <br>
    <br>
Perhaps it's better explained by  <br>
<a href="http://geekz.co.uk/lovesraymond/archive/gpl-3-democracy">http://geekz.co.uk/lovesraymond/archive/gpl-3-democracy</a>  <br>
   <br>
   <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor159510"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">On binary drivers and stable interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 10, 2005 17:14 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/159510/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The kernel's always had one stable ABI, which has gotten only minor if any incompatible changes ever: the interface to userspace. There's also been a push towards moving more and more capabilities into userspace. The USB scanner on the computer I'm sitting at only needs userspace drivers, for example. Jeff Garzik was just talking about block device implementations in userspace, there's discussion of filesystems in userspace, TTYs should be pretty easy, since there aren't so many deadlock possibilities, and most other stuff isn't done with a kernel API, so it's looking good on the regular-userpsace-API side. USB devices can already be handled from userspace, and I think that SCSI devices can mostly be.<br>
<p>
It seems to me that it would be good to have a stable ABI for drivers, where that ABI doesn't let you mess with things you shouldn't, doesn't let you arbitrarily mess with the kernel, and isn't used by in-kernel drivers (although it may be used by open-source projects that want to, like hpoj currently). This obviously won't work well for all types of device, because interrupt latency won't be great, but it should suffice for letting binary drivers exist much like binary executables do. It also means that all of the interaction between the driver and the hardware is going through kernel code, so you don't need to probe the bus to find out exactly what the driver does to make the hardware work.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/159510/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor160027"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Some quibbles</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 14, 2005 23:29 UTC (Mon)
                               by <b>sepreece</b> (guest, #19270)
                              [<a href="/Articles/160027/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I don't have any trouble with agreeing that open-source drivers are preferable. However, I think you overstate some of the issues you raise:<br>
<p>
The statement, "The code does not go through any sort of peer review, so obvious problems will persist into the final product." is generally untrue. Most mature software organizations do peer reviews. I suspect you mean they don't do open, external peer reviews, but the phrase "peer review" has never implied that.<br>
<p>
You say "it is simply that the developers have no way to track down problems when closed-source code is running." However, many OS vendors do, in fact, provide support for customers running code they are unwilling to share with the vendor. It's harder and demands more of the customer, but it's part of the job.<br>
<p>
"Even if a vendor offers top-quality drivers and support, it is unlikely that said vendor supports all of the architectures that run Linux." But, of course, the kernel maintainers don't support all the architectures that run Linux, either. And if you're far enough off the beaten track, you're pretty much on your own anyway. A binary driver at least MAY have a vendor behind it that can offer support. This is particularly the case for those of us in the embedded space.<br>
<p>
In fact, a lot of your comments are general-purpose, desktop-centric. For those of us who build products with Linux inside, hardware changes are largely irrelevant - the hardware will continue to be whatever it ships on. And the API/ABI won't change, either, because we won't let it. This doesn't reduce the validity of your points for desktop and enterprise users, but it does restrict the scope of your claims. We mostly come from using OSs that change infrequently and in big steps and are generally OK with that model, because product cycles can start fresh with whatever is the current release of the OS and, if necessary, do the upmerging needed to make any reused components work on it.<br>
<p>
Again, though, I agree that open-source drivers are preferable...<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/160027/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor160697"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Some quibbles</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2005 16:02 UTC (Fri)
                               by <b>beoba</b> (guest, #16942)
                              [<a href="/Articles/160697/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Minor nit to pick:</p>

<p><i>I suspect you mean they don't do open, external peer reviews, but the phrase "peer review" has never implied that.</i></p>

<p>I dunno about the realm of CS, but in the scientific community, that's exactly what it implies.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/160697/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2005, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
