        <!DOCTYPE html>
        <html lang="en">
        <head><title>The folio pull-request pushback [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/868598/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/868746/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/868598/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The folio pull-request pushback</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 10, 2021</br>
           </div>
When we last <a href="/Articles/864603/">caught up</a> with the <a
href="/Articles/849538/">page folio</a> patch set, it appeared to be on
track to be pulled into the mainline during the 5.15 merge window.  Matthew
Wilcox duly <a 
href="/ml/linux-kernel/YSPwmNNuuQhXNToQ@casper.infradead.org/">sent a pull
request</a> in August to make that happen.  While it is possible that
folios could still end up in 5.15, that has not happened as of this writing
and appears increasingly unlikely.  What we got instead was a lengthy
discussion on the merits of the folio approach.
<p>
The kernel's memory-management subsystem deals with memory in pages, a
fundamental unit that is generally set by the hardware (and is usually 4KB
in size).  These "base" pages are small, though, so the kernel often
needs to deal with memory in larger units.
To do so, it groups sets of physically contiguous pages together
into compound pages, which are made up of a 
head page (the first base page of many in the compound page) and some
number of tail pages.  That leads to a situation where kernel code that is
passed a <tt>struct page</tt> pointer often does not know if it is dealing with a
head or a tail page without explicitly checking.
<p>
It turns out that the "make sure this is a head page" checks add up to a
certain amount of expense in a running kernel.  The use of <tt>struct
page</tt> everywhere also makes kernel APIs unclear — it can be difficult to
know if a given function can cope with tail pages or not.  To address this
problem, Wilcox created the concept of a "folio", which is like a <tt>struct
page</tt> but which is known not to be a tail page.  By changing internal
functions to use folios, Wilcox is able to speed up the kernel and clean up
the API at the same time.  The patch set is huge and intrusive, but it
appeared to have overcome most resistance and be ready to head into the
mainline kernel.
<p>

<h4>Objections</h4>
<p>
Memory-management developer Johannes Weiner quickly <a
href="/ml/linux-kernel/YSQSkSOWtJCE4g8p@cmpxchg.org/">responded</a> to the
request to express his "<q>strong reservations</q>" about the folio
concept.  Over the course of the ensuing discussion he described his objections in
a number of ways, but it seems to come down to a core point: a folio is
just a collection of physically contiguous pages, and that is going to make
it hard to deal with a number of challenges facing memory management.
<p>
To start with, the folio design leaks too much information about memory-management
internals to other users of folios, filesystems in particular.  The
current page-oriented APIs have the same problem, of course, but a massive
API change should, he said, be the time to address that issue.  So Weiner
has <a href="/ml/linux-kernel/YSU7WCYAY+ZRy+Ke@cmpxchg.org/">asked</a>,
more than once, for the creation of a more abstract representation of
memory that would be used in the higher levels of the kernel.  This
abstraction would hide a lot of details; it would also eliminate the
assumption that a folio is a physically contiguous, power-of-two-sized
chunk of memory.
<p>
The assumption of physical contiguity, he <a
href="/ml/linux-kernel/YSjxlNl9jeEX2Yff@cmpxchg.org/">continued</a>, is a
serious problem because the memory-management subsystem has never been good
at allocating larger, contiguous chunks of memory.  At some point
fragmentation takes hold and those larger chunks simply aren't there.
Techniques like page compaction can help to an extent, but that comes at
the cost of excessive allocation latency.  "<q>We've effectively
declared bankruptcy on this already</q>", he said.  There is no point in
adopting folios to represent larger chunks of memory without thinking about
how those chunks will be allocated.
<p>
The other problem, he said, is that the folio concept could make it much
harder to change the memory-management subsystem to use a larger base-page
size.  That change would make the system more efficient in many ways,
including less memory wasted for <tt>page</tt> structures and less CPU time
dedicated to dealing with them.  There is one problem that has kept the
kernel from increasing the base-page size for many years, though: internal
fragmentation.
<p>
When a file's contents (or a portion thereof) are stored in the page cache,
they require a certain number of full pages.  Unix-like systems have a lot
of small files, but even a one-line file will occupy a full page in the
page cache; all of the memory in that page beyond the end of the file is
simply wasted.  Increasing the size of a base page will necessarily
increase the amount of memory lost to this internal fragmentation as well.
In a previous folio discussion, Al Viro <a
href="/ml/linux-fsdevel/YGVUobKUMUtEy1PS@zeniv-ca.linux.org.uk/">did a
quick calculation</a> showing just how much more memory it would take to
keep the kernel source in memory with a larger page size.  A 64KB size
would quadruple the memory used, for example; it is not a small cost.
<p>
For this reason, Weiner <a
href="/ml/linux-kernel/YS+7pzI7pttxtFHT@cmpxchg.org/">argued</a> that the
kernel will need to be able to manage file caching in small units (the
existing 4KB size, for example) even when the memory-management subsystem
moves to a larger base-page size.  In other words, the page cache will need
to be able to work with sub-page units of memory.  A new abstraction for
memory might facilitate that; the current folio concept, being firmly tied
to underlying pages, cannot.
<p>
Wilcox's <a
href="/ml/linux-kernel/YS1PzKLr2AWenbHF@casper.infradead.org/">answer</a>
to this criticism seems to be that it makes little sense in managing memory
in units other than the allocation size.  The way to use larger units in
the memory-management subsystem is thus to allocate compound pages,
represented by folios; if everything in the kernel is using larger pages,
memory will fragment less and those pages will become easier to allocate.
For cases where smaller sizes are needed, such as page-cache entries for
small files, simple base pages could be used.  With careful allocation, the
single pages could be packed together, further avoiding fragmentation.
<p>
Weiner disagreed with that approach, though, saying that it puts the
fragmentation-avoidance problem in the wrong place.  The kernel has two levels of memory
allocation: the page allocator (which deals in full pages and is where
folios are relevant) and the 
slab allocator, which normally deals with smaller units.  They have
different strengths:
<p>
<blockquote class="bq">
	The page allocator is good at cranking out uniform, slightly big
	memory blocks. The slab allocator is good at subdividing those into
	smaller objects, neatly packed and grouped to facilitate contiguous
	reclaim, while providing detailed breakdowns of per-type memory
	usage and internal fragmentation to the user and to kernel
	developers.
</blockquote>
<p>
According to Weiner, Wilcox's approach forces the page allocator to deal
with problems that are currently well solved in the slab allocator.
"<q>As long as this is your ambition with the folio, I'm sorry but it's
a NAK from me</q>".
<p>
<h4>The <i>real</i> problem with folios</h4>
<p>
The ultimate decision on the merging of folios is, of course, up to Linus
Torvalds.  Early in the conversation, he <a
href="/ml/linux-kernel/CAHk-=wgkA=RKJ-vke0EoOUK19Hv1f=47Da6pWAWQZPhjKD6WOg@mail.gmail.com/">wrote
positively</a> about the API improvements, but also noted that the patch
set does bring a lot of churn to the memory-management subsystem.  He
concluded: "<q>So I don't hate the patches. I think they are clever, I
think they are likely worthwhile, but I also certainly don't love
them.</q>"
<p>
He also, however, noted that he wasn't entirely happy with the "folio"
name, thus touching off one of the more predictable dynamics of
kernel-community discussions: when the technical side gets involved and
intractable, it must be time to have an extended debate on naming.  So
David Howells <a
href="/ml/linux-kernel/1957060.1629820467@warthog.procyon.org.uk/">suggested</a>
"sheaf" or "ream".  Torvalds <a
href="/ml/linux-kernel/CAHk-=wip=366HxkJvTfABuPUxwjGsFK4YYMgXNY9VSkJNp=-XA@mail.gmail.com/">favored</a>
something more directly descriptive, like "head_page".  Ted Ts'o <a
href="/ml/linux-kernel/YSVH6k5plj9lrTFe@mit.edu/">thought</a> "mempages"
would work, or <a href="/ml/linux-kernel/YSVQOgrPhwGcUSp4@mit.edu/">maybe</a> 
"pageset".

Nicholas Piggin <a
href="/ml/linux-kernel/1629948817.v8xwzejw2u.astroid@bobo.none/">favored</a>
"cluster" or "superpage".  Given the discussion, Vlastimil Babka <a
href="/ml/linux-kernel/793187d4-835f-a67e-392d-0d88e0a3a4fe@suse.cz/">concluded</a>
that the only suitable name was "pageshed".
<p>
Wilcox has <a
href="/ml/linux-kernel/YSVCAJDYShQke6Sy@casper.infradead.org/">made it
abundantly clear</a> that he doesn't care about the name and will accept
just about anything if that gets the code merged.  He <a
href="/ml/linux-kernel/YSmtjVTqR9%2F4W1aq@casper.infradead.org/">redid the
pull request</a> with everything renamed to "pageset" just to prove that
point.  Needless to say, no real conclusion came from that branch of the
conversation.
<p>
At the end of August, Howells posted <a
href="/ml/linux-kernel/3285174.1630448147@warthog.procyon.org.uk/">a
plea</a> for a quick resolution on the issue; there is a lot of other
pending memory-management work that either depends on the folio patches or
conflicts with them.  He asked:
<p>
<blockquote class="bq">
	Is it possible to take the folios patchset as-is and just live with
	the name, or just take Willy's rename-job (although it hasn't had
	linux-next soak time yet)?  Or is the approach fundamentally flawed
	and in need of redoing?
</blockquote>
<p>
David Hildenbrand <a
href="/ml/linux-kernel/01ed765d-449d-fa5f-2f08-1b74e7f6a9c8@redhat.com/">added</a>
that he would like to see folios move out of linux-next one way or the
other; sooner would be better.
<p>
<h4>Now what?</h4>
<p>
For now, at least, the conversations have wound down.  The 5.15 merge
window is nearing its close and the folio patches have not been pulled.
Chances are that means that folios will, at best, have to wait for another
development cycle.  That said, Torvalds has been known to hold
controversial pulls until — or even past — the end of the merge window,
when he has a 
bit more time to think them through.  So even the closing of the merge
window might not be an indication that the decision has been made.
<p>

The final chapter has not been written here, but either way it seems clear
that there is a lot of work yet to be done in the memory-management
subsystem.  Much of what needs to happen has yet to be designed, much less
written and debugged; that adds some strength to one last <a
href="/ml/linux-kernel/YSQeFPTMn5WpwyAa@casper.infradead.org/">argument</a>
from Wilcox: "<q>The folio patch is here now</q>".  Or, as Babka <a
href="/ml/linux-kernel/6b01d707-3ead-015b-eb36-7e3870248a22@suse.cz/">asked</a>:
"<q>should we just do nothing until somebody turns that hypothetical
future into code and we see whether it works or not?</q>" If folios go
down in flames, work to improve memory-management internals at this level
will have to restart from the beginning, and it's not clear that there is
anybody out there who is ready to take up that challenge.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Folios">Memory management/Folios</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/868598/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor868928"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2021 4:23 UTC (Sat)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/868928/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My recap:<br>
<p>
<a href="https://lore.kernel.org/linux-fsdevel/20210911012324.6vb7tjbxvmpjfhxv@box.shutemov.name/T/#m336504b10569e83ce3370926b4a18bd9bb4f9dfb">https://lore.kernel.org/linux-fsdevel/20210911012324.6vb7...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868928/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor868956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2021 18:29 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/868956/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This seems like it&#x27;s becoming the next BKL... a huge amount of churn, even though the improvements are measurable and significant it&#x27;s going to take some time to convince everyone. Hopefully not as long as that though!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor868961"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2021 19:51 UTC (Sat)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/868961/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ugh. Whatever happened to the idea that the proof is in the code?<br>
<p>
Yes, folios may be imperfect and not-abstracted enough, but they *are* a step in the right direction and further improvements can be built built on top of them.<br>
<p>
I don&#x27;t see an argument that folios block any of the other work that somebody else might be doing (but, or so it seems, currently isn&#x27;t).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868961/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869316"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2021 18:32 UTC (Wed)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/869316/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Yes, folios may be imperfect and not-abstracted enough, but they *are* a step in the right direction and further improvements can be built built on top of them.</font><br>
<font class="QuotedText">&gt; I don&#x27;t see an argument that folios block any of the other work that somebody else might be doing (but, or so it seems, currently isn&#x27;t).</font><br>
<p>
This is the key point IMHO. If some short-term code change makes more difficult some hypothetical, longer term plans, then the long term vision should be detailed enough to at least demonstrate how it conflicts with the short term change. Otherwise it&#x27;s far beyond vaporware.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869316/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor868967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2021 22:38 UTC (Sat)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/868967/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In a previous folio discussion, Al Viro did a quick calculation showing just how much more memory it would take to keep the kernel source in memory with a larger page size. A 64KB size would quadruple the memory used, for example; it is not a small cost.</font><br>
<p>
Is that a realistic cost, though? 64KB would be 4832MB(? *); if you&#x27;re someone running grep over the kernel source repeatedly, you&#x27;ve likely got 5GB to spare. A kernel compilation is going to be a lot messier, with a lot more temporary files and executables fighting for file cache. I&#x27;ve got about 3000 files open on this system according to lsof, which is far less than the 71000 kernel source files. That&#x27;s an additional 192MB if each of them adds 64KB, which wouldn&#x27;t be noticed.<br>
<p>
There&#x27;s a lot more to be studied, but I&#x27;m not sure that quick calculation reflects anything that really matters.<br>
<p>
* Al Viro wrote &quot;64Kb		4832Mb&quot;; since he starts at 4Kb and everyone else says the base page is 4KB, not 4Kb, I assume that&#x27;s careless capitalization.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor868986"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2021 11:40 UTC (Sun)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/868986/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; if you&#x27;re someone running grep over the kernel source repeatedly, you&#x27;ve likely got 5GB to spare</font><br>
<p>
I fail to find the logic in this?<br>
<p>
But to take another case: What if I want to read my email, which is on Maildir, and would like the mailbox to be in cache so that I can open it quickly? Is it reasonable to waste gigabytes of RAM (which I would prefer to use on opening a few extra tabs in my browser…) on 64 kB pages for each email?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868986/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869017"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2021 22:37 UTC (Sun)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/869017/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What if I want to read my email, which is on Maildir, and would like the mailbox to be in cache so that I can open it quickly? Is it reasonable to waste gigabytes of RAM (which I would prefer to use on opening a few extra tabs in my browser…) on 64 kB pages for each email?</font><br>
<p>
Catting a small, cold file to Konsole with time -v yielded &quot;Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.01&quot;. Dumping a 60k cold file to Konsole with time -v yielded &quot;Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.26&quot;. In both cases, this was off hard drive. I&#x27;m going to say that demanding your entire mailbox with thousands of emails to be in cache so you can save hundredths of a second in opening old emails is unreasonable, and demanding the entire kernel for everyone to be optimized for that occurrence is even more unreasonable.<br>
<p>
What if the reduced kernel memory and reduced data handling by the kernel for 64KB pages speeds up opening new tabs in your browser and switching between them? I&#x27;d like hard numbers on a variety of real-life situations, not handwaves based off contrived situations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869017/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869044"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2021 9:32 UTC (Mon)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/869044/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Opening old emails? Remember, I&#x27;m talking about opening a _mailbox_, reading every single email to check its headers. (No, not all systems can maintain a separate header cache.)<br>
<p>
Also, please note that when you dismiss others&#x27; (real!) use cases as “handwaving based off contrived situations”, it does not come across as the most friendly way to make your case. At the very least, it&#x27;s no less handwavy than the original assertion that you&#x27;ll surely have 5 GB of free RAM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869044/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2021 22:37 UTC (Mon)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/869141/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If your system does not have a separate header cache, there&#x27;s a problem you might like to fix. When opening the mailbox up cold, you&#x27;re going to be paying that cost anyway. Once you&#x27;ve opened up the mailbox, your mail program certainly can and should store the headers in memory (much more reliable than the kernel cache, and maybe even noticeably faster), and possibly should store the messages in memory, to avoid all this cache mess to begin with. (It&#x27;ll cost less memory than storing them in kernel cache, even with 4KB pages.)<br>
<p>
<font class="QuotedText">&gt; it&#x27;s no less handwavy than the original assertion that you&#x27;ll surely have 5 GB of free RAM.</font><br>
<p>
Kernel programmers are well-paid professionals. They don&#x27;t have used Dell Optiplexes as their main PC; their programming boxes are almost certainly high-end hardware. $1000 will buy you a computer with 16GB. There&#x27;s a lot of websites that tell you 8 GB is fine for programming, but generally kernel programmers aren&#x27;t going to need or want to skimp out on their hardware. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor869127"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2021 21:50 UTC (Mon)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/869127/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok, but think about all kinds of server use cases with many small files.  They don’t necessarily have “spare” RAM laying around.  They’re specced to the system.  This is a truly huge overhead in a lot of real world cases which would cost a lot of real world money.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869127/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2021 23:32 UTC (Mon)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/869143/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How many small files are actually stored in cache? Conf files are generally read and abandoned. If it is a gain, then major server operators would be quick to code systems to store data in larger data structures; even now, tossing a bunch of small files into a database could save space and time.<br>
<p>
I&#x27;m sure increasing the page size to 64KB would be an improvement in some cases, and hurt others. I just think that storing every single kernel file in cache is a bad comparison. (If nothing else, if grepping the entire kernel is something you&#x27;re actually doing frequently, you&#x27;re doing it wrong; efficient searching via precomputed indexes has been around for 50 years, or if we ignore the electronic computer part, for centuries.) There should be some sort of measurement on real situations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2021 5:28 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/869157/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; How many small files are actually stored in cache? Conf files are generally read and abandoned. If it is a gain, then major server operators would be quick to code systems to store data in larger data structures; even now, tossing a bunch of small files into a database could save space and time.</font><br>
<p>
Hasn&#x27;t the kernel just added a &quot;read and abandon&quot; facility? User space may read and abandon, but the kernel caches EVERYTHING by default aiui. The cost of that is measurable, and big.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869824"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2021 0:37 UTC (Mon)
                               by <b>jwarnica</b> (subscriber, #27492)
                              [<a href="/Articles/869824/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Kernel will cache everything, but discard LRU when needed.<br>
<p>
A config file read, parsed, stored in working memory, and closed, it being cached it&#x27;s a &quot;waste&quot; of cache memory either way.<br>
<p>
It&#x27;s only painful if caching that new file displaces an older cached file which will be read again in some human meaningful time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869824/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor869173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2021 11:05 UTC (Tue)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/869173/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A computer is done for general purpose. Dismissing any use case that needs opening a large number of small file is a weird way to answer the concern. The kernel files are representative of what most devs would work with: small files. Is it representative of all users and all workloads? Certainly not but it represents an existing scenario and quadrupling the memory consumed is problematic.<br>
<p>
Many files smaller than 64KiB ar me opened by the system at some point and stored in cache (all configuration files, log files ...). Only in /etc I have 2500 files smaller than 8KiB and I&#x27;m pretty sure most of them have been opened at one point and cached by the kernel. Same for files under $HOME/.config and other dotted directories.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor869472"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2021 9:31 UTC (Fri)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/869472/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I did some measurements a while ago, using linux-5.4 at the time to see the effect of additional<br>
memory usage of the different page sizes. I tried running linux-5.14-rc1+folio as well, and<br>
put the results in a graph:<br>
<p>
<a href="https://docs.google.com/spreadsheets/d/1Y-eeXEHr8Tud2ul4iApn6hLEQoMsl3Bsud-vlW3V2t8/edit?usp=sharing">https://docs.google.com/spreadsheets/d/1Y-eeXEHr8Tud2ul4i...</a><br>
<p>
I did this on a 16-Core  Arm machine that supports 4KB, 16KB and 64KB pages, giving 4GB to a virtual<br>
machine, and pinning down part of that memory before building a fixed kernel source tree.<br>
<p>
Since the compiler uses mostly contiguous anonymous memory, the effect of the page size is not as strong as when considering only the page cache that wastes more memory, but you can definitely see that the 64KB kernel needs around double the RAM compared to a 4KB kernel, and it also suffers more when it does start paging. The 4KB kernel seems to work much better when it&#x27;s already deep into swap, while the 64KB kernel gets unusable pretty much instantly as soon as it runs out of free pages.<br>
<p>
The 16KB page kernel works better than expected -- not only is it almost as fast as the 64KB version when it has enough RAM available, it also copes with out-of-memory conditions aslmost as well as the 4KB version.<br>
<p>
The folio-enabled kernel also seems to have a problem with running into swap, but I don&#x27;t know if that&#x27;s a result of something different in the folio patches, or a difference between the old 5.4 kernel and the new 5.14-rc1 version. If I find the time to run another test with 5.14-rc1 without the folio patches, I&#x27;ll add the data to the graph.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869472/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor871099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2021 16:13 UTC (Tue)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/871099/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Okay, what if I have 32GB of RAM and I want to grep a bigger project that was using 30GB before? You can&#x27;t really justify a 300% overhead(!!!) by saying it&#x27;s okay on one particular workload.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor870094"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2021 8:22 UTC (Thu)
                               by <b>SomeOtherGuy</b> (guest, #151918)
                              [<a href="/Articles/870094/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There&#x27;s a lot of focus on the name here, this reference is often overused but I think you guys are having a bit of a &quot;bikeshed&quot; moment - the name is the most trivial part of this. <br>
<p>
This is quite a common situation, so much so the object-orientated analogy is common (but slightly altered)<br>
<p>
We have a Bird class, later Birds gain the ability to fly, our Penguin subclass can&#x27;t fly - we have to handle that. <br>
<p>
At some point the sane action is to create a FlyingBird subclass and stick your flying birds there and leave Penguin under the now-implied-flightless Bird base class, or (which you can do here as structs don&#x27;t inherit) have a FlightlessBird name we put Penguins under.<br>
<p>
You have a third option: both, you now have FlightlessBird and FlyingBird and the implied-property-of-Bird (whichever it was, flightless or not) is now attached to the name. <br>
<p>
That&#x27;s it, those are your options up to name isomorphism - bickering about FlyingBird vs flightful_bird doesn&#x27;t change what&#x27;s going on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/870094/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872406"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The folio pull-request pushback</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 9:00 UTC (Sun)
                               by <b>scientes</b> (guest, #83068)
                              [<a href="/Articles/872406/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe the TLB could be put *after* the cache, by using globally addressable memory, and having ranged memory permissions for such large slabs of memory, instead of paged memory be the only option (you can still defrag by putting a TLB and MMU *behind* the cache, which like an IOMMU has minimal overhead). We have 64-bit of address space now—there is no shortage of address space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872406/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
