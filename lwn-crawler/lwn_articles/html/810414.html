        <!DOCTYPE html>
        <html lang="en">
        <head><title>The rapid growth of io_uring [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/810414/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/810397/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/810414/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The rapid growth of io_uring</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 24, 2020</br>
           </div>
One year ago, the <a href="/Articles/776703/">io_uring subsystem</a> did
not exist in the mainline kernel; it showed up in the 5.1 release in May
2019.  At its core, io_uring is a mechanism for performing asynchronous
I/O, but it has been steadily growing beyond that use case and adding new
capabilities.  Herein we catch up with the current state of io_uring, where
it is headed, and an interesting question or two that will come up along
the way.
<p>
Classic Unix I/O is inherently synchronous.  As far as an application is
concerned, an operation is complete once a system call like <tt>read()</tt>
or <tt>write()</tt> returns, even if some processing may continue behind
its back.  There is no way to launch an operation asynchronously and wait
for its completion at some future time — a feature that many other
operating systems had for many years before Unix was created.
<p>
In the Linux world, this gap was eventually filled with the <a
href="http://man7.org/linux/man-pages/man2/io_setup.2.html">asynchronous 
I/O (AIO) subsystem</a>, but that solution has never proved to be entirely
satisfactory.  AIO requires specific support at the lower levels, so it
never worked well outside of a couple of core use cases (direct file I/O
and networking).  Over the years there have been recurring conversations
about better ways to solve the asynchronous-I/O problem.  Various proposals
with names like <a href="/Articles/219954/">fibrils</a>, <a
href="/Articles/223899/">threadlets</a>, <a
href="/Articles/236206/">syslets</a>, <a
href="/Articles/316806/">acall</a>, and <a
href="/Articles/671649/">work-queue-based AIO</a> have been discussed, but
none have made it into the mainline.
<p>
The latest attempt in that series is io_uring, which <i>did</i> manage to
get merged.  Unlike its predecessors, io_uring is built around a ring
buffer in memory shared between user space and the kernel; that allows the
submission of operations (and collecting the results) without the need to
call into the kernel in many cases.  The interface is somewhat complex, but
for many applications that perform massive amounts of I/O, that complexity
is paid back in increased performance.  See <a
href="https://kernel.dk/io_uring.pdf">this document [PDF]</a> for a
detailed description of the io_uring API.  Use of this API can be somewhat
simplified with the <a href="https://github.com/axboe/liburing">liburing
library</a>.
<p>
<h4>What io_uring can do</h4>
<p>
Every entry placed into the io_uring submission ring carries an opcode
telling the kernel what is to be done.  When io_uring was added to the 5.1
kernel, the available opcodes were:
<p>
<blockquote>
<dl>
<dt><tt>IORING_OP_NOP</tt></dt>
<dd>This operation does nothing at all; the benefits of doing nothing
    asynchronously are minimal, but sometimes a placeholder is useful.
</dd>
<p>
<dt><tt>IORING_OP_READV</tt></dt>
<dt><tt>IORING_OP_WRITEV</tt></dt>
<dd>Submit a <a
href="http://man7.org/linux/man-pages/man2/readv.2.html"><tt>readv()</tt> or
<tt>write()</tt></a> operation — the core purpose for io_uring in 
    most settings.
</dd>
<p>
<dt><tt>IORING_OP_READ_FIXED</tt></dt>
<dt><tt>IORING_OP_WRITE_FIXED</tt></dt>
<dd>These opcodes also submit I/O operations, but they use "registered"
    buffers that are already mapped into the kernel, reducing the amount of
    total overhead.
</dd>
<p>
<dt><tt>IORING_OP_FSYNC</tt></dt>
<dd>Issue an <a
    href="http://man7.org/linux/man-pages/man2/fsync.2.html"><tt>fsync()</tt></a>
    call — asynchronous synchronization, in other words.
</dd>
<p>
<dt><tt>IORING_OP_POLL_ADD</tt></dt>
<dt><tt>IORING_OP_POLL_REMOVE</tt></dt>
<dd><tt>IORING_OP_POLL_ADD</tt> will perform a <a
    href="http://man7.org/linux/man-pages/man2/poll.2.html"><tt>poll()</tt></a>
    operation on
    a set of file descriptors.  It's a one-shot operation that must be
    resubmitted after it completes; it can be explicitly canceled with
    <tt>IORING_OP_POLL_REMOVE</tt>.  Polling this way can be used to
    asynchronously keep an eye on a set of file descriptors.  The io_uring
    subsystem also supports a concept of dependencies between operations; a
    poll could be used to hold off on issuing another operation until the
    underlying file descriptor is ready for it.
</dd>
</dl>
</blockquote>
<p>
That functionality was enough to drive some significant interest in
io_uring; its creator, Jens Axboe, could have stopped there and taken a
break for a while.  That, however, is not what happened.  Since the 5.1
release, the following operations have been added:
<p>
<blockquote>
<dl>
<dt><tt>IORING_OP_SYNC_FILE_RANGE</tt> (5.2)</dt>
<dd>Perform a <a
href="http://man7.org/linux/man-pages/man2/sync_file_range.2.html"><tt>sync_file_range()</tt></a>
    call — essentially an enhancement of the existing <tt>fsync()</tt>
    support, though without all of the guarantees of <tt>fsync()</tt>.
</dd>
<p>

<dt><tt>IORING_OP_SENDMSG</tt> (5.3)</dt>
<dt><tt>IORING_OP_RECVMSG</tt> (5.3)</dt>
<dd>These operations support the asynchronous sending and receiving of
    packets over the network with <a
    href="http://man7.org/linux/man-pages/man3/sendmsg.3p.html"><tt>sendmsg()</tt></a>
    and <a
    href="http://man7.org/linux/man-pages/man3/recvmsg.3p.html"><tt>recvmsg()</tt></a>. 
</dd>
<p>
<dt><tt>IORING_OP_TIMEOUT</tt> (5.4)</dt>
<dt><tt>IORING_OP_TIMEOUT_REMOVE</tt> (5.5)</dt>
<dd>This operation completes after a given period of time, as measured
    either in seconds or number of completed io_uring operations.  It is a way of
    forcing a waiting application to wake up even if it would otherwise
    continue sleeping for more completions.
</dd>
<p>
<dt><tt>IORING_OP_ACCEPT</tt> (5.5)</dt>
<dt><tt>IORING_OP_CONNECT</tt> (5.5)</dt>
<dd>Accept a connection on a socket, or initiate a connection to
    a remote peer.</dd>
<p>
<dt><tt>IORING_OP_ASYNC_CANCEL</tt> (5.5)</dt>
<dd>Attempt to cancel an operation that is currently in flight.  Whether
    this attempt will succeed depends on the type of operation and how far
    along it is.
</dd>
<p>
<dt><tt>IORING_OP_LINK_TIMEOUT</tt> (5.5)</dt>
<dd>Create a timeout linked to a specific operation in the ring.  Should
    that operation still be outstanding when the timeout happens, the
    kernel will attempt to cancel the operation.  If, instead, the
    operation completes first, the timeout will be canceled. 
</dd>
</dl>
</blockquote>
<p>
That is where the io_uring interface will stand as of the final 5.5 kernel
release.
<p>
<h4>Coming soon</h4>
<p>
The development of io_uring is far from complete.  To see
that, one need merely look into linux-next to see what is queued for 5.6:
<p>
<blockquote>
<dl>

<dt><tt>IORING_OP_FALLOCATE</tt></dt>
<dd>Manipulate the blocks allocated for a file using <a
href="http://man7.org/linux/man-pages/man2/fallocate.2.html"><tt>fallocate()</tt></a>
</dd>
<p>
<dt><tt>IORING_OP_OPENAT</tt></dt>
<dt><tt>IORING_OP_OPENAT2</tt></dt>
<dt><tt>IORING_OP_CLOSE</tt></dt>
<dd>Open and close files</dd>
<p>
<dt><tt>IORING_OP_FILES_UPDATE</tt></dt>
<dd>Frequently used files can be registered with io_uring for faster
    access; this command is a way of (asynchronously) adding files to the
    list (or removing them from the list).
</dd>
<p>
<dt><tt>IORING_OP_STATX</tt></dt>
<dd>Query information about a file using <a
href="http://man7.org/linux/man-pages/man2/statx.2.html"><tt>statx()</tt></a>.
</dd>
<p>
<dt><tt>IORING_OP_READ</tt></dt>
<dt><tt>IORING_OP_WRITE</tt></dt>
<dd>These are like <tt>IORING_OP_READV</tt> and <tt>IORING_OP_WRITEV</tt>,
but they use the simpler interface that can only handle a single buffer.
</dd>
<p>
<dt><tt>IORING_OP_FADVISE</tt></dt>
<dt><tt>IORING_OP_MADVISE</tt></dt>
<dd>Perform the <a
href="http://man7.org/linux/man-pages/man2/posix_fadvise.2.html"><tt>posix_fadvise()</tt></a> and <a
href="http://man7.org/linux/man-pages/man2/madvise.2.html"><tt>madvise()</tt></a>
system calls asynchronously.
</dd>
<p>
<dt><tt>IORING_OP_SEND</tt></dt>
<dt><tt>IORING_OP_RECV</tt></dt>
<dd>Send and receive network data.</dd>
<p>
<dt><tt>IORING_OP_EPOLL_CTL</tt></dt>
<dd>Perform operations on epoll file-descriptor sets with <a
href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html"><tt>epoll_ctl()</tt></a>
</dd>
</dl>
</blockquote>
<p>
What will happen after 5.6 remains to be seen.  There was <a
href="/ml/io-uring/f77ac379ddb6a67c3ac6a9dc54430142ead07c6f.1576336565.git.asml.silence@gmail.com/">an
attempt</a> to add <a
href="http://man7.org/linux/man-pages/man2/ioctl.2.html"><tt>ioctl()</tt></a>
support, but that was <a
href="/ml/io-uring/CAG48ez0N_b+kjbddhHe+BUvSnOSvpm1vdfQ9cv+cgTLuCMXqug@mail.gmail.com/">shot
down</a> due to reliability and security concerns.  Axboe has, however, <a
href="/ml/io-uring/1f995281-4a56-a7de-d20b-14b0f64536c0@kernel.dk/">outlined</a>
a way in which support for specific <tt>ioctl()</tt> operations could be
added on a case-by-case basis.  One can imagine that, for example, the
media subsystem, which supports a number of performance-sensitive
<tt>ioctl()</tt> operations, would benefit from this mechanism.
<p>
There is also <a
href="/ml/io-uring/cover.1579649589.git.asml.silence@gmail.com/">an early
patch set</a> adding support for <a
href="http://man7.org/linux/man-pages/man2/splice.2.html"><tt>splice()</tt></a>.
<p>
<h4>An asynchronous world</h4>
<p>
All told, it would appear that io_uring is quickly growing the sort of
capabilities that were envisioned many years ago when the developers were
talking about thread-based asynchronous mechanisms.  The desire to avoid
blocking in event loops is strong; it seems likely that this API will
continue to grow until a wide range of tasks can be performed with almost
no risk of blocking at all.  Along the way, though, there may be a couple
of interesting issues to deal with.
<p>
One of those is that the field for io_uring commands is only eight bits
wide, meaning that up to 256 opcodes can be defined.  As of 5.6, 30 opcodes
will exist, so there is still plenty of room for growth.  There are more
than 256 system calls implemented in Linux, though.  If io_uring were to
grow to the point where it supported most of them, that space would run
out.
<p>
A different issue was <a
href="/ml/linux-fsdevel/d4d3fa40-1c59-a48a-533b-c8b221e0f221@samba.org/">raised</a>
by Stefan Metzmacher.  Dependencies between commands are supported by
io_uring now, so it is possible to hold the initiation of an operation
until some previous operation has completed.  What is rather more difficult
is moving information between operations.  In Metzmacher's case, he would
like to call <a
href="http://man7.org/linux/man-pages/man2/open.2.html"><tt>openat()</tt></a>
asynchronously, then submit I/O operations 
on the resulting file descriptor without waiting for the open to complete.
<p>
It <a
href="/ml/linux-fsdevel/7324bbb7-8f7b-c0c6-6a45-48b8b77c4be8@kernel.dk/">turns
out</a> that there is a plan for this: inevitably it calls for ... wait for
it ... using BPF to make the connection from one operation to the next.
The ability to run bits of code in the kernel at appropriate places in a
chain of asynchronous operations would clearly open up a number of
interesting new possibilities.
"<q>There's a lot of potential there</q>", Axboe said.  Indeed, one
can imagine a point where an entire program is placed into a ring by a
small C "driver", then mostly allowed to run on its own.
<p>
There is one potential hitch here, though, in that io_uring is an unprivileged
interface; any necessary privilege checks are performed on the actual operations
performed.  But the plans to make BPF safe for unprivileged users <a
href="/Articles/796328/">have been sidelined</a>, with explicit statements
that unprivileged use will not be supported in the future.  That could make
BPF hard to use with io_uring.  There may be plans for how to resolve this
issue lurking deep within Facebook, but they have not yet found their way
onto the public lists.  It appears that the BPF topic in general <a
href="/ml/linux-fsdevel/e25f7a09-96b2-2288-4777-9f728a8b2c23@gmail.com/">will
be discussed</a> at the 2020 Linux Storage, Filesystem, and
Memory-Management Summit.

<p>
In summary, though, io_uring appears to be on a roll with only a relatively
small set of growing pains.  It will be interesting to see how much more
functionality finds its way into this subsystem in the coming releases.
Recent history suggests that the growth of io_uring will not be slowing
down anytime soon.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Asynchronous_IO">Asynchronous I/O</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#io_uring">io_uring</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/810414/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor810476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2020 18:26 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/810476/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BPF == Biggest Possible Fuckup.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor810482"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2020 20:16 UTC (Fri)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/810482/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When can we get asynchronous sendfile()? :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810482/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor810491"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2020 21:51 UTC (Fri)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/810491/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As soon as the splice stuff is integrated, you'll have just that. When I initially wrote splice, at the same time I turned sendfile() into a simple wrapper around it. So if you have splice, you have sendfile as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810491/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor868131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2021 12:36 UTC (Thu)
                               by <b>awkravchuk</b> (guest, #154070)
                              [<a href="/Articles/868131/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How exactly did you do that for the general case? splice(2) requires that one of the fds is a pipe, so it looks like sending e.g. disk file to TCP socket wouldn&#x27;t be possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor868160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2021 14:02 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/868160/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>There's special cases in the kernel (but not, it appears, in the manpage) to allow file to anything splicing by allocating a secret internal pipe. Look at <a href="https://lxr.missinglinkelectronics.com/linux/fs/splice.c#L893">fs/splice.c, function splice_direct_to_actor</a> for the code.


      
          <div class="CommentReplyButton">
            <form action="/Articles/868160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor868182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2021 16:49 UTC (Thu)
                               by <b>awkravchuk</b> (guest, #154070)
                              [<a href="/Articles/868182/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great stuff, thanks!<br>
Is there a way to use this from userspace? I&#x27;m not an actual kernel hacker, just trying io_uring out :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor868193"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2021 17:14 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/868193/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>Looks like no way to use this from userspace.
<p>However, in the <tt>io_uring</tt> case, you should be able to build a splice-based sendfile yourself using a pipe you create via <tt>pipe(2)</tt> to act as the buffer. Or do similar via fixed buffers in the ring instead of splice.


      
          <div class="CommentReplyButton">
            <form action="/Articles/868193/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor868201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2021 17:40 UTC (Thu)
                               by <b>awkravchuk</b> (guest, #154070)
                              [<a href="/Articles/868201/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s what I thought. Thank you for clarification!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor949980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 4:03 UTC (Fri)
                               by <b>leo60228</b> (guest, #167812)
                              [<a href="/Articles/949980/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This doesn't work if you want to have multiple calls with different offsets in flight at once, though, does it? If there's a partial read/write, the next splice would use the wrong data, and I can't think of a way to avoid that without only having one splice in flight at a time (which kind of defeats the point, at least for my application).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/949980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950021"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 12:07 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/950021/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>If you're building your own equivalent of this trick in io_uring, you can have multiple splices in flight at once; you'd be using two linked SQEs, one of which splices input into the pipe, and the other of which splices the pipe into the output. Offset tracking is in your hands at this point.
<p>The kernel's trick is simply to create the pipe for you if you don't provide one, and you're doing sync I/O from a file to something not-a-file.


      
          <div class="CommentReplyButton">
            <form action="/Articles/950021/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 3, 2023 22:19 UTC (Fri)
                               by <b>leo60228</b> (guest, #167812)
                              [<a href="/Articles/950157/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I tried implementing that. What I mean is that, for example, if you were trying to copy 0x8000 byte chunks at a time, and the first SQE splicing from the input file to the pipe only copied 0x4000 bytes, the linked SQE would still try to read 0x8000 bytes from the pipe and potentially get the wrong data. Additionally, I'm not sure there's a guarantee that these linked SQEs would be atomic (i.e. if SQE A was linked to SQE B, and SQE C was linked to SQE D, the order A, C, B, D could be allowed and result in data being written to the wrong offsets in the output).<br>
<p>
Thinking about it more, I suppose this could be solved by creating a large number of pipes, and making sure that no two SQEs using the same pipe are in flight at the same time. I'm concerned that having many pipes could result in its own performance issues, but it'd probably be fine...?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor950271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2023 10:12 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/950271/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>You don't have one pipe for all splices; you have one pipe per splice. If the first SQE copies 0x4000 bytes, then the linked SQE can only copy 0x4000 bytes out of the pipe, because there's only 0x4000 bytes in there to copy out. This is exactly what the kernel trick is - create a temporary pipe for the splice to use, so that you're always splicing in and out of pipes.


      
          <div class="CommentReplyButton">
            <form action="/Articles/950271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor810490"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2020 21:54 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/810490/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>If <tt>splice()</tt> is wired in, then you have all the components you need to implement <tt>sendfile()</tt> as a user of io_uring :-)
      
          <div class="CommentReplyButton">
            <form action="/Articles/810490/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor810700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2020 10:12 UTC (Tue)
                               by <b>isilence</b> (subscriber, #117961)
                              [<a href="/Articles/810700/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I expect it to be done for-5.7<br>
Nothing really difficult, I just need to address a couple of issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor810495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2020 0:23 UTC (Sat)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/810495/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In Metzmacher's case, he would like to call openat() asynchronously, then submit I/O operations on the resulting file descriptor without waiting for the open to complete. </font><br>
<p>
The X Window System solved this decades ago: applications specify the ID they want when creating an object in X, for precisely this reason.<br>
<p>
Let the application specify the file descriptor it wants to open, so that it knows what fd number it'll get, and can submit subsequent operations on that file descriptor in the same queue.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor810978"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2020 12:05 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/810978/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What if that fd is already in use?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810978/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor811024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2020 14:39 UTC (Thu)
                               by <b>Baughn</b> (subscriber, #124425)
                              [<a href="/Articles/811024/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The call fails, and you get to fix your code. The IDs should be per-process.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor811120"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2020 23:51 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/811120/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fix your code? But...<br>
<p>
Even per-process, how do you know which fds are free?<br>
<p>
Are you suggesting that you should enumerate all the fds currently in use by your program, and then make sure to pick one that you know isn't being used, and hope that another thread doesn't race you to getting it anyway?<br>
<p>
Sorry, I think I'm missing an important part of the puzzle somewhere here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811120/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor811156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2020 10:39 UTC (Fri)
                               by <b>klempner</b> (subscriber, #69940)
                              [<a href="/Articles/811156/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You would presumably use an allocator for this, perhaps one that is part of libc.<br>
<p>
That allocator wouldn't allocate the same fd twice without a deallocate and could be made threadsafe so you wouldn't have race issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor811707"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2020 17:26 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/811707/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Even per-process, how do you know which fds are free?</font><br>
<p>
Run FORTRAN???<br>
<p>
That's the way that always worked :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811707/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor811791"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2020 8:08 UTC (Fri)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/811791/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Mmm, let's add a "allocate_fd" system call, so now first you allocate/reserve a fd (very fast, you could even preallocate them), then you provide it to the different system calls .. which now have to add additional checks of course.<br>
No way, this will happen but that's an interesting WHAT-IF design change.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811791/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor811830"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2020 14:41 UTC (Fri)
                               by <b>canoon</b> (guest, #109743)
                              [<a href="/Articles/811830/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All you really need is a range that is reserved for user space allocation. It of course doesn't solve issues around reusing data between requests though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811830/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor810496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 25, 2020 1:14 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/810496/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Classic Unix I/O is inherently synchronous. As far as an application is concerned, an operation is complete once a system call like read() or write() returns, even if some processing may continue behind its back. There is no way to launch an operation asynchronously and wait for its completion at some future time — a feature that many other operating systems had for many years before Unix was created.
</blockquote>

<p>
Unix historically didn't have asynchronous disk I/O, and this effected the architecture of subsystems and drivers. Linux still doesn't have asynchronous buffered disk I/O. All you're doing is offloading the operation to a thread pool in the kernel, which performs the operation synchronously, rather than a thread pool in user land.
</p>

<p>
Once upon a time Linux eschewed complex APIs in favor of making the basic primitives--forking, threading, syscalls, etc--as fast and efficient as possible. And that's perhaps why all the earlier proposals never never made it in--the original strategy was still paying dividends and reduced the pressures that enterprise systems never could cope with. A kernel-land I/O thread pool couldn't schedule I/O any better than a user land thread pool, and if it could the solution was to make it so the user land thread pool could just as well, not to actually relent and expose a specialized I/O thread pool kernel construct.
</p>

<p>
So now that Linux is moving in the direction of increasingly complex, leaky APIs to cover the performance gap, treading the old waters of enterprise Unix, what does that imply, if anything, about the evolution of Linux and the state of hardware. Are we really better off shifting so much complexity into the kernel? From a security perspective that seems highly doubtful. Are we really better off from a performance perspective? If Linux is abdicating its dogged pursuit of performance improvements, don't we know where this road leads? Or maybe Linux finally hit the wall of what the Unix process and I/O model could fundamentally provide. io_uring is what you'd build as an IPC primitive for a very high performance microkernel. Why keep all this complexity in one, insecure address space when we can finally disperse it across different processes, using a new process model that boxes and aggregates resources in a fundamentally different way.  
</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor810573"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2020 13:26 UTC (Mon)
                               by <b>ermo</b> (subscriber, #86690)
                              [<a href="/Articles/810573/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why keep all this complexity in one, insecure address space when we can finally disperse it across different processes, using a new process model that boxes and aggregates resources in a fundamentally different way. </font><br>
<p>
Are you suggesting that it might be worth it to experiment with making Linux a hybrid (macro/micro) kernel and use io_uring as the transport between separate kernel "daemon" processes, moving forward with the separation by splitting out one subsystem at a time?<br>
<p>
If not, could you perhaps outline what you had in mind?  Inquiring minds would like to know.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810573/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor810898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2020 20:13 UTC (Wed)
                               by <b>notriddle</b> (subscriber, #130608)
                              [<a href="/Articles/810898/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So now that Linux is moving in the direction of increasingly complex, leaky APIs to cover the performance gap, treading the old waters of enterprise Unix, what does that imply, if anything, about the evolution of Linux and the state of hardware.</font><br>
<p>
What it says about the state of hardware is easy.<br>
<p>
Meltdown mitigations made context switching more expensive, and SSDs made the actual I/O cheaper. At some point, you're spending almost as much time context switching as you are doing actual work, and there's nothing Linux can do about it because it's all tied up in the architecture of the MMU and the processor's cache. Thus, it now makes sense to design the interface around reducing the number of context switches at all cost, instead of just assuming that the cost of doing the actual I/O will dominate.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor810901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2020 20:25 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/810901/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Unix historically didn't have asynchronous disk I/O, and this effected the architecture of subsystems and drivers. Linux still doesn't have asynchronous buffered disk I/O. All you're doing is offloading the operation to a thread pool in the kernel, which performs the operation synchronously, rather than a thread pool in user land.</font><br>
That's not quite true, the BIO layer is already asynchronous (with its own scheduler and everything). And that's where the most of the waiting goes.<br>
<p>
And it's not like the VFS layer is impossible to implement asynchronously, it's just that before now it was not needed at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor810531"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2020 11:10 UTC (Sun)
                               by <b>geertj</b> (subscriber, #4116)
                              [<a href="/Articles/810531/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Very interesting. Does io_uring work with buffered io? Does it work with NFS? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810531/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor810543"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2020 18:18 UTC (Sun)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/810543/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes and yes<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810543/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor810546"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2020 21:49 UTC (Sun)
                               by <b>grober</b> (guest, #136840)
                              [<a href="/Articles/810546/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How io_uring implements asynchronous operations if everything is synchronous internally? Does it use thread pool?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810546/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor810555"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2020 0:23 UTC (Mon)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/810555/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually, everything is asynchronous internally. The kernel submits a request to the disk hardware, and some time later, the disk hardware interrupts the kernel to tell it's done. In the meantime, the CPU can be doing something else, be it running another thread or (with asynchronous I/O like io_uring) doing something else on the same thread.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810555/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor810565"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2020 8:45 UTC (Mon)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/810565/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Filesystem code is certainly synchronous for things like reading metadata (inodes) from disk.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810565/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor810702"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2020 10:50 UTC (Tue)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/810702/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was wondering about this too. Is it just a way to avoid the overhead of system calls, or is it actually, truly asynchronous?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810702/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor810554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2020 23:55 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/810554/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've heard complaints there's no AIO readdir(). There may well be a use-case for an IORING_OP_READDIR (although it should come with a user so we're sure we're doing something useful)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor810556"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2020 0:19 UTC (Mon)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/810556/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would hope that such an operation looks more like getdents64 than readdir.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810556/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor810557"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2020 0:22 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/810557/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're thinking about readdir(2) and getdents64(2). I was thinking about readdir(3).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810557/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor810558"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2020 0:36 UTC (Mon)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/810558/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One drawback of io_uring seems to be that, as far as I know, you need a separate buffer for each pending request. So if you were using io_uring to read data from 1000 network connections at the same time, you'd need 1000 separate buffers, while with synchronous epoll+read, you'd need a single buffer (1000 times less memory).<br>
<p>
Is there any plan to allow the kernel to choose the buffer, so that you could give the kernel a small set of buffers (or a single large buffer) and the kernel would pick one (or carve a piece of that large buffer) when the data arrives? Or is that actually not an issue in real-world use cases?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810558/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor810560"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2020 1:44 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/810560/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>While you can't have the kernel choose which buffer is in use for each pending read, you can make use of <tt>IORING_OP_POLL_ADD</tt> to poll all 1,000 network connections via the uring, and then use <tt>IORING_OP_READV</tt> to read only from the connections that are ready, using a smaller number of buffers than there are connections.
<p>That's basically the same work level as <tt>epoll</tt> + <tt>read</tt>, but with both the <tt>epoll</tt> and the <tt>read</tt> being done asynchronously.
      
          <div class="CommentReplyButton">
            <form action="/Articles/810560/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor810568"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2020 10:03 UTC (Mon)
                               by <b>AndreiG</b> (guest, #90359)
                              [<a href="/Articles/810568/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it really that hard to change the name ... ?<br>
Naming is very important in software engineering and we have a long way to go with naming and consistency in kernel code.<br>
That and the title of this article sounds like one of those statistics from Pornhub that nobody asked for.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810568/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor810646"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2020 18:25 UTC (Mon)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/810646/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Everybody knows that porn is a frequent driver of technology.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810646/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor811820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2020 14:45 UTC (Fri)
                               by <b>CúChulainn</b> (guest, #137154)
                              [<a href="/Articles/811820/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Porn is destroying the west at a pace outstripping any technological innovation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor811924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2020 21:04 UTC (Fri)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/811924/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, that's capitalism doing that. Porn is just a conveniently taboo bogeyman used by puritanical wonks descended from slave owners to shift the spotlight off themselves.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor811944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2020 23:18 UTC (Fri)
                               by <b>CúChulainn</b> (guest, #137154)
                              [<a href="/Articles/811944/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with porn is that it is not taboo. Banks and financialisation are not capitalism. A lot of people want to move their families great distances to live amongst the posterity of slave owners, they must really love puritanical wonks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor812336"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2020 0:22 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/812336/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Want to try that again, but make sense this time?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/812336/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor810570"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2020 11:34 UTC (Mon)
                               by <b>seanyoung</b> (subscriber, #28711)
                              [<a href="/Articles/810570/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I must say that io_uring looks fantastic. A lot of people have spent a lot of time trying to solve this problem.<br>
<p>
Thanks Jens Axboe!<br>
<p>
PS I can't wait to see this integrated with rust async_std.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/810570/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor811223"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2020 19:10 UTC (Fri)
                               by <b>sunbains</b> (subscriber, #104233)
                              [<a href="/Articles/811223/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I second that, thanks Jens! I found it  quite straight forward to add support for io_uring to MySQL/InnoDB. I used liburing rather than the lower level interface. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811223/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor811612"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2020 17:52 UTC (Wed)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/811612/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nice! I might have missed this, any references to the MySQL/InnoDB io_uring code?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/811612/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor820588"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2020 1:57 UTC (Fri)
                               by <b>twocode</b> (guest, #132839)
                              [<a href="/Articles/820588/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
+1 @Suny, how much performance gain have you observed from your observation?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/820588/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor812020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2020 22:47 UTC (Sun)
                               by <b>dcoutts</b> (subscriber, #5387)
                              [<a href="/Articles/812020/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What I do not yet understand is how this is expected to interact with epoll for handling large numbers of network connections.<br>
<p>
The io_uring API is designed to scale to a moderate number of simultaneous I/O operations. The size of the submit and collect rings has to be enough to cover all the simultaneous operations. The max ring size is 4k entries. This is fine for the use case of disk I/O, connect, accept etc.<br>
<p>
It's not fine for the "10k problem" of having 10s of 1000s of idle network connections. That's what epoll is designed for. We don't really want to have 10s of 1000s of pending async IO recv operations, we just want to wait for data to arrive on any connection, and then we can execute the IO op to collect the data.<br>
<p>
So what's the idea for handling large numbers of network connections using io_uring, or some combo of io_uring and epoll? We have IORING_OP_POLL_ADD but of course this costs one io_uring entry so we can't go over 4k of them. There's IORING_OP_EPOLL_CTL for adjusting the fds in an epoll set. But there's no io_uring operation for epoll_wait. So do we have to use both io_uring and epoll_wait? Now that needs two threads, so no nice single-threaded event loop.<br>
<p>
Perhaps I'm missing something. If not, isn't the obvious thing to add support for IORING_OP_EPOLL_WAIT? Then we can use IORING_OP_EPOLL_CTL to adjust the network fds we're monitoring and then issue a single IORING_OP_EPOLL_WAIT to wait for any network fd to have activity.<br>
<p>
Alternatively, io_uring could subsume the epoll API entirely. The single-shot style of IORING_OP_POLL_ADD is actually very nice. But it has to scale to the 10k+ case, so cannot consume a completion queue entry for each fd polled like IORING_OP_POLL_ADD does.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/812020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor812021"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2020 23:05 UTC (Sun)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/812021/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The submission/completion queues do not contain entries for requests currently being processed. I.e. there can be more requests being processed, than fit in either of the max queue sizes.<br>
<p>
Early on that could lead to the completion queue overflowing, but now those completions are saved (but no new submissions are allowed, basically).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/812021/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor812025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 10, 2020 1:33 UTC (Mon)
                               by <b>dcoutts</b> (subscriber, #5387)
                              [<a href="/Articles/812025/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So if I understand what you mean then in principle we could have a completion ring of e.g. 1k entries, and submit 10k IORING_OP_POLL_ADD operations on sockets, and this can't lead to loosing any completions. At most, if the completion ring is empty we have to collect completions before submitting new operations (which is completely reasonable). If so, that's excellent.<br>
<p>
So is this pattern of use with sockets expected to perform well, e.g. compared to epoll? If so, that's fantastic, we really can use just one system for both disk I/O and network I/O. The one-shot behaviour of IORING_OP_POLL_ADD is entirely adequate (covering epoll's EPOLLONESHOT which is its most useful mode).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/812025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor812028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 10, 2020 3:29 UTC (Mon)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/812028/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So if I understand what you mean then in principle we could have a completion ring of e.g. 1k entries, and submit 10k IORING_OP_POLL_ADD operations on sockets, and this can't lead to loosing any completions.</font><br>
<p>
Yes, that's correct to my knowledge. That wasn't the case in the first kernels with support for io_uring however (you need to test for IORING_FEAT_NODROP to know).  But for poll like things it's also not that hard to handle the overflow case - just treat all of the sockets as ready. But that doesn't work at all for asynchronous network IO (rather than just readiness).<br>
<p>
And obviously, you'd need to submit the 10k IORING_OP_POLL_ADDs in smaller batches, because the submission queue wouldn't be that long. But that's fine.<br>
<p>
<p>
FWIW, I am fairly sure you can submit an IORING_OP_POLL_ADD on an epoll fd. Signal readiness once epoll_pwait would return (without returning the events of course). So if you need something for which oneshot style behaviour isn't best suited, or which you might want to wait on only some of the time, you can also compose io_uring and epoll.  Caveat: I have not tested this, but I'm fairly sure I've seen code doing so, and a quick look in the code confirms that this should work: eventpoll_fops has a .poll implementation, which is what io_uring (via io_poll_add) relies on to register to get notified for readiness.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/812028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor821379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 25, 2020 23:25 UTC (Mon)
                               by <b>rand0m$tring</b> (guest, #125230)
                              [<a href="/Articles/821379/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the completion queue size is allocated to approx 2x the submission queue. <br>
<p>
<a href="https://github.com/torvalds/linux/blob/444565650a5fe9c63ddf153e6198e31705dedeb2/fs/io_uring.c#L92">https://github.com/torvalds/linux/blob/444565650a5fe9c63d...</a><br>
<p>
 so that's the point at which it would reach capacity and fall over.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/821379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2022 23:06 UTC (Sat)
                               by <b>smahapatra1</b> (guest, #157268)
                              [<a href="/Articles/886922/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry for the naive question: why is EPOLL_ONESHOT the most useful mode? Does it not require another EPOLL_CTL and hence less efficient?<br>
Thank you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor821376"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 25, 2020 22:31 UTC (Mon)
                               by <b>rand0m$tring</b> (guest, #125230)
                              [<a href="/Articles/821376/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
right so this is obviously a huge problem, it makes anything more than a toy server impossible. I don't understand the reasoning for this limitation? <br>
<p>
A buffer per operation is also a nonstarter for the same reason. In 5.7 IOSQE_BUFFER_SELECT attempts to solve the buffer problem with rotations. But I think an input / output ring buffer solution that allows allocation at the tail when needed, and just returns ranges into the input or output buffer makes more sense?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/821376/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor839435"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2020 14:17 UTC (Wed)
                               by <b>hearts</b> (guest, #143561)
                              [<a href="/Articles/839435/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In my understanding, you can still use epoll together with io_uring. For example, use IORING_OP_POLL_ADD to register epoll id to io_uring, this occupies only 1 slot.<br>
<p>
Once epoll is ready, add all the ready descriptors to io_uring (readv / writev etc.) in batch. These descriptors will be dealt with immediately because they are in ready state.<br>
<p>
Even you have say million connections (and most of them are idle), it is still possible to deal with them without issues.<br>
<p>
You at least save some syscalls due to the batch operations, and for the application side, it is still more asynchronous than calling readv/writev yourself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/839435/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor860775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 24, 2021 13:47 UTC (Thu)
                               by <b>Emjayen</b> (guest, #152930)
                              [<a href="/Articles/860775/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So an almost carbon-copy of the NT I/O model, developed 25 years ago.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/860775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor861060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The rapid growth of io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 26, 2021 10:18 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/861060/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And unlike NT, it&#x27;s got the 25 years of filesystem development to go with it!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/861060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
