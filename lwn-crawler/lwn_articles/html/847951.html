        <!DOCTYPE html>
        <html lang="en">
        <head><title>BPF meets io_uring [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/847951/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/848236/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/847951/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>BPF meets io_uring</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>March 4, 2021</br>
           </div>
Over the last couple of years, a lot of development effort has gone into
two kernel subsystems:
<a href="/Articles/740157/">BPF</a> and
<a href="/Articles/810414/">io_uring</a>.  The BPF virtual machine allows
programs from user space to be safely run within the context of the kernel,
while io_uring addresses the longstanding problem of running system calls
asynchronously.  As the two subsystems expand, it was inevitable that the
two would eventually meet; the first encounter happened in mid-February
with <a
href="/ml/io-uring/cover.1613563964.git.asml.silence@gmail.com/">this patch
set</a> from Pavel Begunkov adding the ability to run BPF programs from
within io_uring.
<p>
The patch set itself is relatively straightforward, adding less than 300
lines of new code.  It creates a new BPF program type
(<tt>BPF_PROG_TYPE_IOURING</tt>) for programs that are meant to be run in
the io_uring context.  Any such programs must first be created with the <a
href="https://man7.org/linux/man-pages/man2/bpf.2.html"><tt>bpf()</tt></a>
system call, then  registered with the ring
in which they are intended to run using the new <tt>IORING_ATTACH_BPF</tt>
command.  Once that has been done, the <tt>IORING_OP_BPF</tt> operation
will cause a program to be run within the ring.  The final step in the
patch series adds a helper function that BPF programs can use to submit new
operations into the ring.
<p>
As a proof of concept, the patch series does a good job of showing how BPF
programs might be run from an io_uring.  This work does not, though, really
enable any new capabilities in its current form, which may be part of why
there have been no responses to it on the list.  There is little value to
running a BPF program asynchronously to submit another operation; one could
simply submit that operation directly instead.  As is acknowledged in the
patch set, more infrastructure will be needed before this capability will
become useful to users.
<p>
The obvious place where BPF can add value is making decisions based on the
outcome of previous operations in the ring.  Currently, these decisions
must be made in user space, which involves potential delays as the relevant
process is scheduled and run.  Instead, when an operation completes, a BPF
program might be able to decide what to do next without ever leaving the
kernel.  "What to do next" could include submitting more I/O operations,
moving on to the next in a series of files to process, or aborting a series
of commands if something unexpected happens.
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
Making that kind of decision requires the ability to run BPF programs in
response to other 
events in the ring.  The sequencing mechanisms built into io_uring now
would suffice to run a program once a specific operation completes, but
that program will not have access to much useful information about
<i>how</i> the operation completed.  Fixing that will, as Begunkov noted,
require a way to pass the results of an operation into a BPF program when
it runs.  An alternative would be to tie programs directly to submitted
operations (rather than making them separate operations, as is done in the
patch set) that would simply run at completion time.
<p>
With that piece in place, and with the increasing number of system calls
supported within io_uring, it will become possible to create complex,
I/O-related programs that can run in kernel space for extended periods.
Running BPF programs may look like an enhancement to io_uring, but it can
also be seen as giving BPF the ability to perform I/O and run a wide range
of system calls.  It looks like a combination that people might do some
surprising things with.
<p>
That said, this is not a feature that is likely to be widely used.  On its
own, io_uring brings a level of complexity that is only justified for
workloads that will see a significant performance improvement from
asynchronous processing.  Adding BPF into the mix will increase the level
of complexity significantly, and long sequences of operations and BPF
programs could prove challenging to debug.  Finally, loading io_uring
programs requires either of the <tt>CAP_BPF</tt> or <tt>CAP_SYS_ADMIN</tt>
capabilities, which means "root" in most configurations.  As long as the
current <a href="/Articles/796328/">hostility toward unprivileged BPF
programs</a> remains, that is unlikely to change; as a result, relatively
few programs are likely to use this feature.
<p>
Still, the combination of these two subsystems provides an interesting look
at where Linux may go in the future.  Linux will (probably) never be a <a
href="https://en.wikipedia.org/wiki/Unikernel">unikernel</a> system, but
the line between user space and the kernel does appear to be getting
increasingly blurry.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#BPF">BPF</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#io_uring">io_uring</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/847951/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor848288"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2021 18:43 UTC (Thu)
                               by <b>tux3</b> (subscriber, #101245)
                              [<a href="/Articles/848288/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As foretold by prophecy...<br>
<p>
The kernel/userland barrier just keeps being worked around in increasingly involved ways. Whether it&#x27;s moving the TCP/IP stack to userspace, DIO, decoupling syscalls from context switches with the ring, or moving policy/control to kernelspace with BPF.<br>
<p>
I wonder if this is all converging somewhere coherent, or if we&#x27;ll just have to pick combinations of specialiazed speedhax depending on the application domain.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848288/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 11:57 UTC (Fri)
                               by <b>miquels</b> (guest, #59247)
                              [<a href="/Articles/848369/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There&#x27;s a tongue-in-cheek talk by Gary Bernhardt where he pretends to be in 2035, looking back on how noone uses javascript directly anymore, but how it is _the_ VM on which everythings runs, even the kernel. He does make a few good points, about how the VM costs 25% of performance, but all the hardware protection on the CPU costs 30% of performance so you might as well run everything in ring 0 and handle protection in the VM. This was before webassembly, now that we have that, the talk might well turn out to have been prophetic. It&#x27;s here: <a href="https://www.destroyallsoftware.com/talks/the-birth-and-death-of-javascript">https://www.destroyallsoftware.com/talks/the-birth-and-de...</a> . And prophetic or not, it is funny :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848438"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 16:37 UTC (Fri)
                               by <b>thoeme</b> (subscriber, #2871)
                              [<a href="/Articles/848438/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the link, it is definitely funny :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848438/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor848449"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 17:57 UTC (Fri)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/848449/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I never understood the base assertion; he just says that the cost of separation is 30%? Where on earth does that come from? And why would it be cheaper to do it in software than in hardware?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848449/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848463"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 20:15 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/848463/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In principle it should be cheaper to implement some protection in software, because a trusted piece of software can guarantee that an untrusted piece of software will meet certain conditions (e.g. that it will never access an array out of bounds), either by construction (like a JS JIT compiler will never emit machine code that attempts out-of-bounds accesses) or by static analysis (like with a verifier for proof-carrying code). Once you have those guarantees, you can safely run the untrusted code with no further protection.<br>
<p>
It&#x27;s not practical for hardware to deduce those static guarantees because it&#x27;s at a very different level of abstraction. All it can do by itself is dynamic bounds checks on every single memory access, which is fundamentally less efficient. Some of those checks can run in parallel with normal execution, so it costs transistors but not cycles, and transistors are cheap. But some checks can&#x27;t.<br>
<p>
The Bernhardt talk references &quot;Deconstructing Process Isolation&quot; (<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.109.1184">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.1...</a>) which says &quot;We found that hardware-based isolation incurs non-trivial performance costs (up to 25–33%)&quot;. That&#x27;s specifically about their Singularity microkernel OS, which involves a lot of message-passing IPC. Hardware isolation means virtual memory, separate page tables for each process (or for a small group of processes), TLB flushes on context switches, system calls done with sysenter, etc. Software isolation means memory safety of untrusted code is guaranteed by their compiler, so it all runs in ring 0 alongside the kernel core, using physical memory directly instead of virtual memory, and system calls are just function calls.<br>
<p>
Also, hardware isolation apparently means their IPC system copies messages from one user process&#x27;s heap into the kernel heap, deallocates from the first heap, and then copies from the kernel heap into the other user process&#x27;s heap. Or for large messages it remaps physical pages from one heap to the other. (That sounds suboptimal. Surely it would be way better to have, say, some kind of ring buffer in shared memory between the processes?)<br>
<p>
In that system, one benchmark (which reads tiny files and involves a lot of IPC between application, filesystem and disk driver) gave the quoted 25-33% reduction in performance when using hardware isolation.<br>
<p>
I don&#x27;t think it&#x27;s reasonable to generalise from that specific benchmark in that specific probably-suboptimal prototype kernel into saying &quot;the hardware protection on the CPU costs 30% of performance&quot; - it&#x27;s not like Linux would get 30% faster if you ran it without memory protection. On the other hand, that&#x27;s because Linux has already been designed in a way that largely avoids those costs (e.g. by not being a microkernel), and has accepted compromises on security and reliability in exchange for performance. With more software-based protection, maybe you can get security and reliability *and* performance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848463/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848478"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 22:00 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/848478/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Microsoft has been badly burned by asynchronous shared memory in the past. I believe that their security guidelines just don&#x27;t permit it anymore. As I remember it there were new Windows NT, 2000 and XP TOCTTOU bugs almost every month.<br>
<p>
That was almost safe before multiprocessors became so popular. With one CPU it was nearly impossible to get in between the NT kernel and its IPC.<br>
<p>
It&#x27;s just too easy to change data between the kernel checking it and using it. So it has to be copied to the kernel or otherwise isolated before using it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848478/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 22:19 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/848483/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Normal Windows syscalls are self-contained length-prefixed packets, so they are copied once into the kernel space.<br>
<p>
Windows kernel can read data from userspace, but it&#x27;s only used for syscalls that deal with bulk data transfer. This data is typically unstructured.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor848489"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 22:54 UTC (Fri)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/848489/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, so if you design your system maximally split up, and run a benchmark that runs maximum communication between those parts, you get 30% overhead? And if you design your system less split up (by implementing it in a VM, and trusting that VM blindly), it gets faster…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848489/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2021 0:03 UTC (Sat)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/848496/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Basically that, although they weren&#x27;t &quot;trusting that VM blindly&quot; - they were also building a language and compiler based on C# with contracts that are statically checked using a theorem prover, and then aiming to compile to typed assembly language (which has &quot;a proof of the type safety of compiled x86 code along with the code itself. A properly structured proof of type safety can be verified by a small, simple checker whose correctness is far easier to ensure than a compiler&#x27;s&quot;), so they were well aware of the importance of minimising the trusted computing base and using formal methods to help ensure it deserved that trust.<br>
<p>
(The Singularity project (which was from Microsoft Research) ended some time around 2010, but it sounds like it was reasonably successful - it evolved into the Midori project (which sounds more production-oriented, whereas Singularity was more pure research), and then it sounds like Midori was technically successful but got shut down for messy reasons, but it had proved a bunch of useful ideas (both technical and cultural) that got adopted more widely within Microsoft. There&#x27;s a lot of detail about those lessons at <a href="http://joeduffyblog.com/2015/11/03/blogging-about-midori/">http://joeduffyblog.com/2015/11/03/blogging-about-midori/</a>)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848517"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2021 8:01 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/848517/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s unfortunate that Microsoft, with all their resources, didn&#x27;t invent Rust years earlier.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848517/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 6, 2021 11:04 UTC (Sat)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/848526/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Those posts from Joe Duffy suggest that&#x27;s largely what (a part of) Microsoft was trying to invent, and they just failed. E.g. specifically on concurrency safety:<br>
<p>
<font class="QuotedText">&gt; Out of the bunch, Rust has impressed me the most. They have delivered on much of what we set out to deliver with Midori, but actually shipped it (whereas we did not). My hat goes off to that team, seriously, because I know first hand what hard, hard, hard work this level of type system hacking is. [...] I trust their system more than ours, because they have shipped and had thousands of eyes and real-world experience applied to it.</font><br>
<p>
(and that was 5 years ago).<br>
<p>
If someone nowadays wanted to take the &#x27;software isolated processes&#x27; concept into production, where safety is guaranteed by the language and verified by a small TCB and doesn&#x27;t need to be enforced by expensive hardware, Rust sounds like a good place to start. (And would be nicer than just extending Linux until people start writing entire applications in BPF to avoid context switches.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor848611"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2021 20:43 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/848611/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p><font class="QuotedText">&gt; Software isolation means memory safety of untrusted code is guaranteed by their compiler</font>

<p>It doesn't work, unfortunately. Sun tried to patch JVM for <b>years</b>
… but eventually have given up (well Oracle had given up at this point) and <a href="https://derflounder.wordpress.com/2014/01/15/oracle-java-7-update-51-blocks-unsigned-java-applets-by-default/">turned it into ActiveX</a>.</p>

<p>Typical compiler (even JIT-compiler… maybe <b>especially</b> JIT-compiler) is just too complex of a beast to trust it without verification.</p>

<p>If you use separate <b>much</b>simpler verifier… then it may work. But not if you trust the compiler.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/848611/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848632"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2021 23:16 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/848632/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do you consider the BPF verifier+JIT to be trustworthy enough for its current use in the kernel? That seems like a successful(ish) example of software isolation, just applied to a tiny part of the OS instead of to nearly the whole thing (as Singularity was aiming for).<br>
<p>
It looks like there has been an attempt to apply formal methods to BPF, which claims the JIT compiler can be feasibly verified: <a href="https://www.usenix.org/conference/osdi20/presentation/nelson">https://www.usenix.org/conference/osdi20/presentation/nelson</a><br>
<p>
I don&#x27;t see why you couldn&#x27;t extend that to a more general-purpose language (maybe like Rust minus unsafe), with an untrusted compiler that does all the fancy analysis and optimisation and emits some kind of bytecode plus proof-of-correctness annotations, and then pass it to a trusted verifier+JIT which has itself been formally verified (and also is simple enough that people can review it manually). I&#x27;m not aware that anyone has done that yet, so it&#x27;s probably a research project for some PhDs and then a lot more work to make it production-ready, but it doesn&#x27;t sound impossible or obviously impractical. And then you just need to write a whole OS in that new language.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848632/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848643"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2021 10:04 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/848643/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I don&#x27;t see why you couldn&#x27;t extend that to a more general-purpose language</font><br>
<p>
You cannot verify a Turing-complete language. Not possible.<br>
<p>
Which is why BPF currently forbids loops. I wish they&#x27;d take a leaf out of the Fortran spec and say loop-control variables are read-only, at which point you can verify that the loop will terminate.<br>
<p>
(The Fortran spec doesn&#x27;t say control variables ARE read-only, but it explicitly permits storing them in a register unaffected by the rest of the code, so depending on your compiler, modifying the variable can have strange effects ...)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848643/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848645"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2021 12:07 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/848645/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Why do you say it's not possible to verify a Turing-complete language? Formal methods people do so all the time - verifying C code, for example.
<p>A verifier has three possible outputs - "not valid", "valid", and "indeterminate validity"; it's then up to the user of the verifier to decide what to do with the output. For example, it could declare that "not valid" is barred, "valid" is allowed, and "indeterminate validity" requires a special-case assertion of correctness from a privileged user to permit it to run.
      
          <div class="CommentReplyButton">
            <form action="/Articles/848645/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848647"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2021 12:58 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/848647/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was thinking of verifying in the sense of a definite answer, not returning &quot;indeterminate&quot;.<br>
<p>
That&#x27;s the problem with BPF and loops at the moment - a verifier cannot return &quot;valid&quot;, so they get rejected.<br>
<p>
Let&#x27;s rephrase what I said - a verifier cannot be guaranteed to return a definitive answer, if the language is Turing complete. And that&#x27;s the problem with BPF - if the problem space cannot be verified as valid, then the kernel won&#x27;t run it. Which is why at present the kernel doesn&#x27;t permit backward jumps in BPF. (I think they&#x27;ve found a way round that restriction a bit.)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848647/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor848648"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2021 13:16 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/848648/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You cannot verify a Turing-complete language. Not possible.</font><br>
<p>
You can, as long as the output of the verifier is &quot;this is safe&quot; or &quot;I don&#x27;t know if this is safe, so I won&#x27;t let you run it&quot;, for whatever definition of &quot;safe&quot; you want. In the trivial case a verifier can emit &quot;don&#x27;t know&quot; for every program. The trick is in picking a useful definition of &quot;safe&quot;, then making the provably-safe subset large enough to be useful in practice, and obvious enough to a programmer that they can stay within the provably-safe bounds and not get repeatedly frustrated by trying to write code that they know is safe but that gets rejected by the system.<br>
<p>
The current state of the art indicates that&#x27;s achievable in practice, even for high-performance general-purpose languages, though I think it&#x27;s still an active research topic.<br>
<p>
(If you&#x27;re writing a whole OS in such a language, there will probably be a few places where you need to do things that are not provably safe, but in that case you can move the unprovably safe code into your trusted computing base and hopefully it&#x27;s small enough that you can manually verify it with other techniques. Like if you were using Rust, &#x27;unsafe&#x27; blocks are for unprovably safe code, and I guess you&#x27;d want to move all such blocks into external modules in the TCB, then enforce that applications cannot use &#x27;unsafe&#x27; themselves and have to call those trusted modules instead.)<br>
<p>
If your definition of &quot;safe&quot; allows non-halting programs, and just forbids e.g. memory safety issues, then the verifiable subset of your language can still be Turing complete: you can easily write a simulator for tape-based Turing machines in e.g. JavaScript, and the program will obviously be memory-safe (because JS always is), and the simulator can still compute anything that any Turing machine can (ignoring quibbles about the need for infinite memory). You don&#x27;t have to sacrifice completeness unless you want to guarantee termination. (BPF does want to guarantee termination, but the more general concept of software isolation (in the Singularity sense) doesn&#x27;t require that.)<br>
<p>
<font class="QuotedText">&gt; Which is why BPF currently forbids loops</font><br>
<p>
BPF allows constant-bounded loops now: <a href="https://lwn.net/Articles/794934/">https://lwn.net/Articles/794934/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848648/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850831"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 27, 2021 9:35 UTC (Sat)
                               by <b>ksandstr</b> (guest, #60862)
                              [<a href="/Articles/850831/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; You cannot verify a Turing-complete language. Not possible.</font><br>
<p>
<font class="QuotedText">&gt;You can, as long as the output of the verifier is &quot;this is safe&quot; or &quot;I don&#x27;t know if this is safe, so I won&#x27;t let you run it&quot;, for whatever definition of &quot;safe&quot; you want.</font><br>
<p>
The subset of Turing-complete programs that can be verified does not sum up to a Turing-complete system. It follows that a function from an arbitrary program to a &quot;verifiable, and known safe&quot;/&quot;not verifiable, or not known safe&quot; result is at most identifying a Turing-incomplete subset by whether the program falls into it or not. This is what Wol&#x27;s comment, an oft-repeated truth about Turing-complete languages (processors, VMs, whatever), means.<br>
<p>
As for having programmers work in a Turing-incomplete language, good luck with that. People have been burning time and money on various hobby horse projects in that space since the early eighties, of which absolutely nothing has percolated into software developers&#x27; daily practice. It is literally the Philosopher&#x27;s Stone of software, a windmill that many superficially smart people figure they could really take a proper tilt at if only they had a bigger horse.<br>
<p>
Meanwhile things such as Ada, which yields many practical advantages while not compromising on Turing-completeness, languish in the dustbin of old and busted curiosities.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850831/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor956373"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 29, 2023 16:04 UTC (Fri)
                               by <b>pgoetz</b> (subscriber, #4931)
                              [<a href="/Articles/956373/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; It's not practical for hardware to deduce those static guarantees</span><br>
<p>
I mean, this is why we have an operating system?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/956373/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor848418"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 15:16 UTC (Fri)
                               by <b>federico3</b> (guest, #101963)
                              [<a href="/Articles/848418/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I wonder if this is all converging somewhere coherent, or if we&#x27;ll just have to pick combinations of specialiazed speedhax depending on the application domain.</font><br>
<p>
This is inevitable if you want to satisfy a lot of different needs. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848418/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor848294"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2021 20:03 UTC (Thu)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/848294/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder if the system administrator could authorize specific BPF programs, and unprivileged userspace could then use only those programs and no others? That would allow common libraries to come with sets of BPF programs they require, and distributions could then allow those programs automatically based on being installed in a system location.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848294/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor849820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 19, 2021 13:38 UTC (Fri)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/849820/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It should be pretty simple to implement. You just need a Daemon with root permissions that loads the BPF programs with bpf(2) and then hands the resulting file descriptor out to other processes using SCM_RIGHTS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor848298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2021 21:03 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/848298/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So.... Is this enough to do a TLS handshake entirely in kernel-space?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848305"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2021 21:36 UTC (Thu)
                               by <b>krkhan</b> (guest, #136994)
                              [<a href="/Articles/848305/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn&#x27;t that already in place? <a href="https://www.kernel.org/doc/html/latest/networking/tls.html">https://www.kernel.org/doc/html/latest/networking/tls.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848305/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2021 21:40 UTC (Thu)
                               by <b>krkhan</b> (guest, #136994)
                              [<a href="/Articles/848306/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah.. okay, I see it&#x27;s just the record layer. But what prevents the full handshake from being done in the kernel without the BPF-io_uring patches?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2021 21:57 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/848309/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, you do need a fair amount of code to validate the ASN.1 certificates and negotiate the parameters. ASN.1 parsing is already present in Linux, so theoretically the amount of code to handle the full TLS handshake is not THAT large.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor848362"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 10:32 UTC (Fri)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/848362/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why would you want to do that? You surely cannot gain much performance, since the computational cost of the TLS handshake greatly outweighs the transition costs between kernel- and userspace.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848362/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848435"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2021 16:25 UTC (Fri)
                               by <b>gerdesj</b> (subscriber, #5446)
                              [<a href="/Articles/848435/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You&#x27;ll need it when you are creating a modern one of these: <a href="https://www.linuxjournal.com/article/4132">https://www.linuxjournal.com/article/4132</a> <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848435/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor848628"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF meets io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2021 22:35 UTC (Sun)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/848628/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t think that answers the question? Let me rephrase it; why would you want a kernel-side HTTP server with TLS support? (khttpd never really took off back in the day…)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/848628/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor849904"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IOSQE_IO_LINK, IORING_OP_BPF, IORING_OP_READ, and streams of length-prefixed packets</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2021 4:11 UTC (Sat)
                               by <b>namibj</b> (guest, #145316)
                              [<a href="/Articles/849904/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think this on it&#x27;s own may be useful already, without access to completion status.<br>
<p>
A cluster compute framework (Timely Dataflow, for the curious) currently runs one send/receive thread for each connected peer.<br>
It uses TCP connections and uses a custom message format.<br>
The fixed-layout header contains routing information to target a specific worker thread and thread-local coroutine inbox, along with the message body&#x27;s length.<br>
For zero-copy deserialization, the message body needs to end up contiguous in the worker thread&#x27;s address space (ideally NUMA-local to that thread).<br>
Round-trip overhead largely prevents reassembly-free processing, so it currently has to memcpy messages that cross read(2) target buffer boundaries.<br>
<p>
With BPF, it could read the header (so userspace can use it for logging etc.), and through IOSQE_IO_LINK, immediately run a small BPF program that looks at the now-in-userpsace header to extract target thread and length. After passing the target thread id from the header (combined with `clz(header.msg_len)`) to `bpf_map_lookup_elem()` to retrieve a BPF_MAP_TYPE_STACK reference, it claims a slab by `pop()`ing a pointer to the slab and it&#x27;s  `buf_index`.<br>
Ignoring some bookkeeping needed to cope with incomplete reads and out-of-slabs situations, it can just finish by submitting an IORING_OP_READ_FIXED to DMA-deliver the message body into a NUMA-aware slab allocation, using IOSQE_IO_LINK to chain a IORING_OP_READ + IORING_OP_BPF pair that will deal with the next header in the stream.<br>
<p>
This gets of course extra-powerful if that header-parsing eBPF program can run on a NIC, and if there&#x27;s something concrete I could contribute to the Kernel to let eBPF inspect that header (inside a TCP stream, potentially spanning TCP packets) directly on a NIC (without first copying to a buffer in system memory, like the above sketch does), I&#x27;d like that as my first kernel contribution. I&#x27;d need to know where to start reading/poking and how much work to expect.<br>
<p>
[0]: <a rel="nofollow" href="https://lwn.net/Articles/838884/">https://lwn.net/Articles/838884/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/849904/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
