        <!DOCTYPE html>
        <html lang="en">
        <head><title>Supporting Linux kernel development in Rust [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/829858/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/829694/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/829858/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Supporting Linux kernel development in Rust</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="GAByline">
           <p>August 31, 2020</p>
           <p>This article was contributed by Nelson Elhage</p>
           <hr>
<a href="/Archives/ConferenceByYear/#2020-Linux_Plumbers_Conference">LPC</a>
</div>
<p>The <a href="https://www.rust-lang.org/">Rust programming language</a>
has long aimed to be a suitable replacement for C in operating-system
kernel development.  As Rust has matured, many developers have expressed
growing interest in using it in the Linux kernel. At the 2020 (virtual) <a
href="https://linuxplumbersconf.org/">Linux Plumbers Conference</a>, the
<a href="https://llvm.org/">LLVM</a> microconference track hosted a session
on open questions about and 
obstacles to accepting Rust upstream in the Linux kernel.  The interest in
this topic can be seen in the fact that this was the single most heavily
attended session at the 2020 event.

<p>This session built on prior work by many developers, including a <a
href="https://www.youtube.com/watch?v=RyY01fRyGhM">talk last year by Alex
Gaynor and Geoffrey Thomas [YouTube]</a> at the Linux Security Summit. At
that talk, they presented their work prototyping Rust kernel modules and
made the case for adopting Rust in the kernel. They focused on security
concerns, citing work showing that around two-thirds of the kernel
vulnerabilities that were assigned CVEs in both Android and Ubuntu stem
from memory-safety issues. Rust, in principle, can completely avoid this
error class via safer APIs enabled by its type system and <a
href="https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html">borrow
checker</a>.

<p>Since then, Linus Torvalds and other core kernel maintainers have expressed
<a href="https://www.theregister.com/2020/06/30/hard_to_find_linux_maintainers_says_torvalds/">openness in principle</a> to supporting kernel
development in Rust, so the session at Plumbers aimed to
work through some of the requirements to eventually allowing Rust
in-tree. The session was proposed and discussed <a
href="/ml/linux-kernel/CAKwvOdmuYc8rW_H4aQG4DsJzho=F+djd68fp7mzmBp3-wY--Uw@mail.gmail.com/">on
the linux-kernel mailing list</a>, where some of the topics of discussion were
previewed.

<p>This session, too, featured Thomas and Gaynor, along with Josh Triplett
— the Rust language team co-leader and a longtime Linux kernel developer —
and a number of other interested developers. They briefly touched on their
work so far and some of their initial thoughts and questions before opening
the bulk of the time to discussion. They gave a brief example of what
kernel-mode Rust code might look like (from Thomas and Gaynor's <a
href="https://github.com/fishinabarrel/linux-kernel-module-rust/">linux-kernel-module-rust</a>
project).

<p>The speakers emphasized that they are not proposing a rewrite of the
Linux kernel into Rust; they are focused only on moving toward a
world where new code may be written in Rust.
The ensuing conversation focused on three areas of potential concern
for Rust support: making use of the existing APIs in the kernel,
architecture support, and a question about ABI compatibility between
Rust and C.

<h4>Binding to existing C APIs</h4>

<p>In order to be useful for kernel development, it's not enough that
Rust is able to generate code that can be linked into the kernel;
there also needs to be a way for Rust to access the vast number of
APIs used in the Linux kernel, which are all presently defined in C
header files.
Rust has good support for interoperating with C code, including
support for both calling functions using the C ABI and for defining
functions with C-compatible ABIs that can be called from
C. Furthermore, the <a href="https://github.com/rust-lang/rust-bindgen">bindgen</a> tool is capable of parsing C
header files to produce the appropriate Rust declarations, so that
Rust does not need to duplicate definitions from C, which also
provides a measure of cross-language type checking.

<p>
<blockquote>
<a href="/Articles/829942/"><img
src="https://static.lwn.net/images/conf/2020/lpc/rust1-strip.png" alt="[Rust discussion]"
title="Kernel developers discussing Rust" border=0 class="photo"></a>
</blockquote>
<p>

<p>On the surface, these features make Rust well-equipped to integrate
with existing C APIs, but the devil is in the details, and both the
work to date and the conversation at the session revealed a handful of
open challenges.

For example, Linux makes heavy use of preprocessor macros and inline
functions, which aren't easily supported by bindgen and Rust's
foreign-function interface.
<p>
The ubiquitous <tt>kmalloc()</tt> function, for
instance, is defined as 
<tt>__always_inline</tt>, meaning that it is inlined into all of its callers
and no <tt>kmalloc()</tt> symbol exists in the kernel symbol table for Rust to
link against.
This problem can be easily worked around — one can
define a <tt>kmalloc_for_rust()</tt> symbol containing an un-inlined version —
but performing these workarounds by hand would result in a large
amount of manual work and duplicated
code. This work could potentially be automated by an improved version
of <tt>bindgen</tt>, but such a tool does not yet exist.

<p>The conversation also touched on a second question about API bindings:
how much will C APIs need to be manually "wrapped" to present
idiomatic Rust interfaces? A look at two existing Rust kernel module
projects gives a flavor for some of the choices here.

<p>In the linux-kernel-module-rust project, pointers into user space are
wrapped into a <tt>UserSlicePtr</tt> type, which ensures appropriate use of
<tt>copy_to_user()</tt> or <tt>copy_from_user()</tt>. This wrapper provides
a level of 
safety in Rust code (these pointers can't be dereferenced directly),
and also makes Rust code more idiomatic; writing to a user-space
pointer looks something like
<p>
<pre>
    user_buf.write(&amp;kernel_buffer)?;
</pre>
<p>
<p>The <tt>?</tt> here is part of Rust's <a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">error-handling machinery</a>;
this style of returning and handling errors is ubiquitous in
Rust. Such wrappers make the resulting Rust more familiar to existing
Rust developers, and enable Rust's type system and borrow checker
to provide a maximum amount of safety. However, they must be carefully
designed and developed for each API, which is a lot of work and
creates distinct APIs for modules written in C and Rust.

<p><a href="https://github.com/jbaublitz/knock-out">John
Baublitz's demo module</a>, instead, binds the kernel's user-access functions more
directly; the corresponding code there looks something like:

<pre>
    if kernel::copy_to_user(buf, &amp;kernel_buffer[0..count]) != 0 {
   	return -kernel::EFAULT;
    }
</pre>

<p>This style is easy to implement — the bindings are largely
autogenerated by bindgen — and would also be more comfortable for
existing kernel developers who have to review or patch Rust
code. However, the code is much less idiomatic for Rust developers,
and potentially gives up a lot of the safety guarantees that Rust
promises.

<p>There was some agreement at the session that writing Rust wrappers
will make sense for some of the most common and critical APIs, but
that manually wrapping every kernel API would be infeasible and
undesirable. Thomas mentioned that Google is working on
automatically generating idiomatic bindings to C++ code, and pondered
whether the kernel could do something similar, perhaps building on top
of existing <a href="https://www.kernel.org/doc/html/v4.12/dev-tools/sparse.html">sparse</a> annotations or some new annotations added
to the existing C to guide the binding generator.

<h4>Architecture support</h4>

<p>The next area of discussion was architecture support. At present, the
only mature Rust implementation is the <a href="https://doc.rust-lang.org/rustc/what-is-rustc.html">rustc</a> compiler, which
emits code via LLVM. The Linux kernel supports a wide range of
architectures, several of which have no available LLVM backend. For a
few others, an LLVM backend exists, but rustc does not yet support
that backend. The presenters wanted to understand whether full
architecture support was a blocker to enabling Rust in the kernel.

<p>Several people said that it would be acceptable to implement drivers
in Rust that would never be used on the more obscure architectures
anyway. Triplett suggested that adding Rust into the kernel would
help drive increased architecture support for Rust, citing his experience with
the Debian project. He mentioned that introducing Rust software into
Debian helped to motivate enthusiasts and users of niche architectures
to improve Rust support, and he expected that adding support to the kernel
would have a 
similar effect. In particular, he was confident that any architecture
with an LLVM backend would quickly be supported in rustc.

<p>The conversation also discussed alternate Rust implementations as a
path toward broader architecture support. The <a href="https://github.com/thepowersgang/mrustc">mrustc</a>
project is an experimental Rust compiler that emits C
code. Using mrustc would potentially let Rust be compiled via the same
C compiler that was compiling the rest of the kernel.

<p>In addition, Triplett cited some interest in — and work toward — a Rust
front end for GCC, potentially enabling Rust to target any architecture
GCC supports. This project is in an early stage, but it presents another
avenue toward closing the architecture gap in the future.
The conclusion from this section was a little uncertain, but there did
not seem to be strong pushback against the idea of supporting Rust
device drivers without waiting for broader architecture support.

<h4>ABI compatibility with the kernel</h4>

<p>Gaynor also asked for advice on a question of ABI compatibility.
Since Rust is (currently) compiled via LLVM, and the kernel
is most commonly built with GCC, linking Rust code into the kernel may
mean mixing code emitted by GCC and LLVM. Even though LLVM aims to be
ABI-compatible with GCC, there has been some pushback based
on concerns
that this strategy created a risk of subtle ABI incompatibilities. The
presenters wondered whether the kernel community would prefer to limit
Rust support to kernels built with Clang in order to ensure
compatibility.

<p>Greg Kroah-Hartman confirmed that the current kernel rule was that
compatibility is only guaranteed if all object files in the kernel
are built with the same compiler, using identical flags. 
However, he also
expressed comfort with linking LLVM-built Rust objects into a
GCC-built kernel as long as the objects are built at the same time,
with the appropriate options set, and the resulting configurations are
fully tested. He did not feel the need for any additional restrictions until
and unless actual problems arise. Florian Weimer clarified
that ABI issues tend to be in obscure corners of the language — for
instance, returning a struct containing a bitfield by value — and
that he would expect that the core, commonly-used parts of the ABI
should pose no compatibility problems.

<p>Triplett emphasized that calling between GCC and Rust was routine and
widespread in user space, and so from the Rust side he has no concerns
about compatibility. It sounded like this concern should not, in the
end, be an impediment to bringing Rust into the kernel.

<h4>Conclusions</h4>

<p>The session ended without any further specific next steps, but it
seems that, overall, there is enthusiasm for eventually supporting
Rust modules along with increasing agreement on the broad requirements for
that support. The next big step will likely be when someone
proposes a real Rust driver for inclusion into the kernel. A concrete
use case and implementation always helps to force clarity about any
remaining contentious questions and design decisions.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Elhage_Nelson">Elhage, Nelson</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2020">Linux Plumbers Conference/2020</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/829858/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor830157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 18:41 UTC (Mon)
                               by <b>vegard</b> (subscriber, #52330)
                              [<a href="/Articles/830157/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of the underpinning principles that enable Rust&#x27;s strong memory safety guarantees is &quot;shared xor mutable&quot;. Since most of the kernel most definitely does NOT obey this rule, wouldn&#x27;t this violation &quot;infect&quot; any code written in Rust and most likely throw out the memory safety guarantees? Thanks for any insights!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 19:39 UTC (Mon)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/830158/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      This isn't unique to the kernel: for instance, atomic variables, shared data behind a mutex, etc., all nominally violate the "shared xor mutable" rule. Rust expects you to write an abstraction for the data access pattern you want, where the abstraction is generally in "unsafe Rust" (i.e., it can access raw mutable pointers without checks on sharing). The abstraction can then create either shared or unique references to data for "safe Rust" to interact with, and the compiler is able to check code using the abstraction.
<p>
If you are careful to get the abstraction right, then the compiler can tell you that you got all the users right. Note that this is much stronger than in C, where you have to be careful to get everything right. :) The compiler won't be checking 100% of your code, but the 99% that it can check does not get "infected" by the unsafe Rust you've written.
<p>
For example, Rust's <a href="https://doc.rust-lang.org/std/sync/atomic/">atomic types</a> have functions that let you modify them via shared references, even though shared references are <i>usually</i> immutable in Rust. These functions use the compiler's atomic intrinsics, and are internally implemented in "unsafe Rust" in order to perform the accesses. This way, the compiler ensures that you're not accidentally modifying atomic variables with non-atomic operations, since normal addition, assignment, etc. are forbidden on shared references. As long as a human reviewer checks that all the code in an <tt>unsafe {...}</tt> block is sound, the compiler can check everything else.
<p>
Similarly, the <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock">lock method on a Mutex object</a> takes a shared reference to a Mutex, and returns a scoped guard which provides a unique, mutable reference to the data inside. If the code to implement the lock is sound, the compiler can then guarantee that nobody using that function is accessing locked data without holding the lock.
<p>
We're using a similar pattern for our prototype bindings to RCU - we have an abstraction that calls <tt>rcu_read_lock()</tt> and returns a guard object, and the destructor for the guard object calls <tt>rcu_read_unlock()</tt>. Functions that operate on RCU-protected data require that you pass in a guard object, and they return references whose lifetime is bound to the guard object. The Rust compiler cannot automatically check the soundness of the guard object's constructor and destructor, since it doesn't know about RCU specifically, but it can definitely automatically check that you're not using an RCU-protected pointer after the guard object has been destroyed. (This pattern is based on <a href="https://docs.rs/crossbeam/0.7.3/crossbeam/epoch/index.html">crossbeam-epoch</a>, a userspace concurrency library that is very similar to RCU.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/830158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 19:44 UTC (Mon)
                               by <b>vegard</b> (subscriber, #52330)
                              [<a href="/Articles/830159/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Cool, thanks for the in-depth answer! Your examples are &quot;library functionality&quot; (atomics, locks, etc.). What happens if you want to access core kernel structures (file objects, memory mappings, struct task_struct, etc.)? To make safe abstractions for those, you would have to create Rust wrappers around everything, right?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830162"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 20:15 UTC (Mon)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/830162/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, you&#x27;d want a safe Rust wrapper to define the locking expectations / ownership and deallocation contracts / etc.<br>
<p>
That&#x27;s basically the distinction between the two approaches mentioned in the article. One approach (the one we&#x27;ve been working on) is to pick one area (e.g., filesystems and struct dentry, struct file, etc., or maybe network drivers and struct sk_buff and friends), write and review some bindings, and add a driver that is itself written safe Rust and only relies on unsafe Rust inside reusable abstractions. The other approach is to write unsafe Rust that looks mostly like idiomatic C code, which is a fair bit less work and still provides you with a bit nicer syntax than writing C but won&#x27;t take advantage of compiler-checked memory safety. (Though you could always convert such drivers to using safe wrappers later, once they exist.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830162/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830585"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 7:04 UTC (Fri)
                               by <b>vegard</b> (subscriber, #52330)
                              [<a href="/Articles/830585/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just thinking about this some more.<br>
<p>
What you say sounds &quot;easy&quot; in a way, but is it really possible at all in most cases?<br>
<p>
The Linux kernel is notorious for its use of intrusive doubly-linked lists, and Rust is notorious for the difficulty/discouragement of linked lists. Surely if it was just a matter of finding a safe abstraction in Rust (i.e. wrapper around unsafe code), Rust would also have easy-to-use linked lists?<br>
<p>
If I remember correctly, whenever you have two pieces of unsafe code that individually present a &quot;safe&quot; interface, there is a possibility of an interaction that makes the combination unsafe, most famously &lt;<a href="https://github.com/rust-lang/rust/issues/24292">https://github.com/rust-lang/rust/issues/24292</a>&gt;. A whole bunch of people have worked on proving that all these safe abstractions are safe in the presence of each other (i.e. the RustBelt project). Wouldn&#x27;t we need a whole bunch of verification work to make this work for the kernel?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830585/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830589"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 8:45 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/830589/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Rust has <a href="https://doc.rust-lang.org/std/collections/struct.LinkedList.html">a standard library linked list</a>, and the abstractions for <a href="https://docs.rs/intrusive-collections/0.9.0/intrusive_collections/linked_list/index.html">instrusive double-linked list</a> and <a href="https://docs.rs/intrusive-collections/0.9.0/intrusive_collections/singly_linked_list/index.html">intrusive single-linked list</a> have been written.
<p>The reason linked lists are discouraged in Rust apply to C and assembly, too - they are fundamentally all about pointer chasing, and that's the hardest thing for a CPU to perform well at; other data structures are normally what you want, but the emphasis on linked lists in formal education (and in languages with "sufficiently smart" compilers like Haskell) means that people reach for them when they're the wrong choice.
      
          <div class="CommentReplyButton">
            <form action="/Articles/830589/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830599"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 9:30 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830599/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; whenever you have two pieces of unsafe code that individually present a &quot;safe&quot; interface, there is a possibility of an interaction that makes the combination unsafe</font><br>
<p>
The problem in the issue you linked to was JoinGuard assuming safe Rust doesn&#x27;t leak. In fact, safe Rust is allowed to leak. So this problem wasn&#x27;t due to an interaction between unsafe code modules, but because one piece of unsafe code assumed a property of safe Rust code that doesn&#x27;t necessarily hold.<br>
<p>
This was an understandable mistake in 2015 because then there wasn&#x27;t as clear a picture of what the invariants around safe Rust actually are. The picture is clearer now, although still not fully clear. So maybe in the future some invariants will be clarified that invalidate the assumptions made by some unsafe code --- but even then, there is no general problem of &quot;the possibility of an interaction that makes the combination unsafe&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830599/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor830164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 20:21 UTC (Mon)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/830164/">Link</a>] (34 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In addition, Triplett cited some interest in — and work toward — a Rust front end for GCC, potentially enabling Rust to target any architecture GCC supports. This project is in an early stage, but it presents another avenue toward closing the architecture gap in the future.</font><br>
<p>
Context here: I was mentioning the nascent gcc-rust project at <a href="https://github.com/sapir/gcc-rust/">https://github.com/sapir/gcc-rust/</a> , which compiles Rust&#x27;s &quot;MIR&quot; intermediate representation. It&#x27;d take some more work to turn this into a full solution, but it&#x27;s a potential option, and it would avoid unnecessarily reimplementing the frontend of rustc.<br>
<p>
Another possibility mentioned at LPC would be a rustc backend that uses libgccjit to generate code; despite the name, libgccjit also works for ahead-of-time code generation.<br>
<p>
In any case, there are many paths to supporting all the architectures people are willing to support. I&#x27;d also love to have the competition in code generation backends, to make sure we&#x27;re getting the best code generation possible, and to enable cross-language LTO with either GCC or Rust.<br>
<p>
<font class="QuotedText">&gt; The mrustc project is an experimental Rust compiler that emits C code. Using mrustc would potentially let Rust be compiled via the same C compiler that was compiling the rest of the kernel. </font><br>
<p>
mrustc is mostly a bootstrapping tool; it doesn&#x27;t compile current Rust, and it has no safety checks whatsoever, so it&#x27;s only useful on code you&#x27;ve already tested with another compiler. It&#x27;s not designed to generate efficient code; it&#x27;s designed to generate functional code, so that you can bootstrap rustc without a Rust compiler (by compiling an old version of rustc with mrustc, then walking forward a few steps to current rustc). It&#x27;s unlikely to be a path forward for supporting additional architectures.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830207"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 6:51 UTC (Tue)
                               by <b>CChittleborough</b> (subscriber, #60775)
                              [<a href="/Articles/830207/">Link</a>] (32 responses)
      </p>
      
      </div>
      </summary>
      Rust runs on a 6-week release cycle (like Firefox), and each release seems to bring some changes to the language, and therefore to the compiler front-end. (OTOH, in recent releases the language changes have been relatively small). Trying to re-implement the whole compiler would involve lots of churn. So starting from <a href="https://rustc-dev-guide.rust-lang.org/mir/index.html">the MIR (Mid-level IR)</a> seems much wiser, IMHO.
<p>
Of course, a backend that can translate MIR into GCC's internal representation would be a major win not only for Linux but also for Rust itself.
      
          <div class="CommentReplyButton">
            <form action="/Articles/830207/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830213"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 12:18 UTC (Tue)
                               by <b>BirAdam</b> (guest, #132170)
                              [<a href="/Articles/830213/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That release cycle is precisely why Rust shouldn’t be a systems language at all, and shouldn’t be used for any sizable project either. The cost added to development to use a constantly changing language is simply too high. This is especially true of a language that claims to be more secure. If your security is gained by constant refactoring due to depracations and new features then it is only lite secure by creating changing targets.<br>
<p>
This answer was largely fueled by annoyance with Code Hipsters...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830213/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830214"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 12:57 UTC (Tue)
                               by <b>Deleted user 129183</b> (guest, #129183)
                              [<a href="/Articles/830214/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That release cycle is precisely why Rust shouldn’t be a systems language at all</font><br>
<p>
Yeah, that’s one of reasons why I think that Linux shouldn’t jump on the Rust bandwagon… yet. More mature languages have been rejected in the past to be used for Linux code, and by now we cannot be sure if Rust would last, or it’s just a passing fad, to be forgotten in a few years in favour of some other, more “trendy” language. Let’s wait until Rust stabilises and starts to be used for anything but just Firefox and some toy projects (mostly of the RIIR variety), and *then* consider it for being used to program Linux.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830214/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 15:25 UTC (Tue)
                               by <b>Nahor</b> (subscriber, #51583)
                              [<a href="/Articles/830283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At the time, its adoption by the kernel would go a long way toward the critical masse necessary for its stability and longer lifespan, not the least of it because it would also drive its adoption by other projects and commercial entities as well (see git history).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 22:11 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830314/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://www.rust-lang.org/production/users">https://www.rust-lang.org/production/users</a><br>
<p>
That doesn&#x27;t include some notable big-tech Rust users such as Fuschia (Google) and Firecracker (Amazon).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830337"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 4:15 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830337/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hey look, just today:<br>
<p>
<a href="https://aws.amazon.com/blogs/opensource/announcing-the-general-availability-of-bottlerocket-an-open-source-linux-distribution-purpose-built-to-run-containers/">https://aws.amazon.com/blogs/opensource/announcing-the-ge...</a><br>
<p>
<font class="QuotedText">&gt; Large parts of Bottlerocket are written in Rust, a modern programming language that helps ensure thread safety and prevent memory-related errors, such as buffer overflows that can lead to security vulnerabilities.</font><br>
<p>
&quot;starts to be used for anything but just Firefox and some toy projects&quot; my foot.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830337/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2020 0:32 UTC (Thu)
                               by <b>himi</b> (subscriber, #340)
                              [<a href="/Articles/830455/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, and on top of that I keep seeing new projects coming along which are starting out with Rust (the one I most recently started using in my workflow is gitui, which is all of six months old but which is already a very useful tool). It&#x27;s pretty cleat that Rust has a /lot/ of momentum at the moment, and is on a pretty fast growth path. That doesn&#x27;t mean it&#x27;s future proof, or ready for all possible use cases, or even a better choice than any given alternative for a particular use case, but it does mean it&#x27;s far, /far/ past the point where it has one primary sponsor and a bunch of toy projects.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor830340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 6:04 UTC (Wed)
                               by <b>edomaur</b> (subscriber, #14520)
                              [<a href="/Articles/830340/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The release cycle and the API and ABI stability aren&#x27;t related : you can chose a target &quot;LTS edition&quot; of the language, incoporated in the rustc compiler, and Rust also support raw identifiers for helping working with older release. <br>
<p>
And about the &quot;Firefox and some toy projects&quot; part of your comment, well, it&#x27;s funny but it&#x27;s wrong, look again :-) Amazon run it&#x27;s Lambda system on Firecracker, which they wrote in Rust, Dropbox replaced Python and Go by Rust in their MagicPocket storage system, OVH use it for their custom log application, Cloudflare is pushing new tools and services written in Rust, etc. <br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor830221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 14:27 UTC (Tue)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/830221/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The fact that they release frequently does not mean that they break compatibility often. The parent commenter was talking about keeping an independent compiler up to date with new Rust features, not about keeping Rust code working and relevant.<br>
<p>
You&#x27;re presumably using a kernel with a ~10-week release cycle, would you claim that fact makes Linux unstable and unsuitable for sizable projects?<br>
<p>
Rust is *serious* about stability. Since the Rust 1.0 release in May 2015, they have committed to backwards compatibility. Like Linux, they have a stable &quot;user space interface&quot; (language definition) and internal unstable interfaces (intermediate forms passed to code generation). The second is why keeping a GCC backend up to date is complicated.<br>
<p>
<font class="QuotedText">&gt; If your security is gained by constant refactoring due to depracations [...]</font><br>
<p>
Rust only breaks backwards compatibility in 1.x releases is when necessary to fix safety/soundness bugs. They have happened, but very rarely and with minimal impact as far as I have seen. Even such fixes have been made gradually over multiple releases, not as flag day releases.<br>
<p>
One example here: <a href="https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html">https://blog.rust-lang.org/2019/11/01/nll-hard-errors.html</a> , these bugs were quite rare in the wild, but the deprecation window lasted from December 2018 (deprecated behavior started emitting warnings) to December 2019. They went through significant pains to keep around two borrow checker implementations during that period.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830279"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 15:11 UTC (Tue)
                               by <b>mkubecek</b> (guest, #130791)
                              [<a href="/Articles/830279/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Kernel may have 9-10 week release cycle but the fact is that this year we raised the gcc version requirement from 4.6 (2011) to 4.9 (2014). In a similar fashion, the number of patches needed to build older (e.g. 10 year old) kernels with today&#x27;s gcc is surprisingly small.<br>
<p>
You may claim that rust is stable but my experience is very different. It was the rust dependency what forced me to give up on building firefox development snapshots. I tried really hard but there was no chance to keep up with the dependencies on latest versions of rust toolchain. The idea that one day I might need rust toolchain to build kernel is a nightmare for me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830279/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830293"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 17:24 UTC (Tue)
                               by <b>Baughn</b> (subscriber, #124425)
                              [<a href="/Articles/830293/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Firefox development drives (drove?) Rust development, so of course it requires the latest nightly build.<br>
<p>
There&#x27;s no requirement for doing the same with Linux. Programs written against stable Rust ~never need changes due to new Rust releases.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830293/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 21:54 UTC (Tue)
                               by <b>mkubecek</b> (guest, #130791)
                              [<a href="/Articles/830312/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;no requirement for doing the same&quot; is not nearly enough, if rust in kernel is to be considered, it should rather be &quot;guarantees that it cannot happen&quot;. And even then I would be very unhappy about the prospect of mixing a new language with very different logic into C codebase (and adding dependency on its toolchain).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830315"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 22:17 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830315/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is pretty easy to satisfy. With the &quot;clippy&quot; tool you can easily implement custom lints to restrict the use of new language features, and run those in CI. For a project like the kernel you eventually want custom lints anyway.<br>
<p>
Another approach would be to have a CI checker that simply runs &quot;cargo check&quot; (or the equivalent if you&#x27;re not using cargo) with a fixed version of a compiler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830315/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830342"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 6:07 UTC (Wed)
                               by <b>edomaur</b> (subscriber, #14520)
                              [<a href="/Articles/830342/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In fact, it&#x27;s the same as with GCC : the kernel require a specific version of a compiler, it can/should be the same with rustc, anchoring the Rust kernel code to a specific version.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830342/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 6:42 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830344/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
rustc is different because they don&#x27;t provide updates to any compiler branches other than the current release, so using a fixed release indefinitely to generate shipping code is not a good idea.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830358"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 10:39 UTC (Wed)
                               by <b>vomlehn</b> (guest, #45588)
                              [<a href="/Articles/830358/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Every real project I&#x27;ve worked on reached a point where there were specific stability points, e.g. git branches. Only bug fixes get added to the branches. This is the way the kernel stable releases work. I would expect the same to emerge shortly for Rust as pretty much all Rust users are going to required it. It&#x27;s nothing fundamental to Rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830358/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830447"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 22:49 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830447/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are large projects where the number of stable branches is very small and and the duration for which they are maintained is not very long. E.g. for Chrome there is only one stable branch and it is maintained for no more than six weeks. For Firefox there are two and the longer one (ESR) is maintained for one year. I believe the Google monorepo never has a stable branch.<br>
<p>
I see no reason why Rust will need long-lived stable branches.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830447/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830462"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2020 6:04 UTC (Thu)
                               by <b>edomaur</b> (subscriber, #14520)
                              [<a href="/Articles/830462/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  I see no reason why Rust will need long-lived stable branches.</font><br>
<p>
For embedded systems certification it will be needed, specially in telecom and medical areas. For example, some times ago I used Telit GSM modem which had a Python interpreter available inside, but even if the current Python was already 2.7, the provided interpreter had to be a v1.5.8 because of the time it took to pass the certification. And in the medical world it&#x27;s even worse than that.<br>
<p>
To be honest, I think that the Rust community will add an LTS version for the purpose, sometime in the future, but it&#x27;s not the priority at the moment.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830462/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830558"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2020 22:43 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830558/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah yes, you&#x27;re right about that domain. I guess you&#x27;re talking about Sealed Rust attempting to meet that need: <a href="https://ferrous-systems.com/blog/sealed-rust-the-pitch">https://ferrous-systems.com/blog/sealed-rust-the-pitch</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830558/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2020 7:13 UTC (Sun)
                               by <b>edomaur</b> (subscriber, #14520)
                              [<a href="/Articles/830773/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, yes, I forgot Sealed Rust but it&#x27;s exactly why I meant.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor830461"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2020 5:06 UTC (Thu)
                               by <b>kenmoffat</b> (subscriber, #4807)
                              [<a href="/Articles/830461/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My experience is that what builds now in *released* versions of mozilla or ex-mozilla packages (firefox-esr, thunderbird, seamonkey) is often broken by the second or third next rust release.<br>
<p>
At least some of this appears to be that things which used to be permitted are now prohibited.<br>
<p>
It gives me little confidence that there is stability in rust and therefore I doubt that using it for the kernel can both produce code which compiles with a three-year-old version of rust (which might be expected towards the end of a long-term kernel&#x27;s lifetime), and which offers the wonderful guarantees of safety.<br>
<p>
I use BLFS and we put rust in /opt with a symlink from /opt/rustc to the running version - to change that is a simple matter of remaking the symlink and running ldconfig. That allows me to use a newer version for building latest firefox, and when something else wants a newer rust (librsvg has been a common pain for that) it lets me test what can easily move to the newer rust, and what cannot. Usually, it is painful for at least one package.<br>
<p>
Meanwhile, I&#x27;m reluctant to try newer versions of rust (currently on 1.45.latest) because experiments with the first -rc from the forthcoming llvm showed that rust could no-longer build with system llvm. At one time in the past rust would build with system llvm, but miscompile firefox. Generally, when llvm or rust changes I expect pain.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830461/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2020 12:47 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/830470/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  My experience is that what builds now in *released* versions of mozilla or ex-mozilla packages (firefox-esr, thunderbird, seamonkey) is often broken by the second or third next rust release.</font><br>
<p>
That&#x27;s because those programs manually opt-in to unstable/prototype/still-in-development features: <a rel="nofollow" href="https://doc.rust-lang.org/unstable-book/index.html">https://doc.rust-lang.org/unstable-book/index.html</a><br>
<p>
By the same logic, you could say that C or C++ are unstable, because GCC lets you pass a special flag to opt-in to unstable features that might break in a future release. Quoting the GCC docs:<br>
<p>
<font class="QuotedText">&gt; C++20 features are available since GCC 8. To enable C++20 support, add the command-line parameter -std=c++20 (use -std=c++2a in GCC 9 and earlier) to your g++ command line. [...] *Important:* Because the ISO C++20 standard is still evolving, GCC&#x27;s support is experimental. No attempt will be made to maintain backward compatibility with implementations of C++20 features that do not reflect the final standard.</font><br>
<p>
- <a rel="nofollow" href="https://gcc.gnu.org/projects/cxx-status.html">https://gcc.gnu.org/projects/cxx-status.html</a><br>
<p>
This is totally under control of the project – if the kernel doesn&#x27;t specifically request unstability, they won&#x27;t get unstability.<br>
<p>
<font class="QuotedText">&gt; Meanwhile, I&#x27;m reluctant to try newer versions of rust (currently on 1.45.latest) because experiments with the first -rc from the forthcoming llvm showed that rust could no-longer build with system llvm.</font><br>
<p>
Yeah, llvm is a fast-moving project with no API stability, so it&#x27;s very difficult to use &quot;system llvm&quot; :-/<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830707"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2020 7:36 UTC (Sat)
                               by <b>kenmoffat</b> (subscriber, #4807)
                              [<a href="/Articles/830707/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Off the top of my head, various issues in the past year or eighteen<br>
months with seamonkey releases, and I think there was one problem with thunderbird. Now that thunderbird is on similar versions to<br>
firefox-esr (for full releases) I don&#x27;t expect many new problems with that.<br>
<p>
For seamonkey the problem was in 2.53.1 when we wanted to move from rustc-1.37.0 to rustc-1.41.0.  We want one version of rustc for all the packages in BLFS, so at the moment we are using firefox-esr and rustc-1.42.0 (and the current seamonkey release is fine).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830707/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830737"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2020 23:28 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830737/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m actually interested in the details of what backwards-incompatibility you encountered in each case.<br>
<p>
I&#x27;m aware of a couple of soundness fixes that might possibly have affected you but other than that, I&#x27;m not aware of any backwards-incompatibilities that hit anything real.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830737/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830741"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2020 0:19 UTC (Sun)
                               by <b>kenmoffat</b> (subscriber, #4807)
                              [<a href="/Articles/830741/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Mostly, I don&#x27;t have the details - if the current release fails to build with a newer rust then I don&#x27;t have the skills to track it down. In generally, when a package FTBFS I hope to not be on the bleeding edge and to find that soemone has already solved the problem. But finding relevant search results is increasingly problematic. <br>
<p>
But for seamonkey I eventually discovered they were tracking this and had a series of patches, the bug for tracking current rust versions is at <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1617782">https://bugzilla.mozilla.org/show_bug.cgi?id=1617782</a> and the first several attachments were needed to enable 2.53.1 to be build with whichever version of rust was current at the time - I hit it in February, it was in March that I found the patches (there was a link from an Arch posting).<br>
<p>
I think that bug might have details of how the build failed for each item.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830741/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830766"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2020 3:25 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830766/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks!!!<br>
<p>
One issue is due to &quot;#![deny(warnings)]&quot;. This is similar to C++, where if you build with -Werror you will break frequently. Libraries need to not use that.<br>
<p>
One is a build system issue where the requirements for LTO changed.<br>
<p>
The rest seems to be issues in rust-url but I can&#x27;t see what the actual issues were :-(.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830766/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830792"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2020 19:30 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/830792/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p><tt>#[!deny(warnings)]</tt> sounds like a failure to communicate inside the build system; at the rustc level, there's a <a href="https://doc.rust-lang.org/beta/rustc/lints/levels.html#capping-lints"><tt>--cap-lints</tt></a> option to turn "deny" into "warn" or "allow". I know Cargo threads that through to dependencies, but right now, there's <a href="https://github.com/rust-lang/cargo/issues/3591">no easy way to supply it to <tt>cargo build</tt>, bar setting the <tt>RUSTFLAGS='-A dead_code'</tt> environment variable</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/830792/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor830598"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 9:20 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830598/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can you give some examples of Mozilla releases that build with stable Rust but are broken by later Rust releases? I have not seen this more than a couple of times in my project over the last four years.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830598/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 13:36 UTC (Fri)
                               by <b>tdz</b> (subscriber, #58733)
                              [<a href="/Articles/830608/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A couple of times within four years is already quite a bit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830662"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 16:19 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/830662/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Most of my experience with it has been dependencies jumping onto new features once they stabilize. These tend to happen in waves as larger features land. Some of the latest points I&#x27;ve seen:<br>
<p>
  - 2018 edition<br>
  - byte accesses on primitive types (to_le(), as_bytes(), etc.)<br>
  - code changes to take advantage of NLL<br>
  - async/await<br>
  - feature(doctest)<br>
<p>
These usually have 3-4 releases between them.<br>
<p>
If you want to avoid these kinds of things, keep a Cargo.lock and you&#x27;ll stick with versions that continue to work. Very rarely things do get removed in Rust updates, but these are typically soundness issues that can cause problems if they are used improperly. Luckily crater can be used to fix it across the (FOSS) ecosystem pretty easily. Release notes are well-written and short enough that anyone else can read and follow along.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830662/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830738"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2020 23:32 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830738/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An hour of work spread over two years is insignificant.<br>
<p>
C++ compilers have backwards incompatibilities and just plain compilation bugs at a similar low rate.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830738/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor830710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2020 9:18 UTC (Sat)
                               by <b>kenmoffat</b> (subscriber, #4807)
                              [<a href="/Articles/830710/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, I managed to reply in the wrong place - currently just above your question.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831345"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">MIR is a wiser choice</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2020 14:53 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/831345/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Firefox 79.0 failed to build with Rust 1.45.x+: <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1654465">https://bugzilla.mozilla.org/show_bug.cgi?id=1654465</a> (seriously misleading bug title because the failure-to-build wasn&#x27;t clear until halfway down the discussion thread). Now admittedly 1.45 wasn&#x27;t out at the time FF 79 was released, but still it took over a month to backport the relevant patch from ff trunk...<br>
<p>
This is not what I would describe as a showstopper, though, because it only happens with LTO so it&#x27;s easy to fix by just not using LTO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831345/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor830329"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A libgccjit codegen for rustc is already work-in-progress</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 1:48 UTC (Wed)
                               by <b>antoyo</b> (guest, #141125)
                              [<a href="/Articles/830329/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;ve been working for a while on a libgccjit-based codegen for rustc: it can compile a hello world using the standard library and can generate code for quite a few other features, but many programs won&#x27;t be compiled correctly yet.<br>
<p>
Here&#x27;s the link to the repository: <a rel="nofollow" href="https://github.com/antoyo/rustc_codegen_gcc">https://github.com/antoyo/rustc_codegen_gcc</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830329/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor830173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 21:19 UTC (Mon)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/830173/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What&#x27;s the plan for the other copy_from/to_user() form?<br>
<p>
template&lt;typename T&gt;<br>
int copy_from_user(T* k, user_ptr&lt;T&gt; u);<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830174"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 21:32 UTC (Mon)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/830174/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
and this is just terrible. First, only _interruptible/_killable version fail. Second, 9 lines to take proxy preference and then 7 lines to do what could be done statically in 1 line.<br>
<p>
pub extern &quot;C&quot; fn init_module() -&gt; i32 {<br>
    let mut mutex_guard = MUTEX.acquire();<br>
    let parrot_ref = match mutex_guard.get_mut() {<br>
        Some(p) =&gt; p,<br>
        None =&gt; {<br>
            unsafe {<br>
                printk!(&quot;%s&quot;, to_ptr!(c_string!(&quot;Failed to get reference to global state&quot;)))<br>
            };<br>
            return -1;<br>
        }<br>
    };<br>
    match parrot_ref.init() {<br>
        Ok(_) =&gt; 0,<br>
        Err(e) =&gt; {<br>
            unsafe { printk!(&quot;%s&quot;, to_ptr!(e)) };<br>
            -1<br>
        }<br>
    }<br>
}<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830174/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 22:52 UTC (Mon)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/830189/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, the parrot example is a (quick) demo of writing a Rust kernel module without specific bindings. It&#x27;s not intended to be an example of what Rust code in the kernel should look like.<br>
<p>
<a href="https://github.com/fishinabarrel/linux-kernel-module-rust/blob/master/src/user_ptr.rs">https://github.com/fishinabarrel/linux-kernel-module-rust...</a> is safe bindings to copy_from_user / copy_to_user. See the rest of that repository for examples of its use.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor830175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 21:39 UTC (Mon)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/830175/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You appear to be quoting C++ code, and it&#x27;s not clear what you&#x27;re referring to.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830176"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 21:41 UTC (Mon)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/830176/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
copy_from_user/copy_to_user of a structure, not char[] buffer<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830176/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 22:19 UTC (Mon)
                               by <b>nickodell</b> (subscriber, #125165)
                              [<a href="/Articles/830182/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I assume that Rust has an equivalent of the C++ reinterpret_cast.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830184"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 22:23 UTC (Mon)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/830184/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It does. We also have work in progress to provide a safe way to do that, via the &quot;safe transmute&quot; project.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830184/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830185"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 22:25 UTC (Mon)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/830185/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Cast covers implementation part, what about interface? I&#x27;ve posted what C++ would do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830185/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 22:47 UTC (Mon)
                               by <b>notriddle</b> (subscriber, #130608)
                              [<a href="/Articles/830187/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Rust version of reinterpret_cast is called transmute. <a href="https://doc.rust-lang.org/stable/std/mem/fn.transmute.html">https://doc.rust-lang.org/stable/std/mem/fn.transmute.html</a><br>
<p>
But copy_from_user itself looks closer to ptr::copy. <a href="https://doc.rust-lang.org/stable/std/ptr/fn.copy.html">https://doc.rust-lang.org/stable/std/ptr/fn.copy.html</a><br>
<p>
Both of these functions are unsafe, as any form of copy_from_user must be, since there&#x27;s no way to be sure that the contents of userspace memory are valid for whatever data structure you&#x27;re transmuting them into. You would need to ensure that the data structure in question can accept any arbitrary byte sequence, which is what &quot;safe transmute&quot; proposals are supposed to do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830186"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 22:55 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/830186/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I assume that Rust has an equivalent of the C++ reinterpret_cast.</font><br>
<p>
It exists (you can cast raw pointers from one type to another and dereference them within unsafe blocks) but, like reinterpret_cast, you need to be very careful about how you use it. This is one area where it is probably easier to accidentally trigger undefined behavior in unsafe Rust code than in C, since Rust places more constraints on pointers/references than C does. At a minimum the target object would need to have a repr(C) type to ensure a consistent ABI, and the Copy trait as evidence that the content can be safely duplicated with a straightforward byte copy. The operation itself would also need to be marked as &quot;unsafe&quot; since there is no way that overwriting a Rust object (even one which is Copy and repr(C)) with arbitrary data from a buffer can be guaranteed to preserve whatever invariants might be expected by the object&#x27;s implementation. With all that said, however, the std::ptr::read_unaligned function[1] is fairly close to a typed copy_from_user—without, obviously, the extra checking and error recovery that comes with accessing user memory from kernel mode.<br>
<p>
[1] <a href="https://doc.rust-lang.org/std/ptr/fn.read_unaligned.html">https://doc.rust-lang.org/std/ptr/fn.read_unaligned.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830186/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor830326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 1:14 UTC (Wed)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/830326/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One is inclined to think that they are looking for a new home to support and fund them now that Mozilla laid them off.<br>
<p>
I’m also not convinced… needing to port multiple compilers etc. to enable a new architecture is a significant barrier (just porting gcc+binutils is hard enough), and this will split contributors into those who can and those who can’t deal with rust code… and if someone’s tracking an error and ends up (or passes through) rust code, this will suck for those who don’t use it (i.e. anyone not Mozilla).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830338"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 4:19 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830338/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
See my comments up above. There are far more people using Rust (in production) outside Mozilla than inside it, and that has been true for years. Claiming that no-one outside Mozilla uses Rust is just weirdly out of touch.<br>
<p>
<font class="QuotedText">&gt; they are looking for a new home to support and fund them now that Mozilla laid them off.</font><br>
<p>
This is also out of touch. For years Mozilla has been steadily reducing the number of people they pay to work on Rust. For years the vast majority of the work going into Rust has come from the community beyond Mozilla.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830338/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830413"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 16:34 UTC (Wed)
                               by <b>edomaur</b> (subscriber, #14520)
                              [<a href="/Articles/830413/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, as they said there <a href="https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html">https://blog.rust-lang.org/2020/08/18/laying-the-foundati...</a>  :<br>
<p>
<font class="QuotedText">&gt; Further, it is a common misconception that all of the Mozilla employees who participated in Rust leadership did so as a part of their employment. In fact, many Mozilla </font><br>
<font class="QuotedText">&gt; employees in Rust leadership contributed to Rust in their personal time, not as a part of their job.</font><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830413/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor830362"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 12:23 UTC (Wed)
                               by <b>darwi</b> (subscriber, #131202)
                              [<a href="/Articles/830362/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m not convinced this is good for the health of the kernel community. You risk splitting the community, and people squeezing-in every &quot;cool&quot; rust feature under the sun. Due to C&#x27;s simplicity, it is very easy to get drive-by contributions and get a constant stream of new developers. Meanwhile, it&#x27;s sometimes quite hard to get the damn rust code to even compile...<br>
<p>
If the concept of a new language in the kernel is now open, then honestly C++2x would be a much better option. The whole kernel will be built with one compiler, the benefits can cover the core kernel components (not just things in the margin), and boot-strapping new architectures would still be simple.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830362/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 16:48 UTC (Wed)
                               by <b>rgmoore</b> (<b>&#x272D; supporter &#x272D;</b>, #75)
                              [<a href="/Articles/830409/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>If the concept of a new language in the kernel is now open, then honestly C++2x would be a much better option.</blockquote>

<p>It's not likely to happen as long as Linus is in charge.  He has been very negative about C++ for a long time, and there's no indication that's going to change.  As I understand his view, Linus doesn't see C++ as bringing in any real capabilities that the kernel needs, while it does massively expand the size of the language in a way that makes it very difficult to keep everyone using the same abstractions.  There's a reason people who talk about how great C++ is always talk about the need to use a limited subset of the language.

<p>In contrast, Rust brings some capabilities for memory management that are sorely lacking in C and C++.  The ability to exclude whole categories of error is potentially really valuable, and one can see why kernel developers would like to add those capabilities to their toolbox.
      
          <div class="CommentReplyButton">
            <form action="/Articles/830409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830904"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 8:36 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830904/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There&#x27;s a reason people who talk about how great C++ is always talk about the need to use a limited subset of the language.</font><br>
<p>
<a href="https://www.google.com/search?q=alex+gaynor+holding+it+wrong">https://www.google.com/search?q=alex+gaynor+holding+it+wrong</a><br>
<p>
You can write bug-free code in any language. It&#x27;s just orders of magnitude harder with some.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830904/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor830421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 17:10 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/830421/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Due to C&#x27;s simplicity, it is very easy to get drive-by contributions and get a constant stream of new developers</font><br>
<p>
Sure, for things like typos, whitespace changes, and other changes on a similar level. But that&#x27;s not language specific in any way. The scheduler, mm, and vfs subsystems being in C doesn&#x27;t help me making any kind of substantial change.<br>
<p>
I&#x27;d actually argue that having the ability to spell out better idioms and having things like ownership tracked as part of APIs would make it *easier* to contribute because the compiler can catch the &quot;dumb&quot; mistakes and leave the reviewers just having to look at the actually complicated parts instead of having to worry about &quot;oh, I see a lock here, did you unlock it?&quot; or &quot;this data should be accessed under a lock, did you acquire it properly?&quot; kinds of questions because you can enforce such things in the API directly.<br>
<p>
<font class="QuotedText">&gt; If the concept of a new language in the kernel is now open, then honestly C++2x would be a much better option.</font><br>
<p>
Ha. I don&#x27;t think it&#x27;d be that much of an improvement. For one, the plain makefiles for building the kernel would almost certainly be insufficient (unless you&#x27;re going to ban modules).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830452"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 23:15 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830452/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust code being hard to compile is an *advantage* for maintainers of large projects like the kernel.<br>
<p>
It&#x27;s hard to compile because the Rust compiler does a lot more checking. If submitted code doesn&#x27;t use &quot;unsafe&quot; then the reviewer knows those checks have been satisfied and the code doesn&#x27;t have hidden data races, hidden memory errors, etc. Rust moves work from the code reviewer to the code contributor. In my experience with the kernel contribution process this is something the kernel maintainers are very much in favour of. (It&#x27;s actually better for the contributor too, since running the Rust compiler makes a much faster feedback cycle than getting it reviewed by maintainers.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830452/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830661"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 16:12 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/830661/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Rust code being hard to compile is an *advantage* for maintainers of large projects like the kernel.</font><br>
<p>
Clarification (since I suspect this is what roc meant): I find Rust code far easier to compile than C or C++. Getting the compiler to accept the code is what is harder :) .<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830661/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor830695"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 23:31 UTC (Fri)
                               by <b>bored</b> (subscriber, #125572)
                              [<a href="/Articles/830695/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is maybe the core of the argument, while rust (and C++) both bring things to the table, there is a lot of crossover between the functionality they provide. Which means mostly your just adding additional cognitive load  for people who have to maintain the kernel as a whole. Now a developer has to be an expert in not only C and the compiler&#x27;s code generation, but rust as well. The kernel is already got python, bash, make, etc i&#x27;m not sure it really needs another language. Particularly rust which is quickly becoming a write only language to work around all the edge cases that crop up. Maybe in another ~10 years when its has a lot more developer support and has a proven track record. For all we know at this point rust is going to be just another ada/etc.<br>
<p>
<p>
<p>
 <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830695/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830740"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2020 23:38 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/830740/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, adding Rust or anything not-kernel-C adds cognitive load, so that must be part of the cost-benefit analysis.<br>
<p>
The cognitive load for Rust is much lower than for C++ though; C++ is a much bigger and hairier language, and demands much more effort from the developer to avoid UB.<br>
<p>
<font class="QuotedText">&gt; Particularly rust which is quickly becoming a write only language to work around all the edge cases that crop up.</font><br>
<p>
I have no idea what this is about. I read third-party Rust code a lot. If Rust&#x27;s &quot;edge cases&quot; bother you then C++ must be completely off the table.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830740/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830768"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2020 3:44 UTC (Sun)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/830768/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust and updating code to handle &quot;edge cases&quot; is exactly what is so great about Rust. Yes, you might have to rewrite 300 lines of code to fix that edge case. And it will be done correctly.<br>
<p>
In my 25 years of experience doing C++ (not always full time) the worst bugs are created by the &quot;quick fixes&quot; where somebody makes &quot;just a small change&quot; which seems to work, but in reality has just created a black hole of undefined behavior where tiny code changes in other parts of the code will destroy the storage used by your dangling pointer/reference to a deallocated temporary std::string. Now with bonus C++11 behavior where it depends on how long the string was.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830768/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor830764"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2020 3:18 UTC (Sun)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/830764/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C is not simple. It only *looks* simple to you because of survivor bias; the worst crap gets filtered out through the kernel&#x27;s multiple layers of review and rejection. The same would be true of Rust code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830764/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor830897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Supporting Linux kernel development in Rust</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2020 5:50 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830897/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The ubiquitous kmalloc() function, for instance, is defined as __always_inline, meaning that it is inlined into all of its callers and no kmalloc() symbol exists in the kernel symbol table for Rust to link against.</font><br>
<p>
&quot;Inlining&quot; does not imply &quot;no standalone function&quot;. These are of course related yet different things. There is a number of cases where a standalone function is created even when the calls are inlined. Simple example from  <a href="https://gcc.gnu.org/onlinedocs/gcc/Inline.html">https://gcc.gnu.org/onlinedocs/gcc/Inline.html</a> :<br>
<p>
<font class="QuotedText">&gt; The function must also be compiled as usual if the program refers to its address, because that cannot be inlined.</font><br>
<p>
Wouldn&#x27;t a reference to the address of kmalloc() be simpler than &quot;defining a kmalloc_for_rust() symbol containing an un-inlined version&quot;?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
