        <!DOCTYPE html>
        <html lang="en">
        <head><title>Capability analysis for the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/1012990/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/1013185/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/1012990/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Capability analysis for the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>March 10, 2025</br>
           </div>
One of the advantages of the Rust type system is its ability to encapsulate
requirements about the state of the program in the type system;
often, this state includes which locks must be held to be able to carry out
specific operations.  C&nbsp;lacks the ability to express these
requirements, but there would be obvious benefits if that kind of feature
could be grafted onto the language.  The Clang compiler has made some
strides in that direction with its <a
href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html">thread-safety
analysis</a> feature; two developers have been independently working to
take advantage of that work for the kernel.
<!-- middle-ad -->
<p>
The Clang feature is based on the concept of "capabilities" that a program
can be determined — at compile time — to hold (or not) at any given point.
Capabilities are typically the address of a data structure; for example,
the address of a specific spinlock can be designated as a capability that a
program can acquire with a lock operation.  Functions can be annotated to
indicate that they acquire or release a capability; developers can also
indicate that callers of a function must hold (or <i>not</i> hold) a
specific capability.
<p>
<h4>Adding analysis to the kernel</h4>
<p>
Bart Van Assche posted <a
href="/ml/all/20250206175114.1974171-1-bvanassche@acm.org">a patch
series</a> on February&nbsp;6 showing how Clang's thread-safety feature
could be used with the kernel's mutex type.  The core of this work can be
found in <a href="/ml/all/20250206175114.1974171-7-bvanassche@acm.org">this
patch</a>, which annotates the various mutex-related functions; for
example, the prototype for <tt>mutex_lock()</tt> and
<tt>mutex_unlock()</tt> are modified to be:
<p>
<pre>
    void mutex_lock(struct mutex *lock) ACQUIRE(*lock);
    void mutex_unlock(struct mutex *lock) RELEASE(*lock);
</pre>
<p>
The first line says that a call to <tt>mutex_lock()</tt> will gain a
capability in the form of the pointed-to mutex, while calling
<tt>mutex_unlock()</tt> will give up that capability.  The
<tt>ACQUIRE()</tt> and <tt>RELEASE()</tt> macros are built on top of
Clang's lower-level macros; there are <a
href="/ml/all/20250206175114.1974171-4-bvanassche@acm.org">quite a few</a>
other macros in the set.  With that infrastructure in place, any function
that requires a specific mutex to be held can be annotated accordingly; for
example:
<p>
<pre>
     static struct devfreq_governor *try_then_request_governor(const char *name)
	REQUIRES(devfreq_list_lock);
</pre>
<p>
The compiler will then warn on any call to that function if the possession
of the indicated lock (<tt>devfreq_list_lock</tt>) cannot be determined.  There
is also a series of macros with names like GUARDED_BY() to document that
access to specific data (a structure member, for example) requires that a
certain mutex be held.  Those macros are not actually used in the posted
series, though.
<p>
Van Assche's patch set is focused on the <tt>mutex</tt> type, and attempts
to annotate usage throughout the entire kernel (though many of the
annotations are <tt>NO_THREAD_SAFETY_ANALYSIS</tt>, which disables the
analysis because the locking is too complicated for Clang to figure out — a
situation that arises frequently).  This work culminates in <a
href="/ml/all/20250206175114.1974171-33-bvanassche@acm.org">a massive
patch</a> touching over 800 files, which is a significant amount of code
churn.  The work has already found a number of locking bugs, the fixes for
which are included in the series.
<p>
<h4>An alternative approach</h4>
<p>
On the same day, Marco Elver posted <a
href="/ml/all/20250206181711.1902989-1-elver@google.com">a patch set of his
own</a> with a slightly different approach to using the same feature; that
series has since <a
href="/ml/all/20250304092417.2873893-1-elver@google.com">been updated</a>,
adopting the term "capability analysis" in place of "thread-safety
analysis".  While Van Assche used a breadth-first approach with mutexes,
Elver has gone depth-first with a series that adds annotations for several
locking primitives, but which is only active in subsystems that explicitly
opt into it.  In that way, warnings can be turned on for code where the
maintainers and developers are interested in them (and will act on them),
while being left off for the rest of the kernel.
<p>
The syntax of the annotations is a little different from Van Assche's
approach, but the intent is clearly the same:
<p>
<pre>
    void mutex_lock(struct mutex *lock) __acquires(lock);
    void mutex_unlock(struct mutex *lock) __releases(lock);
</pre>
<p>
Elver's series, though, goes beyond mutexes to add annotations for
spinlocks, <a href="/Articles/364583/">reader-writer locks</a>, <a
href="/Articles/22818/">seqlocks</a>, single-bit spinlocks,
read-copy-update, <a href="/Articles/828477/">local locks</a>, and <a
href="/Articles/548909/">wait/wound mutexes</a>.  In many cases, the
annotations that already exist for the kernel's <a
href="https://docs.kernel.org/locking/lockdep-design.html">locking
correctness validator</a> (lockdep) have been reworked to add the needed
capability declarations.  There is a <tt>__guarded_by()</tt> annotation to
document that a lock that must be held to access a specific structure
member; its use can be seen in <a
href="/ml/all/20250304092417.2873893-27-elver@google.com">this patch</a>
instrumenting the kfence subsystem.  The <tt>capability_unsafe()</tt>
marker disables checking for a block of code.  Most of the new annotations,
along with documentation, can be found in <a
href="/ml/all/20250304092417.2873893-3-elver@google.com">this patch</a>.
<p>
The other difference found in Elver's approach is the explicit opt-in design,
which allows each subsystem to enable or disable the feature.  By default,
any given subsystem will not be covered by this analysis; that can be
changed by adding one or more lines to the subsystem's makefile:
<p>
<pre>
    CAPABILITY_ANALYSIS := y
    CAPABILITY_ANALYSIS_foo := y
</pre>
<p>
The first line will enable analysis for all code compiled by way of that
makefile, while the second will enable it only for the compilation creating
<tt>foo.o</tt>.  The patch set enables the feature for a number of kernel
subsystems, including debugfs, kernel fences, <a
href="/Articles/751374/">rhashtables</a>, tty drivers, the <a
href="https://docs.kernel.org/admin-guide/LSM/tomoyo.html">TOMOYO security
module</a>, the crypto subsystem, and more.
<p>
<h4>What next?</h4>
<p>
It would appear that the community has a wealth of riches here: two
competing patch sets that aim to use the same compiler feature to improve
correctness checking within the kernel.  Either series can increase
confidence that locking is being handled correctly, and both work entirely
at compile time, with no run-time overhead.  The reception for this work
has been quite positive, with the only open question seemingly being which
series would be accepted, or whether the kernel might adopt a combination
of the two.
<p>
There are no definitive answers to that question, but a clue can be found
in the fact that Van Assche has been posting comments (and Reviewed-by
tags) for Elver's patch set.  Peter Zijlstra has also <a
href="/ml/all/20250305112041.GA16878@noisy.programming.kicks-ass.net/">tried
his hand</a> with Elver's work in the scheduler subsystem, saying that
"<q>this is all awesome</q>".  That attempt pointed to some needed changes;
it seems Zijlstra also managed to crash the Clang compiler.  He later <a
href="/ml/all/20250305161652.GA18280@noisy.programming.kicks-ass.net/">pointed
out</a> that the capability analysis works in simple cases, but for
"<q>anything remotely interesting, where you actually want the help, it
falls over</q>".
<p>
Real use in the kernel (and beyond) may well help to drive development work
in the Clang community to improve this analysis feature to the point that
it can be routinely used to verify locking patterns.  Some of that work may
need to happen before support for this kind of capability analysis can be
added to the kernel.  But, since it is an opt-in, compile-time feature,
there may well be value to adding it relatively soon, even if it needs
further work.  The kernel community seems to be hungry for this kind of
support.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Static_analysis">Development tools/Static analysis</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/1012990/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor1013605"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Simple cases need the checking more</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2025 14:55 UTC (Mon)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/1013605/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; for "anything remotely interesting, where you actually want the help, it falls over". </span><br>
<p>
In my experience it's often the simple cases that need the extra checking because they're so "obvious" that people don't pay enough attention, especially during refactors.<br>
<p>
The complex cases tend to get more thoroughly examined.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1013605/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1013606"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2025 14:59 UTC (Mon)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/1013606/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've looked into this for postgres a couple times, but was discouraged by the same thing that Zijlstra observed. The analysis is so simplistic &amp; strict that one needs to suppress the analysis very widely. <br>
<p>
I wish the relevant analysis infrastructure in llvm/clang would improve, unfortunately I haven't seen much advancement in the last few years... <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1013606/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1013607"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2025 18:22 UTC (Mon)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/1013607/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a correlary to this: If your locking scheme is regularly too complex for a computer to understand, humans probably won't understand it either. That's not to say that there aren't use cases for wild locking schemes. But if left to their own devices, programmers will always tend to accidentally build locking schemes so complex they can't understand them. It's helpful to have tools that fight back against that by default.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1013607/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1013638"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2025 18:37 UTC (Mon)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/1013638/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      &gt;  There's a correlary to this: If your locking scheme is regularly too complex for a computer to understand, humans probably won't understand it either.

It doesn't have to be very complicated for clang to not understand it.  IIRC it's enough to have:

<pre>
if (need_lock)
    acquire_lock();

simple_code_like_an_assignment = 1;

if (need_lock)
    release_lock();
</pre>

IIRC it also doesn't deal with conditional lock acquisition failing.

These really aren't complicated hard to understand locking schemes...


      
          <div class="CommentReplyButton">
            <form action="/Articles/1013638/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1013670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2025 10:46 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1013670/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; IIRC it's enough to have</font>

<p>Indeed, that's the code that I would ask to refactor: put the inner part into a function (or a closure), call it between <code>acquire_lock</code> and <code>release_lock</code> unconditionally.</p>

<p>Can be trivially handled in any language with generics or templates.</p>

<p>Don't make reader to play puzzle games in head while reading that code!</p>

<font class="QuotedText">&gt; These really aren't complicated hard to understand locking schemes…</font>

<p>These are complicated enough that most developers (although probably not most kernel developers) would think about ways to abstract all that machinery and put in into simple, easy to digest, code.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/1013670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1013639"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2025 18:42 UTC (Mon)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/1013639/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      Mmm, I agree on the general principle, but is this (the example from the thread that the analyser can't handle) really an example of "so complex you can't understand it" ? All it's doing is "if we have a parent then hold its lock across this call"... It feels to me like maybe the analyser could do with being a little smarter too. (Unless of course I've misunderstood what the code is doing :-) )

<pre>
	struct device *parent = dev-&gt;parent;

	if (parent)
		device_lock(parent);

	device_release_driver(dev);

	if (parent)
		device_unlock(parent);
</pre>








      
          <div class="CommentReplyButton">
            <form action="/Articles/1013639/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1013655"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2025 21:58 UTC (Mon)
                               by <b>proski</b> (subscriber, #104)
                              [<a href="/Articles/1013655/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would avoid conditional locking as much as possible. I'd rather have two functions, one with the lock and another without. Or perhaps the function with the lock should wrap the one without the lock.<br>
<p>
And then let's see why the lock is needed. In Rust, objects are not locked just in case, they are locked to be accessed for reading or writing. If there is no apparent access to the object being locked, perhaps that access is implicit and should be made explicit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1013655/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1013661"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2025 1:57 UTC (Tue)
                               by <b>kschendel</b> (subscriber, #20465)
                              [<a href="/Articles/1013661/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not at all clear to me that two functions that do the same thing except for locking, is any easier to understand than one function with conditional locking.  IMO this is too close to making everything a nail, since one has a hammer ...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1013661/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1013671"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2025 11:05 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1013671/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; IMO this is too close to making everything a nail, since one has a hammer ...</font>

<p>That's what “new generation” writes and while question of efficiency exists it's Ok for 90% of the code.</p>

<p>These debates happened decades ago and the result is: 90% of time complicated control flow is… just not worth it. And in 90% of remaining 10% compiler can handle it just fine.</p>

<p>The remaining 1% of code can be reviewed to the death with every line discussed (and maybe even commented!) separately.</p>

<font class="QuotedText">&gt; It's not at all clear to me that two functions that do the same thing except for locking, is any easier to understand than one function with conditional locking.</font>

<p>You can do conditional locking in Rust, too. What you don't do is conditional <b>un</b>locking. Something like this:

<pre>
     // We probably have Weak reference to parent so need to upgrade.
     let maybe_parent = dev.parent.upgrade();
     let guard;
     // If we have parent then we need to lock it.
     if let(parent) = maybe_parent {
         guard = parent.lock();
     }
     device_release_driver(dev);
</pre>

<p>Note that there are no <code>unlock</code> and there are no need for <code>unlock</code>, there are literally nothing to analyze.</p>

<p>Although the whole thing looks extremely suspicious to me: if we are not planning to touch <code>parent</code> then why do we lock it? If we <b>do</b> plan to touch it then why we are not passing it into that function? And why do we have a strange function that may or may not access parent in the first place ? There would be no need for lock if it doesn't access <code>parent</code> and it may obviously not access it if it's not there so this function <b>be definition</b> is already very strange.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/1013671/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1013900"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2025 22:35 UTC (Wed)
                               by <b>neggles</b> (subscriber, #153254)
                              [<a href="/Articles/1013900/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; if we are not planning to touch parent then why do we lock it?</span><br>
<p>
We *are* planning to touch parent - we're about to remove one of its children, so we lock it to prevent another task from changing it while we do that.<br>
<p>
A number of device classes may or may not have a parent device, depending on how they're attached to the system.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1013900/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1013904"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2025 22:57 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1013904/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; We *are* planning to touch parent</font>

<p>No. We are not doing that. Instead we hope that <b>someone else</b> would reach out to touch our <code>parent</code> to detach us from it. While expecting that <b>we</b> hold the lock.</p>

<p>That's very much a premature optimization: we have two entirely different operations conflated and introduce hidden dependency channel for no good reason.</p>

<font class="QuotedText">&gt; A number of device classes may or may not have a parent device, depending on how they're attached to the system.</font>

<p>Sure, but why do they even <b>care</b>. And why do they <b>care enough</b> to play tricks with pointers where the exact same pointer may be both locked and unlocked with no way to distinguish these two states, except by tracing the call graph (inherently fragile operation both for compiler and human)?</p>

<p>I agree that <b>sometimes</b> that's the only sensible choice… but far too often the whole story is done in this inherently convoluted and fragile fashion not because it may affect the performance or memory or anything like that but simply “because we can”.</p>

<p>And that's how we end up with these endless debates about who have to take the lock and when… the only way to solve it is to stop creating such convoluted schemes except when one <b>knows</b> they are justified by <b>measurable</b> improvements somewhere.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/1013904/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1013897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2025 23:59 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/1013897/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>
The implication (at least as far as I can understand this code) is that we're doing something that makes parent semantically invalid (or at least thread-unsafe), even though we are not writing to any of its bytes.
<p>
In Rust, you would most likely solve this problem with a typestate, which probably looks vaguely like the following:
<pre>
// callsite
let handle = lock_make_parent_handle(dev);
device_release_driver(handle);

// lock_make_parent_handle() definition
pub fn lock_make_parent_handle&lt;'a&gt;(dev: &amp;'a mut Device) -&gt; ParentHandle&lt;'a, MutexGuard&lt;'a, Device&gt;&gt;{
    ParentHandle{
        dev: dev,
        parent: dev.parent.upgrade().map(|parent| parent.lock().unwrap()),  // PoisonError handling elided for brevity
    }
}

pub fn make_parent_handle_unlocked&lt;'a, P&gt;(dev: &amp;'a mut Device, maybe_parent: Option&lt;P&gt;) -&gt; Result&lt;ParentHandle&lt;'a, P&gt;, WrongParentError&gt;
where P: 'a + DerefMut&lt;Device&gt;
{
    let maybe_dev_parent = dev.parent.upgrade();
    if maybe_parent.is_some() != maybe_dev_parent.is_some() {
        return Err(WrongParentError{});
    }
    if let (Some(parent), Some(dev_parent)) = maybe_parent, maybe_dev_parent {
        /* We cannot directly compare parent and dev_parent with PartialEq or the like, because by assumption,
         * dev_parent is already locked (or at least, it should be if the caller is using the function correctly).
         * Test whether parent points somewhere inside of dev_parent by doing pointer comparisons:
         */
        if (&amp;*dev_parent as *const u8) &gt; (&amp;*parent as *const u8){
            return Err(WrongParentError{});
        }
        if (std::ptr::from_ref(&amp;*dev_parent).wrapping_add(1) as *const u8) &lt;= (&amp;*parent as *const u8){
            // Can't wrap, Rust's memory model guarantees that base + size does not overflow usize.
            return Err(WrongParentError{});
        }
    }
    Ok(ParentHandle{
        dev: dev,
        parent: maybe_parent,
    })
}

// ParentHandle definition
struct ParentHandle&lt;'a, P&gt;
where P: 'a + DerefMut&lt;Device&gt;{
    dev: &amp;'a mut Device,
    parent: Option&lt;P&gt;,
}
// This struct and the above two constructors are in a separate crate or module so that
// you can't manufacture your own instances from scratch.

// device_release_driver() definition
fn device_release_driver&lt;'a, P&gt;(handle: &amp;mut ParentHandle&lt;'a, P&gt;)
where P: 'a + DerefMut&lt;Device&gt;
{
    // use handle.dev here... probably needs get() and get_mut() methods, and also for parent, etc.
}
</pre>
<p>
You can then use <tt>&amp;mut ParentHandle</tt> as an argument to anything which must exclusively lock the parent but operates on the device. If you already locked the parent elsewhere, you can also construct it without (further) locking, and that's just as safe (and avoids the need for reentrant locking).


      
          <div class="CommentReplyButton">
            <form action="/Articles/1013897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1013938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Note similarity between Rust references and reader-writer locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2025 10:14 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/1013938/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      It's worth noting when you're analyzing this sort of code in Rust that there's a parallel between Rust's references, and reader-writer locks (rwlocks) on the owned object. Semantically, a shared reference (<tt>&amp;'lifetime Thing</tt>) acts as a compile-time read lock on the thing it refers to (modulo interior mutability - just as it's permissible for a structure protected by an rwlock to contain something with its own locking that allows mutation, even when you only have a read lock on the outer structure), and an exclusive reference (<tt>&amp;'lifetime mut Thing</tt>) acts as a compile-time write lock on the structure it refers to.
<p>As a result, if you have a <tt>&amp;mut Thing</tt>, you know by the semantics of Rust that you have exclusive access to the <tt>Thing</tt>. This could be because the compiler can see at compile time that you've got exclusive access, or because unsafe Rust in a locking primitive guarantees this property at run time.



      
          <div class="CommentReplyButton">
            <form action="/Articles/1013938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1014058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Note similarity between Rust references and reader-writer locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2025 18:03 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/1014058/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is true, but unfortunately there is no easy way to write this generically. Or rather, there are too many ways of writing it generically:<br>
<p>
* You could just use &amp;Foo and &amp;mut Foo (probably with lifetimes, at least if they're going into a struct). The main advantage is that these are the "lowest common denominator" - nearly everything else can be converted into one of these, except that pinning pointers cannot be converted into &amp;mut. But none of the other generic options are compatible with Pin either (in this use case), so if you need to mutate through a Pin, you pretty much have to write it out separately (and hope the type supplies appropriate Pin&lt;&amp;mut Self&gt; methods for actually doing the mutation). Unfortunately, the use of &amp;Foo or &amp;mut Foo means users will sometimes have to write &amp;*foo or the like to convert some other type into a reference, which is not terrible but also not ideal.<br>
* You could instead take Deref&lt;Foo&gt; and DerefMut&lt;Foo&gt;. This covers most reasonable smart pointers, in addition to &amp;Foo and &amp;mut Foo, which means the user can give us ownership (or shared ownership, a lock guard, etc.) if that is more convenient for them. Technically, there is nothing prohibiting a Deref implementation from doing something expensive like taking a lock, but the semantic meaning of Deref and DerefMut is "this conversion is so cheap and so obvious that it should happen implicitly," so taking a lock in Deref is evil (on top of that, the signature of Deref::deref() is not compatible with taking a lock unless you hold it for the entire lifespan of Self, so it makes more sense to implement Deref on the already-taken lock guard instead). For example, a Box&lt;Foo&gt; has all the methods of a &amp;mut Foo, because even though it's technically not the same thing, we prefer to think of it as "a Foo that happens to live on the heap" rather than "a Box containing a Foo." Similarly, Vec&lt;T&gt; and [T; N] both deref coerce into &amp;[T], because they're both conceptually "a contiguous sequence of T objects somewhere in memory," and so it would make no sense to require an explicit conversion to use slice methods on them. However, this can also be a problem, if you don't actually care about that property and just want "a thing that can cheaply and infallibly give me a &amp;Foo, regardless of what it is conceptually supposed to be."<br>
* Then there are AsRef&lt;Foo&gt; and AsMut&lt;Foo&gt;. These are the "cheap reference-to-reference conversion" traits. Just like Deref, they should not take locks or do other expensive operations (and just like Deref::deref(), their method signatures are not really compatible with locking anyway). Unlike Deref, they don't get invoked implicitly, which means that unlike Deref, you can implement them more than once on the same type, as well as on types that are conceptually distinct from one another. For example, the various string-like types can all be converted into &amp;[u8] via AsRef, but they do not Deref as &amp;[u8], because it would be very confusing if we mixed bytewise methods into the same namespace as Unicode-oriented methods. Unfortunately, &amp;T does not blanket implement AsRef&lt;T&gt; due to a trait coherence constraint, which means these are not a good candidate for accepting arguments generically.<br>
* There are also Borrow&lt;Foo&gt; and BorrowMut&lt;Foo&gt;. These are extremely similar to AsRef&lt;Foo&gt; and AsRefMut&lt;Foo&gt;, with two differences: Firstly, they semantically require that Self implements Eq, Ord, and Hash identically to the underlying (owned) type (i.e. if lhs == rhs, then lhs.borrow() == rhs.borrow()). This makes them suitable for use in hash tables, trees, heaps, etc. Secondly, there is a blanket implementation for &amp;T, so they are more suitable for generic use than AsRef&lt;T&gt;. But you don't always need the Eq/Ord/Hash property, so this may be too restrictive in some use cases.<br>
* In principle, there's also Into&lt;&amp;T&gt;, but this doesn't exist in practice because the signature doesn't make sense (it consumes self and returns &amp;T, but what is the lifetime of the &amp;T it returns, given that self has been consumed and no longer exists?).<br>
<p>
IMHO the least problematic option (at least in a case like this) is to take Deref&lt;T&gt; or DerefMut&lt;T&gt;, because:<br>
<p>
* Conversion into &amp;T or &amp;mut T is rarely all that difficult (except for the Pin case noted above) and those always implement Deref/DerefMut.<br>
* Most smart pointers are Deref&lt;T&gt;, so we still support the "pass an owning smart pointer or lock guard instead of a reference" use case. That's one less lifetime for the user to think about, but they don't have to do this if they don't want to (they can pass &amp;T instead).<br>
* If the end user wants to do some conversion that isn't "obvious" in the way that deref coercion is meant to be obvious, then probably they should do that explicitly at the callsite.<br>
<p>
I'm actually not too upset about AsRef lacking that reflexive blanket implementation - if it had one, then it would be much easier to write generic code that does implicit conversions, and once that starts to become the standard way of writing generic code, everything starts feeling a little too much like C++ (before they invented the explicit keyword). In fact, part of me is tempted to say that they should not fix this, even if trait coherence gets more permissive in the future, because I'm not sure the resulting generality would be worth it. But OTOH that doesn't seem to have happened with From and Into, so maybe it's fine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1014058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1014074"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Note similarity between Rust references and reader-writer locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 13, 2025 19:12 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/1014074/">Link</a>] 
      </p>
      
      </div>
      </summary>
      To be clear, this was more meant in terms of reading the code, not writing it - if you see an <tt>&amp;mut</tt>, you know that you already have exclusive access to the thing you're looking at, and thus that you don't need to look for locking.
<p>Thus, if your typestate had a way to get an <tt>Option&lt;&amp;mut P&gt;</tt> from a <tt>ParentHandle</tt>, I'd be reduced to confirming that the only way for that option to be <tt>None</tt> is if the weak reference to parent was already dangling, and thus there is no parent to lock.


      
          <div class="CommentReplyButton">
            <form action="/Articles/1014074/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1014145"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Note similarity between Rust references and reader-writer locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2025 12:36 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/1014145/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; * Then there are AsRef&lt;Foo&gt; and AsMut&lt;Foo&gt;. These are the "cheap reference-to-reference conversion" traits. Just like Deref, they should not take locks or do other expensive operations (and just like Deref::deref(), their method signatures are not really compatible with locking anyway). Unlike Deref, they don't get invoked implicitly, which means that unlike Deref, you can implement them more than once on the same type, as well as on types that are conceptually distinct from one another. For example, the various string-like types can all be converted into &amp;[u8] via AsRef, but they do not Deref as &amp;[u8], because it would be very confusing if we mixed bytewise methods into the same namespace as Unicode-oriented methods. Unfortunately, &amp;T does not blanket implement AsRef&lt;T&gt; due to a trait coherence constraint, which means these are not a good candidate for accepting arguments generically.</span><br>
<p>
Hmm. That's odd. I see `AsRef&lt;Path&gt;` generic parameters fairly often. I feel like `AsRef&lt;OsStr&gt;` is also around, but I've seen that less often. Is &amp;Path and &amp;OsStr better here perhaps (though I feel like String and str usages might need caller-side help then)?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1014145/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1014184"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Note similarity between Rust references and reader-writer locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2025 13:51 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/1014184/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <tt>Path</tt>, <tt>OsStr</tt> and <tt>str</tt> "cheat" by manually implementing <tt>AsRef</tt> for the reflexive case. The problem is that <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#reflexivity">trait coherence prevents you having <tt>impl&lt;T: ?Sized&gt; AsRef&lt;T&gt; for T</tt></a>, but instead requires the crate that defines <tt>T</tt> to add the trivial implementation manually.
<p>If that crate fails to do so, then the orphan rules mean that you can't add it yourself. This means that, unless the type has "cheated" with a trivial manual implementation, you can't use an <tt>&amp;T</tt> where a function asks for an <tt>AsRef&lt;T&gt;</tt>. Fortunately, there is <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#impl-AsRef%3C%5BT%5D%3E-for-%5BT%5D"><tt>impl&lt;T&gt; AsRef&lt;[T]&gt; for [T]</tt></a>, so this restriction only applies to converting <tt>&amp;T</tt> to <tt>AsRef&lt;T&gt;</tt>, not <tt>&amp;[T]</tt> to <tt>AsRef&lt;[T]&gt;</tt>.





      
          <div class="CommentReplyButton">
            <form action="/Articles/1014184/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1014186"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Note similarity between Rust references and reader-writer locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2025 14:09 UTC (Fri)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1014186/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there any desire to relax the trait coherence rules enough for such a blanket impl to become possible?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1014186/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1014187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Note similarity between Rust references and reader-writer locks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2025 14:30 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/1014187/">Link</a>] 
      </p>
      
      </div>
      </summary>
      That's a question better asked on <a href="https://internals.rust-lang.org/">internals.rust-lang.org</a>. My understanding, as an outsider, is that permitting this blanket implementation in parallel to <a href="https://doc.rust-lang.org/std/convert/trait.AsRef.html#impl-AsRef%3CU%3E-for-%26T"><tt>impl&lt;T: AsRef&lt;U&gt; + ?Sized, U: ?Size&gt; AsRef&lt;U&gt; for &amp;T</tt></a> runs into the same set of <a href="https://aturon.github.io/blog/2017/07/08/lifetime-dispatch/">soundness problems as other forms of specialization</a>.
<p>If the issues around specialization can be resolved, then that would provide a path to permitting such a blanket imp for <tt>AsRef</tt>. But that's a big if, since there's a requirement to avoid permitting specialization based on lifetime annotations (mostly because lifetime annotations are supposed to be erased after type checking is complete, but also because there's no way in Rust to represent the statement "lifetimes <tt>'a</tt> and <tt>'b</tt> are exactly the same"; the closest you can get is "<tt>'a</tt> is at least as long as <tt>'b</tt> and <tt>'b</tt> is at least as long as <tt>'a</tt>", which is not quite the same in terms of the logic used for type and borrow checking).


      
          <div class="CommentReplyButton">
            <form action="/Articles/1014187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor1013673"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2025 22:10 UTC (Tue)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/1013673/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The thing is that while stuff like that looks reasonable at first glance, it is a global property that trends towards getting worse in two dimensions unless fiercely checked:<br>
<p>
- As a program grows, it will gain more and more concurrent data structures (ad-hoc or designed), each of which will gain their own bespoke ways of determining when what needs to be locked under which conditions.<br>
- Similarly, as a data structure itself grows in complexity and functionality, the rules for an individual data structure will grow more and more complex with additional considerations, optimisations, special exceptions, build options, etc. Nobody creates inscrutable locking rules on purpose, but they do have a habit of appearing as a codebase gets older. And while ideally these rules would be rigorously specified, in reality you're inevitably going to be playing a game of telephone where each developer gives the next their interpretation of what the locking rules are until nobody can agree on the specifics.<br>
<p>
In the end it always ends up difficult to manage this M x N complexity of bespoke locking rules for each component long term. And the truth is, most code simply doesn't need it. A simple universal locking rule of "if you want to touch this data you need to hold it's associated lock" works for the vast majority of cases. "If you want to touch this you need to call this function" works for even more. You can really design a surprising amount of complex code sensibly around these simple type of rules which are trivial for both humans and computers to verify and are already within what clang can so.<br>
<p>
I think there's a lot of value in having tools that can understand the complexity of these locking rules that have already been created for sure. But I think it's a mistake to trick ourselves into believing that the habitual over-engineering of locking rules we tend to get ourselves into is a necessity when the tools are already perfectly good for most cases and designing around what they can do already delivers more understandable code today. Allowing cleverer locking rules really wouldn't fix that problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1013673/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1013901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 12, 2025 22:38 UTC (Wed)
                               by <b>neggles</b> (subscriber, #153254)
                              [<a href="/Articles/1013901/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; [...] as a data structure itself grows in complexity and functionality, the rules for an individual data structure will grow more and more complex with additional considerations, optimisations, special exceptions, build options, etc. [...]</span><br>
<p>
case in point: `struct page`<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1013901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor1014850"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 20, 2025 8:45 UTC (Thu)
                               by <b>daenzer</b> (subscriber, #7050)
                              [<a href="/Articles/1014850/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since the Rust compiler seems to have no trouble handling complex locking schemes, I suspect the C(++) semantics are a bigger issue than the complexity of locking schemes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1014850/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1016394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">analysis too limited</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 3, 2025 14:55 UTC (Thu)
                               by <b>melver</b> (subscriber, #134990)
                              [<a href="/Articles/1016394/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For further visibility, with the Clang maintainers of this feature, we started a discussion how to extend Clang to address some of the shortcomings: <a href="https://lore.kernel.org/all/CANpmjNPquO=W1JAh1FNQb8pMQjgeZAKCPQUAd7qUg=5pjJ6x=Q@mail.gmail.com/">https://lore.kernel.org/all/CANpmjNPquO=W1JAh1FNQb8pMQjge...</a><br>
<p>
We are hopeful this can happen some time this year. After which, we will revisit the feature for the kernel. If there are willing Clang/LLVM contributors to help us accelerate landing this feature, please get in touch.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1013644"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">coccinelle</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 10, 2025 19:03 UTC (Mon)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/1013644/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have on occasion used coccinelle to check locking rules in my own code, although the syntax is certainly an obstacle.  Also far less convenient than having the compiler do it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1013644/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1014108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Problems with thread safety and RAII patterns in C++</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2025 1:17 UTC (Fri)
                               by <b>irogers</b> (subscriber, #121692)
                              [<a href="/Articles/1014108/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ironically C could be better than in C++ thread safety analysis as it doesn't apply to constructors and destructors. All constructors/destructors are implicitly made NO_THREAD_SAFETY_ANALYSIS:<br>
<a href="https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#no-checking-inside-constructors-and-destructors">https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#no-...</a><br>
This can be pretty limiting as you may put logic in constructors/destructors that uses global locks, particularly common for RAII patterns. C cleanups for RAII are also considered in the thread.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1014108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2025, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
