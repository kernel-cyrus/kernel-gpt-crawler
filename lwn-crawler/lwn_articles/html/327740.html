        <!DOCTYPE html>
        <html lang="en">
        <head><title>Linux Storage and Filesystem Workshop, day 2 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/327740/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/326818/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/327740/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Linux Storage and Filesystem Workshop, day 2</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 8, 2009</br>
           </div>
The second and final day of the Linux Storage and Filesystem Workshop was
held in San Francisco, California on April&nbsp;7.  Conflicting commitments
kept your editor from attending the entire event, but he was able to
participate in sessions on solid-state device support, storage topology
information, and more.
<p>
<h3>Supporting SSDs</h3>
<p>
The solid-state device topic was the most active discussion of the
morning.  SSDs clearly stand to change the storage landscape, but it often
seems that nobody has yet figured out just how things will change or what
the kernel should do to make the best use of these devices.  Some things
are becoming clearer, though.  The 
kernel will be well positioned to support the current generation SSDs.
Supporting future products, though, is going to be a challenge.
<p>

<a href="/Articles/327842/"><img
src="https://static.lwn.net/images/conf/lsf2009/lsf2009-group-sm.jpg" width=250 height=163
alt="[Group photo]" border=0 align="right"></a>

Matthew Wilcox, who led the discussion, started by noting that Intel SSDs
are able to handle a large number of operations in parallel.  The
parallelism is so good, in fact, that there is really little or no
advantage in delaying operations.  I/O requests should be submitted
immediately; the block I/O subsystem shouldn't even attempt to merge
adjacent requests.  This message was diluted a bit later on, but the core
message is clear: the kernel should, when driving an SSD, focus on getting
out of the way and processing operations as quickly as possible.
<p>
It was asked: how do these drives work internally?  This would be nice to
know; the better informed the kernel developers are, the better they can do
at driving the devices better.  It seems, though, that the firmware in
these devices - the part that, for now, makes Intel devices work better
than most of the alternatives - is laden with Valuable Intellectual
Property, and not much information will be forthcoming.  Solid-state
devices will be black boxes for the foreseeable future.
<p>
In any case, current-generation Intel SSDs are not the only type of device
that the kernel will have to work with.  Drives will differ greatly in the
coming years.  What the kernel really needs to know is a few basic
parameters: what kind of request alignment works best, what request sizes
are fastest, etc.  It would be nice if the drives could export this
information to the operating system.  There is a mechanism by which this
can be done, but current drives are not making much information available.
<p>
One clear rule holds, though: bigger requests are better.  They might
perform better in the drive itself, but, with high-quality SSDs, the real
bottleneck is simply the number of requests which can be generated and
processed in a given period of time.  Bundling things into larger requests
will tend to increase the overall bandwidth.
<p>
A related rule has to do with changes in usage patterns.
It would appear that the Intel drives, at least, observe the requests
issued by the computer and adapt their operation to improve performance.
In particular, they may look at the typical alignment of requests.  As a
result, it is important to let the drive know if the usage pattern is about
to change - when the drive is repartitioned and given a new filesystem, for
example.  The way to do this, evidently, is to issue an ATA "secure erase"
command.
<p>
From there, the conversation moved to discard (or "trim") requests, which
are used by the host to tell the drive that the contents of specific blocks
are no longer needed.  Judicious use of trim requests can help the drive in
its garbage collection work, improving both performance and the overall
life span of the hardware.  But what constitutes "judicious use"?  Doing a
trim when a new filesystem is made is one obvious candidate.  When the
kernel initializes a swap file, it trims the entire file at the outset
since it cannot contain anything of use.  There is no controversy here
(though it's amusing to note that mkfs does not, yet, issue trim
commands). 
<p>

But what about when the drive is repartitioned?  It was suggested that the
portion of the drive which has been moved from one partition to another
could be trimmed.  But that raises an immediate problem: if the partition
table has been corrupted and the "repartitioning" is really just an attempt
to restore the drive to a working state, trimming that data would be a
fatal error.  The same is true of using trim in the fsck command, which is
another idea which has been suggested.  In the end, it is not clear that
using trim in either case is a safe thing to do.
<p>

The other obvious place for a trim command is when a file is deleted; after
all, its data clearly is no longer needed.  But some people have questioned
whether that is a good time too.  Data recovery is one issue; sometimes
people want to be able to get back the contents of an erroneously-deleted
file.  But there is also a potential performance issue: on ATA drives, trim
commands cannot be issued as tagged commands.  So, when a trim is
performed, all normal operations must be brought to a halt.  If that
happens too often, the throughput of the drive can suffer.  This problem
could be mitigated by saving up trim operations and issuing them all
together every few minutes.  But it's not clear that the real performance
impact is enough to justify this effort.  So some benchmarking work will be
needed to try to quantify the problem.
<p>

An alternative which was suggested was to not use trim at all.  Instead, a
similar result could be had by simply reusing the same logical block
numbers over and over.  A simple-minded implementation would always just
allocate the lowest-numbered free block when space is needed, thus
compressing the data toward the front end of the drive.  There are a couple
of problems with this approach, though, starting with the fact that a lot
of cheaper SSDs have poor wear-leveling implementations.  Reusing
low-numbered blocks repeatedly will wear those drives out prematurely.  The
other problem is that allocating blocks this way would tend to fragment
files.  The cost of fragmentation is far less than with rotating storage,
but there is still value in keeping files contiguous.  In particular, it
enables larger I/O operations, and, thus, better performance.
<p>
There was a side discussion on how the kernel might be able to distinguish
"crap" drives from those with real wear-leveling built in.  There's
actually some talk of trying to create value-neutral parameters which a
drive could use to export this information, but there doesn't seem to be
much hope that the vendors will ever get it right.  No drive vendor wants
its hardware to self-identify as a lower-quality product.

One suggestion is that the kernel could interpret support for the trim
command as an indicator that it's dealing with one of the better drives.
That led to the revelation that the much-vaunted Intel drives do
not, currently, support trim.  That will change in future versions, though.
<p>

A related topic is a desire to let applications issue their own trim
operations on portions of files.  A database manager could use this feature
to tell the system that it will no longer be interested in the current
contents of a set of file blocks.  This is essentially a version of the
long-discussed <tt>punch()</tt> system call, with the exception that the
blocks would remain allocated to the file.  De-allocating the blocks would
be correct at one level, but it would tend to fragment the file over time,
force journal transactions, and make <tt>O_DIRECT</tt> operations block
while new space is allocated.  Database developers would like to avoid all
of those consequences.  So this variant of <tt>punch()</tt> (perhaps
actually a variant of <tt>fallocate()</tt>) would discard the data, but
keep the blocks in place.
<p>

From there, the discussion went to the seemingly unrelated topic of "thin
provisioning."  This is an offering from certain large storage array
vendors; they will sell an array which claims to be much larger than the
amount of storage actually installed.  When the available space gets low,
the customer can buy more drives from the vendor.  Meanwhile, from the
point of view of the system, the (apparently) large array has never
changed.
<p>
Thin provisioning providers can use the trim command as well; it lets them
know that the indicated space is unused and can be allocated elsewhere.
But that leads to an interesting problem if trim is used to discard the
contents of some blocks in the middle of the file.  If the application
later writes to those blocks - which are, theoretically, still in place -
the system could discover that the device is out of space and fail the
request.  That, in turn, could lead to chaos.
<p>
The truth of the matter is that thin provisioning has this problem
regardless of the use of the trim command.  Space "allocated" with
<tt>fallocate()</tt> could turn out to be equally illusory.  And if space
runs out when the filesystem is trying to write metadata, the filesystem
code is likely to panic, remount the filesystem read-only, and, perhaps,
bring down the system.  So thin provisioning should be seen as broken
currently.  What's needed to fix it is a way for the operating system to
tell the storage device that it intends to use specific blocks; this is an
idea which will be taken back to the relevant standards committees.
<p>
Finally, there was some discussion of the CFQ I/O scheduler, which has a
lot of intelligence which is not needed for SSDs.  There's a way
to bypass CFQ for some SSD operations, but CFQ still adds an
approximately 3% performance penalty compared to the no-op I/O scheduler.
That kind of cost is bearable now, but it's not going to work for future
drives.  There is real interest in being able to perform 100,000 operations
per second - or more - on an SSD.  That kind of I/O rate does not leave
much room for system overhead.  So, at some point, we're going to see a
real effort to streamline the block I/O paths to ensure that Linux can
continue to get the best out of solid-state devices.
<p>
<h3>Storage topology</h3>
<p>
Martin Petersen introduced the storage topology issue by talking about the
coming 4K-sector drives.  The sad fact is that, for all the talk of SSDs,
rotating storage will be with us for a while yet.  And the vendors of disk
drives intend to shift to 4-kilobyte sectors by 2011.  That leads to a
number of interesting support problems, most of which were covered in <a
href="http://lwn.net/Articles/322777/">this LWN article</a> in March.  In
the end, the kernel is going to have to know a lot more about I/O sizes and
alignment requirements to be able to run future drives.
<p>
To that end, Martin has prepared a set of patches which export this information
to the system.  The result is a set of directories under
<tt>/sys/block/<i>drive</i>/topology</tt> which provide the sector size,
needed alignment, optimal I/O flag, and more.  There's also a "consistency
flag" which tells the user whether any of the other information actually
matches reality.  In some situations (a RAID mirror made up of drives with
differing characteristics, for example), it is not possible to provide real
information, so the kernel has to make something up.
<p>
There was some wincing over this use of sysfs, but the need for this kind of
information is clear.  So these patches will probably be merged into the
2.6.31 kernel.

<p>
<a name="readdirplus"></a>
<h3>readdirplus()</h3>
<p>
There was also a session on the proposed <tt>readdirplus()</tt> system
call.  This call would function much like <tt>readdir()</tt> (or, more
likely, like <tt>getdents()</tt>), but it would provide file metadata along
with the names.  That, in turn, would avoid the need for a separate
<tt>stat()</tt> call and, hopefully, speed things considerably in some
situations.
<p>
Most of the discussion had to do with how this new system call would be
implemented.  There is a real desire to avoid the creation of independent
<tt>readdir()</tt> and <tt>readdirplus()</tt> implementations in each
filesystem.  So there needs to be a way to unify the internal
implementation of the two system calls.  Most likely that would be done by
using only the <tt>readdirplus()</tt> function if a filesystem provides
one; this callback would have a "no stat information needed" flag for the
case when normal <tt>readdir()</tt> is being called.
<p>
The creation of this system call looks like an opportunity to leave some
old mistakes behind.  So, for example, it will not support seeking within a
directory.  There will also probably be a new <tt>dirent</tt> structure
with 64-bit fields for most parameters.  Beyond that, though, the shape of
this new system call remains somewhat cloudy.  Somebody clearly needs to
post a patch.
<p>
<h3>Conclusion</h3>
<p>
And there ends the workshop - at least, the part that your editor was able
to attend.  There were a number of storage-related sessions which, beyond doubt,
covered interesting topics, but it was not possible to be in both rooms at
the same time (though, with luck, your editor will soon receive another
attendee's notes from those sessions).  The consensus among the attendees
was that it was a highly 
successful and worthwhile event; the effects should be seen to ripple
through the kernel tree over the next year.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Block_layer">Block layer</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Workshops">Filesystems/Workshops</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_and_Filesystem_Workshop-2009">Storage and Filesystem Workshop/2009</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/327740/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor327890"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Intel drives and TRIM</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 17:01 UTC (Wed)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/327890/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A quick clarification:<br>
<p>
"That led to the revelation that the much-vaunted Intel drives do not, currently, support trim. That will change in future versions, though."<br>
<p>
It's a property of the firmware; the drive I am testing TRIM with uses a special firmware build on current hardware.  I am not able to comment on when or whether firmware that supports TRIM will be available for drives that people already own.<br>
<p>
From what I've read on public websites, this appears to be true for other manufacturers too.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327890/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327918"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 20:04 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/327918/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder if SSDs will ever gain an additional level of hierarchy, such as an NVRAM layer over the flash layer.  "Hot write" zones could then live in the NVRAM layer and only be committed to flash infrequently.  By "hot write," I'm thinking of stuff such as the journal on a journaled filesystem.<br>
<p>
Aggressive use of TRIM when committing entries out of the journal would make it easier to reap blocks within this faster level of hierarchy, and would make the drive less sensitive to the size of the journal.  That is, the journal could be much larger than the NVRAM size, but you'd still get the benefit if the *active* part of the journal fit in the NVRAM.<br>
<p>
Having such a buffer should also make it much easier to wear-level the drive, pushing writes out of the NVRAM LRU only as needed, rotating among all the pieces of flash.  The NVRAM would also allow the SSD to buffer requests (and mark writes as complete!) while it's in the middle of erasing sectors in the flash.<br>
<p>
Sure, it'd be expensive, but I imagine it'd fly like a bat outta hell.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327918/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327932"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 22:06 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/327932/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, how long until flash drives go the "WinModem" route, exposing a raw interface and putting all the smarts in an OS driver?  I guess you still need to have some minimal disk emulation to get booted far enough to load such a driver...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327932/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327937"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 0:43 UTC (Thu)
                               by <b>mattdm</b> (subscriber, #18)
                              [<a href="/Articles/327937/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I understand it, that'd be a very good thing for Linux  just like Linux software RAID is usually better than the "fraid" options.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327937/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328176"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2009 18:34 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/328176/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
<blockquote>
Also, how long until flash drives go the "WinModem" route, exposing a raw interface and putting all the smarts in an OS driver? 
</blockquote>
As I understand it, that'd be a very good thing for Linux
</blockquote>
<p>
But in the Winmodem route, the raw interface is a secret and specific to a small subset of devices, and the manufacturer doesn't write any Linux drivers.  That's all pretty bad for Linux, isn't it?

<p>On the other hand, assuming flash storage lasts (doesn't get replaced by a different solid state storage technology that has different characteristics), I do expect it to eventually grow an interface optimized for driving flash (i.e. low level) rather than use an interface designed for disk drives, and then we could get the advantages of running more of the logic in the client and less in the storage device.

      
          <div class="CommentReplyButton">
            <form action="/Articles/328176/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2009 19:00 UTC (Sat)
                               by <b>dwmw2</b> (subscriber, #2063)
                              [<a href="/Articles/328233/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <BLOCKQUOTE><I>"But in the Winmodem route, the raw interface is a secret and specific to a small subset of devices, and the manufacturer doesn't write any Linux drivers. That's all pretty bad for Linux, isn't it?" </I></BLOCKQUOTE>

A WinModem is mostly just a sound card &mdash; we do actually know how to drive most of them. That's not the problem at all.
<P>
The problem with WinModems is that modem algorithms better than about v.32 are covered by patents. And while a lot of stuff in that situation has still found its way into software projects in the Free World, we still don't have a decent modem implementation. Someone needs to do a Free World fork of <A HREF="http://www.soft-switch.org/">spandsp</A>, perhaps? And/or pick up the late Tony Fisher's work on <A HREF="http://www-users.cs.york.ac.uk/~fisher/modem/">v.32bis and v.34</A>.
<P>
For flash, the situation is different. While there <em>are</em> plenty of patents flying around, they mostly cover the ways in which you make a flash device pretend to be a block device &mdash; and the beauty of exposing flash directly to the operating system is that you don't <em>need</em> that gratuitous extra layer any more. You can have a file system which knows about flash, and is designed to operate directly, and optimally, on it.
<P>
The recent <em>TRIM</em> work goes some way to fixing the most obvious disadvantage of the extra layer, but the fact remains that you still have your real file system running on top of another pseudo-filesystem which is pretending to be a block device. And you can never attempt to debug or improve that lower layer.
<P>
The Linux kernel has two file systems for real flash already, and more are in the works. I'd <em>very</em> much like to see direct access to the flash being permitted by these devices. I'm confident that we <em>can</em> do better than anything they can do inside their little black box.
      
          <div class="CommentReplyButton">
            <form action="/Articles/328233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328235"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2009 20:25 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/328235/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <p>Thanks for elucidating the patent angle.

<p>But that really just raises another issue.  With flash storage having its novel foibles, I find it hard to believe there aren't patents covering the various things you have to do to make it useful.  Method for storing data on flash without wearing out hot spots?  Method for extracting small blocks of data from flash quickly?
<p>
<blockquote>
I'm confident that we can do better than anything they can do inside their little black box.
</blockquote>
<p>
So you're saying there is innovation to be done.  That means there's something for someone to monopolize with a patent.
<p>
At least with a black box, the patents are all paid for as part of acquiring the box.  In contrast, when you need a patent license to run some code in your own Linux system, it usually means the code is useless.
<p>
So it still looks to me like Winmodem-style flash storage would be a bane to Linux and free software.

      
          <div class="CommentReplyButton">
            <form action="/Articles/328235/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2009 23:09 UTC (Sat)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/328243/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <BLOCKQUOTE>So it still looks to me like Winmodem-style flash storage would be a bane to Linux and free software.</BLOCKQUOTE><P>
Nonsense.  There are plenty of machines out there that have just plain NAND or NOR flash hooked up to the CPU and Linux reads/writes these effectively.  The issue is that currently we only see that in the embedded space, and it's typically just enough flash to hold the code for whatever that machine is supposed to do.  For example, be a WiFi router or a set-top box or a cell phone.
</P><P>
What I'd like to see is something I can get off the shelf at my local Computer Mart (or on the web) that plugs into my PC and gives me raw flash.  Instead of focusing on "right sized" and "small" and "maximizing battery life", it instead can be a bank of parallel flash such as what Intel's SSD disks are, but with a raw interface.  We can then use our existing flash filesystems and infrastructure to drive <I>those</I> in a desktop and laptop space, rather than just the netbook/smart-phone/smart-router space.
</P><P>
Now, these (potentially) massively parallel performance oriented disks will need additional software support.  You want something akin to RAID striping across the media along with maybe some redundancy in addition to wear leveling.  That's just enhancements on top of our existing wear leveling filesystems and infrastructure.
</P><P>
The only real issue is that once you give raw flash to the OS and put the smarts in the OS, it'll be harder for dual-boot systems to communicate on the same media, because the likelihood that $VENDOR's Windows driver organizes the disk the way Linux does is slim to none unless $VENDOR works with the Linux community also.
</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/328243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2009 1:21 UTC (Sun)
                               by <b>dwmw2</b> (subscriber, #2063)
                              [<a href="/Articles/328246/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <BLOCKQUOTE><I>"The only real issue is that once you give raw flash to the OS and put the smarts in the OS, it'll be harder for dual-boot systems to communicate on the same media, because the likelihood that $VENDOR's Windows driver organizes the disk the way Linux does is slim to none unless $VENDOR works with the Linux community also."</I></BLOCKQUOTE>

I see two reasons why that wouldn't be a problem, in practice.<P>

Firstly, we've never had many problems working with "foreign" formats. We cope with NTFS, HFS and various bizarre crappy "Software RAID" formats, amongst other things. That includes the special on-flash formats like the  NAND Flash Translation Layer used on the M-Systems DiskOnChip devices, which has been supported for about a decade. Are you suggesting that hardware vendors take Linux <em>less</em> seriously now than they did ten years ago, and that we'd have a harder time working out how to interoperate? Remember, documenting the on-medium format doesn't necessarily give away all the implementation details like algorithms for wear levelling, etc. &mdash; that's why M-Systems were content to give us documentation, all that time ago.
<P>
Secondly, interoperability at that level isn't a showstopper. It's <em>nice</em> to have, admittedly, but I'm not going to lose a lot of sleep if I can't mount my Windows or MacOS file system under Linux. It's the native functionality of the device under Linux that I care about most of the time.
<P>
Of course, I see no reason why the device vendors should be pushing their own "speshul" formats anyway &mdash; the hard drive vendors don't. But I'm not naïve enough to think that they won't try.
<HR>
<P>
Imagine a world where every hard drive you buy is actually a more like a NAS. You can only talk a high-level protocol like CIFS or NFS to it; you can't access the sectors directly. Each vendor has their own proprietary file system on it internally, implemented behind closed doors by the same kind of people who write BIOSes. You have no real information about what's inside, and can't make educated decisions on which products to buy. Having made your choice you can't debug it, you can't optimise it for your own use case, you can't try to recover your data when things go wrong, and you sure as hell can't use btrfs on it. All you can do is pray to the deity of your choice, then throw the poxy thing out the window when it loses your data.<P>
If the above paragraph leaves you in a cold sweat, it was intended to. 
That's the kind of dystopia I see in my head, when we talk about SSDs without direct access to the flash.

      
          <div class="CommentReplyButton">
            <form action="/Articles/328246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor328248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2009 1:46 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/328248/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
What I'd like to see is something I can get off the shelf at my local Computer Mart (or on the web) that plugs into my PC and gives me raw flash. 
</blockquote>
<p>
If a PCIe expansion socket is sufficient, several companies are now selling that.  I remember IBM demonstrating last year a prototype storage server composed of a bunch of Linux systems with Fusion-IO PCI Express cards for storage.  It broke some kind of record.
<p>
In that system, the flash storage still appeared as a block device, but it did it at the Linux block device interface instead of at the SCSI physical interface.

      
          <div class="CommentReplyButton">
            <form action="/Articles/328248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2009 18:53 UTC (Thu)
                               by <b>wmf</b> (guest, #33791)
                              [<a href="/Articles/328745/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fusion io is not raw flash since the driver contains a sophisticated FTL that cannot be disabled. In theory they could release an MTD driver, but they're not going to.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2009 20:15 UTC (Thu)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/328753/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Fusion io is not raw flash since the driver contains a sophisticated FTL that cannot be disabled. In theory they could release an MTD driver, but they're not going to.
</blockquote>
<p>
Is the driver you're talking about a Linux kernel module?  An object code only one?
<p>
What is MTD?

      
          <div class="CommentReplyButton">
            <form action="/Articles/328753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328767"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">All this has happened before...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2009 21:55 UTC (Thu)
                               by <b>wmf</b> (guest, #33791)
                              [<a href="/Articles/328767/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>Is the driver you're talking about a Linux kernel module? An object code only one?</blockquote>

Yep.

<blockquote>What is MTD?</blockquote>

<a rel="nofollow" href="http://www.linux-mtd.infradead.org/">How you access raw flash.</a> See also <a rel="nofollow" href="http://www.linux-mtd.infradead.org/doc/ubifs.html#L_raw_vs_ftl">UBIFS Raw flash vs. FTL devices</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/328767/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor329027"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 19, 2009 14:11 UTC (Sun)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/329027/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What I'd like to see is something I can get off the shelf at my local </font><br>
Computer Mart (or on the web) that plugs into my PC and gives me raw <br>
flash. Instead of focusing on "right sized" and "small" and "maximizing <br>
battery life", it instead can be a bank of parallel flash such as what <br>
Intel's SSD disks are, but with a raw interface. We can then use our <br>
existing flash filesystems and infrastructure to drive those in a desktop <br>
and laptop space<br>
<p>
Unlike block based file systems like ext[234], the existing flash file <br>
systems are designed for very small file systems.  E.g. JFFS2 keeps the <br>
whole file system metadata in RAM and is unusable in GB sized file <br>
systems.<br>
<p>
However, the newly merged UBIFS promises to work much better:<br>
* <a href="http://lwn.net/Articles/275706/">http://lwn.net/Articles/275706/</a><br>
* <a href="http://www.linux-mtd.infradead.org/doc/ubifs.html#L_scalability">http://www.linux-mtd.infradead.org/doc/ubifs.html#L_scala...</a><br>
<p>
There's not usage data on how well it performs with desktop and server <br>
loads though.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/329027/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor329029"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 19, 2009 14:28 UTC (Sun)
                               by <b>dwmw2</b> (subscriber, #2063)
                              [<a href="/Articles/329029/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <BLOCKQUOTE><I>"
Unlike block based file systems like ext[234], the existing flash file
systems are designed for very small file systems. E.g. JFFS2 keeps the
whole file system metadata in RAM and is unusable in GB sized file
systems."</I></BLOCKQUOTE>

Very true &mdash; although we put a lot of effort in to make JFFS2 better for OLPC with its 1GiB of NAND flash. It mounts in 6 seconds or so, and we reduced the RAM usage by a significant amount too. But still, JFFS2 was designed in the days of 32MiB or so of NOR flash, and definitely isn't intended to scale up to the kind of sizes we're seeing now.
<P>
UBIFS is much more promising, but as you correctly observe is not yet proven for desktop or server workloads. I'm actually keen to get btrfs working on raw flash, too.
<P>
The point is that with stuff done in software, we <em>can</em> do better; whether we do better or not <em>today</em> is a different, and less interesting issue.<P>
After all, we can always implement the same <em>"pretend to be a block device"</em> kind of thing to tide us over in the short term, if we need to. We have three or four such translation layers in Linux already, and more on the way.
      
          <div class="CommentReplyButton">
            <form action="/Articles/329029/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor328245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2009 0:42 UTC (Sun)
                               by <b>dwmw2</b> (subscriber, #2063)
                              [<a href="/Articles/328245/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <BLOCKQUOTE><I>"So you're saying there is innovation to be done. That means there's something for someone to monopolize with a patent.
<P>
"At least with a black box, the patents are all paid for as part of acquiring the box. In contrast, when you need a patent license to run some code in your own Linux system, it usually means the code is useless."</I></BLOCKQUOTE>

That's a very pessimistic viewpoint. If you truly believe that the patent system is <em>so</em> broken and abused that it prevents all innovation, I'd recommend a career in goat-herding. You obviously wouldn't want to be involved in any form of innovative software development &mdash; either Free Software or otherwise.<P>
Thankfully, I don't think it's a valid viewpoint either &mdash; as broken as the patent system is, I don't think it's time to throw in the towel just yet. 
      
          <div class="CommentReplyButton">
            <form action="/Articles/328245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2009 1:33 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/328247/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
<blockquote>
<p>So you're saying there is innovation to be done. That means there's something for someone to monopolize with a patent. 

<p>At least with a black box, the patents are all paid for as part of acquiring the box. In contrast, when you need a patent license to run some code in your own Linux system, it usually means the code is useless."
</blockquote>
<p>
That's a very pessimistic viewpoint. If you truly believe that the patent system is so broken and abused that it prevents all innovation, ...
</blockquote>
<p>
But I said the opposite.  I suggested someone <em>would</em> do the innovation.  And then patent it.  It is not pessimistic to expect an inventor to patent his invention; they do it all the time, even for trivial inventions.
<p>
Patents seem to be anathema to the Linux world.  I thought you said patents are the reason Linux and Winmodems don't get along; I'm just trying to complete the analogy.
      
          <div class="CommentReplyButton">
            <form action="/Articles/328247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328249"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Winmodem-like solid state storage</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2009 2:05 UTC (Sun)
                               by <b>dwmw2</b> (subscriber, #2063)
                              [<a href="/Articles/328249/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <BLOCKQUOTE><I>"But I said the opposite. I suggested someone would do the innovation. And then patent it. It is not pessimistic to expect an inventor to patent his invention; they do it all the time, even for trivial inventions."</I></BLOCKQUOTE>

Then we need to make sure we get there first, patent it ourselves and license the patent appropriately for use in Free Software.
<P>
What's the alternative? To always assume that someone will have got there first, and that any software development that's even <em>remotely</em> innovative will fall foul of a patent and thus, in your words, be <i>"useless"</i>?<P>
That's what I meant when I said it <i>"prevents innovation"</I> &mdash; I mean it prevents innovation for <em>us</em>, if we always assume everything interesting will already be patented. And that part of the discussion isn't really specific to modems or SSDs, is it? It applies right across the board.

<BLOCKQUOTE><I>"Patents seem to be anathema to the Linux world. I thought you said patents are the reason Linux and Winmodems don't get along; I'm just trying to complete the analogy."</I></BLOCKQUOTE>

Modems are a special case, because you <em>need</em> to implement precisely the patented algorithms in order to communicate with another modem using the affected standards.
<P>For flash storage, you don't have to do that; you have a lot more flexibility to come up with something that <em>isn't</em> affected by patents. A closer analogy might be audio/video compression &mdash; where the Free Software world was able to come up with the patent-free Ogg and Theora codecs.
      
          <div class="CommentReplyButton">
            <form action="/Articles/328249/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor327973"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 8:28 UTC (Thu)
                               by <b>viiru</b> (subscriber, #53129)
                              [<a href="/Articles/327973/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Aggressive use of TRIM when committing entries out of the journal would </font><br>
<font class="QuotedText">&gt; make it easier to reap blocks within this faster level of hierarchy, and </font><br>
<font class="QuotedText">&gt; would make the drive less sensitive to the size of the journal. That is, </font><br>
<font class="QuotedText">&gt; the journal could be much larger than the NVRAM size, but you'd still get </font><br>
<font class="QuotedText">&gt; the benefit if the *active* part of the journal fit in the NVRAM.</font><br>
<p>
Aggressive use of TRIM on the journal could also mean TRIMming the journal completely on a clean mount, or even after replaying it on an unclean mount (some care needs to be taken here, though). I think this could help wear leveling on laptops and netbooks quite a bit (they boot often), and those are currently the place where the biggest advantages of SSDs are.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327973/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor328744"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2009 18:43 UTC (Thu)
                               by <b>wmf</b> (guest, #33791)
                              [<a href="/Articles/328744/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>I wonder if SSDs will ever gain an additional level of hierarchy, such as an NVRAM layer over the flash layer. "Hot write" zones could then live in the NVRAM layer and only be committed to flash infrequently.</blockquote>

If you're willing to pay $50/GB, the STEC ZeusIOPS and TMS RamSAN provide something like this. For affordable SSDs I expect DRAM caches to range between tiny and nonexistent.
      
          <div class="CommentReplyButton">
            <form action="/Articles/328744/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, part 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 17, 2009 22:10 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/328931/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But why? RAM caches are not not tiny-to-nonexistent for inexpensive server <br>
hardware RAID cards, for instance (Areca, for instance, has a 256Mb cache <br>
in its 4-port cards, rising to 2Gb I think in the huge ones).<br>
<p>
Now 256Mb may not be immense but it's surely not tiny either.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor327926"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unerase</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 21:29 UTC (Wed)
                               by <b>Felix_the_Mac</b> (guest, #32242)
                              [<a href="/Articles/327926/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"sometimes people want to be able to get back the contents of an erroneously-deleted file."<br>
<p>
Isn't this desire/expectation just a relic of having been exposed to poorly implemented/insecure file systems in the past? ie. DOS!<br>
<p>
Do we really want to design this in?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327926/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unerase</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 12:24 UTC (Thu)
                               by <b>prl</b> (guest, #44893)
                              [<a href="/Articles/327989/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If it is needed, then it needs to be designed in. Properly, with well understood version control and security (arguably this should be done in user space). And if it *isn't* (whether filesystem wide or per-file), the OS should be able to scrunge a file from the media beyond any reasonable hope of recovery). What we *don't* want us the DOS/FAT style of "well you, might get it back if you're lucky and buy this add-on utility".<br>
<p>
One of the problems with letting the device firmware handle this is just how effectively a deleted block has been deleted. If the OS has access to the raw hardware, then the user actually gets to control the precise level of undeleteability, which strikes me as being what we want.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor328091"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unerase</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2009 0:50 UTC (Fri)
                               by <b>aigarius</b> (guest, #7329)
                              [<a href="/Articles/328091/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Users delete important file to which they have no backups. Happens all the time. A very simple way to undelete stuff is a very welcome feature in any operating system. It could be an option in a filesystem, enabled by a parameter.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328091/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor327925"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Intel SSD vs. cheap netbook SSDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 21:37 UTC (Wed)
                               by <b>osma</b> (subscriber, #6912)
                              [<a href="/Articles/327925/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When Linux SSD performance is discussed Intel SSD hardware always comes up, which is natural since it represents the next generation of SSD storage.<br>
<p>
What I'm interested in, though, is not the expensive, big and fast SSDs like the Intel offering but the much cheaper and smaller Flash drives used in netbooks and the like. I'm writing this on an Eee 901 with two SSDs, a relatively fast 4GB system drive and a slower 16GB drive for user data. My understanding is that Linux performance on these drives is not quite optimal.<br>
<p>
I currently use ext2 filesystems with the noop scheduler on my Eee, as this seems to be one of the better (at least faster) configurations. What I'd like is a fast, reliable and power-efficient filesystem/scheduler combination for a netbook. I don't have specific complaints about the current state of affairs, but I'd be surprised if there wasn't room for improvements considering that the current filesystems and schedulers were designed with spinning disks in mind.<br>
<p>
Is there any development effort currently underway that would improve performance specifically on cheap netbook SSDs, or will the work discussed in the article be relevant for all kinds of SSDs?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327925/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327927"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Intel SSD vs. cheap netbook SSDs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2009 21:44 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/327927/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The intent, certainly, is to try to perform as well as possible on the full range of devices.
      
          <div class="CommentReplyButton">
            <form action="/Articles/327927/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor327987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Repartition and trim</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 11:59 UTC (Thu)
                               by <b>NRArnot</b> (subscriber, #3033)
                              [<a href="/Articles/327987/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For heaven's sake, don't allow the data on the device to be splatted just because some unfortunate system manager makes a mistake with fdisk! (I've been there with a plain vanilla disk - after getting over being very scared, I worked out what I did wrong, rewrote the partition table right, abd lost no data). <br>
<p>
Surely the right answer is just to add a trim command into fdisk and other partition table tools.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor327988"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Open  hardware opportunity?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 12:19 UTC (Thu)
                               by <b>NRArnot</b> (subscriber, #3033)
                              [<a href="/Articles/327988/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is the "valuable intellectual property" being built into SDDs simply a load of firmware fixing to make the things usable by current and historical operating systems by pretending to be disks? Or is there stuff in there which really does require the sort of realtime or other intense attention that a general purpose operating system can't efficiently provide?<br>
<p>
If the former, how about some hardware person designs a fully open PCIX board populated with a load of flash memory and appropriate (minimalist) interfaces? I'm not a hardware engineer, but I suspect that such a board might be quite a simple thing to design. Then implement all the code for using it as a storage device in linux drivers, kernel and filesystems. Could such a thing end up outperforming even the best SDD manufacturers' firmware? And might some genuinely key bit of intellectual property end up being invented here first, and GPLed?<br>
<p>
OK I'm dreaming, now shoot me down.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327988/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328071"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Open  hardware opportunity?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 20:31 UTC (Thu)
                               by <b>neli</b> (guest, #51380)
                              [<a href="/Articles/328071/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The SSD hardware/firmware is more than wear levelling alone. I.e. just providing access to an array of flash devices isn't the same - consider sector size for example; while also providing those insane read/write speeds.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328071/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor328182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Open  hardware opportunity?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2009 18:48 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/328182/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
how about some hardware person designs a fully open PCIX board populated with a load of flash memory and appropriate (minimalist) interfaces?  ... Then implement all the code for using it as a storage device in linux drivers, kernel and filesystems.
</blockquote>
<p>
I recently saw a list of four companies doing that.  One I remember is FusionIO.  (Not actually PCIX, though -- PCI Express (PCIe), which is probably what you meant).  In addition to allowing more efficient use by the OS than SSDs, it's also cheaper -- less waste.
<p>
It's the best solution for many problems, but SSDs are going to be essential for a long, long time because they're easier to integrate into existing systems.

      
          <div class="CommentReplyButton">
            <form action="/Articles/328182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor328769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Open hardware opportunity?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2009 22:02 UTC (Thu)
                               by <b>wmf</b> (guest, #33791)
                              [<a href="/Articles/328769/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>If the former, how about some hardware person designs a fully open PCIX board populated with a load of flash memory and appropriate (minimalist) interfaces? I'm not a hardware engineer, but I suspect that such a board might be quite a simple thing to design.</blockquote>

The mass market doesn't want this, so it would be more expensive than a traditional SSD. It's a cool idea, though.
      
          <div class="CommentReplyButton">
            <form action="/Articles/328769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor328033"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 16:59 UTC (Thu)
                               by <b>MisterIO</b> (guest, #36192)
                              [<a href="/Articles/328033/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Aren't the two phrases "I/O requests should be submitted immediately; the block I/O subsystem shouldn't even attempt to merge adjacent requests" and "Bundling things into larger requests will tend to increase the overall bandwidth" in constrast?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328033/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 20:31 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/328070/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would seem that way.  The main thing is that you don't want excessive scheduling between unrelated requests (which is what CFQ and elevator algorithms do), whereas things that are naturally large blocks you want to go as large blocks (such as a large streaming read or large streaming write).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor328035"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 17:31 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/328035/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the spirit of this particular workshop, you shouldn't call it "receiving another attendee's notes", you should call it "rebuilding your RAGE".<br>
<p>
(Where, of course, a "RAGE" is a Redundant Array of Grumpy Editors)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328035/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2009 2:52 UTC (Tue)
                               by <b>xoddam</b> (guest, #2322)
                              [<a href="/Articles/328390/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SOL (Snigger Out Loud).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/328390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor328183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2009 19:04 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/328183/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
they will sell an array which claims to be much larger than the amount of storage actually installed.
</blockquote>
<p>
This is a really poor description of thin provisioning.  For those who didn't get it: thin provisioning means the storage server allows you to create volumes whose total size exceeds the actual storage capacity of the system.  So you don't buy disk drives to back the unused portion of those volumes.
<p>
<blockquote>
But that leads to an interesting problem if trim is used to discard the contents of some blocks in the middle of the file. If the application later writes to those blocks - which are, theoretically, still in place - the system could discover that the device is out of space and fail the request. That, in turn, could lead to chaos.
</blockquote>
<p>
That's no more interesting than the simpler problem that when you go to extend a sequential file, the write request fails even though the filesystem has space available.
<p>
These systems work only if you can manage the system in such a way that running out of actual storage space is about as rare as a power supply failure.  That means keeping a large amount of unused space at all times and monitoring consumption rates.  
<p>
I think to do it right, the storage system would probably also have to slow down as it approaches full so as to protect itself from a runaway storage consumer.

      
          <div class="CommentReplyButton">
            <form action="/Articles/328183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 17, 2009 21:10 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/328923/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
   That's no more interesting than the simpler problem that when you go
   to extend a sequential file, the write request fails even though the
   filesystem has space available. 
</blockquote>

This was in the context of an application having used the posix_fallocate() call.  If that call succeeds, the application is guaranteed to be able to use the storage that has been so allocated.  Thin Provisioning breaks this, and it's far from clear how to fix it.
      
          <div class="CommentReplyButton">
            <form action="/Articles/328923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor328976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2009 22:10 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/328976/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
<blockquote>
That's no more interesting than the simpler problem that when you go to extend a sequential file, the write request fails even though the filesystem has space available.
</blockquote>
This was in the context of an application having used the posix_fallocate() call. If that call succeeds, the application is guaranteed to be able to use the storage that has been so allocated. Thin Provisioning breaks this, and it's far from clear how to fix it.
</blockquote>
<p>
No, posix_fallocate() doesn't guarantee you can use the storage.  Your write to it could fail, for example, due to a media defect.  What posix_fallocate() guarantees is that a write won't fail because there is no space left in the filesystem.  That's the same guarantee you get from mkfs that if you create a 1G filesystem, you can put (about) 1G of files in it.  So it's equally interesting that with thin provisioning, your fallocated space within a file may be unusable as that your filesystem space may be unusable for extending the file.
<p>
With thin provisioning, the filesystem storage medium is a volume in the storage server, which does in fact have space for the write in question.  What doesn't have space is the server's pool of backing storage, and the effect of that is a write to certain sectors of the volume fails.

      
          <div class="CommentReplyButton">
            <form action="/Articles/328976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor329129"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2009 14:35 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/329129/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      The text from the standard says:

<blockquote>
DESCRIPTION
<br>
    The posix_fallocate() function shall ensure that any required storage for regular file data starting at offset and continuing for len bytes is allocated on the file system storage media. If posix_fallocate() returns successfully, subsequent writes to the specified file data shall not fail due to the lack of free space on the file system storage media.
</blockquote>

I stand by my assertion that it is currently impossible to provide this with Thin Provisioning without actually writing to every single block.
      
          <div class="CommentReplyButton">
            <form action="/Articles/329129/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor329145"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2009 16:05 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/329145/">Link</a>] 
      </p>
      
      </div>
      </summary>
      That's entirely consistent with what I wrote.  There <em>is</em> space in the filesystem.  (If there weren't, the write would fail with ENOSPC and statfs() would show no space).
<p>
The only problem is that writes to certain sectors of the storage medium fail for reasons out of the scope of POSIX.
<p>
There's layering going on here.

      
          <div class="CommentReplyButton">
            <form action="/Articles/329145/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor328204"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux Storage and Filesystem Workshop, day 2</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2009 0:27 UTC (Sat)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/328204/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>
<b>readdirplus()</b>
<p>
The creation of this system call looks like an opportunity to leave some old mistakes behind. So, for example, it will not support seeking within a directory.</i>
<p>
There is some irony here. The name "readdirplus" comes from NFS - NFSv3 introduced a READDIRPLUS protocol request for exactly the same reason.
<p>
And to support NFS, you absolutely need to be able to seek within a directory.  It is conceivable that some .x version of NFSv4 might remove this requirement.  But until we agree to stop supporting NFSv3, we need to be able to seek within a directory.

      
          <div class="CommentReplyButton">
            <form action="/Articles/328204/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
