        <!DOCTYPE html>
        <html lang="en">
        <head><title>The first Operating-System-Directed Power-Management Summit [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/721573/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/721183/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/721573/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The first Operating-System-Directed Power-Management Summit</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="GAByline">
           <p>May 3, 2017</p>
           <p>This article was contributed by Dietmar Eggemann</p>
           </div>
<p>The first <a
href="http://retis.sssup.it/ospm-summit/">Operating-System-Directed
Power-Management (OSPM) Summit</a> took place at the ReTiS Lab of  
the Scuola Superiore Sant'Anna in Pisa on April&nbsp;3 and&nbsp;4, 2017.

This summit was organized as a collection of collaborative sessions
focused on trying to improve how operating-system-directed power
management and the kernel's task scheduler  can work together
to achieve the goal of reducing energy consumption while still meeting
performance and latency requirements. This subject is receiving great
interest, not least since the advent of energy-aware scheduling (EAS) and
heterogeneous CPU designs.</p>

<p>Since such a complex endeavor requires experts from multiple areas of
expertise, the summit brought together people from academia, open-source
maintainership (Peter Zijlstra, Rafael Wysocki, Thomas
Gleixner), and industry (Google, Red Hat, Linaro, NVIDIA,
LG Electronics, BayLibre, Huawei, Qualcomm, and ARM). The relaxed
atmosphere of the venue and the manageable group of attendees allowed for
intense debate and face-to-face discussions about current problems.
Several proposals or proof-of-concept solutions were presented during the
sessions.</p>

<p>The following chapters, clustered by functional area, summarize the
discussions of the individual sessions. Each chapter headline represents a
link to a YouTube recording of the corresponding session.</p>

<h4>Per-entity load tracking</h4>
<b><a href="https://www.youtube.com/watch?v=HqPkw6B1S9w">Latest evolution
in PELT</a></b>.
Vincent Guittot started his presentation by showing the
improvements on the stability and accuracy of the <a
href="/Articles/531853/">per-entity load tracking</a> (PELT) signals achieved
since v4.9. One of the biggest problems remaining is that an idle CPU can
have stale load and utilization values and can therefore appear as loaded
or busy even though it has been idle for some time. He <a href="https://marc.info/?l=linux-kernel&amp;m=149181593423655">proposed</a>
changing the frequency- and CPU-invariance mechanism from scaling
individual load and utilization contribution values (in response to voltage
and frequency changes) to scaling the running time. 
<p>

Another topic was the possible integration of a PELT-based mechanism for
realtime class utilization tracking that would represent time stolen from the
completely fair scheduling (CFS) class by realtime tasks. Currently, due to
the lack of any utilization signal for realtime 
tasks, we go to maximum CPU frequency at the first tick after a realtime task is
enqueued. When that task blocks and a CFS task starts running, the
schedutil CPU-frequency governor receives 
the (by now decayed) CFS utilization value, which leads to a sudden
CPU-frequency drop. This could be avoided by considering the realtime task
utilization when invoking schedutil. The mechanism should work similarly to
the calculation of the remaining CPU capacity for CFS tasks via
<tt>scale_rt_capacity()</tt>, but for utilization instead.
<p>

A similar issue that was discussed is the frequency drop that occurs when a
CFS task migrates away from an overloaded CPU.</p>
<p>
<blockquote>
<a href="/Articles/721699/"><img src="https://static.lwn.net/images/2017/ospm-group-sm.jpg"
alt="[Group photo]" class="photo"></a>
</blockquote>
<p>

<b><a href="https://www.youtube.com/watch?v=adnSHPBGS-w">PELT decay
clamping/UTIL_EST</a></b>.
Morten Rasmussen showed the results of his PELT decay-clamping
implementation, an idea that was first proposed by Paul Turner during the
2016 Linux Plumbers Conference in Santa Fe. The problem is that we lose
history for a big task 
that sleeps for a long time. Decay clamping places a limit on the time
for which a task’s load-tracking signals can decay after the task sleeps,
making the task appear to have slept for less time. The actual
implementation revealed some issues with the idea. Since entity load and
utilization are accrued in a CFS run queue, they would have to be de-clamped in
case the entity is attached or detached to or from the queue. Another
issue is that the preempted time of a co-scheduled task is not accounted
as sleep time.</p>

<p>Patrick Bellasi demonstrated an alternative approach, UTIL_EST,
which keeps PELT as an estimator and adds a new signal, the estimated
utilization (hence the name) as a sort-of low pass filter on PELT’s
derived values. The current proposal tracks both the utilization at task
deactivation time as well as an exponential moving average of these
values. A series implementing this idea is going to be posted soon on the
linux-kernel mailing list for a better evaluation.</p>

<b><a href="https://www.youtube.com/watch?v=tyoFqxviXOY">Tracepoints for
PELT</a></b>.
Dietmar Eggemann explained his <a
href="https://marc.info/?l=linux-kernel&amp;m=149068303518607&amp;w=2">patch
set</a>,
that introduces trace events for the scheduler’s load and utilization
signals. There is definitely a need to be able to trace the input signals
for task scheduler wake-up and load-balancing decisions as well as
schedutil cpufreq governor behavior. Several problems with PELT have been
fixed over the last few months and having standard tracepoints would have
likely helped to locate them quicker. There was feedback that these trace
events should support other scheduler classes as well rather than just
CFS.</p>

<h4>Energy-aware scheduling</h4>
<p>
<b><a href="https://www.youtube.com/watch?v=9e1Z6X0x02o">EAS: where we
are</a></b>. 
Morten Rasmussen started with a short introduction on EAS and its
importance in maximizing both CPU utilization and power efficiency, along with a
short overview of why frequency- and CPU-invariant scaling for PELT load
and utilization signals is important. He made it clear that having an
energy model is key for scheduling decisions based on energy consumption
and that the EAS energy model is the best we can currently do. He
continued by pointing out that there is no place to store energy data
(energy consumption per operating performance point (OPP) and per idle
state at every scheduling domain level) in mainline Linux. 
<p>

The device tree would be a good place to store such information but there
is a lot of resistance from the device-tree community. For them, energy data
should
describe hardware configuration (in this case CPU core) data, which should
be provided by the core designer. Or at least they require a strictly
defined method to determine the energy consumption. What they don't want
is a situation where different vendors have different values for the same
CPU core.
<p>

But energy data is a platform-specific property rather than a core-specific
one, so
each vendor would have to provide it. The methodology to 
obtain the values for the energy model is to measure the energy
consumption while the platform is forced to run a workload on subsets of
cores at fixed OPPs or idle at fixed idle states. The workload is not
standardized and it is clear that the values gathered are for the
instruction mix of this specific workload. This also requires that energy
consumption is measurable at the core and cluster scheduling domain levels.
<p>

EAS uses the relative numbers of the energy
model; in other words, the energy model is like a single tuning knob for
EAS. This is another 
reason why the device-tree folks argue that it does not belong into the
device tree. 

A possible simplification of the energy model based solely on CPU-level
data and not on aggregate data (e.g. on cluster-level) might be the way
forward.</p>

<b><a href="https://www.youtube.com/watch?v=6MC1jbYbQTo">Schedtune</a></b>.
Patrick Bellasi presented the latest version of the <a
href="https://lkml.org/lkml/2017/2/28/355">per-task 
capacity clamping</a> series recently posted on the mailing list and described in
<a href="/Articles/716303/">this LWN article</a>. People
seem to agree on the usefulness of a better interface to collect
task-related information from an informed run-time system. However, whether
this interface should be the one proposed is not yet agreed. The main problem is
the identification of a proper level of abstraction that achieves
the goals without exposing too many implementation and platform
details.
<p>
Other discussion points were about the use of the proposed
features outside of the Android-specific domain. There are other run-time
systems 
(e.g. ChromeOS and Kubernetes) that might be interested in the
proposed interface. Moreover, it can be used to improve existing features
such as avoiding a jump to the maximum frequency every time a realtime task
runs. Alternative implementations to boost the minimum capacity have been
discussed but some of them were already rejected in the past for various
reasons. There was no agreement that the control-group-based interface would be
sufficient so it is likely that a per-task interface will have to be added.
Overall the discussion was useful to make key maintainers aware of the
proposal.</p>

<b><a href="https://www.youtube.com/watch?v=JEIvZBh5Ou8">Schedutil
governor improvements</a></b>.
Rafael Wysocki led a discussion about issues related to the current
frequency change-rate limiting in schedutil. This CPU-frequency governor
has been around for a year now, people are starting to use it, and 
bug 
reports are beginning to appear. He is keen to address those <a
href="https://marc.info/?l=linux-kernel&amp;m=149091017523940&amp;w=2">issues</a> 
now so that people don’t lose interest in deploying schedutil.
<p>

The rate-limiting mechanism, designed to prevent frequency updates from
happening too often (which may lead to some undesirable effects), is
arguably suboptimal, but some relatively inexpensive improvements appear
to be possible. A few of them were discussed during the session, including
allowing cpufreq drivers to instruct the governor to use shorter intervals
between consecutive frequency updates by default, aggregating utilization
updates that occur between consecutive frequency updates, and making the
governor reduce frequencies less aggressively.
<p>

There was also some brief discussion regarding other schedutil
improvements proposed so far, including cross-CPU utilization updates.
</p>

<b><a href="https://www.youtube.com/watch?v=bLt8JjOO-kc">Energy model &amp;
exotic topologies</a></b>.
Brendan Jackman gave an overview of the energy model that EAS uses to
estimate the energy impact of a task-placement decision. He mentioned that
a simplified version of the model, one that considers each CPU in isolation,
may be the best approach for initial upstreaming of EAS. He then briefly
described some of the key features of ARM’s new DynamIQ cluster
architecture and the challenges they present to Linux’s OSPM and task
scheduler implementations.</p>

<h4>Realtime scheduling</h4>
<p>
<b><a
href="https://www.youtube.com/watch?v=daNZp8rW5fU"><tt>SCHED_DEADLINE</tt>
and reclaiming</a></b>.
Luca Abeni gave an overview of his work implementing the GRUB bandwidth
reclaiming algorithm for <tt>SCHED_DEADLINE</tt>. In fact, one problem with
using 
<tt>SCHED_DEADLINE</tt> is that it is not usually easy to come up with the right
set of parameters (execution time, deadline, and period) to describe task
behavior. 
Bandwidth reclaiming helps with this by allowing a task that occasionally
needs more CPU time than its parameters would allow to reclaim bandwidth
left over from other tasks. Another good reason to merge this patch is
that it adds information about how much CPU capacity is required to
service the deadline tasks. This information is key for proper
clock-frequency selection (see below). 
<p>

Luca’s patch set is pretty mature, so he should be able to get it merged
relatively 
quickly after having addressed a few comments received during the discussion
and as part of the review of the <a href="https://marc.info/?l=linux-kernel&amp;m=149029880524038">latest
version</a> on the list.</p>

<b><a href="https://www.youtube.com/watch?v=UB-VGNmt6Nw">Schedutil for
<tt>SCHED_DEADLINE</tt></a></b>.
Juri Lelli and Claudio Scordino described their recent <a
href="https://marc.info/?l=linux-kernel&amp;m=149036457909119&amp;w=2">
patch set</a> that implements frequency- and CPU-invariance as well as
clock-frequency selection for <tt>SCHED_DEADLINE</tt>. The scale invariance bits
seemed 
uncontroversial since they are based on the same assumption as PELT's
scale invariance (run time scales linearly with current capacity).
<p>
The changes
required to modify clock frequency for <tt>SCHED_DEADLINE</tt> tasks, at
least on 
platforms that require a non-atomic context to implement clock scaling
(like ARM), generated a lively discussion instead. A major point
of contention was the fact that the kernel threads responsible for changing
clock frequency have to be able to preempt all other tasks, including
<tt>SCHED_DEADLINE</tt> tasks. The currently proposed solution is based on a
mechanism that treats these threads as "special"; they appear as
<tt>SCHED_DEADLINE</tt> 
tasks with an immediate deadline and infinite bandwidth. While this seems
to work 
in practice, it breaks admission control and priority inheritance
from a theoretical point of view. However, the agreement seems to be that
a solution that works in practice might be accepted to foster adoption
and further experimentation with the schedutil governor while a better,
longer-term approach, such as making clock-frequency changes atomic even on
ARM, is sought.</p>

<b><a href="https://www.youtube.com/watch?v=tweSBjUka4A"><tt>SCHED_DEADLINE</tt>
group scheduling</a></b>.
Luca Abeni presented a live demonstration of an <a
href="https://marc.info/?l=linux-kernel&amp;m=149098595612413">RFC
implementation</a> of <tt>SCHED_DEADLINE</tt> group scheduling (the set was recently
posted on the list by Alessio Balsini and is based on patches originally
implemented by Andrea Parri). This patch set provides hierarchical realtime
scheduling by nesting <tt>SCHED_</tt>{<tt>FIFO</tt>/<tt>RR</tt>}
fixed-priority scheduling entities 
within <tt>SCHED_DEADLINE</tt> reservations, allowing for groups of tasks to be
scheduled inside a single <tt>SCHED_DEADLINE</tt> entity. The informed reader
should notice some resemblance with the base idea of the “old” <a href="/Articles/398470/">IRMOS</a>
scheduler; such a reader wouldn’t be too far from being correct, as IRMOS
certainly inspired the current set of patches. In its current
form the mechanism is also proposed as a replacement for realtime throttling.
<p>

The RFC still has to ripen quite a bit (starting with proper <a
href="https://marc.info/?l=linux-kernel&amp;m=149098270111415">changelogs</a>),
but the necessity of extending <tt>SCHED_DEADLINE</tt> to deal with groups
of tasks 
seemed to be acknowledged by the people attending the summit. However, the
key question on how to properly integrate this new feature still has to be
answered: how to make it work even when group scheduling is not in
use.</p>

<h4>Power management</h4>
<b><a href="https://www.youtube.com/watch?v=I1GKEDHtqsY">Scheduler
decisions regarding idle</a></b>.
Daniel Lezcano presented some ideas on how the interrupt-prediction
functionality could be used to guide the scheduler's wakeup and
load-balancing decisions to guarantee maximal energy savings by leaving CPUs and
clusters in deeper idle states.

This mechanism would have to be switched on via a scheduler feature flag
indicating that the user considers saving energy as more important than
performance.
<p>
It is implemented with the following four changes:
<p>
<ol class="spacylist">
<li> Prevent waking a CPU or cluster that hasn't reached its target
     residency yet (a CPU entering an idle state consumes more energy if
     the break-even point hasn’t been reached).

<li> A newly idle CPU doesn’t pull tasks if it is the last CPU in the
     cluster, since there is a high probability the entire cluster will be
     powered down.

<li> A newly idle CPU pulls tasks from another
     cluster if this allows that cluster to go idle. 

<li> Compute the average time it takes to execute the different steps
     (heuristic, entering idle state, switch timers, etc.) of the idle
     path. This will allow evaluation of whether it is worth entering a deeper
     idle state through the costly idle path or if we should bail out
     sooner.
</ol>
<p>

These features can only work if we change the way how we compute the idle
duration and if we have the next-event information available when the task
scheduler makes its task placement decision. The change of the next event
from average to deadline duration will allow for higher precision, since
we then see how close a CPU or cluster is from being woken up.</p>

<b><a href="https://www.youtube.com/watch?v=7TBrcPMGrtI">A unified solution
for SoC idling</a></b>.
Ulf Hansson mentioned that, when it comes to saving energy on a
SoC, there are many devices besides the CPU that can enter low-power
states. He presented an approach to unify runtime and system-idle
management scenarios under a single runtime PM framework. One of the steps
is to extend runtime PM and generic PM domain support to include
CPUs to be able to manage idle states across the entire SoC.</p>

<h4>Miscellaneous</h4>
<b><a href="https://www.youtube.com/watch?v=JyA5MpVpAAM">Parameterizing CFS
load balancing</a></b>.
Dietmar Eggemann gave an overview of the CFS scheduler's
load balancer. The use of different input signals in the applied
heuristics, the support of multiple platforms with, possibly, specific
features (such as asymmetric packing), and the dependency of the code on input
signals that are no longer used makes it difficult to understand.
He argued that it should be possible to streamline the
existing code in such a way that, after the statistics-gathering phase, the
load-balancer can work only on one input signal, which could be any of
the number of tasks, the utilization, or the load.</p>

<b><a href="https://www.youtube.com/watch?v=fGGQIJ3Lg0k">I/O scheduling and
power management with storage devices</a></b>.
Luca Miccio started the session by
presenting the current status of the no-op, CFQ, and deadline I/O
schedulers. He then went on highlighting problems (showing a recorded demo
of several Android workloads running on a HiKey board) that existing
schedulers are faced with when applications have low latency
requirements. The proposed solution for these issues is <a
href="/Articles/709202/">the Budget Fair Queuing</a> (BFQ) scheduler,
which seemed (still looking at the same recorded
demo) capable of providing low latency even in the presence of background
I/O. He announced that BFQ is finally expected to land in the mainline during
the v4.12 merge window in its <a href="/Articles/718599/">BFQ-MQ</a>
incarnation.
<p>

Luca then handed over to his professor Paolo Valente, who moderated the
more forward-looking and open-ended part of the session, trying to find
intersections between I/O scheduling and OSPM. Starting with the current
state of the art (a black slide causing the audience to giggle) he then gathered
feedback around possible strategies for saving energy, such as idling during
I/O or controlling components' OPPs.</p>

<h4>Tooling</h4>

<p><b><a
href="https://www.youtube.com/watch?v=53jhYHXk8Os">Tooling/LISA</a></b>.
Patrick Bellasi and Brendan Jackman showed how ARM is testing EAS
behaviors. They presented the <a
href="https://github.com/scheduler-tools/rt-app">rt-app</a> tool used to
create synthetic workloads and the <a
href="https://github.com/ARM-software/lisa">LISA</a> toolkit that provides
regression testing and interactive analysis of Linux kernel behavior.</p>

<b><a href="https://www.youtube.com/watch?v=4BVVV-gbBk8">The need to
power-instrument the Linux kernel</a></b>.
Patrick Titiano stated that today we’re not able to do
continuous-integration tests on energy consumption even though there is
clear evidence that this is becoming more and more important.
This is mainly due to the fact that today's devices and the majority of
the development boards are not equipped for power measurements so people
still rely on hardware modifications. There was overall agreement that another
infrastructural bit missing is a standardized energy (consumption) model
for a device.</p>

<h4>Research</h4>
<p>
<b><a href="https://www.youtube.com/watch?v=_Xe_k_knF-4&amp;index=17&amp;list=PLohWCZQwiEVqYSyggG141vUeUOTLr1cHB">A
hierarchical scheduling model for dynamic soft-realtime systems</a></b>.
Vladimir Nikolov presented a user-space
based proposal for runtime administration of concurrent soft real-time
applications, which is part of the <a href="https://www.uni-ulm.de/en/in/vs/res/projects/artos/">ARTOS</a>
research project. The presented approach involves mechanisms for automated
application monitoring and cost estimation, extraction of required
processing bandwidth, and selection of optimal quality levels for the
applications during runtime. Thereby, capacity reservations are
established and updated at well-defined instants under the premise that
applications and their tasks remain consistent with their actual measured
costs. The system’s ability to handle cyclically occurring
loads and to suppress recurring re-configurations of application quality
levels were discussed as well. An interesting discussion was triggered
around the abstraction levels proposed as well as the usefulness of an
out-of-kernel solution.</p>

<h4>Conclusions</h4>
<p>This event has shown that there is a real need for detailed technical
discussion on how to improve Linux OSPM and task scheduler coordination in
addition to the limited amount of time available at the yearly Linux
Plumbers Conference. Many of the sessions helped to accelerate the
corresponding discussions on the linux-kernel mailing list. The organizers
received positive feedback from the participants about the usefulness
of such an event so they will look into scheduling a follow-on summit next
year.
<p>

Many thanks to all presenters, participants, and note-takers as well as to
the ReTiS Lab for providing the premises.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Power_management">Power management</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Eggemann_Dietmar">Eggemann, Dietmar</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#OS-Directed_Power-Management_Summit-2017">OS-Directed Power-Management Summit/2017</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/721573/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
