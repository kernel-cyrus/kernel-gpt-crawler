        <!DOCTYPE html>
        <html lang="en">
        <head><title>The realtime preemption mini-summit [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/354690/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/354013/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/354690/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The realtime preemption mini-summit</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 28, 2009</br>
           </div>
Prior to the <a
href="http://www.osadl.org/RTLWS-Agenda.rtlws11-agenda.0.html">Eleventh
Real Time Linux Workshop</a> in Dresden, Germany, a small
group met to discuss the further development of the realtime preemption
work for the Linux kernel.  This "mini-summit" covered a wide range of
topics, but was driven by a straightforward set of goals: the continuing
improvement of realtime capabilities in Linux and the merging of the
realtime preemption patches into the mainline.
<p>
The participants were:
Stefan Assmann,
Jan Blunck,
Jonathan Corbet,
Sven-Thorsten Dietrich,
Thomas Gleixner,
Darren Hart,
John Kacur,
Paul McKenney,
Ingo Molnar,
Oleg Nesterov,
Steven Rostedt,
Frederic Weisbecker,
Clark Williams, and
Peter Zijlstra.
Together they represented several companies working in the area of realtime
Linux; they brought a lot of experience with customer needs to the table.
The discussion was somewhat unstructured - no formal agenda existed - but
a lot of useful topics were covered.
<p>

<b>Threaded interrupt handlers</b> came out early in the discussion.  This
feature was merged into the mainline for the 2.6.30 kernel; it is useful in
realtime situations because it allows interrupt handlers to be prioritized
and scheduled like any other process.  
There is one part of the threaded interrupt code which remains outside of
the mainline: the piece which forces <i>all</i> drivers to use threaded
handlers.  There are no plans to move that code into the mainline; instead,
it's going to be a matter of persuasion to get driver writers to switch to
the newer way of doing things.
<p>
Uptake in the mainline is small so
far; few drivers are actually using this feature.  That is beginning to
change, though; the SCSI layer is one example.  SCSI has always featured
relatively heavyweight interrupt-handling code and work done in
single-threaded workqueues.  This code could move fairly 
naturally to process context; the SCSI developers are said to be evaluating
a possible move toward threaded interrupt handlers in the near future.
There have also been suggestions that the network stack 
might eventually move in that direction.
<p>

<b>System management interrupts</b> (SMIs) are a very different sort of
problem.  These interrupts happen at a very low level in the hardware and
are handled by the BIOS code.  They often perform hardware monitoring
tasks, from simple thermal monitoring to far more complex operations not
normally associated with BIOS-level software.  SMIs are almost entirely
invisible to the operating system and are
generally not subject to control at that level, but they are visible in 
some important ways: they monopolize anything between one CPU and all CPUs
in the system for a measurable period of time, and they can change
important parameters like the system clock rate.  SMIs on some types of
hardware can run for surprisingly long periods; one vendor sells systems
where an SMI for managing ECC memory runs for 200&micro;s every three
minutes.  That is long enough to play havoc with any latency deadlines
that the operating system is trying to meet.
<p>
Dealing with the SMI problem is a challenge.  Some hardware allows SMIs to
be disabled, but it's never clear what the consequences of doing so might
be; if the CPU melts into a puddle of silicon, the resulting latencies will
be even worse than before.  Sharing information about SMI problems can be
hard because 
many of the people working in this area are working under non-disclosure
agreements with the hardware vendors; this is unfortunate, because some
vendors have done a far better job of avoiding SMI-related latencies than
others.  There is a tool now (<a
href="http://lwn.net/Articles/337018/">hwlat_detector</a>) 
which can measure SMI latency, so we should start seeing more
publicly-posted information on this issue.  And, with luck, vendors will
start to deal with the problem.
<p>
Not all hardware latency is caused by SMIs; hypervisors, too, can be a
significant source of latency problems.
<p>
A related issue is hardware changes imposed by SMI handlers.  If the BIOS
determines that the system is overheating, it may respond by slowing the
clock rate or lowering the processor voltage.  On a throughput-oriented
system, that may well be the right thing to do.  When latencies are
important, though, slowing the processor could be a mistake - it could
cause applications to miss their deadlines.  A better response might be to
simply shut down some processors while keeping others at full speed.  What
is really needed here is a way to get this information to user space so
that policy decisions can be made there.
<p>


<b>Testing</b> is always an issue in this kind of software development; how
do the developers know that they are really making things better?  There
are various test suites out there (<a
href="http://sourceforge.net/projects/rtmicrobench/">RTMB</a>, for example),
but there is no complete and integrated test suite.
There was some talk of trying to move more of the realtime testing code into the
Linux Test Project, but LTP is a huge body of code.  So the realtime tests
might remain on their own, but it would be nice, at least, to standardize
test options and output formats to help with the automation of testing.
XML output from test programs is favored by some, but it is fair to say
that XML is not universally loved in this crowd.

<p>

The <b>big kernel lock</b> is a perennial outstanding issue for realtime
development for a couple of reasons.  One is that, despite having been
pushed out of much of the core code, the BKL can still create long
latencies.  The other is that elimination of the BKL would appear to be
part of the price for an eventual merge of sleeping spinlocks into the
mainline kernel.  The ability to preempt code running under the BKL was
removed in 2.6.26; this change was directly motivated by <a
href="http://lwn.net/Articles/281938/">a performance 
regression</a> caused by the semaphore rewrite, but it was also seen as a way
to help inspire BKL-removal efforts by those who care about latencies.
<p>
Much of the hard work in getting rid of the BKL has been done; one big
outstanding piece is the conversion of reiserfs being done by Frederic
Weisbecker.  After that, what's left is a lot of grunt work: figuring out
what (if anything) is protected by a lock_kernel() call and putting in
proper locking.  The "tip" tree has a branch (rt/kill-the-bkl) where this
work can be coordinated and collected.

<p>
<b>Signal delivery</b> is still not an entirely solved problem.  Actually,
signals are always a problem, for implementers and users alike.  In the
realtime context, signal delivery has some specific latency issues.  Signal
delivery to thread groups involves an O(n) algorithm to determine which
specific thread to target; getting through this code can create excessive
latencies.  There are also some locks in the delivery path 
which interfere with the delivery of signals in realtime interrupt
context.
<p>
Everybody agrees that the proper solution is to avoid signals in
applications whenever possible.  For example, <tt>timerfd()</tt> can be
used for timer events.  But everybody also agrees that applications will
continue to use signals, so they have to be made to work somehow.  The
probable solution is to remove much of the work from the immediate signal
delivery path.  Signal delivery would just enqueue the information and set
a bit in the task structure; the real work would then be done in the
context of the receiving process.  That work might still be expensive, but
it would at least fall to the process which is actually using signals
instead of imposing latencies on random parts of the system.
<p>

A side discussion on <b>best practices</b> for efficient realtime
application development yielded a few basic recommendations.  The best API
to use, it turns out, is the basic pthread interface; it has been well
optimized over time.  SYSV IPC is best avoided.
Cpusets work better than the affinity mechanism
for CPU isolation.  In general, developers should realize that getting the
best performance out of a realtime system will require a certain amount of
manual tuning effort.  Realtime Linux allows the prioritization of things
like interrupt handlers, but the hard work of figuring out what those
priorities should be can only be done by developers or administrators.  It
was acknowledged that the interfaces provided to administrators currently
are not entirely easy to use; it can be hard to identify interrupt threads,
for example.  Red Hat's <a
href="http://www.redhat.com/docs/en-US/Red_Hat_Enterprise_MRG/1.1/html/Realtime_Tuning_Guide/chap-Realtime_Tuning_Guide-General_System_Tuning.html#sect-Realtime_Tuning_Guide-General_System_Tuning-Using_the_Tuna_Interface">tuna</a>
tool can help in this regard, but more needs to be done.
<p>

<b>Scalability</b> was a common theme at the meeting.  As a general rule,
realtime development has not been focused specifically on scalability
issues.  But there is interest in running realtime applications on larger
systems, and that is bringing out problems.  The realtime kernel tends to
run into scalability problems before the mainline kernel does; it was
described as an early warning system which highlights issues that the
mainline will be dealing with five years from now.  So realtime will tend
to scale more poorly than mainline, but fixing realtime's problems will
eventually benefit mainline users as well.
<p>

<a href="http://rt.wiki.kernel.org/index.php/RTLWS"><img
src="https://static.lwn.net/images/conf/rtlws11/rtsummit-chart-sm.png" alt="[chart]" width=200
height=120 border=0 align="right" hspace=3></a>

Darren Hart presented <a
href="http://rt.wiki.kernel.org/index.php/RTLWS">a couple of charts</a>
containing the results of some work by John Stultz
showing the impact of running the realtime kernel on a 24-processor
system.  When running in anything other than uniprocessor mode, the
realtime kernel imposes a roughly 50% throughput penalty on a suitably
pathological workload - a severe price.
Interestingly, if the locking changes from the realtime kernel are removed
while leaving all of the other changes, most of the performance loss goes
away.  This has led Darren to wonder if there should be a hybrid option
available for situations where hard latency requirements are not present.
<p>
In other situations, the realtime kernel generally shows performance
degradation starting with eight CPUS, with sixteen showing unacceptable
overhead.
<p>
As it happens, nobody really understands where the performance cost of
realtime locking comes from.  It could be in the sleeping spinlocks, but
there is also a lot of suspicion directed at reader-writer locks.  In the
mainline kernel, rwlocks allow multiple readers to run in parallel; in the
realtime kernel, instead, only one reader runs at a time.  That change is
necessary to make priority inheritance work; priority inheritance in the
presence of multiple readers is a difficult problem.  One obvious
conclusion that comes from this observation is that, perhaps, rwlocks
should not implement priority inheritance.  There is resistance to that
idea, though; priority inheritance is important in situations where the
highest-priority process should always run as quickly as possible.
<p>
The alternative to changing rwlocks is to simply stop using them whenever
possible.  The usual way to remove an rwlock is to replace it with a
read-copy-update scheme.  Switching to RCU will improve scalability,
arguably at the cost of increasing complexity.  But before embarking on any
such effort, it is important to get a handle on how much of the problem
really comes down to rwlocks.  Some research will be done in the near
future  to better understand the source of the scalability problems.
<p>
Another problem is per-CPU variables, which work by disabling preemption
while a specific variable is being used.  Disabling preemption is anathema
to the realtime developers, so per-CPU variables in the realtime tree are
protected by sleeping locks instead.  That increases overhead.  The problem
is especially acute in slab-level memory allocators, which make extensive
use of per-CPU variables.
<p>
Solutions take a number of forms.  There will eventually be a more
realtime-friendly slab allocator, probably a variant of SLQB.  Minimizing
the use of per-CPU variables in general makes sense for realtime.
There are also schemes involving the creation of multiple virtual "CPUs" so
that even processes running on the same processor can have their own
"per-CPU" variables.  That decreases contention for those variables
considerably at the cost of a slightly higher cache footprint.
<p>

Plain old locks can also be a problem; a run of dbench on a 16-processor
system during the workshop showed a 90% reduction in throughput, with the
processors sitting idle half the time.  The problem in this case turns out
to be <tt>dcache_lock</tt>, one of the last global spinlocks remaining in
the kernel.  The realtime tree feels the effects of this lock more strongly
for a couple of reasons.  One is that threads holding the lock can be
preempted; that leads to longer lock hold times and more context switches.  The
other is that sleeping spinlocks are simply more complicated, especially in
the contended slow path of the code.  So the locking primitives themselves
require more CPU time.
<p>
The solution to this particular problem can only be the elimination of the
global <tt>dcache_lock</tt>.  Nick Piggin has a patch set which does
exactly that, but it has not yet been tested with the realtime tree.


<p>
Realtime makes life harder for the scheduler.  On a normal system, the
scheduler can optimize for overall system throughput.  The constraints
imposed by realtime, though, require the scheduler to respond much more
aggressively to events.  So context switches are higher and processes are
much more likely to migrate between CPUs - better for bounded response
times, but worse for throughput.  By the time the system scales up to
something relatively large - 128&nbsp;CPUs, say - there does not seem to be
any practical way to get consistently good decisions from the scheduler.
<p>
There is some interest in deadline-oriented schedulers.  Adding an
"earliest deadline first" or related scheduler could be useful for
application developers, but nobody seems to feel that a deadline scheduler
would scale better than the current code.

<p>
What all this means is that realtime applications running on that kind of system
must be partitioned.  When specific CPUs are set aside for specific
processes, the scheduling problem gets simpler.  Partitioning requires real
work on the part of the administrator, but it seems unavoidable for larger
systems. 
<p>
It doesn't help that complete CPU isolation is still hard to accomplish on
a Linux system.  Certain sorts of operations, such as workqueue flushes,
can spill into a processor which has been set aside for specific
processes.  In general, anything involving interrupts - both device
interrupts and inter-processor interrupts - is a problem when one is trying
to dedicate a CPU to a task.  Steering device interrupts to a given
processor is not that hard, though the management tools could use
improvement.  Inter-processor interrupts are currently harder to avoid;
code generating IPIs needs to be reviewed and, when possible, modified to
avoid interrupting processors which do not actually have work to do.
<p>
<a href="/Articles/354631/"><img
src="https://static.lwn.net/images/conf/rtlws11/rt-summit-sm.jpg" width=200 height=134
align="left" border=0 alt="[Group photo]" hspace=3></a>

Integrating interrupt management into the current cpuset and control group
code would be useful for system administrators.  That seems to be a harder
task; Paul Jackson, the original cpuset developer, was strongly opposed to
trying to include interrupt management there.  There's a lack of good
abstractions for this kind of administration, though the generic IRQ layer
helps.  The opinion at the meeting seemed to be that this was a solvable
problem; if it can be solved for the x86 architecture, the other
architectures will eventually follow.
<p>
Going to a fully tickless kernel is also an important step for full CPU
isolation.  Some work has recently been done in that direction, but much
remains to be done.

<p>
<b>Stable kernel ABI</b> concerns made a surprising appearance.  The
"enterprise" Linux offerings from distributors generally include a promise
that the internal kernel interface will not change.  The realtime
enterprise distributions have been an exception to this rule, though; the
realtime code is simply in too much flux to make such a promise practical.
This exemption has made life easier for developers working on that code,
naturally; it also has made it possible for customers to get the newest
code much more quickly.  There are some concerns that, once the remaining
realtime code is merged into the mainline, the same kernel ABI constraints
may be imposed on realtime distributions.  It is not clear that this needs
to happen, though; realtime customers seem to be more interested in keeping
up with newer technology and more willing to put up with large changes.
<p>

<b>Future work</b> was discussed briefly.  Some of the things remaining to
be done include:
<p>
<ul>
<li> More SMP work, especially on NUMA systems.
<p>
<li> A realtime idle loop.  There is the usual tension there between 
     preserving the best response time and minimizing power consumption. 
<p>
<li> Supporting hardware-assisted operations - things like onboard
     cryptographic acceleration hardware.
<p>
<li> Elimination of the timer tick.
<p>
<li> Synchronization of clock events across CPUs.  Clock synchronization is
     always a challenging task.  In this case, it's complicated by the fact
     that a certain amount of clock skew can actually be advantageous on an
     SMP system.  If clock events are strictly synchronized, processors
     will be trying to do things at the same time and lock contention will
     increase. 
</ul>
<p>

A near-future issue is <b>spinlock naming</b>.  Merging the sleeping
spinlock code requires a way to distinguish between traditional, spinning
locks and the newer type of lock which might sleep on a realtime system.
The best solution, in theory, is to rename sleeping locks to something like
<tt>lock_t</tt>, but that would be a huge change affecting many thousands
of files.  So the realtime developers have been contemplating a new name
for non-sleeping locks instead.  There are far fewer of these locks, so
renaming them to something like <tt>atomic_spinlock</tt> would be much less
disruptive.
<p>
There was some talk of the best names for "atomic spinlocks"; they could be
"core locks," "little kernel locks," or "dread locks."  What really came
out of the discussion, though, is that there was a fair amount of confusion
regarding the two types of locks even in this group, which understands them
better than anybody else.  That suggests that some extra care should go
into the naming, with the goal of making the locking semantics clear and
discouraging the use of non-sleeping locks.  If the semantics of
<tt>spinlock_t</tt> change, there is a good argument that the name should
also change.  That supports the idea of the massive lock renaming,
regardless of how disruptive it might be.
<p>
Whether such a change would be accepted is an open question, though.  For
now, both the small renaming and the massive renaming will be prepared for
review.  The issue may then be taken to the kernel summit in October for a
final decision.

<p>
<b>Tools</b> for realtime developers came up a couple of times.  There are
a number of tools for application optimization now, but they are scattered
and not always easy to use.  And, it is said, there needs to be a tool with
a graphical interface or a lot of users simply will not take it seriously.
The "perf" tool, part of the kernels "performance events" subsystem, seems
poised to grow into this role.  It can handle many of the desired tasks -
latency tracing, for example - now, and new features are being added.  The
"tuna" tool may be extended to provide a nicer interface to perf.
<p>
User-space tracepoints seem to be high on the list of desirable features
for application developers.  Best would be to integrate these tracepoints
with ftrace somehow.  Alternatively, user-space trace data could be
collected separately and integrated with kernel trace data at
postprocessing time.  That leads to clock synchronization issues, though,
which are never easy to solve.
<p>

The final part of the meeting became a series of informal discussions and
hacking efforts.  The participants universally saw it as a worthwhile
gathering, with much learned by all.  There are some obvious
action items, including more testing to better understand scalability
problems, increasing adoption of threaded interrupt handlers, solving the
spinlock naming problem, improving tools, and more.  Plenty of work for all
to do.  But your editor has been assured that the work will be done and
merged in the next year - for real this time.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Atomic_spinlocks">Atomic spinlocks</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Latency">Latency</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Realtime">Realtime</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Spinlocks">Spinlocks</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/354690/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor354715"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2009 22:00 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/354715/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
SYSV IPC is best avoided.
</blockquote>
Not just in realtime situations, of course.
<blockquote>
A realtime idle loop. There is the usual tension there between preserving 
the best response time and minimizing power consumption.
</blockquote>
Liunx can do infinite loops faster than anything else!
<blockquote>
Supporting hardware-assisted operations - things like onboard 
cryptographic acceleration hardware.
</blockquote>
Well, that's an interesting question, really. I've got a couple of 
machines with Geode CPUs now, and these have AES hardware acceleration. 
Some of the BSDs provide an interface that allows OpenSSL to use this, but 
as far as I can tell Linux does not. There's support for the Geode in the 
crypto layer, but this doesn't seem to be made available to userspace, so 
if you do your crypto in userspace (say, ssh), you're stuck using the CPU, 
which is much slower at this sort of thing.
<p>
I saw some patches a long time ago adding a BSD-style /dev/crypto, but 
then I lost them again...
      
          <div class="CommentReplyButton">
            <form action="/Articles/354715/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354717"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2009 22:35 UTC (Mon)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/354717/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ISTR the Geode's AES encryption acceleration is accessed with particular instructions. No special privilege required. But I may be wrong.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354717/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354758"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 9:20 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/354758/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh right. My ignorance is showing, so I'll go and correct that before saying anything else (and add a comment here once I know one way or the other).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354758/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor354720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2009 22:42 UTC (Mon)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/354720/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt;    SYSV IPC is best avoided. </font><br>
<p>
<font class="QuotedText">&gt;Not just in realtime situations, of course. </font><br>
<p>
Tell that to the PostgreSQL people.  They use SYSV shared memory and semaphores in the database.  It's quite efficient and works well. <br>
<p>
Of course, an RDBMS is not a realtime application, but you claimed that it should be avoided in other situations as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 9:21 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/354759/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes. I don't really know why databases use SysV SHM: the API for all the SysV stuff is so cracksmoking and unpleasant and non-Unixlike. I suppose POSIX shared memory functions didn't exist when PostgreSQL was young, and mmap() of /dev/null wasn't very portable at that point... so maybe it's just history.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354778"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 14:58 UTC (Tue)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/354778/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, the SysV stuff for a lot of things is unpleasant to work with.  Still, it does work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354778/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor354817"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">POSIX shmem in PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 19:50 UTC (Tue)
                               by <b>alvherre</b> (subscriber, #18730)
                              [<a href="/Articles/354817/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not just history.  In fact, a patch was posted to add support for POSIX shmem, but as it turns out, the POSIX API is not complete enough for PostgreSQL's purposes.  See here, for instance: <a href="http://archives.postgresql.org/pgsql-patches/2007-02/msg00527.php">http://archives.postgresql.org/pgsql-patches/2007-02/msg0...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354817/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354831"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">POSIX shmem in PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 22:47 UTC (Tue)
                               by <b>alvherre</b> (subscriber, #18730)
                              [<a href="/Articles/354831/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BTW, mmap does not work either.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354831/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor354875"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">POSIX shmem in PostgreSQL</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2009 15:14 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/354875/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, curses. We need a POSIX syscall that does what lsof/fuser do, really.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354875/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor354723"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2009 23:15 UTC (Mon)
                               by <b>niv</b> (guest, #8656)
                              [<a href="/Articles/354723/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Jon, thanks for the excellent write-up as usual.<br>
<p>
"Some hardware allows SMIs to be disabled, but it's never clear what the consequences of doing so might be; if the CPU melts into a puddle of silicon, the resulting latencies will be even worse than before".<br>
<p>
Just to elaborate on the above, and to clear up any doubt on the issue, as we (IBM) have actually done work to remediate SMIs - we are pretty confident that our CPUs will not melt into a puddle, and we officially  support on select platforms IBM premium real-time mode which allows us to do this safely (don't try this at home :)).<br>
<p>
In all seriousness, though, we have open-sourced the work that Keith  Mannthey has done (he talked about this at LPC this past week, and we'll have his slides up on the LPC website shortly) and I imagine it would be of interest to others. <br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354723/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354760"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 9:23 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/354760/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's a bit unfortunate that the ability to have the OS actually control the machine is relegated to a "premium real-time mode" on "select platforms". *Everything* should work like this.<br>
<p>
The only tolerable use for SMIs IMNSHO is emergency thermal control, i.e. keeping the hardware safe...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354760/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor355391"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2009 13:51 UTC (Sun)
                               by <b>dvhart</b> (guest, #19636)
                              [<a href="/Articles/355391/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are other less known uses for SMIs that are an unfortunately reality of our world.  Fixing hardware bugs is one. A buggy instruction for instance can get emulated under an SMI. It would be wonderful if those things never existed, but in practice, that just isn't the case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/355391/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor355513"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2009 19:10 UTC (Mon)
                               by <b>bdonlan</b> (guest, #51264)
                              [<a href="/Articles/355513/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Buggy instructions can also be fixed in the kernel, however, and at least then you know about them. While this may be a bit unfeasable for Windows, there should be some kind of switch Linux can use to disable the SMI handling, and just pass things to the normal #UD handler. If you then include hooks for any operations needing emulation at the same time as loading new microcode to disable the hardware support, no problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/355513/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor354734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 2:02 UTC (Tue)
                               by <b>mcgrof</b> (subscriber, #25917)
                              [<a href="/Articles/354734/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<p>
Does someone really have a patch which coverts all drivers to use thread IRSs? If so I'd like to see the wireless parts :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354735"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 3:15 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/354735/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, nobody has a patch which converts all ISRs individually to threaded interrupt handling.  Mainline allows selectively making individual interrupts threaded.  The -rt patchset allows making *all* interrupts automatically threaded, with no individual changes to each one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354735/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354740"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 5:26 UTC (Tue)
                               by <b>mcgrof</b> (subscriber, #25917)
                              [<a href="/Articles/354740/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah got it -- thanks. And what is the tree where I can pull all this from to test?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354740/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354741"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">-rt tree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 5:38 UTC (Tue)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/354741/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      See, for example, the <a rel="nofollow" href="http://lwn.net/Articles/353497/">2.6.31-rt11 announcement</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/354741/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">-rt tree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 7:15 UTC (Tue)
                               by <b>dvhart</b> (guest, #19636)
                              [<a href="/Articles/354743/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The rt wiki <a href="http://rt.wiki.kernel.org">http://rt.wiki.kernel.org</a> is a good source of information as well, including links to the download site.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor354746"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 8:28 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/354746/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is probably a very silly question, but priority inheritance seems to be such a messy thing to do right - wouldn't it be better to tell API users directly that it is not guaranteed and that they should either not wait for potentially low priority processes in critical paths, or make sure that the processes waited for already have the right priority?  I understand that it is preferable to solve things in a generic way where that is feasible, but one has to be careful that the solution doesn't end up being worse than the problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354746/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354763"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 10:59 UTC (Tue)
                               by <b>abacus</b> (guest, #49001)
                              [<a href="/Articles/354763/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      Priority inheritance is indeed messy. The following paper contains interesting background information: Victor Yodaiken, <a href="http://www.linuxfordevices.com/files/misc/yodaiken-july02.pdf"><em>Against Priority Inheritance</em></a>, July 2002.


      
          <div class="CommentReplyButton">
            <form action="/Articles/354763/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354807"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 18:14 UTC (Tue)
                               by <b>aleXXX</b> (subscriber, #2742)
                              [<a href="/Articles/354807/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, it's messy.<br>
<p>
Still it's a practical tool and works in general.<br>
Another problem is that most RTOSes don't have the full priority <br>
inheritance implemented, but a simplified version.<br>
E.g. eCos (and I think also vxworks) raise the priorities as expected, <br>
but lower them again when all mutexes in the system are released again. <br>
This can be very late.<br>
<p>
The poster before said:<br>
"that they should either not wait for potentially low priority processes <br>
in critical paths,"<br>
<p>
This is not easy.<br>
I mean, assume you have code like<br>
<p>
int get_foo(struct foo* f)<br>
{<br>
   lock_mutex(&amp;mutex);<br>
   memcpy(f, &amp;source, sizeof(struct foo));<br>
   unlock_mutex(&amp;mutex);<br>
}<br>
<p>
i.e. you just protect access to the variable "source". You may need this <br>
information in a low priority thread. The code looks innocent, there are <br>
no loops, nothing undeterministic, it will take at less than 10 <br>
microseconds.<br>
So why now wait use the same mutex in all other threads ?<br>
The issue is when a medium priority thread comes into play, suddenly the <br>
code above can block a higher priority thread for a time determined by <br>
the medium priority thread (which does not use that mutex at all).<br>
<p>
Also, "make sure that the processes waited for already have the right <br>
priority" is basically saying that all threads using the same mutex <br>
should have the same priority ?<br>
Doesn't work.<br>
<p>
So, this is a hard issue, and there's no easy solution. <br>
Maybe, try not to use too many shared variables, let your threads <br>
communicate via messages/tokens/etc.<br>
This helps, but everything gets asynchronous, which doesn't make things <br>
necessarily easier.<br>
<p>
Alex<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354807/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354823"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 20:09 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/354823/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I mean, assume you have code like</font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt; int get_foo(struct foo* f)</font><br>
<font class="QuotedText">&gt; {</font><br>
<font class="QuotedText">&gt; lock_mutex(&amp;mutex);</font><br>
<font class="QuotedText">&gt; memcpy(f, &amp;source, sizeof(struct foo));</font><br>
<font class="QuotedText">&gt; unlock_mutex(&amp;mutex);</font><br>
<font class="QuotedText">&gt; }</font><br>
That particular example could be solved by RCU, although I don't want to start a showdown here, as I'm sure you would win it :)  I was thinking more on the lines of avoiding contention in the critical path as much as possible though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354823/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor356475"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2009 16:02 UTC (Sun)
                               by <b>efexis</b> (guest, #26355)
                              [<a href="/Articles/356475/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Priority inheritance may often/usually not be the best way to do things by design (ie, try not to rely on it) sure, but is always better to have support for it to avoid inversion just-in-case, than not and have a Pathfinder style incident on your hands :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/356475/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor354773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2009 7:49 UTC (Wed)
                               by <b>simlo</b> (guest, #10866)
                              [<a href="/Articles/354773/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, as for being one of those who actually pushed and implemented a little bit of the priority inheritance in the beginning, I must say that he is just making excuses for not making it in RTLinux, because making it right _is_ indeed very hard. From experience I know it is done wrong even in VxWorks!<br>
<p>
But it can be done, and it is done in the current rtmutex in Linux. <br>
<p>
From the cases he is talking about, shows me that he has not understood how to use the system at all. He does the usual mistake of not distinguishing  between a mutex and a semaphore used as a condition (i.e. waiting for some external event to happen). <br>
<p>
Yes, making an RT application work with priority inheritance mutex requires some programming rules: You can't block on a semaphore, socket etc. while holding a lock. But, heck you should always try to avoid that in any multi-threaded program to avoid the whole program eventually locking up because some message didn't arrive over TCP as expected.<br>
<p>
In general locks should only be used "inside a module" to protect it's state. The user of the module should not be aware of it. The modules should be ordered such that low level module is not calling a highlevel module with an internal the lock taken - or you can create a deadlock. Or a even simpler rule: Newer make a call to another module with a lock held. In a RT environment with priority inheritance the module can use this to ensure the timing of all the calls to it because all the modules "lower" in the chain have a known timing and you therefore know the maximum time all the internal locks can be held by any thread.<br>
<p>
And yes, priority inheritance takes a lot of performance. But in general you should try to avoid congestion and make your program such that the locks are not contended. The locks should only be considered as "safeguards" against a contention, which should not happen very often.<br>
<p>
If you know how to use locks, and can avoid the pitfalls, priority inheritance will work for you - provided they are properly implemented by the OS. As is done in Linux.<br>
<p>
Wrt. rwlocks: If a high priority, realtime writer wants the lock, it doesn't make sense to boost the readers as you don't know how many there are. What you could do was to limit the number of readers to specific number. Or you could say that writers don't boost the readers but readers can boost the single writer. That way you can't use rwlocks in real time tasks and that would not be a problem in most cases. But the kernel would need a lot of review to be sure and therefore I fully understand the current solution in the preemt RT patche.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354848"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2009 8:05 UTC (Wed)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/354848/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Or you could say that writers don't boost the readers but readers can boost the single writer. That way you can't use rwlocks in real time tasks and that would not be a problem in most cases.</font><br>
So to return to my previous question, this would simply mean not trying to get it "right" for this API and clearly write that on the box.<br>
<p>
<font class="QuotedText">&gt; But the kernel would need a lot of review to be sure and therefore I fully understand the current solution in the preemt RT patche.</font><br>
Of course I was naively thinking that the API user would be aware of what locking they are using, but that won't hold if they are doing the locking implicitly through other APIs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354848/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor355392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2009 13:56 UTC (Sun)
                               by <b>dvhart</b> (guest, #19636)
                              [<a href="/Articles/355392/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
WRT rwlocks.  We actually cap reader count to 1 in PREEMPT_RT for that very reason. This is unfortunate, and one of the causes for performance degradation on -rt for certain workloads.  There was some discussion during the rt-summit in Dresden about making kernel rwlocks non-pi-aware for this reason. Some more investigation is needed before we make a decision there.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/355392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor355646"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2009 15:37 UTC (Tue)
                               by <b>simlo</b> (guest, #10866)
                              [<a href="/Articles/355646/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I said: You could leave half-PI-aware : Let readers boost the writer, but not the other way around. This will most likely work in many cases. It means a RT task can't write-lock a rwlock must defer the operation to another task. Config options are needed....<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/355646/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor354761"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About 2.6.29.5-rt22-tirqonly patch and the exact test scenario.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 9:28 UTC (Tue)
                               by <b>leemgs</b> (guest, #24528)
                              [<a href="/Articles/354761/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that this is good information for realtime developers. <br>
Can I get 2.6.29.5-rt22-tirqonly patch and the exact test scenario <br>
about this result among 2.6.29.5 and 2.6.29.5-rt22 and <br>
2.6.29.5-rt22-tirqonly by Darren Hart and and John Stultz? <br>
<p>
I can just find  test result at <br>
<a href="http://dvhart.com/darren/rtlws/elm3c160-dbench-vanilla-vs-rt-vs-tirq.png">http://dvhart.com/darren/rtlws/elm3c160-dbench-vanilla-vs...</a> file without test scenario <br>
using dbench(<a href="http://samba.org/ftp/tridge/dbench/">http://samba.org/ftp/tridge/dbench/</a>). <br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354761/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354833"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About 2.6.29.5-rt22-tirqonly patch and the exact test scenario.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 23:20 UTC (Tue)
                               by <b>jstultz</b> (subscriber, #212)
                              [<a href="/Articles/354833/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yea, sorry, the chart wasn't originally intended to be distributed as far as it has, so I wasn't as rigorous with the data as I should have been.<br>
<p>
2.6.29.5-rt22-tirqonly is the same as 2.6.29.5-rt22 with CONFIG_PREEMPT_RT disabled (CONFIG_PREEMPT is used instead).<br>
<p>
I booted with maxcpus=$NP for each cpu point, and with dbench-3.04, ran:<br>
./dbench $NP -t 7000 -D . -c client.txt<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354833/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor355393"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">About 2.6.29.5-rt22-tirqonly patch and the exact test scenario.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2009 13:59 UTC (Sun)
                               by <b>dvhart</b> (guest, #19636)
                              [<a href="/Articles/355393/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That isn't a patch, it's just a .config setting.  Grab the 2.6.29-rt22 patches (see Download on rt.wiki.kernel.org) and set CONFIG_PREEMPT (not CONFIG_PREEMPT_RT) and enable hard and soft threaded irq's to yes. As for the exact test scenario, I don't have the details, but running dbench is fairly straightforward and will easily reproduce these results.  Ingo did so with a simple 10 second run during discussions at the rt-summit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/355393/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor354776"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lock naming</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 14:44 UTC (Tue)
                               by <b>nettings</b> (subscriber, #429)
                              [<a href="/Articles/354776/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There was some talk of the best names for "atomic spinlocks"; they could be "core locks," "little kernel locks," or "dread locks." </font><br>
<p>
Well, some locks are to heavy, some are too lightweight. Since these are Just Right, they are obviously goldilocks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354776/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lock naming</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 20:42 UTC (Tue)
                               by <b>niv</b> (guest, #8656)
                              [<a href="/Articles/354825/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Well, some locks are to heavy, some are too lightweight. Since these are Just Right, they are obviously goldilocks."<br>
<p>
Just have to applaud :).<br>
<p>
Humor aside, we really do have to get the naming right - there's enough confusion as it is, as Jon points out. Lock names really need to be self-explanatory, or at very least, imply behavior that's somewhat in the ballpark of actual behavior. Spinlocks that can sleep should have big, flashing red neon warning signs or some equivalent thereof in their name, ideally.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lock naming</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 21:08 UTC (Tue)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/354828/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Call them sleepy locks then. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lock naming</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2009 12:03 UTC (Wed)
                               by <b>nevets</b> (subscriber, #11875)
                              [<a href="/Articles/354864/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
goldielocks was indeed mentioned. But the sleepy locks were not. I'll have to have Jon add that one to the list of possibilities. :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor356478"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lock naming</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2009 16:34 UTC (Sun)
                               by <b>efexis</b> (guest, #26355)
                              [<a href="/Articles/356478/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sleepy sounds like they might run a bit slow and probably need to sleep... if the locks may end up sleeping due to external conditions then it should be a narcolocksy :-)<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/356478/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor354896"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lock naming</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2009 17:32 UTC (Wed)
                               by <b>doogie</b> (guest, #2445)
                              [<a href="/Articles/354896/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You mean baby bear.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354896/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor354810"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What do they mean by &quot;Realtime&quot;?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 18:20 UTC (Tue)
                               by <b>clameter</b> (subscriber, #17005)
                              [<a href="/Articles/354810/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems that the realtime folks are fuzzy on what they are trying to accomplish. I thought realtime was ensuring that the kernel always responds in a mininum time interval to an event but I dont see any discussion of what the minimum time interval is. <br>
<p>
From the article it seems that there are numerous features in the kernel that are currently not "Realtime". That probably means that the potential latencies are beyond any assumable time interval. This includes such basic things as locking.<br>
<p>
What is meant by "Realtime" then? What set of functionality of the kernel can be used so that a response is guaranteed within the time interval?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354810/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor354816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What do they mean by &quot;Realtime&quot;?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 18:56 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/354816/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
by realtime they don't mean responding in the minimum time<br>
<p>
they are looking for a response in a _predictable_max_ time<br>
<p>
how short that predictable time is determines how suitable it is for a particular application, but the key thing is to make it predictable.<br>
<p>
right now linux is not predictable, that is what they are working on fixing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor354818"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What do they mean by &quot;Realtime&quot;?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2009 20:15 UTC (Tue)
                               by <b>niv</b> (guest, #8656)
                              [<a href="/Articles/354818/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Determinism is what's really important to real-time. <br>
<p>
It's often confused with low latency, but the two are separate criteria and often conflicting goals requiring a trade-off, made complicated by the fact that most applications typically want BOTH - determinism AND low latency. <br>
<p>
Determinism is easier understood as the ability to say "this task will take AT MOST n ms". That is, bounded maximum latency. <br>
<p>
In the strictest case, this would mean the following:<br>
<p>
   it is preferable for all 5000 iterations of a task execution <br>
   to take 49us (less than 50us) than it is for 4950 to take <br>
   35us and 50 iterations to take 69us, when your application <br>
   requires a maximum latency of 50us.<br>
<p>
For most enterprise applications, the max latency is not a MUST_FINISH_BY with severe consequences for failure, but a REALLY_GOOD_TO_FINISH_WITHIN, with the average low latency being also important. Some applications can tolerate some outliers (maximum latency bound exceeded) as they usually need average low latency as well.<br>
<p>
Most OSs are optimized for throughput-driven applications (where average latency is minimized). <br>
<p>
Real-time Linux is optimized to offer greater determinism than the stock kernel. Hence the need for greater preemption, including the ability to preempt critical kernel tasks should a higher priority application become runnable. <br>
<p>
And remember, you can only guarantee/meet real-time requirements for as many threads as you can run concurrently on your system - on an N-core system, you can at most guarantee that  N SCHED_FIFO tasks at the same highest priority P will meet their real time guarantees (depending on a lot of things, handwave, handwave, but you get the general idea). So a lot depends on what the system is running, the overall application solution and top-down configuration of the entire system.<br>
 <br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354818/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor354915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2009 19:20 UTC (Wed)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/354915/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds like you guys had fun :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor354965"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Typical geek party</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2009 6:31 UTC (Thu)
                               by <b>nevets</b> (subscriber, #11875)
                              [<a href="/Articles/354965/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you look closely at the picture of everyone. You will notice that they are (mostly) all concentrating on their laptops. This probably shows that the room was silent most of the time, and everyone was communicating over IRC!<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/354965/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor355394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Typical geek party</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2009 14:03 UTC (Sun)
                               by <b>dvhart</b> (guest, #19636)
                              [<a href="/Articles/355394/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That or when the camera came out we all tried to find something else to focus on. ;-)  Actually, there was discussion 100% of the time.  Most of time, about 1/3 of the room was participating while the others focused on something else.  I think that's probably typical (or even pretty good) given the diversity of topics and expertise in the room.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/355394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor356464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption mini-summit</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2009 9:53 UTC (Sun)
                               by <b>jnareb</b> (subscriber, #46500)
                              [<a href="/Articles/356464/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So the realtime tests might remain on their own, but it would be nice, at least, to standardize test options and output formats to help with the automation of testing. XML output from test programs is favored by some, but it is fair to say that XML is not universally loved in this crowd.</font><br>
<p>
Why not use Test Anything Protocol (TAP), originally developed for unit testing of the Perl interpreter?  See <a rel="nofollow" href="http://www.testanything.org">http://www.testanything.org</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/356464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
