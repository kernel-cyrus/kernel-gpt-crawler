        <!DOCTYPE html>
        <html lang="en">
        <head><title>TCP Fast Open: expediting web services [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/508865/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/508218/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/508865/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>TCP Fast Open: expediting web services</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Michael Kerrisk</b><br>August 1, 2012</br>
           </div>
<p> Much of today's Internet traffic takes the form of short TCP data flows
that consist of just a few round trips exchanging data segments before the
connection is terminated. The prototypical example of this kind of short
TCP conversation is the transfer of web pages over the Hypertext Transfer
Protocol (HTTP).

<p> The speed of TCP data flows is dependent on two factors: transmission
delay (the width of the data pipe) and propagation delay (the time that the
data takes to travel from one end of the pipe to the other). Transmission
delay is dependent on network bandwidth, which has increased steadily and
substantially over the life of the Internet. On the other hand, propagation
delay is a function of router latencies, which have not improved to the
same extent as network bandwidth, and the speed of light, which has
remained stubbornly <a
href="http://en.wikipedia.org/wiki/Speed_of_light">constant</a>. (At
intercontinental distances, this physical limitation means
that&mdash;leaving aside router latencies&mdash;transmission through the
medium alone requires several milliseconds.) The relative change in the
weighting of these two factors means that over time the propagation delay
has become a steadily larger component in the overall latency of web
services.  (This is especially so for many web pages, where a browser often
opens several connections to fetch multiple small objects that compose the
page.)

<p> Reducing the number of round trips required in a TCP conversation has
thus become a subject of keen interest for companies that provide web
services. It is therefore unsurprising that Google should be the originator
of a series of patches to the Linux networking stack to implement the TCP
Fast Open (TFO) feature, which allows the elimination of one round time
trip (RTT) from certain kinds of TCP conversations. According to the
implementers (in <a
href="http://conferences.sigcomm.org/co-next/2011/papers/1569470463.pdf">"TCP
Fast Open", <i>CoNEXT 2011</i> [PDF]</a>), TFO could result in speed
improvements of between 4% and 41% in the page load times on popular web
sites.

<p> <a href="/Articles/458610/#tfo">We first wrote</a> about TFO back in
September 2011, when the idea was still in the development stage. Now that
the TFO implementation is <a
href="http://thread.gmane.org/gmane.linux.network/237733">starting</a> to
make its way into the kernel, it's time to visit it in more detail.

<h4>The TCP three-way handshake</h4>

<p> To understand the optimization performed by TFO, we first need to note
that each TCP conversation begins with a round trip in the form of the
so-called three-way handshake. The three-way
handshake is initiated when a client makes a connection request
to a server. At the application level, this corresponds to a
client performing a <tt>connect()</tt> system call to establish a
connection with a server that has previously bound a socket to a well-known
address and then called <tt>accept()</tt> to receive incoming connections.
Figure&nbsp;1 shows the details of the three-way handshake in diagrammatic form.

<p>
<blockquote>
<img src="https://static.lwn.net/images/2012/tfo/3whs.png" alt="[TCP Three-Way Handshake]">
</blockquote>
<i>Figure 1: TCP three-way handshake between a client and a server</i>

<p> During the three-way handshake, the two TCP end-points exchange <tt>SYN</tt>
(synchronize) segments containing <a
href="http://www.iana.org/assignments/tcp-parameters/tcp-parameters.txt">options</a>
that govern the subsequent TCP conversation&mdash;for example, the <a
href="http://en.wikipedia.org/wiki/Maximum_segment_size">maximum segment
size (MSS)</a>, which specifies the maximum number of data bytes that a TCP
end-point can receive in a TCP segment.  The SYN segments also contain the
initial sequence numbers (ISNs) that each end-point selects for the
conversation (labeled <i>M</i> and <i>N</i> in Figure&nbsp;1).

<!--
These sequence numbers (which are independent for each
end-point) are incremented as bytes of information are exchanged in each
direction on the TCP connection and allow each of the TCP end-points to
acknowledge receipt of segments from its peer.  (ISNs do not start from
zero. Instead, they are chosen in such a way as to minimize the chance that
delayed segments from a previous incarnation of a connection between these
two end-points could be misinterpreted as being data belonging to this
connection. The ISNs are also chosen in such a way that they are difficult
to guess, so as to prevent a malicious user spoofing segments belonging to
the connection. The 32-bit sequence numbers wrap around to zero when the
maximum value is reached.)
-->

<p> The three-way handshake serves another purpose with respect to connection
establishment: in the (unlikely) event that the initial <tt>SYN</tt> is
duplicated (this may occur, for example, because underlying network
protocols duplicate network packets), then the three-way handshake allows the duplication to
be detected, so that only a single connection is created. If a connection
was established before completion of the three-way handshake, then a duplicate <tt>SYN</tt>
could cause a second connection to be created.

<p> The problem with current TCP implementations is that data can only be
exchanged on the connection after the initiator of the connection has
received an <tt>ACK</tt> (acknowledge) segment from the peer TCP. In other
words, data can be sent from the client to the server only in the third
step of the three-way handshake (the ACK segment sent by the initiator). Thus, one full
round trip time is lost before data is even exchanged between the
peers. This lost RTT is a significant component of the latency of short
web conversations.

<p> Applications such as web browsers try to mitigate this problem using <a
href="http://en.wikipedia.org/wiki/HTTP_persistent_connections">HTTP
persistent connections</a>, whereby the browser holds a connection open to
the web server and reuses that connection for later HTTP requests. However,
the effectiveness of this technique is decreased because idle connections
may be closed before they are reused. For example, in order to limit
resource usage, busy web servers often aggressively close idle HTTP
connections. The result is that a high proportion of HTTP requests are
<i>cold</i>, requiring a new TCP connection to be established
to the web server.

<h4>Eliminating a round trip</h4>

<p> Theoretically, the initial <tt>SYN</tt> segment <i>could</i> contain
data sent by the initiator of the connection: <a
href="http://www.ietf.org/rfc/rfc793.txt">RFC 793</a>, the specification
for TCP, <i>does</i> permit data to be included in a <tt>SYN</tt> segment.
However, TCP is prohibited from delivering that data to the application
until the three-way handshake completes. This is a necessary security measure to prevent
various kinds of malicious attacks. For example, if a malicious client sent
a <tt>SYN</tt> segment containing data and a spoofed source address, and
the server TCP passed that segment to the server application before
completion of the three-way handshake, then the segment would both cause resources to be
consumed on the server and cause (possibly multiple) responses to be sent
to the victim host whose address was spoofed.

<p> The aim of TFO is to eliminate one round trip time from a TCP
conversation by allowing data to be included as part of the <tt>SYN</tt>
segment that initiates the connection. TFO is designed to do this in such a
way that the security concerns described above are addressed.  (<a
href="http://tools.ietf.org/html/rfc1644">T/TCP</a>, a mechanism designed
in the early 1990s, also tried to provide a way of short circuiting the
three-way handshake, but fundamental <a
href="http://www.phrack.org/issues.html?issue=53&id=6#article">security
flaws</a> in its design meant that it never gained wide use.)

<p> On the other hand, the TFO mechanism does <i>not</i> detect duplicate
<tt>SYN</tt> segments. (This was a deliberate choice made to
simplify design of the protocol.) Consequently, servers employing TFO must
be <a
href="http://en.wikipedia.org/wiki/Idempotent">idempotent</a>&mdash;they
must tolerate the possibility of receiving duplicate initial <tt>SYN</tt>
segments containing the same data and produce the same result regardless of
whether one or multiple such <tt>SYN</tt> segments arrive. Many web
services are idempotent, for example, web servers that serve static web
pages in response to URL requests from browsers, or web services that
manipulate internal state but have internal application logic to detect
(and ignore) duplicate requests from the same client.

<p> In order to prevent the aforementioned malicious attacks, TFO employs
security cookies (TFO cookies). The TFO cookie is generated once by the
server TCP and returned to the client TCP for later reuse.  The cookie is
constructed by encrypting the client IP address in a fashion that is
reproducible (by the server TCP) but is difficult for an attacker to guess.
Request, generation, and exchange of the TFO cookie happens entirely
transparently to the application layer.

<p> At the protocol layer, the client requests a TFO cookie by sending a
<tt>SYN</tt> segment to the server that includes a special TCP option
asking for a TFO cookie. The <tt>SYN</tt> segment is otherwise "normal";
that is, there is no data in the segment and establishment of the
connection still requires the normal three-way handshake.  In response, the
server generates a TFO cookie that is returned in the <tt>SYN-ACK</tt>
segment that the server sends to the client.  The client caches the TFO
cookie for later use. The steps in the generation and caching of the TFO
cookie are shown in Figure&nbsp;2.

<p>
<blockquote>
<img src="https://static.lwn.net/images/2012/tfo/foc_creation.png" alt="[Generating the TFO cookie]">
</blockquote>
<i>Figure 2: Generating the TFO cookie</i>

<p> At this point, the client TCP now has a token that it can use to prove
to the server TCP that an earlier three-way handshake to the client's IP address completed
successfully. 

<p>
For subsequent conversations with the server, the client can
short circuit the three-way handshake as shown in Figure&nbsp;3.

<p>
<blockquote>
<img src="https://static.lwn.net/images/2012/tfo/foc_use.png" alt="[Employing the TFO cookie]">
</blockquote>
<i>Figure 3: Employing the TFO cookie</i>



<p>
The steps shown in Figure 3 are as follows:

<ol>

<p> <li> The client TCP sends a <tt>SYN</tt> that contains both the TFO
cookie (specified as a TCP option) <i>and</i> data from the client
application.

<p> <li> The server TCP validates the TFO cookie by duplicating the
encryption process based on the source IP address of the <i>new</i>
<tt>SYN</tt>. If the cookie proves to be valid, then the server TCP can be
confident that this <tt>SYN</tt> comes from the address it claims to come
from. This means that the server TCP can immediately pass the application
data to the server application.

<p> <li> From here on, the TCP conversation proceeds as normal: the server
TCP sends a <tt>SYN-ACK</tt> segment to the client, which the client TCP
then acknowledges, thus completing the three-way handshake. The server TCP
can also send response data segments to the client TCP <i>before</i> it
receives the client's <tt>ACK</tt>.

</ol>

<p> In the above steps, if the TFO cookie proves not to be valid, then the
server TCP discards the data and sends a segment to the client TCP that
acknowledges just the <tt>SYN</tt>. At this point, the
TCP conversation falls back to the normal three-way handshake. If the
client TCP is authentic (not malicious), then it will (transparently to the
application) retransmit the data that it sent in the <tt>SYN</tt> segment.

<p> Comparing Figure 1 and Figure 3, we can see that a complete RTT has
been saved in the conversation between the client and server. (This assumes
that the client's initial request is small enough to fit inside a single
TCP segment. This is true for most requests, but not all. Whether it might
be technically possible to handle larger requests&mdash;for example, by
transmitting multiple segments from the client before receiving the
server's <tt>ACK</tt>&mdash;remains an open question.)

<p> There are various details of TFO cookie generation that we don't cover
here. For example, the algorithm for generating a suitably secure TFO
cookie is implementation-dependent, and should (and can) be designed to be
computable with low processor effort, so as not to slow the processing of
connection requests. Furthermore, the server should periodically change the
encryption key used to generate the TFO cookies, so as to prevent attackers
harvesting many cookies over time to use in a coordinated attack against
the server.

<p> There is one detail of the use of TFO cookies that we will revisit
below. Because the TFO mechanism allows a client that submits a valid TFO
cookie to trigger resource usage on the server before completion of the
three-way handshake, the server can be the target of resource-exhaustion
attacks. To prevent this possibility, the server imposes a limit on the
number of pending TFO connections that have not yet completed the three-way
handshake. When this limit is exceeded, the server ignores TFO cookies and
falls back to the normal three-way handshake for subsequent client requests
until the number of pending TFO connections falls below the limit; this
allows the server to employ <a
href="http://tools.ietf.org/html/rfc4987">traditional measures against
SYN-flood attacks</a>.

<h4>The user-space API</h4>

<p> As noted above, the generation and use of TFO cookies is transparent to
the application level: the TFO cookie is automatically generated during the
first TCP conversation between the client and server, and then automatically
reused in subsequent conversations. Nevertheless, applications that wish to
use TFO must notify the system using suitable API
calls. Furthermore, certain system configuration knobs need to be turned in
order to enable TFO.

<p> The changes required to a server in order to support TFO are minimal, and
are highlighted in the code template below.

<pre>
    sfd = socket(AF_INET, SOCK_STREAM, 0);   // Create socket

    bind(sfd, ...);                          // Bind to well known address
    <b>
    int qlen = 5;                            // Value to be chosen by application
    setsockopt(sfd, SOL_TCP, TCP_FASTOPEN, &amp;qlen, sizeof(qlen));
    </b>
    listen(sfd, ...);                        // Mark socket to receive connections

    cfd = accept(sfd, NULL, 0);              // Accept connection on new socket

    // read and write data on connected socket cfd

    close(cfd);
</pre>

<p> Setting the <tt>TCP_FASTOPEN</tt> socket option requests the kernel to
use TFO for the server's socket. By implication, this is also a statement
that the server can handle duplicated <tt>SYN</tt> segments in an
idempotent fashion. The option value, <tt>qlen</tt>, specifies this
server's limit on the size of the queue of TFO requests that have not yet
completed the three-way handshake (see the remarks on prevention of
resource-exhaustion attacks above).

<p> The changes required to a client in order to support TFO are also
minor, but a little more substantial than for a TFO server. A normal TCP
client uses separate system calls to initiate a connection and transmit
data: <tt>connect()</tt> to initiate the connection to a specified server
address and (typically) <tt>write()</tt> or <tt>send()</tt> to transmit
data. Since a TFO client combines connection initiation and data
transmission in a single step, it needs to employ an API that allows both
the server address and the data to be specified in a single operation. For
this purpose, the client can use either of two repurposed system calls:
<tt>sendto()</tt> and <tt>sendmsg()</tt>.

<p> The <tt>sendto()</tt> and <tt>sendmsg()</tt> system calls are normally
used with datagram (e.g., UDP) sockets: since datagram sockets are
connectionless, each outgoing datagram must include both the transmitted
data and the destination address. Since this is the same information that
is required to initiate a TFO connection, these system calls are recycled
for the purpose, with the requirement that the new <tt>MSG_FASTOPEN</tt>
flag must be specified in the <tt>flags</tt> argument of the system call. A
TFO client thus has the following general form:

<pre>
    sfd = socket(AF_INET, SOCK_STREAM, 0);
    <b>
    sendto(sfd, data, data_len, MSG_FASTOPEN, 
                (struct sockaddr *) &amp;server_addr, addr_len);
        // Replaces connect() + send()/write()
    </b>
    // read and write further data on connected socket sfd

    close(sfd);
</pre>

<p>
If this is the first TCP conversation between the client and server, then the
above code will result in the scenario shown in Figure&nbsp;2, with the result
that a TFO cookie is returned to the client TCP, which then caches the
cookie. If the client TCP has already obtained a TFO cookie from a previous
TCP conversation, then the scenario is as shown in Figure&nbsp;3, with
client data being passed in the initial <tt>SYN</tt> segment and a round
trip being saved.

<p>
In addition to the above APIs, there are various knobs&mdash;in the form of
files in the <tt>/proc/sys/net/ipv4</tt> directory&mdash;that control TFO
on a system-wide basis:

<ul>

<p> <li> The <tt>tcp_fastopen</tt> file can be used to view or set a value
that enables the operation of different parts of the TFO
functionality. Setting bit 0 (i.e., the value 1) in this value enables
client TFO functionality, so that applications can request TFO
cookies. Setting bit 1 (i.e., the value 2) enables server TFO
functionality, so that server TCPs can generate TFO cookies in response to
requests from clients. (Thus, the value 3 would enable both client and
server TFO functionality on the host.)

<p> <li> The <tt>tcp_fastopen_cookies</tt> file can be used to view or set
a system-wide limit on the number of pending TFO connections that have not
yet completed the three-way handshake. While this limit is exceeded, all
incoming TFO connection attempts fall back to the normal three-way
handshake.

</ul>

<h4>Current state of TCP fast open</h4>

<p> Currently, <a
href="http://tools.ietf.org/html/draft-ietf-tcpm-fastopen-01">TFO is
an Internet Draft</a> with the IETF.  Linux is the first operating system
that is adding support for TFO.  However, as yet that support remains
incomplete in the mainline kernel. The client-side support has been merged
for Linux 3.6. However, the
server-side TFO support has not so far been merged, and from conversations
with the developers it appears that this support won't be added in the current
merge window. Thus, an operational TFO implementation is likely to become
available only in Linux 3.7.

<p> Once operating system support is fully available, a few further steps
need to be completed to achieve wider deployment of TFO on the
Internet. Among these is assignment by <a href="http://www.iana.org/">IANA</a> of
a dedicated TCP Option Number for TFO. (The current implementation employs
the <a
href="http://www.iana.org/assignments/tcp-parameters/tcp-parameters.txt">TCP
Experimental Option Number</a> facility as a placeholder for a real TCP
Option Number.)

<p>
Then, of course, suitable changes must be made to both
clients and servers along the lines described above. Although each
client-server pair requires modification to employ TFO, it's worth noting
that changes to just a small subset of applications&mdash;most notably, web
servers and browsers&mdash;will likely yield most of the benefit visible to
end users.
During the deployment process, TFO-enabled clients may attempt connections
with servers that don't understand TFO. This case is handled gracefully by
the protocol: transparently to the application, the client and server will
fall back to a normal three-way handshake.

<p> There are other deployment hurdles that may be encountered.  In their
<i>CoNEXT 2011</i> paper, the TFO developers note that a minority of
middle-boxes and hosts drop TCP <tt>SYN</tt> segments containing unknown
(i.e., new) TCP options or data. Such problems are likely to diminish as
TFO is more widely deployed, but in the meantime a client TCP can
(transparently) handle such problems by falling back to the normal
three-way handshake on individual connections, or generally falling back
for all connections to specific server IP addresses that show repeated
failures for TFO.

<h4>Conclusion</h4>

<p> TFO is promising technology that has the potential to make significant
reductions in the latency of billions of web service transactions that take
place each day. Barring any unforeseen security flaws (and the developers
seem to have considered the matter quite carefully), TFO is likely to see
rapid deployment in web browsers and servers, as well as in a number of other
commonly used web applications.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking">Networking</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#TCP">TCP</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/508865/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor509259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2012 21:57 UTC (Wed)
                               by <b>pj</b> (subscriber, #4506)
                              [<a href="/Articles/509259/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why do clients have to change to using sendto() or sendmsg() ? Couldn't the charter of connect() be changed a little iff TCP_FASTOPEN is set to make it be a bit more 'lazy' so it doesn't actually attempt a connection until something is written to it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509270"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2012 22:21 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/509270/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can't see a sensible way for connect(2) to determine if it should return ECONNREFUSED without that first SYN/ACK roundtrip. :)<br>
<p>
(You'll note that sendmsg(), being intended for connectionless protocols, isn't documented as being able to return ECONNREFUSED either. I suspect this oversight will be rectified in due course.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509270/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2012 23:00 UTC (Wed)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/509277/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just document that if you connect with the TCP_FASTOPEN flag you can potentially get ECONNREFUSED from whatever later call you use to write data to the socket.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509451"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 22:56 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/509451/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite. The set of errors in the manpages (and, indeed, in POSIX) is not a total set -- the kernel is allowed to return other errors, though it is perhaps unwise to expect callers to expect those errors.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509451/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor509280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2012 23:11 UTC (Wed)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/509280/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Well, <tt>connect</tt> could return <tt>EINPROGRESS</tt> if the option is used as it does for a non-blocking socket.  That's a bit of a lie, though. :)

      
          <div class="CommentReplyButton">
            <form action="/Articles/509280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor510199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2012 14:45 UTC (Wed)
                               by <b>kevinm</b> (guest, #69913)
                              [<a href="/Articles/510199/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
...and you could request fastopen by setting TCP_CORK before connect(); write(); then uncorking.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor509271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 1, 2012 22:34 UTC (Wed)
                               by <b>bojan</b> (subscriber, #14302)
                              [<a href="/Articles/509271/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; and the speed of light, which has remained stubbornly constant.</font><br>
<p>
Anyone has a patch for this? ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 0:39 UTC (Thu)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/509285/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Numerous more-pessimal patches exist in the literature; some assembly may be required.  More-optimal is TBD for the time being and left as an exercise for the student.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor509456"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 23:28 UTC (Thu)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/509456/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For HTTP the patch is a SPDY-/HTTP/2-like protocol, the performance of HTTP is currently limited because it does not do multiplexing.<br>
<p>
SPDY/2 is currently supported by Firefox, Chrome. An Apache module from Google, there is a beta patch from the nginx developers, node.js module, a Java server implementation and some beta C-client- and server-libraries and implementations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509456/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor510347"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2012 6:11 UTC (Thu)
                               by <b>cvrebert</b> (guest, #86030)
                              [<a href="/Articles/510347/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <a href="http://www.imdb.com/title/tt0584424/quotes">You're gonna have to wait until 2208 for that.</a>
      
          <div class="CommentReplyButton">
            <form action="/Articles/510347/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor509310"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 7:45 UTC (Thu)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/509310/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This probably will have an uphill battle being really accepted, since the client has to be sure that the request is idempotent on the server when connecting. That's effectively impossible without explicit annotations (at least for http, other protocols might not have that problem) :-/<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509310/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 9:44 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/509318/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The article makes it sound like the server's responsibility to make sure its behaviour is idempotent before enabling TFO.  For http in particular, a GET request is defined to be idempotent while POST is not, and the client knows which it is sending.  So it makes more sense for web servers to always allow TFO, but clients refrain from using it for POST or PUT requests.  The web server could add a sanity check, once it receives the data and starts processing the request, that TFO was not used for these request types.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 12:16 UTC (Thu)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/509331/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many 'GET' operations are not necessarily idempotent. The RFC's language is 'SHOULD NOT', which is about the mildest way requirements are described.<br>
<p>
The problem is that often different applications run in a big webserver (especially true for massive virtual hosting setups) and that "partially enabling TFO" is not really an option.<br>
<p>
The other way round would be for the application to signal that the request is not allowed using TFO, but that would require a retry using non-TFO which is not specced and introduces more latency than is gained using TFO.<br>
<p>
The only real solution that is safe would be to invent (yet another) HTTP header that signifies which methods for which paths under the current vhost may be done using TFO initialized connections.<br>
For systems that support TFO for all requests (because they have higher-level guards against duplicate requests) one could simply hint '* /' or something. Only the first connection to such a site must in that case always be made using non-TFO requests.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 9, 2012 13:48 UTC (Thu)
                               by <b>jthill</b> (subscriber, #56558)
                              [<a href="/Articles/510397/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I think just allowing a server to detect whether the connection is still in fast-open state should be enough.  If the server sees a non-idempotent request it can make sure the initial <tt>ACK</tt> has arrived before proceeding.  Make it detectable by say making <tt>{aio_,}fsync</tt> not complete until it's arrived, or fabricating a redundant <tt>EPOLLOUT</tt> edge.
      
          <div class="CommentReplyButton">
            <form action="/Articles/510397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor509333"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 12:21 UTC (Thu)
                               by <b>colo</b> (guest, #45564)
                              [<a href="/Articles/509333/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, well yes, in an ideal world... :)<br>
<p>
I've seen enough GET-requests with at times far-reaching side effects in the wild that I'm not convinced this will (or should) see widespread adoption, at least not for "ordinary" HTTP servers that aren't serving up static content only or something like that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509333/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 13:16 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/509344/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Long ago I worked at ArsDigita where the rule was to avoid form submit buttons as much as possible.  So the user management page on a site would have 'delete user' not as a POST form submission, but simply a hyperlink.  This was held to make the website look cleaner and feel faster.  Then a customer using a 'web accelerator' which eagerly follows links ended up trashing their whole site.  The programmer's fault, of course - GET requests should never be used for strongly state-changing operations like deleting data.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509354"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 14:04 UTC (Thu)
                               by <b>alankila</b> (guest, #47141)
                              [<a href="/Articles/509354/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Although to be fair, multiple GETs that all attempt to delete the same user aren't a problem here. So maybe the latter request crashes if website developer wasn't careful enough, but the delete itself was idempotent.<br>
<p>
I guess cautious people can't turn TFO on unless they validate the software they runs, but now there is going to be a good reason why you want to ensure that software is idempotent-GET safe. I imagine that the vast majority of software is, actually.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509354/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 15:19 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/509360/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, I was confusing idempotent (makes no difference whether requested once, or many times) with stateless (makes no difference whether requested zero, one, or many times).  Ideally GET requests would be not merely idempotent but stateless, which is a stronger property.  But that is not needed for TFO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509366"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 16:11 UTC (Thu)
                               by <b>man_ls</b> (guest, #15091)
                              [<a href="/Articles/509366/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      That is not required in the RFC, and I am not sure that restful, stateless web services would be even possible. After all, web services are supposed to change state in the server; otherwise what is the point?
      
          <div class="CommentReplyButton">
            <form action="/Articles/509366/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 16:32 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/509367/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe I don't understand. Internally we have a great many RESTful web services which all work roughly like this:<br>
<p>
The client asks if this particular combination of data (provided as GET query parameters) is found in the database overseen by that web service. The server looks in its database (e.g. maybe it's the collection of all voter registration records for a particular country) and if there is a matching record it replies saying what was found and where.<br>
<p>
You can run that same request again and get the same exact answer and running it many times or not at all changes nothing‡ so that seems to meet your requirement entirely.<br>
<p>
‡ In practice some of the services do accounting, they are incrementing a counter somewhere for every query run and then we use that counter to determine the payment to a third party for the use of their data. But this is no greater deviation from the concept than the usual practice of logging GET requests and anyway most of the services don't do that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 20:42 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/509421/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
you are making the assumption that the RESTful web service is read-only.<br>
<p>
How can you do a RESTful web service where the client is sending information to the server without causing these sorts of problems?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509472"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 2:02 UTC (Fri)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/509472/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The normal technique is to mark all non-idempotent requests with a unique id, and keep track of which ones have already been processed.  That is practically the only way to get once-only execution semantics.<br>
<p>
This could presumably be done (up to a point) at the transport layer with TCP Fast Open by having the initiating endpoint assign a unique identifier to a given user space connection request, attaching the identifier as a TCP option, caching the identifier for some reasonable period on the target endpoint, and throwing away SYN packets with connection identifiers that have already been satisfied.  The more general way to do that of course is to do it at the application layer, in addition to anything the transport layer may or may not do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509472/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor509578"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 15:35 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/509578/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought that part of making a RESTful web service was deciding which operations are read-only and which affect the state; and splitting them into GET and POST requests accordingly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509578/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509656"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 21:16 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/509656/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That depends on how you define REST<br>
<p>
many groups make everything a GET request, especially for APIs that are not expected to be used from browsers, but rather called from other applications, especially in B2B type situations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509656/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor509376"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 17:33 UTC (Thu)
                               by <b>ycheng-lwn</b> (guest, #86073)
                              [<a href="/Articles/509376/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Our draft creates this confusion that HTTP on TFO will break if the request is not idempotent because we use the word "idempotent transactions". But today the client may send a non-idempotent request twice already with standard TCP. For example, the link may fail after the server receive a non-idempotent request. the client will retry the request on another connection later since the original is not acknowledged.<br>
<p>
TFO makes such a case possible in the SYN stage: the server reboots between when it receives request in SYN-data and when it sends the SYN-ACK. Being unaware of the reboot, the client will timeout and retransmit SYNs. If the server comes back and accepts the SYN, the client will repeat the request. But IMO the risk is minimal especially if the server defers enabling TFO until a reasonable connection  timeout after reboot, e.g., 5 min.<br>
<p>
Cheers,<br>
<p>
-yuchung (tfo developer)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509376/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509499"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 4:36 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/509499/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Being unaware of the reboot, the client will timeout and retransmit SYNs. </font><br>
<p>
For that to happen the server must accept the cookie.  Surely you could get around that by including the servers boot time in the MAC key used to generate the cookie?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509499/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 14:04 UTC (Fri)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/509569/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Surely you could get around that by including the servers boot time in the MAC key used to generate the cookie?</font><br>
<p>
A better option would be /proc/sys/kernel/random/boot_id (see <a href="http://0pointer.de/blog/projects/ids.html">http://0pointer.de/blog/projects/ids.html</a>).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor509772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2012 23:16 UTC (Sat)
                               by <b>drdabbles</b> (guest, #48755)
                              [<a href="/Articles/509772/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How do you perceive this working with load balancing hardware in the future? Vendors will have to get behind TFO and patch firmwares, but hardware behind the LBs will also need to be patched. Do you expect a chicken-and-the-egg situation here, or do you know something that perhaps you aren't or can't share with us?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510076"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2012 0:05 UTC (Wed)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/510076/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That depends on the design of the load balancer.  A well designed one should have no problem converting a TCP Fast Open connection between the client and the LB and a standard connection between the LB and the servers behind it. Assuming the servers and the load balancer(s) are colocated, there should be very little penalty for doing so. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510076/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2012 3:41 UTC (Wed)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/510098/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Doing so would presumably add latency and reduce the effectiveness of fast open. It would make more sense for the LB to just do NAT rather than proxying the connection. Is there any special handling in conntrack needed for this?  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510133"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 8, 2012 8:02 UTC (Wed)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/510133/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think it would affect the effectiveness a lot -- presumably the backend server and LB are close by each other, so the latency between them matters less than the latency between the LB &amp; client.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510133/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor509319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 9:42 UTC (Thu)
                               by <b>Los__D</b> (guest, #15263)
                              [<a href="/Articles/509319/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"In the above steps, if the TFO cookie proves not to be valid, then the server TCP discards the data and sends a segment to the client TCP that acknowledges just the SYN. At this point, the TCP conversation falls back to the normal three-way handshake. If the client TCP is authentic (not malicious), then it will (transparently to the application) retransmit the data that it sent in the SYN segment."<br>
<p>
Why does the server discard the data? Shouldn't it just return to the old ways, and defer the delivery until the three-way handshake has completed?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 10:59 UTC (Thu)
                               by <b>dan_a</b> (guest, #5325)
                              [<a href="/Articles/509326/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would think that the problem is the resources in the OS which you could consume by doing this - especially since the handshake has already failed one trustworthiness test.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509328"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 11:28 UTC (Thu)
                               by <b>Los__D</b> (guest, #15263)
                              [<a href="/Articles/509328/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But if it is already possible to send data with an normal SYN, and that data gets delivered to the application later, what do you gain from throwing it away when you use TCP Fast Open? If the feature can be used for SYN attacks, they would just do it without Fast Open.<br>
<p>
I'm probably missing something, but it doesn't really make sense to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509328/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509480"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 2:17 UTC (Fri)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/509480/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If I am not mistaken, most modern TCP stacks do not hold data sent with a SYN, and do not send it either.  For most applications, there would be relatively little advantage if they did.  Requests usually fit in an MTU (or MSS) worth of data, and in the absence of something like TCP Fast Open, the target endpoint has to wait for an acknowledgement that can carry the full sub-MSS sized request without a problem.  Where on the other hand, holding the data simply makes it easier to conduct SYN attacks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509480/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor509361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 15:57 UTC (Thu)
                               by <b>gdt</b> (subscriber, #6284)
                              [<a href="/Articles/509361/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>"Router latencies" isn't really an issue, as they are easily enough solved by increasing the bandwidth (which reduces the time to receive and transmit a packet). (And yeah, I'm avoiding the "bufferbloat" overprovisioning of buffers at the network edge here, because when that exists RTO is not much help -- saving one RTT when you have multiple RTT in the queue ahead of you isn't a huge win.)</p>

<p>The speed of light in optical fiber is the major contributor to latency. The speed of light in fiber is roughly 150Km per ms, this is much slower than the speed of light in a vacuum.  The speed of light in a fiber can be improved, but at the cost of narrowing bandwidth. This tradeoff isn't available to users, but is determined during ITU standards-making. Moreover the tradeoff isn't huge, in the order of 5% of latency. But the tradeoff does have a major effect on the cost of Forward Error Correction ASICs.</p>

<p>Once you get out of the tail links, the lowest speed you'll encounter on a ISP backbone is 1Gbps. You've got to have well more than 1,000 router hops before you'll get 1ms of ingress playin, cell switching and egress playout. The other devices which can add significant latency are the middleboxes at the other end of the link: firewalls, load sharers and so on.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/509361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509460"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 23:44 UTC (Thu)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/509460/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So when will we see companies building vacuum tubes used to speed up the light when crossing large parts of land or maybe the atlantic ?<br>
<p>
That is the thing I care about. ;-)<br>
<p>
Is anyone doing research on that yet ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509460/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509732"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2012 12:20 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/509732/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Warning: work in this area can be dangerous. See e.g. the series, ahem I mean feasibility study, bookended by &lt;<a href="http://www.amazon.com/The-Collapsium-Wil-McCarthy/dp/055358443X">http://www.amazon.com/The-Collapsium-Wil-McCarthy/dp/0553...</a>&gt;, &lt;<a href="http://www.amazon.com/To-Crush-Moon-Wil-McCarthy/dp/055358717X">http://www.amazon.com/To-Crush-Moon-Wil-McCarthy/dp/05535...</a>&gt;.<br>
<p>
(Though admittedly the Queendom did go to rather more extreme lengths to increase the speed of light than mere vacuum tubes, and displayed a cavalier degree of carelessness, indeed insouciance, regarding the fact that keeping trillions of black holes in your solar system in very large arrays moving at well below orbital velocity is insanely dangerous.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509732/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor509739"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2012 13:34 UTC (Sat)
                               by <b>Jannes</b> (subscriber, #80396)
                              [<a href="/Articles/509739/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
actually TFO should be a huge improvement in a bufferbloated situation. If there is 1 second of bufferbloat, then 'Saving one RTT' means saving 1 second.<br>
<p>
Not saying it's a solution to bufferbloat of course.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509739/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor509770"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2012 23:12 UTC (Sat)
                               by <b>drdabbles</b> (guest, #48755)
                              [<a href="/Articles/509770/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This may be true in theory (I'm not sure), but in practice it's completely wrong. Bandwidth tells you only how much data can be passed through a link in a given time period. Saying a link is capable of 1Gbit/sec means if you consume every possible bit for every possible cycle for 1 second, you'll have transferred 1Gbit of data over the wire. Many links have a frame/second limit, so if your frames aren't completely full, you've wasted bandwidth and decreased the utilization of the link.<br>
<p>
Router latency is caused by many factors. Some can be router CPU shortages, memory resource shortages, the time it takes to transfer a frame from "the wire" to the internal hardware and vice verse, how quickly a packet can be processed, whether packet inspection is happening, etc. This, relatively speaking, can be a very long time. Typically it's microseconds, but certainly not always. Either way, it represents a minimum time delay with only a practical ceiling (IP timeout / retransmission). So increasing bandwidth to an already slow router only makes the problem worse.<br>
<p>
Also, if you have a link that passes through 1000 routers, it's bound to hit a dozen that are oversubscribed and performing horribly. This is especially true as your distance from the "core" increases and your distance to the "edge" decreases. This is why major datacenters are next to or house the major peering points of the Internet.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509770/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor509395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 18:46 UTC (Thu)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/509395/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Perhaps I'm not totally understanding what's going on here (high-level): TFO seems more like a user-space fix (i.e. Apache HTTPD, Microsoft IIS, etc.).  Are changes to the system calls <tt>socket(2)</tt>, <tt>connect(2)</tt>, etc. the reason this article is on the LWN Kernel Development page?</p>

<p>Also, do I assume correctly that both client and server have to support TFO to realize the speed-up mentioned in the article?</p>

<p>I certainly don't mean to criticize this article (or its placement here on LWN), just curious instead.  Great article, thanks!</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/509395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor509481"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2012 2:22 UTC (Fri)
                               by <b>butlerm</b> (subscriber, #13312)
                              [<a href="/Articles/509481/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, both client and server need support for TCP Fast Open.  That support amounts to a change to both the TCP stack and the TCP socket API, both of which are implemented by the kernel.  Without kernel support (or a user space TCP implementation and the privileges necessary to use it) neither endpoint can make use of TFO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509481/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor509403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">TCP Fast Open: expediting web services</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 2, 2012 19:06 UTC (Thu)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/509403/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Google [...] to implement TCP Fast Open</font><br>
<p>
Great, now GTFO is going to get a new subentry in the Urban Dictionary.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/509403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor510509"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Examples for the speed of light</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2012 0:28 UTC (Fri)
                               by <b>paulproteus</b> (guest, #69280)
                              [<a href="/Articles/510509/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      The article says:

<blockquote>At intercontinental distances, this physical limitation means that—leaving aside router latencies—transmission through the medium alone requires several milliseconds</blockquote>

To be more concrete:

<ul><li>1 mile is 5 microseconds</li>
<li>6 milliseconds from New York to Florida (1152 miles)</li>
<li>15 milliseconds from New York to San Francisco (2917 miles)</li>
<li>36 milliseconds from New York to Tokyo (6735 miles)</li>
</ul>

Source for time conversion: GNU Units.

<blockquote>You have: 1 mile<br>
You want: light second<br>
	* 5.3681938e-06<br>
	/ 186282.4
</blockquote>
      
          <div class="CommentReplyButton">
            <form action="/Articles/510509/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510517"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Examples for the speed of light</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2012 1:27 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/510517/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it's actually a bit longer than these times as the speed of light you are listing is the speed of light through a vacuum, going through fiber is noticeably slower.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510517/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor510519"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Examples for the speed of light</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2012 1:30 UTC (Fri)
                               by <b>paulproteus</b> (guest, #69280)
                              [<a href="/Articles/510519/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting point!<br>
<p>
<a href="http://blog.advaoptical.com/speed-light-fiber-first-building-block-low-latency-trading-infrastructure/">http://blog.advaoptical.com/speed-light-fiber-first-build...</a> suggests that one should expect approximately a 33% increase in these times for the fiber optics.<br>
<p>
(Additionally, they should be doubled due to round-trip time, as per my follow-up comment.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510519/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor510518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Examples for the speed of light (Correction)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2012 1:28 UTC (Fri)
                               by <b>paulproteus</b> (guest, #69280)
                              [<a href="/Articles/510518/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One correction to the above note: One should *double* these numbers for *round*-trip time. These are one-way times.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/510518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor518298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Examples for the speed of light</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2012 8:17 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/518298/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do fibers follow great-circle routes already?  I expected that to take longer to happen.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/518298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor519575"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Examples for the speed of light</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2012 12:04 UTC (Fri)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/519575/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can see the routes here:<br>
<p>
<a href="http://www.cablemap.info/">http://www.cablemap.info/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/519575/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
