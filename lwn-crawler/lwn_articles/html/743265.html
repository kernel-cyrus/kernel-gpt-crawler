        <!DOCTYPE html>
        <html lang="en">
        <head><title>Addressing Meltdown and Spectre in the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/743265/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/742985/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/743265/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Addressing Meltdown and Spectre in the kernel</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 5, 2018</br>
           </div>
When the Meltdown and Spectre vulnerabilities were disclosed on
January&nbsp;3, attention quickly turned to mitigations.  There was already
a clear defense against Meltdown in the form of <a
href="/Articles/741878/">kernel page-table isolation</a> (KPTI), but the
defenses 
against the two Spectre variants had not been developed in public and still
do not exist in the mainline kernel.  Initial versions of proposed
defenses have now been disclosed.  The resulting picture shows what has
been done to fend off Spectre-based attacks in the near future, but the
situation remains chaotic, to put it lightly.
<p>
First, a couple of notes with regard to Meltdown.  KPTI has been merged for
the 4.15 release, followed by a steady trickle of fixes that is undoubtedly
not yet finished.  The <tt>X86_BUG_CPU_INSECURE</tt> processor bit is being
<a href="/Articles/743276/">renamed</a> to <tt>X86_BUG_CPU_MELTDOWN</tt>
now that the details are public; there will be bug flags for the other two
variants added in the near future.  <a href="/Articles/743248/">4.9.75</a>
and <a href="/Articles/743249/">4.4.110</a> have been released with their
own KPTI variants.  The older kernels do not have mainline KPTI, though;
instead, they have a backport of the older KAISER patches that more closely
matches what distributors shipped.  Those backports have not fully
stabilized yet either.  KPTI patches for ARM are circulating, but have not
yet been merged.
<p>
<h4>Variant 1</h4>
<p>
The first Spectre vulnerability, known as "variant 1", "bounds-check bypass",
or CVE-2017-5753,
takes advantage of speculative execution to circumvent bounds checks.  If
given the following pseudocode sequence:
<p>
<pre>
    if (within_bounds(index)) {
        value = array[index];
	if (some_function_of(value))
	    execute_externally_visible_action();
    }
</pre>
<p>
The body of the outer <tt>if</tt> statement should only be executed if
<tt>index</tt> is within bounds.  But it is possible that this body will be
executed speculatively before the bounds check completes.  If
<tt>index</tt> is controlled by an attacker, the result could be a
reference far beyond the end of <tt>array</tt>.  The resulting value will
never be directly visible to the attacker, but if the target code performs
some action based on the value, it may leave traces somewhere where the
attacker can find them — by timing memory accesses to determine the state
of the memory cache, for example.
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
The best solution here (and for the other variants too) would be for the
processor to completely clean up 
the results of a failed speculation, but that's not in the cards anytime
soon.  So the approach being taken is to prevent speculative execution
after important bounds tests in the kernel.  An <a
href="/Articles/743277/">early patch</a>, never posted for public review,
created a new barrier macro called <tt>osb()</tt> and sprinkled calls to it in
places where they appeared to be necessary.  In the pseudocode above, the
<tt>osb()</tt> call would be placed immediately after the first <tt>if</tt>
statement.
<p>
It would appear that this is not the approach that will be taken in the
mainline, though, judging from <a href="/Articles/743188/">this patch
set</a> from Mark Rutland.  Rather than place barriers after tests, this
series creates a set of helper macros applied to the pointer and array
references instead.  <a href="/Articles/743278/">The documentation</a>
describes them in detail.  For the example above, the second line would
become:
<p>
<pre>
    int *element = nospec_array_ptr(array, index, array_size);
    if (element)
        value = *element;
    else
        /* Handle out-of-bounds index */
</pre>
<p>
If the index is less than the given <tt>array_size</tt>, a pointer to the
indicated value — <tt>&amp;array[index]</tt> — will be returned;
otherwise a null pointer is returned.  The macro contains whatever
architecture-specific magic is needed to prevent speculative execution of
pointer dereferencing operation.  This magic is supported by new directives
being added to the <a
href="https://gcc.gnu.org/ml/gcc-patches/2018-01/msg00205.html">GCC</a> and
<a href="https://reviews.llvm.org/D41760">LLVM</a> compilers.

<p>
Earlier efforts had included a separate <a
href="/Articles/743280/"><tt>if_nospec</tt> macro</a> that would replace
the <tt>if</tt> statement directly.  After discussion, though, its author
(Dan Williams) <a href="/Articles/743281/">decided</a> to drop it and use
the dereferencing macros instead.
<p>
These macros can protect against variant 1 — if they are placed in the
correct locations.  As <a href="/Articles/743282/">Linus Torvalds
noted</a>, that is where things get a bit sticky:
<p>
<div class="BigQuote">
	I'm much less worried about these "nospec_load/if" macros, than I am
	about having a sane way to determine when they should be needed.
<p>
	Is there such a sane model right now, or are we talking "people will
	randomly add these based on strong feelings"?
</div>
<p>
Finding exploitable code sequences in the kernel is not an easy task; the
kernel is large and makes use of a lot of values supplied by user space.
It <a href="/Articles/743284/">appears</a> that speculative execution can
proceed for sequences as long as "<q>180 or so simple
instructions</q>", which means that the vulnerable test and subsequent
reference can be far apart — even in different functions.  Identifying such
sequences is hard, and preventing the introduction of new ones in the
future may even be harder.
<p>
It seems that the proprietary Coverity checker was used to find the spots
for which there are patches to date.  That is less than ideal going
forward, since most 
developers do not have access to Coverity.  The situation may not improve
anytime soon, though.  Some developers have suggested using <a
href="http://coccinelle.lip6.fr/">Coccinelle</a>, but 
Julia Lawall, the creator of Coccinelle, has <a
href="/Articles/743287/">concluded</a> that the task is too complex for
that tool.
<p>
One final area of concern regarding variant 1 is the BPF virtual machine.
Since BPF allows user space to load (and execute) code in kernel space, it
can be used to create vulnerable code patterns.  The early patches added
speculation barriers to the BPF interpreter and JIT compiler, but it
<a href="/Articles/743289/">appears</a>
that they are not enough to solve the problem.  Instead, <a
href="/Articles/743288/">changes to BPF</a> are being considered to prevent
possibilities for speculative execution from being created.
<p>
<h4>Variant 2</h4>
<p>
Attacks using variant 1 depend on the existence of a vulnerable code
sequence that is conveniently accessible from user space.  Variant&nbsp;2,
(or "branch target injection", CVE-2017-5715)
instead, depends on poisoning the processor's branch-prediction mechanism
so that indirect jumps (calls via a function pointer, for example) will,
under speculative execution, be redirected to an attacker-chosen location.
As a result, a useful sequence of code (a "gadget") anywhere in the kernel
can be made to run speculatively on demand.  This attack can also be
performed across 
processes in user space, meaning that it can be used to access data outside
of a JavaScript sandbox in a web browser, for example.
<p>
There are two different variant-2 defenses in circulation, in multiple
versions.  Complete protection of systems will likely involve some
combination of both, at least in the near future.
<p>
The first of those is a processor microcode update giving the operating
system more control over the use of the branch-prediction buffer.  The new
feature is called IBRS, standing for "indirect branch restricted
speculation".  It takes the form of a new bit in a model-specific register
(MSR) that, when written, effectively clears the buffer, preventing the
poisoning attack. 
<a href="/Articles/743019/">A patch set enabling IBRS</a> usage in the
kernel has been posted 
but, in an example of the rushed nature of much of this work, the patches
did not compile and had clearly not been run in their posted form.
<p>
The alternative approach is a hackaround termed a "return trampoline" or
"retpoline"; this mechanism is well described in <a
href="https://support.google.com/faqs/answer/7625886">this Google page</a>
(which also suggests that we should "<q>imagine speculative execution as
an overly energetic 7-year old that we must now build a warehouse of
trampolines around</q>").  A retpoline replaces an indirect jump or indirect
function call with a sequence of operations that, in short, puts the
target address onto the call stack, then uses a <tt>return</tt> instruction
to "return" to the function to be called.  This dance prevents speculative
execution of the call; it's essentially a <a
href="https://en.wikipedia.org/wiki/Return-oriented_programming">return-oriented
programming</a>
attack against the branch predictor.  The performance cost of using this
mechanism is estimated at 0-1.5%.
<p>
Naturally, these retpolines must be deployed to every indirect call in any
program (the kernel or something else) that is to be protected.  That is
not a task that can reasonably be done by hand in non-trivial programs.
But it is something that can be given over to a compiler to handle.  <a
href="https://reviews.llvm.org/D41723">LLVM patches</a> have been posted to
automate retpoline generation, but that is not particularly helpful for the
kernel. GCC patches have not yet been circulated, but they can be found in
<a
href="http://git.infradead.org/users/dwmw2/gcc-retpoline.git/shortlog/refs/heads/gcc-7_2_0-retpoline-20171219">this
repository</a>. 
<p>
Several variants of the retpoline patches for the kernel have been posted
by different 
authors who clearly were not always communicating as well as they could
be.  The current version, as of this writing, was <a
href="/Articles/743291/">posted</a> by David Woodhouse.  This series
changes the kernel
build system to use the new GCC option and includes manual conversions for
indirect jumps made by assembly-language code.  There is also a
<tt>noretpoline</tt> command-line option which will patch out the
retpolines entirely.
<p>
The retpoline implementation seems to be nearly stable and imposes a
relatively small overhead overall.  But there is still a lot of uncertainty
around whether any given system should be using retpolines or IBRS — or a
combination of the two.  One might think that a hardware-based mechanism
would be preferable, but the performance cost of IBRS is evidently quite
high.  So it seems that, as a general rule, retpolines are preferable to
IBRS.  But there are some exceptions.
<p>
One of those is that, it would seem, retpolines don't work on
Skylake-generation Intel CPUs, which perform more aggressive speculative
execution around <tt>return</tt> operations.  Nobody has publicly
demonstrated that this speculation can be exploited on Skylake processors,
but some developers, at least, are nervous about leaving a possible
vulnerability open.  As Woodhouse <a href="/Articles/743293/">said</a>:
<p>
<div class="BigQuote">
	We had IBRS first, and especially on Broadwell and earlier, its
	performance really is painful.  Then came retpoline, purely as an
	optimisation. A very *important* performance improvement, but an
	optimisation nonetheless.
<p>
	When looking at optimisations, it is rare for us to say "oh, well
	it opens up only a *small* theoretical security hole, but it's
	faster so that's OK".
</div>
<p>
So the more cautious administrators, at least, will probably want to stick
with IBRS on Skylake processors.  The good news is that IBRS performs
better on those CPUs than it does on the earlier ones.
<p>
The other problem is that, even if the kernel can be built with retpolines,
other code, such as system firmware cannot be.  Concerns about firmware
surprised some developers, but it would seem that they are warranted.
<a
href="/Articles/743294/">Quoting Woodhouse</a> again:
<p>
<div class="BigQuote">
	In the ideal world, firmware exists to boot the kernel and then it
	gets out of the way, never to be thought of again.  In the Intel
	world, firmware idiocy permeates everything and we sometimes end up
	making calls to it at runtime.
</div>
<p>
The firmware that runs in response to those calls is unlikely to be rebuilt
with retpolines in the near future, so it may well contain vulnerabilities
to variant-2 attacks. Thus the IBRS bit needs to be set
before any such calls are made, regardless of whether IBRS is used by the
kernel as a whole.
<p>
<h4>In summary</h4>
<p>
From all of the above, it's clear that the development community has not
yet come close to settling on the best way to address the Spectre
vulnerabilities.  Much of what we have at the moment was the result of
fire-drill development so that there would be something to ship when the
disclosure happened.  Moving the disclosure forward by six days at the last
minute did not help the situation either.
<p>
It is going to take some time for everything to settle down — even if no
other vulnerabilities crop up, which is not something that would be wise to
count on.  It's worth noting that, in the IBRS discussion, Tim Chen <a
href="/Articles/743295/">said</a> that there are more speculation-related
CPU features in the works at Intel.  They may just provide better defenses
against the publicly known attacks — maybe.  But even if no other
vulnerabilities are about to jump out at us, it seems almost certain that
others will be discovered at some point in the future.
<p>
Meanwhile, there is enough work to do just to get a proper handle on the
current set of problems and to get acceptable solutions into the mainline
kernel.  It seems fair to say that these issues are going
to distract the development community (for the kernel and beyond) for some
time yet.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Retpoline">Retpoline</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Meltdown_and_Spectre">Security/Meltdown and Spectre</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Meltdown_and_Spectre">Meltdown and Spectre</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/743265/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor743308"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2018 23:43 UTC (Fri)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/743308/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We have an internal binary scanning tool that can help identify variant 1 loads which has been under development for a while but isn't ready for release. I am going to followup about what we can do to expedite getting tools developed for projects - this all went down a bit chaotically as you said. Won't help today, but we have also been discussing the merits of getting an LF or FSF project pulled together to develop new tools. Certainly this needs to be a focus of discussion at OSLS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743308/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 0:12 UTC (Sat)
                               by <b>jeff_marshall</b> (subscriber, #49255)
                              [<a href="/Articles/743312/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can you comment on where interested parties might look for this tool if/when it's released? It would be a big help when validating the effectiveness of manual code audits, which I suspect is going to be the first line of defense for many people (including the company I work for).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 1:07 UTC (Sat)
                               by <b>ken</b> (subscriber, #625)
                              [<a href="/Articles/743318/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes the developers needs new tools but how about the pore end user? telling people to update and use the latest patches is like telling them to backup all their data. It's not going to happen as it's to much work. I myself use in a week something like 5-10 different computer and I have no clue if the latest microcode for the CPU is used or even the lasted BIOS I mostly do not even know what motherboard there is. <br>
<p>
Sure I can check but it's going to take a lot of time and the next day something new might have been released. <br>
<p>
There needs to be some distro agnostic tool that continuously checks this things and that pester the user on like every login that they are out of date. Preferably list all the known   CVE that a system is open for. Its really important that this lives outside of the distro update system so people notice when the distro fails doing timely update. <br>
<p>
Maybe the gnome desktop project could put some time into something useful for once instead of doing things like a desktop map program that  I'm not sure anybody even asked for. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 1:28 UTC (Sat)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/743319/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Like <a href="https://fwupd.org/">https://fwupd.org/</a> which is integrated into Gnome?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 2:11 UTC (Sat)
                               by <b>ken</b> (subscriber, #625)
                              [<a href="/Articles/743321/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And it was already installed. but not functional as far as I can see. <br>
<p>
/usr/bin/fwupdmgr update<br>
No devices can be updated<br>
<p>
does that mean I'm ok or that there really is no device that the program knows about on my computer.? <br>
<p>
do not look like it knows anything about cpu microcode versions. <br>
<p>
It gets confused about the version of the BIOS. could be that the BIOS is reporting wrong but the version I have do not exist  on the web site. demidecode also report the same strange values. There is two versions 1.I0, date 04/25/2017 and BIOS Revision: 5.12. none of them exist as a download. latest looks to be  Version 7976v1J Release Date 2017-12-19.<br>
<p>
This is exactly the issue with telling people to be updated. Nobody is going to be able to do this manually.  Something should have alerted me that there is a new version even if it do not know how to actually install the new version. <br>
<p>
Maybe just mapping the mainboard to the BIOS version and storing every uniq combination is enough. then whenever anybody anywhere do an update the system know that somewhere there is a newer version and everybody gets a notice. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 2:54 UTC (Sat)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/743331/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It requires that your system vendor support the service, and many (unfortunately) don't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743505"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 14:14 UTC (Mon)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/743505/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thankfully, Linux can update microcode independently of your BIOS. It's typically built into your initramfs, and one of the very first things the kernel does as it boots is to upload the new microcode to the CPU. If so, it comes from your package repository (apt/yum/pacman/whatever) like any other package, and all you need to worry about is to have a system in place for automatically patching those and booting every now and then.<br>
<p>
The microcode is obviously a non-free component, but most people will be willing to make that sacrifice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743505/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743313"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about the Intel Management Engine?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 0:15 UTC (Sat)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/743313/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can vulnerable code be in the ME and can it reveal ME memory to userspace programs?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743313/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743316"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about the Intel Management Engine?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 0:38 UTC (Sat)
                               by <b>jspenguin</b> (guest, #120333)
                              [<a href="/Articles/743316/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An interesting thought... Does the ME processor itself do speculative execution? I've heard it's based on a 486-like core, so I would be inclined to say no, but then again, this is Intel we're talking abount.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743316/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743320"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about the Intel Management Engine?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 1:40 UTC (Sat)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/743320/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The ME contains an Edison/Quark CPU x32 CPU. According to Wikipedia it's got the same instruction set as a P54C/i586 CPU. There is no indication if it's got the out of order engine that was present on the 586. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743320/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about the Intel Management Engine?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 2:13 UTC (Sat)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/743326/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
AIUI, 586/P1 had pairing, but not out-of-order, which was introduced<br>
with the PPro.<br>
<p>
That being said, it is only known that the 586/P1 is safe from Meltdown,<br>
nothing about Spectre safety yet. (I do run a server with such a CPU.)<br>
<p>
As for the original question, I’d expect it not to be, as it’s a separate<br>
CPU and address space… well unless Intel fucked up. Indeed this is Intel<br>
we’re talking about. Perhaps it can be mapped, but that would kinda defeat<br>
it, so…<br>
<p>
… on the other hand, conspiracy can be smelt in “throw away all your old<br>
CPUs, buy new ones to be safe from Spectre and Meltdown… oh did we mention<br>
you can only buy CPUs with the MEv2 now, which is even more backdoored?”.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743346"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about the Intel Management Engine?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 11:28 UTC (Sat)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/743346/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah I see.<br>
So as long as the ME does not share the cache or if it does not even have a cache, we're probably fine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743346/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744542"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about the Intel Management Engine?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2018 1:56 UTC (Wed)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/744542/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good luck to anyone other than Intel to know that, for all we know it does in fact do so. Intel will divulge nothing about the ME other than the the relatively recent revelation that the ME is running Minix. <br>
<p>
I'm sure these management engines on both Intel and AMD will found to be full of holes, exploits and bad programming just like all the rest of the software in the world with these weaknesses hidden by proprietary code. One of the advantages of open source is it's easier for people to find those bugs and programming errors and get them fixed rather than having them sit there like a timebomb. People have been begging Intel to release the ME code so it can be audited for years now, maybe after the 5th or 10th major vulnerability they will finally give in. It takes the black hats longer because there is no code, but now that the first ME vulnerability is found it wont' be long till the next and the hat wearing people (white, grey and black) are investigating the ME system in full force now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744542/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about the Intel Management Engine?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 16:54 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/743372/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quark is 486 core. Since 486 and Pentium differ only by a couple if instructions... They added these and now it's "Pentium ISA CPU". Pure marketing gimmic. It's not superscalar thus THESE attacks don't affect it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor743324"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Way too narrow</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 2:09 UTC (Sat)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/743324/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There’s no IBRS bit in the old Pentium M and early Celeron systems I have.<br>
<p>
The suggested commands to fill the retpoline do not exist on the 80486‑<br>
based (both Intel and not) and P5-based Pentium MMX systems I have and run.<br>
<p>
Also, there’s still no word out precisely which CPUs are affected by<br>
Speculatius, err, Spectre. For Meltdown, the situation is clear, but<br>
what kinds of CPUs are exempted from Spectre-like attacks?<br>
<a href="https://www.raspberrypi.org/blog/why-raspberry-pi-isnt-vulnerable-to-spectre-or-meltdown/">https://www.raspberrypi.org/blog/why-raspberry-pi-isnt-vu...</a><br>
has a good description of CPU classes (in-order, out-of-order, OOO plus<br>
speculative), but it’s equally hard to find which CPU matches which?<br>
<p>
What about SPARC v7 and especially v8 CPUs (supersparc, hypersparc)?<br>
(Not asking about SPARC64 v9 CPUs.)<br>
<p>
This is totally chaotic, I agree. I’ve mostly understood Meltdown, but<br>
Spectre remains puzzling, and it’s also only described in examples, not<br>
in general.<br>
<p>
I’d expect a solution that requires recompiling everything with a patched<br>
compiler to be… very unhelpful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743324/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743358"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Way too narrow</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 14:45 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/743358/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That Raspberry Pi article is just beautiful. If Intel had come out with that instead of its mealy-mouthed, equivocatory press release, people might be feeling a lot happier about this screwup.<br>
<p>
And it's not the only really good explanation I've read in the last few days, either (Google's had some very good ones, and there've been others, obviously including Jon's!). This is probably simply because other companies have nothing to lose, so they let doc writers and hackers at the job of explaining things, while Intel has everything to lose, so they gave the job to lawyers, who it appears demanded they do all but outright lie to their customers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743358/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor743328"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 2:46 UTC (Sat)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/743328/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with simple barriers in the case of variant 1 is that they work for the original x86 solution (lfence the second speculated loads, and guarantee that lfence is serializing if it wasn't on some cores) but they aren't good across architectures where other better solutions and optimizations might be possible. Which is why they're looking at alternatives. There have been many names for the simple barrier btw, and I think we renamed them 2 or 3 times at least.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743328/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743329"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 2:50 UTC (Sat)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/743329/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Retpolines are a great invention (thanks Google), but there are lots of corner cases (RSB state dependent), they require non-trivial toolchain changes (we did analyze this approach at length), and so on. On the other hand, you always need IBPB on VM world switch, so you need the microcode anyway. The safest thing to do right now would be to just do IBRS and IBPB and rely on microcode updates, which is also similar to what will happen on other architectures than just x86 (which is getting too much focus as if it were the only one that mattered). To get something that works do the microcode approach and take the hit. Then followup with the optimized alternatives based approaches and retpolines.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743329/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 2:53 UTC (Sat)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/743330/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In RHEL, we turn on all the mitigations by default, and we stuck with the microcode approach rather than deal with getting retpolines right on day one. My recommendation was that after the craziness subsided we got the mainline GCC (and LLVM) communities to hammer that out. We fully expected this to eventually get figured out and then potentially go back and rework/replace the initial mitigations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor743337"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why the issue became public before the 9th of January?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 8:29 UTC (Sat)
                               by <b>sasha</b> (guest, #16070)
                              [<a href="/Articles/743337/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am sorry for a stupid question, but you say "Moving the disclosure forward by six days at the last minute did not help the situation either."  Why it happened?<br>
<p>
I believe that all parties have their strong reasons, but for Russia is was extremely unfortunate because we have holidays for the first week in January...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743337/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why the issue became public before the 9th of January?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 9:18 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/743340/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why it happened?</font><br>
Basically, multiple people deduced the vulnerability on their own based on disclosed patches.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why the issue became public before the 9th of January?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 10:53 UTC (Sat)
                               by <b>edeloget</b> (subscriber, #88392)
                              [<a href="/Articles/743344/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From my understanding, many people understood there was some kind of harsh as hell vuln somewhere on processors, and it began to generate a very bad buzz for processor vendors (intel stock for instance began to decline before the vuln was made public).<br>
<p>
I haven't seen any speculation that pointed to cache speculation before it was made public :) (but indeed, the whole thing look like a real-life exploit of the very same bug). <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743345"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why the issue became public before the 9th of January?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 11:10 UTC (Sat)
                               by <b>MarcB</b> (subscriber, #101804)
                              [<a href="/Articles/743345/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://twitter.com/brainsmoke/status/948561799875502080">https://twitter.com/brainsmoke/status/948561799875502080</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743345/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743373"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why the issue became public before the 9th of January?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 16:56 UTC (Sat)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/743373/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, when we pulled down that reproducer and I analyzed it on Wed, we knew things were going to get interesting quicky.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743373/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor744003"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why the issue became public before the 9th of January?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 11, 2018 2:26 UTC (Thu)
                               by <b>JoeBuck</b> (subscriber, #2330)
                              [<a href="/Articles/744003/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <a href="https://www.theregister.co.uk/2018/01/02/intel_cpu_design_flaw/">The Register broke the story on Jan 2</a> (though it seems they only knew about Meltdown, and then only roughly, and not Spectre).  It appears that AMD gave the game away with <a href="https://lkml.org/lkml/2017/12/27/2">a patch disclosing that AMD wasn't vulnerable to Meltdown</a> on Dec. 27, so a sufficiently careful reader of the kernel list would know what to look for at that point.
<p>
If AMD had waited for the embargo to lift before submitting that patch, it might have held longer.

      
          <div class="CommentReplyButton">
            <form action="/Articles/744003/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor743343"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 9:48 UTC (Sat)
                               by <b>arekm</b> (guest, #4846)
                              [<a href="/Articles/743343/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder if 4.1 series will get KAISER, too? (I guess it's unlikely since it's going to be EOL in may 2018)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743343/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743356"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 14:36 UTC (Sat)
                               by <b>shemminger</b> (subscriber, #5739)
                              [<a href="/Articles/743356/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The enterprise distro's have been porting it back to 3.XX<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743356/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 15:30 UTC (Sat)
                               by <b>sasha</b> (guest, #16070)
                              [<a href="/Articles/743364/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
... back to 2.6.32 (in RHEL6/CentOS6).  IIRC event RHEL5 (2.6.18) has an update!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743375"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 17:19 UTC (Sat)
                               by <b>amacater</b> (subscriber, #790)
                              [<a href="/Articles/743375/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Really pleased to see this - I wonder if someone can suggest to CentOS that they do this kernel backport to 5.* even after the end of their formal support?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743375/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor743382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 17:42 UTC (Sat)
                               by <b>arekm</b> (guest, #4846)
                              [<a href="/Articles/743382/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
AFAIK there is no enterprise distro that still maintains 4.1 and backported that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">x86 or x86-64</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2018 23:50 UTC (Sat)
                               by <b>aaaaaaaaaaa</b> (guest, #121170)
                              [<a href="/Articles/743408/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can someone clear up for me if 'meltdown' affects i386 (x86) or just i686/amd64 (x86-64)?  i.e.: does it affect windows 7 x32 or Red Hat 6 i386?  All of the exploit code I've seen so far is for x86-64 only, but the meltdown.pdf says PPro is 'theoretically' affected - which was not an x64 product.  Maybe the easiest way is to look at the kernel patch and see what the rules are for setting X86_BUG_CPU_INSECURE (X86_BUG_CPU_MELTDOWN), but it seems like that's still in a state of flux (e.g.: they've just added a vendor exception for AMD chips).  Bonus points for any comments on Spectre and i386 vs amd64...  I see Red Hat have released new kernels for RH6 i386 - but maybe they are just being cautious, trying to maintain one codeine, or that's only for spectre, not meltdown.  TIA!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">x86 or x86-64</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 7:35 UTC (Sun)
                               by <b>Lionel_Debroux</b> (subscriber, #30014)
                              [<a href="/Articles/743421/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup, 32-bit x86 is affected.<br>
<p>
<a href="https://twitter.com/grsecurity/status/949794658720337920">https://twitter.com/grsecurity/status/949794658720337920</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743460"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">x86 or x86-64</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 21:30 UTC (Sun)
                               by <b>aaaaaaaaaaa</b> (guest, #121170)
                              [<a href="/Articles/743460/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the reply.  You're not on LWN but I'm not on Twitter, so I'll reply here rather than there.  It's a confusing answer:  Yes x32/i386 is affected;  No the patches are for x64/amd64 only but GRSecurity have separate patches for x32 that the linux kernel maintainers don't seem interested in...  I'm assuming the Red Hat patches are the same - even though they've released new i386/x32 binaries that they don't have i386/x32 fixes?  This bug is doing my head in.  Anyone have any inside dirt on whether the Windows patches are also x64 only since I have those systems to maintain too...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743460/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743477"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">x86 or x86-64</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 1:57 UTC (Mon)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/743477/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Did the grsec folks post their x86_32 patches somewhere public? I thought they started restricting all their patches to customers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743477/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743481"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">x86 or x86-64</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 5:23 UTC (Mon)
                               by <b>aaaaaaaaaaa</b> (guest, #121170)
                              [<a href="/Articles/743481/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't know.  Surely that's a matter for grsec and the Linux Kernel developers to sort out?  I think his point was that no-one is talking about i386 and specifically talking about that these well publicised patches are only for amd64/x64.  My question was primarily 'is' i386 vulnerable? Not how to address it.  I have the answer to that: new silicon - these patches are for the birds (IMO - YMMV).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743481/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743485"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">x86 or x86-64</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 6:35 UTC (Mon)
                               by <b>Lionel_Debroux</b> (subscriber, #30014)
                              [<a href="/Articles/743485/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, they started restricting all of their patches to paying customers in 2017, after providing them at no cost for 15-16 years. Their statements about the change in behaviour point mostly to the KSPP's effects.<br>
<p>
However, even though merging the KAISER / KPTI (depending on which version of the kernel is targeted) code, the UDEREF code (and parts of the KERNEXEC code touching the same areas ?) together is far from trivial, chances are that it will eventually happen. And one of spender's tweets indicated that making PaX/grsec immune to a variant of a 32-bit port of the Meltdown exploit he devised, based on gs instead of fs (since he could not make the standard exploit work on an UDEREF-enabled kernel), took "~4 lines of code"; chances are that these could be figured out by third parties (not me).<br>
<p>
In another thread, <a href="https://twitter.com/ochsff/status/950025906751451142">https://twitter.com/ochsff/status/950025906751451142</a> , spender hinted at a possible blog post coming, and PaXTeam's reply was... amusing. Let's wait and see.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743485/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor743418"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 4:03 UTC (Sun)
                               by <b>simcop2387</b> (subscriber, #101710)
                              [<a href="/Articles/743418/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A bit off topic and meta, but I'd be curious how so many good articles you guys have written on this topic has affected subscriber counts.  This has to have been a goldmine for you guys.  Between them all I feel like I actually understand all the things going on with the vulnerabilities and the mitigations that are being created and put into place.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743418/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743437"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Subscriptions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 16:17 UTC (Sun)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/743437/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      There's definitely been an increase in subscription activity, which is great.  Welcome to all the new folks, and we're hoping you'll stay around!
      
          <div class="CommentReplyButton">
            <form action="/Articles/743437/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Subscriptions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 23:42 UTC (Sun)
                               by <b>aaaaaaaaaaa</b> (guest, #121170)
                              [<a href="/Articles/743470/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you!  I'm a new 12 month subscriber.  Yes the Meltdown/Spectre articles were my main reason for joining.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Subscriptions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 13:33 UTC (Wed)
                               by <b>alexwoehr</b> (guest, #100148)
                              [<a href="/Articles/743825/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just chiming in and saying thank you! I have been enjoying the great coverage here as we make our response plans. I hope the sudden workload of research didn't wreck any holiday plans.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743433"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 15:06 UTC (Sun)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/743433/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many writeups, here and elsewhere, don't seem to address the difference between incidental code and intentional code. Changing compilers to insert fence instructions, for instance, leaves hand-built assembler code still able to skip the new fence instruction placement.  If I were going only by these articles, it would almost seem like the speculative fetches are harmful by themselves, instead of merely leaking information.  For instance, a speculative return to an unauthorized address might start executing unauthorized code whose side effects could not be undone when the speculation proves false.  I don't expect that is the case, otherwise systems would have failed before ever leaving the labs.  But that's the impression I get from some stories.<br>
<p>
I understand how compiler changes can be helpful in the case of JavaScript.  But they won't do anything to prevent a dedicated program from collecting leaked information.<br>
<p>
Are malicious web pages with JavaScript the most likely attack vector?  Are there ways of mitigating the danger from hand-crafted assembly code run from the command line?  Or have I missed something?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743433/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743439"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 16:46 UTC (Sun)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/743439/">Link</a>] (28 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually, the flaw is that there is one side effect that is not undone: a value loaded into the cache during speculative execution stays in the cache, even if the speculation proves false. Whether this value is loaded or not can then be determined by timing differences (cache hit is faster than cache miss).<br>
<p>
The main attack vector for the kernel are calls from userspace. Userspace cannot force the kernel to run hand crafted assembly. However it can make calls (with hand crafted function parameters) and observe the timing. The fences are put into the kernel to ensure that critical functions do not do speculative execution any more.<br>
<p>
Of course, the details are much more involved, but this is the core of the Spectre flaw. Meltdown is a bit more extreme, as in userspace, Intel CPUs even speculatively executes accesses to memory that only the kernel is allowed to read. Again some traces are left in the cache that can be used to get some information about the memory contents. Here the solution is to unmap kernel memory in userspace (KPTI) to ensure that such speculative execution is impossible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743439/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743441"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 17:57 UTC (Sun)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/743441/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought I'd have trouble with my question :-)<br>
<p>
I understand the information leakage via timing.  What I don't quite understand is that all of the mitigations schemes I have seen don't protect against malicious assembly language programmers.  They do protect against malicious JavaScript and other web languages, because those must go through compilers on the target system.  This seems to leave local users writing malicious assembler as the only credible threats.  So my question boils down to -- what can be done to protect against them?<br>
<p>
I should have left off my side observation that many of these articles can be read as implying that actually executing the unauthorized access itself is harmful, beyond information leakage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743441/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743442"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 18:03 UTC (Sun)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/743442/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The thing you might be missing is that the attack is "only" interesting across privilege domains. In the javascript case that's being able to access all memory from within the JS sandbox. In the userland-&gt;kernel case that's accessing all kernel memory, etc.  What that basically means that protective measures have to be taken at each of the domain transitions, e.g. when entering/exiting javascript, when performing a syscall, etc.  Various patches to e.g. linux have been presented that make userland/kernel transition more secure (by flushing various caches, by preventing dangerous speculation, ...). The problem is that such domain transitions exist in a lot more places...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743442/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743443"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 18:15 UTC (Sun)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/743443/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We have to distinguish the two flaws. Meltdown allows unprivileged code to access privileged memory. The mitigation is kernel page table isolation, that is to unmap kernel memory when in user space. This helps against malicious assembly, as unmapped memory  cannot be accessed by speculative execution.<br>
<p>
For Spectre the problem is that privileged code (either kernel code wrt. userspace or userspace code wrt. javascript) leaves some traces from speculative execution behind after it is run. This can be triggered by unprivileged code by crafted function parameters (or by crafted javascript). Here, it is the privileged code that does (unwanted) speculative execution. The mitigation strategy is to use fences in privileged code to prevent the speculative execution at critical places. Then, even hand crafted assembly then cannot force the privileged code to do speculative execution any more.<br>
<p>
The fences should not go into unprivileged code. They have to be in the privileged code that is not under control of the attacker. To protect the kernel from userspace, it is necessary to compile the kernel with fences. To protect privileged userspace code (e.g. SUID binaries) from unprivileged userspace code, the privileged code has to be compiled with fences. To protect normal userspace code from javascript, the javascript interpreted (and JIT compiler) has to be compiled with fences.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743443/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 18:19 UTC (Sun)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/743448/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Here, it is the privileged code that does (unwanted) speculative execution."<br>
<p>
I better go back and read again -- this is where I went off the rails.  I hadn't realized this.  I thought it was user code sneaking a peek at kernel memory, or user code in a different process.<br>
<p>
Thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743449"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 18:25 UTC (Sun)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/743449/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually it is the user code that does some peek at kernel memory, but (at least for Spectre), this only works if some kernel code has done some speculative execution before that left traces in the cache. Therefore, this can be mitigated by changing the kernel code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743449/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743447"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 18:19 UTC (Sun)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/743447/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The code that does the bounds check or the indirect call is the victim. (The attacking code later reads the side effects from the cache.) If you prevent speculation in these cases, you avoid being a victim (at least for the currently known instances of Spectre).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743447/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor743445"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 18:12 UTC (Sun)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/743445/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <p>Newbie question... My understanding is that speculative execution happens if the processor stalls fetching something from main memory. Rather than spinning its wheels, it speculatively executes code that might be needed anyway.

<P>But if the speculatively-executing code stalls fetching something into the cache, is it really much of a performance improvement?  Couldn't speculative-execution run in a special mode that just abandons executing the code if it requires data that isn't already in the cache?  It seems to me that wouldn't have a huge performance penalty.

<P>Of course, this is a hardware change; it can't be done in software.

      
          <div class="CommentReplyButton">
            <form action="/Articles/743445/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743446"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 18:22 UTC (Sun)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/743446/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The delay of a cache miss is in the order of some hundred CPU cycles. The advantage of speculatively fetching into the cache is that the needed data arrives shortly after the information whether the speculative execution is correct. If there would be no speculative fetching, the CPU would stall some hundred cycles to wait for the jump condition and then another some hundred cycles to wait for the data. With speculative fetching, the performance hit is only taken once.<br>
<p>
Also, for Spectre, the privileged information might be already in the cache, allowing speculative execution to run without a stall. Running the same procedure twice should force the needed code into the cache the first time, and use it the second time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743446/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743453"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 18:32 UTC (Sun)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/743453/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <p>OK, how about this:  When something is fetched into the cache by speculatively-executing code, tag it as "speculatively fetched".  If the speculatively-executed code turns out to be required, the data is in cache and the speculatively-fetched tag is cleared.  If the speculatively-executed code is abandoned, then pretend the data is not in cache if some <em>other</em> code requires it.
      
          <div class="CommentReplyButton">
            <form action="/Articles/743453/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 18:42 UTC (Sun)
                               by <b>Otus</b> (subscriber, #67685)
                              [<a href="/Articles/743455/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That could still leak that something was *removed* from cache by the speculatively executed path.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743462"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 22:03 UTC (Sun)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/743462/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>Well, you could have a separate dedicated cache only used by speculatively-executed code and you only move it to the main cache (and evict something else) if the speculative execution was needed.  This means more cache memory, some of which is "wasted".

<P>I agree that you can never hope to shut all covert channels, but I think it is worth brainstorming how to reduce their bandwidth and make attacks harder
      
          <div class="CommentReplyButton">
            <form action="/Articles/743462/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743469"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 23:19 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/743469/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe you could add a new buffer to store speculative data before it goes into the L1 cache; but what about the L2 cache, and L3, and eDRAM, and buffers inside the DRAM? Any of those could be modified by the memory read in an observable way.<br>
<p>
Also, what would happen if you try to read a cache line that's currently dirty in another core's L1? The read would normally trigger that other core to write back to RAM (or share its data in some other way), which may be observable even if the first core perfectly hides the read from itself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743469/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 0:35 UTC (Mon)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/743473/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Ok. :) I get it.  So then it seems to me speculative-execution is by its very nature a covert channel impossible to shut down completely.  That's a somewhat unsettling reality.
      
          <div class="CommentReplyButton">
            <form action="/Articles/743473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 16:51 UTC (Mon)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/743583/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Speaking as the mostly clueless, would there be any sense in halting speculation if it leads to a load that was not present in L1? In that case, at least latency of L2/L3 will always be involved, if not a bus transaction. This would seem to be efficient where it matters, e.g. tight loops where the instruction stream is already cached, and for other cases PREFETCHxx could be used to explicitly request population where it was known it could not create problems<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor744568"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2018 14:55 UTC (Wed)
                               by <b>mstone_</b> (subscriber, #66309)
                              [<a href="/Articles/744568/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
since the point of speculation is basically to paper over memory latency, this would probably have a significant performance impact<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744568/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor743454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 18:47 UTC (Sun)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/743454/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good idea, but probably not enough. At least, this will make the attack harder. Even if the data is tagged in the cache, there is the effect that for some data to get into the cache some other data has to be revoked from the cache. The attacker can look which data was revoked and (because of cache associativity) learn which of two possible addresses has been loaded into the cache. It will make the attack harder, but not mitigate it completely.<br>
<p>
There will always be some side channels. Even the timing of speculative execution itself could reveal some information. The goal with side channels has to be to make the bandwidth really small, such that they become unusable. Closing all side channels after all means that the execution time must not depend on the data. Especially the best case performance has to be the same as the worst case performance. This would be a big performance hit that people usually will not pay. This is what is done in cryptography (where best and worst case usually do not differ that much anyway), but I do not think this is a valid option for each and every code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743461"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 21:54 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/743461/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You couldn't insert data into the cache without evicting something else first. Thus your scheme would need only minor modification to circumvent it: see what data it EVICTED from the cache by speculative read and go from there. Would be less reliable than current Spectre, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743461/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 12:20 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/743496/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I noted elsewhere, you'd need to keep a bit of the cache free, populate only that free bit with speculated fetches, cease speculation if it filled up and more reads were required, and evict such bits if only required by speculations that never retired.<br>
<p>
Making this all more complex is that you might have multiple speculations requiring the same bit of cacheline data, only some of which might fail so you need refcounting, and now you have counter overflow problems and oh gods I'm glad I'm not a silicon engineer right now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743510"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 15:15 UTC (Mon)
                               by <b>mgb</b> (guest, #3226)
                              [<a href="/Articles/743510/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe speculative fetches should not look beyond the L1 cache.<br>
<p>
Throwing away cached information and a hundred cycles to fetch something that might not be needed can be counter-productive.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743510/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743512"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 15:27 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/743512/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But one major benefit of speculation is that it can take the huge 100-clock hit of going to main memory in advance! We don't want to lose that *entirely*.<br>
<p>
Maybe this will require a memory controller redesign as well (a signal that this is a speculative fetch, reset the RAS and buffers of affected DIMMs to some default value before any subsequent nonspeculative fetch to those DIMMs, perhaps).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743512/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743519"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 15:57 UTC (Mon)
                               by <b>mgb</b> (guest, #3226)
                              [<a href="/Articles/743519/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect that memory running far enough ahead of CPU for speculative fetches to be beneficial is exceeding rare.<br>
<p>
Such rare use cases - staggering amounts of floating point ops on each fetched datum - could be hand crafted to use a speculative fetch without the risk of Spectre.<br>
<p>
And remember that speculation can just as easily be counter-productive - speculatively replacing a cache line not only leaks information but also throws away good cached information and replaces it with information of unknown merit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743519/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2018 23:46 UTC (Tue)
                               by <b>immibis</b> (guest, #105511)
                              [<a href="/Articles/743765/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I suspect that memory running far enough ahead of CPU for speculative fetches to be beneficial is exceeding rare.</font><br>
<p>
It would be quite common if most of the data the CPU is working on is in the cache already - which, in a well-designed and well-tuned program, should be the case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743819"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 10, 2018 11:51 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/743819/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>If the latency hit is 100 clocks,your cacheline size is 64 bytes, and the CPU is running sequentially through the data, each 100 clock delay gets you 64 bytes to work on. If the datum size is a 32 bit integer, that's 16 items to work on for every 100 clock latency hit. If my workload takes more than 6 clock cycles per item, then speculating far enough ahead that I can trigger the next cacheline fetch as soon as I've finished the first cacheline fetch means that my workload never sees a cache miss.
<p>I suspect this type of case isn't that rare - while I've described the absolute best case which can also be done easily by a prefetch engine, it also covers workloads where the code fits in L1I, the bytes you need to work on any one datum fit in L1D, but the bytes you need to work on the next datum are not all going to be in L1D immediately after finishing the last datum.
      
          <div class="CommentReplyButton">
            <form action="/Articles/743819/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 15:50 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/743518/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Branch predictors are apparently correct ~90% of the time, so it's worth doing things that have some performance cost on misprediction if they give a similar performance benefit in correctly-predicted cases.<br>
<p>
I'd imagine there's plenty of code that does something a bit like "for (linked_list_node *n = head; n-&gt;data-&gt;key != key; n = n-&gt;next) { }". If the CPU waits for n-&gt;data before fetching n-&gt;next, I think it's going to take two memory-latency periods per iteration. If it speculatively fetches n-&gt;next concurrently with n-&gt;data, it should run twice as fast, which is a huge improvement, with only a single incorrectly-predicted fetch at the end of the loop. I can't imagine CPU designers or marketers would be happy with throwing away so much performance in what seems like fairly common code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743592"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 17:03 UTC (Mon)
                               by <b>mgb</b> (guest, #3226)
                              [<a href="/Articles/743592/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In your example if n-&gt;data and n-&gt;next are in the same cache line there will be one fetch and if not there will be two fetches.<br>
<p>
It makes no difference whether speculative fetches are enabled, disabled, or enabled only to the L1 cache.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743592/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor743596"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 17:30 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/743596/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was thinking of something like "struct data { int key; ... }; struct node { node *next; data *data; };". Each iteration, it has to read one 'struct node' and one 'struct data', and they likely won't be in the same cache line as each other. It needs to read the first node to get the address of the first data (so there's a data dependency), and it needs to read the first data to determine whether it's safe to dereference node-&gt;next and read the second node (so there's a control dependency).<br>
<p>
I tried testing that code on a Haswell CPU. Nodes were 64B-aligned and randomly shuffled in memory (to avoid simple prefetching). Simply iterating over the list (i.e. one uncached memory read per node) takes about 310 cycles per node, which sounds plausible for RAM latency. Adding an 'lfence' instruction (which should prevent out-of-order reads) makes basically no difference (since these reads can't be reordered anyway). With the extra read of a 'data' pointer (i.e. two uncached memory reads per node, with control and/or data dependencies between them all), and no lfence, it takes about 370 cycles per node. With an lfence between the two reads, it goes up to 650 cycles.<br>
<p>
That suggests that (without lfence) it is indeed doing two memory reads in parallel, and must be speculatively ignoring the control dependency, so the second read is nearly free. Preventing speculation almost doubles the cost.<br>
<p>
(On a Cortex-A53 (which is in-order and doesn't really speculate), the one-read-per-node version takes 200 cycles, and the two-read-per-node version takes 420 cycles, so it's equivalent to the lfenced x86 version.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743596/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor745412"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2018 8:08 UTC (Fri)
                               by <b>mcortese</b> (guest, #52099)
                              [<a href="/Articles/745412/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Hats off, sir!
I wish more comments were as articulated and proof-backed as this one.
      
          <div class="CommentReplyButton">
            <form action="/Articles/745412/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor743459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 7, 2018 21:10 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/743459/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually, there are other side effects other than the memory caches, for example the branch predictors, the TLB, even the occupancy of specific functional units.<br>
<p>
Whether those other side effects are useful for exfiltrating data is unclear, but I suspect a lot of people are investigating that right now!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor743483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ARM speculation barrier instruction</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 8, 2018 6:00 UTC (Mon)
                               by <b>brouhaha</b> (subscriber, #1698)
                              [<a href="/Articles/743483/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Would I be correct in thinking that ARM's newly announced conditional speculation barrier instruction, intended to address these vulnerabilities, has the same problem as retpolines, etc., in that it's difficult or impossible to automatically identify all of the code paths which will require it?  Though presumably the cost will be slightly lower than retpolines, and unlike retpolines, they will be guaranteed not to be optimized away at run time by future ARM processors that might do more agressive speculation.

      
          <div class="CommentReplyButton">
            <form action="/Articles/743483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor743640"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2018 12:29 UTC (Tue)
                               by <b>kiko</b> (guest, #69905)
                              [<a href="/Articles/743640/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Taking a step back, I feel these mitigations, which add more complexity on top of an already incredibly complex system, are acceptable short-term fixes. However, they will also create new opportunities for exploitation. <br>
<p>
(Using an analogy in the non-technical world, it's kind of like what happens when you design a more complicated sales compensation plan to stymie basic gaming of an existing plan -- over time gaps and edges in the new system become evident and new, more sophisticated gaming techniques emerge.)  <br>
<p>
This is really the opportunity for the pendulum to swing in the opposite direction; first, for us to remove some of the black magic in hardware in favor of simpler designs, and second, for us to look at software tooling and design in order to better match the capabilities of modern hardware — in particular, the ability to scale out to multiple cores and systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/743640/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor744057"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Addressing Meltdown and Spectre in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 11, 2018 16:14 UTC (Thu)
                               by <b>and</b> (guest, #2883)
                              [<a href="/Articles/744057/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; One final area of concern regarding variant 1 is the BPF virtual machine. Since BPF allows user space to load (and execute) code in kernel space.</font><br>
<p>
As I see it, this is another clear indication that allowing unprivileged processes to load BPF programs by default is a very bad idea: Even if BPF and its verifier were completely bug free (which in the past they haven't been), it will facilitate exploiting other bugs. For the stated purpose of eBPF (performance analysis), it is IMO not a problem to hide that capability behind a debugfs knob.<br>
<p>
In other words, BPF in its current form is probably any intelligence agency's wet dream come true.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/744057/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
