        <!DOCTYPE html>
        <html lang="en">
        <head><title>The realtime preemption endgame [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/345076/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/344261/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/345076/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The realtime preemption endgame</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 5, 2009</br>
           </div>
There has been relatively little noise out of the realtime preemption camp
in recent months.  That does not mean that the realtime developers have
been idle, though; instead, they are preparing for the realtime endgame:
the merger of the bulk of the remaining patches into the mainline kernel.
The <a href="http://lwn.net/Articles/344439/">2.6.31-rc4-rt1 tree</a>
recently announced by Thomas Gleixner shows the results of much of this
work.  This article will look at some of the recent changes to -rt.

<p>
The point of the realtime preemption project is to enable a general-purpose
Linux kernel to provide deterministic response times to high-priority
processes.  "Realtime" does not (necessarily) mean "fast"; it means knowing
for sure that the system can respond to important events within a specific
time period.  It has often been said that this cannot be done, that the
complexity of a full operating system would thwart any attempt to guarantee
bounded response times.  Of course, it was also said that free software
developers could never create a full operating system in the first place.
The realtime hackers believe that both claims are equally false, and they
have been working to prove it.

<p>
One of the long-term realtime features was threaded interrupt handlers.  A
"hard" interrupt handler can monopolize the CPU for as long as it runs;
that can create latencies for other users.  Moving interrupt handlers into
their own threads, instead, allows them to be scheduled like any other
process on the system.  Thus, threaded interrupt handlers cannot get in the
way of higher-priority processes.
<p>

Much of the threaded interrupt handling code moved into the mainline for
the 2.6.30 release, but in a 
somewhat different form.  While the threading of interrupt handlers is
nearly universal in a realtime kernel, it's an optional (and, thus far,
little-used) feature in the mainline, so the APIs had to change somewhat.
Realtime interrupt handling has been reworked on top of the mainline
threaded interrupt mechanism, but it still has its own twists.
<p>
In particular, the kernel can still be configured to force all interrupt
handlers into threads.  If a given driver explicitly requests a threaded
handler, behavior is similar to a non-realtime kernel; the driver's "hard"
interrupt handler runs as usual in IRQ context.  Drivers which do not
request threaded handlers get one anyway, with a special hard handler which
masks the interrupt line while the driver's handler runs.  Interrupt
handler threads are per-device now (rather than per-IRQ line).  All told,
the amount of code which is specific to the realtime tree is fairly small
now; the bulk of it is in the mainline.
<p>
Software interrupt handling is somewhat different in the realtime tree.
Mainline kernels will normally handle software interrupts at convenient
moments - context switches or when returning to user space from a system
call, usually.  If the software interrupt load gets too heavy, though, handling will
be deferred to the per-CPU "ksoftirqd" thread.  In the realtime tree
(subject to a configuration option), all software interrupt handling goes
into ksoftirqd - but now there is a separate thread for each interrupt
line.  So each CPU will get a couple of ksoftirqd threads for network
processing, one for the block subsystem, one for RCU, one for tasklets, and
so on.  Software interrupts are also preemptable, though that may not
happen very often; they run at realtime priority.
<p>

The work which first kicked off the realtime preemption tree was the
replacement of spinlocks with sleeping mutexes.  The spinlock technique is
difficult to square with deterministic latencies; any processor which is
spinning on a lock will wait an arbitrary period of time, depending on what
code in another CPU is doing.  Code holding spinlocks also cannot be
preempted; doing so would cause serious latencies (at best) or deadlocks.
So the goal of ensuring bounded response times required the elimination of
spinlocks to the greatest extent possible.
<p>
Replacing spinlocks throughout the kernel with realtime mutexes solves much
of the problem.  Threads waiting for a mutex will sleep, freeing the
processor for some other task.  Threads holding mutexes can be preempted if
a higher-priority process comes along.  So, if the priorities have been set
properly, there should be little in the way of the highest-priority process
being able to respond to events at any time.  This is the core idea behind
the entire realtime preemption concept.
<p>
As it happens, though, not all spinlocks can be replaced by mutexes.  At
the lowest levels of the system, there is still a need for true (or "raw")
spinlocks; the locks which are used to implement mutexes are one obvious
example.  Over the years, a fair amount of effort has gone into the task of
figuring out which spinlocks really needed to be "raw" locks.  At the code
level, the difference was papered over through the use of some rather ugly
trickery in the spinlock primitives.  Regardless of whether a raw spinlock
or a sleeping lock was being used, the code would call <tt>spin_lock()</tt>
to acquire it; the only difference was where the lock was declared.
<p>
This approach was probably useful during the early development phases where
it was often necessary to change the type of specific locks.  But ugly
compiler trickery which serves to obfuscate the type of lock being used in
any specific context seems unlikely to fly when it comes to merger into the
mainline.  So the realtime hackers have bitten the bullet and split the two
types of locks entirely.  The replacement of "spinlocks" with mutexes still
happens as before, for the simple reason that changing every spinlock call
would be a massive, disruptive change across the entire kernel code base.
But the "raw" spinlock type, which is used in far fewer places, is more
amenable to this kind of change.
<p>
The result is a new mutual exclusion primitive, called
<tt>atomic_spinlock_t</tt>, which looks a lot like
traditional spinlocks:
<p>
<pre>
    #include &lt;linux/spinlock.h&gt;

    DEFINE_ATOMIC_SPINLOCK(name)
    atomic_spin_lock_init(atomic_spinlock_t *lock);

    void atomic_spin_lock(atomic_spinlock_t *lock);    
    void atomic_spin_lock_irqsave(atomic_spinlock_t *lock, long flags);
    void atomic_spin_lock_irq(atomic_spinlock_t *lock);
    void atomic_spin_lock_bh(atomic_spinlock_t *lock);
    int atomic_spin_trylock(atomic_spinlock_t *lock);    

    void atomic_spin_unlock(atomic_spinlock_t *lock);
    void atomic_spin_unlock_irqrestore(atomic_spinlock_t *lock, long flags);
    void atomic_spin_unlock_irq(atomic_spinlock_t *lock);
    void atomic_spin_unlock_bh(atomic_spinlock_t *lock);
</pre>
<p>

These new "atomic spinlocks" are used in the scheduler, low-level interrupt
handling code, clock-handling, PCI bus management, ACPI subsystem, and in
many other places.  The change is still large and disruptive - but much
less so than changing ordinary "spinlock" users would have been.
<p>
<span class="PullQuote">
<span class="invisible">[PULL QUOTE: </span>
One might argue that putting atomic spinlocks back into the kernel will
reintroduce the same latency problems that the realtime developers are
working to get rid of.
<span class="invisible"> END QUOTE]</span>
</span>


One might argue that putting atomic spinlocks back into the kernel will
reintroduce the same latency problems that the realtime developers are
working to get rid of.  There is certainly a risk of that happening, but it
can be minimized with due care.  Auditing every kernel path which uses
spinlocks is clearly not a feasible task, but it <i>is</i> possible to look
very closely at the (much smaller) number of code paths using atomic
spinlocks.  So there can be a reasonable degree of assurance that the
remaining atomic spinlocks will not cause the kernel to exceed the latency
goals. 

<p>
(As an aside, Thomas Gleixner is <a
href="http://rt.wiki.kernel.org/index.php/Atomic_Spinlock">looking for a
better name</a> for the <tt>atomic_spinlock_t</tt> type.  Suggest the
winning idea, and free beer at the next conference may be your reward.)
<p>
Similar changes have been made to a number of other kernel mutual exclusion
mechanisms.  There is a new <tt>atomic_seqlock_t</tt> variant on <a
href="http://lwn.net/Articles/22818/">seqlocks</a> for cases where the
seqlock writer cannot be preemptable.  The <tt>anon_semaphore</tt> type
mostly appears to be a renaming of semaphores and their related functions;
it is a part of the continuing effort to eliminate the use of semaphores in
any place where a mutex or completion should be used instead.  There is
also a <tt>rw_anon_semaphore</tt> type as a replacement for
<tt>rw_semaphore</tt>. 
<p>

Quite a few other realtime-specific changes remain in the -rt tree.  The
realtime code is incompatible with the SLUB allocator, so only slab is
allowed.  There is also an interesting problem with <tt>kmap_atomic()</tt>;
this function creates a temporary, per-CPU kernel-space address mapping for
a given memory page.  Preemption cannot be allowed to happen when an atomic
kmap is active; it would be possible for other code to change the mapping
before the preempted code tries to use it.  In the realtime setting, the
performance benefits from atomic kmaps are outweighed by the additional
latency they can cause.  So, for all practical purposes,
<tt>kmap_atomic()</tt> does not exist in a realtime kernel; calls to
<tt>kmap_atomic()</tt> are mapped to ordinary <tt>kmap()</tt> calls.  And so
on.

<p>

As for work which is not yet even in the realtime tree, the first priority
would appear to be clear:
<p>
<div class="BigQuote">
	We seriously want to tackle the elimination of the PREEMPT_RT
   	annoyance #1, aka BKL. The Big Kernel Lock is still used in ~330
   	files all across the kernel.
</div>
<p>
At this point, the remaining BKL-removal work comes down to low-level
audits of individual filesystems and drivers; for the most part, it has
been pushed out of the core kernel.
<p>
Beyond that, of course, there is the little task of getting as much of this
code as possible into the mainline kernel.  To that end, a proper git tree
with a bisectable sequence of patches is being prepared, though that work
is not yet complete.  There will also be a gathering of realtime Linux
developers at the <a
href="http://www.osadl.org/RTLWS-2009.rtlws-2009.0.html">Eleventh Real-Time
Linux Workshop</a> this September in Dresden; getting the realtime work
into the mainline is expected to be discussed seriously there.  As it
happens, your editor plans to be in the room; watch this space in late September
for an update.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Atomic_spinlocks">Atomic spinlocks</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Realtime">Realtime</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Spinlocks">Spinlocks</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/345076/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor345359"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 14:20 UTC (Wed)
                               by <b>dankamongmen</b> (subscriber, #35141)
                              [<a href="/Articles/345359/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
heh, this will obsolete some hoary old slide in 95% of all graduate realtime classes for at least a year. people are still talking about select() and poll() in their powerpoints, bah.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345359/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor345362"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">kmap_atomic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 14:48 UTC (Wed)
                               by <b>arjan</b> (subscriber, #36785)
                              [<a href="/Articles/345362/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
turning kmap_atomic into a full kmap sounds a bit overkill, one could do a per cpu kmap like pool, and then pin the task to the cpu for the duration of the kmap... saves the cross-cpu IPIs that kmap_atomic tries to eliminate from kmap...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345362/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345363"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">kmap_atomic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 14:56 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/345363/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      That wouldn't quite do it - you still have to avoid contention for the atomic kmap slots or chaos will result.  That generally implies disabling preemption, which is what they're trying to avoid.  I suppose one could implement some sort of slot-management layer so that one task's KM_USER0 is different from another's, but that sounds messy...
      
          <div class="CommentReplyButton">
            <form action="/Articles/345363/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">kmap_atomic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 17:28 UTC (Wed)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/345403/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So if it were performance-wise feasible to make kmaps local per thread (part <br>
of a thread switch) the whole kmap_atomic and kmap could be folded back <br>
into one implementation?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">kmap_atomic</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2009 16:06 UTC (Thu)
                               by <b>ebiederm</b> (subscriber, #35028)
                              [<a href="/Articles/345690/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just don't allow highmem and RT.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor345375"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 15:44 UTC (Wed)
                               by <b>tertium</b> (guest, #56169)
                              [<a href="/Articles/345375/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Doesn't replacing spinlocks with mutexes cancel a recently discussed idea of adaptive mutexes, which spin while the lock is taken by a running thread?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345375/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 17:40 UTC (Wed)
                               by <b>avik</b> (guest, #704)
                              [<a href="/Articles/345408/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Certainly it makes sense now to switch some spinlocks to mutexes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor345464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 18:49 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/345464/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would argue that replacing spinlocks with mutexes would make things like adaptive mutexes more urgently needed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345466"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 19:09 UTC (Wed)
                               by <b>tertium</b> (guest, #56169)
                              [<a href="/Articles/345466/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I just don't see how the two will co-exist. In an rt-kernel, spinlocks are being replaced with mutexes so that a thread waiting for a lock could be preempted. And with adaptive mutexes, a thread entering a mutex will (in certain circumstances) spin, thus breaking the latency guarantees, if I read the article well. Could you please shed some light on this?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345466/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345493"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 20:39 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/345493/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      Just to make sure I understand, your concern is exemplified by the following sequence of events, right?

<ol>
<li> High-priority task A is initially blocked waiting for something to do.
<li> Low-priority task B acquires a lock.
<li> Medium-priority tasks C, D, E, and so on (one per CPU) start running, preempting task B.
<li> Work arrives for task A, so that it wakes up, preempting one of the medium-priority tasks.
<li> Task A now attempts to acquire the lock held by preempted task B, and spins for awhile (uselessly degrading latency).
<li> Task A finally blocks, which kicks priority inheritance into action, awakening task B, which releases the lock so that task A can acquire it.
</ol>

Or am I missing your point?
      
          <div class="CommentReplyButton">
            <form action="/Articles/345493/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345499"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 21:21 UTC (Wed)
                               by <b>tertium</b> (guest, #56169)
                              [<a href="/Articles/345499/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm imagining a much simpler scenario (for two CPUs):<br>
<p>
1. High-priority task A takes a mutex and runs for some time without going to sleep.<br>
2. Low-priority task B tries to take the mutex and spins, since A is running. This is where we lose latency, because...<br>
3. ...while B spins, it can't be preempted, so a medium-priority task C can't run on either of CPUs, even if there is some work for it.<br>
<p>
I presume, I'm missing something obvious and would be glad to know what it is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345499/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345504"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 21:24 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/345504/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OK, you lost me on this one.  Why can't task B be preempted while spinning?  What am I missing here?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345504/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345508"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 21:43 UTC (Wed)
                               by <b>tertium</b> (guest, #56169)
                              [<a href="/Articles/345508/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was actually looking at the following phrase in the article: "Code holding spinlocks also cannot be preempted; doing so would cause serious latencies (at best) or deadlocks." Am I confused?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345508/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 22:17 UTC (Wed)
                               by <b>tertium</b> (guest, #56169)
                              [<a href="/Articles/345518/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, it seems I am: "code holding a spinlock" != "code spinning". My apologies.<br>
<p>
By the way, in your scenario (if I'm not off the mark again) at the step 5, the task A wouldn't spin, since B isn't running. Instead, A would block immediately, awakening B and taking the lock. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345524"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 22:47 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/345524/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly!  :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345524/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor345863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2009 15:49 UTC (Fri)
                               by <b>dvhart</b> (guest, #19636)
                              [<a href="/Articles/345863/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is indeed a balancing act.  Testing has shown however that spinning for a short while can be preferable to at least 2 additional context switches (figure 25us or so each).  See kernel/rtmutex.c adaptive_wait() for details, but basically we sping until one of the following occurs: we get the lock, the owner changes, or the owner goes to sleep.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor345496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 20:55 UTC (Wed)
                               by <b>glikely</b> (subscriber, #39601)
                              [<a href="/Articles/345496/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From Paragraph 5: "... If a given driver explicitly requests a threaded handler, behavior is similar to a non-realtime kernel; the driver's "hard" interrupt handler runs as usual in IRQ context."<br>
<p>
For those who were confused by this, as I was, this post from tglx may help:<br>
<p>
<a href="http://lwn.net/Articles/324980/">http://lwn.net/Articles/324980/</a><br>
<p>
Drivers which request threaded irq handlers actually register 2 handlers in the call to request_threaded_irq().  The primary or "hard" handler runs at the usual IRQ contex, and it checks if the IRQ originated from the device.  If so it masks out the IRQ at the device level and returns IRQ_WAKE_THREAD.  Then the generic IRQ code can wake the thread that runs the threaded handler.<br>
<p>
In the realtime context, it doesn't make sense to run the "hard" handler in a thread since it is already designed to be low latency and it would just turn around and ask for another thread to be scheduled anyway.  Plus, since the hard handler masks the IRQ at the device level, the generic IRQ code can leave the irq line unmasked so that IRQs from other devices on the same line don't have to get inhibited also.<br>
<p>
Not knowing this background, the paragraph from the article sounded like drivers requesting a threaded handler would get the old non-threaded behaviour.  Hence my confusion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor345498"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The obvious name ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 5, 2009 20:56 UTC (Wed)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/345498/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not going to create an account there just for one suggestion.  If someone submits this and wins a free beer, enjoy!<br>
<p>
The obvious name is raw_spinlock, as opposed to cooked_spinlock.  There ie great UNIX tradition in this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345498/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345610"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The obvious name ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2009 9:28 UTC (Thu)
                               by <b>eliezert</b> (subscriber, #35757)
                              [<a href="/Articles/345610/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would call the busywait spinlocks.<br>
This is what they do, and this will also make it obvious they should be used rarely.<br>
I like your cooked / raw proposal, but I think a name the would discourage unnecessary use would be better. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345610/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345729"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The obvious name ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2009 18:03 UTC (Thu)
                               by <b>cpeterso</b> (guest, #305)
                              [<a href="/Articles/345729/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <code>busywait_spinlock</code> is a great name! It accurately describes its behavior <i>and</i> discourages people from using it (without deep thought).
      
          <div class="CommentReplyButton">
            <form action="/Articles/345729/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor346183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The obvious name ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2009 14:44 UTC (Mon)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/346183/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought atomic_spinlock wasn't too bad, but I like busywait_spinlock.  <br>
<p>
Of course, I do think it would be better to rename the spinlock itself if  it no longer does that.... <br>
<p>
I guess to facilitate the changeover you could have atomic_lock or busywait_lock (spin is a bit redundant) and mutex, and only very old code would need a typdef for the now non existant 'spinlock' type.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/346183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor345777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The obvious name ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2009 0:40 UTC (Fri)
                               by <b>Kamilion</b> (subscriber, #42576)
                              [<a href="/Articles/345777/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Eh, I signed up just to post up "snooze_lock".<br>
Seemed pretty self-explanatory to me. :)<br>
<p>
And there's always the alarm-clock connotation, someone always manages to mash the snooze button.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The obvious name ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2009 1:08 UTC (Fri)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/345781/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But, it's not a snooze lock, it's a spin lock!  A snooze lock would imply that a process goes to sleep and yields the processor.  A spin lock does not yield, it's in fact the opposite of a "sleep" lock.<br>
<p>
If I understand the naming dilemma, the problem is that the old spin_locks which will not be renamed are in fact becoming sleep locks.  If your naming convention is adopted, you would have spin_locks which sleep, and snooze_locks which spin!<br>
<p>
So, raw_spinlock or real_spinlock seem more appropriate to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor346240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The obvious name ...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2009 18:08 UTC (Mon)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/346240/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's incredibly sad if the spinlocks wouldn't get renamed.  Linux already has incredibly badly named things (struct class anyone?) but now it's also getting incapable of making a mass rename due to what - proprietary or out of tree code?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/346240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor345554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2009 3:48 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/345554/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For the BKL stuff, what is needed to get a BKL-removing patch into a mainline driver?<br>
<p>
It seems as though proving thoroughly that the BKL does nothing useful (in some particular driver) is nearly impossible since it interacts so comprehensively with other subsystems, so my first thought was that I should just try removing uses of the BKL from the driver and recompiling. But presumably the LKML would also frown on a patch which says "Drivername: Remove BKL" and offers as justification only the fact that "It works for me".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor345596"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2009 8:06 UTC (Thu)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/345596/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; For the BKL stuff, what is needed to get a BKL-removing patch into a mainline driver?</font><br>
<p>
You're expected to carefully review interactions with other subsystems, locking within the driver, identify things relying on the BLK (often it's very little or nothing) and then remove/replace the BLK usage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345596/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor345622"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2009 10:07 UTC (Thu)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/345622/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But presumably the LKML would also frown on a patch which says "Drivername: Remove BKL" and offers as justification only the fact that "It works for me".</font><br>
<p>
If you just remove any locking from a driver, it will most likely just work as before. Locking usually is not such a critical thing in a driver that it immediately breaks things.<br>
_But_ it will introduce silent cornercase breakages that you will probably only notice weeks later when some weird coincidence happens.<br>
So you'd better make sure you _do_ understand the locking requirements before removing the BKL from a driver.<br>
Removing the BKL from part of the code requires deep understanding of that code and its interactions with other BKL holders(!). That is the actual problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/345622/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor346177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">name games</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2009 13:57 UTC (Mon)
                               by <b>tridge</b> (guest, #26906)
                              [<a href="/Articles/346177/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What about strangle_lock() - it strangles the CPU for the time it holds<br>
the lock. It should also discourage use :-)<br>
<p>
Or grid_lock() ? Too much grid lock and nobody gets to move.<br>
<p>
Finally, flint_lock(), because it's very primitive :-)<br>
<p>
Cheers, Tridge<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/346177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor347439"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 17, 2009 20:57 UTC (Mon)
                               by <b>trasz</b> (guest, #45786)
                              [<a href="/Articles/347439/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great to see Linux finally doing what FreeBSD done a decade ago - real mutexes, interrupt threads etc.  Except that in FreeBSD - just like in OSX or Solaris - this is the default behaviour.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/347439/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor368808"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The realtime preemption endgame</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 6, 2010 11:37 UTC (Wed)
                               by <b>Kraftman</b> (guest, #62833)
                              [<a href="/Articles/368808/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great, but those are just their imaginary "advantages". Don't forget about Freebsd lock limitations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/368808/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor349749"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Major features wating to be merged</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2009 10:15 UTC (Sat)
                               by <b>YannisDas</b> (guest, #60144)
                              [<a href="/Articles/349749/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An interesting idea for an article would be an overview of the major or not so major features/drivers/whatsoever yet unmerged to the mainline. Stuff like realtime, reiser4 etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/349749/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
