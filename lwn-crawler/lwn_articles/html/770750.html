        <!DOCTYPE html>
        <html lang="en">
        <head><title>Zinc: a new kernel cryptography API [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/770750/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/770568/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/770750/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Zinc: a new kernel cryptography API</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="GAByline">
           <p>November 6, 2018</p>
           <p>This article was contributed by Tom Yates</p>
           <hr>
<a href="/Archives/ConferenceByYear/#2018-Kernel_Recipes">Kernel Recipes</a>
</div>
<p>
We <a href="/Articles/761939/">looked at</a>
the <a href="https://www.wireguard.com/">WireGuard</a> virtual private
network (VPN)
back in August and noted that it is built on top of a new
cryptographic API being developed for the kernel, which is called
Zinc.   There has been some <a
href="/Articles/765965/">controversy</a> about Zinc and why a brand new 
API was needed when the kernel already has an extensive crypto API.  A <a
href="https://kernel-recipes.org/en/2018/talks/zinc-minimal-lightweight-kernel-cryptography-api/">recent
talk</a> by lead WireGuard developer Jason Donenfeld at  <a href="https://kernel-recipes.org/en/2018/">Kernel 
Recipes 2018</a> would appear to be a serious attempt to reach out, engage
with that question, and explain the what, how, and why of Zinc.

<p>
WireGuard itself is small and, <a
href="/ml/linux-kernel/CA+55aFz5EWE9OTbzDoMfsY2ez04Qv9eg0KQhwKfyJY0vFvoD3g@mail.gmail.com/">according
to Linus Torvalds</a>, a work of 
art.  Two of its stated objectives are maximal simplicity and high
auditability.  Donenfeld initially did try to implement WireGuard using
the existing kernel cryptography API, but after trying to do so, he found
it impossible to do in any sane way.  That led him to question whether
it was even possible to meet those objectives using the existing API.</p>

<img src="https://static.lwn.net/images/2018/kr-donenfeld-tux.jpg" align="left"
alt="[Tux and ECB mode]" title="Tux and ECB mode" width=323 height=196>

<p>
By way of a case study, he considered <a
href="https://elixir.bootlin.com/linux/v4.19.1/source/security/keys/big_key.c"><tt>big_key.c</tt></a>.
This is kernel code that is designed to take a key, store 
it encrypted on disk, and then return the key to someone asking
for it 
if they are allowed to have access to it.
Donenfeld had taken a look at it, and found that the
crypto was totally broken.  For a start, it used ciphers in <a
href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#ECB">Electronic
Codebook</a> (ECB) mode, which is known to leave gross structure in
ciphertext &mdash; the encrypted image of Tux on the left may still
contain data perceptible to your eye &mdash; and so is not recommended for
any serious cryptographic use.  Furthermore, according to Donenfeld,
it was missing authentication
tags (allowing ciphertext to be undetectably modified), it didn't zero
keys out of memory after use, and it didn't use its sources of randomness
correctly; there were many CVEs associated with it.  So he set out to
rewrite it using the crypto API, hoping to better learn
the API with a view to using it for WireGuard.</p>

<p>
The first step with the existing API is to allocate an instance of a cipher
"object".  The syntax for so doing is arguably confusing &mdash;
for example, you pass the argument <tt>CRYPTO_ALG_ASYNC</tt> to
indicate that you <i>don't</i> want the instance to be asynchronous.
When you've got it set up and want to encrypt something, you can't
simply pass data by address. You must use scatter/gather to pass it, which
 in turn means that data in the <tt>vmalloc()</tt> area or on the stack
 can't just be encrypted with this API.  The key 
you're using ends up attached not to the object you just allocated,
but to the global instance of the algorithm in question, so if you want
to set the key you must take a mutex lock before doing so, in order to
be sure that someone else isn't changing the key underneath you at the
same time.  This complexity has an associated resource cost: the
memory requirements for a single key can approach a megabyte, and some
platforms just can't spare that much.  Normally one would use
<tt>kvalloc()</tt> to 
get around this, but the crypto API doesn't permit it.  Although this
was <a href="https://patchwork.kernel.org/patch/10223869/">eventually
addressed</a>, the fix was not trivial.</p>

<a href="/Articles/770760/">
<img src="https://static.lwn.net/images/2018/kr-donenfeld-sm.jpg" border=0 hspace=5 align="right"
alt="[Jason Donenfeld]" title="Jason Donenfeld" width=211 height=300>
</a>

<p>
So Donenfeld's experiences left him convinced that although the
current crypto API has "definitely been developed by some smart
people who can really code [...] who can really push the limits of
what we're used to in C", it is a big, fancy enterprise API that is
hard to use, which means that people often use it wrong.  It's also,
he said, a museum of ciphers.  Primitives and their multiple
implementations lie stacked about the place, some getting quite dusty —
<a href="https://en.wikipedia.org/wiki/MD4">MD4</a> is still in there, for
example. 
It's hard to tell who wrote any given implementation, or whether it has
been formally verified or how widely used it is, which makes it hard to
know what's reliable.  He has a strong preference for formally verified
code.  Failing that, he prefers code that is in widespread use and
has received a lot of scrutiny, noting that these are often the fastest
implementations as well.  And failing that, he prefers code based on the
reference implementations.

<p>
So Zinc's approach, and this is where feathers started to get
ruffled, is not to be an API at all; it's just
functions.  Donenfeld argues that functions are well-understood in C,
and people know about and are comfortable with them.  Zinc is aiming
for high-speed and high-assurance; these are easier goals to
achieve without a big API, as is formal verification.  Moreover,
"tons of code" has already leaked out of the kernel and into
<tt>lib/</tt>; it's clear that programmers want functions and Zinc is
prepared to provide them in a non-haphazard way.

<p>
As for formal verification, there are apparently several
teams working on that for crypto code, including MIT's <a
href="https://github.com/mit-plv/fiat-crypto">fiat-crypto</a> project and
INRIA's <A href="https://github.com/project-everest/hacl-star">HACL*</a>.
The latter project takes the approach of modeling the algorithm in
<a href="https://www.fstar-lang.org/">F*</a> and proving the model
correct, which F* is designed to optimize.  Then — in a term of art
which never fails to make me think of Arnold Schwarzenegger's Terminator
descending into a bath of molten metal — the model is "lowered into" C
(or in some cases, all the way into assembly language).  According to
Donenfeld, this produces C which, though slightly non-idiomatic,
is surprisingly readable, and much more likely to be bug-free
than human-written code.  It also produces some of the fastest C
implementations that exist, which he suspects is because the
formal verification process removes certain things that are not obviously
removable when you're working the mathematics out by hand.
In addition to using formal verification, all Zinc code has been, and will
continue to be, heavily 
<a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzed</a>.

<p>
Donenfeld has been working with the INRIA team to get as much as possible
of their work into Zinc, and is trying generally to improve relations
between the kernel community and academic cryptographers.  He feels
that the people who design cryptographic primitives, and their hordes
of capable graduate students, generally don't come anywhere near kernel
development, and that it's our loss.

<p>
Cryptographic primitives in Zinc are organized differently than the
current API.  Code is organized by the name of the cipher; for example,
the <a
href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant">ChaCha20</a>
cipher lives under <tt>lib/zinc/chacha20/</tt>, where
you can find the generic C implementation <tt>chacha20.c</tt> as well as
architecture-specific assembly versions including <tt>chacha20-arm.S</tt>
and <tt>chacha20-x86_64.S</tt>.  Donenfeld feels this invites contribution in an
approachable and manageable way.  It also allows architecture
implementation selection not via function pointers but by compiler
inlining, "which makes things super fast" &mdash; and the absence of
function pointers means no retpoline-induced slowdowns.

<p>
Zinc currently implements the ChaCha20 stream cipher, the <a
href="https://en.wikipedia.org/wiki/Poly1305">Poly1305</a>
message authentication code (MAC), the <a
href="https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2">Blake
2s</a> hash function, and <a
href="https://en.wikipedia.org/wiki/Curve25519">Curve25519</a>
for elliptic-curve cryptography.  This is a long way from a complete
replacement of the current API; it's essentially just what WireGuard uses.
But Donenfeld and Samuel Neves have started the work of refactoring the
existing crypto API to use Zinc functions under the hood.
He also tried re-implementing <tt>big_key.c</tt> in Zinc, which ended up
removing over 200 
lines of  
a 500-line file and replacing them with 28 lines of new code.

<p>
Some of the current API will not be so easily refactored.  One question
from the floor asked about handling asynchronous callback for hardware
crypto accelerators, which are important in lower-power CPU environments
such as some ARM chips.  Donenfeld's response was that he didn't like the
idea of "polluting" the Zinc API by evolving it to handle asynchronous
callback. He said that it would be better to build a layer on top of Zinc
that either invoked Zinc for in-CPU crypto or handed the request out to
the external hardware, which essentially dodges the question.  It does
appear that he has some clear views about how people should use crypto;
uses that don't fit into those views aren't really his top priority.

<p>
Two easier questions related to naming and to learning opportunities.  As
to the former, Zinc apparently now stands for "Zinc Is Nice Cryptography";
the suggestion it might stand for "Zinc Is Not a CryptoAPI" elicited some
laughter.  The name also fits with the elemental naming scheme used in crypto
projects like <a href="https://download.libsodium.org/doc/">Sodium</a>
and <a href="https://github.com/jedisct1/libchloride">libchloride</a>.
The other question was motivated by the questioner finding it
increasingly difficult to know how to respond to requests for a good
place for beginners to get started with kernel work.  Donenfeld felt
that Zinc may not be a great place to start contributing, but that the
nature of the code and the tasks it performs &mdash; it's pure C, it
takes in data, modifies it, and writes it out &mdash; makes it a
great place to start reading and understanding.

<p>
Although his frustration with Zinc's reception by the kernel
community occasionally leaked through, it's clear that Donenfeld has
learned from 
the response to his initial 24,000-line patch.  Talks like this are
part of the outreach.  But the process is made easier by the legitimate
criticisms he makes of the current API and that, even though Zinc doesn't
do everything the crypto API currently does, what it does do it does
really well.  I suspect that, in some form not yet determined, we
will all benefit from this work for some time
to come.

<p>
[We would like to thank LWN's travel sponsor, The Linux Foundation, for assistance with travel funding for Kernel Recipes.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Cryptography">Cryptography</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Cryptography">Cryptography</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-Virtual_private_network_VPN">Linux kernel/Virtual private network (VPN)</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Yates_Tom">Yates, Tom</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Kernel_Recipes-2018">Kernel Recipes/2018</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/770750/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor770873"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Names</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2018 19:54 UTC (Tue)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/770873/">Link</a>] 
      </p>
      
      </div>
      </summary>
      So on LWN in the past few weeks we've had Zinc, <a href="https://lwn.net/Articles/770390/">Zink</a>, and <a href="https://lwn.net/Articles/768486/">Zeek</a>.  Do they co-ordinate the names?
      
          <div class="CommentReplyButton">
            <form action="/Articles/770873/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor770892"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2018 23:35 UTC (Tue)
                               by <b>bferrell</b> (subscriber, #624)
                              [<a href="/Articles/770892/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Portability is a big concern for me.  Because this is kernel code, I see an issue with widespread deployment.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770892/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor770926"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 15:25 UTC (Wed)
                               by <b>adam820</b> (subscriber, #101353)
                              [<a href="/Articles/770926/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Portability of...?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770926/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor770968"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 16:03 UTC (Wed)
                               by <b>bferrell</b> (subscriber, #624)
                              [<a href="/Articles/770968/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
VPNs in particular.  Crypto isn't very useful if it only works on frubaz systems and nothing else, even if there ARE a lot of frubaz systems.  Under those circumstances, it becomes an interesting lab rat.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770968/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor771017"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 21:00 UTC (Wed)
                               by <b>johannbg</b> (guest, #65743)
                              [<a href="/Articles/771017/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is nothing wrong with developing spesific application or application stack to take benefit of and be used only for a single OS. <br>
<p>
Those that use other OS or "frubaz systems" as you like to call it, can simply write their own or use something else.<br>
<p>
There is no obligation from upstream to be available on every platform in the existance. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/771017/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor771018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 21:25 UTC (Wed)
                               by <b>dtlin</b> (subscriber, #36537)
                              [<a href="/Articles/771018/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      For Wireguard in particular, this isn't an issue. There is an officially-supported alternate implementation <a href="https://git.zx2c4.com/wireguard-go/about/">wireguard-go</a> which works on macos, BSD, <a href="https://git.zx2c4.com/wireguard-ios/about/">iOS</a>, and <a href="https://git.zx2c4.com/wireguard-android/about/">Android</a>. (There exists a protocol-compatible closed-source implementation for Windows, but <a href="https://lists.zx2c4.com/pipermail/wireguard/2018-March/002448.html">ZX2C4 recommends against it</a>.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/771018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor771027"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 21:34 UTC (Wed)
                               by <b>bferrell</b> (subscriber, #624)
                              [<a href="/Articles/771027/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks!<br>
<p>
I went hunting and it's exactly what I didn't find.<br>
<p>
That takes care of that!  Even if the page DOES say in effect "don't drink me"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/771027/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor771069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Faster in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2018 10:45 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/771069/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
WireGuard's big claim (which I cannot vouch for) is that it's very _fast_<br>
<p>
To be as _fast_ as it can it is implemented as a kernel module, since obviously the kernel is much better able to consume an incoming packet, decrypt it, and spit the plaintext packet out of another interface quickly than a userspace implementation.<br>
<p>
But so far as I know WireGuard does not claim "but very slow in, like, userspace". If you use a userspace solution like OpenVPN, or most portable VPN solutions today I would be surprised if the userspace version of WireGuard is slower, indeed my guess would be that it's still faster, just not enough to make people as excited as they are about the kernel module.<br>
<p>
WireGuard has some other properties that you may find attractive (I think some of them are a bad idea, but they were done on purpose by smart people and I may yet be proved quite wrong) and for those it doesn't matter whether it's implemented in the kernel, so if these give you a boner then you don't need to care about kernel modules you should download the Go implementation for your BeOS machine or whatever (does Go run on BeOS? Maybe not)<br>
<p>
- Like SSH it doesn't come with any actual PKI or anything like that. So this makes it very easy to get started (make key pairs, copy-paste the public keys)<br>
- The crypto is from this century not last century, out of the box, no need to research obscure configuration settings like "dont-use-rot13-encryption" and "allowed-key-size=4096".<br>
- Everything except correctly encrypted messages is ignored. So it's completely invisible to bad guys, this makes your fourteen step SSH port knocking script look like child's play.<br>
- If you're scared about Quantum Computers it has some shared key shenanigans that might in theory save your backside (and doesn't make things worse if, as seems more likely, this is never important at all).<br>
- It's a peer-oriented system, no designated "servers" are needed, although obviously if you want to use it as a normal VPN you will probably ensure a "server" is everybody else's peer.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/771069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor770896"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 0:28 UTC (Wed)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/770896/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What does "not an API at all; it's just functions" mean?  Isn't an Application Programming Interface the name we use to describe the function signatures of the functions we expect applications to use to call our code?<br>
<p>
I'm guessing that he means that the design isn't using some opaque state object that needs to be initialized and configured first, and that's lovely, but having one of those isn't a necessary part of being an "API", as far as I know.<br>
<p>
Also: crypto off-load "engines" aren't just for phones, and aren't (I suspect) going away.  If your "not an API" can't use them, then there will be grief sooner or later, I suspect.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770896/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor770901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 2:45 UTC (Wed)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/770901/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think you're wrong.  Still, when I hear "API" I think of a ball of poo with parts that are poorly co-ordinated, opaque objecty things with no clear meaning, and things like close() or shutdown() functions that when you read them you find out do nothing.  Oh and with some kind of error struct with 3 items all of which are numbers, none of which are documented outside the source code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor770905"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 2:54 UTC (Wed)
                               by <b>pj</b> (subscriber, #4506)
                              [<a href="/Articles/770905/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Don't guess. Check out the <a href="https://www.kernel.org/doc/html/v4.17/crypto/index.html">4.17 Crypto API docs</a> in all their glory... and see what you think.
      
          <div class="CommentReplyButton">
            <form action="/Articles/770905/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor770909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 4:15 UTC (Wed)
                               by <b>robert.cohen@anu.edu.au</b> (subscriber, #6281)
                              [<a href="/Articles/770909/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is an example of an API and yes it contains opaque blobs.<br>
<p>
But that doesnt mean that all API's have to contain opaque blobs.<br>
<p>
I would agree that the set of mechanisms that are used to programatically access the functionality of a package are the API of the package.<br>
<p>
Just because there are many bad complicated API's out there doesnt mean all API's have to be confusing and complicated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor770907"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 4:15 UTC (Wed)
                               by <b>WolfWings</b> (subscriber, #56790)
                              [<a href="/Articles/770907/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I mean for doing one-off encryption tasks with fixed blocks of data, or PBKDF2? The existing Linux Crypto API is pretty easy to use for that.<br>
<p>
There's no scatter-gather needed or anything beyond basic socket handling (socket, bind, setsockopt, accept, write/sendto, read/recvfrom) but it's half the speed or slower than other approaches due to all the resulting syscalls in testing PBKDF2 for example, versus a standalone library. Upside? It's &lt;800 bytes compiled for a full PBKDF2 implementation w/ proper error checking and fail-out.<br>
<p>
But for a constant-stream-of-data system like a VPN or if you're trying to go As Fast As Possible? Yeah, it's sucky complexity once you hit using the scatter-gather functions instead or try to gin things up with zero-copy.<br>
<p>
The existing kernel crypto API is meant to avoid having to roll your own libraries, and get faster versions if they're available, but it's got a lot of fixed overhead either in code complexity to make it scream, or syscall count if you don't care about speed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770907/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor770910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 4:28 UTC (Wed)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/770910/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Full disclosure, when I wrote that, I  was thinking of various corporate "REST" apis that are anything but REST, overly complicated java libraries that resort to XML to "simplify", and OpenSSL.  It wasn't really meant as a comment on anything directly related, whether apropos or not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor770992"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 17:20 UTC (Wed)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/770992/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
API has a technical meaning: Application programming interface.  This can be anything. Eg open, close, read, write, lseek, ftruncate are the basic UNIX file access API and they're all "just functions". There' also "an API" for network configuration which is build on top of AF_NETLINK sockets which is a rather different animal (and not a particularly cute or pretty one).<br>
<p>
API is also a marketing term. Then, it means "we do stuff on the web and we're so absoluetely MODERN! that we won't even know what until next week!"  (presumably, this usage is meanwhile somewhat dated).<br>
<p>
:-&gt;<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770992/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor771014"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 20:44 UTC (Wed)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/771014/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm having trouble relating this comment to mine.  I described my personal associations for the term, and you seem to be defining the term.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/771014/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor770923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 15:16 UTC (Wed)
                               by <b>mageta</b> (subscriber, #89696)
                              [<a href="/Articles/770923/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
He seem confused about this himself:<br>
<p>
<font class="QuotedText">&gt; So Zinc's approach, ..., is not to be an API at all ...</font><br>
<font class="QuotedText">&gt; ...</font><br>
<font class="QuotedText">&gt; Donenfeld's response was that he didn't like the idea of "polluting" the Zinc API ...</font><br>
<p>
I don't completely understand what the phobia with the acronym API is all of a sudden?! Is this a thing now? People not wanting to use something because its called an API?<br>
<p>
<p>
Coming from s390 I also disagree with the notion that Crypt-Offloading is something only for Android. Offloading is also done one the "opposite" of the spectrum, and isn't going to go anywhere. Building something on top of Zinc to handle that will help exactly how, if the rest of the world calls Zinc functions and not your stuff on top?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor770994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 7, 2018 18:01 UTC (Wed)
                               by <b>drag</b> (guest, #31333)
                              [<a href="/Articles/770994/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am guess that 'API' means something more specific and formal in the context of the kernel.   The second quote then was him making a mistake and slipping back to the more generic meaning.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/770994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor771058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2018 6:53 UTC (Thu)
                               by <b>cyphar</b> (subscriber, #110703)
                              [<a href="/Articles/771058/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would recommend that everyone in this thread who is confused go and watch the Kernel Recipes talk[1], where he explains in quite a bit of depth what he means by "API" (which I agree is not the best way of phrasing what the problem is with the API). This information is actually given in the article, though it is given in quite a dense paragraph that you might miss it:<br>
<p>
<font class="QuotedText">&gt; The first step with the existing API is to allocate an instance of a cipher "object". [...]</font><br>
<p>
The short version is that the current crypto API is very abstracted and "enterprisey" in how it works. Here is an incomplete list of problems and confusing behaviour from what I understand: <br>
<p>
  * In order to specify an algorithm there's a weird meta-language that is parsed -- stuff like "gcm(aes)" to represent AES-GCM.<br>
  * You need to use scatter-gather even for encrypting a single buffer -- meaning you can't use stack values.<br>
  * Additional data is apparently stored in the same buffer as the plaintext-to-be-encrypted.<br>
  * You need to allocate memory each time you want to encrypt something, and once per-key.<br>
  * Keys are global -- despite there being an object you are dealing with -- and thus you need to take a mutex if you want to change what key you're using or allocate a new encryption context for each key.<br>
  * In order to use the API synchronously you need to pass the flag CRYPTO_ALG_ASYNC!<br>
  * Many internals of the crypto API have slowly leaked to lib/ because people want to use the crypto but don't want to use the crypto API.<br>
<p>
I'm not familiar with using the crypto API at all, but if even half of these are significantly true then I agree with Donenfeld that this API really has a lot of problems. I'm sure the reason it's so complicated and convoluted is because of crypto hardware off-load requirements -- but that doesn't mean that everything in the kernel should be forced to go through these hoops if hardware off-load is not actually useful for their usecase.<br>
<p>
Zinc is literally just a bunch of functions, which form an API, but is not in any way abstracted like the crypto API. Donenfeld specifically says that this is not a new idea, it's just taking an already existing idea and putting it in the kernel (just use functions, forget abstracting away different crypto implementations).<br>
<p>
[1]: <a href="https://kernel-recipes.org/en/2018/talks/zinc-minimal-lightweight-kernel-cryptography-api/">https://kernel-recipes.org/en/2018/talks/zinc-minimal-lig...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/771058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor771062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2018 8:57 UTC (Thu)
                               by <b>nhippi</b> (subscriber, #34640)
                              [<a href="/Articles/771062/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the word API is misused here. I think what he is arguing is that midlayers are bad and helper functions are good.<br>
<p>
The problem with midlayers being that you have to buy into them wholesale. If the framework doesn't fit your usecase, you have to either workaround it or get hooks implemented in the midlayer. And since it's a common layer, you can't just implement the hook *you* need - you need to negotiate with the midlayer maintainer a version that supports all hypothetical future use scenarios.<br>
<p>
In the helper world, the API is just helper functions you can use, and if the helpers are not helpful for you, you just write your own function instead. <br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/771062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor809129"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2020 22:03 UTC (Thu)
                               by <b>zimaalsu</b> (guest, #136573)
                              [<a href="/Articles/809129/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Whats the differences from easync and other?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/809129/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor771086"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2018 12:24 UTC (Thu)
                               by <b>gby</b> (guest, #23264)
                              [<a href="/Articles/771086/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While I wholeheartedly sympathize with the observation that the Linux crypto API has much room for improvement (CRYPTO_ALG_ASYNC indeed - and the documentation is certainly in need for some work)  and I'm working on making it better (<a href="https://www.redhat.com/archives/dm-devel/2017-October/msg00130.html">https://www.redhat.com/archives/dm-devel/2017-October/msg...</a>), some of the things stated in the article about that API are not accurate, or at the very least, seem to indicate a lack of understanding about the reasoning behind them.<br>
<p>
For example: "The key you're using ends up attached not to the object you just allocated, but to the global instance of the algorithm in question, so if you want to set the key you must take a mutex lock before doing so, in order to be sure that someone else isn't changing the key underneath you at the same time."<br>
<p>
This is incorrect. The key is indeed associated with a transformation object, analogous to a security session and usually refereed to as tfm for short, while actual encryption/decryption is done on a request object, which is derived from a transformation object. However, this transformation object is NOT a singleton. You can have as many of them as you like and, should you wish, can have a 1:1 association between a transformation and a request, and therefore have no need for a mutex or other locking arrangement. <br>
<p>
The reason for this arrangement becomes obvious, by the way, once you consider a protocol such as IPsec, where a single session, which uses a specific key, may have several outstanding independent requests associated with it, corresponding to different IPsec packets.<br>
<p>
In a similar way, the statement  "When you've got it set up and want to encrypt something, you can't simply pass data by address. You must use scatter/gather to pass it, which in turn means that data in the vmalloc() area or on the stack can't just be encrypted with this API. " misses the mark, because it fails to note WHY this is the case - some of the encryption transformation providers in the kernel are hardware based and use DMA to access the memory to be operated on. Performing DMA to/from memory obtained from stack area is a bad idea and will not work.  At the same time, it is possible to feed the crypto API memory obtained from vmalloc() - but it needs to be done with care (for example - <a href="https://patchwork.kernel.org/patch/10573051/">https://patchwork.kernel.org/patch/10573051/</a>).<br>
<p>
Once again, the reason is that some of the transformation providers are HW elements that access the data via DMA. In fact, the Linux Crypto API used to have a separate API that allowed you to provide simple pointers to virtually addressed memory (blkcipher) and this interface was deprecated and removed. <br>
<p>
Furthermore, these HW based transformation providers do more than simply provide "acceleration" - some of them (such as the one included in s390 and Arm CryptoCell of which driver I am the maintainer of) allow the decryption and encryption of data where the actual keys are sealed in hardware and therefore are significantly more difficult to steal, even in the face of a security breach - a capability that is even more important in these days of Spectre and Meltdown, than ever before. <br>
<p>
In summary, the Linux Crypto API does need some tender love and care and the work and feedback from brilliant people such as Jason Donenfeld is highly appreciated. However, when doing so it is critical to understand why the API looks the way it does. Otherwise, you may end up either missing lessons learned in the past.<br>
<p>
Cheers,<br>
Gilad Ben-Yossef &lt;gilad@benyossef.com&gt;<br>
<p>
<p>
 <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/771086/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor771089"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Zinc: a new kernel cryptography API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2018 12:26 UTC (Thu)
                               by <b>gby</b> (guest, #23264)
                              [<a href="/Articles/771089/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, something I forgot to mention above - WireGuard is really cool :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/771089/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
