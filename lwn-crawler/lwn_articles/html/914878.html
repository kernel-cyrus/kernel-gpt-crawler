        <!DOCTYPE html>
        <html lang="en">
        <head><title>Averting excessive oopses [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/914878/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/915255/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/914878/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Averting excessive oopses</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>November 18, 2022</br>
           </div>
Even a single kernel oops is never a good thing; it is an indication that something has
gone badly wrong in the system somewhere and a straightforward
recovery is not possible.  But it seems that oopsing a large number
of times has the potential to be even worse.  To head off problems that
might result from repeated oopsing, there
is currently work afoot to put an upper limit on the number of times that
the kernel can be allowed to oops before just giving up and rebooting.
<p>
An oops in the kernel is the equivalent of a crash in user space.  It can
come about for a number of reasons, including dereferencing a stray
pointer, hardware problems, or a bug detected by checks within the kernel code itself.
The normal response to an oops is to output a bunch of diagnostic
information to the system log and kill the process that was running when
the problem occurred.
<p>
The system as a whole, however, will continue on
after an oops if at all possible.  Killing the system would deprive the
users of the ability to save any outstanding work and can also make
problems much harder to debug than they would otherwise be.  So the kernel
will do its best to continue executing even when something has clearly gone
badly wrong.
An immediate result of that design decision is that any given system can
oops more than once.  Indeed, for some types of problems, multiple oopses
are common and may continue until somebody gets fed up and reboots the
system.
<p>
Jann Horn recently started to wonder whether perhaps the kernel should just
give up and go into a panic (which will cause a reboot) if it oopses too
many times.  This could be a wise course of action in general; a kernel
that is oopsing frequently is clearly not in a good condition and allowing
it to continue could lead to problems like data corruption.  But Horn had
another concern: oopsing a 
system enough times might be a way to exploit security problems.
<p>
An oops, almost by definition, will leave an operation halfway completed;
there is usually no way to clean up everything that might need cleaning
when something has gone wrong in an unexpected place.  So an oops might
cause locks to be left in a held state or might lead to the failure to
decrement counters that have been
incremented.  Counters are a particular concern; if an oops causes a
counter to not be properly decremented, oopsing repeatedly  might well become a
way to overflow that counter, creating an exploitable situation.
<p>
To thwart attacks of this type, Horn wrote <a
href="/ml/linux-kernel/20221107201317.324457-1-jannh@google.com/">a
patch</a> putting an upper limit on the number of times the system can oops
before it simply calls <tt>panic()</tt> and reboots.  The limit was set
to 10,000, but can be changed with the <tt>oops_limit</tt> command-line
parameter.
<p>
One might well wonder whether oopsing the kernel repeatedly is a realistic
way to exploit a kernel 
vulnerability.  A kernel oops takes a bit of time, depending on a number of
factors including the amount of data to be logged and the speed of the
console device(s).  The development community has put a vast amount of
effort into optimizing many parts of the kernel, but speeding up oops
handling has somehow never been a priority.  
To determine how long handling an oops takes, Horn wrote a special sort of
benchmark:
<p>
<blockquote class="bq">
	In a quick single-threaded benchmark, it looks like oopsing in a
	vfork() child with a very short stack trace only takes ~510
	microseconds per run when a graphical console is active; but
	switching to a text console that oopses are printed to slows it
	down around 87x, to ~45 milliseconds per run.
</blockquote>
<p>
Based on that, he concluded that it would take between eight and 12 days of
constant oopsing, in the best of conditions, to overflow a 32-bit counter
that was incremented once for each
oops.  So it is not the quickest path toward a system exploit; it is also
not the most discreet: "<q>this is a *very* noisy and violent approach to
exploiting the kernel</q>".  While there are almost certainly systems out there
that can oops continuously for over a week without anybody noticing, they
are probably relatively rare.
<p>
Even so, nobody seemed opposed to putting an upper limit on the number of
oopses any given kernel can be expected to endure.  Nobody even really felt
the need to argue over the 10,000 number, though Linus Torvalds did <a
href="/ml/linux-kernel/CAHk-=wjejeg+mymJQYzjc=TeMkGkcOLTgKg4FY4tz4ueYdMsGQ@mail.gmail.com/">note
in passing</a> that he would have preferred a higher limit.  Alexander
"Solar Designer" Peslyak <a
href="/ml/linux-kernel/20221107211440.GA4233@openwall.com/">suggested</a>
that, rather than creating a separate command-line parameter, Horn could
just turn the existing <tt>panic_on_oops</tt> boolean parameter into an
integer and use that.  That idea didn't get too far, though, due to the
number of places in the kernel that check that parameter and use it to
modify their behavior now.
<p>
A few days later, Kees Cook posted <a
href="/ml/linux-kernel/20221109194404.gonna.558-kees@kernel.org/">an
updated version</a> of the patch (<a
href="/ml/linux-kernel/20221117233838.give.484-kees@kernel.org/">since
revised</a>), turning it into a six-part series.  The
behavior implemented by Horn remained unchanged, but there have been some
additions, starting with a separate count to panic the system if the kernel
emits too many warnings.  Cook also concluded that, since the kernel was
now tracking the number of oopses and warnings, that information could be
provided to user space via sysfs, where it might be useful to monitoring
systems.
<p>
No opposition to this change appears to be in the offing, so
chances are that this patch set will find its way into the 6.2 kernel in
something close to its current form.  Thereafter, no kernel will be forced
to put up with the indignity of constant oopsing for too long and, perhaps, some
clever exploit might even be fended off.  "Don't panic" might be good
advice for galactic hitchhikers, but sometimes it is the right thing for
the kernel to do.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Kernel_hardening">Security/Kernel hardening</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/914878/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor915415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 17:21 UTC (Fri)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/915415/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; While there are almost certainly systems out there that can oops continuously for over a week without anybody noticing, they are probably relatively rare.</span><br>
<p>
We'll soon find out if Twitter had such systems. :-)<br>
<p>
More seriously, 10.000 is gross, oops_limit if implemented should default to a small multiple of "possible" CPUs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915541"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2022 21:07 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/915541/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It depends on how their system is set up. If you use a cattle-not-pets mentality, then you probably have panic_on_oops enabled and some higher-level control plane (such as k8s) is responsible for rescheduling containers onto other available nodes. In that case, this change would not affect you at all, because you're effectively already running with an oops_limit of 1.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915541/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 29, 2022 0:41 UTC (Tue)
                               by <b>jccleaver</b> (subscriber, #127418)
                              [<a href="/Articles/916159/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fleet not cattle. If your boxes have state, data locality, and preferred workloads, then they develop individual quirks. Doesn't mean they have to be babied like your pal Spot, but presuming all wear and tear has been identical forever seems ill-advised.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 29, 2022 11:27 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/916163/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>With a fleet of cattle, as opposed to a fleet of pets, you don't presume that all wear and tear is identical - you have monitoring that measures the state of each machine individually, and handles it. E.g. your monitoring detects that machine 10,994,421 is frequently throwing ECC corrected errors, and it migrates all jobs off that machine and sends it off for repair. Or you detect filesystem corruption, and migrate everything off then send that machine to repair.
<p>The key is that automation handles everything if you have cattle, not pets. Instead of knowing that http10294 is a unique snowflake with certain problems and fixes for problems, you have your automation look at the state of all hardware, and identify and deal with the problems of the machines en-masse.


      
          <div class="CommentReplyButton">
            <form action="/Articles/916163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916207"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 29, 2022 16:14 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/916207/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; With a fleet of cattle, as opposed to a fleet of pets,</span><br>
<p>
Shouldn't that be a hurd?<br>
<p>
(G, D&amp;R)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916207/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor916237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 29, 2022 22:47 UTC (Tue)
                               by <b>jccleaver</b> (subscriber, #127418)
                              [<a href="/Articles/916237/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The key is that automation handles everything if you have cattle, not pets.</span><br>
<p>
At the risk of mixing metaphors further: you can automate pets as well. Plenty of shops use robust config management but don't (for a variety of different reasons) presume that indefinite horizontal scaling is the proper solution to all of life's problems, and thus can have a lot of systems running where the system cattle type n &lt;= 4, which when combined with data locality, master/standby, or prod/test, is very much in the pet range for whatever number your tweaks go to. <br>
<p>
Not everyone is Google Scale, and designing for Google Scale -- or creating enough complexity so that you can self-fullfillingly justify designing for Google Scale -- constitutes owning only the world largest k8s hammer. <br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916279"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 30, 2022 12:12 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/916279/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Absolutely - and automating admin is not, in itself, a sign that you're going for the "herd of cattle" phase. It's still valuable to automate repeated jobs for pets.
<p>The point of "herd of cattle" is that there's a continuum from the "pet" (e.g. my laptop), where all admin is done by hand, as a careful operation, through to the "cattle" where you have so many servers to look after that doing admin by hand is simply too time-consuming, and thus you must automate everything so that any server that leaves the "expected" state is either repaired by automation or kicked out as "definite hardware fault" by automation, with clear instructions on how to fix or replace the faulty hardware.
<p>Where you need to be on that line depends on how much time you have to do admin. If you have 40 hours a week to look after a single server that runs a single service, then pets are absolutely fine. If you have an hour a month to look after 10,000 servers, then you need to treat them as cattle. If you have 8 hours a week and 10 servers, then you're probably somewhere in the middle -  you want to have the baseline dealt with by automation (things like checking for hardware failures, making sure the underlying OS is up to date etc), but you can treat the services on top of the hardware (the things you care about like a database setup, a web server, your organisation's secret special code etc) as pets.
<p>And it's a good rule of thumb to assume that anything you do more than 3 times should be automated. For a small shop, this means that the things that recur have you treating the servers as cattle (why care about manually checking whether both disks are present in the RAID-1, or that btrfs checksums match data, when the server can do that automatically and notify you when bad things happen? Why manually choose all the options in the installer, when kickstart or equivalents can do that for you?) but once-offs (there's been a schema change from 2021-09 to 2021-10 deploy, needs manual application) are done by hand, treating the affected servers as pets.




      
          <div class="CommentReplyButton">
            <form action="/Articles/916279/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 30, 2022 16:30 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/916367/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Absolutely - and automating admin is not, in itself, a sign that you're going for the "herd of cattle" phase. It's still valuable to automate repeated jobs for pets.</span><br>
<p>
<span class="QuotedText">&gt; The point of "herd of cattle" is that there's a continuum from the "pet" (e.g. my laptop), where all admin is done by hand, as a careful operation,</span><br>
<p>
Even with a single, "pet" computer, automating admin where possible just makes sense. My /usr/local/bin has a few scripts (I ought to write more) that do assorted things like creating lvm volumes to assist my weekly backups/emerges, and there's plenty of stuff I ought to do regularly, that scripts would help with.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor915666"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2022 0:22 UTC (Tue)
                               by <b>KaiRo</b> (subscriber, #1987)
                              [<a href="/Articles/915666/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
After recent happenings, I wouldn't trust them to have enough employees in relevant areas to debug why something goes wrong if a reboot fixes it for now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915666/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor915425"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 19:38 UTC (Fri)
                               by <b>xi0n</b> (subscriber, #138144)
                              [<a href="/Articles/915425/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the concern is about an attacker who can rapidly trigger a large number of oopses to exploit some counter vulnerability, then wouldn’t it be better to track the oopses over a time window instead?<br>
<p>
Granted, I don’t have a good mental model as to how severe an oops is. But if something like a faulty driver for an obscure device can trigger it consistently without much harm for the rest of the kernel, then I can imagine a long running system may eventually hit the limit and panic seemingly out of the blue.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915425/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915430"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 20:31 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/915430/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If I were doing this kind of stuff, I'd want to involve as few components as possible. Timers seem fundamental, but not as fundamental as a simple counter.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915430/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor915454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2022 5:26 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/915454/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A timer means that an attacker merely needs to wait longer to succeed. It doesn't prevent the attack.<br>
<p>
Meanwhile, a timer is terrible for catching normal oops, because if the problem is infrequent enough it goes completely unnoticed while the corruption it causes persists.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor915428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 20:18 UTC (Fri)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/915428/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've been having the complete inverse problem on one machine: no warning signs whatsoever, the kernel would just spontaneously reboot back to BIOS at random times of day. Sometimes several times a day. It turned out it was just caused by use of llvm-lto (which I'm going to swear off of until I next forget this), but getting to that deduction was extremely unfun.<br>
<p>
Something in the middle, between that headache scenario and a dmesg full of emergencies going ignored, seems preferable to either... but if the option existed, I'd rather have the kernel vocalise its impending doom through the PC speaker.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915443"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 23:25 UTC (Fri)
                               by <b>sroracle</b> (subscriber, #124960)
                              [<a href="/Articles/915443/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To be clear - was this an LTO-built kernel that was sporadically rebooting, or something else?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915443/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915876"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 24, 2022 12:45 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/915876/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, specifically make LLVM=1 with the full-lto option on llvm 15, x86-64. Happening over a few weeks, my working theory was that the power supply was getting marginal with age. Then on a whim I made the next update plain GCC and it's been fine ever since.<br>
<p>
There's good reasons why that code is impossible to activate by accident, so I can't complain too much.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915876/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor915431"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2022 21:00 UTC (Fri)
                               by <b>unixbhaskar</b> (guest, #44758)
                              [<a href="/Articles/915431/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, in a wild hunch and armed with a lack of knowledge, may I suggest, it would be of great help, if and only if, the oops can point to the nearby location to look at(without going through the rigmarole of firing up the debugger to find out the culprit). I know, it requires some sort of system training to be built on to get it. <br>
<p>
I am driving this notion by seeing it in different contexts in a specific environment. <br>
<p>
See, I am looking for an "easy way out" than putting in any kind of effort.  My lacuna.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915431/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor915553"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2022 8:58 UTC (Mon)
                               by <b>jafd</b> (subscriber, #129642)
                              [<a href="/Articles/915553/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Don't oopses provide a stack trace? Is this what you mean?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915553/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor915556"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2022 10:44 UTC (Mon)
                               by <b>aaronmdjones</b> (subscriber, #119973)
                              [<a href="/Articles/915556/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OOPSes already provide a stack trace and a full register dump. They also (if it was caused by e.g. the BUG_ON() macro) provide the file and line number that caused it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915556/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor915667"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2022 0:30 UTC (Tue)
                               by <b>KaiRo</b> (subscriber, #1987)
                              [<a href="/Articles/915667/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The sysfs exposure of oops and warning counts sounds really great and I hope a lot of monitoring tools (including stuff on desktops) will look at that as I'm sure that most of those right now are simply not noticed at all - people are just not regularly reading logs and if an entry there is all that happens, it will go unnoticed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/915667/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor916447"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 1, 2022 15:42 UTC (Thu)
                               by <b>esemwy</b> (guest, #83963)
                              [<a href="/Articles/916447/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn’t this turning any bug into an immediate denial-of-service? I understand the concern that there may be an information leak or multiple tries on the same intermittent vulnerability, but given that the system owner is rarely in a position to actually make the fix, this seems like a pretty crude solution. <br>
<p>
Is there something I’m missing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916447/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916450"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 1, 2022 16:57 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/916450/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>You've already got a denial of service if you can trigger oopses at will - oops handling is not free, and if two or more CPUs hit an oops at the same time, one CPU is chosen as the oops handler, while the others spin in kernel space, preventing you from doing anything useful until the oops is handled. If I can trigger oopses freely, I can have all but one core spinning in the kernel, while the one that's trying to do work keeps re-entering the oops handler and not making progress.
<p>Plus, the nature of oopses is that some are one-off ("cosmic ray") events that never recur, while others leave the system in a state where doing the same thing will result in another oops. The older knob (panic_on_oops) lets you turn all oopses into panics, so that the machine comes into a known state before trying again. This knob allows you to attempt to distinguish cosmic ray events from important subsystems broken, so that (e.g.) if I can reliably oops you because part of the TCP stack has trashed state for one tx queue, and you'll oops every time you send data, you'll panic, but if the oops is because the driver author for my NIC didn't think about what would happen if I tried to tx during a NIC reset, and everything will be fine after the NIC reset completes, well, this is a rare event and I'll recover.
<p>And to some extent, the key difference between an oops and a panic is that an oops says "the system is partially broken; some things still work, but other things are permanently broken", while a panic says "the system is beyond recovery, short of a complete reboot". On my laptop, for example, an oops that occurs every time my TCP stack tries to handle a receive window of more than 8 bytes is a pain, but I can deal - save files (NVMe is unaffected by a broken TCP stack), and reboot. If I lose my input subsystem, however, I'm stuck - if I can't tell the computer what to do, all I can do is reset it. On a network server at Twitter, however, losing the input subsystem is no big deal, but a network stack that can't handle a receive window of more than 8 bytes is effectively useless.





      
          <div class="CommentReplyButton">
            <form action="/Articles/916450/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 1, 2022 17:54 UTC (Thu)
                               by <b>esemwy</b> (guest, #83963)
                              [<a href="/Articles/916471/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OK, thanks. That makes a lot more sense then. The only remaining concern would be on extremely long running systems, and I expect the amount of monitoring those receive is sufficient that the hard limit rather than a timed window shouldn’t matter. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/916471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor916474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 1, 2022 18:05 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/916474/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>It's also worth noting that this is an optional mechanism; if your system is meant to be extremely long running, and to keep going through oopses, you'd turn this off. But for a use case like Twitter (or Amazon Web Services, or Facebook, or Google), this mechanism will result in servers that are accumulating software faults panicking and thus rebooting before things get serious - and you'll have other monitoring that says "this server is rebooting frequently, take it out of service" already.



      
          <div class="CommentReplyButton">
            <form action="/Articles/916474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor919113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Averting excessive oopses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 5, 2023 14:50 UTC (Thu)
                               by <b>sammythesnake</b> (guest, #17693)
                              [<a href="/Articles/919113/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a point where "very long running" bumps up against the mean time between kernel upgrades you don't want to miss. Longer ruining than that is probably not something to aspire to!<br>
<p>
Providing the "cosmic ray" and "meh - non-critical subsystem" oopsen don't add up to 10,000 much more quickly than that, then your reboot rate will probably be pretty unaffected, I'd have thought.<br>
<p>
For my own use case, the most common cause of reboots is accidentally knocking the power cable loose while hunting for something that fell down the back of my desk, so this is all a little academic for me :-P<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/919113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
