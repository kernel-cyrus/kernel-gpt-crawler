        <!DOCTYPE html>
        <html lang="en">
        <head><title>This is why we can't have safe cancellation points [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/683118/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/682941/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/683118/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>This is why we can't have safe cancellation points</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="GAByline">
           <p>April 13, 2016</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
<p>Signals <a href="/Articles/414618/">have been described</a> as an
&quot;unfixable design&quot; aspect of Unix.  A <a
href="https://lore.kernel.org/all/06079088639eddd756e2092b735ce4a682081308.1457486598.git.luto@kernel.org/">recent
discussion</a> on the linux-kernel mailing list served to highlight some of
the difficulties yet again.  There were two sides to the discussion, one
that focused on solving a problem by working with the known challenges and
the existing semantics, and one that sought to fix the purportedly
unfixable.</p>

<p>The context for this debate is the <a
href="http://man7.org/linux/man-pages/man3/pthread_cancel.3.html"><tt>pthread_cancel(3)</tt></a>
interface in the <a
href="http://man7.org/linux/man-pages/man7/pthreads.7.html">Pthreads</a>
POSIX threading API.
Canceling a thread is conceptually similar to killing a process, though with
significantly different implications for resource management.  When a
process is killed, the resources it holds, like open file descriptors, file
locks, or memory allocations, will automatically be released.
</p>

<p>In contrast, when a single thread in a multi-threaded process is
terminated, the resources it was using cannot automatically be cleaned
up since other threads might be using them.  If a multi-threaded
process needs to be able to terminate individual threads — if for
example it turns out that the work they are doing is no longer needed —
it must keep track of which resources have been allocated and where
they are used.  These resources can then be cleaned up, if a thread is
canceled, by a 
cleanup handler registered with
<a href="http://man7.org/linux/man-pages/man3/pthread_cleanup_push.3.html"><tt>pthread_cleanup_push(3)</tt></a>.  For this to be achievable, there must be
provision for a thread to record the allocation and deallocation of
resources atomically with respect to the actual allocation or
deallocation.  To support this Pthreads introduces the concept of
&quot;cancellation points&quot;.</p>
<p>

These cancellation points are optional and can be disabled with a call to
<a
href="http://man7.org/linux/man-pages/man3/pthread_setcanceltype.3.html"><tt>pthread_setcanceltype(3)</tt></a>.
If the cancel type is set to <tt>PTHREAD_CANCEL_ASYNCHRONOUS</tt> then a
cancellation can happen at any time.  This is useful if the thread is not
performing any resource allocation or not even making any system calls at
all.  In this article, though, we'll be talking about the case where
cancellation points are enabled.


<h4>On cancellation points and their implementation</h4>

From the perspective of an application, a "cancellation point" is any one
of a number of POSIX function calls such as <tt>open()</tt>, and
<tt>read()</tt>, and many 
others.  If a cancellation request arrives at a time when none of
these functions is running, it must take effect when the next
cancellation-point function is called.  Rather than performing the
normal function of the call, it must call all cleanup handlers and
cause the thread to exit.
<p>
If the cancellation occurs while one of these function calls is
waiting for an event, the function must stop waiting.  If it can still
complete successfully, such as a <tt>read()</tt> call for which some data has
been received but a larger amount was requested, then it may complete
and the cancellation will be delayed until the next cancellation
point.  If the call cannot complete successfully, the cancellation
must happen within that call.  The thread must clean up and exit and
the interrupted function will not return.
<p>
From the perspective of a library implementing the POSIX Pthreads API,
such as the <a
href="http://www.musl-libc.org/">musl C library</a> (which was the focus of
the discussions), 
the main area of interest is the handling of system calls that can
block waiting for an event, and how this interacts with resource
allocation.  Assuming that <tt>pthread_cancel()</tt> is implemented by
sending a signal, and there aren't really any alternatives, the exact
timing of the arrival of the cancellation signal can be significant.
<p>
<ul>
<li> If the signal arrives after the function has checked for any pending
  cancellation, but before actually making a system call that might
  block, then it is critical that the system call is not made at all.
  The signal handler must not simply return but must arrange to
  perform the required cleanup and exit, possibly using a mechanism
  like <a
  href="http://man7.org/linux/man-pages/man3/longjmp.3.html"><tt>longjmp()</tt></a>. 
<p>
<li> If the signal arrives during or immediately after a system call
  that performs some sort of resource allocation or de-allocation,
  then the signal handler must behave differently.  It must let the
  normal flow of code continue so that the results can be recorded to
  guide future cleanup.  That  code should notice if the system call was
  aborted by a 
   cancellation signal and start cancellation processing.  The signal
   handler cannot safely do that directly; it must simply set a flag for
   other code to deal with.
</ul>
<p>
There are quite a number of system calls that can both wait for an
event and allocate resources; <tt>accept()</tt> is a good example as it
waits for an incoming network connection and then allocates and
returns a file descriptor describing that connection.  For this class of
system calls, both requirements must be met: a signal arriving
immediately before the system call must be handled differently
than a signal arriving during or immediately after the system call.
<p>

There are precisely three Linux system calls for which the distinction
between "before" and "after" is straightforward to manage:
<tt>pselect()</tt>, <tt>ppoll()</tt>, and <tt>epoll_pwait()</tt>. Each of
these takes a 
<tt>sigset_t</tt> argument that lists some signals that are normally 
blocked before the system call is entered. These system calls will
unblock the listed signals, perform the required action, then block them
again before returning to the calling thread.  This behavior 
allows a caller to block the cancellation signal, check if a signal has
already arrived, and then proceed to make the system call
without any risk of the signal being delivered just before the system
call actually starts.  Rich Felker, the primary author of musl, did  
<a
href="http://mid.gmane.org/20160310164104.GM9349@brightrain.aerifal.cx">lament</a>
that if all system calls took a <tt>sigset_t</tt> and used it 
this way, then implementing cancellation points correctly would be
trivial. Of course, as he acknowledged, "<q>this is obviously not a
practical change to make.</q>"
<p>
Without this ability to unblock signals as part of every system call,
many implementations of Pthread cancellation are racy.
The <a href="http://ewontfix.com/2/">ewontfix.com</a> web site goes into quite some detail on
this race and its history and reports that <a
href="https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/unix/sysdep.h;h=94a2ce0e37a1d531064923f249d9a8ef9c3e5739;hb=ab30899d880f9741a409cbc0d7a28399bdac21bf#l53">the
approach taken in glibc</a> is:</p>
<p>
<pre>
    ENABLE_ASYNC_CANCEL();
    ret = DO_SYSCALL(...);
    RESTORE_OLD_ASYNC_CANCEL();
    return ret;
</pre>

<p>where <tt>ENABLE_ASYNC_CANCEL()</tt> directs the signal handler to
terminate the thread immediately and
<tt>RESTORE_OLD_ASYNC_CANCEL()</tt> directs it to
restore the behavior appropriate for the <tt>pthread_setcanceltype()</tt>
setting. 

<p>If the signal is delivered before or during the system call this works
correctly.  If, however, the
signal is delivered after the system call completes but before
<tt>RESTORE_OLD_ASYNC_CANCEL()</tt> is called, then any resource
allocation or
deallocation performed by the system call will go unrecorded.  The
<tt>ewontfix.com</tt> site provides a simple test case that reportedly can
demonstrate this race.</p>

<h4>A clever hack</h4>

<p>The last piece of background before we can understand the debate about
signal handling is that  musl has a
solution for this difficulty that is &quot;clever&quot; if you ask Andy
Lutomirski and &quot;<a
href="http://mid.gmane.org/CA+55aFzOcxbhXCm01+NMgY9=THYgjojvDGeYsnxe-vWfiX4X0g@mail.gmail.com">a
hack</a>&quot; if you ask Linus Torvalds.  The solution is almost trivially
obvious once the problem is described as above so it should be no surprise
that the description was developed with the solution firmly in mind.</p>

<p>
The signal handler's behavior must differ depending on whether the signal
arrives just before or just after a system call.  The
handler can make this determination by looking at the code address
(i.e. instruction pointer) that control will return to when the
handler completes.  The details of getting this address may require
poking around on the stack and will differ between different
architectures but the information is reliably available.</p>

<p>As Lutomirski explained when starting the thread, <tt>musl</tt> uses
a single code fragment (a <a
href="https://en.wikipedia.org/wiki/Thunk">thunk</a>) like:</p>
<p>
<pre>
    cancellable_syscall:
        test whether a cancel is queued
        jnz cancel_me
        int $0x80
    end_cancellable_syscall:
</pre>

<p>to make cancellable system calls. (&quot;<tt>int $0x80</tt>&quot; is the traditional way
to enter the kernel for a system call by behaving like an
interrupt).  If the signal handler finds the return address to be at or
beyond <tt>cancellable_syscall</tt> but before <tt>end_cancellable_syscall</tt>,
then it must arrange for termination to happen without ever returning
to that code or letting the system call be performed.  If it has any
other value, then it must record that a cancel has been requested so
that the next cancellable system call can detect that and jump to
<tt>cancel_me</tt>.</p>

<p>

This "clever hack" works correctly and is race free, but is not perfect.
Different architectures have different ways to enter a system call, 
including <tt>sysenter</tt> on x86_64 and <tt>svc</tt> (supervisor call) on
ARM.  For 32-bit 
x86 code there are three possibilities depending on the particular
hardware: <tt>int&nbsp;$0x80</tt> always works but is not always the
fastest.  The 
<tt>syscall</tt> and <tt>sysenter</tt> instructions may be available and are
significantly faster.  To achieve best results, the <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/arch/x86/entry/vdso/vdso32/system_call.S?id=b562e44f507e863c6792946e4e1b1449fbbac85d#n29">preferred
way</a> to make 
system calls on a 32-bit x86 CPU is to make an indirect call through the
<tt>kernel_vsyscall()</tt> entry point in the "<a
href="https://lwn.net/Articles/446528/">vDSO</a>" virtual system call 
area.  This function will use
whichever instruction is best for the current platform.  If musl tried
to use this for cancellable system calls it would run into difficulties,
though,
as it has no way to know where the instruction is, or to be certain that
any other instructions that run before the system call are all located
before that 
instruction in memory.  So musl currently uses <tt>int&nbsp;$0x80</tt> on
32-bit 
x86 systems and suffers the performance cost.



<p>
<h4>Cancellation for faster system calls</h4>

<p>Now, at last, we come to Lutomirski's <a href="http://mid.gmane.org/06079088639eddd756e2092b735ce4a682081308.1457486598.git.luto@kernel.org">simple patch</a> that started the
thread of discussion.  This patch adds a couple of new entry points to
the vDSO, the important one for us is <tt>pending_syscall_return_address</tt>,
which determines if the current signal happened during
<tt>kernel_vsyscall</tt> handling and reports the address of the system call
instruction.  The caller can then determine if the signal happened before,
during, or after that system call.</p>

<p>

Neither Linus nor Ingo Molnar liked this approach, though their
exact reasons weren't made clear.  Part of the reason may have been that
the semantics of cancellation appear clumsy so it is hard to justify much
effort to support them.  <a
href="http://mid.gmane.org/20160309085631.GA3247@gmail.com">According to
Molnar</a>, "<q>it's a really bad interface to rely on</q>". 
Even Lutomirski <a
href="http://mid.gmane.org/CALCETrXXx36buZyOhnYu-N3boRrCdK0a8p8yPHD+te1k3zYY=Q@mail.gmail.com">expressed
surprise</a> that musl "<q>didn't take the approach of 'pthread
cancellation is not such a great idea -- let's just not support
it'.</q>" Szabolcs Nagy's <a
href="http://mid.gmane.org/20160309113449.GZ29662@port70.net">succinct
response</a> "<q>because of standards</q>" seemed to settle that
issue.


<p>

One clear complaint
from Molnar was that there was "<q>so much complexity</q>" and it is
true that the code would require some deep knowledge to fully understand.
This concern is borne out by the fact that Lutomirski, who has that
knowledge, hastily <a
href="http://mid.gmane.org/CALCETrWNSAWHhQmxuJr1eF+3nLkd50NGF3pQ2EiNvzLFKybegQ@mail.gmail.com">withdrew
his first</a> and <a
href="http://mid.gmane.org/CALCETrVMp6twHwdTrX3WAzEL+7qi1Aha5BxVz++V_Yc2AP8pBg@mail.gmail.com">second</a>
attempts.  While complexity is best avoided where possible, complexity
should not be, by itself, itself a justification for keeping something out
of Linux.</p> 

<p>Torvalds and Molnar contributed both by exploring the issues to flesh
out the shared understanding and by proposing extra semantics that
could be added to the Linux signal facility so that a more direct
approach could be used.</p>

<p>Molnar <a href="http://mid.gmane.org/20160310111646.GA13102@gmail.com">proposed</a> &quot;sticky signals&quot; that could be enabled with an extra
flag when setting up a signal handler.  The idea was that if the
signal is handled other than while a system call is active, then the
signal remains pending but is blocked in a special new way.  When the
next system call is attempted, it is aborted with <tt>EINTR</tt> and
the signal 
is only then cleared.  This change would remove the requirement that
the signal handler must not allow the system call to be entered at all
if the signal arrives just before the call, since the system call would
now immediately exit.</p>

<p>Torvalds's <a href="http://mid.gmane.org/CA+55aFxvMM3j1aWjN-kr5Hn8CUC_RSNw5hc+X8zFXMaMv+mGww@mail.gmail.com">proposal</a> was similar but involved &quot;synchronous&quot; signals.
He saw the root problem being that signals can happen at any time and
this is what leads to races.  If a signal were marked as &quot;synchronous&quot;
then it would only be delivered during a system call.  This is exactly
the effect achieved with <tt>pselect()</tt> and friends and so could
result in a race-free implementation.</p>

<p>The problem with both of these approaches is that they are not
selective in the correct way.  POSIX does not declare all system calls
to be cancellation points and, in fact, does not refer to system calls
at all.  It is only certain API functions that are defined as cancellation
points and, as Torvalds clearly agreed that 
being able to use the faster system call entry made available in the
vDSO was important, but neither he nor Molnar managed to provide a
workable alternative to the solution proposed by Lutomirski.</p>

<p>Felker <a href="http://mid.gmane.org/20160312180531.GD9349@brightrain.aerifal.cx">made his feelings</a> on the
progress of the discussion quite clear:</p>
<p>
<div class=BigQuote>
I'm really frustrated that, again and again, we have
kernel folks with no experience with libc implementation trying to
redesign something that already has a simple zero-cost design that
works on all existing systems, and proposing things that have a mix of
immediately-obvious flaws and potential future problems we haven't
even thought of yet.
</div>

<p>It is certainly important to get the best design, and exploring
alternatives to understand why they were rejected is a valid part of
the oversight provided by a maintainer.  When that leads to the
design being improved, we can all rejoice.  When it leads to an
understanding that the original design, while not as elegant as might
be hoped, is the best we can have, it shouldn't prevent that design from
being accepted.
Once Lutomirski is convinced that he has all the problems resolved, it
is to be hoped that a re-submission results in further progress
towards efficient race-free cancellation points.  Maybe that would
even provide the incentive to get race-free cancellation points in
other libraries like glibc.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#System_calls">System calls</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/683118/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor683775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 1:49 UTC (Thu)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/683775/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FYI I just learned ewontfix's author is the musl author.<br>
<p>
<a href="http://ewontfix.com/4/">http://ewontfix.com/4/</a> is also a good one.  Things that make you shake your head and wonder how anything works.  Also apparently everything assumes malloc + threads + fork is safe, but I saw some recent glibc bugs on that too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683804"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 8:52 UTC (Thu)
                               by <b>gutschke</b> (subscriber, #27910)
                              [<a href="/Articles/683804/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
fork() and threads are just mutually incompatible. Period.<br>
<p>
The preferred solution in the POSIX world is to fork() a helper process as the first thing in main(), before any threads get created. And this helper is then used whenever another process needs to be created. Unfortunately, this is not always possible in existing code bases. It also breaks, if libraries decide to start threads before main() executes. And it can make reaping of child processes more difficult.<br>
<p>
If the above concerns pose an insurmountable problem, there are ways to make forking possible; but they require direct system calls, intimate knowledge of the underlying libc implementation and of the kernel, and also knowledge of how the compiler and the dynamic linker interact. It's amazingly difficult to get right.<br>
<p>
For many years, I have maintained commercial code that had to implement this hack. It generally worked fine, but the amount of engineering effort to get there was insanely high, and every couple of years new bugs popped up, when the tool chain gradually changed.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683804/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683905"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 22:46 UTC (Thu)
                               by <b>pikhq</b> (subscriber, #98351)
                              [<a href="/Articles/683905/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The actually preferred POSIX solution is to use the posix_spawn function, which works correctly in the presence of threads. I admit it's a bit of a little-known function, but it's a handy one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683905/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683908"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 23:51 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/683908/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
posix_spawn exists solely because POSIX makes implementing fork optional so that systems without virtual memory can still meet the letter of the standard.<br>
<p>
 posix_spawn doesn't magically solve thread race problems. Using fork+exec+dup2 can be just as safe posix_spawn and be significantly more clear. For example, descriptors without the FD_CLOEXEC descriptor flag set will still leak into the new process instance unless you explicitly close them. But which is easier: tediously filling out a posix_spawn_file_actions object, or simply calling close? Often the latter.<br>
<p>
Implementations generally implement posix_spawn by using vfork+exec. That does mean that they bypass pthread_atfork handlers. But that's not intrinsically safer: it can cut both ways--maybe one was going to close a descriptor. Anyhow, pthread_atfork handlers are fundamentally broken wrt the original intention, and the specification admits this.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683908/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 12:07 UTC (Fri)
                               by <b>oshepherd</b> (guest, #90163)
                              [<a href="/Articles/683953/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <tt>posix_spawn</tt> is not optional in POSIX. Yes, one of the motivating reasons for it is that it permits <i>profiles</i> of  POSIX for no-MMU platforms to spawn new processes, but that is not the only motivation. <tt>posix_spawn</tt> can also be more efficient (because it does not have to go through the completely generic <tt>fork</tt> path, and it additionally makes error handling much easier (Have you ever tried reporting <tt>execve</tt>, <tt>dup</tt> or <tt>close</tt> errors back to the parent process? It's not a trivial matter...)
<p>
I don't buy the argument that <tt>fork</tt>+<tt>dup</tt>+<tt>close</tt>+<tt>exec</tt> is easier. Not once you actually handle errors properly or do other things that a Robust Application (TM) should.
      
          <div class="CommentReplyButton">
            <form action="/Articles/683953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683957"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 14:04 UTC (Fri)
                               by <b>MrWim</b> (subscriber, #47432)
                              [<a href="/Articles/683957/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; posix_spawn is not optional in POSIX.</font><br>
<p>
A minor point: I understood the parent to mean that fork is optional in POSIX, whereas posix_spawn is mandatory.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683957/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 15:05 UTC (Fri)
                               by <b>oshepherd</b> (guest, #90163)
                              [<a href="/Articles/683997/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Uh, thinko. I meant to say "fork is not optional in POSIX." Indeed, <tt>posix_spawn</tt> is optional, but <tt>fork</tt> is not

(that said, if there are any important platforms where POSIX spawn doesn't exist - I'm thinking probably OS X here - it'd be relatively easy for somebody to produce a compatibility shim which implemented it on top of fork/execve/pipe/close/dup/etc)
      
          <div class="CommentReplyButton">
            <form action="/Articles/683997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor684532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2016 5:13 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/684532/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're completely right: posix_spawn is optional (part of the Spawn extension) and fork is not. I even had the standard open but didn't bother confirming what I asserted. Shameful....<br>
<p>
Regarding error checking: routines like posix_spawn_file_actions_addclose can fail with ENOMEM, and AFAICT both the glibc and musl implementations allocate memory even on the first add--musl for each individual action, glibc for 8 actions. Because allocation can fail even on Linux with OOM (e.g. policy-based resource limits), regardless of allocation size, correct code needs to check for failure on each individual descriptor action added to the queue. So posix_spawn requires the same number of error checks.<br>
<p>
OTOH, even the most pedantic of developers could choose to ignore errors from close() (or posix_close() if and when <a href="http://austingroupbugs.net/view.php?id=529">http://austingroupbugs.net/view.php?id=529</a> is adopted) in the child process. Apropos this article, you no longer need to worry about close being a thread cancellation point in the child, and blocking all signals is easy, so EINTR won't happen. And EBADF shouldn't happen in correctly written software.[1] Alternatively, you could choose to set FD_CLOEXEC, which doesn't even have an EINTR failure mode. Arguably dup2 could correctly be ignored--I have a hard time imagining a failure condition where dup'ing a descriptor over an already open stdio descriptor could fail, though that does depend on some assumptions and it's not something I would do anyhow.<br>
<p>
Point being, explicit fork+exec could in some situations take less code than posix_spawn because you could elide some error checks. And I can't imagine a situation where it could take appreciably more code.<br>
<p>
More importantly, though, is the point that posix_spawn doesn't solve threading race conditions. The only possibly plus in this regard is that posix_spawn will correctly block signals during the operation so that, e.g., a signal handler isn't wrongly called in the child but before exec.[2]  Conspicuously missing, on the other hand, is the ability to set the umask in the child process. Setting or even querying the umask simply can't be done in a race-free manner in a threaded application, unless no other thread relies on the umask, or if you fork and report back the umask.<br>
<p>
While there's nothing intrinsically wrong with using posix_spawn, it shouldn't be used for the wrong reasons. You still have to carefully consider the important stuff.<br>
<p>
[1] EBADF invariably means you have a bug in your application, often a thread race or in single-threaded non-blocking I/O code an ordering issue. I refuse to ignore EBADF in my event loop and polling libraries (unlike libevent and similar libraries) despite people complaining to me how annoying it is to propagate it. Such a bug could easily lead to stalled network I/O. I'm convinced it's is a very common problem in non-blocking I/O networking daemons, but that its rare enough that people chaulk it up to network hiccups. So I propagate EBADF when manipulating a descriptor event because it's not the library's prerogative to hide such an error, and it can't possibly know whether the error is benign, recoverable, or panic-worthy. Though as with ENOMEM, library state remains consistent after the error so that recovery isn't foreclosed.<br>
<p>
[2] pthread_sigmask has no failure mode when used correctly, so it's just two lines of condition-less code when using fork+exec. Though I learned a few years ago over on comp.unix.programmer that one should initialize a sigset_t object with sigemptyset before passing as the _output_ argument to pthread_sigmask and similar routines. Some implementations will logical-OR the signal set, rather than writing over the entire sigset_t object. See also <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigismember.html">http://pubs.opengroup.org/onlinepubs/9699919799/functions...</a>. I admit this is one case where using posix_spawn has a clear benefit over fork+exec. I just don't think that in the grand scheme of things it amounts to much. Descriptor leakages and umask races, for example, are arguably far-and-above the bigger problem, especially from a security perspective, and posix_spawn provides no benefit and in some cases is more limited.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 25, 2016 14:39 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/684960/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Arguably dup2 could correctly be ignored--I have a hard time imagining a failure condition where dup'ing a descriptor over an already open stdio descriptor could fail, though that does depend on some assumptions and it's not something I would do anyhow.
</blockquote>
A brief glance at do_dup2() in the kernel (or, for that matter, at a sufficiently recent manpage) reveals that it can fail with -EBUSY if the file descriptor it's being asked to dup over is still being opened, so (just as with -EINTR) a retry loop would be needed for perfect safety in this situation.
      
          <div class="CommentReplyButton">
            <form action="/Articles/684960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor683904"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 23:30 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/683904/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>
Forking a helper process from main just to execute other programs sounds like cargo cult advice.
</p>

<p>
Calling fork from a thread is just as safe or unsafe as another common asynchronous context: signals. Pthread mutexes aren't async-signal safe, either.  So you _can_ use fork from a threaded application, just make sure that between fork and exec you only call async-safe routines--typically syscalls. It's perfectly safe to call routines like close, dup2, mmap, etc. Definitely do not use FILE handles, malloc, etc. 
</p>

<p>
Threading in general is incompatible with any code which doesn't pay attention to global state and other race conditions. But if you use a third-party library which doesn't internally implement locking, but which is very carefully designed not to touch global state and which behaves correctly as long the caller synchronizes on an instance object before calling its methods, that's not something I would call "incompatible" with threading even though safe behavior it's not automatic. The POSIX standard and implementations are likewise very carefully designed to permit mixed-use, but likewise require you to heed certain well-specified constraints. It's not magic. </p>

<p>
The lesson here isn't that it's impossible to mix these things; it's that you really need to pay attention. If you can't be bothered to think these things through; if you can't be bothered to read the freely available and relatively concise standards, if only to confirm what you've read on Stack Overflow or elsewhere; if you can't be bothered to otherwise catalog and verify your assumptions; then not only should you not mix forking and threading, you probably shouldn't be doing any kind of threaded programming, period.
</p>

<p>
That advice applies to everybody, regardless of skill, myself included, because you devise solutions to problems based on your resources. If you don't have the time (presuming you have the knowledge and faculties) to implement something correctly using certain tools, you should use safer tools. This is why even the most expert of C lovers regularly use scripting languages, and why people using so-called "safe" languages use even safer languages on occasion.
</p>

<p>
FWIW, forking and threading is well-defined by POSIX. From the specification for fork in IEEE Std 1003.1, 2013 Edition,
</p>

<tt><blockquote>
<p>
A process shall be created with a single thread. If a multi-threaded process calls fork(), the new process shall contain a replica of the calling thread and its entire address space, possibly including the states of mutexes and other resources. Consequently, to avoid errors, the child process may only execute async-signal-safe operations until such time as one of the exec functions is called. Fork handlers may be established by means of the pthread_atfork() function in order to maintain application invariants across fork() calls.
</p>
<p>
When the application calls fork() from a signal handler and any of the fork handlers registered by pthread_atfork() calls a function that is not async-signal-safe, the behavior is undefined.
</p>
</blockquote></tt>

<p>
Likewise, the advice that "the only safe thing to do from a signal handler is to set a flag" is also not true. It's intended to scare junior programmers (or lazy programmers) away from interfaces that are difficult to use. They require enough experience and knowledge to be able verify correct usage. But IMO, if you're programming any non-trivial application in C or C++, you should at least understand how to _disprove_ correct usage. Which is to say, you should be able to explain _why_ code implementing a signal handler is unsafe, even if you're not sure if or how it could be made safe, and even if it requires consulting a specification or other primary source.
</p>

<p>
A corollary is that good C programmers should be well practiced at reading the C, POSIX, or other relevant standard. Manual pages, especially on Linux, are definitely not up to snuff, FWIW. They're woefully incomplete, and too often resort to scare tactics. Whereas the POSIX specification is more complete, well laid-out, and has useful overviews and discussions relevant to subsystems and specific routines. It's the best starting point, though for many situations there's no substitute for verifying behavior by consulting the source code. 
</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683904/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2016 17:10 UTC (Mon)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/684243/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you for dispelling some of the incorrect received wisdom one sees circulating around programming communities. Signals are not magic. Fork is not magic. All of these things are just powerful tools that become useful when understood. It really is a wonder anything works at all when people program with the kind of incorrect models you rail against.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor683786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 5:24 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/683786/">Link</a>] (28 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is still early in the morning, so I may write something silly now... if the interface is so bad it is hardly worth supporting and there is a solution now (int 0x80) which works, albeit slowly, is it feasible to only use this solution when cancelling is enabled? Or some similar fast and slow path solution?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 7:51 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/683799/">Link</a>] (27 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For embedded library like newlib - may be. For general-purpose library like musl - nope. You don't "enable" cancelling, you just use it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 19:40 UTC (Thu)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/683884/">Link</a>] (25 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You do enable cancellation, though -- by default, system calls are not cancellable AFAIK.<br>
<p>
So musl could (and, AFAICT, does) use int $0x80 only for cancellable syscalls.<br>
<p>
(FWIW, the actual meat of the patch I wrote was fine, I think.  The issue was that building vdso code at all is a giant mess and I broke the build system.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683895"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 21:18 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/683895/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      Uhm. Perhaps I'm misreading something but AFAICS <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_setcancelstate.html">the cancelability state and type of any newly created threads, including the thread in which main() was first invoked, shall be PTHREAD_CANCEL_ENABLE and PTHREAD_CANCEL_DEFERRED respectively</a> means exactly what I wrote: you don't enable cancellation, you just use it. You can disable it, sure - but that's not default.
      
          <div class="CommentReplyButton">
            <form action="/Articles/683895/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 21:28 UTC (Thu)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/683897/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IMO that's simply daft.<br>
<p>
Perhaps someone should attempt to change the standard to work the other way (default is PTHREAD_CANCEL_DISABLE and PTHREAD_CANCEL_DEFERRED).  After all, no sensible program uses cancellation, so why make them pay the price?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 22:30 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/683902/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>POSIX had that requirement <a href="http://pubs.opengroup.org/onlinepubs/007908775/xsh/pthread_setcancelstate.html">for the last 20 years or so</a>, I'm afraid it's too late to change it.</p>

<p>If someone wants to introduce drastic, potentially disruptive, change to POSIX then it would be significantly more sane to just make them optional in POSIX and remove them from libraries like Musl and GLibc, don't you think?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/683902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor683909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 0:04 UTC (Fri)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/683909/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; After all, no sensible program uses cancellation, so why make them pay the price?</font><br>
<p>
This is the part of the story that didn't make much sense to me.  Why do you think cancellation is such a bad idea?<br>
I appreciate that it only gets about a 3 or 4 on Rusty's API Design scale but they provide an extremely light-weight mechanism to protect threads from dying at awkward moments.<br>
The only alternative I can see is for an application to use an ad-hoc signaling mechanism and for threads to only use non-blocking versions of 'accept' and other interfaces that allocate resources.<br>
Apart from wheel-reinvention, that would be an interface that libraries couldn't share.<br>
You and Rich have made it clear that cancellation can be implemented correctly and efficiently.  So there isn't really any price to be paid.  Let's just do it and move on ???<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 0:11 UTC (Fri)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/683914/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Using it correctly is a real pain.  Using it correctly in C++ is even worse.<br>
<p>
AFAICT the only way to use it safely is to have cancellation off *except* at very carefully selected points and to turn it on at those points.  Every cancellation point then needs to be aware that the thread can go away without unwinding.<br>
<p>
ISTM any code that actually does this would be better off using ppoll, etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683916"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 0:38 UTC (Fri)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/683916/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is assertion without substance.<br>
<p>
Surely I can:<br>
1/ create a data structure that contains a list of all resources I might hold (file descriptor, byte range locks).<br>
2/ register a cleanup handler which walks that data structure and frees everything.<br>
3/ write simple wrappers for open/accept/whatever which record the results in the data structure<br>
4/ just call those wrappers, never the bare API.<br>
<p>
Then if I ever get canceled, everything will be cleaned up nicely.<br>
<p>
I would need to disable cancellation while manipulating a data structure shared with other threads, but I see cancellation more as being appropriate for largely independent threads.<br>
<p>
What specific risks do you see if cancellation is mostly enabled?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683916/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683930"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 7:21 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/683930/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">What specific risks do you see if cancellation is mostly enabled?</font></blockquote><p>I think the problem is simple inefficiency.</p>

<p>Cancellation support is not free - even if it's not used.</p>

<p>And even your "simple" scheme includes many steps and couldn't arrive in a random program by accident.</p>

<p>Surely if you change a design of your program that much to make it possible to use cancellation you could as well go and create wrapper for pthread_create which will call pthread_setcancelstate(p), too?</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683930/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683934"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 8:00 UTC (Fri)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/683934/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I think the problem is simple inefficiency.</font><br>
<p>
Specifically?  The solution used by musl costs almost nothing except on x86_32 and the change to make it work well on x86_32 has zero extra performance cost.<br>
<p>
<font class="QuotedText">&gt; And even your "simple" scheme includes many steps and couldn't arrive in a random program by accident.</font><br>
<p>
I'm failing to parse that... Certainly you wouldn't put any code in any program by accident (I hope) ??<br>
The random program probably never cancels threads so it wouldn't want these steps anyway.<br>
<p>
<font class="QuotedText">&gt; Surely if you change a design of your program that much to make it possible to use cancellation you could as well go and create wrapper for pthread_create which will call pthread_setcancelstate(p), too?</font><br>
<p>
I fail to see how this would solve anything at all.<br>
<p>
Many applications never cancel any threads.  They are irrelevant.  They need do nothing and they suffer no cost (maybe a couple of instructions per syscall.  If you can't afford that, hand-code your systemcalls).<br>
<p>
Some applications do find value in the ability to cancel threads.  Those threads clearly need to be prepared to be canceled.  Being prepared is not zero work, but it is not too onerous.<br>
<p>
If the thread is not doing any resource allocation, maybe just computing pi to a few million bits, then it can deliberately request async cancellation and go about its business.<br>
If the thread is allocating resources then it naturally needs to make sure they get de-allocated.  Any code already needs to worry about this.  Code that can be canceled needs to do maybe 10% more work.<br>
It can disable cancellation over a short allocate/use/deallocate sequence that won't block.  Or it can register a cleanup helper and record the allocation in some array or something.<br>
If your allocations follow a strict LIFO discipline you can even<br>
 - alloc<br>
 - push cleanup handler<br>
 - use the allocation<br>
 - pop the cleanup handler<br>
<p>
Which makes for nice clean code with the certainty that the cleanup handler will run even if the thread is canceled.<br>
The point of deferred cancellation is that this can be done with no locking, no extra system calls.  It just needs a little care - like not logging any messages between the allocation and pushing the cleanup handler.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683934/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683984"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 15:10 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/683984/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">Many applications never cancel any threads. They are irrelevant.</font></blockquote>

<p>99.9% of all programs (and I've picked conservative number) are irrelevant? That's novel idea to me.</p>

<blockquote><font class="QuotedText">They need do nothing and they suffer no cost (maybe a couple of instructions per syscall. If you can't afford that, hand-code your systemcalls).</font></blockquote>

<p>When proportion is <b>this</b> skewed even these two instructions make no sense: why should 99.9% of all the apps suffer at all if this could be avoided?</p>

<p>The natural response would: because I could just take bits and pieces from these 99.9% apps and use these to build these rare few apps which <b>do</b> use cancellation.</p>

<p>But as you've shown you couldn't just take random working code from working library, plug it in a program which uses cancellation and hope that the end result would work.

<p>ALL code must be carefully designed in such a program. And if ALL code is specifically written for such a program then additional burden of adding couple of pthread_setcancelstate calls here and there wouldn't be large at all!</p>

<p>The argument that "hey, I don't know where and how threads are created in this large program" wouldn't fly: if you don't know even that much about your program/library/whatever then how could you be sure that you control is enough to even try to attempt to use cancellation of threads?</p>

<blockquote><font class="QuotedText">It just needs a little care - like not logging any messages between the allocation and pushing the cleanup handler.</font></blockquote>

<p>Sure. But if that's called "a little care" then "you <b>also</b> need to call pthread_setcancelstate(PTHREAD_CANCEL_ENABLE) in each thread" wouldn't a large problem...</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/683984/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor684007"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 17:17 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/684007/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite. The program I work on for my day job does precisely that, with subsidiary threads whose primary job is ptrace()ing and waitpid()ing, but which may be commanded to go away by a controlling 'master' thread with many more jobs. All the work of such subsidiary threads is associated with a single structure relating to a specific subprocess under monitoring, and it is easy (and good style) to make sure that this structure is properly freeable at all times (you need that for decent error handling anyway). The cleanup handler then just needs to do the same 'shut down and free everything associated with the process structure' that we have to do when the subprocess dies anyway (indeed, we simply call the cleanup handler by hand in that situation).<br>
<p>
I've had problems with the multithreading in that code, but they were all races associated with mutexes and condition variables. The nature of synchronous cancellation has caused me zero problems.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684007/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor683903"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 19:07 UTC (Fri)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/683903/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are lot of programs using cancellation without mixing them with syscall and they work fine.<br>
The trick is to have the parent allocate and free all resources in advance, and use robust<br>
data structures like stacks. <br>
If C++ is broken, do not use it for thread.<br>
<p>
The fact that something is broken in some corner case does not make is useless in other case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683903/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 19:16 UTC (Fri)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/684025/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This code that supposedly works fine only works fine if it never calls into libraries, since those libraries might use malloc, or open, or mutexes, or anything else that acquires resources.<br>
<p>
pthread cancellation is very dangerous, is useful only for specialized cases, and IMO should never have been enabled by default.<br>
<p>
If it were simply disabled by default, then this performance issue would be irrelevant.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 19:40 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/684028/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But this breaks all programs that assume it is enabled by default and then proceed to call pthread_cancel() on their own threads.<br>
<p>
Changing longstanding defaults like this constitutes a break of userspace. You need a new -D flag (which, perhaps, sets a new ELF note, or simply triggers the linking in of a new crt1.o which flips the default) to ensure that this only happens to programs that are prepared for it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 19:49 UTC (Fri)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/684032/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agreed.  I'm not saying that changing the default is actually wise.  But it might be enough of a simplification and a performance benefit to make it worthwhile.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 20:19 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/684038/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A performance benefit? What performance cost is there to a single address comparison in a relatively rare path? (And as for complexity cost, well, hell, that sort of backward-compatibility burden is why systems get more complex over time, but that doesn't mean we can cavalierly throw users over the wall. codesearch.debian.net shows quite a lot of users, and yes, many of them are real users. :) )<br>
<p>
(Now I'd agree that *asynchronous* cancellation is nearly impossible to program to and has an even smaller use case than synchronous cancellation, but even *it* is useful sometimes, particularly as a transient thing; e.g. when a thread that otherwise is synchronously cancellable is doing a long-running computation that it knows does no syscalls and can be safely unwound from the cleanup handler.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 20:34 UTC (Fri)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/684040/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It prevents syscall inlining.  The impact is small but nonzero.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 17, 2016 23:12 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/684143/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmmm. I see now -- when HJ's sycall inlining does turn up, or anything like it, you don't have one address to compare to any more, you have a great heap of them all across glibc, and there is obviously no way to do any similar comparison (I can think of ridiculously overdesigned ways to do it involving searching a tree of address ranges, but they'd all be *far* too slow and blow the dcache sky-high: just no).<br>
<p>
Given that syscall inlining isn't something you can possibly turn on and off at runtime -- the inlining is, after all, into glibc, so you'd need multiple copies of glibc via hwcaps, which seems total overkill for this and would totally negate any saving via massive icache bloat -- you'd not be able to fix this by changing a *default*. You'd need to basically give up on fixing this race, or give up on fixing it this way, or break cancellation completely for everyone (a total non-starter).<br>
<p>
Hmm. Too late at night, but I'll think on this. Either I have a niggling germ of a possible idea for a fix for this at the edge of my brain, or I'm just tired and hallucinating. (Or both!)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684149"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2016 0:21 UTC (Mon)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/684149/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you could do it the way the kernel does the exception table -- just make a sorted list of pairs of starts and ends of cancellable regions.  You only need to check it when your cancellation signal is delivered, and the data cache impact of *that* is basically irrelevant.<br>
<p>
But you could do it by flipping the default if you're willing to accept a branch: just test the cancellable flag and jump out of line if needed.  This is no worse than the existing musl thing in which each cancellable syscall needs to test the cancallable flag anyway to see if it needs to cancel even without a signal being sent.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684149/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2016 10:28 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/684171/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, I assumed you were necessarily taking the cost of the cancellable test anyway (the branch is near-zero cost in the common case, because it obviously has a prediction hint). Were you trying to avoid even that?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor684159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2016 4:20 UTC (Mon)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/684159/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  you don't have one address to compare to any more</font><br>
<p>
No, but you probably have one sequence of op-codes to compare.<br>
The comparisons might be a little more complex than "memcmp" but could you not test "is this EIP value within a thunk" by comparing surrounding bytes against the standard thunk at each of the (very few) possible offsets?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684169"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2016 10:27 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/684169/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good point. And yes, you do have one sequence, it's extremely stereotyped, and it'll always be in the icache (at syscall entry, anyway). (On x86-64 -- on x86-32, this is irrelevant, because there, even the 'inlined' syscalls (INTERNAL_SYSCALL users) are still doing a GOT lookup and an indirect jump (on x86-32, anyway) to the vDSO syscall entry point.)<br>
<p>
If you can get away with scanning for this only when cancellation is actually detected, it seems that the cost would be very low, though the complexity would obviously be higher than a simple address comparison, and it would tie that part of the kernel to these fairly fine and arch-dependent details of glibc's implementation, in a way that would probably not be spotted fast if it broke :(<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684169/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684178"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2016 11:10 UTC (Mon)
                               by <b>itvirta</b> (guest, #49997)
                              [<a href="/Articles/684178/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And yes, you do have one sequence, it's extremely stereotyped, and it'll always be in the icache</font><br>
<p>
Stupid question: Does the instruction cache help if you're reading the instruction bytes as data?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684178/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2016 16:56 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/684464/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hm, no, but the L2+ caches are unified on many models (e.g. on all the Intel x86-64 CPUs I have access to, Nehalem and later), and getting stuff from L2 cache is still immensely faster than getting it from RAM, fast enough that you can often consider it free for applications like this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor684033"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 16, 2016 13:52 UTC (Sat)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/684033/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This code that supposedly works fine only works fine if it never calls into libraries, since those libraries might use malloc, or open, or mutexes, or anything else that acquires resources.</font><br>
<p>
Yes, so ? This is a static property of the code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684033/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor684307"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 19, 2016 14:40 UTC (Tue)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/684307/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another potentially daft idea: have the signal handler do nothing but set the cancel flag, but also have a flag to say when the thread is in a critical code section, that is, about to start a cancellable system call, already (or nearly already) checked the cancel flag and not yet (or only just) exited the system call. Then pthread_cancel() in the library just keeps resending the signal until the critical section flag is cleared again. Not nice, but not much cost for people who don't need cancellation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684307/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor684244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2016 17:11 UTC (Mon)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/684244/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, now if only musl supported dlclose, by the same logic. dlclose is also one of those routines that's perfectly safe when you understand how to use it. Felker just doesn't like it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor683862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 15:41 UTC (Thu)
                               by <b>karkhaz</b> (subscriber, #99844)
                              [<a href="/Articles/683862/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Editor: Musl's lead developer is called Rich Felker, not Rick.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor683863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2016 15:45 UTC (Thu)
                               by <b>jake</b> (editor, #205)
                              [<a href="/Articles/683863/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Editor: Musl's lead developer is called Rich Felker, not Rick.</font><br>
<p>
Indeed.  Fixed now.  Thanks for the report.<br>
<p>
(I will take this opportunity to remind folks that typo reports and such should go to lwn@lwn.net)<br>
<p>
jake<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/683863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor684008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is why we can't have safe cancellation points</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2016 17:21 UTC (Fri)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/684008/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A lot of this post sounded remarkably familiar, because it turns out that QEMU's linux-user code (where it emulates a binary for one architecture on a host with a different architecture, passing system calls through to the host) needs to do a very similar trick with a signal handler that has to look at the interrupted PC to see whether it was just before or just after the syscall instruction.<br>
<p>
(For QEMU the problem that has to be solved is making sure that incoming signals interrupt emulated guest system calls -- if the signal arrives before we execute the host syscall instruction we must abandon emulation of the guest syscall, otherwise we might block forever. There's no way to close the race window completely without having the signal handler check the PC to see "did we actually execute that instruction yet?".)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2016, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
