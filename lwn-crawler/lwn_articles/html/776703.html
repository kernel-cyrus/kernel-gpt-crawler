        <!DOCTYPE html>
        <html lang="en">
        <head><title>Ringing in a new asynchronous I/O API [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/776703/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/776410/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/776703/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Ringing in a new asynchronous I/O API</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 15, 2019</br>
           </div>
While the kernel has had support for <a
href="http://man7.org/linux/man-pages/man2/io_submit.2.html">asynchronous
I/O</a> (AIO) since the 2.5
development cycle, it has also had people complaining about AIO for about
that long.  The current interface is seen as difficult to use and
inefficient; additionally, some types of I/O are better supported than
others.  That 
situation may be about to change with the introduction of a <a
href="/ml/linux-fsdevel/20190112213011.1439-1-axboe@kernel.dk/">proposed
new interface</a> from Jens Axboe called "io_uring".  As might be expected
from the name, 
io_uring introduces just what the kernel needed more than anything else:
yet another ring buffer.
<p>
<h4>Setting up</h4>
<p>
Any AIO implementation must provide for the submission of operations and
the collection of completion data at some future point in time.  In
io_uring, that is handled through two ring buffers used to implement a
submission queue and a completion queue.  The first step for an application
is to set up this structure using a new system call:
<p>
<pre>
    int io_uring_setup(int entries, struct io_uring_params *params);
</pre>
<p>
The <tt>entries</tt> parameter is used to size both the submission and
completion queues.  The <tt>params</tt> structure looks like this:
<p>
<pre>
    struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u16 resv[10];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
    };
</pre>
<p>

On entry, this structure (with the possible exception of <tt>flags</tt> as
described later) should simply be initialized to zero.  On
return from a successful call, the <tt>sq_entries</tt> and
<tt>cq_entries</tt> fields will be set to the actual sizes of the
submission and completion queues; the code is set up to allocate
<tt>entries</tt> submission entries, and twice that many completion
entries.  
<p>
The return value from <tt>io_uring_setup()</tt> is a file descriptor that
can then be passed to <tt>mmap()</tt> to map the buffer into the process's
address space.  More specifically, three calls are needed to map the two
ring buffers and an array of submission-queue entries; the information
needed to do this mapping will be found in the <tt>sq_off</tt> and
<tt>cq_off</tt> fields of the <tt>io_uring_params</tt> structure.  In
particular, the submission queue, which is a ring of integer array indices,
is mapped with a call like:
<p>
<pre>
    subqueue = mmap(0, params.sq_off.array + params.sq_entries*sizeof(__u32),
    		    PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE,
		    ring_fd, IORING_OFF_SQ_RING);
</pre>
<p>
Where <tt>params</tt> is the <tt>io_uring_params</tt> structure, and
<tt>ring_fd</tt> is the file descriptor returned from
<tt>io_uring_setup()</tt>.  The addition of <tt>params.sq_off.array</tt> to
the length of the region accounts for the fact that the ring is not located
right at the beginning.  The actual array of submission-queue entries,
instead, is mapped with:
<p>
<pre>
    sqentries = mmap(0, params.sq_entries*sizeof(struct io_uring_sqe),
    		    PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE,
		    ring_fd, IORING_OFF_SQES);
</pre>
<p>
This separation of the queue entries from the ring buffer is needed because
I/O operations may well complete in an order different from the submission
order. 
The completion queue is simpler, since the entries are not separated from
the queue itself; the incantation required is similar:
<p>
<pre>
    cqentries = mmap(0, params.cq_off.cqes + params.cq_entries*sizeof(struct io_uring_cqe),
    		    PROT_READ|PROT_WRITE|MAP_SHARED|MAP_POPULATE,
		    ring_fd, IORING_OFF_CQ_RING);
</pre>
<p>
It's perhaps worth noting at this point that Axboe is working on a
user-space library that will hide much of the complexity of this interface
from most users.
<p>
<h4>I/O submission</h4>
<p>
Once the io_uring structure has been set up, it can be used to perform
asynchronous I/O.
Submitting an I/O request involves filling in an <tt>io_uring_sqe</tt>
structure, which looks like this (simplified a bit):
<p>
<pre>
    struct io_uring_sqe {
	__u8	opcode;		/* type of operation for this sqe */
	__u8	flags;		/* IOSQE_ flags */
	__u16	ioprio;		/* ioprio for the request */
	__s32	fd;		/* file descriptor to do IO on */
	__u64	off;		/* offset into file */
	void	*addr;		/* buffer or iovecs */
	__u32	len;		/* buffer size or number of iovecs */
	union {
	    __kernel_rwf_t	rw_flags;
	    __u32		fsync_flags;
	};
	__u64	user_data;	/* data to be passed back at completion time */
	__u16	buf_index;	/* index into fixed buffers, if used */
    };
</pre>
<p>
The <tt>opcode</tt> describes the operation to be performed; options
include <tt>IORING_OP_READV</tt>, <tt>IORING_OP_WRITEV</tt>,
<tt>IORING_OP_FSYNC</tt>, and a couple of others that we will return to.
There are clearly a number of parameters that affect how the I/O is
performed, but most of them are relatively straightforward: <tt>fd</tt>
describes the file on which the I/O will be performed, for example, while
<tt>addr</tt> and <tt>len</tt> describe a set of <tt>iovec</tt> structures
pointing to the memory where the I/O is to take place.
<p>
As mentioned above, the <tt>io_uring_sqe</tt> structures are kept in an
array that is mapped into both user and kernel space.  Actually submitting
one of those structures requires placing its index into the submission
queue, which is defined this way:
<p>
<pre>
    struct io_uring {
	u32 head;
	u32 tail;
    };

    struct io_sq_ring {
	struct io_uring		r;
	u32			ring_mask;
	u32			ring_entries;
	u32			dropped;
	u32			flags;
	u32			array[];
    };
</pre>
<p>

The <tt>head</tt> and <tt>tail</tt> values are used to manage entries
in the ring; if the two values are equal, the ring is empty.  User-space
code adds an entry by putting its index into <tt>array[r.tail]</tt> and
incrementing the tail pointer; only the kernel side should change
<tt>r.head</tt>.  Once one or more entries have been placed in the ring,
they can be submitted with a call to:
<p>
<pre>
    int io_uring_enter(unsigned int fd, u32 to_submit, u32 min_complete, u32 flags);
</pre>
<p>
Here, <tt>fd</tt> is the file descriptor associated with the ring, and
<tt>to_submit</tt> is the number of entries in the ring that the kernel
should submit at this time.  The return value should be zero if all goes
well.
<p>
Completion events will find their way into the completion queue as
operations are executed.  If <tt>flags</tt> contains
<tt>IORING_ENTER_GETEVENTS</tt> and <tt>min_complete</tt> is nonzero,
<tt>io_uring_enter()</tt> will block until at least that 
many operations have completed.  The actual results can be found in the
completion structure:
<p>
<pre>
    struct io_uring_cqe {
	__u64	user_data;	/* sqe-&gt;user_data submission passed back */
	__s32	res;		/* result code for this event */
	__u32	flags;
    };
</pre>
<p>
Where <tt>user_data</tt> is a value passed from user space when the
operation was submitted and <tt>res</tt> is the return code for the
operation.  The <tt>flags</tt> field will contain
<tt>IOCQE_FLAG_CACHEHIT</tt> if the request could be satisfied without
needing to perform I/O — an option that may yet have to be reconsidered
given the current concern about using the page cache as a side channel.
<p>
These structures live in the completion queue, which looks similar to the
submission queue:
<p>
<pre>
    struct io_cq_ring {
	struct io_uring		r;
	u32			ring_mask;
	u32			ring_entries;
	u32			overflow;
	struct io_uring_cqe	cqes[];
    };
</pre>
<p>
In this ring, the <tt>r.head</tt> index points to the first available
completion event, while <tt>r.tail</tt> points to the last; user space
should only change <tt>r.head</tt>.
<p>
The interface as described so far is enough to enable a user-space program
to enqueue multiple I/O operations and to collect the results as those
operations complete.  The functionality is similar to what the current AIO
interface provides, though the interface is quite different.  Axboe claims
that it is far more efficient, but no benchmark results have been included
yet to back up that claim.  Among other things, this interface can do
asynchronous buffered I/O without a context switch in cases where the
desired data is in the page cache; buffered I/O has always been a bit of a
sore spot for Linux AIO.
<p>
<h4>Advanced features</h4>
<p>
There are, however, some more features worthy of note in this interface.
One of those is the ability to map a program's I/O buffers into the
kernel.  This mapping normally happens with each I/O operation so that data
can be copied into or out of the buffers; the buffers are unmapped when the
operation completes.  If the buffers will be used many
times over the course of the program's execution, it is far more efficient
to map them once and leave them in place.  This mapping is done by filling
in yet another structure describing the buffers to be mapped:
<p>
<pre>
    struct io_uring_register_buffers {
	struct iovec *iovecs;
	__u32 nr_iovecs;
    };
</pre>
<p>
That structure is then passed to another new system call:
<p>
<pre>
    int io_uring_register(unsigned int fd, unsigned int opcode, void *arg);
</pre>
<p>
In this case, the opcode should be <tt>IORING_REGISTER_BUFFERS</tt>.  The
buffers will remain mapped for as long as the initial file descriptor
remains open, unless the program explicitly unmaps them with
<tt>IORING_UNREGISTER_BUFFERS</tt>.  Mapping buffers in this way is
essentially locking memory into RAM, so the usual resource limit that
applies to <tt>mlock()</tt> applies here as well.
When performing I/O to premapped buffers, the <tt>IORING_OP_READ_FIXED</tt>
and <tt>IORING_OP_WRITE_FIXED</tt> operations should be used.
<p>
There is also an <tt>IORING_REGISTER_FILES</tt> operation that can be used
to optimize situations where many operations will be performed on the same
file(s).
<p>
In many high-bandwidth settings, it can be more efficient for the
application to poll for completion events rather than having the kernel
collect them and wake the application up; that is the motivation behind the
<a href="/Articles/663879/">existing block-layer polling interface</a>, for
example.  Polling is most efficient in situations
where, by the time the application gets around to doing a poll, there is
almost certainly at least one completion ready for it to consume.  This
polling mode can be enabled for io_uring by setting the
<tt>IORING_SETUP_IOPOLL</tt> flag when calling <tt>io_uring_setup()</tt>.
In such rings, an occasional call to <tt>io_uring_enter()</tt> (with the
<tt>IORING_ENTER_GETEVENTS</tt> flag set) is mandatory
to ensure that completion events actually make it into the completion
queue.
<p>
Finally, there is also a fully polled mode that (almost) eliminates the
need to make any system calls at all.  This mode is enabled by setting the
<tt>IORING_SETUP_SQPOLL</tt> flag at ring setup time.  A call to
<tt>io_uring_enter()</tt> will kick off a kernel thread that will
occasionally poll the submission queue and automatically submit any
requests found there; receive-queue polling is also performed if it has
been requested.  As long as the application continues to submit I/O and
consume the results, I/O will happen with no further system calls.
<p>
Eventually, though (after one second currently), the kernel will get bored
if no new requests are submitted and the polling will stop.  When that
happens, the <tt>flags</tt> field in the submission queue structure will
have the <tt>IORING_SQ_NEED_WAKEUP</tt> bit set.  The application should
check for this bit and, if it is set, make a new call to
<tt>io_uring_enter()</tt> to start the mechanism up again.
<p>
This patch set is in its third version as of this writing, though that is a
bit deceptive since there were (at least) ten revisions of the <a
href="/ml/linux-fsdevel/20181221192236.12866-1-axboe@kernel.dk/">polled AIO
patch set</a> that preceded it.   While it is possible that the interface is
beginning to stabilize, it would not be surprising to see some
significant changes yet.  One review comment that has not yet been
addressed is Matthew Wilcox's <a
href="/ml/linux-fsdevel/20190109160036.GK6310@bombadil.infradead.org/">request</a>
that the name be changed to "<q>something that looks a little less like
io_urine</q>".  That could yet become the biggest remaining issue — as
we all 
know, naming is always the hardest part in the end.  But, once those
details are worked out, the kernel may yet have an asynchronous I/O
implementation that is not a constant source of complaints.
<p>
For the curious, Axboe has posted <a
href="http://git.kernel.dk/cgit/fio/plain/t/io_uring.c">a complete
example</a> of a program that uses the io_uring interface.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Asynchronous_IO">Asynchronous I/O</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#io_uring">io_uring</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/776703/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor776826"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 5:45 UTC (Wed)
                               by <b>unixbhaskar</b> (guest, #44758)
                              [<a href="/Articles/776826/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Whoa! good one Jens! Your hard work pays off man! thank you. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776826/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor776828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 6:58 UTC (Wed)
                               by <b>mokki</b> (subscriber, #33200)
                              [<a href="/Articles/776828/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Lots of software would also benefit from async directory listings, file open/close etc.<br>
<p>
Did anything ever come out of the various syslets/fibrils/sys_indirect ways of making most syscalls async?<br>
<p>
There was lots of discussion in 2007, see: <a href="https://lwn.net/Articles/221913/">https://lwn.net/Articles/221913/</a> and<br>
<a href="https://lwn.net/Articles/259068/">https://lwn.net/Articles/259068/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776847"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 13:00 UTC (Wed)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/776847/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I sometimes wonder whether something as mundane as tar should use parallel I/O to use RAID efficiently (assuming files smaller than the chunk size).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776847/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 14:22 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/776854/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Not just RAID - any device that can do multiqueue I/O will benefit from parallel I/O, such as an NVMe SSD (which can have 65,536 parallel queues to the device).
      
          <div class="CommentReplyButton">
            <form action="/Articles/776854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor776956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 1:03 UTC (Thu)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/776956/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have it on my todo list to write a fully CPU/IO-parallel ZIP implementation (because it's fairly straightforward), with an article around it highlighting most of the traditional UNIX tooling is utterly obsolete on pretty much all modern devices. Naturally it can't really benefit from the work here due to the parent comment, but yeah, the problem is very real, and frankly an entirely ridiculous state of affairs<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776979"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 12:30 UTC (Thu)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/776979/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So you want to demonstrate that something is obsolete by implementing… an obsolete compression algorithm? :-)<br>
<p>
(zlib/deflate is still around pretty much only due to huge transition costs, and a fragmented market among the alternatives. Try something like zstd if you want to make a clean break.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776979/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 12:33 UTC (Thu)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/776980/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's always newer and better technology around, but tech is only useful when it's compatible with what you already have :)  And ZIPs are eeeverywhere<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor777276"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2019 10:09 UTC (Tue)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/777276/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be convenient to have a system call that declares 'I plan to read this file in the near future'.  The kernel would make a best effort to get that file into the page cache, using background I/O, while your process continues.  So if you are about to zip up a directory, call plan_to_read() on each file, then continue reading them sequentially as normal.  It wouldn't be quite as fast as a true parallel implementation, but for some tasks it could give you 80% of the performance gains without having to rewrite your creaky old sequential code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777276/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2019 11:35 UTC (Tue)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/777277/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't this basically what posix_fadvise() gives us already? But IIRC that interface currently or previously blocked while readahead happened.<br>
<p>
For zipping, imagine something like a 100k item maildir of tiny 1.5kb messages. While the compression is still relatively expensive, a huge chunk of the operation will be wasted on ceremonial serialized filesystem round-trips (open/close/read/stat/getdents/etc). To avoid that I'm not sure there is any way around it except a whole bunch of threads keeping as many FS operations  in flight (either doing the CPU bits or any IO bits for uncached data) to get even close to a genuinely busy computer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777282"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2019 12:22 UTC (Tue)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/777282/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, I was thinking of a few large files, where the overhead really is in I/O and not in bookkeeping.<br>
<p>
How about a generalized stat() that lets you open a directory and get info on all the files it contains?  That would save a lot of time, and not just for parallel code.  Network filesystems, for example.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777282/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor777283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 22, 2019 12:38 UTC (Tue)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/777283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You mentioned posix_fadvise().  That is useful but not quite the stupidly simple interface I had in mind.  It requires an open file handle.  I envisaged a call that takes a filename and nothing else, works entirely in the background, and does not fail (not even if the file doesn't exist or whatever; it just does nothing in that case).<br>
<p>
You could then sprinkle these calls all over your code -- including scripting languages -- and get a handy speedup without having to do any real programming.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor780716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2019 1:53 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/780716/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It would be convenient to have a system call that declares 'I plan to read this file in the near future'.</font><br>
<p>
The readahead system call does that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/780716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor776868"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 15:27 UTC (Wed)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/776868/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Honestly, the easiest path to something syslets-like is to express the kernel program in eBPF. The nice thing about this approach is that eBPF is expressive enough to include arbitrary error-handling and cleanup logic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776868/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor776869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about async metadata</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 15:48 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/776869/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's far less disruptive (to performance) to simply use a thread or two to do your directory-level operations. Actual data R/W on the other hand can take every performance improvement you can throw at it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor776841"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 10:03 UTC (Wed)
                               by <b>kitanatahu</b> (guest, #44605)
                              [<a href="/Articles/776841/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In my opinion it would be a hell of a lot more useful if it were pollable using the already existing polling mechanisms, including epoll, and it wouldn't get "bored".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776841/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 18:07 UTC (Wed)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/776915/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
io_uring will grow support for IORING_OP_POLL, but it's outside the scope of the initial implementation. This will work similarly to the recently added IOCB_CMD_POLL support for aio.<br>
<p>
Apart from that, I do think you're mixing up the polling with the io polling. One provides a way to signal when data is ready, the other skips IRQs in favor of busy polling for completion events.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 3:12 UTC (Thu)
                               by <b>samroberts</b> (subscriber, #46749)
                              [<a href="/Articles/776960/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you can forgive the OP for calling what epoll() does "polling", though it doesn't fit your definition, given its the name of the syscall!<br>
<p>
The point stands: io_uring should be easily useable with poll/select/epoll so it can be integrated with existing event loop based code, networking code in particular are heavy users of these calls. Specifically, this fd<br>
<p>
<font class="QuotedText">&gt; The return value from io_uring_setup() is a file descriptor that can then be passed to mmap() to map the buffer into the process's address space.</font><br>
<p>
should be epoll()able.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776961"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 3:28 UTC (Thu)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/776961/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm addressing what is a misconception in the original comment. It referred to the "bored" part, which is when you have the kernel side doing polling for you. That has nothing to do with epoll(), and epoll() would not be a solution for this at all.<br>
<p>
If the ring_fd should be pollable, in terms of epoll, absolutely. That would be trivial to add. It would NOT work for IORING_SETUP_IOPOLL for obvious reasons, as you can't sleep for those kinds of completions. But for "normal", IRQ driven IO, adding epoll() support for the CQ side of the ring_fd is straight forward. On the SQ ring side, there's nothing to epoll for. The application knows if the ring is writeable (eg can hold new entries) without entering the kernel.<br>
<p>
Outside of that, my IOCB_CMD_POLL reference has to do with this:<br>
<p>
<a href="https://lwn.net/Articles/743714/">https://lwn.net/Articles/743714/</a><br>
<p>
and adding IORING_OP_POLL for similar functionality on the io_uring side.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776961/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 16:26 UTC (Thu)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/777020/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just to follow up on this, if you check the latest repo, the ring_fd is now both pollable (in terms of poll(2)/epoll(2), not io-pollable), and io_uring also supports IORING_OP_POLL to offer the same functionality that aio does in that regard.<br>
<p>
I believe this caters to both of your needs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 23:16 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/777067/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is such a nice interface, I'm wondering if heavy ioctl() users might be able to reuse some of these ideas to redo their ioctl madness into a nice high-performance command/response ring :) I mean yeah it's not exactly simple for userspace to use, but if the complexity is wrapped away from users its properties are seriously slobbersome.<br>
<p>
(yes, I help maintain one of those monsters, making heavy use of ioctl() passing intricate structures into and out of the kernel, and the massive use of ioctl() is one thing I at least am hoping to get rid of in the process of getting it ready for upstreaming.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 23:34 UTC (Thu)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/777069/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since it already has all the mechanics to do buffered IO async, any ioctl could easily be channeled through the API. We're already grabbing the files/mm of the original process. Depending on how many arguments you need to the ioctl, we'd need to tweak the sqe a bit.<br>
<p>
With liburing, it should be _very_ easy for applications to use. If you go native, yes, you need to be a bit more careful, and it's more hairy. But even with the basic support liburing has now, you just do:<br>
<p>
{<br>
struct io_uring ring;<br>
struct io_uring_sqe *sqe;<br>
struct io_uring_cqe *cqe;<br>
<p>
io_uring_queue_init(queue_depth, &amp;ring, 0);<br>
<p>
sqe = io_uring_get_sqe(&amp;ring);<br>
sqe-&gt;opcode = IORING_OP_READV;<br>
sqe-&gt;fd = fd;<br>
[...]<br>
<p>
io_uring_submit(&amp;ring);<br>
<p>
io_uring_wait_completion(&amp;ring, &amp;cqe);<br>
}<br>
<p>
as a very basic example.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777079"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2019 4:21 UTC (Fri)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/777079/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Might even makes sense to just move away from an ioctl, and provide an sqe entry into the driver through the file_operations, for instance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777079/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2019 18:57 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/777163/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We're in "passing massive structures and/or arrays of structures" land, and trying to *not* produce a horror show like perf_event_open() is fairly high on my priority list! (Though, really, arguing against myself: the reason perf_event_open() is horrifying is that it does a lot, and honestly the same would be true of any attempt to wrap it in a uring, or in anything else. It's not really a win to move from 'this ioctl/syscall has security holes because the interface has too many edges to test exhaustively' to 'this uringed interface has security holes because the interface has too many edges to test exhaustively', alas. :( )<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor777164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2019 19:00 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/777164/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ooh that's honestly nicer than plain read()/write() would be. No -EINTR worries, no short reads, the only bit that makes me squint is the cqe/sqe acronyms, which are perhaps too concise to be easily understandable (it's a bit longer, but maybe _cmd and _stat suffixes would be easier to read? You're really only granting yourself one variable letter is the existing scheme, which is... a small naming budget.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 19, 2019 20:27 UTC (Sat)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/777167/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
sqe and cqe are for “submit” and“completion” queues. Your confusion demonstrates the need for less brief identificators :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777176"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2019 10:20 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/777176/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, exactly. I was confused despite being sure I would be confused and checking the parent article before posting (my fault, not the article's).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777176/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor777452"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2019 12:35 UTC (Thu)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/777452/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What is the mechanics of doing buffered AIO? I faintly recall all those old attempts (syslets, fibrils, whatever) failed partly because there was no natural in-kernel context for progressing those IO's? An in-kernel threadpool is of course always a possibility, but is that noticeably better than a user-space threadpool?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777452/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor776898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Physically-contiguous buffers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 16:14 UTC (Wed)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/776898/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This looks awesome.<br>
<p>
Regarding IORING_REGISTER_BUFFERS, would it be possible to have the kernel use high-order allocations (if available) to get larger physically-contiguous buffers?  If you are using the same buffers for DMA over and over again, then setting up a larger physically-contiguous buffer would reduce the number of scatterlist entries required for each I/O.  For example, imagine you are submitting 1 MiB per I/O.  With 4096-byte pages, that would take 256 scatterlist entries.  But with high-order allocations, you might be able to do it with just a few scatterlist entries, saving a lot of overhead.  This could be done either by having the kernel allocate the memory using high-order allocations and then letting userspace mmap() it, or by trying to compact the memory when it is submitted to IORING_REGISTER_BUFFERS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776911"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Physically-contiguous buffers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 18:03 UTC (Wed)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/776911/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not only that, but you could also pre-map the SG lists, instead of having to do map SG and unmap SG for each IO. Right now the registered buffers only avoid the get_user_pages() and put_pages() for each IO, which is (by far) the biggest overhead. But if we fix the kernel parts as well, then we can avoid the dma map/unmap for each IO. That'd bypass the split as well, some quick mental math shows we should be able to kill ~5% of the overhead on my box with that.<br>
<p>
In general we have various pieces of low hanging fruit on the block layer side, which are readily apparent now that we have an efficient interface into the kernel. Work in progress! But I'd like to wrap up io_uring first.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776911/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776950"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Physically-contiguous buffers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 23:31 UTC (Wed)
                               by <b>ms-tg</b> (subscriber, #89231)
                              [<a href="/Articles/776950/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This sort of comment by the patch author is a major example of the value of LWN<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776950/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor776968"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Physically-contiguous buffers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 9:45 UTC (Thu)
                               by <b>nilsmeyer</b> (guest, #122604)
                              [<a href="/Articles/776968/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And you could potentially allocate the buffers as huge pages, right? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776968/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor776899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 16:15 UTC (Wed)
                               by <b>me@jasonclinton.com</b> (subscriber, #52701)
                              [<a href="/Articles/776899/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  It's perhaps worth noting at this point that Axboe is working on a user-space library that will hide much of the complexity of this interface from most users.</font><br>
<p>
What's the procedure for a user-space library tightly coupled to a kernel API, like this one, getting into glibc (or any of the rest of the libcs)?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 16:19 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/776902/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can just leave it as a separate library, like libaio is now, and libattr, and libacl, and many others. (Though if it's useful and glibc wants to use it itself, it's not unimaginable that it might find its way in there in time -- but glibc has harsh backward-compatibility constraints that argue in favour of a trial period in an external library in any case, until we know whether the API the library provides works well.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor776914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 18:05 UTC (Wed)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/776914/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
System calls should go into libc, but anything else will reside in liburing. You can clone that here:<br>
<p>
git://git.kernel.dk/liburing<br>
<p>
though not a lot of items are in there yet. It does contain helpers to setup/teardown the ring, and submit/complete helpers for applications that don't want (or need) to muck with the ring itself. This will grow some more features, the intent is that most applications will _probably_ end up using that instead of handling all the details themselves.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777066"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 23:12 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/777066/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nice library name. The plan is to lure people into using it, right? :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777066/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 17, 2019 23:30 UTC (Thu)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/777068/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Don't give away all my secrets :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor777092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2019 10:36 UTC (Fri)
                               by <b>NAR</b> (subscriber, #1313)
                              [<a href="/Articles/777092/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My first association/misread was uring - urine and that's not that nice name. Maybe I just need new glasses.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777094"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2019 12:06 UTC (Fri)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/777094/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not only yours.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777094/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 18, 2019 17:22 UTC (Fri)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/777136/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's the brain making that leap, since uring isn't a word it currently recognizes. This will go away as it becomes a bit more ubiquitous. I see no reason to change the name.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777484"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2019 16:09 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/777484/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can't you stick a "t" in there? uring -&gt; turing <br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777484/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor776927"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 19:24 UTC (Wed)
                               by <b>arjan</b> (subscriber, #36785)
                              [<a href="/Articles/776927/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
	void	*addr;		/* buffer or iovecs */<br>
<p>
<p>
hmm that makes 32/64 compat funky.. wonder if it really should just be a u64<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776927/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor776928"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 19:30 UTC (Wed)
                               by <b>axboe</b> (subscriber, #904)
                              [<a href="/Articles/776928/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is, check the git repo!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776928/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor776936"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2019 20:09 UTC (Wed)
                               by <b>HIGHGuY</b> (subscriber, #62277)
                              [<a href="/Articles/776936/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Would the interface support operations that require 2 file descriptors, like splicing from a file to a socket and vice versa? I have the impression it doesn’t but could have easily missed something.<br>
<p>
Slightly more complex operations could be useful in combination with primitives like the P2P PCIe transfers that are being worked on to avoid going through main memory altogether.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/776936/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor777180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 20, 2019 13:22 UTC (Sun)
                               by <b>zse</b> (guest, #120483)
                              [<a href="/Articles/777180/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nice that we're finally getting a decent AIO option.<br>
<p>
I haven't found the complete list of opcodes that are proposed, so don't know if this is already in the works, but I'd think you'll also need synchronization primitives (e.g. a barrier so that all io ops before it need to complete before those after the barrier can start).<br>
<p>
In general this proposal kind of reminds me of the command queues you have for graphics hardware (OpenGL/Vulkan). I'm wondering if there is potential for (partial) unification or at least mutual inspiration...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor777453"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 24, 2019 12:37 UTC (Thu)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/777453/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For inspiration in the IO world, there's IOCP (<a href="https://en.wikipedia.org/wiki/Input/output_completion_port">https://en.wikipedia.org/wiki/Input/output_completion_port</a> ).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/777453/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor788131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How to register more files while using some registered files?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2019 10:35 UTC (Sat)
                               by <b>hnakamur</b> (guest, #123503)
                              [<a href="/Articles/788131/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My understanding is you can register new set of file descriptors after unregistering all of old ones.<br>
<p>
io_uring_register(ring_fd, IORING_REGISTER_FILES, fds, nr_files);<br>
io_uring_register(ring_fd, IORING_UNREGISTER_FILES);<br>
io_uring_register(ring_fd, IORING_REGISTER_FILES, fds2, nr_files2);<br>
<p>
But, what to do if you want to add some more file descriptors while using some of already registered<br>
file descriptors?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/788131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor788803"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ringing in a new asynchronous I/O API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 17, 2019 19:30 UTC (Fri)
                               by <b>crzbear</b> (guest, #132097)
                              [<a href="/Articles/788803/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
this sounds awesome<br>
<p>
is there any particular reason the kernel has to allocate those buffers<br>
couldn't they be passed from userspace in the setup call<br>
and then the kernel maps those into its address space<br>
<p>
while this might obviously lead to not properly aligned buffers,<br>
the kernel can check that and return with an error if needed<br>
<p>
this would do away with the mmapping<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/788803/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor950744"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Guidance on using io_uring to support 60,000+ TCP connections with &lt;1ms RTT</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2023 2:30 UTC (Thu)
                               by <b>Tushar</b> (guest, #167911)
                              [<a href="/Articles/950744/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi,<br>
<p>
I am working on building a new application which is required to support 60,000+ tcp connections on a single server (preferably a single POSIX thread) with &lt;1ms RTT. I am considering using io_uring for this.<br>
<p>
I have not found any data for similar application of io_uring for other applications. Do you have some benchmark that I might refer to to see if something like this may be possible.<br>
<p>
Thanks for your time and help.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/950744/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
