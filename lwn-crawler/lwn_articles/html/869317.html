        <!DOCTYPE html>
        <html lang="en">
        <head><title>Key Rust concepts for the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/869317/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/869382/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/869317/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Key Rust concepts for the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 17, 2021</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2021-Kangrejos">Kangrejos</a>
</div>
The <a href="/Articles/869145/">first day</a> of the online <a
href="https://kangrejos.com/">Kangrejos conference</a> was focused on
introducing the effort to bring the <a
href="https://www.rust-lang.org/">Rust programming language</a> into the 
Linux kernel.  On the second day, conference organizer Miguel Ojeda shifted
to presenting the Rust language itself with an emphasis on what Rust can
provide for kernel development.  The result was a useful resource for
anybody who is curious about this project, but who has not yet had the time
to become familiar with Rust.
<p>
Ojeda began by stressing that the talk was not meant to be a
tutorial; to actually learn the language, one should get a good book and
work from that.  There is no way to cover everything needed in an hour of
talk (a fact that became abundantly clear as time went on), but he hoped to
be able to show some of the key ideas behind Rust. 
In the end, though, the only way to really understand the language is to
sit down and write some code.
<p>
<h4>Reading material</h4>
<p>
There are a number of resources available for developers wanting to learn
Rust, including several books.  The definitive book appears to be <i>The
Rust Programming Language</i>, which is <a
href="https://doc.rust-lang.org/book/title-page.html">available online</a>
for free.  The book is a good introduction, he said, and is also an example
of the documentation style that pervades the Rust project.  Developers who
are specifically interested in kernel development need not read the whole
thing; much of the discussion on concurrency, for example, is not
applicable to the kernel environment.
<p>
<a
href="https://www.oreilly.com/library/view/programming-rust-2nd/9781492052586/"><i>Programming
Rust</i></a> is also quite nice, he said.  It is aimed at experienced
programmers, and thus may be useful for kernel developers.  This book is
the only resource on his list that is not freely available, though.
For readers who want to jump right in, <a
href="https://doc.rust-lang.org/rust-by-example/"><i>Rust by
Example</i></a> presents a series of exercises, each of which introduces a
new language feature.
<p>
Then, there is <a href="https://doc.rust-lang.org/nomicon/"><i>The
Rustonomicon</i></a>.  This book, which is not complete, focuses on the
challenges of writing unsafe Rust in particular.  If the Rust-for-Linux
project's goals 
are met, driver writers will not need to write unsafe Rust and, thus, may
not need this book.  There is a lot of gritty, low-level material in this
book, but it 
also demonstrates a key point: most Rust developers should never have to
deal with the language at this level.
<p>
Finally, <a href="https://doc.rust-lang.org/stable/reference/"><i>The Rust
Reference</i></a>, which is also incomplete, is a good book for "people who
like to read language standards".  Most Rust developers will not need it.
Ojeda summarized this section by suggesting either of the <i>The Rust
Programming Language</i> or <i>Programming Rust</i> for most developers.
<p>
The Rust project offers a lot of other documentation too, of course.  For
the C language, Ojeda said, the standard <i>is</i> the documentation, but
Rust is different.  Documentation is everywhere, full of explanations and
examples, and often generated directly from the code.  A similar approach
is being taken to the documentation generated by the kernel effort; it is
being written using <a
href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">rustdoc</a>
rather than the kernel's Sphinx-based system.  How to integrate those two
bodies of documentation remains an open question.
<p>
<a href="/Articles/869321/"><img
src="https://static.lwn.net/images/conf/2021/rust/CompilerExplorer-sm.png" alt="[Compiler
Explorer]" title="Miguel Ojeda shows Compiler Explorer"
class="rthumb"></a>

<h4>Tools</h4>
<p>
Ojeda moved on to a couple of tools that are useful for looking at Rust code
and the machine code that it is compiled to.  One of those is the <a
href="https://play.rust-lang.org/">Rust playground</a>, which can build
code, run linters, examine assembly code, and more.
<p>
That said, he prefers <a href="https://godbolt.org/">Compiler Explorer</a>;
it offers a lot of the same features but is not limited to Rust.  It can be
used to compare assembly output produced by different languages, for
example, and features a nice basic-block display for that purpose.
Compiler Explorer can also run the code in question and display the
results.
<p>
<h4>The language</h4>
<p>
While some people describe Rust as "a safer C", Ojeda doesn't like that
term.  It's more like a version of C with a safer type system, which is not
the same as being safety-critical.  Rust can also be described as a
"cleaned-up C", he said.  As an example, he presented a snippet of similar
code in three languages:
<p>
<pre>
    map(v, [](const auto &amp; x) { return x.get(); });   // C++
    map(v, lambda x: x.get())    # Python
    map(v, |x| x.get());  // Rust
</pre>
<p>
The Rust version is just cleaner and easier, he said.  C++ may contain a
lot of useful features, but developers often fear to use them; Rust 
makes it all easier.
<p>
He spent some time on the concept of "safety" in Rust, a discussion that
repeated a fair amount from the first day.  Rust is "safe" in that it has
no undefined behavior; there are no situations where "the compiler has the
freedom to do crazy things".  Many undesirable behaviors, including kernel
panics, memory leaks, and integer overflows, are well defined and, thus,
Rust-safe (the compiler can be made to
check for overflows though).  And, of course, logic errors are "safe"; the
language cannot guarantee that a program does what the developer intended.
<p>
But many other types of problems can be eliminated by coding in safe Rust.
As an example of undefined behavior, Ojeda showed a simple C function:
<p>
<pre>
    int f(int a, int b) {
        return a/b;
    }
</pre>
<p>
There are two ways that this function can wander into undefined behavior.
The obvious one is if the caller passes zero for <tt>b</tt>; if that
happens, the compiler is allowed to produce any result it likes.  The other
undefined situation
comes about if <tt>a</tt> is <tt>INT_MIN</tt> and <tt>b</tt>
is&nbsp;<tt>-1</tt>.  There is no positive equivalent of the largest
negative integer in the <a
href="https://en.wikipedia.org/wiki/Two%27s_complement">two's
complement</a> representation, so the result of the division cannot be
represented.  Once again, the compiler is allowed to improvise when that
happens. 
<p>
One can write a similar function in Rust:
<p>
<pre>
    pub fn f(a: i32, b: i32) -&gt; i32 {
        a/b
    }
</pre>
<p>
Using Compiler Explorer, Ojeda showed that this function, when compiled,
contains tests for both of the above undefined-behavior cases.  If either
is encountered, the program will abort.  That may not be what the
programmer wanted, but neither is continuing to run in an undefined state.
<p>
There was some brief discussion of the performance cost for all of these
checks.  It certainly is not zero, but nobody seems to have measured what
the impact really is in a performance-critical situation.  Ojeda pointed
out that, in the worst case, code can be put into an unsafe block, which
will remove all of those checks.  "Unsafe" was often described as an
"escape hatch" during this conference — a way to remove many of the
constraints placed by the language when they become too heavy.
<p>

There are also various tricks that can be applied to show the compiler that
certain situations are impossible, at which point it will omit the
checks automatically.  If one defines a bounded-integer type, for example,
the compiler knows that its value will be within its bounds and may not
need to perform overflow checks.  This technique often involves putting the
necessary checks into a constructor, where they only need to be done once.

<p>
Ojeda provided one other example, being C code in a function that looks
like this:
<p>
<pre>
    int x;  /* not initialized */

    while (f())
        x = 42;
    return x;
</pre>
<p>

Looking at the assembly output for this function, he pointed out that the
compiled code just returns a constant 42.  The loop body that assigns to
<tt>x</tt> may never have executed, but to reference <tt>x</tt> in that
case puts the program into undefined behavior.  The compiler is allowed to
assume that this will never happen; in that worldview, <tt>x</tt>
<i>must</i> be assigned the value&nbsp;42.  Rust, instead, will throw a
compile-time error in
this case and force an explicit initialization of the variable.
<p>
Laurent Pinchart noted that developers must train their brains to avoid
undefined behavior when working in either language.  The difference is that
the Rust 
compiler will catch mistakes, while a C compiler will often remain silent.
After training your brain with a language like Rust, he said, the result
will often be writing better C code as well.
<p>
The time for the session had long since run out by this point, but Ojeda
pressed through a series of additional slides describing other Rust language
features that are relevant to kernel developers.  These include union types
that don't allow access to the wrong member, implicit freeing of
dynamically allocated objects, handling signed integer overflow, mechanisms
for avoiding data races, and 
more.  There is, in short, a lot in Rust for systems developers — much more
than can be covered in a brief conference session.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Kangrejos-2021">Kangrejos/2021</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/869317/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor869640"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 0:23 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/869640/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Ojeda pointed out that, in the worst case, code can be put into an unsafe block, which will remove all of those checks.</font><br>
<p>
Not sure if they have been correctly quoted, but to be clear, &quot;unsafe { a/b }&quot; does *not* remove the division-by-zero check or the overflow check. It is a common misconception that &quot;unsafe removes all checks&quot;. In fact almost all checks still apply. &quot;unsafe&quot; enables five specific &quot;superpowers&quot;, and that&#x27;s all it does:<br>
<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#unsafe-superpowers">https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#u...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869640/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869665"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 7:14 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/869665/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, to get rid of the division-by-zero check you have to use unchecked_div(a,b), which obviously requires unsafe. But this is nightly and should therefore not be used in the kernel. <br>
<p>
You can get rid of the overflow check by using wrapping division. This even works without unsafe, as INT_MIN/-1 in wrapping semantics is well defined, i.e., INT_MIN.<br>
<p>
And I just realize that the article states that -INT_MAX/-1 is undefined. Of course -INT_MAX/-1 is simply INT_MAX.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869665/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869732"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 13:23 UTC (Sat)
                               by <b>PengZheng</b> (subscriber, #108006)
                              [<a href="/Articles/869732/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
At first I was confused by the -INT_MAX/-1 statement, then saw your comment.<br>
Thanks for your clarification.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869732/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor869737"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 14:02 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/869737/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Of course -INT_MAX/-1 is simply INT_MAX.</font><br>
<p>
I had to stare at this for a moment. Yes, it should say INT_MIN / -1 is undefined. Perhaps our Editor can consult his notes and, if that&#x27;s what was actually said, correct the article, or else, point out in a parenthetical that it should have been INT_MIN.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869737/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor869742"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 14:24 UTC (Sat)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/869742/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But this is nightly and should therefore not be used in the kernel.</font><br>
<p>
Note that we currently use quite a few of unstable features (of course, we want to minimize them as soon as possible).<br>
<p>
<font class="QuotedText">&gt; You can get rid of the overflow check by using wrapping division.</font><br>
<p>
Indeed. I think having all the wrapping/saturating/... operations in `core` is a nice feature. In related news, C23 is getting checked integer operations (N2683).<br>
<p>
<font class="QuotedText">&gt; Of course -INT_MAX/-1 is simply INT_MAX.</font><br>
<p>
I told Jonathan about the typo yesterday, but he is likely very busy with LPC coming up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869742/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor869745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">INT_MAX</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 14:27 UTC (Sat)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/869745/">Link</a>] 
      </p>
      
      </div>
      </summary>
      It looks like somebody (other than me) fixed that error, apologies for the mistake.


      
          <div class="CommentReplyButton">
            <form action="/Articles/869745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor869726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 14:06 UTC (Sat)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/869726/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Not sure if they have been correctly quoted, but to be clear, &quot;unsafe { a/b }&quot; does *not* remove the division-by-zero check or the overflow check.</font><br>
<p>
I assume &quot;code&quot; here is used in the general sense, not the literal `a / b` expression copy-pasted into an `unsafe` block.<br>
<p>
In the actual talk, the assembly generated for different examples was shown, including e.g. a comparison with `unchecked_*()` etc.<br>
<p>
<font class="QuotedText">&gt; It is a common misconception that &quot;unsafe removes all checks&quot;. In fact almost all checks still apply. &quot;unsafe&quot; enables five specific &quot;superpowers&quot;, and that&#x27;s all it does:</font><br>
<p>
What is critical to understand is that `unsafe` gives the burden of the UB-less proof to the user. What rules are or not in place is second-order for maintainers evaluating Rust.<br>
<p>
Moreover, saying &quot;almost all checks still apply&quot; is not particularly useful, because one still needs to know all the rules. In fact, I find the statement can be misleading for newcomers -- they may get overconfident thinking the compiler is going to catch &quot;almost all&quot; soundness violations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2021 0:42 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/869825/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I haven&#x27;t done any teaching in this space and I rarely use &quot;unsafe&quot;, but AFAIK the extra review required for &quot;unsafe&quot; code is simply checking that every use of those five superpowers is valid.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869826"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2021 0:44 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/869826/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Which makes me wonder if it would be a good idea for Rust to support &quot;limited unsafe&quot; blocks that enable a specific superpower. E.g. &quot;unsafe(call) { unsafe_function(); }&quot;, &quot;unsafe(deref) { *x = 0; }&quot;, &quot;unsafe(mut_global) { global = 100; }&quot; etc<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869826/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869829"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2021 2:20 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/869829/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The biggest current trip hazard is that by default an unsafe function&#x27;s entire body is allowed to be unsafe.<br>
<p>
That is, having declared your function unsafe (meaning a caller ought to read your documentation to ensure they use it safely), you are free to do anything unsafe inside it, even if you didn&#x27;t intend to.<br>
<p>
There is a (default off) lint to warn you that this might be a bad idea, and I especially encourage you to use this if you write unsafe functions that are, from Rust&#x27;s point of view, technically safe (e.g. they actually control important hardware, and so callers must read your documentation to use them safely or bad things might happen, but they will not cause Undefined Behaviour as far as Rust is concerned and so do not technically need Rust&#x27;s unsafe &quot;super powers&quot;). The reason the default isn&#x27;t default on is that many common unsafe functions have line 1-2 lines inside them, and those are genuinely unsafe code, so with the lint you&#x27;d be adding redundant unsafe blocks inside these tiny unsafe functions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869829/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869834"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2021 10:11 UTC (Tue)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/869834/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There is a (default off) lint to warn you that this might be a bad idea</font><br>
<p>
Indeed -- in Rust for Linux we are already using `unsafe_op_in_unsafe_fn` (as an error, in fact, rather than a warning) and I hope it becomes the default in a future Rust edition.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869834/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor869833"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2021 9:49 UTC (Mon)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/869833/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I haven&#x27;t done any teaching in this space and I rarely use &quot;unsafe&quot;, but AFAIK the extra review required for &quot;unsafe&quot; code is simply checking that every use of those five superpowers is valid.</font><br>
<p>
This is correct, except for the &quot;simply&quot; ;)<br>
<p>
Being able to prove those uses are sound can range from trivial to very complex.<br>
<p>
For instance, it is trivial to know a dereference is valid if you just acquired a valid pointer within the same function. But in other cases the reasoning is non-local -- the &quot;safety boundary&quot; might be the type or the module.<br>
<p>
Another example is doing FFI. It requires understanding the safety preconditions of a foreign function, which could be documented or not. If not documented, then unraveling that is likely to require further non-local reasoning. And, of course, all this in a different language.<br>
<p>
Another complicating factor is that the `unsafe` rules are not perfectly specified, yet (yes, the &quot;superpowers&quot; are clearly defined, but those are just the &quot;API&quot;, so to speak).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869833/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor869733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 13:29 UTC (Sat)
                               by <b>PengZheng</b> (subscriber, #108006)
                              [<a href="/Articles/869733/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
    int x;  /* not initialized */<br>
<p>
    while (f())<br>
        x = 42;<br>
    return x;<br>
<p>
IIRC, Coverity can catch this kind of error. <br>
If a static analysis tool can, so can a compiler like GCC in the future?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869738"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 14:42 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/869738/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A few problems:<br>
<p>
1. Because the language does not outright forbid this construction, these will necessarily be optional diagnostics. C has been around for decades at this point and we can say from experience that (to a first approximation) none of those who most need them will enable the optional diagnostics.<br>
<p>
2. Because the language does not outright forbid this _type_ of construction, there may be cases where the programmer believes, correctly or otherwise, that forcing them to eliminate Undefined Behaviour costs performance, which invariably C programmers are loathe to accept. So those cases become reasons not to have the general warning, or, if it exists, not to enable it, particularly on large codebases like Linux.<br>
<p>
3. Outright forbidding Undefined Behaviour is safer because it forces the language designers and compiler developers to address any corner cases. Without this you get a mismatch between the set of things the language actually defines, and the set of things diagnosed by your tools as Undefined Behaviour, with some things slipping through the gap between the two.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869738/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor869754"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 17:12 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/869754/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It certainly could do. GCC already has to understand whether a loop is bounded or unbounded for various -ftree-* optimisations, and it annotates variable assignments for SSA opts.<br>
<p>
The downside is it needs higher settings than -O0 to understand code at that depth, but that&#x27;s true of many optimising compilers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869754/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor869766"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 19:17 UTC (Sat)
                               by <b>dave_malcolm</b> (subscriber, #15013)
                              [<a href="/Articles/869766/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      FWIW, I've implemented that for GCC 12 (with -fanalyzer):

https://godbolt.org/z/Tjojofjzo

<pre>
warning: use of uninitialized value 'x' [CWE-457] [-Wanalyzer-use-of-uninitialized-value]
    9 |   return x;
      |          ^
  'test': events 1-3
    |
    |    7 |   while (f())
    |      |          ^
    |      |          |
    |      |          (1) following 'false' branch...
    |    8 |     x = 42;
    |    9 |   return x;
    |      |          ~
    |      |          |
    |      |          (2) ...to here
    |      |          (3) use of uninitialized value 'x' here
    |
</pre>



      
          <div class="CommentReplyButton">
            <form action="/Articles/869766/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869770"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2021 20:34 UTC (Sat)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/869770/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks a lot David for your work -- I think it is invaluable.<br>
<p>
The analysis seems to bail out when the address is taken (e.g. <a href="https://godbolt.org/z/xE6deTTTG">https://godbolt.org/z/xE6deTTTG</a>) for some reason, but not in all cases (see second example where it seems to be analyze the body of `g`).<br>
<p>
Also, it seems the warning does not appear if optimizations are enabled, is that expected?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869770/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2021 21:28 UTC (Sun)
                               by <b>dave_malcolm</b> (subscriber, #15013)
                              [<a href="/Articles/869821/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for &quot;taking it for a spin&quot; :)<br>
<p>
Re your 1st example: for better or worse, the analyzer works on the SSA representation.  Taking the address of x means gcc doesn&#x27;t use ssa names for x, and this changes what the analyzer &quot;sees&quot; (which can be seen with  -fdump-ipa-analyzer=stderr)<br>
<p>
Re your 2nd example: g has an empty body, so the analyzer &quot;knows&quot; that it doesn&#x27;t write to x, and that x is still uninitialized.  (this can be seen with -fanalyzer-verbosity=4)<br>
<p>
Optimizations affecting the output is another side-effect of my choice to use the SSA representation (which gains us some things, but costs us others...)  I may need to revisit that choice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor870366"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2021 14:27 UTC (Fri)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/870366/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
These days GCC&#x27;s uninitialized variable warning is disabled in the kernel because apparently the latest version is quite buggy.  Nathan Chancellor is using Clang to warn about them.  Smatch will also warn about them but normally Nathan is getting to them before I do which is a relief for me because there were a lot of warnings.  Also a lot of the bugs were really embarrassing.<br>
<p>
You are using a loop in your code.  Traditionally, GCC used to assume that the code would enter loops at least once.  Smatch would only assume that when it was certain about it.  This caused a lot of false positives in Smatch when it&#x27;s not intelligent enough about the callers.  Actually &quot;this function is never called with an empty list so we will always enter the loop&quot;.  Or &quot;this function will never be called with length zero.&quot;<br>
<p>
In some cases I view handling size zero as a readability and hardening improvement.  But other times it&#x27;s maybe not clear what is the correct way to handle a condition like that and it&#x27;s impossible anyway so we may as well leave the code as-is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/870366/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor870402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2021 19:54 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/870402/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Traditionally, GCC used to assume that the code would enter loops at least once.</font><br>
<p>
If programmers intend that a loop will always be entered at least once they should use a do/while loop, which is defined to have those semantics. The use of a plain while loop implies that the condition may be false on the first iteration. If Smatch was reporting false positives it was due to the code being incorrect, not any issue with Smatch&#x27;s treatment of while loops.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/870402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor870422"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2021 21:31 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/870422/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OMG. We learnt that with FORTRAN/Fortran back in the seventies!<br>
<p>
FORTRAN-IV always did the test at the bottom of the loop so was guaranteed to execute at least once. Fortran-77 did the test at the top of the loop so would skip the loop if the test was false the first time round.<br>
<p>
The compiler I used had a switch to apply the FORTRAN logic to Fortran.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/870422/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor870575"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2021 11:51 UTC (Mon)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/870575/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No...  Often times while loops are more readable and that&#x27;s always the most important thing.<br>
<p>
And even if I thought one style was more readable than another, I&#x27;m not trying to be the style police.  People sometimes suggest adding style rules to Smatch but I don&#x27;t want any part of that.<br>
<p>
The fix is to make the cross function analysis more robust.  That ends up paying for itself in other ways as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/870575/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor871034"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2021 20:38 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/871034/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The more readable version is always going to be the one that says what it means: a while loop for zero or more iterations, and a do/while loop for one or more. Requiring the reader to have extra context about how the function is called to determine whether variables are properly initialized before being used is *not* what I would consider &quot;more readable&quot;. That&#x27;s prioritizing a minor style preference above *correctness*.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871034/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor871040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2021 21:56 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/871040/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Aren&#x27;t you missing something? Languages where the syntax is<br>
<p>
DO ... WHILE ... UNTIL ... END DO<br>
<p>
???<br>
<p>
What&#x27;s important (and this is where FORTRAN/Fortran failed), is that the test should be carried out where the test is written.<br>
<p>
DO WHILE condition<br>
statements<br>
END DO<br>
<p>
or <br>
<p>
DO<br>
statements<br>
WHILE condition END DO<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor871041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2021 23:13 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/871041/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What&#x27;s important (and this is where FORTRAN/Fortran failed), is that the test should be carried out where the test is written.</font><br>
<p>
The context is C code compiled by GCC and Clang. C doesn&#x27;t have any issue with the placement of the test. A while loop puts the test at the top of the loop, and evaluates it at the top of the loop (before the first iteration of the loop body). The do/while loop places the test at the bottom and evaluates it after executing the body of the loop.<br>
<p>
However, if you use a while loop in a context where it would be *incorrect* (as in: results in reading from uninitialized variables) to exit the loop before the body had executed at least once, there is a bug in your code, or at least the very strong *potential* for one even if you think you know that the inputs will always cause the body to be executed. In the absence of some clear human- and machine-readable indication of the initial condition, such as assert() statements, the compiler or other static analysis tool should warn about the potentially uninitialized variable(s). Even with assert() statements I would consider it better to use do/while since it better reflects the actual flow control vs. &quot;assert(expr); while (expr) { ... }&quot; which has the false appearance of a test and branch prior to the first iteration which will (hopefully) be removed by the compiler as dead code.<br>
<p>
Or you could structure the code so that it reliably does the right thing even if the initial condition results in the body of the loop not being executed. That would be ideal: easier to read and reason about, while handling a wider range of inputs without risking undefined behavior.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor871042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 27, 2021 23:22 UTC (Mon)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/871042/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
Standard FORTRAN didn't even have “DO WHILE … END DO” loops (although some implementations added them as a non-standard extension). You would emulate structured loops like these with “IF” and “GOTO” .
</p>
<p>
The other thing was that it was pretty easy to get loops wrong. The moral equivalent to a “FOR” loop in FORTRAN looks like
<pre>
      DO 10 I=1,10
        …
10    CONTINUE
</pre>
IIRC the line with the statement label “10” doesn't have to be “CONTINUE” (which is basically a no-op which is useful to hang statement labels off of), although it makes for more readable loops. But you would have to take care not to accidentally write something like
<pre>
      DO 10 I=1.10
        …
10    CONTINUE
</pre>
where, since spaces inside variable names are allowed in FORTRAN and variables don't need to be explicitly declared, the compiler would assume the first line to be an assignment statement rather than the beginning of a loop (having a “10 CONTINUE” statement without a corresponding “DO” isn't an error, either). FORTRAN 77 changed the syntax of “DO” to optionally allow
<pre>
      DO 10, I=1,10
</pre>
which would prevent the error, and back in a previous life when I was the TA for a FORTRAN course at the university (I was young and needed the money) I would heavily penalise students who didn't avail themselves of this safety measure.
</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/871042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor869782"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">INT_MIN / -1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2021 1:22 UTC (Sun)
                               by <b>dskoll</b> (subscriber, #1630)
                              [<a href="/Articles/869782/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>In some cases, gcc on Linux gives a floating point exception and terminates the program in this case.  I compiled the following code:

<pre>
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int im = INT_MIN;

int divide(int a, int b)
{
    return a/b;
}

int main(int argc, char **argv)
{
    int b = atoi(argv[1]);
    printf("%d\n", divide(im, b));
}
</pre>

And running it gives:

<pre>
$ ./test -1
Floating point exception
</pre>

<p>On the other hand, if you change the first assignment in main to <tt>int b = -1</tt> then you get:
<pre>
$ ./test 
-2147483648
</pre>



      
          <div class="CommentReplyButton">
            <form action="/Articles/869782/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor869808"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">INT_MIN / -1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2021 17:17 UTC (Sun)
                               by <b>ojeda</b> (subscriber, #143370)
                              [<a href="/Articles/869808/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, the compiler is free to create a program that raises SIGFPE (or does anything else) if you reach a state that triggers UB. This is what allows the compiler to ignore handling that case.<br>
<p>
If, instead, the standard defined that e.g. `abort()` is called, then the compiler would need to ensure that happens somehow (e.g. by guarding the division or by handling hardware exceptions).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/869808/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor871246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">INT_MIN / -1</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2021 17:13 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/871246/">Link</a>] 
      </p>
      
      </div>
      </summary>
      My guess is: you compiled and ran on AMD64 (or IA-32), and the code as shown actually performs a division, and the processor produces an exception due to the integer overflow in this case, which the OS translates into a SIGFPE (with appropriate si_code if you pass SA_SIGINFO to sigaction).  By contrast, in the case where gcc can see that b=-1, it tries to constant-fold the division and botches it (of course, they will claim that you bothed your program).


      
          <div class="CommentReplyButton">
            <form action="/Articles/871246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor871250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Key Rust concepts for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 29, 2021 17:24 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/871250/">Link</a>] 
      </p>
      
      </div>
      </summary>
      As it happens, I <a href="http://www.complang.tuwien.ac.at/anton/undefined-div-bench/">tried pretty hard</a> to find a performance difference between checking before the division and checking afterwards (my theory was that checking afterwards should run in parallel with the division, while checking before should not).  Even with specially crafted microbenchmarks, the differences were small on some CPUs and non-existent on others.  Therefore I consider it unlikely that the check has any measurable effect in production code.  However, I did not compare a variant without any check, so that's something a sufficiently interested individual can still do (maybe based on my microbenchmarks).


      
          <div class="CommentReplyButton">
            <form action="/Articles/871250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872393"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Learning resources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 2:54 UTC (Sun)
                               by <b>yodermk</b> (guest, #3803)
                              [<a href="/Articles/872393/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just to note, I read the free online The Rust Programming Language earlier this year. I am now reading the new edition of Programming Rust. The latter is way, way, WAY better. It covers a lot more things and describes things in more detail. This is one case where it&#x27;s definitely worth ponying up for the dead tree. That said, the online book will get you started.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872393/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Learning resources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 7:50 UTC (Sun)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/872403/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Programming Rust is also available as an e-book, if you want to avoid killing a tree.<br>
<p>
Another fresh Rust book is Rust for Rustaceans by Jon Gjengset. This book is for &quot;developers who have mastered the basics.&quot; I haven&#x27;t read it myself yet, but I have been watching some of the author&#x27;s Crust of Rust videos on YouTube. But be warned: some of the videos are over five hours long.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872424"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Learning resources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2021 15:44 UTC (Sun)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/872424/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But be warned: some of the videos are over five hours long.</font><br>
<p>
For the curious, this podcast explains why: https://rustacean-station.org/episode/038-jon-gjengset/<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872424/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872621"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Learning resources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2021 7:12 UTC (Tue)
                               by <b>MrWim</b> (subscriber, #47432)
                              [<a href="/Articles/872621/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, to find out why some YouTube videos are over 5hrs long listen to a 1h20m podcast ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872621/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872638"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Learning resources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2021 13:31 UTC (Tue)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/872638/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Lol :) On the other hand they are listing timestamps so it&#x27;s easy to find the relevant segment.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872638/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor874466"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Learning resources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 31, 2021 9:11 UTC (Sun)
                               by <b>mcortese</b> (guest, #52099)
                              [<a href="/Articles/874466/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Do you know if it's available as epub, though? I could only find the Kindle version, which I'm not a big fan of.


      
          <div class="CommentReplyButton">
            <form action="/Articles/874466/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor874471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Learning resources</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 31, 2021 11:00 UTC (Sun)
                               by <b>peniblec</b> (subscriber, #111147)
                              [<a href="/Articles/874471/">Link</a>] 
      </p>
      
      </div>
      </summary>
      "Programming Rust" (2nd edition) can be found <a href="https://www.ebooks.com/en-us/book/210313783/programming-rust/jim-blandy/">DRM-free on ebooks.com</a>. As for "Rust for Rustaceans", <a href="https://nostarch.com/rust-rustaceans">no starch press</a> seems to provide PDF and ePub versions.




      
          <div class="CommentReplyButton">
            <form action="/Articles/874471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
