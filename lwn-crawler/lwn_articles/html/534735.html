        <!DOCTYPE html>
        <html lang="en">
        <head><title>Rethinking optimization for size [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/534735/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/533892/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/534735/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Rethinking optimization for size</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 30, 2013</br>
           </div>
Contemporary compilers are capable of performing a wide variety of
optimizations on the code they produce.  Quite a bit of effort goes into
these optimization passes, with different compiler projects competing to
produce the best results for common code patterns.  But the nature of
current hardware is such that some optimizations can have surprising
results; that is doubly true when kernel code is involved, since kernel
code is often highly performance-sensitive and provides an upper bound on
the performance of the system as a whole.  A recent discussion on the
best optimization approach for the kernel shows how complicated the
situation can be.
<p>
Compiler optimizations are often aimed at making frequently-executed code
(such as that found in inner loops)
run more quickly.  As an artificially simple example, consider a loop like
the following:
<p>
<pre>
    for (i = 0; i &lt; 4; i++)
	do_something_with(i);
</pre>
<p>
Much of the computational cost of a loop like this may well be found in the
loop structure itself â€” incrementing the counter, comparing against the
maximum, and jumping back to the beginning.  A compiler that performs loop
unrolling might try to reduce that cost by transforming the code into something like:
<p>
<pre>
    do_something_with(0);
    do_something_with(1);
    do_something_with(2);
    do_something_with(3);
</pre>
<p>
The loop overhead is now absent, so one would expect this code to execute
more quickly.  But there is a cost: the generated code may well be larger
than it was before the optimization was applied.  In many situations, the
performance improvement may outweigh the cost, but that may not always be
the case.
<p>
GCC provides an optimization option (<tt>-Os</tt>) with a different
objective: it instructs the compiler to produce more compact code, even if
there is some resulting performance cost.  Such an option has obvious value
if one is compiling for a space-constrained environment like a small
device.  But it turns out that, in some situations, optimizing for space
can also produce <i>faster</i> code.  In a sense, we are all running
space-constrained systems, in that the performance of our CPUs depends
heavily on how well those CPUs are using their cache space.
Space-optimized code can make better use of scarce instruction cache space,
and, as a result, perform better overall.  With this in mind, compilation
with <tt>-Os</tt> was <a
href="http://git.kernel.org/linus/0910b444bcd7ea7f437a3ff48e0e3d2495ead22e">made
generally available</a> for the 2.6.15 kernel in 2005 and <a
href="http://git.kernel.org/linus/96fffeb4b413a4f8f65bb627d59b7dfc97ea0b39">made
non-experimental</a> for 2.6.26 in 2008.
<p>
Unfortunately, <tt>-Os</tt> has not always lived up to its promise in the real-world.
The problem is not necessarily with the idea of
creating compact code; it has more to do with how GCC interprets the
<tt>-Os</tt> option.  In the space-optimization mode, the compiler tends to
choose some painfully slow instructions, especially on older processors.  It
also discards the branch prediction information provided by kernel
developers in the form of the <tt>likely()</tt> and <tt>unlikely()</tt>
macros.  That, in turn, can cause rarely executed code to share cache space
with hot code, effectively wasting a portion of the cache and wiping out
the benefits that optimizing for space was meant to provide.  
<p>
Because <tt>-Os</tt> did not produce the desired results, Linus <a
href="http://git.kernel.org/linus/281dc5c5ec0fb299514567cbc358562649c1af95">disabled
it by default</a> in 2011, effectively ending experimentation with this
option.  Recently, though, Ling Ma posted <a href="/Articles/534745/">some
results</a> suggesting that the situation might have changed.  Recent Intel
processors, it seems, have a new cache for decoded instructions, increasing
the benefit obtained by having code fit into the cache.  The performance of
the repeated "move" instructions used by GCC for memory copies in
<tt>-Os</tt> mode has also been improved in newer processors.  The posted
results claim a 4.8% performance improvement for the netperf benchmark and
2.7% for the volano benchmark when <tt>-Os</tt> is used on a newer CPU.  Thus, it was
suggested, maybe it is time to reconsider <tt>-Os</tt>, at least for some
target processors.
<p>
Naturally, the situation not quite that simple.  Valdis Kletnieks <a
href="/Articles/534746/">complained</a> that the benchmark results may not
be showing an actual increase in real-world performance.  Distributors hate
shipping multiple kernels, so an optimization mode that only works for some
portion of a processor family is unlikely to be enabled in distributor
kernels.  And there is 
still the problem of the loss of branch prediction information which, as
Linus <a href="/Articles/534749/">verified</a>, still happens when
<tt>-Os</tt> is used.
<p>
What is really needed, it seems, is a kernel-specific optimization mode
that is more focused on instruction-cache performance than code size in its
own right.  This mode would take some behaviors from <tt>-Os</tt> while
retaining others from the default <tt>-O2</tt> mode.  Peter Anvin <a
href="/Articles/534750/">noted</a> that the GCC developers are receptive to
the idea of implementing such a mode, but there is nobody who has the time
and inclination to work on that project at the moment.  It would be nice to
have a developer who is familiar with both the kernel and the compiler and
who could work to make GCC produce better code for the kernel environment.
Until somebody steps up to do that work, though, we will likely have to
stick with <tt>-O2</tt>, even knowing that the resulting code is not as
good as it could be.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#GCC">GCC</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/534735/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor535362"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 8:13 UTC (Thu)
                               by <b>kugel</b> (subscriber, #70540)
                              [<a href="/Articles/535362/">Link</a>] (25 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why should that mode be kernel-specific? It seems completely fine for user space programs as well (and likely()/unlikely() can be used by them too).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535362/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 10:57 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/535382/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
kugel wrote:<br>
<font class="QuotedText">&gt; Why should that mode be kernel-specific? It seems completely fine for user space programs as well (and likely()/unlikely() can be used by them too).</font><br>
Roughly what I was thinking too - and additionally that if -Os is performing better than -O2 then perhaps that means that the way the compiler handles -O2 (that is, what optimisations -O2 enables) needs some attention rather than that users should prefer -Os over -O2 for performance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535387"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 11:55 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/535387/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I never understood why the compiler doesn't just have an optimization option mode which optimizes for speed on the selected target CPU.  Instead we have -O, -O2, and -O3 where each enables a fixed list of optimization strategies (for example -O3 is documented as turning on function inlining, tree vectorization, etc).  This means that if it turns out that a particular optimization tends to help on some CPUs but not others, there is no way to just choose whatever is best, even though you may have specified the exact processor to generate code for.<br>
<p>
After all, if you really were interested in a fixed set of optimization rules you could specify them by hand with a long list of -fthis and -fthat.  Most people who aren't interested in that level of detail would rather have a way to let the compiler decide what's best - even if its decisions are not quite as good as a skilled developer hand-tuning the flags.<br>
<p>
To be clear, I am not saying that the compiler can magically determine which optimization flags will help on a particular piece of code.  But it can know in general which ones tend to work on which CPUs.  An older CPU may benefit from loop unrolling while a newer one, whose performance is more memory-bound, will usually not benefit.  It makes more sense for these heuristics to be codified in the compiler, with a table mapping CPU models to optimizations.  This table would explicitly be open to change in newer compiler versions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535387/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535499"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 21:48 UTC (Thu)
                               by <b>mstefani</b> (guest, #31644)
                              [<a href="/Articles/535499/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The compiler has no chance to know on which CPU the code will run in the end.<br>
Unless you're Gentoo it is highly likely that your binaries were compiled on a totally different CPU.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535499/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535592"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2013 10:51 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/535592/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>The compiler has no chance to know on which CPU the code will run in the end.</blockquote>The programmer can tell it, if not the exact CPU, then at least the family or families to optimize for.  The -march and -mcpu options already affect code generation in the choice of instructions; it's strange that there is little connection from that to the higher-level optimizations that are applied.
<p>
The developer building Fedora, etc, also doesn't know on which CPU it will be run, but you can make a reasonable guess and try to use optimizations that perform well on typical target hardware.  That won't be the same set of optimizations that worked on a typical i486, even if you exclude things that require new instruction set support.  Yet the set of optimizations chosen by -O and -O2 is essentially fixed and gcc doesn't use its knowledge of the target CPU to influence that set.
      
          <div class="CommentReplyButton">
            <form action="/Articles/535592/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor536748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2013 14:50 UTC (Thu)
                               by <b>bluss</b> (subscriber, #47454)
                              [<a href="/Articles/536748/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
GCC does have options for this. -mtune to optimize for a cpu without losing generality, -mcpu to optimize and use exclusive instruction sets etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/536748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor535522"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 23:21 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/535522/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">I never understood why the compiler doesn't just have an optimization option mode which optimizes for speed on the selected target CPU.</font></blockquote>

<p>It <a href="http://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/i386-and-x86_002d64-Options.html#index-mtune-1394">does</a>. Typically distributions compile code for 386 or 486 but optimize for something newer. The problem is that -Os does not use this information: it optimizes purely for size, not for speed.</p>


<blockquote><font class="QuotedText">Instead we have -O, -O2, and -O3 where each enables a fixed list of optimization strategies (for example -O3 is documented as turning on function inlining, tree vectorization, etc). This means that if it turns out that a particular optimization tends to help on some CPUs but not others, there is no way to just choose whatever is best, even though you may have specified the exact processor to generate code for.</font></blockquote>

<p>The wast majority of options can lead to speedup or slowdown depending <b>on the program</b>, not on the CPU. And -O, -O2 and -O3 are just typical set of strategies. To find out the right set of optimizations for a given program is tough problem.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/535522/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535593"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2013 11:01 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/535593/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      As I understand it, the -mtune flag affects the low-level code generation step, but it has no influence on the optimizations that are applied at a higher level.  It won't, for example, turn on or off loop unrolling depending on how memory-bound a particular CPU tends to be.
<blockquote>The wast majority of options can lead to speedup or slowdown depending on the program, not on the CPU.</blockquote>This is certainly true.  But most programmers don't want to spend time testing each optimization separately; they tend to just pick -O2 and let the compiler decide.  After all the compiler writers know more about optimization, even if I know more about my particular program.  If the compiler could be just a bit smarter, that would be a big win.
      
          <div class="CommentReplyButton">
            <form action="/Articles/535593/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2013 21:02 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/535753/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">It won't, for example, turn on or off loop unrolling depending on how memory-bound a particular CPU tends to be.</font></blockquote>

<p>It's impossible to predict unless you know what your <b>program</b> is doing - and compiler deals with <b>functions</b>. Even puny Atoms have 32KiB of L1 cache where functions (even with loops unrolled) are usually smaller.</p>

<blockquote><font class="QuotedText">If the compiler could be just a bit smarter, that would be a big win.</font></blockquote>

<p>This way lies madness. Difference between contemporary CPUs is <b>much</b> smaller then you think. The aforementioned cache which presumably should be handled differently in different cases is between 32KiB on most Intel CPUs (from Atoms to XeonsCore and 64KiB for AMD, L2 differs more substantially but difference is not large enough to affect issues at small (function-sized) scale and LTO is not yet in wide use and not all that mature besides.</p>

<blockquote><font class="QuotedText">But most programmers don't want to spend time testing each optimization separately; they tend to just pick -O2 and let the compiler decide.</font></blockquote>

<p>It's even worse: they often abuse "premature optimization is the root of all evil" mantra to introduce 3x-5x-10x slowdown. What the compiler does after that is more-or-less irrelevant. If people care about efficiency they should start thinking about efficiency first and hot hope that compiler will magically make 10 levels of indirections disappear. No, they <b>don't</b> disappear and compiler very rarely can do anything to thembut looks like developers (except for kernel developers, <a href="http://lwn.net/Articles/509416/">of course</a>) understand that. Instead most books explain how you can use them to nicely "encapsulate" and "separate" stuff - usually without ever mentioning their price.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/535753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537006"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2013 17:50 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/537006/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Difference between contemporary CPUs is much smaller then you think.</font><br>
<p>
But not as small as you think.  I work on a production compiler and we are always tuning for new targets.  Even something as simple as moving from Sandy Bridge to Ivy Bridge can result in a change in strategy.<br>
<p>
<font class="QuotedText">&gt; What's even worse: they often abuse "premature optimization is the root </font><br>
<font class="QuotedText">&gt; of all evil" mantra to introduce 3x-5x-10x slowdown.</font><br>
<p>
But worse than that is programmers trying to out-guess the compiler and do hand loop unrolling, converting of array accesses to pointer arithmetic and the like.  This *kills* the compiler's ability to analyze the program and thus make transformations to improve the code.<br>
<p>
It is essential for the developer to take a high-level view of performance.  Algorithm and data structure choice is the #1 performance decision to make.  After that, the ROI decreases rapidly for the programmer.  Yes, the programmer should be aware of the cost of abstractions when appropriate but we should not throw away those abstractions on a whim.  They save expensive programmer time.  Do hand performance tuning *only* after a proven need via profiling.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537006/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537030"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2013 21:41 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/537030/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">Do hand performance tuning *only* after a proven need via profiling.</font></blockquote>

<p>By that time it's often much too late to do anything. The one thing programmer should keep in mind are <a href="http://everythingisdata.wordpress.com/2009/10/17/numbers-everyone-should-know/">few numbers</a>. If you introduce nice level of indirection (to facilitate future expansion or something like this) and this indirection triggers access to the main memory then you are losing about 500-600 ticks right there. And contemporary CPU can move hundred of sequential bytes and do thousand of operations in that time! If your program is built around bazillion tiny objects it's too late to anything at this point: to remove these useless levels of indirection you need to basically rewrite program from scratch.</p>

<blockquote><font class="QuotedText">But not as small as you think. I work on a production compiler and we are always tuning for new targets. Even something as simple as moving from Sandy Bridge to Ivy Bridge can result in a change in strategy.</font></blockquote>

<p>Sure, but how much can you hope to win? I speak from the experience: just recently we've rewrote piece of code - it went from nice "modern" structure with five or six independent layers and couple of dozen structures to one function (autogenerated one) with 20'000 lines of code and dozen of simple local variables. Speedup was about 10x (in one mode was 8x and in another mode was 12x). Do you really believe you can do something like this with a compiler options or small tweaks after profiler run?</p>

<p>P.S. Actually we can squeeze additional ~30% with PGO and some other compiler tricks but in the end we decided that it complicates our build system too much and accepted "mere" 8x/12x speedup.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/537030/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537051"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2013 0:00 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/537051/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it depends on what you define as 'hand optimization'<br>
<p>
unrolling loops is something that is almost always better left to the compiler.<br>
<p>
But changing the algorithm from using a pointer-heavy set of linked lists to an implementation using small offsets in a buffer is not something the compiler will ever do, but can result is huge speedups.<br>
<p>
"trust the compiler, write whatever you want" doesn't work well in real life, and by the time you get things under a real load to find the bottlenecks, it's frequently too late to change them short of a re-write.<br>
<p>
You need to keep end efficiency in mind as you go along. This requires that you keep up to date with what sorts of things are cheap to do and what are expensive to do. If you get it right, you are an unsung hero (you seldom get thanks for things that don't crumple under load), if you get it wrong you get ridiculed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537051/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537090"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2013 10:32 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/537090/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      Are you sure you wanted to answer to my post? Because it looks like you are saying almost exactly the same thing I did: compiler can usually optimize your <b>code</b> well enough, but it can't do anything to your <b>data structures</b> - and <b>this</b> is where major inefficiencies lurk. And my major I mean <b>major</b>: 10x slowdown, 100x slowdown, sometimes even 1000x slowdown!
      
          <div class="CommentReplyButton">
            <form action="/Articles/537090/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2013 23:37 UTC (Sat)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/537157/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe I said exactly the same.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor537163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 10, 2013 0:16 UTC (Sun)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/537163/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; converting of array accesses to pointer arithmetic and the like. </font><br>
<p>
You said this is bad behavior on the programmer's side<br>
<p>
however, this may be exactly the algorithm/data structure change that produces the multiple orders of magnitude performance improvements, and the type of thing the developer should keep in mind<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 10, 2013 3:59 UTC (Sun)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/537171/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; converting of array accesses to pointer arithmetic and the like.</font><br>
<p>
<font class="QuotedText">&gt; You said this is bad behavior on the programmer's side</font><br>
<p>
<font class="QuotedText">&gt; however, this may be exactly the algorithm/data structure change that </font><br>
<font class="QuotedText">&gt; produces the multiple orders of magnitude performance improvements, and </font><br>
<font class="QuotedText">&gt; the type of thing the developer should keep in mind</font><br>
<p>
I find that extremely hard to believe.  Do you have an example?  I can't think of any possible reason that converting array index operations into pointer arithmetic is ever a win.<br>
<p>
Now if you're talking about changing out an array data structure for some other kind of data organization, that's something else entirely.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 10, 2013 11:34 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/537181/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">I can't think of any possible reason that converting array index operations into pointer arithmetic is ever a win.</font></blockquote>

<p>It may be a win because to access data using an index you need two variables (array address and index) but to access data using pointer you need one (just pointer is enough). When callbacks are involved it may replace code which uses just registers to pass information around with code which uses structure in memory - in this case wins can be substantial (speaking from experience). But of course such cases are rare.</p>

<p>But you are saying that conversion to pointer arithmetic is somehow bad? In my experience it's usually net neutral. What kind of optimization compiler can apply if I'm using indexes? How often it can apply them? I'm not saying it never happens, I just don't see and a common occurrence.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/537181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2013 17:21 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/537372/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It may be a win because to access data using an index you need two </font><br>
<font class="QuotedText">&gt; variables (array address and index) but to access data using pointer you </font><br>
<font class="QuotedText">&gt; need one (just pointer is enough).</font><br>
<p>
At code-generation time the compiler knows well enough how to convert from array notation to pointer arithmetic so no extra registers are used.  Indeed it must do so for most architectures.  By doing that too early, the compiler loses valuable information about array stride accesses and the like that are critical for transformations like vectorization.<br>
<p>
In addition, pointer arithmetic has all sorts of nasty aliasing properties that hamper the compiler's ability to analyze the code.<br>
<p>
"But arrays and pointers are the same in C!" some may cry.  Well, that's not entirely true and even if it were there's nothing that prohibits the compiler from representing the two very differently in its internal data structures.<br>
<p>
<font class="QuotedText">&gt; When callbacks are involved it may replace code which uses just </font><br>
<font class="QuotedText">&gt; registers to pass information around with code which uses structure in </font><br>
<font class="QuotedText">&gt; memory.</font><br>
<p>
This sounds like an ABI issue.  Most sane ABIs pass small structs via registers.<br>
<p>
<font class="QuotedText">&gt; What kind of optimization compiler can apply if I'm using indexes?</font><br>
<p>
Anything that involves analyzing loop inductions and stride patterns.<br>
<p>
- Vectorization<br>
- Loop interchange<br>
- Cache blocking<br>
- Strip mining<br>
- Loop collapse<br>
<p>
and about a dozen other transformations.  These are the "big improvement" optimizations.  Petty things like CSE and copy propagation are important but are done more to enable these big-gain transformations than for their code improvement in and of themselves.<br>
<p>
In rare cases the compiler can convert pointer arithmetic back to array indices but this often involves extra bit-twiddling or other arithmetic to recover the original indices and more likely than not aliasing rules get in the way and make it impossible to recover the critical information.<br>
<p>
Pointer arithmetic is just generally bad for the compiler.  Avoid it if possible.<br>
<p>
Incidentally, this is also why it's a very *bad* idea to use unsigned as a loop counter.  One is not "giving the compiler more information."  On the contrary, by using unsigned one is moving the arithmetic away from normal algebraic rules to the realm of modulo arithmetic.  The compiler must then make all kinds of pessimistic assumptions about loop termination and access patterns.  This also kills many of the loop transformations listed above.<br>
<p>
Of course I am speaking in generalities.  One can always find a counter-example.  However, the vast majority of codes behave as I describe.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2013 18:45 UTC (Mon)
                               by <b>Aliasundercover</b> (subscriber, #69009)
                              [<a href="/Articles/537380/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In times past I often reviewed the code output from compilers I was working with.  It was helpful to calibrate what idioms carried what costs and track how they changed with compilers.<br>
<p>
I still get the itch to look now and then but mostly recoil in horror at how hard it is to relate the code GCC gives me to what I wrote.  Typically I have some function I want to review but give up after 10 minutes of searching the listing without finding it.  The listing is of course fabulously ugly but that is no change from any other compiler I ever used.  I just don't find my code.  Well, I do, but it is all in a huge block of raw C code without the corresponding output.<br>
<p>
No doubt some cool optimization hoisted my code out of its place in the C code I wrote and dropped it some place which makes sense to the compiler. No doubt all this transformation is good for run time performance or size or something.  Perhaps listing quality just isn't an interesting bit of work for compiler writers.<br>
<p>
I used to know what those old Windows and SunOS compilers would do with my code but now I have no similar feeling for GCC.  I can read what people write about indexing vs. pointers and signed vs. unsigned but I used to really know from first hand observation.<br>
<p>
I wish the listing got more respect.  It can be a powerful optimization tool.<br>
<p>
Maybe I just do it wrong.  My makefile has the following incantation for generating listings.<br>
<p>
%.lst: %.c<br>
	$(CC) $(CFLAGS) $(CPPFLAGS) -g -Wa,-a,-ad -c $&lt; &gt; $@<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537396"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2013 19:25 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/537396/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The listing is of course fabulously ugly but that is no change from any </font><br>
<font class="QuotedText">&gt; other compiler I ever used.</font><br>
<p>
This is actually a quality of implementation issue.  There are compilers out there that give fantastic listings, even down to a mostly-readable highish-level decompliation even after very aggressive code transformations.  This is not very easy to obtain and really has to be baked-in at the beginning of the compiler design.<br>
<p>
But you're right in that a good compiler will make your code unrecognizable.  :)<br>
<p>
<font class="QuotedText">&gt; I wish the listing got more respect. It can be a powerful optimization </font><br>
<font class="QuotedText">&gt; tool.</font><br>
<p>
Indeed.  I don't think there's much one can do with gcc to get a decent listing.  It just doesn't carry enough information.  Neither does LLVM, unfortunately, at least AFAIK.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537396/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor537420"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2013 21:09 UTC (Mon)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/537420/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
maybe you want gcc -S -fverbose-asm for commented assembly output? also -fdump-tree-all and -fdump-rtl-all if you want to see what happens to your C and also relate the internal GIMPLE variable names to the comments in the verbose asm output.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537420/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537560"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 12, 2013 16:28 UTC (Tue)
                               by <b>Aliasundercover</b> (subscriber, #69009)
                              [<a href="/Articles/537560/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, you got me there.  I tried those dump options and got 151 spam files in my source directory.<br>
<p>
-fverbose-asm seems useful.  It doesn't help with finding where my code went but the comments are nice.<br>
<p>
I wish compiler listings got more respect.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537560/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor537405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2013 19:54 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/537405/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">Anything that involves analyzing loop inductions and stride patterns.<br />
- Vectorization<br />
- Loop interchange<br />
- Cache blocking<br />
- Strip mining<br />
- Loop collapse<br />
and about a dozen other transformations.</font></blockquote>

<p>Which are not applicable at all if you have arrays of various complex objects. Sure, I can understand that in some tight loops where "vectorization", "loop interchange" and other cool things can be applied indexes may be beneficial. But for typical high-level code (that is: for 90% of code if not 99% of code in a given project) changes from indexes to pointers and back make absolutely no difference: any function call tend to break all these nice techniques - and there are a lot of them.</p>

<p>Sure, for inner loop it may be interesting, but then they usually are faster when implemented in the appropriate CPU intrinsics (the change in data structures needed to use them efficiently are impossible for the compiler) anyway thus in practice I rarely see any observable difference. Of course nowadays it's often better to use CUDA or OpenCL to push all that to the GPU - where different rules are used altogether and where traditional pointers make no sense at all, but these are specialized applications.</p>

<blockquote><font class="QuotedText">This sounds like an ABI issue. Most sane ABIs pass small structs via registers.</font></blockquote>

<p>Yup. Up to six registers for x86-64 case. And if you have couple of arrays plus some kind of "options" argument plus some callback_data... you've already used all of them. Add one additional argument - and spill is inevitable.</p>

<p>You may say that code which calls a callback in a tight loop is hopeless in a first place, but that's the problem: quite often I can not afford doing anything else. It's just too expensive to have one function for buttons, another for lists and so on: code is pushed from from L1 (or sometimes even L2 cache) and all these benchmark-friendly optimizations actually slow the code down.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/537405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2013 21:41 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/537423/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Which are not applicable at all if you have arrays of various complex </font><br>
<font class="QuotedText">&gt; objects.</font><br>
<p>
How did you come to that conclusion?  Sometimes it is not worth it but for smallish structs it can be a win.  Complex numbers are a good example.<br>
<p>
<font class="QuotedText">&gt; any function call tend to break all these nice techniques</font><br>
<p>
If the function call is still there and even then the compiler can sometimes accomplish the task, depending on how aggressive the developers were.<br>
<p>
<font class="QuotedText">&gt; Of course nowadays it's often better to use CUDA or OpenCL to push all </font><br>
<font class="QuotedText">&gt; that to the GPU</font><br>
<p>
No.  There is never a case where CUDA or OpenCL are a good idea.  Only poor compilers have led us down that path.  Look at what's being done with OpenACC.  A good compiler can match CUDA performance pretty easily and can often dramatically outperform it.<br>
<p>
<font class="QuotedText">&gt; Add one additional argument - and spill is inevitable.</font><br>
<p>
In the grand scheme of thing, one write to cache/read from cache isn't usually critical.  Sure, there are cases where this kind of optimization is very important -- if the callback is called in a tight loop for example.  But in that case a better solution is often to refactor the code and/or rework the data structures.  It should not be necessary to hand-linearize array accesses to get performance.<br>
<p>
<font class="QuotedText">&gt; You may say that code which calls a callback in a tight loop is hopeless </font><br>
<font class="QuotedText">&gt; in a first place</font><br>
<p>
Actually, I would say that's often good design for the reasons you give.  But then this kind of code usually isn't dealing with numerical arrays or arrays of very small structs which might be well vectorized.  I suppose that is what you were thinking of with your first statement.<br>
<p>
If that's the kind of code you're concerned about then yes, hand-linearizing array accesses is probably not going to hurt much.  But it won't really help either.  I've no problem with a loop that iterates over such arrays using a single pointer.  I am more concerned about people who take multidimensional arrays and translate accesses to complex pointer arithmetic.<br>
<p>
Still, if the objects are small enough, vectorization targeting efficient load/store of the data can often be a win, even if the actual data manipulation isn't vectorized.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor537005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2013 17:44 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/537005/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
gcc has -mtune for that.  Many compilers do take target architecture into account when doing analyses and transformations.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor537003"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2013 17:43 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/537003/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Spot on.<br>
<p>
Speaking as a compiler developer, the stated problems look like possible performance bugs to me.  There are always tradeoffs in compiler transformations.  You hope to speed one thing up without hurting other stuff too much.  Most of it is heuristic based and changing the heuristics can have dramatic effects.  I have seen register allocators swing performance +-20% simply by changing the heuristic of how to pick which object to allocate next.<br>
<p>
Incidentally, I have run into exactly the same unrolling/icache issue before.  It's one of those 2nd- or 3rd-order effects you hope doesn't matter but when it does it can be a fun time tracking it down.  The main problem is that it is highly context sensitive.  Unrolling a loop by 4 in one place may be exactly right but may result in disaster on another loop.  This is one reason compilers try to do a global analysis when possible.  Of course, that's another tradeoff, one between generated code quality and compile time.<br>
<p>
The last thing we need is another compiler mode.  We have too many already.  The real solution is to re-tune some of gcc's passes for modeern architectures.  That is realy work, though, and takes a tone of time and patience.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537003/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor535488"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2013 21:25 UTC (Thu)
                               by <b>robert_s</b> (subscriber, #42402)
                              [<a href="/Articles/535488/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Offtopic, but this article reminded me of some work a GHC developer did a few years ago using genetic algorithms to search for an optimal set and order of LLVM optimization flags for a particular program.<br>
<p>
(Quite a commendation to LLVM that it allows this amount of control over optimization passes I suppose)<br>
<p>
<a href="http://donsbot.wordpress.com/2010/03/01/evolving-faster-haskell-programs-now-with-llvm/">http://donsbot.wordpress.com/2010/03/01/evolving-faster-h...</a><br>
<p>
Wonder if anyone's done any further work on the subject.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535488/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor535650"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2013 16:20 UTC (Fri)
                               by <b>NAR</b> (subscriber, #1313)
                              [<a href="/Articles/535650/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This occurred to me also while reading through the article - with a good benchmark finding the right optimization can be automated (to a degree).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/535650/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor536059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2013 18:38 UTC (Mon)
                               by <b>ssam</b> (guest, #46587)
                              [<a href="/Articles/536059/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
if you have the time then profile guided optimization (PGO) is worth a look. You compile, then run the code with a profiler so that you know which bits of code are used the most. Then the compiler can be selective about how different bits get optimized. At a simple level use -Os for rarely called functions and -O3 for repeatedly called ones. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/536059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor536152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2013 23:29 UTC (Mon)
                               by <b>rgmoore</b> (<b>&#x272D; supporter &#x272D;</b>, #75)
                              [<a href="/Articles/536152/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <P>It seems like PGO is something that would only have to be run once in a while.  The hot code paths are likely to stay hot unless you substantially rewrite your program.  So you'd only need to run the profiling occasionally, then use that to optimize your choice of compiler flags, which could be written into the makefile.  Everyone downstream could benefit from the improvements without having to do the profiling themselves.
      
          <div class="CommentReplyButton">
            <form action="/Articles/536152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor536291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2013 19:10 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/536291/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>PGO does not work this way. It does not change set of flags - it's totally orthogonal optimization.</p>

<p>Basically a lot of optimizations are tradeoffs (perhaps most): "if we unroll this loop and it's hot then we win because it'll be faster, but if it's cold then we lose because we increase memory pressure... and we can unroll it twice or four time or even hundred of times... what to do, what to do". Without PGO there are some heuristics ("if branch will probably be taken more often then else branch", etc), but with PGO you <b>know</b> if the given piece of code is hot or cold. And this makes all the same optimizations perform better.</p>

<p>That's why you can not reuse results of PGO runs: you need the exact some code compiled twice. Most changes will invalidate the results (tiny changes in code may mean significant changes in the parsed tree - especially in C++). Yes, you know that hot codepath is still somewhere in this function, but where exactly? That's the question.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/536291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor536938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2013 14:12 UTC (Fri)
                               by <b>jdbrandmeyer</b> (guest, #85840)
                              [<a href="/Articles/536938/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Other way around, actually.  Acovea came well in advance of your LLVM example, and the target compiler was GCC.<br>
<p>
<a href="http://stderr.org/doc/acovea/html/acoveaga.html">http://stderr.org/doc/acovea/html/acoveaga.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/536938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2013 17:56 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/537008/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, this was done long before that.  See for example:<br>
<p>
<a href="http://dl.acm.org/citation.cfm?id=1134650.1134663&amp;coll=DL&amp;dl=GUIDE&amp;CFID=178864352&amp;CFTOKEN=20287415">http://dl.acm.org/citation.cfm?id=1134650.1134663&amp;col...</a><br>
<p>
<a href="http://dl.acm.org/citation.cfm?id=603339.603341&amp;coll=DL&amp;dl=GUIDE&amp;CFID=178864352&amp;CFTOKEN=20287415">http://dl.acm.org/citation.cfm?id=603339.603341&amp;coll=...</a><br>
<p>
<a href="http://dl.acm.org/citation.cfm?id=314403.314414&amp;coll=DL&amp;dl=GUIDE&amp;CFID=178864352&amp;CFTOKEN=20287415">http://dl.acm.org/citation.cfm?id=314403.314414&amp;coll=...</a><br>
<p>
And that's just a small sample.  In addition, there are many papers using genetic algorithms to drive the heuristic decisions within various transformation passes.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2013 22:20 UTC (Fri)
                               by <b>Shewmaker</b> (guest, #1126)
                              [<a href="/Articles/537038/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The first project that I remember seeing that seriously pursued automatically optimizing for whatever architecture you compiled it on was the <a rel="nofollow" href="http://math-atlas.sourceforge.net/faq.html">ATLAS</a> linear algebra library. It was moderately successful, but it could be beat by <a rel="nofollow" href="http://en.wikipedia.org/wiki/Kazushige_Goto">Goto's BLAS</a>.
<p>
I remember ACOVEA too, but it looks like it is no longer being maintained.
<p>
There is a current effort, <a rel="nofollow" href="http://ctuning.org">Collective Tuning</a> that goes beyond ACOVEA's intentions. They compare it to their <a rel="nofollow" href="http://cTuning.org/ccc">Continuous Collective Compilation Framework</a>
<p>
I don't know how it compares to the LLVM work.
      
          <div class="CommentReplyButton">
            <form action="/Articles/537038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor536674"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2013 8:58 UTC (Thu)
                               by <b>massimiliano</b> (subscriber, #3048)
                              [<a href="/Articles/536674/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I might be wrong, but what we really need is not just a new compiler flag that says "optimize for speed knowing that code size heavily affects speed".<br>
<p>
What would be nice to have would be profile-driven optimizations.<br>
<p>
You compile your kernel, profile it during a "normal workload" (the definition of which is really tricky), and then, maybe, optimize functions differently.<br>
For instance, for very hot ones you could afford loop unrolling, and for colder ones you'd keep size as small as possible.<br>
<p>
My 2c,<br>
_ Massi<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/536674/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor537457"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2013 23:59 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/537457/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Um, yes. That's what profile-guided optimizations *are*. :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/537457/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor536864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking optimization for size</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2013 22:41 UTC (Thu)
                               by <b>stevenb</b> (guest, #11536)
                              [<a href="/Articles/536864/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps the likely()/unlikely() hints were ignored because GCC did<br>
not reorder basic blocks in traces at -Os.  If that is the problem,<br>
then it should be fixed in GCC 4.8.  See gcc.gnu.org/PR54364<br>
<p>
Perhaps someone can try GCC 4.8 -Os for the kernel and see if the<br>
hints are honored now?  Otherwise it'd be good to have a PR filed<br>
for it in GCC Bugzilla.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/536864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
