        <!DOCTYPE html>
        <html lang="en">
        <head><title>A big.LITTLE scheduler update [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/501501/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/500847/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/501501/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A big.LITTLE scheduler update</h1>
</div>
<div class="ArticleText">
<div class="GAByline">
           <p>June 12, 2012</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
<p>ARM's big.LITTLE architecture is an example of asymmetric multiprocessing
where all CPUs are instruction-set compatible, but where different CPUs
have very different performance and energy-efficiency characteristics.
In the case of big.LITTLE, the big CPUs are
<a href="http://www.arm.com/products/processors/cortex-a/cortex-a15.php">Cortex-A15</a>
CPUs with deep pipelines and numerous functional
units, providing maximal performance.
In contrast, the LITTLE CPUs are
<a href="http://www.arm.com/products/processors/cortex-a/cortex-a7.php">Cortex-A7</a>
with short pipelines and few functional units,
which optimizes for energy efficiency.
<a href="http://www.linaro.org/">Linaro</a> is working on two methods of
supporting big.LITTLE systems.

<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>The first method pairs up each big CPU with a
LITTLE CPU, so that user applications are aware of only one CPU corresponding
to each such pair.
A given application thread can then be transparently migrated between
the big and LITTLE CPUs making up the pair, essentially providing
extreme dynamic voltage/frequency scaling.
Instead of merely varying the voltage and frequency, at some point the
application thread is migrated between the big and LITTLE CPUs making
up the corresponding pair,
as was described in an
<a href="http://lwn.net/Articles/481055/">earlier LWN article by
Nicolas Pitre</a>.
This approach is termed &ldquo;big.LITTLE Switcher.&rdquo;

<p>The other way to support big.LITTLE systems is to have all CPUs,
both big and LITTLE, visible in a multiprocessor configuration.
This approach offers greater flexibility, but also poses special
challenges for the Linux kernel.
For example, the scheduler assumes that CPUs are interchangeable,
which is anything but the case on big.LITTLE systems.
These big.LITTLE systems were therefore the subject of a
scheduler minisummit at last February's
Linaro Connect in the Bay Area which was
<a href="http://lwn.net/Articles/482344/">reported on at LWN</a>.

<p>This article summarizes progress since then, both on the relevant
mailing lists and as reported during the Linaro Connect sessions in
Hong Kong, and is divided into the following topics:

</p><ol>
<li>	<a href="#Emulating Asymmetric Computation on Commodity Systems">
	Emulate asymmetric computation on commodity systems</a>
<li>	<a href="#Documenting System Configuration for big.LITTLE Work">
	Document system configuration for big.LITTLE work</a>
<li>	<a href="#Define Mobile Workload and Create Simulator">
	Define mobile workload and create simulator</a>
<li>	<a href="#Address kthread Performance Issues">
	Address kthread performance issues</a>
<li>	<a href="#Wean CPU Hotplug from Stopping All CPUs">
	Wean CPU hotplug from stopping all CPUs</a>
<li>	<a href="#Add Minimal Support to Scheduler for Asymmetric Cores">
	Add minimal support to scheduler for asymmetric cores</a>
<li>	<a href="#Conclusions">
	Conclusions</a>
</ol>

<p>Following this are the inevitable
<a href="#Answers to Quick Quizzes">Answers to Quick Quizzes</a>.
</p><p>

</p><h4><a name="Emulating Asymmetric Computation on Commodity Systems"></a>
Emulating asymmetric computation on commodity systems</h4>

<p>The need to develop software concurrently with the corresponding hardware
has led to heavy reliance on various forms of emulation, and ARM's
asymmetric big.LITTLE systems are no exception.
Unfortunately, full emulation is quite slow, especially given that core
kernel code and user-level code really only needs a reasonable approximation
to big.LITTLE's performance characteristics.
What we need instead is some way to cause commodity systems to roughly
mimic big.LITTLE, for example, by artificially slowing down the CPUs
designated as LITTLE CPUs.

<p>There are a number of ways of slowing down CPUs, the first three of which
were discussed at the February
scheduler minisummit:
<p>
<ol>
<li>	Assign a high-priority <code>SCHED_FIFO</code> cycle-stealing
	thread for each designated LITTLE CPU, which consumes a
	predetermined fraction of that CPU's bandwidth.
<p>
<li>	Constrain clock frequencies of the LITTLE CPUs.
<p>
<li>	Make use of Intel's T-state capability.
<p>
<li>	Use <a href="https://perf.wiki.kernel.org/index.php/Tutorial">perf</a>
	to place a load on the designated-LITTLE CPUs.
</ol>
<p>
Rob Lee presented the results of experiments comparing the
cycle-stealing and clock-frequency approaches.
Morten Rasmussen proposed the perf-based approach,
in which he configured perf to interrupt the designated LITTLE CPUs
every few thousand cycles.
Each of these approaches has advantages and disadvantages, as
laid out in the following table:

<p><table cellspacing=2 cellpadding=2>
<tr><th>Type</th>
	<th>Transparent to Scheduler?</th>
		<th>Portability?</th>
			<th>Calibration?</th>
				<th>Scope?</th></tr>
<tr class="Odd"><td>Cycle stealing</td>
	<td><code>SCHED_FIFO</code> threads visible</td>
		<td>Portable</td>
			<td>Requires calibration for duty cycles less than about 10 milliseconds</td>
				<td>Process-level only</td></tr>
<tr class="Even"><td>Clock Frequency</td>
	<td>Transparent</td>
		<td>Requires per-CPU clock domains</td>
			<td>Auto-calibrating, but limited number of settings</td>
				<td>All execution</td></tr>
<tr class="Odd"><td>T-State</td>
	<td>Transparent</td>
		<td>Intel only</td>
			<td>Auto-calibrating</td>
				<td>All execution</td></tr>
<tr class="Even"><td>perf</td>
	<td>Transparent</td>
		<td>Requires fine-grained perf</td>
			<td>Requires calibration</td>
				<td>All code subject to perf exceptions</td></tr>
</table>

</p><div class="tlr"><a name="Quick Quiz 1"></a><b>Quick Quiz 1</b>:
How can you tell whether multiple CPUs on your system are in the same
clock domain?
<a href="#aqq1">Answer</a>
</div>

<p>As can be seen from the table, none of these mechanisms is perfect,
for example, many embedded systems-on-a-chip (SoCs) have multiple CPUs
(often all of them) in a given clock domain, which limits the applicability
of the clock-frequency approach.
Rob has placed scripts for the cycle-stealing and clock-frequency
approaches in a git tree
located at <tt>git://git.linaro.org/people/rob_lee/asymm_cpu_emu.git</tt>;
he plans to add Morten's perf-based approach as well.

<div class="tlr"><a name="Quick Quiz 2"></a><b>Quick Quiz 2</b>:
Given that these emulation approaches are never going to provide a
perfect emulation of big.LITTLE systems, why bother?
Wouldn't it be simpler to just wait until real hardware is available?
<a href="#aqq2">Answer</a>
</div>


<p>At this point, it seems likely that more than one of these will be
required in order to cover the full range of development hardware and
workloads.

</p><h4><a name="Documenting System Configuration for big.LITTLE Work"></a>
Documenting system configuration for big.LITTLE work</h4>

<p>The Linux kernel as it is today can handle big.LITTLE systems,
give or take hardware bring-up issues.
However, the current kernel does need some help to get
good results from a big.LITTLE system.
Chris Redpath's presentation is a first step towards determining the
best division of labor between current kernels and the application.

<p>Chris described an experiment running an Android workload on emulated
big.LITTLE hardware.
He made use of Android's <code>bg_non_interactive</code> cpuset,
which holds low-priority threads (<code>ANDROID_PRIORITY_BACKGROUND</code>)
and is limited to 10% of CPU usage.
Chris further constrained this cpuset to run only on CPU&nbsp;0, which on his
system is a LITTLE CPU.
Chris then created two new cpusets, <code>default</code> and
<code>fg_boost</code>.
The <code>default</code> cpuset is constrained to the LITTLE CPUs,
and contains all non-background tasks that are not <code>SCHED_BATCH</code>.
The <code>SCHED_BATCH</code> tasks remain in the <code>bg_non_interactive</code>
cpuset called out above.
The new <code>fg_boost</code> cpuset contains tasks that are
<code>SCHED_NORMAL</code> and that have a priority higher than
<code>ANDROID_PRIORITY_NORMAL</code>.

<p>Chris used a combination of sysbench and cyclictest as a rough-and-ready
mobile-like workload, where sysbench mimics high-CPU-consumption mobile
tasks (e.g., rendering a complex web page) and cyclictest mimics interactive
workloads (e.g., user input and communications).
Chris's configuration uses four sysbench compute threads and eight
cyclictest threads.
The sysbench threads all run for 15 seconds and then block for 10
seconds, and repeat this on a 25-second cycle.
The eight cyclictest threads run throughout the full benchmark run.
Without Chris's additional cgroups, the scheduler scattered the threads
across the system, slowing execution of the sysbench threads and wasting
power.
With the additional cgroups, the sysbench threads were confined to the
big CPUs, and the cyclictest threads to a single LITTLE CPU.

<p>In short, use of cpusets to constrain whether given threads run on big
or LITTLE CPUs works quite well, at least as long as we know a priori
which threads should run where.

<p>Chris also tested <code>sched_mc</code>, which can be set up to keep
short-lived tasks off of the big CPUs.
Although <code>sched_mc</code> was able to keep an additional CPU free
of work, it was unable to help the remaining CPUs to reach deeper sleep
states, and was nowhere near as effective as use of cpusets.
These big.LITTLE results support the decision taken at the February Linaro
Connect to remove <code>sched_mc</code> from the kernel.

<p>Finally, Chris tested userspace tools that dynamically migrate tasks
among the
CPUs in response to Android's priority boosting of foreground user-interface
(UI) threads.
In contrast, Chris's first approach statically assigned
the threads.
This approach required minor changes to the Android software stack.
Although this approach was effective in getting high-consumption UI
threads running on big CPUs, the migration latency rivaled the
bursts of UI CPU-bound activity, which in many cases defeats the purpose.
The migration latency would need to be decreased by about a factor of two
for this approach to be worthwhile, though your mileage may vary on
real hardware.
These results underscore the importance of planned scheduler changes
for dynamic general-purpose workloads.
<p>
Several other potential approaches were discussed:
<p>
<ol>
<li>	Use a modified <code>cpufreq</code> governor to switch between
	the big and LITTLE CPUs.
	One potential issue with this approach is that the governor
	currently runs at full frequency most of the time, in accordance
	with its race-to-idle strategy.
	Some tweaking would therefore be required for workloads for which
	race-to-idle is inappropriate.
<p>
<li>	Treat specific applications specially, for example, make big.LITTLE
	scheduling decisions based on the <code>-&gt;comm</code> name.
	This is likely to work well in some cases, but is unable to
	optimally handle applications that have different threads
	that want to run on different CPUs.
<p>
<li>	Rather than migrating threads from one cpuset to another, add and
	remove CPUs to given cpusets.
	This should reduce the sysfs overhead in some cases.
</ol>

<p>In short, it is possible to get decent performance out of big.LITTLE
systems on current Linux kernels for at least some workloads.
As more capabilities are added to the scheduler, we can expect
more workloads will run well on big.LITTLE systems, and also that
it will become easier to tune workloads that can already be made
to run well on big.LITTLE.

</p><h4><a name="Define Mobile Workload and Create Simulator"></a>
Define mobile workload and create simulator</h4>

<p>An easy-to-use mobile-workload simulator is needed to allow people
without access to the relevant hardware, emulators, and SDKs to evaluate
the effects of changes on mobile workloads.
The good news is that the work presented at Linaro Connect used
a number of synthetic workloads, but the not-so-good news is that
the setups are not yet generally useful.
Shortcomings include: (1)&nbsp;Much work is required to interpret the
output of the workloads, (2)&nbsp;The figures of merit are not constant,
but instead different figures of merit are chosen in different circumstances,
and of course (3)&nbsp;They are not (yet) nicely packaged.
Hopefully we will see additional progress going forward.

</p><h4><a name="Address kthread Performance Issues"></a>
Address kthread performance issues</h4>

<p>At the February Linaro Connect, Vincent Guittot presented
<a href="https://wiki.linaro.org/WorkingGroups/PowerManagement/Doc/Hotplug">work</a>
showing that the bulk of CPU-hotplug latency was due to creation,
teardown, and migration of the per-CPU kthreads that carry out housekeeping
tasks for various kernel subsystems.
Further discussion indicated that any mechanism that successfully
clears all current and future work from a given CPU will likely
incur similar latencies.

<p>In an ideal world, these per-CPU kthreads would automatically quiesce
when the corresponding CPU went offline, and then automatically spring back
into action when the CPU came back online, but without the overheads of
kthread creation, teardown, or migration.
Unfortunately, the scheduler does not take kindly to runnable tasks
whose affinity masks only allow them to run on CPUs that are currently
offline.
However, Thomas Gleixner noticed that there is one exception to this rule,
namely a set of per-CPU tasks that have exactly this property:
the idle tasks.
This key insight led Thomas to propose that the per-CPU kthreads
should have this same property, which should completely eliminate the
overhead of per-kthread creation, teardown, and migration.

<p>The idle tasks are currently created by each individual architecture,
so Thomas posted a
<a href="https://lkml.org/lkml/2012/4/20/160">patchset</a> that
moves idle-task creation to common code.
This patchset has been well received thus far, and went into mainline
during the 3.5 merge window.
Thomas has since followed up with a new
<a href="http://lwn.net/Articles/500338/">patch</a>
that allows kthreads to be parked and unparked.
The new <code>kthread_create_on_cpu()</code>,
<code>kthread_should_park()</code>,
<code>kthread_park()</code>, and
<code>kthread_unpark()</code> APIs can be applied to the per-CPU
kthreads that are now created and destroyed on each CPU-hotplug cycle.

<div class="tlr">
<a name="Quick Quiz 3"></a><b>Quick Quiz 3</b>:
This sounds way simpler than CPU hotplug, so why not just
get rid of CPU hotplug and replace it with this mechanism?
<a href="#aqq3">Answer</a>
</div>
<p>At the Q2 Linaro Connect in Hong Kong, Nicolas Pitre suggested
a different way to leverage the properties of idle tasks, namely
to provide a set of high-priority per-CPU idle tasks that would normally
be blocked.
When it was time to quiesce a given CPU, its high-priority idle task would
become runnable, preempting all of the rest of that CPU's tasks.
The high-priority idle task could then power down the CPU.
This approach can be thought of as a variant of idle-cycle injection.
There are some limitations to this approach, but it might work quite
well in situations where the CPU is to be quiesced for short periods
of time.

</p>
<p>In the meantime, Vincent Guittot has been experimenting with various
userspace approaches to reduce the per-kthread overhead.
One promising approach is to use cgroups to ensure that <tt>kthreadd</tt> (the
parent of all other kernel threads)
is guaranteed the CPU bandwidth needed during the hotplug operation.
Preliminary results indicate large improvements in latency.
Although this approach cannot achieve a five-millisecond CPU-hotplug
operation (a target adopted at the February meeting), it is nevertheless
likely to be useful for projects 
that are required to use current kernels with the existing slow
CPU-hotplug code.

</p><h4><a name="Wean CPU Hotplug from Stopping All CPUs"></a>
Wean CPU hotplug from stopping all CPUs</h4>

<p>Another source of CPU-hotplug slowness&mdash;and of real-time
latency degradation&mdash;is its use of <code>__stop_machine()</code>.
The problem is that <code>__stop_machine()</code> function causes
each CPU to run a special per-CPU <code>__stop_machine()</code>
kthread, which brings all processing on the system to a grinding
halt for the duration.
This system-wide grinding halt is bad for performance and fatal to real-time
response.
Given that other systems have managed to remove CPUs from service
without requiring such a grinding halt, it should be possible to
wean Linux's CPU-hotplug process from its <code>__stop_machine()</code>
habit.

<div class="tlrw">
<p><a name="Quick Quiz 4"></a><b>Quick Quiz 4</b>:
Why bother to fix CPU hotplug?
Wouldn't it be better to just rip it out and replace it with something better?
<a href="#aqq4">Answer</a>
</p></div>
<p>This is a large change, and will take considerable time and effort.
However, it is likely to provide good improvements in both performance
and robustness of CPU hotplug.

</p>

</p><h4><a name="Add Minimal Support to Scheduler for Asymmetric Cores"></a>
Add minimal support to scheduler for asymmetric cores</h4>

<p>There has been great progress in a number of areas.
First, Paul Turner posted a new version of his
<a href="https://lkml.org/lkml/2012/2/1/763">entity load-tracking patchset</a>.
This patchset should allow the scheduler to make better
(and more power-aware) task-placement and load-balancing decisions.
Second, Morten Rasmussen ran some experiments (including experimental
patches) on top of Paul Turner's patchset.
See below for more information.
Third, Peter Zijlstra posted a
<a href="https://lkml.org/lkml/2012/5/15/123">pair</a> of
<a href="https://lkml.org/lkml/2012/5/15/126">patches</a>
removing <code>sched_mc</code>
and also posted an
<a href="https://lkml.org/lkml/2012/5/15/256">RFC email</a>
proposing increased scheduler awareness of hardware topology.
This should allow the scheduler to better handle asymmetric
architectures such as ARM's big.LITTLE architecture.
Finally, Juri Lelli posted an
<a href="http://lwn.net/Articles/498472/">updated version</a>
of a prototype
<a href="https://github.com/jlelli/">
<code>SCHED_DEADLINE</code> patchset</a>,
which Juri has taken over from Dario Faggioli.
Please see below for a discussion of how
<code>SCHED_DEADLINE</code> might be used for energy efficiency on
big.LITTLE systems.

<p>Morten Rasmussen presented prototype enhancements to the Linux scheduler
that better accommodate big.LITTLE systems.
As noted above, these enhancements are based on Paul Turner's entity
load-tracking patchset.
The key point behind Morten's enhancements is that work should be
distributed <i>unevenly</i> on big.LITTLE systems in order to maximize
power efficiency with minimal performance degradation.
Unlike SMP systems, on big.LITTLE systems it matters deeply where
a given task is run, not just when a task is run.
Morten therefore created a pair of cgroups, one for the big CPUs
and another for the LITTLE CPUs, but with no load balancing between
them.
The <code>select_task_rq_fair()</code> function checks task load history
in order to make the correct big.LITTLE selection when a given task
starts running.
High-priority tasks that have tended to be CPU bound are placed on big CPUs,
and all other tasks are placed on LITTLE CPUs.

<p>Of course, a high-priority task that has historically been I/O bound
might enter a CPU-bound phase.
Therefore, Morten's patchset also periodically migrates tasks via
load balancing.
There are of course issues with global load balancing, and addressing
these issues is important future work.
Nevertheless, when running the Bbench browser benchmark on an
emulated big.LITTLE Android system, Morten's patches provided
response time very nearly that of an SMP system with all big CPUs,
both when running on SMP hardware emulating big.LITTLE and
when running on Paul Turner's <a href="/Articles/487701/">LinSched</a>.
This is clearly an impressive achievement.
In contrast, big.LITTLE response time on a vanilla kernel is 10-20% slower
with much worse variability in response times.

<p>Obviously, considerably more performance evaluation is required,
but preliminary results are quite promising.
In addition, more work will be required to handle thermal issues
and also to do load balancing of tasks back onto LITTLE CPUs when
all the big CPUs are saturated.

<p>Juri Lelli's <code>SCHED_DEADLINE</code> is quite important for some
types of real-time computing, but some thought is required to see possible
application to non-real-time big.LITTLE systems.
The key thing about <code>SCHED_DEADLINE</code> is that it provides the
scheduler with information about the likely future needs of the various
applications running on the system.
This information should allow the scheduler to make better big.LITTLE
task placement decisions, and also potentially better frequency-selection
decisions.

<p>Of course, this begs the question of where the deadlines and CPU
requirements come from.
In fact, one reason that deadline schedulers remain the exception
rather than the rule even for real-time applications is that it is
difficult to generate the needed information for a given real-time
application, especially given
<a href="https://www.osadl.org/?id=684">the non-deterministic
nature of modern hardware</a>
and variations in rendering time for different media&mdash;or even
for different segments of a given item being played back.
One way to solve this problem for some mobile workloads might be to
use feedback-directed profiling techniques, where the application's
CPU requirements are measured rather than derived.

<p>Regardless of how things turn out for the use of deadline
scheduling for mobile workloads, there is clearly some important
and innovative work ahead for power-aware scheduling of mobile
workloads.

<p>Finally, Vincent Guittot led a discussion on additional inputs
to the scheduler, which centered mainly around accurate load tracking
(e.g., Paul Turner's patchset), which CPUs share a clock (and thus must
all run at the same frequency), which CPUs share idle state, which
CPUs share each level of cache, and thermal constraints.
There was also a call to keep all this simple, which is clearly extremely
important&mdash;and also will likely be extremely difficult.
But if keeping things simple was easy, where would be the challenge?

<h4><a name="Conclusions"></a>
Conclusions</h4>

<p>Although there is still a great deal of work remaining before
mobile workloads fully exploit the power and power efficiency of
big.LITTLE, the past few months have seen some impressive progress
in that direction.
With appropriate user-mode help, some important workloads can make
good use of big.LITTLE systems even given the existing scheduler,
and some modest modifications (in conjunction with Paul Turner's
entity load-tracking patchset) greatly improves the scheduler's
ability to support big.LITTLE with minimal user-mode help.
A promising design for streamlining CPU hotplug has been identified,
and work in that direction has started.

<p>This work gives some hope that the future will be bright for asymmetric
multiprocessing in general and ARM's big.LITTLE architecture in
particular.

</p><h4><a name="Acknowledgments"></a>
Acknowledgments</h4>

<p>We all owe a debt of gratitude to Srivatsa Bhat, Juri Lelli, Daniel Lezcano,
Nicolas Pitre, Christian Daudt, Roger Teague, and George Grey
for helping to make this article human readable.
I owe thanks to Dave <font class="SpellingError">Rusling</font> and Jim <font class="SpellingError">Wasko</font> for their support of this effort.

</p><p></p><h4><a name="Answers to Quick Quizzes"></a>
Answers to quick quizzes</h4>

<a name="aqq1"></a>
<p><b>Quick Quiz 1</b>:
How can you tell whether multiple CPUs on your system are in the same
clock domain?

</p><p><b>Answer</b>:
Look at the contents of this <code>sysfs</code> file:

<pre>
    /sys/devices/system/cpu/cpu0/cpufreq/affected_cpus
</pre>

<p>This file lists all of the CPUs that are in the same clock domain
as CPU&nbsp;0.
Similar files are present for the rest of the CPUs.

</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>

<a name="aqq2"></a>
</p><p><b>Quick Quiz 2</b>:
Given that these emulation approaches are never going to provide a
perfect emulation of big.LITTLE systems, why bother?
Wouldn't it be simpler to just wait until real hardware is available?

</p><p><b>Answer</b>:
Indeed, none of these emulation methods will perfectly emulate big.LITTLE
systems.
Then again, the various big.LITTLE implementations will not be exactly
the same as each other anyway, so significant emulation error is
quite acceptable.
More importantly, these emulation approaches allow big.LITTLE software
work to proceed long before real big.LITTLE hardware is available.

</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>

<a name="aqq3"></a>
</p><p><b>Quick Quiz 3</b>:
This sounds way simpler than CPU hotplug, so why not just
get rid of CPU hotplug and replace it with this mechanism?

</p><p><b>Answer</b>:
First, CPU hotplug is still needed to isolate failing hardware,
which some expect to become more prevalent as transistors continue
to shrink.
Second, there are a number of limitations of Nicolas's approach
compared to CPU hotplug:
<ol>
<li>	Interrupts must be directed away from the CPU.
<p>
<li>	Timers must be migrated off of the CPU.
<p>
<li>	If a CPU is left in this state for more than two minutes,
	the softlockup subsystem will start reporting errors
	if there are runnable tasks affinitied to this CPU.
	One workaround is to migrate tasks away from this
	CPU, but that approach starts looking a lot like CPU
	hotplug.
<p>
<li>	If one of the preempted threads is hard-affinitied to the
	CPU and is holding a mutex, then that mutex cannot be
	acquired on any other CPU.
	If the CPU remains in this state very long, a system hang
	could result.
<p>
<li>	The per-CPU kthreads would need to be informed of this
	transition if it persists for very long.
</ol>

<p>In other words, as noted above, Nicolas's approach is appropriate
only for cases where the CPU is to be quiesced for a short time.

<p></p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>

<a name="aqq4"></a>
</p><p><b>Quick Quiz 4</b>:
Why bother to fix CPU hotplug?
Wouldn't it be better to just rip it out and replace it with something better?

</p><p><b>Answer</b>:
Although there is always a strong urge to rip and replace, the fact is
that any mechanism that successfully removes all current and future work
from a CPU will really need to remove all current and future work from
that CPU.
And it is the removal of all such work that makes CPU hotplug difficult,
not the actual powering down of the electronics.
Of course, this suggests the possibility of removing all work without
actually powering the CPU down, a possibility that is likely to be
supported by Thomas's ongoing CPU-hotplug rework.

</p><p><a href="#Quick%20Quiz%204"><b>Back to Quick Quiz 4</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Architectures-Arm">Architectures/Arm</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#big.LITTLE">big.LITTLE</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Scheduler-big.LITTLE">Scheduler/big.LITTLE</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/501501/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor501682"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A big.LITTLE scheduler update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2012 22:33 UTC (Tue)
                               by <b>Tara_Li</b> (guest, #26706)
                              [<a href="/Articles/501682/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
QQ2 - Answer 3:  We got into this mess by assuming symmetric multiprocessors would stay the rule for a long time.  This is the tip of the iceberg, and we should be aiming for the most general solution we can come up with, as it's going to take a lot of refinement down the road to get right.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501682/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor501733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A big.LITTLE scheduler update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2012 14:21 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/501733/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, there is a large amount of work ahead, and big.LITTLE is no doubt only the start.  But I find it quite encouraging that small changes can produce meaningful improvements: This means that we can make use of asymmetric hardware now and improve its performance, energy efficiency, and ease of use over time.<br>
<p>
But yes, there might well be very large changes required over the longer term.  It should be fun!  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor501723"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A big.LITTLE scheduler update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2012 9:46 UTC (Wed)
                               by <b>liam</b> (guest, #84133)
                              [<a href="/Articles/501723/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Regarding the  __stop_machine kthread, that sounds like it behaves like old fashioned garbage collectors. Is there any possibility in using concurrent GC techniques to help with this problem?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501723/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor501734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A big.LITTLE scheduler update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2012 14:27 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/501734/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From what I can see, __stop_machine() was designed to simplify some of the synchronization issues surrounding CPU hotplug.  As you say, there might be an analogy between __stop_machine() and the stop-the-world nature of some garbage collectors.  That said, my personal guess is that a more-organized CPU-hotplug notification strategy will help quite a bit, and modifications to the way that CPUs are iterated over will help some more.  In contrast, concurrent garbage collectors cannot assume much about the data that they collecting garbage from.<br>
<p>
But we will see!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor501816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A big.LITTLE scheduler update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2012 19:32 UTC (Wed)
                               by <b>charlesgt_arm</b> (guest, #83016)
                              [<a href="/Articles/501816/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Regarding simulation of b/L in symmetric. Would another option be to use hrtimers? I am not that well versed there, but initial reading suggested to me that you can run them per core, and in interrupt context. If the latter is true (former helps but not essential) then it should be fairly trivial to create a driver which interrupts the cores at given frequency and then spins in the callbacks for a period of time. Ugly, but then all cycle stealing is. The driver could offer a simple interface to select period and duty cycle (spin time). The solution (assuming hrtimer is generally supported) would be generic<br>
<p>
Cheers<br>
<p>
Charles<br>
 <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor501864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A big.LITTLE scheduler update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2012 23:38 UTC (Wed)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/501864/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds like another potentially reasonable approach to me!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor502741"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A big.LITTLE scheduler update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2012 18:08 UTC (Wed)
                               by <b>olivier_cozette</b> (guest, #84087)
                              [<a href="/Articles/502741/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The main reason we choose perf is that there is nothing to do, no kernel change, nothing new to write in user mode.<br>
We just need to run the user mode perf on every CPU that should be a LITTLE one and that's all!<br>
<p>
Cheers,<br>
Olivier<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/502741/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor502841"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A big.LITTLE scheduler update</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2012 12:30 UTC (Thu)
                               by <b>pantoniou</b> (subscriber, #85257)
                              [<a href="/Articles/502841/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please take a look at this:<br>
<p>
[PATCH] [CPUFREQ] VCPUfreq: Virtual CPU frequency driver<br>
<p>
<a href="http://lists.linaro.org/pipermail/linaro-dev/2012-June/012483.html">http://lists.linaro.org/pipermail/linaro-dev/2012-June/01...</a><br>
<p>
I did try to use hrtimers at first but the API to do what was needed seems to be missing.<br>
<p>
Anyway, using the omap timers was relatively easy, and I'm sure most recent SoCs have a multitude<br>
of timers; the requirement is to have one per CPU.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/502841/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor501913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Race-to-idle</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 9:08 UTC (Thu)
                               by <b>ttonino</b> (guest, #4073)
                              [<a href="/Articles/501913/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Race-to-idle was introduced by Intel. Intel has a high-leakage process and agressive sitch off of components in idle, making race-to-idle a good strategy for Intel hardware.<br>
<p>
That is also why Intel needs the deeper sleep states as compared to (at least older SOI) AMD chips.<br>
<p>
I think it needs to be figured out on a per-device basis. It is dependent on chip architecture (what gets switched off when) and on process/manufacture (how much leakage is there at the lowest voltage levels).<br>
<p>
Also important: how often does one witch on and off, and how much power does that take. Emptying a cache to memory is not free.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor501960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Race-to-idle</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 12:46 UTC (Thu)
                               by <b>yaap</b> (subscriber, #71398)
                              [<a href="/Articles/501960/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're right there's some implementation variations. This said, leakage becomes nasty even on LP processes nowadays. It used to be the case that clock gating could be sufficient, but from 40nm downward (even in 40LP, the low-power / low leakage variant) for good performance you want power gating for long durations. So the notion of race to idle will apply to most systems, and I can testify it applies to embedded SoCs very (VERY ;) far from Intel CPUs.<br>
<p>
There will still be variations in how long is needed to justify the cost of mode changes, and what are the operating points available for DVFS (dynamic voltage and frequency scaling). But this may be handled as configuration.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor502022"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Race-to-idle</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 17:23 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/502022/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One way to reduce leakage current is to switch from a big CPU to a LITTLE CPU.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/502022/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor502190"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank you Paul!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2012 16:37 UTC (Fri)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/502190/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't have anything profound to add.  I just wanted to say I really enjoyed the article and found it extremely informative, and a big "thank you" to Paul for all the effort he obviously put into it.  It seems these articles don't always get as much commentary as more "bite sized" items but please don't think that means they're not widely read and appreciated.<br>
<p>
Kudos!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/502190/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor502285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank you Paul!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 16, 2012 2:10 UTC (Sat)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/502285/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Glad you liked it!  ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/502285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
