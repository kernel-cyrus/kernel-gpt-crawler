        <!DOCTYPE html>
        <html lang="en">
        <head><title>The trouble with volatile [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/233479/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/232961/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/233479/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The trouble with volatile</h1>
<div class="Byline">[Posted May 9, 2007 by corbet]
               <p>
               </div>
</div>
<div class="ArticleText">
Your editor's copy of <i>The C Programming Language, Second Edition</i>
(copyright 1988, still known as "the new C book") has the following to say
about the <tt>volatile</tt> keyword:
<p>
<div class="BigQuote">
	The purpose of volatile is to force an implementation to suppress
	optimization that could otherwise occur.  For example, for a
	machine with memory-mapped input/output, a pointer to a device
	register might be declared as a pointer to <tt>volatile</tt>, in
	order to prevent the compiler from removing apparently redundant
	references through the pointer.
</div>
<p>
C programmers have often taken <tt>volatile</tt> to mean that the variable
could be changed outside of the current thread of execution; as a result,
they are sometimes tempted to use it in kernel code when shared data
structures are being used.  Andrew Morton recently <a
href="/Articles/233481/">called out</a> use of <tt>volatile</tt> in a
submitted patch, saying:
<p>
<div class="BigQuote">
	The volatiles are a worry - volatile is said to be
	basically-always-wrong in-kernel, although we've never managed to
	document why, and i386 cheerfully uses it in readb() and friends.
</div>
<p>
In response, Randy Dunlap <a href="/Articles/233482/">pulled together some
email from Linus</a> on the topic and suggested to your editor that he
could maybe help "document why."  Here is the result.
<p>

The point that Linus often makes with regard to <tt>volatile</tt> is that
its purpose is to suppress optimization, which is almost never what one
really wants to do.  In the kernel, one must protect accesses to data
against race conditions, which is very much a different task.  
<p>

Like <tt>volatile</tt>, the kernel primitives which make concurrent access
to data safe (spinlocks, mutexes, memory barriers, etc.) are designed to
prevent unwanted optimization.  If they are 
being used properly, there will be no need to use <tt>volatile</tt> as
well.  If <tt>volatile</tt> <i>is</i> still necessary, there is almost
certainly a bug in 
the code somewhere.  In properly-written kernel code, <tt>volatile</tt> can
only serve to slow things down.
<p>

Consider a typical block of kernel code:
<p>
<pre>
    spin_lock(&amp;the_lock);
    do_something_on(&amp;shared_data);
    do_something_else_with(&amp;shared_data);
    spin_unlock(&amp;the_lock);
</pre>
<p>
If all the code follows the locking rules, the value of
<tt>shared_data</tt> cannot change unexpectedly while <tt>the_lock</tt> is
held.  Any other code which might want to play with that data will be
waiting on the lock.  The spinlock primitives act as memory barriers - they
are explicitly written to do so - 
meaning that data accesses will not be optimized across them.  So the
compiler might think it knows what will be in <tt>shared_data</tt>, but the
<tt>spin_lock()</tt> call will force it to forget anything it knows.  There
will be no optimization problems with accesses to that data.
<p>
If <tt>shared_data</tt> were declared <tt>volatile</tt>, the locking would
still be necessary.  But the compiler would also be prevented from
optimizing access to <tt>shared</tt> <i>within</i> the critical section,
when we know that nobody else can be working with it.  While the lock is
held, <tt>shared_data</tt> is not volatile.  This is why Linus says:
<p>
<div class="BigQuote">
	Also, more importantly, "volatile" is on the wrong _part_ of the
	whole system. In C, it's "data" that is volatile, but that is
	insane. Data isn't volatile - _accesses_ are volatile. So it may
	make sense to say "make this particular _access_ be careful", but
	not "make all accesses to this data use some random strategy".
</div>
<p>
When dealing with shared data, proper locking makes <tt>volatile</tt>
unnecessary - and potentially harmful.
<p>
The <tt>volatile</tt> storage class was originally meant for memory-mapped
I/O registers.  Within the kernel, register accesses, too, should be
protected by locks, but one also does not want the compiler "optimizing"
register accesses within a critical section.  But, within the kernel, I/O
memory accesses are always done through accessor functions; accessing I/O
memory directly through pointers is frowned upon and does not work on all
architectures.  Those accessors are written to prevent unwanted
optimization, so, once again, <tt>volatile</tt> is unnecessary.
<p>
Another situation where one might be tempted to use <tt>volatile</tt> is
when the processor is busy-waiting on the value of a variable.  The right
way to perform a busy wait is:
<p>
<pre>
    while (my_variable != what_i_want)
        cpu_relax();
</pre>
<p>
The <tt>cpu_relax()</tt> call can lower CPU power consumption or yield to a
hyperthreaded twin processor; it also happens to serve as a memory
barrier, so, once again, <tt>volatile</tt> is unnecessary.  Of course,
busy-waiting is generally an anti-social act to begin 
with.

<p>
There are still a few rare situations where <tt>volatile</tt> makes sense
in the kernel:
<p>
<ul>
<li> The above-mentioned accessor functions might use <tt>volatile</tt> on 
     architectures where direct I/O memory access does work.  Essentially,
     each accessor call becomes a little critical section on its own and
     ensures that the access happens as expected by the programmer.
<p>
<li> Inline assembly code which changes memory, but which has no other
     visible side effects, risks being deleted by GCC.  Adding the
     <tt>volatile</tt> keyword to <tt>asm</tt> statements will prevent this
     removal.
<p>
<li> The <tt>jiffies</tt> variable is special in that it can have a
     different value every time it is referenced, but it can be read
     without any special locking.  So <tt>jiffies</tt> can be
     <tt>volatile</tt>, but the addition of other variables of this type is
     frowned upon.  Jiffies is considered to be a "stupid legacy" issue
     in this regard.
</ul>
<p>
For most code, none of the above justifications for <tt>volatile</tt>
apply.  As a result, the use of <tt>volatile</tt> is likely to be seen as a
bug and will bring additional scrutiny to the code.  Developers who are
tempted to use <tt>volatile</tt> should take a step back and think about
what they are truly trying to accomplish.

<p>

(Thanks to Randy Dunlap for getting things started and researching the
issue, and to Satyam Sharma, and Johannes Stezenbach for comments on the
first draft of this article).<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Coding_style">Coding style</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#volatile">volatile</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/233479/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor233798"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 10, 2007 17:38 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/233798/">Link</a>] 
      </p>
      
      </div>
      </summary>
      One other use for volatile is when communicating with interrupt/NMI handlers running on the same CPU.  In this case, all the accesses are on the same CPU, so CPU reordering is irrelevant -- CPUs see their own accesses in order.  The only requirement is that the compiler avoid optimizations that re-order the code.<br>
<p>
Note that this applies only to hardware interrupts or NMIs -- this technique does not necessarily work for "interrupt handlers" that are passed off to threads.<br>
<p>
So this is a specialized technique (especially in -rt), but an entirely valid one.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/233798/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor233854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 10, 2007 22:04 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/233854/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      People who think they want something volatile should know that assigning to a volatile variable, or through a pointer to volatile, generates a store instruction <i>followed by a load instruction</i>.  The load is normally optimized away, but the language definition says it's there (because an assignment has a value), and you said you didn't want optimization.  Sometimes the extra load just slows things down, but if the address is really a register, it may be actively wrong.
      
          <div class="CommentReplyButton">
            <form action="/Articles/233854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor233902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2007 5:54 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/233902/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <P>Huh?  That makes no sense.  The *assignment statement* has a value, sure, and that's the value referenced in any outer context.  For example:
</P><PRE>
volatile int   a;
volatile short b;
volatile int   c;

a = b = c;</PRE>
<P>
This code will read 'c' cast it to the type of 'b', and then write it to 'b'.  That whole expression, 'b = c', takes on the same value as was written to 'b'.  That value gets written to 'a'.  You aren't reading 'b' and assigning it to 'a', you're assigning the value of the expression 'b = c', plain and simple.  That makes sense.  Let's suppose 'b' gets modified by an interrupt handler, and the interrupt happens right after the write to 'b'.  The code will always write the same value to 'a' regardless of whether 'b' even takes on the value written to it.
</P>
<P>
Now, on a compiler that doesn't do register allocation, or for which that's disabled, the value of the expression 'b = c' might get written to a compiler temporary in memory, and the compiler issues writes and reads for <I>that</I> location.  I assert it's actually incorrect to read 'b' and write it to 'a' when writing 'a = b = c'.</P>
<P>
If all assignments had a hidden read behind them, then <A HREF="http://en.wikipedia.org/wiki/Duff%27s_Device">Duff's Device</A> probably would never have worked.  The motivation for Duff's Device was fast writes through a volatile pointer to a hardware FIFO.
</P>
<P>
Now, C++ on the other hand...  they allow assignments to be lvalues, which causes all sorts of wackiness.  And so C++ apparently <I>does</I> behave somewhat as you describe, at least in the 'a = b = c' case.  (An assignment in isolation still doesn't have a phantom read.)  It bolsters my argument above that they consider this a deviation from how C behaves.  <A HREF="http://www.open-std.org/JTC1/sc22/wg21/docs/cwg_active.html">Take a peek here.</A></P>
<P>
At any rate, since we're talking about the Linux kernel, we're talking C, not C++.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/233902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor233913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2007 6:45 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/233913/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Hmmm...<br>
<p>
I did some playing around, and it appears different compilers treat the a = b = c case rather differently than I expected.  Some *do* in fact read 'b' after writing it (which just seems crazy to me).<br>
<p>
I've asked our compiler optimizer lead developer at work his take on this topic.<br>
<p>
In the meantime, allow me to throw a mea culpa out there and then I'll shut up.  :-)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/233913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor234384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2007 9:15 UTC (Tue)
                               by <b>IkeTo</b> (subscriber, #2122)
                              [<a href="/Articles/234384/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I think the original response says the following simpler code will cause a store plus load:

<pre>
volatile int a;
void f() {
        a = 2;
}
</pre>

The argument is that "a = 2" has a value which requires a load to find, and the compiler is forbidden from optimizing out that load.  I don't think the code generated by my 4.1.1 gcc reflects this, however:

<pre>
        movl    $2, a
        ret
</pre>

So perhaps the OP is speaking from a rather old experience or a different compiler.

      
          <div class="CommentReplyButton">
            <form action="/Articles/234384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor234404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2007 12:20 UTC (Tue)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/234404/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I spoke to the compiler optimizer lead at work.  He assures me that assignment ONLY implies a write, even if the value of the assignment expression is used in a subsequent expression.<br>
<p>
At least as far as he's concerned, "a = 2" should only compile to a write, and "a = b = 2" should compile to two writes.  "a = b = c" should compile to one read (reading 'c'), and two writes (to 'a' and 'b').<br>
<p>
That said, our compiler actually compiled "a = b = c" more like "b = c; a = c" (reading 'c' twice), which he indicated was a bug.  GCC seems to compile "a = b = c" more like "b = c; a = b", which is actually pretty close to what the OP was suggesting would happen.  (Read 'c', Write 'b'.  Read 'b', write 'a'.)  Fun stuff.<br>
<p>
So... a secondary lesson is, "However YOU might have interpreted the C specification, chances are your compiler treats it differently for anything other than the simplest of expressions."<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/234404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor233909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2007 6:16 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/233909/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>Hiding 'volatile' in the various accessor macros, etc. is entirely different than bare 'volatile' in the code.  The statement that "volatile is said to be basically-always-wrong in-kernel" applies to the second case in my opinion.
</P><P>
The platform and compiler specific trickery is safely hidden away, and the rest of the kernel "does the right thing" no matter where it runs.  
</P><P><A HREF="http://lxr.linux.no/source/Documentation/memory-barriers.txt">This document</A> will keep you busy for awhile.  Heavy stuff.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/233909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor234040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2007 21:50 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/234040/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>Linus' conclusion may be right, but his reasoning is all wrong.

<p>First, while the <em>purpose</em> (reason for existence) of "volatile" is to prevent optimization, that's not what it's definition is.  The keyword "volatile" does not say to not optimize; it says the value may change all by itself.  So the fact that disabling optimization is a poor goal is not an argument against using "volatile."
<p>
Then Linus misinterprets the English word "volatile" and claims that <em>data</em> isn't volatile; rather <em>accesses</em> are volatile.  The opposite is true.
<p>
I think he should have instead pointed out that some data is known to be involatile some of the time, so it is better if you can declare specifically when the data is volatile rather than just say it is volatile in general.
<p>
But the ways provided are just as over-general in the other direction.  They say in a certain interval <em>every</em> memory location is volatile.
There may be variables that due to circumstances cannot change while cpu_relax() runs.  The program unnecessarily rereads memory.
<p>
I don't doubt that analysis shows that this over-generalization is better than the other over-generalization, but at least we should understand what comparison we're making.

      
          <div class="CommentReplyButton">
            <form action="/Articles/234040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor234175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2007 7:16 UTC (Mon)
                               by <b>xoddam</b> (guest, #2322)
                              [<a href="/Articles/234175/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Thanks girrafedata -- you have summed up all my niggling doubts about Linus' argument.  His sweeping generalisations apply as well to explicit barriers as they do to volatile; they are undoubtedly the best solution to the problems they are used in the Linux kernel to solve, but they are not so much less general that his argument sweeps all before it.<br>
<p>
What you don't mention (and Linus does) is that volatile can actually produce incorrect (as well as inefficient) code, because the compiler is not necessarily able to produce the right kind of barrier operation.  Compilers know about instruction architectures and, maybe, something about which optimisations work best for which processor families, but they aren't oracles on the most appropriate bus synchronisation operations for every system architecture.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/234175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor234392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 15, 2007 11:12 UTC (Tue)
                               by <b>IkeTo</b> (subscriber, #2122)
                              [<a href="/Articles/234392/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; it says the value may change all by itself.</font><br>
<p>
I think the inaccuracy and uselessness of this statement is what Linus is really objecting to.  With this being inaccurate and useless, the compiler are forced to do useless things as a result.  But those are side effects, the real culprit is still the inaccuracy and uselessness.<br>
<p>
I believe the inaccuracy of "volatile" is that it says the memory is always changing, which is not really the case.  The memory is changed by some other threads, or by some reordering done by some smart CPUs.  It is definitely not "changing all the time", with the exception of I/O mapped memory which might.<br>
<p>
I think it is mostly useless, because in most cases a simple "volatile" will not do what is intended, and to do what is intended you need something that will make volatile redundant.<br>
<p>
E.g., if you are afraid of some other threads changing your variables, you need a lock to prevent that, rather than just an advice to the compiler not to optimize things out; and once you get that, the CPU reordering is dealt with, and the variable is no longer changing at all within the critical region, so you don't want volatile.<br>
<p>
Another reply supplies another example: if you do inter-processor communications, "volatile" is not sufficient, because the instruction reordering done by the CPU causes the result to be erratic.  You need something like barrier(), rmb(), wmb(), etc.  Once you have that, "volatile" is redundant.  Yes, those operations are over-general, but at least they work.<br>
<p>
What if you really want to do I/O memory mapped read/write?  Again, you need memory barriers for the code to work correctly, and once you have them, you don't need volatile.<br>
<p>
<font class="QuotedText">&gt; Then Linus misinterprets the English word "volatile" and claims that data</font><br>
<font class="QuotedText">&gt; isn't volatile; rather accesses are volatile. The opposite is true.</font><br>
<p>
I agree that it is difficult to characterize an "access" is "volatile" or not, and I admit that I don't quite understand the statement.  On the other hand, while "data is volatile" might be true for some time during the execution of the kernel, the "volatile" in the C language does not provide you the abstraction that you need most of the time.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/234392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor234552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2007 11:43 UTC (Wed)
                               by <b>massimiliano</b> (subscriber, #3048)
                              [<a href="/Articles/234552/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>
<i>
I agree that it is difficult to characterize an "access" is "volatile" or not, and I admit that I don't quite understand the statement. On the other hand, while "data is volatile" might be true for some time during the execution of the kernel, the "volatile" in the C language does not provide you the abstraction that you need most of the time.
</i>
</p>

<p>
A funny thing, that made me ring a bell...
</p>

<p>
In the .NET bytecode specification (called "CIL", Common Intermediate Language), there <i>is</i> the possibility to define something as "volatile", and... guess what? it is accesses that can be marked so, not variables!
</p>

<p>
This reinforces my idea that the .NET standard is very well thought
out: they really learned from the mistakes of the past, at least on
technical issues.
</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/234552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor234594"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2007 16:07 UTC (Wed)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/234594/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
In the .NET bytecode specification (called "CIL", Common Intermediate
Language), there is the possibility to define something as "volatile",
and... guess what? it is accesses that can be marked so, not variables!
<p>
This reinforces my idea that the .NET standard is very well thought out:
they really learned from the mistakes of the past, at least on technical
issues.
</blockquote>
<p>
You're implying that "volatile" in C was a mistake.  It wasn't.  While it isn't useful for coordinating threads on separate processors in a 2007 Linux kernel, it's just fine for what it was designed for: coordinating a CPU with a memory-mapped I/O device in the early '80s.
<p>
I don't know anything about .NET, but I think the most you can conclude from this volatile thing is that .NET is designed for more modern computers than ANSI C.  And that the spec is written poorly -- "volatile" is the wrong word for this.

      
          <div class="CommentReplyButton">
            <form action="/Articles/234594/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor234072"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 12, 2007 3:46 UTC (Sat)
                               by <b>mikov</b> (guest, #33179)
                              [<a href="/Articles/234072/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      There have been some very fun discussions about volatile on comp.std.c in the past.  Basically my opinion, although I have never been able to convince anybody, is that volatile is _always_ wrong even in user mode. Period. It serves no purpose whatsoever that couldn't be achieved much better and more reliably in a different way. To put it another way, volatile is useless in a 100% standard-compliant C program, and if the program is not 100% compliant, then it is even more useless.<br>
<p>
Also, not all compilers implement it. Notably Borland C in some of its versions didn't.<br>
<p>
People might argue that it is useful with signals or longjmp(), but the need for volatile in such scenarios is always an indication of a serious problem in the code.<br>
<p>
The way I find it easy to think about it or explain it is that volatile does nothing to prevent the CPU reordering memory accesses, not to mention the visibility of memory accesses across different CPUs. So, it just muddles the issues.<br>
<p>
I want to open a big bracket here and mention that volatile in Java an entirely different beast and is much much more useful. According to the Java memory model, volatile actually has very useful guarantees for memory  visibility. (Perhaps Linux should consider Java for the kernel :-)<br>
<p>
Still, I agree with what already has already been said earlier: it is conceptually wrong to mark data as volatile. Accesses should be marked, bit the data itself. So, Java doesn't get it 100% right either. (But of course it wasn't possible to add lightweight volatile accesses to Java without modifying the language).<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/234072/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor234238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2007 15:07 UTC (Mon)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/234238/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      "People might argue that it is useful with signals or longjmp(), but the need for volatile in such scenarios is always an indication of a serious problem in the code."<br>
<p>
These are the two cases defined by the standard where volatile *must* be used for certain variables. Memory-mapped I/O is the third case it was intended for, but as that's inherently unportable the standard doesn't explicitly mention it. (I think the rationale does.)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/234238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor234298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2007 17:30 UTC (Mon)
                               by <b>mikov</b> (guest, #33179)
                              [<a href="/Articles/234298/">Link</a>] 
      </p>
      
      </div>
      </summary>
      You are right. IIRC, it is required for local variables with setjmp(). I forgot the other case. What was it ? (Hmm, I have my C99 standard somewhere here..)<br>
<p>
In any case, it doesn't mean that it actually is a good idea. Requiring volatile for setjmp() is a terrible, fragile, ugly hack. It's been some time since I thought about this, but off the top of my head:<br>
<p>
This requirement presumes that the compiler doesn't know anything about setjmp()/longjmp(). What if the function invoking setjmp() gets auto-inlined ? Obviously the programmer can't be required to use volatile for all variables in all functions up the call tree. What is to prevent the auto-inlining ? <br>
<p>
I don't view the standard as a mantra. After all, it did standardize "atoi"  ... There is no excuse for that. There are things in the C99 that strike me as absolutely horrible.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/234298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor234540"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2007 8:38 UTC (Wed)
                               by <b>roelofs</b> (guest, #2599)
                              [<a href="/Articles/234540/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <FONT COLOR="#440066"><I>The way I find it easy to think about it or explain it is that volatile does nothing to prevent the CPU reordering memory accesses, not to mention the visibility of memory accesses across different CPUs.</I></FONT>

<P>
Well, more generally, the C and C++ languages themselves do nothing to prevent such problems (unlike Java)--they are blissfully unaware of all concurrency-related issues, and as a consequence, there is nothing you can do about any of it using only language-provided constructs.  Some form of assembly-level support is always required.

<P>
Note that, fundamentally, it's the same problem afflicting the Double-Checked Locking Pattern (C/C++ version).  Scott Meyers' (co-authored) <A HREF=
"http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">2004 DDJ article</A> describes the issues quite nicely.

<P>
Greg
      
          <div class="CommentReplyButton">
            <form action="/Articles/234540/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor234556"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The trouble with volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 16, 2007 11:48 UTC (Wed)
                               by <b>massimiliano</b> (subscriber, #3048)
                              [<a href="/Articles/234556/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
<i>
I want to open a big bracket here and mention that volatile in Java an entirely different beast and is much much more useful. According to the Java memory model, volatile actually has very useful guarantees for memory visibility. (Perhaps Linux should consider Java for the kernel :-)
</i>
</p>

<p>
Or C#... it <a href="http://lwn.net/Articles/234552">seems</a> that the
.NET platform is even more specific than Java in this sense :-)
</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/234556/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor435922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A fourth case</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 29, 2011 21:43 UTC (Tue)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/435922/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have a device which will DMA entries to a block of memory.<br>
To determine if an entry is new or old, there is a phase bit which is flipped each time around the ring.  So I rely on the compiler actually loading from memory, and not using a cached copy of that bit.<br>
<p>
See uses of volatile in <a href="http://git.kernel.org/?p=linux/kernel/git/willy/nvme.git;a=blob;f=drivers/block/nvme.c;h=014a7f6e39bcc6376d3f6048db58eda8bd0d554c;hb=HEAD">http://git.kernel.org/?p=linux/kernel/git/willy/nvme.git;...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/435922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2007, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
