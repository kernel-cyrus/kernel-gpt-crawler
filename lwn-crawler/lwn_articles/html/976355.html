        <!DOCTYPE html>
        <html lang="en">
        <head><title>Removing GFP_NOFS [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/976355/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/975975/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/976355/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Removing GFP_NOFS</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>June 5, 2024</br>
           <hr>
<a href="/Articles/lsfmmbpf2024/">LSFMM+BPF</a>
</div>
<p>
The <tt>GFP_NOFS</tt> flag is meant for kernel memory allocations that
should not cause a call into the filesystems to reclaim memory because there are
already locks held that can potentially cause a deadlock.  The "scoped
allocation" API is a better choice for filesystems to indicate that they
are holding a lock, so <tt>GFP_NOFS</tt> has <a
href="/Articles/753078/">long been on the chopping block</a>, though
progress has been slow.  In a filesystem-track session at
the 2024 <a
href="https://events.linuxfoundation.org/lsfmmbpf/">Linux Storage,
Filesystem, Memory Management, and BPF Summit</a>, Matthew Wilcox wanted to
discuss how to move kernel filesystems away from the flag with the eventual
goal of removing it completely.
</p>

<p>
He began the session by saying that there are several changes
that people would like with regard to the <tt>GFP</tt> flags, but that
the scoped-allocation API (i.e. <a
href="https://elixir.bootlin.com/linux/v6.9.3/source/include/linux/sched/mm.h#L366"><tt>memalloc_nofs_save()</tt>
and <tt>memalloc_nofs_restore()</tt></a> as mentioned in the <a
href="/ml/linux-fsdevel/ZZcgXI46AinlcBDP@casper.infradead.org/">LSFMM+BPF
topic discussion</a>) for <tt>GFP_NOFS</tt> went in long ago, while the
conversion to it is far from complete.  He also wanted to talk a bit about
Rust, he said. There is a desire to bring in Rust code from outside the
kernel for, say, a hash table, but that requires the ability to allocate
memory, which means making <tt>GFP</tt> flags available.  "Why the hell
would we want to add <tt>GFP</tt> flags to every Rust thing that we bring
into the kernel?  That's crazy."
</p>

<p>
So, he asked, what interface would the filesystem developers like to have to
indicate that an allocation should not recurse into the filesystem code;
the existing 
interface is, seemingly, not the right one, since filesystems are generally
not using it.  Josef Bacik said that from the Btrfs perspective, there is no real
advantage to switching away from <tt>GFP_NOFS</tt> because there are
other <tt>GFP</tt> flags that it still needs to use.  The flags are already
plumbed through the Btrfs code, so it is just easier to add another
<tt>GPF_NOFS</tt> use when that situation arises.
</p>

<a href="/Articles/976854/">
<img src="https://static.lwn.net/images/2024/lsfmb-wilcox-sm.png" border=0 hspace=5 align="right"
alt="[Matthew Wilcox]" title="Matthew Wilcox" width=220 height=270>
</a>

<p>
But the Rust use case is
not one he had considered before; it is the first example he has seen where
the save and restore interface makes a difference that makes the switch
worth doing.
Bacik said that he would be willing to change the code to eliminate
<tt>GFP_NOFS</tt> if that was requested, but it has not really "seemed like
a pressing need", so far, to him.  The Rust need for the switch changes
that equation in his mind.
</p>

<p>
Jan Kara said that he has been working on removing the flag from ext4 and
other places, but has found it inconvenient to do in some parts of the
code.  Passing the cookie that gets returned from the save operation
through, so that it is available to pass to the restore, is ugly and makes
the conversion harder, he said.  Similarly, there are locks that are taken
in some paths such that recursing back into the filesystem needs to be
prevented (which is what <tt>GFP_NOFS</tt>
protects against). Rather than having code that manually does the save and
restore while managing the cookie, marking those locks in a way that causes
the system to automatically
handle the allocation scope would make things easier for
conversions. 
</p>

<p>
Rust for Linux developer Wedson Almeida Filho said that it was painful to
have to manage and think about all of the different <tt>GFP</tt> flags in
the code.  He wondered if there were some way to automatically set the
scope by detecting the areas where one of them is needed.  Ideally, that detection
would happen at compile time; there could perhaps be support in Rust for
that, he suggested.
</p>

<p>
Wilcox said that it depends on the specific filesystem, because they work
in different ways with regard to their locking.  The detection would
have to know that a particular lock is taken during the reclaim path, for
example.  Kara suggested that <a
href="https://www.kernel.org/doc/html/latest/locking/lockdep-design.html">lockdep</a>
might help, but Wilcox seemed 
skeptical, noting that lockdep cannot say that a particular lock is never
taken in the reclaim path, for example.  Dave Chinner agreed that it would
be difficult to detect that situation since the filesystem code, its
locking, and the interaction with the reclaim path are extremely complex.
</p>

<p>
There was some discussion between Chinner, Almeida, and Kent Overstreet
about the difficulty of automatically detecting the proper context.  There
is also some interaction with lockdep, which emits false-positive warnings;
that has led the XFS developers to use the <tt>__GFP_NOLOCKDEP</tt> flag
(some of which is <a href="/Articles/958426/">described in a patch from
January</a>).  It was all rather fast-moving and technically deep.
</p>

<p>
Overstreet raised the idea of <a href="/Articles/964793/">preventing
kernel allocations from failing</a> (effectively making <tt>GFP_NOFAIL</tt>
more widespread).  He is opposed to that effort because he thinks that it
is important to ensure that the error paths are well-tested both for
allocation failure and other errors.  But he wondered if making that change
might eliminate the need for <a
href="https://www.kernel.org/doc/html/latest/core-api/mm-api.html?highlight=mempool#memory-pools">memory
pools</a> (or "mempools").
</p>

<p>
Chinner said that there is a difference between mempools and the no-fail
case: mempools provide a guarantee of forward progress that no-fail does
not.  In particular, when memory is being reclaimed, there is no guarantee
that whatever needs the memory will actually get it.  That reclaimed memory
could be allocated to some other task, unlike with
mempools. 
He thought it would be difficult to be sure that making that switch would
work in all cases.
</p>

<p>
But what a no-fail policy does do, he continued, is remove the possibility
of dereferencing null pointers when there is an allocation failure.  Those
kinds of bugs generally have security implications, so eliminating the
possibility of allocation failure can remove a whole class of
security-sensitive bugs.
</p>

<p>
Overstreet said that making the error paths
easier to test is another approach. He plans to post some patches for that,
including ways to inject errors at any memory-allocation site; those patches
rely on his recently merged <a href="/Articles/974380/">memory-allocation profiler</a>.  Bacik said
that Btrfs has ways to inject errors to test its error paths using BPF
scripts.  Overstreet said that it is important to be able to target the
error injection for code that is under your control; simply randomly
failing memory allocations for the kernel as a whole is not viable.  Bacik
said that the Btrfs error paths are systematically tested using the BPF code.
</p>

<p>
The session ran out of time without coming to any conclusions on the path
forward, which is unfortunate, Wilcox said.  Everyone seemed interested in
removing <tt>GFP_NOFS</tt> allocations, but there is no concrete proposal
for how to get there; he will try to work on one.  Now that he realizes
there is a major push to get rid of those allocations, Bacik said that he
will work with the other Btrfs developers to not add any more and to start
removing the ones that are there.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems">Filesystems</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-GFP_flags">Memory management/GFP flags</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_Memory-Management_and_BPF_Summit-2024">Storage, Filesystem, Memory-Management and BPF Summit/2024</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/976355/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor977299"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Difficulty pushing restore flags through the code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2024 18:09 UTC (Wed)
                               by <b>riking</b> (subscriber, #95706)
                              [<a href="/Articles/977299/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Scoped flag restore gets a lot easier when you can make closures easily (you can pass the to-be-restored flags into the closure), but oops, the most generic definition of a closure in C (void* data + void fn(void*)) requires allocation to add data past the first pointer!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977299/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor977301"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 5, 2024 18:48 UTC (Wed)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/977301/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In 2024 it's just not worth worrying about the security impact of null pointer dereferences.  On the hardware side, both x86 and arm64 have long since gained hardware functionality to block the kernel from accidentally dereferencing userspace pointers.  Not sure about other arches, but those two account for the vast majority of real-world attack targets.  Meanwhile, on the software side, mmap_min_addr has been around for a long time and can be enforced by LSMs.<br>
<p>
However…<br>
<p>
It *is* worth worrying about the security consequences of error paths.  Just two days ago Google published a blog post about yet another kernel vulnerability involving an error path freeing something that had already been freed. [1] I've seen a bunch of those.<br>
<p>
So I agree that thoroughly testing error paths is a great idea.  At the same time, of course, from a security perspective, what's better than well-tested code is no code.  If there are error paths that exist *only* to handle allocation failure (as opposed to handling allocation failure as one of multiple error conditions), then it would definitely be better for security if allocations were infallible and the error paths could be removed entirely.<br>
<p>
Note that I'm opining only on the security aspect, not on the other pros and cons of allocator fallibility.<br>
<p>
[1] <a href="https://androidoffsec.withgoogle.com/posts/attacking-android-binder-analysis-and-exploitation-of-cve-2023-20938/#vulnerability">https://androidoffsec.withgoogle.com/posts/attacking-andr...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977301/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977336"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 3:40 UTC (Thu)
                               by <b>azumanga</b> (subscriber, #90158)
                              [<a href="/Articles/977336/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, as time goes by I think most memory allocations should be treated as infalliable -- it's fine to have a special "I'm fine if this memory allocation fails" flag, particularly for large allocations (I tend to not bother unless I expect it to be at least 64MB, but that's not a hard rule).<br>
<p>
But, experience tells us writing software which can survive many small failing memory allocations is REALLY hard. The only thing I know which does this correctly is sqlite, and that's a fairly small program with a crazy-large test suite, full of special tests to catch just this case.<br>
<p>
I'd go as far as saying unless you've fuzz tested extensively with a sometimes-failing allocator, there is no chance your code for dealing with failing small allocations works correctly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977336/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 12:07 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977357/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But, experience tells us writing software which can survive many small failing memory allocations is REALLY hard. The only thing I know which does this correctly is sqlite, and that's a fairly small program with a crazy-large test suite, full of special tests to catch just this case.</span><br>
<p>
Doesn't the malloc spec actually help here? Of course, it's not something I did myself either, but shouldn't frees be written<br>
<p>
ptr = free(ptr);  ?<br>
<p>
Iirc free always returns null (does it always succeed?), and free(null) is defined as a no-op, so provided you don't make multiple copies on the assumption you're only going to free one, at least this tactic means that double frees can't happen ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977362"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 12:29 UTC (Thu)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/977362/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
free() doesn't return any value at all. You can defensively code a free as "free(ptr); ptr = NULL;" but this is not the common idiom in most C code I've seen. Also typically the malloc-failed codepath has to handle unwinding a lot more than merely freeing some other memory allocations.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977362/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 13:37 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977383/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or am I thinking something like mmalloc (or remalloc or whatever it's called).<br>
<p>
I'm sure I remember something about being able to do that, whether resizing it to zero actually does a free instead, or something. It's 20 years ago!, but I'm sure I remember thinking back in the day that you could achieve a free and assign null to the pointer in one operation. And I'm sure it was actually documented as working, even if nobody ever did it :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 15:36 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/977399/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe you were thinking of realloc(ptr, 0)? Although, it can still return a non-NULL pointer value.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977445"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 16:15 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977445/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Almost certainly. But I did think the spec said "free and return null if asked for 0 bytes".<br>
<p>
Just looked at the man page - I think it's a safe bet the version I used explicitly said it "frees and returns null", but the reality is it's implementation-dependent :-( Shame, would have been a nice fix for preventing double-frees if you could rely on it.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977445/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977463"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 17:22 UTC (Thu)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/977463/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
realloc(ptr, 0) has just been made UB in the latest C standard :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977463/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977502"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2024 22:04 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977502/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Brilliant. A whole load of previously VALID C code will now silently screw up when fed through the "latest and greatest" compilers.<br>
<p>
And they wonder why programmers are switching to other languages like Rust ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977502/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977604"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 18:01 UTC (Fri)
                               by <b>riking</b> (subscriber, #95706)
                              [<a href="/Articles/977604/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It was made UB because implementations differ in their behavior incompatibly, in particular "returning NULL and freeing the pointer" and "returning NULL without freeing the pointer" are the critical two that make it impossible to code correctly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977604/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2024 18:13 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977608/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In which case you have a compiler flag or something, and it's implementation defined - "you get what you ask for, or either documented option at random". <br>
<p>
Not "your previous implementation-defined code can now be optimised away as undefined".<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor977647"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined, implementation defined, and unspecified behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2024 8:47 UTC (Sat)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/977647/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <p>That sounds like a perfect case for implementation defined behaviour, without a set of constrained behaviours; the implementation has to document how it chooses to behave to be compliant, but has to stick to whatever behaviour it documents. I can see why you wouldn't want it to be unspecified behaviour, since (while you can constrain that to a set of allowed options), you generally want unspecified behaviour to be cases where there's a consistent compatible use, and room to do better if the implementation chooses a specific option.
<p>Is there any discussion you can point me to that explains why not implementation defined here?


      
          <div class="CommentReplyButton">
            <form action="/Articles/977647/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977650"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined, implementation defined, and unspecified behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2024 10:25 UTC (Sat)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/977650/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looks like the relevant document is <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2464.pdf">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2464.pdf</a> ("Zero-size Reallocations are Undefined Behavior").<br>
<p>
The key part is:<br>
<p>
<span class="QuotedText">&gt; Classifying a call to realloc with a size of 0 as undefined behavior would allow POSIX to define the otherwise undefined behavior however they please.</span><br>
<p>
It won't be undefined behaviour to call realloc(ptr, 0) from C23 on a POSIX system, because POSIX already defines it. ("Undefined behaviour" is a recessive trait - if another document wants to define it, then that definition takes priority). Platform-independent code can't rely on the POSIX definition (since it may run on a non-POSIX platform), but it can't rely on any implementation-defined behaviour either, so that's no worse than how it's been since at least C99.<br>
<p>
POSIX says realloc(ptr, 0) can either return NULL, or return a pointer to some allocated space of unknown size, with some extra rules about errno (which were never in the C standard). So you can't use it as an alternative to free() anyway - it may perform a new allocation, which you will leak.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977650/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977657"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pushing for downstream standards to define more</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2024 13:38 UTC (Sat)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/977657/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>Ah, so the rationale is that they want POSIX and other downstream standards to add definitions for more things that are UB in Standard C; effectively reducing Standard C to "the things that are portable across all implementations of C", and expecting POSIX C to be an extension of Standard C to "the things that portable across all reasonable UNIX-like implementations of C".


      
          <div class="CommentReplyButton">
            <form action="/Articles/977657/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977691"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pushing for downstream standards to define more</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2024 9:03 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977691/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In which case, surely that is "implementation defined" !?!?<br>
<p>
If the C standard says "the compiler can assume undefined behaviour cannot happen", then if it's defined as undefined surely the compiler can just delete the code as "can't happen"? And isn't that exactly the behaviour we've been moaning about for ages?<br>
<p>
In which case any alternative definition never gets considered?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977691/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pushing for downstream standards to define more</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2024 10:07 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/977694/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If the C standard says "the compiler can assume undefined behaviour cannot happen" [...]</span><br>
<p>
It doesn't say that. It says:<br>
<p>
<span class="QuotedText">&gt; undefined behavior: behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which this document imposes no requirements</span><br>
<span class="QuotedText">&gt; </span><br>
<span class="QuotedText">&gt; Note 1 to entry: Possible undefined behavior ranges from ignoring the situation completely with unpredictable results, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</span><br>
<p>
A compiler that assumes realloc(ptr, 0) cannot happen will still be a conforming implementation of the C standard, but it won't be a conforming implementation of POSIX. A compiler that implements the POSIX behaviour will be a conforming implementation of both. Any C compiler that targets POSIX will aim to conform with both standards, so it doesn't really matter which one defines the behaviour.<br>
<p>
Incidentally, on non-POSIX systems, Microsoft says "realloc hasn't been updated to implement C17 behavior because the new behavior isn't compatible with the Windows operating system" (<a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/realloc?view=msvc-170">https://learn.microsoft.com/en-us/cpp/c-runtime-library/r...</a>). N2464 says C17 changed the definition of realloc "to allow for the existing range of implementations", but evidently they failed since Microsoft believes it doesn't allow their behaviour.<br>
<p>
I'm guessing C23 made it undefined because they couldn't work out a useful, unambiguous definition that would allow both the POSIX and Windows behaviours, and neither of those are going to change, so it was a waste of time - better to simply defer to the platform documentation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977704"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pushing for downstream standards to define more</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2024 16:19 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977704/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So I'm guessing it's the windows behaviour treats realloc(ptr,0) as free(ptr), seeing as my memories of Microsoft C v5 (and v6).<br>
<p>
But that then leaves us wondering what on earth any cross-platform compiler such as gcc does, seeing as it can produce both Posix and Windows binaries ... and given that linux makes no claim whatsoever to support Posix, that's giving the gcc guys carte blanche to just eliminate a realloc(ptr,0) as "does nothing". BAAADDDD ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977704/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977731"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Compiler choices when supporting two conflicting C standards</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 8:18 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/977731/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>A compiler like GCC can know what platform it's compiling code for (it has to know which CPU, and which ABI, after all, so extending that to which platform standard applies and allowing an override is a non-issue). It can thus support POSIX C when compiling for POSIX platforms (like glibc-based Linux), Windows C when compiling for Windows, and merely ISO C when compiling a freestanding binary that doesn't depend on a platform.
<p>Note that GCC already has the mechanism you'd need for this in place as part of its <a href="https://gcc.gnu.org/onlinedocs/gcc/C-Dialect-Options.html">support for multiple C dialects</a> - it could have a POSIX/Windows/neither switch in there, too.


      
          <div class="CommentReplyButton">
            <form action="/Articles/977731/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor977705"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pushing for downstream standards to define more</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2024 16:25 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977705/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
following that link to the Microsoft definition, yes that is exactly what I remember.<br>
<p>
So doing a "ptr = realloc(ptr, 0)" instead of a free would prevent double frees or access-after-free, so long as (a) you're using a Windows-compliant compiler, and (b) you don't make copies of ptr. Surely that would make masses of sense as a simple way of defensive coding!<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977705/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor977734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Downstream standards should define more behaviours (changing the split between US, ID, and UB)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 10:40 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/977734/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>So, reading the discussions a bit more, I get the sense that the ISO committee's goal is to move the meanings of undefined behaviour, unspecified behaviour and implementation-defined behaviour around a bit (in a way that's always been valid, but has been under-utilized by downstream standards like POSIX).
<p>The ISO standard sets a common definition of C that all implementations of C must agree on, but allows a lot of latitude for downstream standards to tighten up the ISO definitions; for example, ISO says that "double" is a floating point number, so a downstream standard cannot repurpose "double" for integers represented using a pair of registers, but while ISO C says that the size of "char" in bits is implementation-defined and at least 8 bits, POSIX says that the size of "char" is always exactly 8 bits.
<p>This is then an attempt to push downstream standards to tighten up ISO definitions when it comes to behaviours; it's already obvious to downstream standards that where something is implementation defined, a downstream standard can say "the implementation must define it this way", but it's not so obvious that where something is unspecified behaviour (one of  a set of choices, no need to be consistent or to document which one as long as you choose from the set every time you encounter this construct) or undefined behaviour (the program can take any meaning if this construct is encountered) in ISO C, a downstream standard can make that defined, implementation-defined (choose and document a behaviour), or unspecified if it so desires, without conflicting with ISO C.
<p>Taking an example that upsets a lot of people, ISO says that signed integer overflow is undefined behaviour; but they'd be very happy for POSIX to say that signed integer overflow is unspecified behaviour, and must be either saturating, twos complement wrap-around, wraps around to zero (skipping the negative numbers completely), or results in the program receiving a <tt>SIGFPE</tt> signal. It'd then be on implementations to choose the behaviour that results in the most optimal program from those choices, assuming they claimed POSIX support.


      
          <div class="CommentReplyButton">
            <form action="/Articles/977734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor977733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 9:51 UTC (Mon)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/977733/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've never seen anyone use realloc() in that way myself. I guess, not least, cause it doesn't guarantee what you want. The other subthread on UB/ID is interesting there. ;) (And I agree, why push to make it UB when clearly it's ID, as implementations do have their own definitions? but... sibling subthread ;) ).<br>
<p>
What I do is:<br>
<p>
1. At the lower levels that need to deal directly with *alloc and free(), I have a wrapper around free() (possibly a macro) which takes a double-pointer to the caller's pointer. It can then null out the caller's pointer directly.<br>
<p>
foo *foo_free(foo_t **foo) {<br>
  __whatever_house_and_book_keeping (); <br>
  free (*foo);<br>
  *foo = NULL;<br>
  return NULL;<br>
}<br>
#define attr_cleanup(X) __attribute__ ((__cleanup__(X)))<br>
....<br>
{<br>
    foo_t *foo attr_cleanup (foo_free) = foo_new(ctxt);<br>
    ...<br>
}<br>
<p>
2. At a higher level, you need to encapsulate the low-level memory allocations into some coherent strategy to manage the lifetime of objects. Often some combination of:<br>
a) Allocating a pre-determined number of objects, suitable for the problem being tackled. (Good for deterministic behaviour).<br>
b) Careful alignment of entity lifetime with the structure of the algorithm being run<br>
c) Reference counting<br>
d) Hierarchical allocation management, in combination with one of the previous<br>
e) Liveness checking [either at a low level by scanning for pointers (v rare in C/C++), or some more abstract, problem-domain + type specific check] and GC<br>
<p>
Probably forgetting some strategies.<br>
<p>
This is one of the most important and hardest parts to get right. Some languages have features to make it harder, even impossible, to free used objects. But that leads to many programmers in such languages not understanding the importance of lifetime management - which remains important even in such languages for performance.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 16:00 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/977797/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I've never seen anyone use realloc() in that way myself. I guess, not least, cause it doesn't guarantee what you want.</span><br>
<p>
How come? It sounds like it typically doesn't work that way on Unix, but if MS define "realloc( ptr, 0)" to free the memory and return null, then "ptr = realloc( ptr, 0)" achieves exactly what I would like by that definition - it destroys the pointer at the same time as destroying the memory.<br>
<p>
If you have something that then traps de-referencing a null pointer (or simply your code checks for a null pointer), then the likelihood of double-free, use-after-free, etc goes down.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Null pointers and error paths</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2024 17:24 UTC (Mon)
                               by <b>mrugiero</b> (guest, #153040)
                              [<a href="/Articles/978725/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not just writing a little macro?<br>
#define xfree(ptr) do { \<br>
    free(ptr); \<br>
    ptr = NULL; \<br>
} while (0)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
