        <!DOCTYPE html>
        <html lang="en">
        <head><title>Atomic extent swapping for XFS [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/818977/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/819089/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/818977/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Atomic extent swapping for XFS</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>May 1, 2020</br>
           </div>
Normally, files exist in a filesystem to keep data contained within them
separated; seeing data 
exchanged directly between files is often a sign of filesystem
corruption.  There are, however, use cases where it is desirable to be able
to perform a controlled swap of data between a pair of files.  Darrick Wong
has recently posted <a
href="/ml/linux-fsdevel/158812825316.168506.932540609191384366.stgit@magnolia/">a
patch set</a> implementing this feature for the XFS filesystem, but also
making it available in a general way.
<p>
As it happens, XFS has had a data-swapping capability for some time: the
rigorously undocumented
<tt>XFS_IOC_SWAPEXT</tt> <tt>ioctl()</tt> command will exchange extents of
data in two files.  This feature exists for one purpose in particular:
defragmentation of filesystems.  The <a
href="http://man7.org/linux/man-pages/man8/xfs_fsr.8.html"><tt>xfs_fsr</tt>
utility</a> does its job by scanning a filesystem for the most highly
fragmented files — those that are split up into the largest number of
extents.  It then creates a new file with a single extent large enough to
hold one of the fragmented files and copies the data over.  The final step
is an <tt>XFS_IOC_SWAPEXT</tt> operation to atomically replace the old file's
data blocks with the new, defragmented version.
<p>
It seems, however, that there are other interested users out there.
Application developers would like a way to replace some or all of the
contents of a file in an atomic and safe way — one which preferably does
not leave the file corrupted if the system goes down partway through.
Currently such tasks must be handled by creating a temporary file,
populating it, and renaming it over the original; this works, but it is
a multi-step affair that is hard to get right.
<p>
With a well-implemented "swap range" operation, atomically replacing a
portion of a file's contents can be done with a series of operations like:
<p>
<ul class="spacylist">
<li> Create a new file in the same filesystem as the one to be modified,
     using the <tt>O_TMPFILE</tt> option.
<li> Populate the temporary file with the new data.  If only a portion of
     the file's contents are to be changed, the application can start with
     an <a
     href="http://man7.org/linux/man-pages/man2/ioctl_ficlonerange.2.html"><tt>FICLONE</tt>
     <tt>ioctl()</tt> operation</a> to "copy" the old data in by reference; then
     only the data to be changed needs to be written.
<li> Perform the swap operation to move the new data into the old file.
<li> Close the temporary file, which will then be deleted by the kernel.
</ul>
<p>
Other processes working with the file will see either the old or the new
data, but they will never see a combination of the two.
<p>
Wong's patch set adds a new <tt>FISWAPRANGE</tt> <tt>ioctl()</tt> command to
the virtual filesystem layer, meaning that any filesystem can implement it
(though only XFS is implemented so far).  An application fills in a structure
describing the operation that is to be performed:
<p>
<pre>
    struct file_swap_range {
	__s64		file1_fd;
	__s64		file1_offset;
	__s64		file2_offset;
	__s64		length;	
	__u64		flags;
	__s64		file2_ino;
	__s64		file2_mtime;
	__s64		file2_ctime;
	__s32		file2_mtime_nsec;
	__s32		file2_ctime_nsec;
    };
</pre>
<p>
One of the two files is identified by <tt>file1_fd</tt>, which holds a file
descriptor; the other file is passed directly as the <tt>ioctl()</tt>
call's file-descriptor argument.  The normal operation of this call will be
to exchange <tt>length</tt> bytes from the first file starting at
<tt>file1_offset</tt> with the same number of bytes in the second file
starting at <tt>file2_offset</tt>.  The range of data to move need not be
tied to existing extents in the file, but the offsets must be aligned to the
filesystem block size, and in most cases <tt>length</tt> must be a multiple
of the block size.
Interestingly, the two files can, in fact, be the same file, in which case
the two ranges of data (which must not overlap) exchange positions.
<p>

The operation is done in an atomic
manner, meaning that the file will not be corrupted in case of a crash.
<p>
The <tt>flags</tt> argument can modify the behavior of this operation in a
number of ways.  The flags defined in the patch set are:
<p>
<ul class="spacylist">
<li> <tt>FILE_SWAP_RANGE_NONATOMIC</tt>: the application doesn't care
     about atomic behavior, so the operation can potentially be done in a
     less expensive way.
<li> <tt>FILE_SWAP_RANGE_FILE2_FRESH</tt>: before performing the swap, the
     kernel will verify that the second file's inode number matches
     <tt>file2_ino</tt>, and that its modification times match
     <tt>file2_mtime</tt>, <tt>file2_mtime_nsec</tt>, <tt>file2_ctime</tt>,
     and <tt>file_ctime_nsec</tt>.  In the absence of an
     exact match, the call will fail with an <tt>EBUSY</tt> error.  This is
     a way of ensuring that nobody else has modified the file while the
     exchange was being prepared.
<li> <tt>FILE_SWAP_RANGE_FULL_FILES</tt>: ensure that the exchange
     operation includes all of the data in both files.  In other words,
     this requires both offsets to be zero and both files to have
     the same length (which must match the <tt>length</tt> field).
<li> <tt>FILE_SWAP_RANGE_TO_EOF</tt>: data is exchanged from the indicated
     offsets to the ends of both files.  In this case, the <tt>length</tt>
     field is ignored, and the size of the two ranges to swap may differ.
</ul>
<p>
The XFS implementation records the operation in the transaction log before
actually carrying it out.  That provides the necessary robustness in the
face of a crash, but it also makes filesystems using this feature
incompatible with earlier versions of the XFS code.
<p>
Internally, the patch set adds another member to the ever-growing
<a
href="https://elixir.bootlin.com/linux/v5.6.7/source/include/linux/fs.h#L1821"><tt>file_operations</tt>
structure</a>:
<p>
<pre>
    int (*swap_file_range)(struct file *file_in, struct file *file_out,
		           struct file_swap_range *fsr);
</pre>
<p>
Any other filesystem can support the <tt>FISWAPRANGE</tt>
<tt>ioctl()</tt> by implementing this function.
<p>
This patch set is quite young, to the point that reporting on it is
probably violating its privacy rights in some jurisdictions.  The review
process has not yet begun.  It is thus fair to expect that things could
change significantly before it finds its way into the mainline, at some
point in the not-too-close future.  It does appear to be a useful feature,
though, so it seems likely to be merged at some point.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-XFS">Filesystems/XFS</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/818977/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor819229"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 1, 2020 19:40 UTC (Fri)
                               by <b>TheJH</b> (subscriber, #101155)
                              [<a href="/Articles/819229/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ext4 has EXT4_IOC_MOVE_EXT, which also does something vaguely along those lines of the existing XFS_IOC_SWAPEXT, right? (And which therefore could probably also could be hooked up to FISWAPRANGE with a check for FILE_SWAP_RANGE_NONATOMIC?)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819229/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor819233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 1, 2020 20:16 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/819233/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; FILE_SWAP_RANGE_NONATOMIC: the application doesn't care about atomic behavior, so the operation can potentially be done in a less expensive way.</font><br>
<p>
Correct me if I'm wrong, but this sounds a lot like sendfile(2) with two regular on-disk file arguments. Would it offer different semantics, or have I totally misunderstood something here?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2020 0:20 UTC (Sat)
                               by <b>djwong</b> (subscriber, #23506)
                              [<a href="/Articles/819239/">Link</a>] 
      </p>
      
      </div>
      </summary>
      “Other processes working with the file will see either the old or the new data, but they will never see a combination of the two.”

There's a subtlety here with the new API that perhaps I should have made more explicit in the cover letter -- processes will never see a combination of the old and new data, <b>even if the system goes down in the middle of the swap operation</b>.  Most of the patches in the series are there to build into XFS the ability to restart the swap operation after a crash.
      
          <div class="CommentReplyButton">
            <form action="/Articles/819239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor819243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2020 4:00 UTC (Sat)
                               by <b>Baughn</b> (subscriber, #124425)
                              [<a href="/Articles/819243/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What application developers actually want is the ability to write data such that, in case of a crash, subsequent reads see the either the old or the new data; not a mixture.<br>
<p>
The create-and-rename trick does this, but since it requires multiple fsync calls it also provides durability. That is, the application can be sure that after a crash it will only see the new data -- not the old.<br>
<p>
This is useful for networked applications sometimes, but costly. What we'd *prefer*, at least as an option, is the behavior provided by ZFS with sync=disabled -- that is, the data isn't immediately forced to disk and can be written out in the background, but it's still crash-atomic as a whole. Put another way: Write barriers, not pipeline flushes.<br>
<p>
Does this new call provide that behavior, or does it effectively perform a flush?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2020 12:28 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/819258/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The create-and-rename trick does this, but since it requires multiple fsync calls it also provides durability. That is, the application can be sure that after a crash it will only see the new data -- not the old.</font><br>
<p>
The problem with that is that it also means the application *MUST* be file-system aware. "create and rename with fsync" is *seriously* pathological behaviour on - I think - ext4, while it's completely un-necessary on ext3 - if you have default options. Certainly when ext was upgraded there was an awful lot of fuss over that.<br>
<p>
What application developers actually want is something that behaves in a manner that is sensible and easily understood, without having to worry about stuff that should be looked after by administrators and operators.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2020 19:17 UTC (Sat)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/819272/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It was slightly different IIRC. Create and rename with fsync was required on ext4, while on ext3 it isn't required and fsync can be expensive on ext3 with data=ordered.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819274"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2020 19:44 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/819274/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
data=ordered was the default iirc. So obviously I got things the wrong way round, but the point remains - what was required with one file system's default settings was pathological with a different file system's default settings ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819274/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819335"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2020 1:20 UTC (Mon)
                               by <b>nivedita76</b> (guest, #121790)
                              [<a href="/Articles/819335/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Read the actual history. It wasn't really pathological except for pathological applications that tried to fsync 100's of tiny files one by one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819335/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819338"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2020 6:55 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/819338/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And if they NEEDED to be certain those files had hit the disk?<br>
<p>
That is actually quite a common requirement, and calling fsync is officially the only - AND RECOMMENDED - way of doing it. So no, I would not call the apps pathological.<br>
<p>
So my point stands. IF your app needs to be filesystem-aware to ensure something as simple as "is my data saved to disk? will it survive a crash?" actually works properly, then there's something wrong at the OS/filesystem level. The app shouldn't need to care.<br>
<p>
Oh - and you do know that this class of apps includes pretty much EVERY database out there?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819338/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819341"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2020 8:09 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/819341/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And if they NEEDED to be certain those files had hit the disk?</font><br>
<p>
The pathological case is the "one by one" part. Most programs that need to write many small files don't care whether they reach the disk in a specific order as long as they are all there at the end of the operation and each individual file is updated atomically. IIRC there was no issue with writing 1000s of tiny files and then calling fsync on them all at the same time so that the updates could be batched together. The problem was that data=ordered promoted *file* synchronization into *filesystem* synchronization; if the fsync calls all occurred together then most of them would turn into no-ops, as the data is already on disk, and the performance impact would be minimal. This pattern should also work without data=ordered, or on other filesystems, and is likely to be more efficient even when file-level synchronization is supported. Of course, deferring the fsync() calls does complicate the application slightly.<br>
<p>
<font class="QuotedText">&gt; IF your app needs to be filesystem-aware to ensure something as simple as "is my data saved to disk? will it survive a crash?" actually works properly, then there's something wrong at the OS/filesystem level.</font><br>
<p>
If that is all you care about then just call fsync(). If you also care about performance, write as much data as you can *before* calling fsync() and don't assume the synchronization process has file-level granularity.<br>
<p>
Databases do have special requirements, but if you're in a situation where this is likely to matter you've probably selected and configured your filesystem to suite the database in the first place. It is commonplace for database software to be tightly integrated with the filesystem on which the database is hosted for optimal performance and resiliency.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819341/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2020 11:08 UTC (Mon)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/819344/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How can you call fsync() for many files at the same time? Would you need to keep one file descriptor open for each (possibly exhausting your limit), do all the fsync() calls one by one and hope the OS effectively squashes them together?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2020 15:23 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/819404/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can either keep the file descriptors open (up to some predetermined limit) and submit the fsync() calls in batches or else reopen the files after all the content is updated. Or if you're doing a truly huge number of files, just use syncfs() instead of fsync() since you basically need to synchronize the whole filesystem anyway. The semantics of syncfs() are the same as calling fsync() on every file in the filesystem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor819350"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2020 12:43 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/819350/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If that is all you care about then just call fsync(). If you also care about performance, write as much data as you can *before* calling fsync() and don't assume the synchronization process has file-level granularity.</font><br>
<p>
Which is why I'd really just be happy with *ordering* guarantees. I want to be able to issue a "sync" command and be confident that all writes *before* the sync hit disk before *any* writes after the sync hit disk.<br>
<p>
<font class="QuotedText">&gt; Databases do have special requirements, but if you're in a situation where this is likely to matter you've probably selected and configured your filesystem to suite the database in the first place. It is commonplace for database software to be tightly integrated with the filesystem on which the database is hosted for optimal performance and resiliency.</font><br>
<p>
So you're quite happy to corrupt a power-user's database because they're happy to accept the distro's default settings...<br>
<p>
Or trash a user's mail because the developers of Thunderbird or mutt or outlook didn't know the quirks of some esoteric filesystem like ext3/4 that the user just happened to be using ...<br>
<p>
The elephant in the room really is that the linux developers consider posix the be-all and end-all, and posix is pathological about providing an interface that can be logically reasoned about (apart from the requirement that "if the system is functioning normally, time appears to flow normally").<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819350/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2020 15:39 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/819408/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So you're quite happy to corrupt a power-user's database because they're happy to accept the distro's default settings...</font><br>
<p>
The POSIX default is safe when used properly, but may be slower than expected with certain filesystems. Skipping the fsync() (or syncfs() etc.) call is what causes the data loss. I'm not suggesting that applications call fsync() any less often than they actually need to for data safety. However, if you're writing 1000 small files and you need each of them to be updated on disk but do *not* need them all to be written in a specific order, then it's better to write them all and *then* call fsync() or syncfs() to ensure that they're all committed. If you're using an atomic rename, the process would be (1) write the data to the new files; (2) sync all the new files; (3) rename all the new files over the originals; (4) sync all the directories. That only requires two synchronization points no matter how many files you've updated, rather than the 2000 sync points you'd need if you updated all the files serially and called fsync() after each one. *That* process assumes that the filesystem will synchronize the files in parallel with no inter-file dependencies rather than enforcing a global order, which is not true for every filesystem (e.g. ext3 with data=ordered). It becomes unsafe when application developers blame the fsync() calls and remove them altogether rather than adjusting the order of operations to make less granular synchronization more efficient.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2020 20:38 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/819436/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The POSIX default is safe when used properly,</font><br>
<p>
The problem is that the POSIX default explicitly excludes a system crash ... or to put it another way, posix doesn't actually apply to the real world ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819449"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 5, 2020 0:15 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/819449/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, yes. It's hard to make any definite guarantees in the face of a system crash since this is, by definition, abnormal operation where the system is not meeting its requirements. The crash could involve the OS scrambling the contents of the filesystem, for example, even data that was previously committed to disk. At best you could specify what should happen if the system is restored to its original disk state from some point in time before the crash. Along the same lines, the C standard doesn't say what the result is of a program that never terminates or writes to a file—these are the only points where the result is defined to match the virtual machine model. And yet people do write programs that neither terminate nor use standard C files; the Linux kernel is one example. They can do this because the implementation provides guarantees beyond those found in the standard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819449/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 5, 2020 11:25 UTC (Tue)
                               by <b>hkario</b> (subscriber, #94864)
                              [<a href="/Articles/819471/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Well, yes. It's hard to make any definite guarantees in the face of a system crash since this is, by definition, abnormal operation where the system is not meeting its requirements.</font><br>
<p>
and yet people are programming to this standard, so either it is doable (as evidenced by dozens of practical examples), or posix is not a be-all end-all of file system API for modern systems<br>
<p>
we need a standard that describes what is the expected behaviour, which operations are atomic and what's the data ordering (one that's not "what ext3/4 is doing") and then test the file systems to this standard<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819477"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 5, 2020 14:06 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/819477/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly. That's my beef - posix gives me NOTHING I can reason against to try and guarantee my data has hit the disk, other than using the various sync operations many of which work by negating all of the disk i/o optimisation techniques and - courtesy of Murphy's law - can be pretty much guaranteed to make a vital real-time system do an emergency stop at the worst possible time.<br>
<p>
Yes I accept that disks can (and many cheap ones do) lie, but at the present moment I have three options if I want to make certain my data is not corrupted - (1) pray that the sys-admin knows what he's doing and configures the computer according to my instructions, or (2) be liberal with syncs and just accept that for many people performance will be abysmal, or (3) put loads of file-system-specific code in my app.<br>
<p>
All it would take for most people to solve all of this would be a guarantee that (1) all writes from any given process hit the disk in the same order they are written, or (b) allow users to issue an async sync aka a write barrier. If I can reason about the order in which writes hit the disk, as an app developer I can take reasonable steps to ensure data safety.<br>
<p>
The problem is there seem to be a fair few developers who value the computer's stability far more than the users' data. The attitude seems to be "users should back up", and they're quite happy to shave a few seconds off boot time even if this markedly raises the probability of data corruption and forcing a full restore of user space :-(<br>
<p>
imho there's no point shaving that ten seconds off boot time, if it then necessitates a day's downtime to restore the backup!<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819477/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819523"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 5, 2020 15:52 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/819523/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (1) all writes from any given process hit the disk in the same order they are written, or (b) allow users to issue an async sync aka a write barrier.</font><br>
<p>
I would be very surprised if a (production-ready) filesystem was prepared to offer (1) (reordering writes is essential to performance), so I think (b) is the only option here. But whenever we (application developers) ask for that, we get accused of asking for O_PONIES, and then people go back to talking about databases and other "real use-cases." It's actually really frustrating.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819523/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819531"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 5, 2020 17:53 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/819531/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup. We don't even need some way of knowing the sync has completed - just the guarantee that writes *after* the barrier will not occur until all writes *before* have completed. I want to be able to "write journal, flush, write data, flush".<br>
<p>
Yeah, allow re-ordering, no problem. Just have a special "write" that cannot be re-ordered, and cannot be re-ordered around. As stuff flows down, this barrier is passed on from layer to layer.<br>
<p>
Given the recent article about how stripping buffers out of the encryption layer massively improved performance (buffer bloat :-), I don't think the file-system should even care! Stuff should just get passed straight through to the device layer(s) with no re-ordering at all.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819531/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819557"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 6, 2020 1:29 UTC (Wed)
                               by <b>djwong</b> (subscriber, #23506)
                              [<a href="/Articles/819557/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
With the default FISWAPRANGE mode (i.e. the atomic one), no writes after the call will be sent to disk until everything that was dirty before the call has landed on disk.  If the system goes down, after the reboot you'll either see the old contents or the new ones, but not a mix of both.<br>
<p>
(Granted, someone who isn't the patch author should probably /test/ that claim I just made...)<br>
<p>
((Unless your storage lies.))<br>
<p>
(((Hmm, maybe I /should/ have patchbombed linux-fsdevel with all the testcases and manpages too....)))<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819557/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819619"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 6, 2020 16:16 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/819619/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In that case, why can't we have something that provides that guarantee without all this FISWAPRANGE stuff. Just call it FI_NO_OP that I can call between writing the journal and writing the data.<br>
<p>
Then IF my data is scrambled by a crash, at least it's not linux to blame. Just because linux can't *guarantee* that my data will survive a crash, is no excuse for actively obstructing the user's attempts to make sure it does.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819619/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor819257"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2020 12:15 UTC (Sat)
                               by <b>walters</b> (subscriber, #7396)
                              [<a href="/Articles/819257/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This won't work for e.g. updating an executable that happens to be running, because we need a new inode there right?  In other words, this couldn't be used by traditional package managers (dpkg/rpm) in place of the create+rename() approach.  (I guess they could try this and fall back though?)<br>
<p>
I liked the direction of O_TMPFILE() and Omar's patch to support atomic replacement:<br>
<a href="https://lore.kernel.org/linux-fsdevel/cover.1524549513.git.osandov@fb.com/">https://lore.kernel.org/linux-fsdevel/cover.1524549513.gi...</a><br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819257/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819286"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2020 22:55 UTC (Sat)
                               by <b>TheJH</b> (subscriber, #101155)
                              [<a href="/Articles/819286/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, they definitely should not be doing this. Because even if the writer is atomic, the reader normally won't be - if someone e.g. has a library mapped, and you replace the contents of the library while it's being executed, things will blow up in your face.<br>
<p>
Same thing for configuration files and other stuff - if someone is reading a file with buffered reads that are smaller than the file size, and the file contents are replaced in the middle, the reader could easily end up seeing broken lines that consist of half of a line in the old file and half of a line in the new file spliced together.<br>
<p>
If you're going to use this interface for atomic file updates, you also need the readers to be atomic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819286/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 3, 2020 19:02 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/819321/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If you're going to use this interface for atomic file updates, you also need the readers to be atomic.</font><br>
<p>
Or alternatively, you need the writer to *be* the reader, which I suspect is often the case for some types of (binary) config databases and certain things that live under /var. In that case, the writer can simply avoid reading while writing (for example with a mutex, or by structuring the program appropriately).<br>
<p>
(In principle, multi-process writer/reader systems could use something like flock(2) to synchronize access in this fashion, but everyone would need to agree to that, since file locking is advisory and there are multiple ways of doing it. In practice, this is likely limited to cases where all of the processes involved are parts of a single whole.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor819555"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 6, 2020 0:53 UTC (Wed)
                               by <b>djwong</b> (subscriber, #23506)
                              [<a href="/Articles/819555/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Right.  This API provides for "update the contents of this file and anyone with an open file description sees the results immediately".<br>
<p>
For "...anyone with an open file description continues to see the old results until they close the fd", you'll have to make do with either the fsync-and-rename strategy or help push Omar's linkat-an-O_TMPFILE series upstream.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819555/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor819277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2020 20:30 UTC (Sat)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/819277/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good. Now we got an ambiguity for the word 'swap' too. Does ext2 support swap? Yes, it does, but not in the way you mean.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819553"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 6, 2020 0:45 UTC (Wed)
                               by <b>djwong</b> (subscriber, #23506)
                              [<a href="/Articles/819553/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I /was/ trying to steer everyone towards "swaprange" and "swapextent", or at least not towards the (overloaded) term "swap"...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819553/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor819556"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 6, 2020 1:09 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/819556/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps "exchange" would be a better word? E.g.: EXCHANGE_FILE_RANGES.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819556/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor851313"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 1, 2021 1:10 UTC (Thu)
                               by <b>djwong</b> (subscriber, #23506)
                              [<a href="/Articles/851313/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Done, it is now called FIEXCHANGE_RANGE.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/851313/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor819302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 3, 2020 11:44 UTC (Sun)
                               by <b>pebolle</b> (guest, #35204)
                              [<a href="/Articles/819302/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Index entries for this article</font><br>
<p>
Is this a new feature? I hadn't noticed it before. I do think it's a good idea.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Atomic extent swapping for XFS</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2020 0:55 UTC (Mon)
                               by <b>gus3</b> (guest, #61103)
                              [<a href="/Articles/819331/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
+1<br>
<p>
(I tried to post a Unicode "thumbs up" but apparently I don't have the right emoji installed....)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor819472"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mtimes?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 5, 2020 11:29 UTC (Tue)
                               by <b>hkario</b> (subscriber, #94864)
                              [<a href="/Articles/819472/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What about mtimes?<br>
Since this changes file contents, will it also update the mtime of the target file?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/819472/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor819554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">mtimes?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 6, 2020 0:48 UTC (Wed)
                               by <b>djwong</b> (subscriber, #23506)
                              [<a href="/Articles/819554/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, see the file_modified() calls in do_swap_file_range in <a href="https://lore.kernel.org/linux-xfs/158812827320.168506.17255602633619684843.stgit@magnolia/">patch 3</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/819554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
