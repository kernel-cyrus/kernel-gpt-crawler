        <!DOCTYPE html>
        <html lang="en">
        <head><title>Linux and object storage devices [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/305740/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/305172/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/305740/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Linux and object storage devices</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>November 4, 2008</br>
           </div>
The btrfs filesystem is widely regarded as being the long-term future
choice for Linux.  But what if btrfs is taking the wrong direction,
fighting an old war?  If the nature of our storage devices changes
significantly, our filesystems will have to change as well.  A lot of
attention has been paid to the increasing prevalence of flash-based
devices, but there is another upcoming technology which should be planned
for: object storage devices (OSDs).  The recent posting of a new
filesystem called <a href="http://lwn.net/Articles/305688/">osdfs</a>
provides a good opportunity to look at OSDs and how they might be supported
under Linux.
<p>

The developers of OSDs were driven by the idea that traditional,
block-based disk drives offer an overly low-level interface.  With
contemporary hardware, it should be possible to push more intelligence into
storage devices, offloading work from the host while maintaining (or
improving) performance and security.  So the interface offered by an OSD
does not deal in blocks; instead, the OSD provides "objects" to the host
system.  Most objects will simply be files, but a few other types of
objects (partitions, for example) are supported as well.  The host
manipulates these objects, but need not (and cannot) concern itself with
how those objects are implemented within the device.

<p>

A file object is identified by two 64-bit numbers.  It contains whatever
data the creator chooses to put in there; an OSD does not interpret the
data in any way.  Files also have a collection of attributes and metadata;
this includes much of the information stored in an on-disk inode in a
traditional filesystem - but without the block layout information, which
the OSD hides from the rest of the world.  All of the usual operations can
be performed on files - reading, writing, appending, truncating, etc. -
but, again, the implementation of those operations is handled by the OSD.
<p>

One thing that is <i>not</i> handled by the OSD, though, is the creation of
a directory hierarchy or the naming of files.  It is expected that the host
filesystem will use file objects to store its directory structure,
providing a suitable interface to the filesystem's users.  One could,
presumably, also use an OSD as a sort of hardware-implemented object
database without a whole lot of high-level code, but that is not where the
focus of work with OSDs is now.

<p>

<span class="PullQuote">
<span class="invisible">[PULL QUOTE: </span>
The OSD designers decided to offload
another task from the host systems: security.
<span class="invisible"> END QUOTE]</span>
</span>


The OSD <a
href="http://www.t10.org/ftp/t10/drafts/osd2/osd2r04.pdf">protocol
[PDF]</a> is a T10-sanctioned extension to the SCSI protocol.  It is thus
expected that OSD devices will be directly attached to host systems; the
protocol has been designed to perform well in that mode.  It is also
expected, though, that OSDs will be used in network-attached storage
environments.  For such deployments, the OSD designers decided to offload
another task from the host systems: security.
To that end, the OSD protocol includes an extensive set of security-related
commands.  Every operation on an object must be accompanied by a "capability," a
cryptographically-signed ticket which names the object and the access
rights possessed by the owner of the capability.  In the absence of a
suitable capability, the drive will deny access.
<p>
It is expected that capabilities will be handed out by a security policy
daemon running somewhere on the network.  That daemon may be in possession
of the drive's root key, which allows unrestricted access to the drive, or
it may have a separate, partition-level key instead.  Either way, it can
use that key to sign capabilities given out to processes elsewhere in the
system.  (Drives also have a "master" key, used primarily to change the
root key.  Loss of the master key is probably a restore-from-backup sort of
event.)
<p>
Capabilities last for a while (they include an expiration time) and
describe all of the allowed operations.  So the act of actually obtaining a
capability should be relatively rare; most OSD operations will be performed
using a capability which the system already has in hand.  That is an
important design feature; adding "ask a daemon for a capability" to the
filesystem I/O path would not be a performance-enhancing move.
<p>
In theory, it should be relatively easy to make a standard Linux filesystem
support an OSD.  It's mostly a matter of hacking out much of the low-level
block layout and inode management code, replacing it with the appropriate
object operations.  The osdfs filesystem was created in this way; the
developers started with ext2.  After taking out all the code they no longer
needed, the osdfs developers simply added code translating VFS-level
requests into operations understood by the OSD.  Those requests are then
executed by way of the low-level <a
href="http://git.open-osd.org/gitweb.cgi?p=open-osd.git;a=blob;f=Documentation/scsi/osd.txt;hb=HEAD">osd-initiator</a>
code (which was also recently <a
href="http://lwn.net/Articles/305860/">submitted</a> for consideration).
Directories are implemented as simple files containing names and
associated object IDs.  There is no separate on-disk inode; all of that
information is stored as attributes to the file itself.  The end result is
that the osdfs code is relatively small; it is mostly concerned with
remapping VFS operations into OSD operations.
<p>

Anybody wanting to test this code may run into one small problem: there are
few OSDs to be found in the neighborhood computer store.  It would appear
that most of the development work so far has been done using OSD
simulators.  The <a
href="http://www.open-osd.org/bin/view/Main/OscOsdProject">OSC software
OSD</a> is, like osdfs, part of the <a
href="http://www.open-osd.org/">open-osd project</a>; it implements the OSD
protocol over an SQLite database.  There is also <a
href="http://www.alphaworks.ibm.com/tech/osdsim">an OSD simulator</a>
hosted at IBM, but it would not appear to be under current development.
Simulator-based development and testing may not be as rewarding as having a
shiny new device implementing OSD in hardware, but it will help to insure
that both the software and the protocol are in good shape by the time such
hardware is available.
<p>

It should be noted that the success of OSDs is not entirely assured.  An
OSD takes much of the work normally done in an operating system kernel and
shoves it into a hardware firmware blob where it cannot be inspected or
fixed.  A poor implementation will, at best, not perform well; at worst,
the chances of losing data could increase considerably.  It may yet prove
best to insist that storage devices just concentrate on placing bits where
the operating system tells them to and leave the higher-level decisions to
higher-level code.  Or it may turn out that OSDs are the next step forward
in smarter, more capable hardware.  Either way, it is an interesting
experiment. 
<p>

See <a href="http://developers.sun.com/solaris/articles/osd.html">this
article at Sun</a> for more information on how OSD works.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Block_layer-Object_storage_devices">Block layer/Object storage devices</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-osdfs">Filesystems/osdfs</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Object_storage_devices">Object storage devices</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/305740/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor305913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2008 21:00 UTC (Tue)
                               by <b>vblum</b> (guest, #1151)
                              [<a href="/Articles/305913/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds like we need the open source OSD to make this idea sit well with Linux. A good part of OS development went into making more efficient file systems. Should this type of work now become hidden again?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor305917"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2008 21:22 UTC (Tue)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/305917/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems that there is Open Source OSD. Sun sells StorageTek 5800, source for which one can find at <a href="http://opensolaris.org/os/project/honeycomb/">http://opensolaris.org/os/project/honeycomb/</a> . If I understand all the issue correctly :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305917/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor305920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Offloading security maketh me nervouth</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2008 22:18 UTC (Tue)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/305920/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Security software has such a record of flimflam, security thru obscurity, and just plain shoddiness that I wonder how wise it would be to move it to drives where it can't be easily reviewed or modified.<br>
<p>
Are there any disk drives with GPL software on them which can be reviewed and modified?  Is there any provision for such in this scheme?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor305932"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 4, 2008 23:56 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/305932/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it sounds as if they need to go to the SCSI target code and implement a OSD mode for it that then stores the files on a 'normal' local filesystem.<br>
<p>
this would let any linux box with the appropriate interface act as a OSD device, allowing for solid experimentation on both sides of the interface.<br>
<p>
putting the filesystem layout code on the storage device raises a _lot_ of questions about reliability and performance. it also prevents trying different layouts.<br>
<p>
it will also make it very hard for RAID to be used on such devices.<br>
<p>
I really don't expect this to be the wave of the future, but anything can happen.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305932/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor305941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2008 2:01 UTC (Wed)
                               by <b>gdt</b> (subscriber, #6284)
                              [<a href="/Articles/305941/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>OSD isn't really aimed at drives, it's aimed at managed storage devices. At the moment these either need to handle disk blocks, which is pretty low level, or implement a network file system, which is pretty high level. You really want a protocol which allows the managed storage to understand which blocks comprise a file with buying into all of the semantics of file handling. That allows the storage to migrate the file to nearline storage, duplicate the entire file for redundancy, etc.</p>

<p>The protocol is an extension to SCSI not because OSD drives are expected to be common, but because that's the transport above Fiber Channel and iSCSI -- the dominant storage attachment protocols.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/305941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor305956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2008 5:36 UTC (Wed)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/305956/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So it doesn't seem likely to you that OSDs will supercede block devices for "commodity" mass storage?  That's good...I don't really like the idea of the hardware itself mandating a particular organizational scheme.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor306392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2008 22:51 UTC (Sat)
                               by <b>vonbrand</b> (subscriber, #4458)
                              [<a href="/Articles/306392/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>
So you don't like the layout in blocks of your current disk drive either...
      
          <div class="CommentReplyButton">
            <form action="/Articles/306392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor327969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Nice exaggeration</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2009 7:24 UTC (Thu)
                               by <b>felixfix</b> (subscriber, #242)
                              [<a href="/Articles/327969/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I want each byte to include a length specifier so I can have variable size and capability tickets with timeouts per byte.  I resent the rigid 8 bit byte paradigm enforced upon me by hardware manufacturers.<br>
<p>
The difference between hardware enforced block size and hardware enforced security, object layout, capability tickets, and all the other cruft that goes with it is obvious to most people.  If you don't see it, you shouldn't be wasting your time reading news from a Linux web site, which places a premium on cognitive capability.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/327969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor305959"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2008 6:50 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/305959/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
so why would you use OSD instead of one of the many network/cluster file systems? they all abstract the block device away and let the server at the far side do whatever it wants for the data storage.<br>
<p>
the only 'advantage' this would have is that instead of using cheap, common ethernet, it requires a SCSI layer (parallel SCSI or fiberchannel), you could mix and match normal storage with OSD storage, but they really are so different that I would not expect them to be mixed in practice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305959/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor305962"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2008 8:36 UTC (Wed)
                               by <b>jamesh</b> (guest, #1159)
                              [<a href="/Articles/305962/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They probably want something that isn't quite as high level as a NAS box such as abstraction of the actual location of the file data (flash, disk, tape, etc), while not imposing a particular high level file system interface as you'd get with NFS or SMB.<br>
<p>
It'd probably also make it easy to do things like run multiple file system hierarchies off the same object store, rather than having to worry about growing or shrinking partitions.<br>
<p>
Lastly, this doesn't look incompatible with using ethernet to connect to the storage device: people have been running SCSI over ethernet for years with iSCSI.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305962/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor306142"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2008 12:01 UTC (Thu)
                               by <b>csamuel</b> (<b>&#x272D; supporter &#x272D;</b>, #2624)
                              [<a href="/Articles/306142/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This *has* come from the cluster filesystems, I first came across OSD's in 2004 as<br>
part of the Lustre file system design.  The idea is that you have a whole bunch of<br>
OSD's and you parallelise your I/O across them.<br>
<p>
Lustre is now owned by Sun...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/306142/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor305952"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2008 4:22 UTC (Wed)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/305952/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OSD and osdfs might be an interesting way to export directories to virtual machines.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305952/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor305980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wrong direction!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2008 13:07 UTC (Wed)
                               by <b>kev009</b> (guest, #43906)
                              [<a href="/Articles/305980/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think this is certainly the wrong direction.  Manufacturers can't even get hard disk firmwares let alone RAID right much of the time.  Expecting them to to do even more complex tasks is asking for trouble..  not to mention obsolescence: they likely wont release updates after 2 or so years if they are feeling generous.<br>
<p>
The future of mainstream storage is squarely in solid state technology such as flash memory, holographic storage, memresitors, etc.  It only makes sense to treat these as low as possible: arrays of raw memory addresses just like RAM.<br>
<p>
With many core processors, it seems foolish to even think about this these days.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor305981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wrong direction!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2008 13:12 UTC (Wed)
                               by <b>kev009</b> (guest, #43906)
                              [<a href="/Articles/305981/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, input from experts at EMC, NetApp, Seagate, IBM and Sun/StorageTek would be critical because they have been doing things like this for a long time.<br>
<p>
In the end I still think a software layer is the only way to go because it can be developed and improved in the open as FOSS.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor305987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wrong direction!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2008 15:22 UTC (Wed)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/305987/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Except that even RAM isn't just RAM anymore.  No one who cares about performance treats memory like a big random access array.  With multi-level caches and sequential prefetch, RAM is more like disk blocks.  Flash memory is even more so, with its relatively slow read start and very slow write.<br>
<p>
When programmers don't understand and account for the underlying nature of the system, it results in awful code, like most Java software.  So don't hide too much of it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/305987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor306079"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Wrong direction!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2008 3:32 UTC (Thu)
                               by <b>gdt</b> (subscriber, #6284)
                              [<a href="/Articles/306079/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p><i>It only makes sense to treat these as low as possible: arrays of raw memory addresses just like RAM.</i></p>

<p>That's hardly a low as possible abstraction. For rotating storage it hides bad block remapping. For flash storage it hides wear levelling and delete-before-write.</p>

<p>The search isn't for the lowest possible abstraction to present to the computer, the search is for the abstraction which best mediates between the needs of the computer and the needs of the storage. Storage is increasingly remote and managed, and the current block-based abstraction and your offset-based proposal don't give enough information to the storage's management software.</p>

<p>It's the diversity of storage media that's currently driving object-based storage. It's a lot simpler to build complex storage (with features like migration between flash, disk and tape) if the storage is told what blocks are in a file rather than being left to guess.</p>

<p>Someone asked, why not use a filesystem such as CIFS or NFS? The answer is that this leads to user-based authentication, which leads to a lot of unnecessary complexity for the storage. One of the aims of OBS is to allow storage to be leased out, and integrating with customers' authentication systems would have introduced a big hurdle.</p>

<p>Please note that I'm not a OBS defender, I'm only seeking to explain it. Conversely, I'm also not saying that OBS is such a poor idea that it shouldn't be in Linux. My own view is that the SCSI protocol itself is now inadequate for enterprise storage, as it is a poor fit for the link, network and transport protocols used in corporate networks. I don't see much sense in using a disk protocol to communicate between a computer and  a storage manager (ie, another computer). There's a lot of pretence happening there which could be stripped away for better performance and robustness. My view may be overly coloured by experience as a participant in the iSCSI working group</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/306079/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor306178"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">It was wrong back then and it's wrong now</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2008 16:20 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/306178/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>For rotating storage it hides bad block remapping. For flash storage it hides wear levelling and delete-before-write.</blockquote>

<p>Yes - and I've certainly had problems with the first and I'm <b>sure</b> I'll have problems with the second. The only sane way to resolve this problem is to offer as low access as possible - but not lower. I don't think checksum calculation for blocks on HDD belongs to OS kernel (it can be calculated in HDD more or less for free, but general-purpose CPU will spend significant power doing it), but bad blocks handling certainly should belong to kernel - it have more resources to cope.</p>

<blockquote>The search isn't for the lowest possible abstraction to present to the computer, the search is for the abstraction which best mediates between the needs of the computer and the needs of the storage.</blockquote>Puhlease. What have this search offered us now? Predictable and mostly unlreliable HDDs and SSDs? I'd prefer raw flash, thank you.

<blockquote>It's a lot simpler to build complex storage (with features like migration between flash, disk and tape) if the storage is told what blocks are in a file rather than being left to guess.</blockquote>What is the goal: great storage subsystem or great system? If the latter then all these things must be done at the system level (and may be offered via NFS/CIFS).

<blockquote>Please note that I'm not a OBS defender, I'm only seeking to explain it. Conversely, I'm also not saying that OBS is such a poor idea that it shouldn't be in Linux.</blockquote>OBS is quite bad idea but Linux will need some support for it anyway. And it's useful is some strange places (for example in KVM/VMWare/Xen).
      
          <div class="CommentReplyButton">
            <form action="/Articles/306178/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor306345"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">It was wrong back then and it's wrong now</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 8, 2008 3:15 UTC (Sat)
                               by <b>Ze</b> (guest, #54182)
                              [<a href="/Articles/306345/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <i>Yes - and I've certainly had problems with the first and I'm sure I'll have problems with the second. The only sane way to resolve this problem is to offer as low access as possible - but not lower. I don't think checksum calculation for blocks on HDD belongs to OS kernel (it can be calculated in HDD more or less for free, but general-purpose CPU will spend significant power doing it), but bad blocks handling certainly should belong to kernel - it have more resources to cope.</i>
Yes and what about the bandwidth requirements of sending the checksum over? or if someone wishes to use that space for an error correcting code or a more secure hash?

Ultimately the time spent transferring files from the disk should be a small percentage compared to the time spent waiting for them. However there are always going to be trade offs with flexibility , speed and other things.
<i>What is the goal: great storage subsystem or great system? If the latter then all these things must be done at the system level (and may be offered via NFS/CIFS).
OBS is quite bad idea but Linux will need some support for it anyway. And it's useful is some strange places (for example in KVM/VMWare/Xen).</i>
The whole point though is that NFS and CIFS are unsuitable for some uses. This is where Object based file systems come in , they are like a stripped down form of NFS/CIFS.

Ideally it'd be nice to have a nice layer setup that allows people to see the layers they want and not have to put up with the layers they don't need.

One downside I see for object based file systems is with versioning file systems , which use the layout of the block layer to make having multiple versions cheap in space. That's a trade off though that may be worth it to some and not to others.


      
          <div class="CommentReplyButton">
            <form action="/Articles/306345/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor306395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">It was wrong back then and it's wrong now</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 9, 2008 0:37 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/306395/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
For rotating storage it hides bad block remapping.
</blockquote>
Bad block remapping?  It hides <em>all</em> block mapping.  In a truly low level disk interface, Linux would address the disk by cylinder/head/sector.  Indeed, there are things Linux could do more effectively if it controlled the storage at that level.  And that's nowhere near the lowest conceivable abstraction, either.
<p>
<blockquote>
I don't think checksum calculation for blocks on HDD belongs to OS kernel (it can be calculated in HDD more or less for free, but general-purpose CPU will spend significant power doing it)
</blockquote>
<p>
I see no reason for it to be a cheaper computation in the HDD than in the main computer.  If there are special purpose processors in the HDD to do it cheaply, it's because that's where we've decided to do it; not vice versa.
<p>
<blockquote>
the search is for the abstraction which best mediates between the needs of the computer and the needs of the storage.
</blockquote>
<p>
I'd like to put it differently, because it's not what <em>I</em> can do for the computer and the storage, but what <em>they</em> can do for me.  So: Which abstraction best leverages the abilities of the computer and those of the storage, to provide the most efficient storage service?
<p>
There was a time when the best dividing line was such that the main computer watched the bits stream off the head until it detected the start of a record, etc.  That let us consolidate expensive CPUs.  Today, we can squeeze more storage service out cheaper by moving a great deal of that function to the other end of the cable.  More recent technological changes might mean it's most efficient for file layout to move out there too.
<p>
I can think of a few reasons to stick function inside the storage product and the storage box instead of the main computer products and box:
<ul>
<li>The implementation must change more when the storage layer below it changes than when the application layer above it does.
<li>Multiple main computers share the storage box.
<li>It's expensive to move information over the cable.
</ul> 

      
          <div class="CommentReplyButton">
            <form action="/Articles/306395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor306088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2008 4:45 UTC (Thu)
                               by <b>palapa</b> (guest, #612)
                              [<a href="/Articles/306088/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds like a perfect way to embed DRM into linux systems.  The DRM could reside in the OSD, and not run afoul of the (gnu) operating system.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/306088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor306147"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2008 12:38 UTC (Thu)
                               by <b>ricwheeler</b> (subscriber, #4980)
                              [<a href="/Articles/306147/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Object based storage systems have been shipping for several years and done relatively well (Panasas, EMC Centera and its archival storage competitors all have object based guts).<br>
<p>
Since linux is usually the base operating system used to implement the object based back end, it is interesting to track how well our components support people trying to build systems from our existing stack - target mode SCSI, scalable file systems, etc.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/306147/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor307781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux and object storage devices</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2008 14:58 UTC (Wed)
                               by <b>nanolinux</b> (guest, #55256)
                              [<a href="/Articles/307781/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Object storage devices are a trojan horse unless the devices are under the control of linux by offloading the work onto a "storage processor" on the mainboard where the main CPU resides and be completely open source under the control of all linux completely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/307781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2008, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
