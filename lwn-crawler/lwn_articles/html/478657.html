        <!DOCTYPE html>
        <html lang="en">
        <head><title>Betrayed by a bitfield [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/478657/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/477352/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/478657/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Betrayed by a bitfield</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 1, 2012</br>
           </div>
Developers tend to fear compiler bugs, and for good reason: such bugs can
be hard to find and hard to work around.  They can leave traps in a
compiled program that spring on users at bad times.  Things can get even
worse if one person's compiler bug is seen by the compiler's developer as a
feature - such issues have a tendency to never get fixed.  It is possible
that just this kind of feature has turned up in GCC, with unknown impact on
the kernel.
<p>
One of the many structures used by the btrfs filesystem, defined in
<tt>fs/btrfs/ctree.h</tt>, is:
<p>
<pre>
    struct btrfs_block_rsv {
	u64 size;
	u64 reserved;
	struct btrfs_space_info *space_info;
	spinlock_t lock;
	unsigned int full:1;
    };
</pre>
<p>
Jan Kara recently <a href="/Articles/478658/">reported</a> that, on the
ia64 architecture, the <tt>lock</tt> field was occasionally becoming
corrupted.  Some investigation revealed that GCC was doing a surprising
thing when the bitfield <tt>full</tt> is changed: it generates a 64-bit
read-modify-write cycle that reads both <tt>lock</tt> and <tt>full</tt>,
modifies <tt>full</tt>, then writes both fields back to memory.  If
<tt>lock</tt> had been modified by another processor during this operation,
that modification will be lost when <tt>lock</tt> is written back.  The
chances of good things resulting from this sequence of events are quite small.
<p>
One can imagine that quite a bit of work was required to track down this
particular surprise.  It is also not hard to imagine the dismay that
results from a conversation like this:
<p>
<div class="BigQuote">
	I've raised the issue with our GCC guys and they said to me that:
	"C does not provide such guarantee, nor can you reliably lock
	different structure fields with different locks if they share
	naturally aligned word-size memory regions.  The C++11 memory model
	would guarantee this, but that's not implemented nor do you build
	the kernel with a C++11 compiler."
</div>
<p>
Unsurprisingly, Linus was <a href="/Articles/478667/">less than
impressed</a> by this response.  Language standards are not written for the
unique needs of kernels, he said, and can never "guarantee" the behavior
that a kernel needs:
<P>
<div class="BigQuote">
	So C/gcc has never "promised" anything in that sense, and we've
	always had to make assumptions about what is reasonable code
	generation. Most of the time, our assumptions are correct, simply
	because it would be *stupid* for a C compiler to do anything but
	what we assume it does.
<p>
	But sometimes compilers do stupid things. Using 8-byte accesses to
	a 4-byte entity is *stupid*, when it's not even faster, and when
	the base type has been specified to be 4 bytes!
</div>
<p>
As it happens, the problem is a bit worse than non-specified behavior.
Linus <a href="/Articles/478672/">suggested</a> running a test with a
structure like: 
<p>
<pre>
    struct example {
	volatile int a;
      	int b:1;
    };
</pre>
<p>
In this case, if an assignment to <tt>b</tt> causes a write to <tt>a</tt>,
the behavior is clearly buggy: the <tt>volatile</tt> keyword makes it
explicit that <tt>a</tt> may be accessed from elsewhere.  Jiri Kosina <a
href="/Articles/478669/">gave it a try</a> and reported that GCC is still
generating 64-bit operations in this case.  So, while the original problem
is technically compliant behavior, it almost certainly results from the same
decision-making that makes the second example go wrong.
<p>
Knowing that may give the kernel community more ammunition to flame the GCC
developers with, but it is not necessarily all that helpful.  Regardless of
the source of the problem, this behavior exists in versions of the compiler
that, almost certainly, are being used outside of the development community
to build the kernel.  So some sort
of workaround is likely to be necessary even if GCC's behavior is fixed.
That could be a bit of a challenge; auditing the entire kernel for 32-bit-wide
bitfield variables in structures that may be accessed concurrently will not be a
small job.  But, then, nobody said that kernel development was easy.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#GCC">GCC</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/478657/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor478898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 4:20 UTC (Thu)
                               by <b>arjan</b> (subscriber, #36785)
                              [<a href="/Articles/478898/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So we have a good small testcase...<br>
sounds like we can run this and just ban compilers that miscompile this....<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/478898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor478900"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 4:43 UTC (Thu)
                               by <b>nevets</b> (subscriber, #11875)
                              [<a href="/Articles/478900/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can just imaging the error message we post:<br>
<p>
"We refuse to build your kernel with the current version of your compiler. Linus has declared that this version of gcc violates SOPA (Stop Obnoxious Programming Acts). Although the gcc developers feel that this bug is a feature, we have proof that they are wrong."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/478900/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor478942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 9:55 UTC (Thu)
                               by <b>spaetz</b> (guest, #32870)
                              [<a href="/Articles/478942/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for that comment, it was exactly what I needed to save my day. SOPA, LOL<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/478942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor480296"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2012 17:51 UTC (Thu)
                               by <b>jd</b> (guest, #26381)
                              [<a href="/Articles/480296/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can't we just give a "Compiler On Acid" error?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/480296/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor478908"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Knock me over with a feather</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 5:43 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/478908/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm astonished that Linus has a problem with this.  Everybody knows that C bitfields can never be counted on to work right.  Even when one seems to, that's bad luck because it just hasn't failed *yet*.  A one-bit bitfield?   Next to a lock type defined as 32 bits on an almost militantly 64-bit machine? Why did he allow such cursed, doomed, jinxed code into his kernel in the first place?<br>
<p>
My bet is that he knows the code is bad, but is covering his embarrassment by haranguing the Gcc developers, on the (sound!) general principle that they always deserve abuse, regardless of the immediate facts.  Gcc developers are the candles whose unsteadiness we blame for causing us to stumble in the darkness.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/478908/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479125"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Knock me over with a feather</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 20:05 UTC (Thu)
                               by <b>dashesy</b> (guest, #74652)
                              [<a href="/Articles/479125/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can someone please explain, what could be the advantage of a "one-bit bitfield" over an integer here?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479125/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Knock me over with a feather</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 20:46 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/479136/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe they're planning to have several flags in future?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor479157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Knock me over with a feather</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 21:57 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479157/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the thing is, this compiler bug would break that too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Knock me over with a feather</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2012 6:50 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/479238/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, the real bug was the 32-bit lock word.  The bitfield was just to tempt fate.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor479399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Knock me over with a feather</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2012 22:58 UTC (Fri)
                               by <b>cavok</b> (subscriber, #33216)
                              [<a href="/Articles/479399/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
bitfields in a mostly 32/64 bit aligned world...<br>
how many millions of those structures do you need to see some gain in using bitfields?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Knock me over with a feather</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2012 23:02 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479402/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
not very many.<br>
<p>
if you can even replace two int variables with one bitfield, you may shrink your datastructure enough to have it fit within a CPU cache line. The memory access that can then be avoided can be enough to make a noticeable difference.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479578"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Knock me over with a feather</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 13:32 UTC (Mon)
                               by <b>cavok</b> (subscriber, #33216)
                              [<a href="/Articles/479578/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
got it. thank you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479578/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor479570"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Knock me over with a feather</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 12:22 UTC (Mon)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/479570/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can gain a lot of code space using related bits declared in a bitfield structure, because the compiler can do a single mask (to hide irrelevant bits) and a single test of a 32 bits value to decide something.<br>
For instance, a bitfield structure describing the debugging/logging of messages where bits are enable_global, enable_subsystem1, enable_onserial, telnet_connected, and the test is "if (debug.enable_global &amp;&amp; (debug.enable_onserial || debug.telnet_connected) &amp;&amp; debug.enable_subsystem5)".<br>
If you do not do that, on processors with one single "flag" register, the only way for the compiler is to do multiple test and jump and storing intermediate bit into 32 or 64 bits registers (compilers do not do well sub-register allocation by themself).<br>
You could also use the preprocessor with "#define enable_global 0x80000", but I prefer writing in C/C++ than in CPP...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479570/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor478965"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spinlock definition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 11:39 UTC (Thu)
                               by <b>abacus</b> (guest, #49001)
                              [<a href="/Articles/478965/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      From <code>arch/x86/include/asm/spinlock_types.h</code>:<pre>
        typedef u8  __ticket_t;
        typedef u16 __ticketpair_t;

        typedef struct arch_spinlock {
                union {
                        __ticketpair_t head_tail;
                        struct __raw_tickets {
                                __ticket_t head, tail;
                        } tickets;
                };
        } arch_spinlock_t;</pre>

Shouldn't all the above fields have been declared as volatile ?
      
          <div class="CommentReplyButton">
            <form action="/Articles/478965/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Spinlock definition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2012 6:54 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/479239/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, volatile almost never does anything useful.  It's the 32-bit lock word that was the mistake.  Fortunately, it should be easy to fix in the kernel without depending on a compiler fix, just by forcing a 64-bit aligned word.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor478990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 13:57 UTC (Thu)
                               by <b>Lovechild</b> (guest, #3592)
                              [<a href="/Articles/478990/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder if LLVM/Clang behaves differently in this case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/478990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 16:31 UTC (Thu)
                               by <b>darthscsi</b> (guest, #8111)
                              [<a href="/Articles/479041/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It does it correctly.  Se the load, or, store (extended to i32 in the padded bytes), then load of the volatile. compiled on x86-64 at O3.<br>
<p>
struct example {<br>
        volatile int a;<br>
        int b:1;<br>
    };<br>
<p>
int foo(struct example* e) {<br>
  e-&gt;b = 1;<br>
  return e-&gt;a;<br>
}<br>
<p>
<p>
%struct.example = type { i32, i8 }<br>
<p>
define i32 @foo(%struct.example* nocapture %e) nounwind uwtable {<br>
entry:<br>
  %0 = getelementptr %struct.example* %e, i64 0, i32 1<br>
  %1 = bitcast i8* %0 to i32*<br>
  %2 = load i32* %1, align 4<br>
  %3 = or i32 %2, 1<br>
  store i32 %3, i32* %1, align 4<br>
  %a = getelementptr inbounds %struct.example* %e, i64 0, i32 0<br>
  %4 = load volatile i32* %a, align 4, !tbaa !0<br>
  ret i32 %4<br>
}<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 16:33 UTC (Thu)
                               by <b>darthscsi</b> (guest, #8111)
                              [<a href="/Articles/479042/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, and the assembly:<br>
<p>
0000000000000000 &lt;foo&gt;:<br>
   0:   80 4f 04 01             orb    $0x1,0x4(%rdi)<br>
   4:   8b 07                   mov    (%rdi),%eax<br>
   6:   c3                      retq<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 16:47 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/479050/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>This looks like x86-64 assembler to me, not IA64.</p>

<p>Are you even sure we are talking about the same case? x86-64 works just fine with GCC, too. PowerPC, Sparc and IA-64 (which started the thread) work incorrectly...</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/479050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor479089"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 19:13 UTC (Thu)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/479089/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Noone is claiming GCC's behaviour is not a bug<br>
<a href="http://gcc.gnu.org/bugzilla/show_bug.cgi?id=52080">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=52080</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479089/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2012 22:21 UTC (Thu)
                               by <b>jan.kara</b> (subscriber, #59161)
                              [<a href="/Articles/479163/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes. Initially there was some misunderstanding between kernel &amp; GCC ;). But in fact GCC guys agreed that there is a bug. Just they claim fix won't be easy / quick...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor479331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2012 17:43 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479331/">Link</a>] (54 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Speaking as a compiler developer here.<br>
<p>
<font class="QuotedText">&gt; But sometimes compilers do stupid things. Using 8-byte accesses to a </font><br>
<font class="QuotedText">&gt; 4-byte entity is *stupid*, when it's not even faster, and when the base </font><br>
<font class="QuotedText">&gt; type has been specified to be 4 bytes! </font><br>
<p>
The compiler may have no choice.  I can imagine a machine where the only access size is 64 bits or greater.  Insane?  I imagine the 6- and 16-bit processor guys said the same when Alpha appeared.  If the hardware does not support a smaller granularity of access there is no choice but to do a RMW.  This is why the C standard does not make the guarantees Linus wants it to make.<br>
<p>
In this IA64 case it probably is a bug because AFAIK 32-bit accesses are allowed and no worse performance-wise than 64-bit accesses on all implementations.  But I can also imagine implementations of IA-64 where a 32-bit access would be more expensive and thus a 64-bit access would make sense.<br>
<p>
There really is no way to guarantee what Linus wants using standard C, so the kernel code is buggy.  That's why compiler extensions abound.  In this case, some of the GCC alignment directives could help.<br>
<p>
But as compiler developers, we often have to fix bugs in user code where the developer expected unreasonable things.  So we do it.  :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2012 22:01 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479384/">Link</a>] (50 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In this IA64 case it probably is a bug</font><br>
<p>
To clarify, it's probably only a "bug" in a quality-of-implementation sense.  The behavior is perfectly acceptable according to the C standard.  6.7.2.1 makes pretty much everything related to bitfields implementation-defined.<br>
<p>
The ABI may define semantics more strictly and if gcc violates them it's a "real" bug.  I don't have a copy of the IA-64 ABI so I don't know what the rules are for that platform.<br>
<p>
The x86_64 ABI does place more restrictions on bitfield layout but technically there is nothing there that says the bitfield *must* be accessed though any particular type (i.e. load/store size).  But quality-of-implementation concerns will lead the compiler writer to implement the semantics Linus expects for that platform and to not do so would be considered a bug.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2012 22:04 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479385/">Link</a>] (49 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
remember that this same thing happens if you have two int (32 bit) fields next to each other, it's not just bitfield related<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2012 22:50 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479394/">Link</a>] (48 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure which "this" you're referring to but it is certainly the case that one doesn't need bitfields to trigger this kind of false sharing.  The behavior entirely depends on the target platform.<br>
<p>
Even for the non-bitfield case, it is technically not a bug (unless the ABI mandates something stricter) but is almost certainly a quality-of-implementation issue and for all intents and purposes would be considered a bug if the target platform has the appropriate kinds of loads and stores available.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2012 22:56 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479398/">Link</a>] (47 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it was pointed out that if you define two 32 bit variables, one of which is defined as volitile, the compiler will still do the 64 bit load, modify, save routine.<br>
<p>
This is a direct violation of the spec.<br>
<p>
note that these target platforms do have the appropriate loads and stores, and they aren't even slower than the 64 bit ones.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2012 23:07 UTC (Fri)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479404/">Link</a>] (45 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This is a direct violation of the spec.</font><br>
<p>
Which spec?  The IA-64 ABI?  There is nothing in the C standard that mandates a specific allocation size for any member of a struct, much less alignment and access width.<br>
<p>
I'm agreeing with you that it's a gcc bug, in that it may violate the ABI (I don't know) and almost certainly violates the standards of a quality implementation.<br>
<p>
I'm simply pointing out that any code that relies on the layout of a struct or how its members are accessed is inherently non-portable.  Fundamentally, from a language perspective, it is the kernel code that is buggy, assuming the kernel wants to be portable, which I think it does.  :)<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2012 0:34 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479415/">Link</a>] (43 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it is violating the part of the spec that says that 'volitile' variables are assumed to be affected by external things and so the compiler cannot make assumptions that the variable has not changed just because it didn't issue any commands to change it.<br>
<p>
remember, the developers are not demanding that the layout be a particular way, it's the compiler that's doing this.<br>
<p>
restating my understanding<br>
<p>
  volitile int a;<br>
  int b;<br>
<p>
and then making a change to b triggers a read/write cycle on a the compiler is doing the wrong thing (because the value of a may change between the read and write) and the programmer has explicitly told the compiler that a may change unexpectedly.<br>
<p>
in the case that found the bug they were doing something like<br>
<p>
  int lock;<br>
  int bitfield'<br>
<p>
and they found that if one thread modified the value of bitfield while another thread modified lock, the modification to lock would get lost.<br>
<p>
If the compiler can't do 32 bit loads and stores, then it needs to store these two variables in a way that they are padded so that the 64 bit lodes and stores won't loose modifications.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479444"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2012 14:20 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/479444/">Link</a>] (41 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
it is violating the part of the spec that says that 'volitile' variables are assumed to be affected by external things and so the compiler cannot make assumptions that the variable has not changed just because it didn't issue any commands to change it.
</blockquote>
There is no such part (even if you spell it properly and look for 'volatile' :P ).
<p>
The standard states (with wording identical in C99 and the just-released C11):
<blockquote>
An object that has volatile-qualified type may be modified in ways unknown to the implementation or have other unknown side effects. Therefore any expression referring to such an object shall be evaluated strictly according to the rules of the abstract machine, as described in 5.1.2.3. Furthermore, at every sequence point the value last stored in the object shall agree with that prescribed by the abstract machine, except as modified by the unknown factors mentioned previously. What constitutes an access to an object that has volatile-qualified type is implementation-
defined.
</blockquote>
This states how volatile accesses are to be carried out. It does <i>not</i> stipulate that such accesses may not have effects on other, non-volatile-qualified objects (such as adjacent bitfield fields): nor does it state that volatile-qualified objects cannot be modified incidentally by expressions that do <i>not</i> refer to them, nor that you cannot read from one and then store the same data back. All that is required is the usual rule that objects not described as having changed contents between sequence points should appear unchanged at the subsequent sequence point from the point of view of the C abstract machine. And that machine, up till C11, is a <i>serial</i> machine, taking no account of threading. There is no provision whatsoever for avoiding a read-write cycle of the same data from an object back into itself in case other threads might modify it, because in a single-threaded environment this is harmless so the freedom is better granted to implementors than denied.
<p>
Thus it is not a violation of the (C99) Standard for accesses to a bitfield to unexpectedly issue write cycles to adjacent volatile bitfields for their current content as far as the serial abstract machine is concerned: indeed, on nearly all platforms this is unavoidable if the adjacent bitfields are located within the same byte. It would not be a violation of the Standard for an implementation to do a massive RMW cycle on <i>all of memory</i> every time a variable of <i>any</i> sort was accessed. These are both quality-of-implementation issues, not standards violations.
<p>
In C11, this has been fixed: as footnote 13 of the new section s5.1.2.4 puts it
<blockquote>
Compiler transformations that introduce assignments to a potentially shared memory location that would not be modified by the abstract machine are generally precluded by this standard, since such an assignment might overwrite another assignment by a different thread in cases in which an abstract machine execution would not have encountered a data race. This includes implementations of data member assignment that overwrite adjacent members in separate memory locations. We also generally preclude reordering of atomic loads in cases in which the atomics in question may alias, since this may violate the "visible sequence" rules.
</blockquote>
However, compiler support for C11 isn't here yet, and the kernel is currently being compiled by a C99 compiler. So this is moot except inasmuch as it guides compiler implementors towards what <i>will</i> be expected in the future. And this fix appeared more than twenty years after the finalization of the first C standard to mention 'volatile'. For all that intervening time, the behaviour of GCC seen here was -- while unpleasant and probably a bug -- not a standards-violation.
      
          <div class="CommentReplyButton">
            <form action="/Articles/479444/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479456"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2012 17:56 UTC (Sat)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479456/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This includes implementations of data member assignment that overwrite </font><br>
<font class="QuotedText">&gt; adjacent members in separate memory locations.</font><br>
<p>
That would seem to be the "out" that gets around the problem of the target machine not having an appropriately-sized load/store instruction to avoid false sharing.<br>
<p>
I've not studied the C11 standard yet.  Is that the intent of this statement?  Otherwise C11 structs with volatile members could be ABI-incompatible with source-equivalent C99 structs due to forced alignment to avoid placing volatile members next to other members in a single load/store access unit.<br>
<p>
In other words, what happens if I have a volatile char next to a non-volatile char and my target only has 32-bit loads and stores?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479456/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2012 21:27 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/479471/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Er, that footnote says that those are *precluded*, not permitted (though of course as a footnote it is not normative).<br>
<p>
I'm not sure how you can implement these requirements without either ABI changes or an efficiency reduction (on platforms where sub-maximum-sized writes are inefficient). We might have to eat the efficiency loss: we surely cannot fix this by aligning every member of every structure to cacheline boundaries or something like that, that's ridiculous.<br>
<p>
(But I am a neophyte in this area. Someone, anyone, who knows more than me, please chip in!)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479616"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 18:06 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479616/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Er, that footnote says that those are *precluded*, not permitted (though </font><br>
<font class="QuotedText">&gt; of course as a footnote it is not normative).</font><br>
<p>
I think it's an "out" because the footnote only covers data in "separate memory locations."  Two chars that don't cross an alignment boundary would be in the same "memory location" in some sense.  They're in the same atomically-readable space.<br>
<p>
But I don't know if that's the intent.  If not, I think C11 has a serious issue.  It will require ABI changes and that's not going to make people happy.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479616/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479626"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 18:38 UTC (Mon)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479626/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yours cannot be the correct reading.  The basic C11 requirement for multi-threaded programs is in ยง5.1.2.4/4: "Two expression evaluations conflict if one of them modifies a memory location and the other one reads or modifies the same memory location."  In this normative provision, "memory location" cannot possibly mean anything other than the internal representation of a built-in type (char, int, or other integer, or a pointer), otherwise writing multi-threaded programs would be impossible.   The POSIX standard for pthreads imposes a similar requirement on the implementation.<br>
<p>
Note that marking a struct or a field of a struct volatile is irrelevant to all this.  This (ยง5.1.2.4) is a part of the C specification relating to access to an object of a given built-in type by multiple threads within a single process.  Volatile is concerned only with asynchronous access to a given memory location by a single thread in a single process (for example, by an interrupt).  Of course, if volatile were to work at all in the usage in the kernel, some prior cache synchronization would be required so approximating to what is wanted here.  But even so, the compiler is not obliged to provide the behavior demanded by the kernel code in question.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479626/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479643"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 20:02 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479643/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for explaining things.<br>
<p>
<font class="QuotedText">&gt; But even so, the compiler is not obliged to provide the behavior demanded </font><br>
<font class="QuotedText">&gt; by the kernel code in question.</font><br>
<p>
Again, not being familiar with C11, what does the memory model give that can help multithreaded programming, then?  How does ยง5.1.2.4/4 work in the case where the machine access granularity is larger than some primitive types and a RMW must happen?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479643/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479656"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 21:04 UTC (Mon)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479656/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Again, not being familiar with C11, what does the memory model give that can help multithreaded programming, then? How does ยง5.1.2.4/4 work in the case where the machine access granularity is larger than some primitive types and a RMW must happen?"<br>
<p>
Discarding volatile, which is irrelevant, it requires the faulty behavior observed in the kernel not to occur.  On 64 bit architectures it can do this by various pessimizations.  It could use slower 32 bit accesses where available.  If that is not available it may have to pad so that any 32-bit scalar occupies 64 bits of space, where necessary to conform to the standard.<br>
<p>
None of this is new.  gcc's pthreads implementations have been doing this for years.  It might be instructive to look at the assembly output of the same test cases compiled with the -pthread switch.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479656/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479659"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 21:11 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479659/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
32 bit operations are not slower on all 64 bit architectures, including specifically the ia64 architecture where this problem was discovered.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479659/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479662"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 21:32 UTC (Mon)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479662/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well that should make it easier to get the gcc developers to deal with the ia64 at least, although I would take a little persuading that moving memory from 64 bit registers into non-64-bit aligned memory locations didn't cause some slow down in code operating in 64 bit mode.  Do you have any citations for that?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479662/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479665"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 21:39 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479665/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linus and several others in the kernel thread on the subject have said this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479665/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor479696"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 0:43 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479696/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If that is not available it may have to pad so that any 32-bit scalar </font><br>
<font class="QuotedText">&gt; occupies 64 bits of space, where necessary to conform to the standard.</font><br>
<p>
Or pad 8 bits to 32, etc.  This is what I mean by breaking ABI compatibility.  If interfaces include struct values this could be a real nightmare.<br>
<p>
Personally, I think this requirement is ridiculous absent some special attribute to enforce it.  If there was a qualifier on a type to indicate "shared," _a_la_ UPC, that would be one thing.  But to have this requirement for every single data item in the program is a very bad idea.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479696/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479757"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 8:43 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/479757/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>Since C11 includes _Alignas and you can specify you own alignment it's not a disaster, albeit it <b>is</b> inconvenience.</p>

<p>Perfectly working C++ program can already be broken by recompilation in C++11 mode, so it's not the first time upgrade broke things.</p>

<p>Of course is only possible if original program violated specs and worked by accident (if you can show me genuinely different behavior in standards-compliant program it'll be interesting to know, too, but so far all examples I've seen contained subtle violations of one form or another).</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/479757/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 18:35 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479843/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, cool, didn't know about _Alignas.  I'm a codegen guy so I'm not playing around in the C frontend very often.  I only look at the standard when I really have to.  :)<br>
<p>
There's still an ABI problem if the compiler always has to align members to uphold the requirement.<br>
<p>
<font class="QuotedText">&gt; Perfectly working C++ program can already be broken by recompilation in </font><br>
<font class="QuotedText">&gt; C++11 mode</font><br>
<p>
But as we all know, C++ is not C.  :)  I don't see this as a problem.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479877"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 20:53 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/479877/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">&gt; Perfectly working C++ program can already be broken by recompilation in <br />
&gt; C++11 mode<br /><br />
But as we all know, C++ is not C. :) I don't see this as a problem.</font></blockquote>

<p>C++ is quite explicitly not C, but C++11 pretends that it's still C++.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/479877/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479907"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 23:29 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479907/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, I read "C11."<br>
<p>
Yes, you are correct, but I don't think there's an ABI issue.  An ABI issue is much harder to deal with than a semantic change.<br>
<p>
With an ABI issue you've got to recompile the world (your project, libraries it links to, etc.) to get a working application.  With a semantic change you only recompile the bits that had to recoded to account for the change.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479907/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2012 8:54 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/479969/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>YMMV, as usual.</p>

<p>We recompile the world anyway, so ABI change is less of a problem, but the fact that just a recompilation does not fix the issue and you need to do a lot of investigations is a problem.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/479969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor479630"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 18:40 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/479630/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Not quite. s3.14's definition of 'memory location' is

<blockquote>
either an object of scalar type, or a maximal sequence of adjacent bit-๏ฌelds all having nonzero width
</blockquote>

Therefore, even a 'long long' variable occupies a single 'memory location' by that defintion. However, a two-byte array of two chars occupies two memory locations. A location is not the same as an address.
      
          <div class="CommentReplyButton">
            <form action="/Articles/479630/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor479474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2012 21:47 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/479474/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      That's very interesting, because it seems to say the provision for "volatile" is so incomplete as to be a pointless language feature.  "volatile" was supposed to deal with C programs running in an address space that includes memory mapped I/O regions.  But if the compiler is allowed to write whatever it wants whenever it wants into I/O regions, just as long as it doesn't expect it to stay there, what's the point?  You can't confidently run a C program in an address space that contains memory mapped I/O regions.
<p>
Maybe it's useful in read-only memory mapped I/O regions that just ignore writes.


      
          <div class="CommentReplyButton">
            <form action="/Articles/479474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2012 22:25 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/479476/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
That's very interesting, because it seems to say the provision for "volatile" is so incomplete as to be a pointless language feature.
</blockquote>
I dunno. As long as compiler vendors cooperate, it's useful for its intended purpose, which was pretty much entirely *reading* from memory-mapped I/O regions and writing into them very carefully, in a serial environment. It wasn't particularly intended for parallel processing environments or multithreading, AIUI (though since I was only 13 when C89 was finalized, I obviously wasn't there and don't know for sure).
<p>
In general you can't (and never could) rely on 'volatile' without knowing what the compiler would do when you asked it: implementations have had horrible bugs in their treatment of volatile often enough that care is warranted. But at the very least, it provides a way to flag that 'something tricky is happening here, look out'. It's proved more useful than 'register', low bar though that is. :)
      
          <div class="CommentReplyButton">
            <form action="/Articles/479476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479477"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2012 22:37 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/479477/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Right, it's a useful feature of de facto C, but maybe not of standard C.  This is just an academic discussion about the standard, since it seems everyone agrees GCC needs to change regardless of whether it presently implements the standard.
<p>
As long as you know that storing to your memory mapped I/O regions is a no-op, you can use standard C with volatile to usefully fetch from them, but otherwise you need more than standard C.  You need common sense C.  It just seems strange to me because writable I/O regions did exist at the time this accomodation for reading them was added to the spec.

      
          <div class="CommentReplyButton">
            <form action="/Articles/479477/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479633"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 19:21 UTC (Mon)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479633/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"This is just an academic discussion about the standard, since it seems everyone agrees GCC needs to change regardless of whether it presently implements the standard."<br>
<p>
I absolutely don't agree with this.  Forbidding 64-bit read/writes for 32-bit scalars within an aligned 64-bit boundary is a pessimization which should be opted into in C99, such as with the -pthread flag as in current gcc implementations (-pthread does require this pessimization if adjacent memory locations would otherwise be corrupted).<br>
<p>
Presumably when C11 is implemented in gcc, opting out of this pessimization will also be available.  Or possibly gcc will require some specific flag to be set where a multi-threaded program is being compiled, who knows.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479633/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor479619"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 18:08 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479619/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That's very interesting, because it seems to say the provision for </font><br>
<font class="QuotedText">&gt; "volatile" is so incomplete as to be a pointless language feature.</font><br>
<p>
Not totally true.  It's true that volatile doesn't do what most people expect.  Basically, volatile says the data can't be cached in a register (because the unerlying value might change unexpectedly), and little else.  But the prohibition on register allocation is a pretty big deal to the compiler.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479619/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479636"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 19:27 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479636/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
if it's not allowed to be cached in a register (because it could change unexpectedly), why are you allowed to do a read-write cycle on it? isn't that effectively the same thing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479636/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479639"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 20:01 UTC (Mon)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479639/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am not sure if it answers your question, but gcc would only be non-conforming if it carried out a corrupting read-write cycle on the memory location of a volatile variable as also read by an interrupt in the same thread attempting to read the same variable (or vice-versa), where the volatile variable is of type sig_atomic_t.<br>
<p>
This is orthogonal to the original problem, which (as far as I can work out) is concerned with concurrent access by different threads.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479639/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479644"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 20:06 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479644/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the thing is, the current GCC behaviour _would_ overwrite the value of a volatile variable that was modified by an interrupt in the middle of the read-modify-write cycle of a different (but adjacent) variable.<br>
<p>
As Linux says, it's possible for someone to fix the bug with respect to volatile, and explicitly leave the bug in for all other accesses (with the claim that the spec allows the compiler to do that), but it would probably be more work to do that then to just change the behaviour across the board.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479644/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479654"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 20:51 UTC (Mon)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479654/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"the thing is, the current GCC behaviour _would_ overwrite the value of a volatile variable that was modified by an interrupt in the middle of the read-modify-write cycle of a different (but adjacent) variable."<br>
<p>
I don't believe that has been tested and I don't believe it to be true.  On hardware where 64 bit boundaries are important, sig_atomic_t would be likely to be 64-bits wide.  (Someone with a ia64 architecture might be able to confirm this.)  In that case alignment boundaries would be fully respected.<br>
<p>
Also, I can't see that the original problem had anything to do with interrupts.  It seems to be concerned with either multi-threading, or shared access by multiple processes.<br>
<p>
Lastly, when you refer to "the bug with respect to volatile", you impute that gcc has the bug.  If there is a bug, it is a bug in the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479654/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479655"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 21:04 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479655/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
one of the posts I saw on this topic (I think from Linus) tested the code snippet<br>
<p>
  volitile int a;<br>
  int b;<br>
<p>
  b++;<br>
<p>
and the resulting assembler did the exact same read-write on a that caused the problem with the case in question. If an interrupt were to happen between the read and the write that changed the value of a, the write would cause that value to be lost.<br>
<p>
no, the item in question wasn't related to interrupts, but the cause of the problem causes the same problem if interrupts were involved.<br>
<p>
If the 32 bit loads and stores were significantly more expensive to use than 64 bit loads and stores, there would be at least some reason to have this behaviour available, but in the case of the architectures in question there isn't a performance benefit to doing it this way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479655/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479657"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 21:16 UTC (Mon)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479657/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"no, the item in question wasn't related to interrupts, but the cause of the problem causes the same problem if interrupts were involved."<br>
<p>
Not it doesn't.  Memory access issues relating to multiple threads (or multiple processes in the case of shared memory) have nothing to do with interrupts, and nothing to do with volatile.<br>
<p>
This really is beating a dead horse.  Compiler switches are available to ensure memory consistency for the case in question, notably the -pthread switch.  I can see why the kernel doesn't want to, or can't, use that.  In that case the kernel authors need to write some assembler or use 64-bit values on architectures where it is important, or persuade the gcc developers to provide another compiler switch dealing with this particular problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479657/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor479645"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 20:05 UTC (Mon)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479645/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The key work is "cached."  On any load/store machine the data must be first loaded into a register to do anything with it.  volatile says it must be written back out by the next sequence point.  I'm sure language lawyers will find some detail I've missed but that's the way I think about the guarantee.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479645/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479647"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 20:13 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479647/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
right, but the programmer is not attempting to do anything with it. The programmer is attempting to do something with another variable, one that just happens to be adjacent to the one in question.<br>
<p>
again the code snippit is<br>
<p>
  volitile int a;<br>
  int b;<br>
<p>
  b++;<br>
<p>
if modifying b causes a read/write of a, this is wrong.<br>
<p>
the programmer has not made any attempt to specify alignment here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479647/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479698"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 0:48 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479698/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; if modifying b causes a read/write of a, this is wrong.</font><br>
<p>
No, it's not.  Believe me.<br>
<p>
The volatile keyword doesn't say anything about when it will change value, be read/written etc.  It says simply that it will not be cached in a register such that every read will get the "latest" value expected when executed under the Abstract Machine.<br>
<p>
It says nothing about threading.<br>
<p>
It says nothing about interrupts.<br>
<p>
Simply remember that volatile is not magic.  Think of it as the opposite of "register."<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479698/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479705"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 1:03 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479705/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
in that case I have to agree with the other poster who said that if the compiler considers it Ok to write over any arbitrary memory locations, as long as what it's writing matches what the compiler thinks is already there, then that compiler is unsuitable for use with any memory mapped I/O as it will feel free to clobber the new data that is waiting to be read.<br>
<p>
since this sort of thing has been part of C's traditional strength, this doesn't seem like a sane interpretation to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479705/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor479818"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 16:54 UTC (Tue)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479818/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"It says nothing about interrupts."<br>
<p>
I think it does.  See ยง5.1.2.3/5 and /10, which are normative.  The principal purpose of volatile is to deal with arbitrary changes of data values outside the program context of the process in which the code is running (ie asynchronous interrupts).  (This does not include threads, which are within the program context and which, because they can run on more than one core, require quite different synchronizations, some of which are not async-signal-safe.)<br>
<p>
See also the footnote 134 of ยง6.7.3/8 (which is non-normative despite the "shall not"): "A volatile declaration may be used to describe an object corresponding to a memory-mapped input/output port or an object accessed by an asynchronously interrupting function. Actions on objects so declared shall not be 'optimized out' by an implementation or reordered except as permitted by the rules for evaluating expressions."  This is a curious note as, as far as I am aware, it is the one and only reference to memory mapping (and about which I mis-spoke in an earlier posting on this article because it is not in C99 which contains no reference to memory mapping).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479818/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479844"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 18:38 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479844/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; "It says nothing about interrupts."</font><br>
<p>
Thanks for the correction.  But the compiler is still correct here.  Volatile doesn't say anything about restricting _when_ it is read or written, only that it will get the "latest" value in a single-thread context.<br>
<p>
It's perfectly fine for I/O as long as you can guarantee alignment such that there is no "false sharing."<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479844/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479851"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 19:07 UTC (Tue)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479851/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree.  And if you get false sharing between two free-standing variables where the one being operated on is marked volatile, or between fields of a struct where the struct is marked volatile, there is a compiler bug.  It is still not clear whether that is the case with the kernel test case (first, the struct was not marked volatile, only one of its fields; and secondly, we don't know whether the test case involved an asynchronous test (as opposed to threads) or not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479851/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 20:01 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/479863/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the kernel did not have one field marked volatile, but in the research into the problem, someone (I think it was Linus) tested with volatile and the false sharing was happening there as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor479909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 23:32 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479909/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And if you get false sharing between two free-standing variables where the &gt; one being operated on is marked volatile, or between fields of a struct </font><br>
<font class="QuotedText">&gt; where the struct is marked volatile, there is a compiler bug.</font><br>
<p>
No, there isn't.<br>
<p>
There isn't.  Really.<br>
<p>
Volatile does not mean what you think it means.<br>
<p>
It's a bit like sequential consistency.  Just when you think you understand it, something unexpected happens that is both non-intuitive and perfectly legal.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor480030"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2012 15:24 UTC (Wed)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/480030/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seeing some of your other posts about -pthread, I think we are in agreement.  Apologies if I mischaracterized your understanding.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/480030/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor480001"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2012 13:51 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/480001/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And, thirdly, the kernel is not C11 code -- yet.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/480001/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor479669"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 22:22 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/479669/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
<blockquote>
That's very interesting, because it seems to say the provision for 
"volatile" is so incomplete as to be a pointless language feature.
</blockquote>
Not totally true. It's true that volatile doesn't do what most people expect. Basically, volatile says the data can't be cached in a register ...
</blockquote>
<p>
I was commenting at a higher level.  Never mind what the compiler can and can't do.  The question is, what programs can you write in C because it has the "volatile" feature that you couldn't otherwise?  Relying on nothing but that the compiler implements the C standard.
<p>
I've always understood the originally intended answer to be, "you can write a program that uses memory mapped I/O."  But comments in this thread say regardless of how one uses the "volatile" keyword in a program, the compiler may always generate code that arbitrarily writes to memory mapped I/O addresses.  There's nothing in the standard to stop it.  If so, then you not only can't use memory mapped I/O in a C program, you can't even let a C program &mdash; any C program &mdash; <em>run</em> in an address space that includes memory mapped I/O regions.
<p>
Unless all memory-mapped I/O regions ignore writes.
<p>
And it's hard to believe that the definers of "volatile" actually had such a useless thing in mind.

      
          <div class="CommentReplyButton">
            <form action="/Articles/479669/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 0:52 UTC (Tue)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479700/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Again, this is implementation-defined behavior.  The standard you're looking for is the ABI for your target.  That's where all the memory layout, access size, calling convention and other low-level stuff is specified.<br>
<p>
Volatile is perfectly fine for I/O as long as you know the address being accessed is suitably aligned to avoid problems, as the ABI should indicate.<br>
<p>
This is why volatile is non-portable.  Unfortunately, C99 has no standard way to force alignment of any object.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 8:46 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/479759/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">This is why volatile is non-portable. Unfortunately, C99 has no standard way to force alignment of any object.</font></blockquote>

<p>GCC, MSCV and other compilers include such an ability and C11 finally adds it to standard so it's all is not so bad...</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/479759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor479455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2012 17:47 UTC (Sat)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479455/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's not what volatile says.  There is nothing in the entire C execution model that even considers multiple threads.  That's why we have other standards like MPI and OpenMP.<br>
<p>
If you need to protect data like this you must make use of constructs outside the C standard.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor479443"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2012 13:57 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/479443/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
I'm simply pointing out that any code that relies on the layout of a struct or how its members are accessed is inherently non-portable.
</blockquote>
Not so: you can depend on later members of a struct having strictly higher addresses than earlier ones: i.e., the compiler cannot reshuffle struct members. (This is not an especially exciting guarantee, but it's all we've got.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/479443/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor479439"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2012 13:17 UTC (Sat)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/479439/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a comment on the GCC bug that suggests that for volatile to have this affect on a structure member, it would require the whole structure to be tagged volatile - not just the member concerned. (Not offering my own opinion here either way, EINSUFFICIENTEXPERTISE, just drawing attention to the comment).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479439/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor479823"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 17:06 UTC (Tue)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/479823/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>Insane? I imagine the 6- and 16-bit processor guys said the same when Alpha appeared.</blockquote>
<p>Yes, Alpha's lack of 8- and 16-bit store instructions was insane. That's why they were added in later versions of the architecture.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/479823/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2012 0:11 UTC (Wed)
                               by <b>daglwn</b> (guest, #65432)
                              [<a href="/Articles/479914/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are plenty of architectures that have these kinds of restricted loads and stores.  The old Cray machines only ever operated on 64 bit words, for example.<br>
<p>
And often a machine implements the smaller accesses but there is a performance penalty due to alignment issues and the bus/DRAM access architecture.  It's not uncommon for the RMW to be faster.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor480003"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2012 13:57 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/480003/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SPARC is another major example of an arch with alignment-restricted loads and stores. I have dim memories that suggest that MIPS might be as well.<br>
<p>
It's actually easier to come up with a list of architectures that do *not* require natural alignment on loads and stores than to come up with a list of those that do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/480003/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor479575"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2012 12:41 UTC (Mon)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479575/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is not a gcc bug even in the case of struct fields marked volatile, if the whole struct is not marked volatile.<br>
<p>
In a user-space program all this would be irrelevant.  In the case of different threads accessing different 32 bit integers within an aligned 64-bit boundary, POSIX would prohibit gcc making a 64-bit read/write if the program is compiled with the -pthread compiler option and memory corruption would otherwise arise (this is implicit in Base Definitions, General Concepts, section 4.11, Memory Synchronization, of the SUS).  In the case of different processes accessing shared memory between processes (about which the C standard says nothing) you are likewise relying on the guarantees of the shared memory implementation, if any.<br>
<p>
The kernel is expecting POSIX-like behavior from a C compiler.  gcc is not obliged to provide this if that has not been required of it, either by means of the -pthread switch or by gcc being required (once it has been implemented) to use the similar C11 memory model for multi-threaded programs.  Those writing kernels have to force the issue in some other way, such as by writing machine-word sized fields in such cases or by writing processor specific assembly language to force the correct synchronized behavior.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479575/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 17:12 UTC (Tue)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/479825/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
None of the options you are suggesting makes a slight difference to gcc behaviour in this case. In any case, the C11 memory model is to a large extent a codification of what is already understood in the industry to be necessary to support multithreaded C programs.<br>
<p>
Your unhelpful standards-lawyering attitude is exactly what many programmers have come to hate about certain compiler developers.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 19:21 UTC (Tue)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479854/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are you telling me that you have actually run a test case compiled with the -pthread option which exhibits this problem?  If not, I just don't believe you because I have written shed loads of multi-threaded code using POSIX threads which has never encountered a false sharing problem of this kind.<br>
<p>
If you run a test case compiled with the -pthread flag which exhibits this problem then this is an egregious failure on the part of the threading implementation of gcc and you should post a bug.  (It is far more serious than the non-standards complying kernel code.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor479859"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 19:36 UTC (Tue)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479859/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And since you refer to "none of the options you are suggesting makes a slight difference", can you also clarify whether you mean you have run a test case demonstrating false sharing even in the case of 64-bit scalars, and/or even in the case of assembly instructions which should have forced synchronization?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479859/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor481691"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 17:01 UTC (Wed)
                               by <b>cbf123</b> (guest, #74020)
                              [<a href="/Articles/481691/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I just tested with gcc version 4.3.2 (Wind River Linux Sourcery G++ 4.3-85) for powerpc.  Building the test app (the volatile version) as "gcc x.c -c -m64 -pthread" resulted in the following code, which clearly shows a 64-bit read/write cycle.

<pre>
0000000000000000 <.wrong>:
   0:   fb e1 ff f8     std     r31,-8(r1)
   4:   f8 21 ff c1     stdu    r1,-64(r1)
   8:   7c 3f 0b 78     mr      r31,r1
   c:   f8 7f 00 70     std     r3,112(r31)
  10:   e9 3f 00 70     ld      r9,112(r31)
  14:   e8 09 00 08     ld      r0,8(r9)
  18:   39 60 00 01     li      r11,1
  1c:   79 60 f8 2c     rldimi  r0,r11,31,32
  20:   f8 09 00 08     std     r0,8(r9)
  24:   e8 21 00 00     ld      r1,0(r1)
  28:   eb e1 ff f8     ld      r31,-8(r1)
  2c:   4e 80 00 20     blr
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/481691/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 20:21 UTC (Thu)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/481990/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Any chance you could file a bug on this one?  It is not so bad if the non-standard use of volatile has this effect (although no doubt still very annoying to the kernel developers), but it seems to me to be something else when the code happens to be POSIX-conforming code and corrupts memory locations.<br>
<p>
(Yes I have seen the argument in papers in the early proposals for the C/C++ threading model that "memory location" is ambiguous in Base Definitions, section 4.11, of the SUS, and could refer to a machine's natural word size rather than individual scalars, and so C11/C++11 now explicitly states that "memory location" in its equivalent wording means any scalar or bitfield, but that is a completely perverse construction of the SUS as it makes POSIX threads completely useless as a standard, bringing threading back to individual non-standard ABIs.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor479865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2012 20:18 UTC (Tue)
                               by <b>chrisV</b> (guest, #43417)
                              [<a href="/Articles/479865/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I want to keep your issues separate and I have asked you under a separate posting about your tests concerned.  On the POSIX point, setting out the assembly output of test cases for Itanium, first without -pthread and then with -pthread, and showing the false sharing would be sufficient, as -pthread is supposed to switch on the POSIX memory model in gcc and it will quickly become apparent if it doesn't.<br>
<p>
This posting is just to comment on your observations on the C11 memory model.  You are quite right in saying it represents accumulated wisdom, because its starting point was the (comparatively under-specified) POSIX memory model for multi-threaded programs.  However, if you read the lkml postings in questions, you will see that the kernel community do not want the generalized C11 memory model for the kernel.  They want the preclusion of false sharing; they don't want full sequential consistency in all cases because of its efficiency implications.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/479865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Betrayed by a bitfield</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 16:20 UTC (Fri)
                               by <b>jwakely</b> (subscriber, #60262)
                              [<a href="/Articles/482123/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; as -pthread is supposed to switch on the POSIX memory model in gcc</font><br>
<p>
Says who?<br>
<p>
On ia64-linux it appears to be equivalent to just -D_REENTRANT, on x86-linux it also passes -lpthread to the linker, but it has no effect on code-generation.<br>
<p>
<font class="QuotedText">&gt; they don't want full sequential consistency in all cases because of its efficiency implications.</font><br>
<p>
Which part of the C11 memory model requires sequential consistency?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor480693"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A single historical context of volatile</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 10, 2012 22:22 UTC (Fri)
                               by <b>dfsmith</b> (guest, #20302)
                              [<a href="/Articles/480693/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To quote from Harbison &amp; Steele 3rd ed. (1991)* section 4.4.5<br>
<p>
"... any object ... of a volatile-qualified type should not participate in optimizations that would ... modif[y] the object."<br>
<p>
To my mind that prohibition includes non-volatile object optimizations that would clobber volatile objects.<br>
<p>
The book then slightly contradicts itself two paragraphs later by saying that "optimizations between sequence points are permitted" before clarifying with a hardware example.<br>
<p>
<p>
* A standard ANSI C reference manual for programmers and compiler implementers at the time.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/480693/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
