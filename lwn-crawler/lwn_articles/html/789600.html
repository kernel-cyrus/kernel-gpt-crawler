        <!DOCTYPE html>
        <html lang="en">
        <head><title>A way to do atomic writes [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/789600/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/789232/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/789600/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A way to do atomic writes</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jake Edge</b><br>May 28, 2019</br>
           <hr>
<a href="/Articles/lsfmm2019/">LSFMM</a>
</div>
<p>
Finding a way for applications to do atomic writes to files, so that either
the old or new data is present after a crash and not a combination of the
two, was the topic of a session 
led by Christoph Hellwig at the 2019 Linux Storage, Filesystem, and
Memory-Management Summit (LSFMM).
Application developers hate the fact that when they update files in place,
a crash can leave them with old or new data—or sometimes a combination of
both. 
He discussed some implementation ideas
that he has for atomic writes for XFS and wanted to see what the other
filesystem developers thought about it.
</p>

<p>
Currently, when applications want to do an atomic write, they do one of two
things. Either they use "weird user-space locking schemes", as
databases typically do, or they write an entirely new file, then do an
"atomic rename trick" to ensure the data is in place.  Unfortunately, the
applications often do not use <tt>fsync()</tt> correctly, so they lose
their data anyway.
</p>

<a href="/Articles/789378/">
<img src="https://static.lwn.net/images/2019/lsf-hellwig-sm.jpg" border=0 hspace=5 align="left"
alt="[Christoph Hellwig]" title="Christoph Hellwig" width=210 height=300>
</a>

<p>
In modern storage systems, the devices themselves sometimes do writes that
are not in-place writes.
Flash devices have a flash translation layer (FTL) that
remaps writes to different parts of the flash for wear leveling, so
those never actually do in-place updates.  For NVMe devices, an update of
one logical-block address (LBA) is guaranteed to be atomic but the
interface is awkward so he is not sure if anyone is really using it.  SCSI
has a nice interface, with good error reporting, for writing atomically,
but he has not seen a single device that implements it.
</p>

<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
There are filesystems that can write out-of-place, such as XFS, Btrfs, and
others, so it would be nice to allow for atomic writes at the filesystem
layer.  He said that nearly five years ago there was an interesting <a
href="https://www.usenix.org/conference/fast15/technical-sessions/presentation/verma">paper</a> 
from HP 
Research that reported results of adding a special <tt>open()</tt> flag to
indicate that atomic 
writes were desired.  It was an academic paper that didn't deal with some
of the corner cases and limitations, but had some reasonable ideas.
</p>

<p>
In that system, users can write as much data as they want to a file, but nothing
will be visible until they do an explicit commit operation.  Once that
commit is done, all of the changes become active.  One simple way to
implement this would be to handle the commit operation as part of
<tt>fsync()</tt>, 
which means that no new system call is required. 
</p>

<p>
A while back, he started implementing atomic writes using this scheme in
XFS.  He <a href="/Articles/715918/">posted</a> some patches, but there
were multiple problems there; he has since reworked that patch set.  Now
the authors of the paper are "pestering him" to get the code out so that
they can write another paper about it with him.  Others have also asked for
the feature, he said.
</p>

<p>
Chris Mason asked what the granularity is; is it just a single
<tt>write()</tt> call or more than that?  Hellwig said that it is all of
the writes that happen until the commit operation is performed.
Filesystems can establish an upper bound on the amount of data that can be
handled; for XFS it is based on the number of discontiguous regions
(i.e. extents) that 
the writes touch.  
</p>

<p>
This feature would work for <tt>mmap()</tt> regions as well, not just
traditional <tt>write()</tt> calls.  For example, Hellwig noted that it is
difficult to do an atomic update of a, say, B-Tree that updates multiple
nodes. With this feature, the application can just make the changes in the
file-backed memory, then do the commit; if there is a crash, they will end
up with one version or the other.
</p>

<p>
Ted Ts'o said that he found it amusing because someone he is advising on
the Android team wants a similar feature, but wants it on a per-filesystem
basis.  The idea is that, when updating Android from one version to
another, the ext4 or F2FS filesystem would be mounted with a magic option
that would stop any journal commits from happening.  An <tt>ioctl()</tt>
command would then be sent once the update has finished and the journal
commits would be processed.  It is "kind of ugly", he said, but it gives
him perhaps 90% of what would be needed to implement the atomic write
feature. 
Toward the end of the session, 
Ts'o said that he believes ext4 will get the atomic write feature as well,
though it 
will be more limited in terms of how much of the file can be updated prior
to a commit.
</p>

</p>

<p>
Hellwig expressed some skepticism, noting that he had tried to do something
similar by handling the updates in memory, but that became restrictive in
terms of the amount of update data that could be handled.  Ts'o said that for
Android, the data blocks are being written to the disk, it is just the
metadata updates that are being held for the few minutes required to do the
update.  It is a "very restrictive use case", Ts'o said, but the new
mechanism replaces a device-mapper hack that was far too slow.
</p>

<p>
Chris Mason said that, depending on the interface, he would be happy to see
Btrfs support it.  Hellwig said that it should be fairly straightforward to do
in Btrfs.  One of the big blockers for him at this point is the interaction
with <tt>O_DIRECT</tt>.  If an application writes data atomically, then
reads it back, it better get what it just wrote; no "sane application"
would do that, he said, but NFS does.  The Linux I/O path is not really set
up to handle that, so he has some work to do there.
</p>

<p>
There was some discussion of using <tt>fsync()</tt> instead of a dedicated
system call or other interface.  Hellwig sees no reason not to use <tt>fsync()</tt> since
it has much the same meaning; there is no reason to do one operation
without the other, he said.  Amir Goldstein asked about the possibility of
another process using an <tt>fsync()</tt> on the file as a kind of attack.
</p>

<p>
Hellwig said that originally he was using an <tt>open()</tt> flag, but got
reminded again that unused flags are not checked by <tt>open()</tt> so
using a flag for data integrity is not really a good idea.  Under that
model, though, an <tt>fsync()</tt> would only map to the commit operation
for file 
descriptors that had been opened with the flag.  He has switched to an
inode flag, which makes more sense in some ways, but it does leave open the
problem of unwanted <tt>fsync()</tt> calls.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Atomic_IO_operations">Atomic I/O operations</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Block_layer-Atomic_operations">Block layer/Atomic operations</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_and_Memory-Management_Summit-2019">Storage, Filesystem, and Memory-Management Summit/2019</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/789600/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor789661"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2019 3:53 UTC (Wed)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/789661/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be nice to keep atomicity separate from durability, i.e. don't make fsync() the atomic commit primitive, unless it also works with an asynchronous variant of fsync().  A lot of applications don't care if you lose the last few updates, as long as the application never sees the results of a partial update.  In database terms, this is asynchronous commit, which trades durability for performance without giving up atomicity, consistency, or integrity.<br>
<p>
Currently what happens in Linux looks kind of weird when you write it down:<br>
<p>
 1.  A bunch of application threads issue a series of well-defined(-ish) IO syscalls which modify the logical contents of a filesystem.  The kernel arbitrates an order when several operations affect the same files or metadata in concurrent threads according to some rules--maybe not the best rules, or rules that everyone likes, or rules that are even written down, but there are rules and the kernel does follow them.  Observers that later inspect the data in the filesystem find something equivalent to the result of performing the mutation operations in the arbitrated order.  Application developers can predict how multiple threads modifying a filesystem might behave as long as the system doesn't crash.  There are test suites to verify consistent behavior across filesystems, and bugs can be reported against filesystems that don't comply.  But then...<br>
<p>
 2.  At irregular intervals, we mash all of the writes together in big shared buffers, and unreliably spew them out to disk in arbitrary order (not necessarily the optimal IO order, although IO optimization is ostensibly why we do this) without protecting those buffers against concurrent modification.  If there's no crash and no threads concurrently writing, the disk holds a complete and correct copy of the filesystem state at some chosen instant in time.  If there's a crash, we just leave the user applications with a mess to clean up, proportional in size to the amount of idle RAM we had lying around, possibly containing garbage and previously deleted data.  The existing behavior is the spec, so it's impossible to report any undesirable behavior as a bug because all current behavior is tautologically correct, even when it changes.<br>
<p>
So for an application developer, we set up a bunch of expectations in #1, and then fail to deliver on all of them in #2.  No wonder they hate Linux filesystems and can't use fsync() correctly!<br>
<p>
It would be nice to get to a point where we can say that not behaving like #1 after crashes is a filesystem bug, or the result of some risky non-default mount option or open flag chosen by an administrator or application developer.  Features that reduce data integrity and impose new requirements on existing applications (like delalloc, or, for that matter, Unix-style buffered writes in general) should really be opt-in.  It's maybe a bit late to have this opinion now, some decades after Unix-style buffered writes became a thing, but if multiple filesystems support atomic updates, there might be an opportunity to make better choices for default filesystem behavior in the future (e.g. do periodic filesystem commits as atomic updates as well).<br>
<p>
Databases know how to make precise tradeoffs between integrity and performance, and they can use the many shades of ranged and asynchronous fsync() effectively to implement atomic updates and all their other requirements on any filesystem, and they are more willing than most to keep up with changing filesystem API.  Non-database application developers don't want have to constantly learn new ways to avoid losing data every time filesystem default behavior changes.  They just want the filesystem to give back some consistent version of the data their threads asked it to write,  and don't need or want to know any details beyond knobs that adjust performance and latency (i.e. "write this to disk immediately, I'll wait" at one extreme, "you can write this any convenient time in the next hour, I don't care" at the other).  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789661/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor789682"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2019 13:06 UTC (Wed)
                               by <b>walters</b> (subscriber, #7396)
                              [<a href="/Articles/789682/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One way to look at it is - what scenarios is the current setup good for?  I would argue it's nearly optimal for the interesting case of "local software builds", e.g. on a developer workstation/laptop.<br>
<p>
Compilers tend to generate a lot of intermediate files which often get unlinked quickly.  If writes weren't buffered this would be an enormous hit.  It'd really force build systems to write to a tmpfs style mount instead of the persistent source code directory.<br>
<p>
I don't think anyone would want compliers to invoke fsync() either.  But it's not truly transient either - I *do* usually want the intermediate build files still there after I reboot.  (Contrast with most production buildsystems that don't do incremental builds).  So this falls more into your case of:<br>
<p>
"you can write this any convenient time in the next hour, I don't care"<br>
<p>
But then on the topic of consistency - a while ago when I was using ccache I hit a bug where some of the cached objects were corrupted (zero-filled) after I had a kernel crash, and that caused bizarre errors.  This probably hits the interesting corner case of "tmpfile + rename over existing is atomic, but writing a new file isn't".  It took me longer than it should have to figure out, kept doing `git clean -dfx` and double checking the integrity of my compiler, etc.<br>
<p>
In <a href="https://github.com/ostreedev/ostree">https://github.com/ostreedev/ostree</a> we write all new objects to a "staging" directory that includes the value of /proc/sys/random/boot_id, and then syncfs() everything, then renameat() into place (I've been meaning to investigate doing parallel/asynchronous fsync instead).  We assume that the files are garbage if the boot id doesn't match (i.e. system was rebooted before commit).<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789682/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor789721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2019 17:35 UTC (Wed)
                               by <b>mmastrac</b> (guest, #132326)
                              [<a href="/Articles/789721/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is great information on something I hadn't considered before. Do you have anywhere you could point me at for "best practices" to use in combination with that technique (ie: fsync the file, then syncfs, then renameat iff boot_id matches, etc)?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor789752"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2019 20:43 UTC (Wed)
                               by <b>walters</b> (subscriber, #7396)
                              [<a href="/Articles/789752/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't know of any other software using the boot ID technique; I just made it up one day.  It seems to work well though.<br>
<p>
You can see some parts of this in <br>
<a href="https://github.com/ostreedev/ostree/blob/e0ddaa811b2f7a1af7e24c6b8c6f1074e216609e/src/libostree/ostree-repo.c#L3197">https://github.com/ostreedev/ostree/blob/e0ddaa811b2f7a1a...</a><br>
<a href="https://github.com/ostreedev/ostree/blob/e0ddaa811b2f7a1af7e24c6b8c6f1074e216609e/src/libostree/ostree-repo-commit.c#L1776">https://github.com/ostreedev/ostree/blob/e0ddaa811b2f7a1a...</a><br>
and<br>
<p>
But this is definitely the kind of thing that would be better with kernel assistance somewhat like the article is talking about.  Some sort of open flag or fcntl that says "I always want the whole file written, or nothing" - an extension to `O_TMPFILE` that allows fsyncing at the same time as `linkat()`?  Which is also closely related to my wishlist item for O_OBJECT: <a href="https://marc.info/?l=linux-fsdevel&amp;m=139963046823575&amp;w=2">https://marc.info/?l=linux-fsdevel&amp;m=139963046823575&amp;...</a> <br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789752/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor970656"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2024 18:50 UTC (Sun)
                               by <b>BrucePerens</b> (guest, #2510)
                              [<a href="/Articles/970656/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
5 years later I don't think anything's been done about this. In addition to your concerns, linkat() could use a flag to atomically unlink an existing target file when creating the new link. That seems to be the missing piece to creating an anonymous temporary file (O_TMPFILE) and then atomically giving it a name.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/970656/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor789735"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2019 18:45 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/789735/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps dumping the object files into the same directory as the source files (and hence the same filesystem) is a bit mad anyway? A tmpfs / ramdisk approach does seem more sensible, given that there is no particular need to spool out the intermediate files to physical disk. It’s one of those “we have always done it this way” things. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789735/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor789737"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2019 18:56 UTC (Wed)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/789737/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This could be extremely expensive. For example, suppose I do a sequence of writes, serialized in this order:<br>
<p>
1. Create huge file B1.<br>
2. Write to file A.<br>
3. Create huge file B2.<br>
4. Delete B1.<br>
5. Create huge file B3.<br>
6. Delete B2.<br>
<p>
And keep doing the create / delete dance.<br>
<p>
In your atomic model, A cannot ever be made durable without writing at least one large unnecessary file to disk.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789737/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor789808"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2019 8:39 UTC (Thu)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/789808/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This could be extremely expensive. For example, suppose I do a sequence of writes, serialized in this order:</font><br>
[...]<br>
<font class="QuotedText">&gt; And keep doing the create / delete dance.</font><br>
<p>
<font class="QuotedText">&gt; In your atomic model, A cannot ever be made durable without writing at least one large unnecessary file to disk.</font><br>
<p>
And is this a use case to be optimised for, or should people learn other ways of creating huge transient files?  I know that sounds like a suggestive question, but it is not.  I don't feel qualified to say.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789808/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor789866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2019 15:52 UTC (Thu)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/789866/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The same thing happens now if the dirty writeback timer (or filesystem commit interval for filesystems that have one of those) expires in the middle of this sequence.  We'd write out whichever parts of B1/B2 were in cache at the time (at the end of this sequence B3 exists, so we're always going to write that one).  We also do a big flush if we run out of memory while buffering B1 or B2, and in that case we block writing processes (so we do the expensive thing _and_ force userspace to wait for it).<br>
<p>
The difference with filesystem-atomic-by-default is that we'd choose some epoch and the atomic update would include all writes completed before the epoch and none of them after (any concurrent modification during writeback would be redirected to the next atomic update).  So you'd get e.g. all of A, all of B1, and the first parts of B2 in one atomic update, and a later update would delete B1, write the rest of B2, and the first parts of B3.  If there's a crash before B1 gets to disk, then A disappears.<br>
<p>
This is fine!  This is the correct behavior according to what the various system calls are documented to do, assuming that writeback caching behaves like an asynchronous FIFO pipeline to disk by default (i.e. when you didn't explicitly turn off atomic update, call fsync(), or provide some other hint that says the filesystem needs to do more or less work for specific files).  It's not the most performant behavior possible, so it sucks, but the most performant behavior possible does bad things to data when the system crashes, so it sucks too.  Most people who aren't saturating their storage stack with iops care more about correctness than performance, and would trade some iops to get correctness even if it means flushing out a multi-gigabyte temporary file now and then.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor789710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2019 19:12 UTC (Wed)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/789710/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the right model is: Imagine there's a process on the machine constantly making backups to storage that doesn't go down in the crash. It will back up every file eventually, and will back up every file that fsync() is called on during the call. After the system comes back, the state matches the backup, except that there may be some arbitrary damage, which the kernel tries to minimize.<br>
<p>
The current behavior, or any behavior, obviously fits this model, since it means that any post-restore state is possible, but it gives a different idea of what the kernel should be optimizing for with respect to crash resilience, which seems to me to be a good fit for how users rate system behavior.<br>
<p>
Note that Unix-style buffered writes don't cause any problem here, because ordering changes there can be explained as getting unlucky as to the order the backup process read them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor790025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2019 0:02 UTC (Sat)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/790025/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Imagine there's a process on the machine constantly making backups to storage that doesn't go down in the crash.</font><br>
<p>
My backups are atomic, and have been for years...<br>
<p>
OK, I'm imagining this now:  of course, I expect the storage to be updated atomically and correctly every time by this backup process.  Worst case, I don't get the last update, or the last N consecutive updates if I choose to optimize for performance by pipelining.<br>
<p>
<font class="QuotedText">&gt; After the system comes back, the state matches the backup, except that there may be some arbitrary damage</font><br>
<p>
[still imagining] Nope, that's totally unacceptable.  If I see any damage at all, someone's getting a bug report.  Broken files are failure.  [imagination off]<br>
<p>
Proprietary storage vendors have supported atomic backups from snapshots of live filesystems for decades, and Linux hasn't been far behind.  They just work.  This is not a new or experimental thing any more.  The better implementations have reasonable performance costs.  Let's have filesystems on Linux that can get it right all the time, not just between crashes.<br>
<p>
<font class="QuotedText">&gt; The current behavior, or any behavior, obviously fits this model</font><br>
<p>
"It's impossible to report any undesirable behavior as a bug because all current behavior is tautologically correct, even when it changes."  For example, recently I pointed out on LWN that the current behavior is undesirable, and someone soon replied to explain the current behavior back to me without supporting argument, as if it was somehow self-evident that the current behavior is the best behavior possible.<br>
<p>
This pattern happens a lot.  It usually takes several tries to get past that and get into a discussion of what's undesirable about the current behavior, or how things could become better, or even how different people just have different preferences and expectations.  Then we have to get past the horrified "but...that could be slightly slower!" response.  Then we have to avoid regressing to the beginning of the loop when someone who missed the first part of the conversation jumps in.  Usually by this point, everyone's gotten bored and left.<br>
<p>
The problem is not that Linux is an incorrect implementation of the current model.  The problem is that the current model is patently insane, and we should maybe consider sane models that could be used instead.<br>
<p>
<font class="QuotedText">&gt; a different idea of what the kernel should be optimizing for with respect to crash resilience</font><br>
<p>
This doesn't appear to be a different idea.  It seems to be just a retroactive justification of the way Linux filesystems have worked since the mid 90's--a time when every crash resulted in filesystem damage requiring time-expensive recovery tools, because nothing better had been implemented yet.  Now we have atomic snapshots and journals and CoW and persistent writeback caches and future improvements like atomic write API implemented in multiple filesystems.  We can do better than mid-90's standards of crash behavior now.<br>
<p>
<font class="QuotedText">&gt; Note that Unix-style buffered writes don't cause any problem here, because ordering changes there can be explained as getting unlucky as to the order the backup process read them.</font><br>
<p>
The filesystem and the backup process could arrange not to change the ordering, and then it would all work properly.  No luck required, nothing to explain.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/790025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor790042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2019 1:47 UTC (Sat)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/790042/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The operating system can't guarantee that your hardware won't destroyed entirely by your building collapsing on it, even if you called fsync() on a file. If your drive controller goes bad, it could start writing the wrong blocks. If you want to be really sure about your data, you restore of real off-site (or, at least, off-box) backups, rather than using a filesystem left on a machine that crashed, if only because you don't know what could have gone wrong before whatever caused the crash actually brought down the system.<br>
<p>
I'm saying that the post-crash state should exactly match some state that userspace might have observed had the system never crashed, and any deviation from that should be accounted and planned for like equipment failure, except that it may be attributed to the filesystem software rather than the disk hardware; in any case, you're trading off reliability against size, performance, and cost, and none of these is ever perfectly ideal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/790042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor790182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2019 18:25 UTC (Mon)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/790182/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If your drive controller goes bad, it could start writing the wrong blocks.</font><br>
<p>
That happens from time to time.  Storage stacks can deal with that kind of event gracefully.  Today we expect those errors to be detected and reported by the filesystem or some layer below it, and small errors repaired automatically when there is sufficient redundancy in the system.<br>
<p>
<font class="QuotedText">&gt; If you want to be really sure about your data, you restore of real off-site (or, at least, off-box) backups</font><br>
<p>
To make correct backups, the backup process needs a complete, correct, and consistent image of the filesystem to back up, so step one is getting the filesystem to be capable of making one of those.<br>
<p>
Once you have that, and can atomically update it efficiently while the filesystem is online, you can stop using fsync as a workaround for legacy filesystem behaviors that should really be considered bugs now.  fsync should only be used for its two useful effects:  to reorder and isolate updates to individual files for reduced latency, and to synchronize IO completion with events outside of the filesystem (and those two things should become separate system calls if they aren't already).  If an application doesn't need to do those two things, it should never need to call fsync, and its data should never be corrupted by a filesystem.<br>
<p>
<font class="QuotedText">&gt; you don't know what could have gone wrong before whatever caused the crash actually brought down the system.</font><br>
<p>
If we allow arbitrary failure modes to be in scope, we'll always lose data.  To manage risks, both the frequency and cost of event occurrence have to be considered.<br>
<p>
Most of the time, crashes don't have complications with data integrity impact (e.g. power failure, HA forcing a reboot, kernel bugs with known causes and effects).  We expect the filesystem to deal with those automatically, so we can redirect human time to cleaning up after the rarer failures:  RAM failures not detected by ECC, multi-disk RAID failures, disgruntled employees with hammers, etc.<br>
<p>
When things start going unrecoverably wrong, each subsystem that detects something wrong gives us lots of information about the failure, so we can skip directly to the replace-hardware-then-restore-from-backups step even before the broken host gets around to crashing.  All the filesystem has to do in those cases is provide a correct image of user data during the previous backup cycle.<br>
<p>
None of the above helps if the Linux filesystem software itself is where most of the unreported corruption comes from.  It was barely tolerable while Linux filesystems were a data loss risk comparable to the rest of the storage stack, but over the years the rest of the stack has become more reliable while Linux filesystems have stayed the same or even gotten a little worse.<br>
<p>
<font class="QuotedText">&gt; I'm saying that the post-crash state should exactly match some state that userspace might have observed had the system never crashed, and any deviation from that should be accounted and planned for like equipment failure</font><br>
<p>
I'm saying that in the event there is no equipment failure, there should be no deviation.  Even if there is equipment failure, there should not necessarily be a deviation, as long as the system is equipped to handle the failure.  We don't wake up a human if just one disk in a RAID array fails--that can wait until morning.  We don't want a human to spend time dealing with corrupted application caches after a battery failure--the filesystem shouldn't corrupt the caches in the first place.<br>
<p>
<font class="QuotedText">&gt; in any case, you're trading off reliability against size, performance, and cost, and none of these is ever perfectly ideal.</font><br>
<p>
...aaaand we're back to the horrified "but it could be slower!" chant again.<br>
<p>
Atomic update is probably going to end up being faster than delalloc and fsync for several classes of workload once people work on optimizing it for a while, and start removing fsync workarounds from application code.  fsync is a particularly bad way to manage data integrity when you don't have external synchronization constraints (i.e. when the application doesn't have to tell anyone else the stability status of its data) and when your application workload doesn't consist of cooperating threads (i.e. when the application code doesn't have access to enough information to make good global IO scheduling decisions the way that monolithic database server applications designed by domain experts do).<br>
<p>
It's easier, faster, and safer to run a collection of applications under eatmydata on a filesystem with atomic updates than to let those applications saturate the disk IO bandwidth with unnecessary fsync calls on a filesystem that doesn't have atomic updates--provided, as I mentioned at the top, that there's a way to asynchronously pipeline the updates; otherwise, you just replace a thousand local-IO-stall problems with one big global-IO-stall problem (still a net gain, but the latency spikes can be nasty).<br>
<p>
Decades ago, when metadata journaling was new, people complained it might be an unreasonable performance hit, but it turned out that the journal infrastructure could elide a lot of writes and be faster at some workloads than filesystems with no journal.  The few people who have good reasons not to run filesystems with metadata journals can still run ext2 today, but the rest of the world moved on.  Today nobody takes a filesystem seriously if it can't recover its metadata to a consistent state after uncomplicated crashes (though on many filesystems we still look the other way if the recovered state doesn't match any instantaneous pre-crash state, and we should eventually stop doing that).  We should someday be able to expect user data to be consistent after crashes by default as well.<br>
<p>
Worst case, correct write behavior becomes a filesystem option, then I can turn it on, and you can turn it off (or it becomes an inode xattr option, and I can turn it off for the six files out of a million where crash corruption is totally OK).  You can continue to live in a world where data loss is still considered acceptable, and the rest of us can live in a world where we don't have to cope with the post-crash aftermath of delalloc or the pre-crash insanity of fsync.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/790182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor790522"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2019 12:03 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/790522/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  ...aaaand we're back to the horrified "but it could be slower!" chant again.</font><br>
<p>
Which is a damn good reason NOT to use fsync ...<br>
<p>
When ext4 came in, stuff suddenly started going badly wrong where ext3 had worked fine. The chant went up "well you should have used fsync!". And the chant came back "fsync on ext4 is slow as molasses!".<br>
<p>
On production systems with multiple jobs, fsync is a sledgehammer to crack a nut. A setup that works fine on one computer WITHOUT fsync could easily require several computers WITH fsync.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/790522/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor789674"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2019 9:32 UTC (Wed)
                               by <b>nilsmeyer</b> (guest, #122604)
                              [<a href="/Articles/789674/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I vaguely remember f2fs already having atomic writes support through some ioctl. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789674/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor789800"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2019 5:44 UTC (Thu)
                               by <b>qtplatypus</b> (subscriber, #132339)
                              [<a href="/Articles/789800/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have been thinking about this and I'm wondering if on fs that support it ioctl_ficlone it might leveraged to make atomic writes of the A without D type that many application devs desire.<br>
<p>
A sequence of<br>
<p>
 create B<br>
 ioctl_ficlone B from A<br>
 write to B<br>
 ioctl_ficlone A from B<br>
<p>
Though that looks too simple and there may be something I'm missing.<br>
 <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789800/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor789824"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2019 12:36 UTC (Thu)
                               by <b>Jonno</b> (subscriber, #49613)
                              [<a href="/Articles/789824/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Though that looks too simple and there may be something I'm missing.</font><br>
<p>
For crash consistency, you have to at least add an `fdatasync B` before `ioctl_ficlone A from B`, or you might get garbage in A after recovery. It also depends upon the filesystem writing the new extent mapping of A to disk atomically, which I don't think is actually guaranteed (though most filesystems probably do so anyway).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789824/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor789875"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2019 16:59 UTC (Thu)
                               by <b>perennialmind</b> (guest, #45817)
                              [<a href="/Articles/789875/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>
This is way too reminiscent of Transactional NTFS and Microsoft's earlier attempts to bring ACID guarantees to the filesystem. The generalized contract proposed makes a huge commitment and relies an awful lot on the particulars of journaling filesystems. The per-filesystem feature doesn't strike me as  "kind of ugly" at all: it sounds conservative and maintainable, with reasonably predictable ramifications.
</p>

<p>
For a more general solution, I'm much more interested in that <a href="https://www.usenix.org/conference/fast18/presentation/won">Barrier-Enabled IO Stack for Flash Storage</a>. It just makes sense to me. It's so neat and plausible, that I can't help but wonder if it isn't also wrong. Else, I should be reading more about it on LWN. &lt;shrug&gt;
</p>
All I want is a sane ordering guarantee. I'm willing to accept intermediate changes being observable if it means I can have some weak, localized constraints on causality. 
<pre><code>write(...)
write(...)
fdatabarrier(...)
rename(...)</code></pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/789875/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor790090"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2019 16:55 UTC (Sun)
                               by <b>daniel</b> (guest, #3181)
                              [<a href="/Articles/790090/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So in other words, you want exactly Tux3 semantics.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/790090/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor790524"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2019 14:29 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/790524/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A synchronous flush?<br>
<p>
Dunno how easy it would be to implement this, but imagine ...<br>
<p>
My application (database, whatever) writes a load of stuff - a user-space journal. It then calls the flush. This triggers writing all the buffers to disk, with a guarantee that writes AFTER my sync call can be moved EARLIER in time, but ALL EARLIER writes will complete before my call returns.<br>
<p>
That way, my application knows, when the call returns, that it's safe to start updating the files because it can recover a crash from the logs. It doesn't interfere with other applications because it's not hogging i/o. And if it's one of the few applications on an almost-single-use system then the almost continuous flushing it might trigger probably won't actually get noticed much - especially if it's a multi-threaded database because it can happily mix flushing one transaction's logs with another transaction's data.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/790524/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor789917"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2019 20:50 UTC (Thu)
                               by <b>yige</b> (guest, #132365)
                              [<a href="/Articles/789917/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
F.Y.I. we have an academic project, TxFS, which provides a version of Ext4 file system with ACID transactions. The idea can be generalized to other file systems that use journaling or COW to maintain crash consistency as well.<br>
<a href="https://github.com/ut-osa/txfs">https://github.com/ut-osa/txfs</a><br>
<p>
We added three new system calls to initiate/commit/abort a per-process file system transaction. It also separates ordering from durability, and does optimizations like eliminating temporary durable files, as discussed in the previous comments. e.g. The followed piece of pseudo-code will be executed without the persistence of fileA.<br>
<p>
fs_tx_begin();<br>
create(fileA);<br>
create(fileB);<br>
write(fileA);<br>
write(fileB);<br>
unlink(fileA);<br>
fs_tx_commit();<br>
<p>
It currently only supports a subset of file-related system calls since it's an experimental project. (e.g. rename and mmap are not supported yet.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/789917/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor790183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2019 17:36 UTC (Mon)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/790183/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The followed piece of pseudo-code will be executed without the persistence of fileA.</font><br>
<p>
...if fileA and fileB can be stored in the cache memory of the implementation, yes; otherwise, you have to start writing the data of at least one of fileA or fileB to disks before you get to the unlink which removes the need to write.<br>
<p>
That point was missed in the previous comments too:  temporary file optimizers can't read your mind, they can only read an incomplete transaction log, so they only work if the temporary file gets deleted while it is (or parts of it are) still in memory.  If you really want temporary file optimization, you need to label the file as a temporary as early as possible, so it can avoid getting flushed to disk too early.<br>
<p>
It might be nice to add an open flag named O_TMPFILE that tells the system that a file shouldn't be persisted...except we already have one, and it already does that.  So these tmpfile examples could look more like:<br>
<p>
fs_tx_begin();<br>
create(dirA, O_TMPFILE | normal_flags); // returns fileA file descriptor<br>
create(fileB, normal_flags);<br>
write(fileA);<br>
write(fileB); // if we start running out of memory here, we might flush fileB, not fileA<br>
// don't need to unlink fileA, it will disappear when closed.<br>
fs_tx_commit();<br>
<p>
If you need fileA to have a name or you need to close it during the transaction, it gets more complicated to use O_TMPFILE:  you have to do a weird dance with /proc/self/fd/* symlinks and linkat, and you do need to do the unlink at the end, and the O_TMPFILE flag is not a correct hint to the optimizer if you change your mind and keep the file through the end of the transaction.  It's also not clear that keeping fileA in RAM was a net win above--maybe it's better if fileA gets pushed out to disk so there's more RAM for caching fileB.<br>
<p>
So maybe a separate indicator (an xattr or fadvise flag) that says "optimize by minimizing writes to this file", and nothing else, might be more useful to provide hints to transaction infrastructure.  That will handle the cases where it's better to flush the temporary file to disk under memory pressure instead of the permanent one, and it can be set or cleared on files without having to modify the parts of the application that create files (which might be inaccessible or hard to modify).<br>
<p>
The nice thing about xattrs is that system integrators can set them without having to hack up applications, so you can get broad behaviors like "everything created in this directory from now on is considered a temporary file for the purposes of transaction commit optimization."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/790183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor790301"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2019 21:33 UTC (Tue)
                               by <b>yige</b> (guest, #132365)
                              [<a href="/Articles/790301/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, we do cache files in memory during a transaction. Flushes to disk are ignored until a transaction gets committed. This guarantees isolation for ACID transactions. But you're right, it sets up a limit for the size of a transaction. In our case, the optimization for eliminating temporary durable files is more of a positive side effect of ACID transactions. It helps especially in case users are unaware of the existence of such files in their transaction code.<br>
<p>
I agree that a separate indicator for minimized persistency on temporary files can be a good idea, so that it gets flushed only in face of memory pressure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/790301/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor790563"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2019 14:34 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/790563/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It might be nice to add an open flag named O_TMPFILE that tells the system that a file shouldn't be persisted...except we already have one, and it already does that. So these tmpfile examples could look more like:</font><br>
<p>
I worked on a FORTRAN system in the 80s that had such a file - it flagged the file as "delete on close". Except it had a bug - it flagged the file *descriptor* as delete on close. And because you could re-use a file descriptor my program started deleting a bunch of random - important - files. Caused the operators (it was a mainframe) a small amount of grief until I twigged the problem, tested it, and raised a bug report!<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/790563/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor818685"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2020 21:44 UTC (Sun)
                               by <b>edgecase</b> (guest, #138459)
                              [<a href="/Articles/818685/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looking at the set of all filesystems in-tree, out of tree, experimental, dead and gone, I wonder if there are just too many conflicting requirements, use-cases, and types of underlying hardware, to choose one set of semantics.<br>
<p>
The POSIX API seems to be bursting at the seams also.<br>
<p>
I wonder if ACID could be broken up, at a lower layer, and POSIX semantics built on top, as well as other APIs (or mount options?), that could focus on whatever combination of features is wanted.<br>
<p>
One in particular I can see being useful, is similar to the Android example mentioned earlier in this thread. The use-case of an operating system package manager installing or updating a set of packages (apt-get upgrade, yum update) for example, would ideally employ the sequence:<br>
<p>
1) unpack many files Isolated, but not durable.  This takes advantage of elevator seeks and write combining, but does not put (as much) pressure on journal.<br>
2) wait until they are all Durable (as a set, not individually)<br>
3) rename them all into place in one transaction, directory lock could be taken once per directory, not per file<br>
4) let them be visible (end the isolation)<br>
<p>
Making a special filesystem for doing this isn't ideal; there should be a more general way, since in this use-case, modifying files atomically isn't of value, but for someone else it might be.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/818685/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor856821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A way to do atomic writes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 20, 2021 20:33 UTC (Thu)
                               by <b>aist</b> (guest, #51495)
                              [<a href="/Articles/856821/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Atomic operations on files don&#x27;t have much sense now, because they imply two things:<br>
<p>
1. The model of concurrency.<br>
2. The system of relaxations of atomicity, to support different consistency/performance tradeoffs. <br>
<p>
Atomicity is not cheap, and, what is much more important, it&#x27;s not (easily) composable. Because of that, pushing high-level semantics down to hardware (disks) will not work as expected. Elementary (1-4 blocks) atomic operations are more than enough to support high-level composable atomic semantics across many disks. BUT, it&#x27;s very hard to have high-level (generic) atomic writes which will be parallel. People, relational databases apparently provide pretty concurrent atomicity, but they rely on the fact that relational tables are unordered (sets or records), so it&#x27;s relatively easy to merge multiple parallel versions of the same table into the single one. Merging of ordered data structures like vectors (and files) is not defined in general case (it&#x27;s application-defined). <br>
<p>
There are pretty good single-writer-multiple-readers (SWMR) schemes which are pretty light-weight, log-structured, wait-free and atomic for readers and writers (see LMDB for an example), but they are inherently single-writer. So, only one writer at a time can own the domain of atomicity (single file, directory, file-system). Readers are fully concurrent though with themselves and with writers. SWMR is best suitable for dynamic data analytics applications because of point-in-time semantics for readers (stable cursors, etc). <br>
<p>
Multiple concurrent atomic writes (MWMR) are possible, but they are not that wait-free like SWMR, have much higher operational overhead and require atomic counters for (deterministic) garbage collection. And write-write conflict-resolution is application-defined. So, if we want an MWMR engine to be implemented at the device level, it will require pretty tight integration with applications, implying pretty complex APIs. Simply speaking, it isn&#x27;t worth the efforts.<br>
<p>
Log-structured SWMR/MWMR may work well with a single-block-scale atomic operations, they just need certain power-failure guaranties. They can be implemented entirely in the userspace as services on top of asynchronous IO interfaces like uring. Partial POSIX file API is emulation for legacy applications accessing the &quot;atomic data&quot; is also possible via FUSE.<br>
<p>
Adding complex high-level atomic semantics (especially multi-operation commits) to the POSIX API will create much more problems than atomics are intended to solve. <br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/856821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
