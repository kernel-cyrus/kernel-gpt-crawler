        <!DOCTYPE html>
        <html lang="en">
        <head><title>The word-at-a-time interface [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/501492/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/500847/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/501492/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The word-at-a-time interface</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>June 12, 2012</br>
           </div>
While the kernel is a crucial part of almost any job one might want to do with
a computer, it is rarely the kernel itself that gets the interesting work
done.  More often, it appears as overhead that takes system resources away
from the applications the user actually wants to run.  So it makes sense to
optimize kernel operations to the greatest extent possible, especially when
those operations are carried out frequently on performance-critical paths.
The "word at a time" interface, optimized and made generic for the 3.5
release, is a good example of how far those optimization efforts can go.
<p>
The kernel does a lot of string processing, especially (but not
exclusively) when working with file path names.  It is often necessary to
know the length of a name or path component.  When confronted with such a
task, a C programmer would typically code a loop iterating through the
string one character at a time.  But, given enough strings, the
per-character loop overhead starts to get expensive.  It turns out that,
with enough bit-level trickery, much of that overhead can be dealt with by
working through string data one 32-bit or 64-bit word at a time.  The "word
at a time" API makes that sort of processing possible—but with a certain
complexity cost.
<p>
<h4>The API</h4>
<p>
Code wanting to use this interface should include
<tt>&lt;asm/word-at-a-time.h&gt;</tt>.  A few functions are defined
therein, the first being <tt>has_zero()</tt>:
<p>
<pre>
    unsigned long has_zero(unsigned long value, unsigned long *bits, 
			   const struct word_at_a_time *constants);
</pre>
<p>
From one point of view, <tt>has_zero()</tt> is a simple boolean function
that returns true if <tt>value</tt> contains a zero byte.  But what are the
other two parameters?  Let's start with the <tt>constants</tt> value, which
must simply be set to a value defined in the header file:
<p>
<pre>
    const struct word_at_a_time constants = WORD_AT_A_TIME_CONSTANTS;
</pre>
<p>
As will be described in more detail below, this structure contains
some useful constant values.  The structure is small and the contents are
architecture-dependent, so it was evidently deemed unnecessary to create a
single, globally-accessible copy.
<p>
The <tt>bits</tt> parameter, instead, is a place where <tt>has_zero()</tt>
can stash temporary data that will be useful to the remaining functions in
the API.  Those functions are:
<p>
<pre>
    unsigned long prep_zero_mask(unsigned long value, unsigned long bits,
    				 const struct word_at_a_time *constants);
    unsigned long create_zero_mask(unsigned long bits);
    unsigned long find_zero(unsigned long mask);
</pre>
<p>
Once <tt>has_zero()</tt> has identified a word containing a zero byte, all
three of these functions must be used to determine <i>which</i> byte
contains the zero value.  The usual calling sequence looks something like
this:
<p>
<pre>
    if (has_zero(value, &amp;bits, &amp;constants)) {
        bits = prep_zero_mask(value, bits, &amp;constants);
    	bits = create_zero_mask(bits);
    	zero_byte = find_zero(bits);
	/* ... */
</pre>
<p>
In other words, <tt>prep_zero_mask()</tt> and <tt>create_zero_mask()</tt>
both take the <tt>bits</tt> value first created by <tt>has_zero()</tt> and
rework it to the point that <tt>find_zero()</tt> can produce the offset of
the first zero byte in the word.
<p>
This may seem like a lot of work to do, but there is a reason for it.  The
functionality split allows different architectures to provide optimized
functions for each part of the job.  But there is another interesting bit
of subtlety here: it is possible to perform a logical OR of two different
<tt>bits</tt> values from two calls to <tt>prep_zero_mask()</tt>.  The
function <tt>hash_name()</tt> in <tt>fs/namei.c</tt> uses this feature to
search for either a zero byte or one containing a slash—the string it is
looking at ends either with a null byte or the beginning of the next
component in the path name.  The kernel spends a lot of time processing
path names, so this operation is worth optimizing in this way.
<p>
There is one other little detail to be kept in mind: the string might not
start at the beginning of a word.  Managing unaligned strings adds a bit
more complexity to the task; the curious can look at
<tt>lib/strnlen_user.c</tt> for one example of how these strings are
handled.  All told, using this interface adds enough complexity that it is
probably almost never worthwhile.  In that rare case where a per-character
loop is too expensive, though, word-at-a-time access can help.
<p>
<h4>How it works</h4>
<p>
The x86 version of this API can be found in
<tt>arch/x86/include/asm/word-at-a-time.h</tt>; one might be forgiven for
thinking that parts of it came from the obfuscated C contest.  It starts by
defining the above-mentioned constants:
<p>
<pre>
    struct word_at_a_time {
	const unsigned long one_bits, high_bits;
    };

    #define WORD_AT_A_TIME_CONSTANTS { REPEAT_BYTE(0x01), REPEAT_BYTE(0x80) }
</pre>
<p>
<tt>REPEAT_BYTE()</tt> is a macro (defined in
<tt>&lt;linux/kernel.h&gt;</tt>) that fills a word with copies of the given
byte value.  So, on a 32-bit machine, <tt>one_bits</tt> will be initialized
to <tt>0x01010101</tt>, and <tt>high_bits</tt> will be <tt>0x80808080</tt>;
64-bit machines will get the same pattern, but twice as long.  
<p>
After that,
<tt>has_zero()</tt> is defined as:
<p>
<pre>
    static inline unsigned long has_zero(unsigned long a, unsigned long *bits, 
    					 const struct word_at_a_time *c)
    {
	unsigned long mask = ((a - c-&gt;one_bits) &amp; ~a) &amp; c-&gt;high_bits;
	*bits = mask;
	return mask;
    }
</pre>
<p>
In English, the code subtracts one from every byte, masks out all of the
bits that were set in the original value, then masks everything but
the highest bit in every byte.  If one thinks of each byte as an
independent value, the high bit can be thought of as the sign bit.
Subtracting one from a value will only cause the sign bit to change from zero to one
if the bytes's value was zero before.  So this series of operations will cause the
highest bit to be set in any byte whose value was zero before.  (In truth,
the bytes are not independent, and borrowing will cause different results
after the first zero byte, but only the first one is of interest so that is
unimportant).
<p>
In the x86 implementation, <tt>prep_zero_mask()</tt> does nothing and will
be optimized out by the compiler.  That is not true of
<tt>create_zero_mask()</tt>, though:
<p>
<pre>
    static inline unsigned long create_zero_mask(unsigned long bits)
    {
	bits = (bits - 1) &amp; ~bits;
	return bits &gt;&gt; 7;
    }
</pre>
<p>
The subtraction will cause all bits up to the first set bit to be set to
one; all of the other bits are then masked out and the result is
right-shifted.  Thereafter, all bytes prior to the first zero byte (in the
original value) will be set to <tt>0xff</tt>.  All that's left, now, is to
figure out how many of those fully-populated bytes there are.  The code
that does this is not entirely straightforward; it is the result of <a
href="https://plus.google.com/102150693225130002912/posts/7bKRjV92snH">a
request Linus posted on Google+</a> in March.  For 32-bit machines,
<tt>find_zero()</tt> comes down to this code:
<p>
<pre>
    long a = (0x0ff0001+mask) &gt;&gt; 23;
    /* Fix the 1 for 00 case */
    return a &amp; mask;
</pre>
<p>
On 64-bit systems, instead, it looks like:
<p>
<pre>
    return mask*0x0001020304050608ul &gt;&gt; 56;
</pre>
<p>
Either way, the effect is to produce a number that is the byte offset of
the first zero.
<p>
This API is relatively new, having been first added (for x86 only) in the
3.4 development cycle.  In 3.5, it was substantially reworked and made more
widely applicable.  There are specific implementations for x86 and powerpc (the
latter uses a "count leading zeroes" instruction to speed things up); there
is also a "generic" version that really only works properly for big-endian
architectures.  That is enough, though, for a number of architectures to
make use of the capability.  The resulting microsecond-sized time savings
may not seem like much, but, multiplied across all of the string operations
the kernel does, it adds up to a significant improvement.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#String_processing">String processing</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Word-at-a-time">Word-at-a-time</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/501492/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor501882"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 6:17 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/501882/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>Nifty.  I'm a big fan of sub-word arithmetic without the benefit of SIMD extensions.  (And, in kernel mode, I'm certain there's a strong impetus to stay entirely in the integer part of the pipe for these things.)
</P>
<P>It might help to walk through some examples on the pieces to really understand what the 32-bit x86 version does.  At least, it helped me to mentally do these gymnastics.  I'll first just stick to the byte-at-a-time version, and then extend to the word oriented version, expanding our our dear editor's notes.  (Most or all of this is packed into the description in the article; I'm unpacking it for my benefit as much as for others'.)</P>
<P>The sequence expanded out is:</P>
<OL><LI><TT>tmp1 = byte - 1</TT></LI>
<LI><TT>tmp2 = tmp1 &amp; ~byte</TT></LI>
<LI><TT>rslt = tmp2 &amp; 0x80</TT></LI>
</OL>
<P>If you start with<TT> byte </TT><I>not</I> equal to 0, then<TT> byte - 1 </TT>will not equal 0xFF.  The right-most 1 will change from a 1 to a 0, and the zeros to the right of that will change to 1s.  Therefore, at the end of step 1, if<TT> byte != 0</TT>, the MSB of<TT> tmp1 </TT>will either be the same as it was for<TT> byte</TT>, or it will (in the case where<TT> byte == 0x80</TT>) have changed from 1 to 0.</P>
<P>So, when you get to step 2, the MSB of<TT> tmp2 </TT>will be 0, since step 2 ANDs the result of step 1 with the NOT of the original byte.  There are two cases here:  In case 1 (<TT>byte != 0x80 &amp;&amp; byte != 0x00</TT>) the MSB of<TT> tmp1 </TT>is the same as it was for<TT> byte</TT> so you're ANDing opposite values, whereas in case 2 (<TT>byte == 0x80</TT>) the MSB of both<TT> tmp1 </TT>and<TT> ~byte </TT>are both 0.  Either way, you end up with a 0 in the MSB of<TT> tmp2</TT>.  (BTW, the<TT> byte == 0x80 </TT>case is the reason you need AND-NOT, rather than XOR.)</P>
<P>Step 3 just extracts this bit, which should give<TT> rslt == 0x00 </TT>for all values of<TT> byte != 0x00</TT>.</P>
<P>If you start with<TT> byte == 0x00</TT>, at the end of step 1<TT> tmp1 = 0xFF</TT>.  When you reach step 2, then,<TT> tmp2 == 0xFF &amp; ~(0x00) == 0xFF</TT>.  Thus, at the end of step 3,<TT> rslt == 0x80 </TT>when<TT> byte == 0x00</TT>.</P>
<P>Things get only slightly more involved when you pack these bytes into words.  All the same math works with one caveat:  Any zero-byte in the word will corrupt the result for bytes to the left of it in the word.  That's OK though -- the first byte is all you need, and in little-endian, that also happens to be the rightmost byte.  On a big-endian machine, you're still OK, although you may have a little more work ahead of you to determine<I> which </I>byte was zero from the resulting packed mask.</P>
<P>Here's an example of where you run might into problems:  (Here 'byte' is actually four bytes in a 32-bit word.)</P>
<PRE>
byte = 0xAA0100AA
tmp1 = 0xAA0100AA - 0x01010101 = 0xA9FFFFA9
tmp2 = 0xA9FFFFA9 &amp; 0x55FFFF55 = 0x01FFFF01
rslt = 0x01FFFF01 &amp; 0x80808080 = 0x00808000
</PRE>
<P>On little endian, it's enough to consider the rightmost 0x80 as the "first zero", and ignore the "ghost zero" that showed up due to the borrow.  (You only get borrows when there's actually a zero.)  On big-endian, if you ever have 0x80s in consecutive bytes of the result, you have to scan to find the real 0.  Discontinuous 0x80s are real zeros.  Consider:</P>
<PRE>
byte = 0xAA00AA00
tmp1 = 0xAA00AA00 - 0x01010101 = 0xA8FFA8FF
tmp2 = 0xA8FFA8FF &amp; 0x55FF55FF = 0x00FF00FF
rslt = 0x00FF00FF &amp; 0x80808080 = 0x00800080
</PRE>
<P>There you didn't end up with a "ghost zero" because the non-zero byte between them ate the carry.  But any time you have 0x80s in consecutive bytes, you have more work to do:</P>
<PRE>
byte = 0xAA000100
tmp1 = 0xAA000100 - 0x01010101 = 0xA8FEFFFF
tmp2 = 0xA8FEFFFF &amp; 0x55FFFEFF = 0x00FEFEFF
rslt = 0x00FEFEFF &amp; 0x80808080 = 0x00808080
</PRE>
<P>This has entirely to do with the fact that big-endian orders bytes left-to-right in the word, but carries and borrows go right-to-left, and so only the rightmost result is reliable.</P>
<P>That gets us through determining a word has a zero.  What about the next part?  This comment is already long enough, so I'll start a new one for that...</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/501882/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor501886"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 6:51 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/501886/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <P>Now to explain the magic behind this bit of code:</P>
<PRE>
    long a = (0x0ff0001+mask) &gt;&gt; 23;
    /* Fix the 1 for 00 case */
    return a &amp; mask;
</PRE>
<P>To understand it, you need to first understand the output of the step just before it:</P>
<PRE>
    static inline unsigned long create_zero_mask(unsigned long bits)
    {
	bits = (bits - 1) &amp; ~bits;
	return bits &gt;&gt; 7;
    }
</PRE>
<P>As our dear editor states: "The subtraction will cause all bits up to the first set bit to be set to one; all of the other bits are then masked out and the result is right-shifted. Thereafter, all bytes prior to the first zero byte (in the original value) will be set to<TT> 0xff</TT>.</P>
<P>Unpacking that a bit:  The incoming mask in<TT> bits </TT>will have<TT> 0x80 </TT>in one or more bytes.  Subtracting 1 from<TT> bits </TT>will turn the rightmost<TT> 0x80 </TT>into<TT> 0x7F</TT>.  It will also turn any<TT> 0x00 </TT>bytes into<TT> 0xFF</TT>.  Thus, if<TT> bits == 0x80800000 </TT>, then<TT> bits - 1 = 0x807FFFFF</TT>.  ANDing this with<TT> ~bits </TT>will then leave a word with leading-zero bytes, a byte with<TT> 0x7F </TT>(in the position where the rightmost<TT> 0x80 </TT>was), and trailing<TT> 0xFF </TT>bytes.  (There could be zero leading or trailing bytes, depending on where the<TT> 0x80 </TT>was in<TT> bits</TT>.)</P>
<P>The subsequent right-shift by 7 just shifts the 0x7F down to the byte to the right of the first<TT> 0x80 </TT>from the right.  If the<TT> 0x80 </TT>was in the rightmost byte, then the overall result is zero.  Concretely, you end up with one of the following results:</P>
<PRE>
0x80000000 =&gt; 0x00FFFFFF
0x??800000 =&gt; 0x0000FFFF
0x????8000 =&gt; 0x000000FF
0x??????80 =&gt; 0x00000000
</PRE>
<P>Cute, isn't it?  For the 64-bit version, this step is similar, only with four more possible outcomes following the same pattern for the upper 4 bytes.</P>
<P>So how about that magic bit of code to find the byte number, then?  It's perhaps easiest to see how it works just by expanding out the math longhand for the four cases:</P>
<PRE>
(0x00FFFFFF + 0x00FF0001) &gt;&gt; 23 = 0x01FF0000 &gt;&gt; 23 = 3
(0x0000FFFF + 0x00FF0001) &gt;&gt; 23 = 0x01000000 &gt;&gt; 23 = 2
(0x000000FF + 0x00FF0001) &gt;&gt; 23 = 0x00FF0100 &gt;&gt; 23 = 1
(0x00000000 + 0x00FF0001) &gt;&gt; 23 = 0x00FF0001 &gt;&gt; 23 = 1
</PRE>
<P>Oops... doesn't look like it works entirely in that last case does it?  That explains the enigmatic comment "Fix the 1 for the 00 case" and the final<TT> a &amp; mask</TT>.  The result of the first calculation gets ANDed with the original mask, which has 0xFF in the LS byte for the first three cases.  That leaves the result unmodified.  In the case where<TT> bits == 0x00000000</TT>, though, that final AND clears the result away to the desired 0.  Tada!</P>
<P>I'll leave the 64-bit version's multiply as an exercise to the reader...  It's simple enough to work through the 8 possible inputs to the multiply, though.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/501886/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor501888"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 6:54 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/501888/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <BLOCKQUOTE><I>It will also turn any 0x00 bytes into 0xFF.</I></BLOCKQUOTE>
<P>That should say "any<TT> 0x00 </TT>bytes<I> to the right of it </I>into<TT> 0xFF</TT>."  Oops.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/501888/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor501889"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 7:04 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/501889/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>Ok, I can't resist offering a hint for the 64-bit case.  Consider that<TT> ((mask + 1) * 0x0001020304050607ul) &gt;&gt; 56 </TT>would also work.</P> 
      
          <div class="CommentReplyButton">
            <form action="/Articles/501889/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor501926"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 10:03 UTC (Thu)
                               by <b>alankila</b> (guest, #47141)
                              [<a href="/Articles/501926/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On topic, recommend studying the document called "bit-twiddling hacks":<br>
<p>
<a href="http://graphics.stanford.edu/~seander/bithacks.html">http://graphics.stanford.edu/~seander/bithacks.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501926/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor501962"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 13:10 UTC (Thu)
                               by <b>rschroev</b> (subscriber, #4164)
                              [<a href="/Articles/501962/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have a few questions about this. Not about the inner workings, which other comments have already explained, but about the interface.<br>
<p>
First, I don't understand the need of the bits argument of has_zero(). It is used to pass the value of mask to the caller, but mask is also the return value so the caller already has access to it. It seems to me one could just as well simplify to:<br>
<p>
unsigned long has_zero(unsigned long value, const struct word_at_a_time *constants);<br>
<p>
and use it like this:<br>
<p>
if (bits = has_zero(value, &amp;constants)) {<br>
  ...<br>
}<br>
<p>
Second, the parameter constants in has_zero() and prep_zero_mask() must be set to a value defined in the header file. If it's a fixed value, why does one have to pass it? Can't the function itself simply use the correct value itself?<br>
<p>
Can anyone enlighten me why things are done this way? Many thanks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501962/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor501980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 13:42 UTC (Thu)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/501980/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For the first thing, it may be that other architectures, for some values, may want to set *bits to zero and return non-zero indicating that zero byte was found.<br>
<p>
The second though puzzles me as well. I would assume that encoding constant in the code would be more efficient then getting them from memory. Then again, compiler may be clever enough to do that anyway, but this still does not explain why bother...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor502039"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 18:04 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/502039/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps it's a codesize thing, at least for 64-bit arches?  A 64-bit manifest constant is fairly big and may require many more than 8 bytes to generate with code.  Since these are inlines, multiply the cost by the number of call sites.<br>
<p>
A data-page relative access might be comparatively smaller and possibly cheaper when you account for smaller I-cache footprint.  You're still costing some D-cache, but it gets reused at every call site.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/502039/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor502044"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 18:15 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/502044/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <P>To throw some data into all this, I coded up a short test:</P>
<PRE>
struct csts
{
    long csta, cstb;
};

long foo1(long x, const struct csts *c)
{
    return (x + c-&gt;csta) &amp; c-&gt;cstb;
}

long foo2(long x)
{
    return (x + 0x0101010101010101ul) &amp; 0x8080808080808080ul;
}
</PRE>
<P>The objdump output illustrates the codesize argument:</P>
<PRE>
0000000000000000 &lt;foo1&gt;:
   0:	48 89 f8             	mov    %rdi,%rax
   3:	48 03 06             	add    (%rsi),%rax
   6:	48 23 46 08          	and    0x8(%rsi),%rax
   a:	c3                   	retq   
   b:	eb 03                	jmp    10 &lt;foo2&gt;
   d:	90                   	nop
   e:	90                   	nop
   f:	90                   	nop

0000000000000010 &lt;foo2&gt;:
  10:	48 b8 01 01 01 01 01 	movabs $0x101010101010101,%rax
  17:	01 01 01 
  1a:	48 ba 80 80 80 80 80 	movabs $0x8080808080808080,%rdx
  21:	80 80 80 
  24:	48 8d 04 07          	lea    (%rdi,%rax,1),%rax
  28:	48 21 d0             	and    %rdx,%rax
  2b:	c3                   	retq   
</PRE>
<P>If you ignore the end padding (which, in practice, would disappear with inlining), the first function is less than half the size of the second (11 vs. 27).  (Not exactly sure what that <TT>jmp foo2</TT> is doing there, but I'm ignoring it.)  With inlining, the situation naturally gets muddier if you have multiple uses of the same constant, but still, you can see that the constant-in-struct approach has some natural size advantages.</P>
<P>And yes, my data-page relative comment above is maybe a little bit off, unless after inlining the generation of the "struct word_at_a_time *" gets resolved there as data-page relative.  It may well not.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/502044/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor502060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 19:17 UTC (Thu)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/502060/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Then again, if you call it in a loop, those constants are loaded into register before the loop.  But then again, that is probably true for the code with structure as well.  In fact, when compiling hash_name(), with -O2, both versions gave the same result, so the whole thing may be premature optimisation which compiler is capable of handling itself.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/502060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor502067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 19:36 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/502067/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not referring to the cycle cost of generating the constants, but rather the codesize cost.  Even if the constant generation gets hoisted out of the loop, there's still the codesize outside the loop.<br>
<p>
If hash_name() is the only call site for these inlines, then yeah, it's tilting at windmills.  If the inlines start to find use other places, then the savings, while small, may start to add up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/502067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor502068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2012 19:38 UTC (Thu)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/502068/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But that's not how the constants work, or at least not how I understand it. The idea is that each call site will have its own const structure on stack. After all, there's no shared structure anywhere.  If there was, then the functions would not need to have it passed as argument.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/502068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor502103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2012 1:54 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/502103/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <P>Indeed, I had visually glossed over this bit:</P>
<BLOCKQUOTE><I>As will be described in more detail below, this structure contains some useful constant values. The structure is small and the contents are architecture-dependent, so it was evidently <B>deemed unnecessary to create a single, globally-accessible copy.</B></I></BLOCKQUOTE>
<P>Right there in black and white.  Ah well, <I>mea culpa.</I></P>
<P>Still, not every call site will have these constants, but rather the enclosing function or compilation unit.  If the same functions get called multiple times from one outer function or compilation unit, then you have an opportunity for reuse across all those instances.</P>
<P>As I said upthread, though, it does feel a bit like tilting at windmills.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/502103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor502195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2012 17:37 UTC (Fri)
                               by <b>hamjudo</b> (guest, #363)
                              [<a href="/Articles/502195/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Locally generating a copy, means that the copy is in a cache line with related stuff. It actually takes more time to pull in a stale cache line, than to make a fresh copy of something small. Things could really go slowly, if that global copy lived in a cache line with data that was written by another CPUs.<p>
Optimizations get rejected if they make the worst case times even worse, even if they improve the average case.
      
          <div class="CommentReplyButton">
            <form action="/Articles/502195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor502203"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 15, 2012 18:15 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/502203/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>I guess it depends on how the local copy initializer gets implemented.  If the compiler effectively does<TT> memcpy(local, shared_constant_initializer, size)</TT>, then you've gained nothing.</P>
<P>As for a global copy -- it would be in<TT> .rodata </TT>or equivalent.  It would only result in a read miss, and never in "cache line ping" because it would be with other read-only data.  The cost of bringing it in wouldn't be dramatically different than bringing the shared instructions into the instruction cache.  In MESI terms, it could be in E, S or I (just like program code), but never M.  That said, a global copy is unlikely to get optimized away; see below.</P>
<P>All that said, it appears that GCC just turns the struct back into manifest constants.  I threw together what I imagined a string length function might look like (ignoring pointer alignment issues), and the compiler just generated the raw constants without ever storing them to the stack.  So, on x86_64 at least, there's no real difference between passing the struct pointer around and just having manifest constants in the code, it would appear.  The compiler generated identical code for both of these versions:</P>
<PRE>
#define CONSTANTS {0x0101010101010101ul, 0x8080808080808080ul}

struct word_at_a_time
{
    unsigned long one_bits, high_bits;
};

static inline unsigned long has_zero(unsigned long a, unsigned long *bits,
                                     const struct word_at_a_time *c)
{
    unsigned long mask = ((a - c-&gt;one_bits) &amp; ~a) &amp; c-&gt;high_bits;
    *bits = mask;
    return mask;
}

static inline unsigned long prep_zero_mask(unsigned long value,
                                           unsigned long bits,
                                           const struct word_at_a_time *c)
{
    return bits;
}

static inline unsigned long create_zero_mask(unsigned long bits)
{
    bits = (bits - 1) &amp; ~bits;
    return bits &gt;&gt; 7;
}

static inline unsigned int find_zero(unsigned long mask)
{
    return mask*0x0001020304050608ul &gt;&gt; 56;
}

int string_len(char *str)
{
    unsigned long *l_str = (unsigned long *)str;
    unsigned int bytes = 0, zero_byte;
    unsigned long bits;
    const struct word_at_a_time csts = CONSTANTS;

    while (1)
    {
        bits = 0;
        if (has_zero(*l_str, &amp;bits, &amp;csts))
        {
            bits = prep_zero_mask(0, bits, &amp;csts);
            bits = create_zero_mask(bits);
            zero_byte = find_zero(bits);

            return zero_byte + bytes;
        }

        bytes += sizeof(unsigned long);
        l_str++;
    }
}
</PRE>
<P>...and...</P>
<PRE>
static inline unsigned long has_zero(unsigned long a, unsigned long *bits)
{
    unsigned long mask = ((a - 0x0101010101010101ul) &amp; ~a) &amp; 0x8080808080808080ul;
    *bits = mask;
    return mask;
}

static inline unsigned long prep_zero_mask(unsigned long value,
                                           unsigned long bits)
{
    return bits;
}

static inline unsigned long create_zero_mask(unsigned long bits)
{
    bits = (bits - 1) &amp; ~bits;
    return bits &gt;&gt; 7;
}

static inline unsigned int find_zero(unsigned long mask)
{
    return mask*0x0001020304050608ul &gt;&gt; 56;
}

int string_len(char *str)
{
    unsigned long *l_str = (unsigned long *)str;
    unsigned int bytes = 0, zero_byte;
    unsigned long bits;

    while (1)
    {
        bits = 0;
        if (has_zero(*l_str, &amp;bits))
        {
            bits = prep_zero_mask(0, bits);
            bits = create_zero_mask(bits);
            zero_byte = find_zero(bits);

            return zero_byte + bytes;
        }

        bytes += sizeof(unsigned long);
        l_str++;
    }
}
</PRE>
<P>So, whatever benefits the structure abstraction provides aren't in evidence on x86-64, at least with GCC 4.4.5 or 4.6.0.  At least it doesn't slow the code down any.  I guess I'd like to hear more about the intended benefits of this structure (and what platform(s) benefit), since I clearly didn't understand it completely on first examination.</P>
<P>Anyone have a pointer to a thread somewhere that discusses the<TT> struct </TT>and its intended benefits more directly?</P>
<HR>
<P>Compiler output from 4.6.0 with<TT> -O3 -fomit-frame-pointer </TT>for the curious:</P>
<PRE>
string_len:
.LFB4:
    .cfi_startproc
    movq    (%rdi), %rax
    movabsq $-72340172838076673, %r8     ; this is 0xFEFEFEFEFEFEFEFFul
    movabsq $-9187201950435737472, %rsi  ; this is 0x8080808080808080ul
    leaq    (%rax,%r8), %rdx
    notq    %rax
    andq    %rax, %rdx
    xorl    %eax, %eax
    andq    %rsi, %rdx
    jne .L3
    .p2align 4,,10
    .p2align 3
.L5:
    movq    8(%rdi), %rcx
    addl    $8, %eax
    addq    $8, %rdi
    leaq    (%rcx,%r8), %rdx
    notq    %rcx
    andq    %rcx, %rdx
    andq    %rsi, %rdx
    je  .L5
.L3:
    movq    %rdx, %rcx
    subq    $1, %rdx
    notq    %rcx
    andq    %rdx, %rcx
    movabsq $283686952306184, %rdx  ; this is 0x01020304050608ul
    shrq    $7, %rcx
    imulq   %rdx, %rcx
    shrq    $56, %rcx
    addl    %ecx, %eax
    ret
</PRE>
<P>Interestingly,<TT> -O2 -Os -fomit-frame-pointer </TT>generated somewhat different code, but still generated identical code for both versions of the functions:</P>
<PRE>
string_len:
.LFB4:
    .cfi_startproc
    xorl    %edx, %edx
    movabsq $-72340172838076673, %rax    ; this is 0xFEFEFEFEFEFEFEFFul
    movabsq $-9187201950435737472, %rsi  ; this is 0x8080808080808080ul
.L2:
    movq    (%rdi,%rdx), %r8
    movl    %edx, %r9d
    addq    $8, %rdx
    leaq    (%r8,%rax), %rcx
    notq    %r8
    andq    %r8, %rcx
    andq    %rsi, %rcx
    je  .L2
    movq    %rcx, %rax
    decq    %rcx
    movabsq $283686952306184, %rdx  ; this is 0x01020304050608ul
    notq    %rax
    andq    %rcx, %rax
    shrq    $7, %rax
    imulq   %rdx, %rax
    shrq    $56, %rax
    addl    %r9d, %eax
    ret
</PRE>

      
          <div class="CommentReplyButton">
            <form action="/Articles/502203/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor506790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2012 12:26 UTC (Sun)
                               by <b>anomalizer</b> (<b>&#x272D; supporter &#x272D;</b>, #53112)
                              [<a href="/Articles/506790/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can someone illustrate why this might be faster than the simple one byte at a time check? Much of the explanation seems to be around why the obscure code actually works.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor506827"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The word-at-a-time interface</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2012 21:30 UTC (Sun)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/506827/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
fewer, faster commands to execute at the assembly level on the CPU.<br>
<p>
on the surface it seems like this complexity should add cost, but due to the exact details of how the CPUs implement the commands, this more complex method takes fewer cpu cycles to complete.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/506827/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
