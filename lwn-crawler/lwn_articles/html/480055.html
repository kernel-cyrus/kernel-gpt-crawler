        <!DOCTYPE html>
        <html lang="en">
        <head><title>The Android ION memory allocator [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/480055/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/479074/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/480055/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The Android ION memory allocator</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="GAByline">
           <p>February 8, 2012</p>
           <p>This article was contributed by Thomas M. Zeng</p>
           </div>
<p>
Back in December 2011, LWN <a href="http://lwn.net/Articles/472984/">reviewed the list of Android 
kernel patches</a> in the linux-next staging directory. The merging of these drivers, 
one of which is a memory allocator called PMEM, holds the promise that the 
mainline kernel release can one day boot an Android user space. 
Since then, it has become clear
<a href="http://lists.linuxfoundation.org/pipermail/ce-android-mainline/2012-January/000031.html"> 
that PMEM is considered obsolete</a> and  
<a href="http://lists.linuxfoundation.org/pipermail/ce-android-mainline/2012-January/000024.html">
will be replaced by the ION memory manager</a>.
ION is a generalized memory manager that Google introduced in the Android 4.0 
ICS (Ice Cream Sandwich) release to address the issue of
fragmented memory management interfaces across different Android devices. There are at least three, probably more, PMEM-like interfaces. 
On Android devices using NVIDIA Tegra, there is <a href="http://www.spinics.net/lists/linux-tegra/msg00225.html">"NVMAP"</a>; 
on Android devices using TI OMAP, there is <a href="http://processors.wiki.ti.com/index.php/CMEM_Overview">"CMEM"</a>; 
and on Android devices using Qualcomm MSM, there is <a href="https://www.codeaurora.org/gitweb/quic/le/?p=kernel/msm.git;a=commitdiff;h=6aaa69d90a53f169afc5222684f0102356dc39c5">"PMEM" </a>.   
All three SoC vendors  are in the process of switching to ION.   
</p>
This article takes a look at ION, summarizing its interfaces to user space
and to kernel-space drivers. Besides being a memory pool manager, ION also enables its clients to share buffers, 
hence it treads the same ground as <a href="http://lwn.net/Articles/474819/">the 
DMA buffer sharing framework from Linaro</a> (DMABUF). This article will end with a comparison of the two buffer sharing schemes.
</p>
     
<h4>ION heaps </h4>
Like its PMEM-like predecessors, ION manages one or more  memory pools, some of which are set 
aside at boot time to combat fragmentation or to serve special hardware needs. 
GPUs, display controllers, and cameras are some of the hardware blocks that
may have special  memory requirements.
   
ION presents its memory pools as ION heaps. Each type of Android device can be 
provisioned with a different set of ION heaps according to the memory 
requirements of the device.  

The provider of an ION heap must implement the following set of callbacks: 
<pre>
   struct ion_heap_ops {
	int (*allocate) (struct ion_heap *heap,
			 struct ion_buffer *buffer, unsigned long len,
			 unsigned long align, unsigned long flags);
	void (*free) (struct ion_buffer *buffer);
	int (*phys) (struct ion_heap *heap, struct ion_buffer *buffer,
		     ion_phys_addr_t *addr, size_t *len);
	struct scatterlist *(*map_dma) (struct ion_heap *heap,
			 struct ion_buffer *buffer);
	void (*unmap_dma) (struct ion_heap *heap, 
	         struct ion_buffer *buffer);
	void * (*map_kernel) (struct ion_heap *heap, 
	         struct ion_buffer *buffer);
	void (*unmap_kernel) (struct ion_heap *heap, 
	         struct ion_buffer *buffer);
	int (*map_user) (struct ion_heap *heap, struct ion_buffer *buffer,
			 struct vm_area_struct *vma);
   };
</pre>

Briefly, <tt>allocate()</tt> and <tt>free()</tt> obtain or release an <tt>ion_buffer</tt> object from the heap.

A call to <tt>phys()</tt> will return the physical address and length of the buffer, but only for physically-contiguous buffers. 
If the heap does not provide physically contiguous buffers, it does not have to provide this callback. Here <tt>ion_phys_addr_t</tt> 
is a typedef of <tt>unsigned long</tt>, and will, someday,  be replaced by
<tt>phys_addr_t</tt> in <tt>include/linux/types.h</tt>. 

The <tt>map_dma()</tt> and <tt>unmap_dma()</tt> callbacks cause the buffer
to be prepared (or unprepared) for DMA. The <tt>map_kernel()</tt> and
<tt>unmap_kernel()</tt> callbacks map (or unmap) the physical memory into the
kernel virtual address space. A call to <tt>map_user()</tt> will map the
memory to user space. There is no <tt>unmap_user()</tt> because the 
 mapping is represented as a file descriptor in user space. The
closing of that file descriptor will cause the memory to be unmapped from
the calling process.
<p>
The default ION driver (which can be cloned from <a href="https://android.googlesource.com/kernel/common.git">here</a>) offers three heaps as listed below:
<pre>
   ION_HEAP_TYPE_SYSTEM:        memory allocated via vmalloc_user().
   ION_HEAP_TYPE_SYSTEM_CONTIG: memory allocated via kzalloc.
   ION_HEAP_TYPE_CARVEOUT:	carveout memory is physically contiguous and set aside at boot.
</pre> 
Developers may choose to add more ION heaps. For example,
<a href="http://lists.linaro.org/pipermail/linaro-mm-sig/2012-January/001002.html">this NVIDIA patch</a> was 
submitted to add ION_HEAP_TYPE_IOMMU for hardware blocks equipped with an IOMMU.

<h4> Using ION from user space </h4>
Typically, user space device access libraries will use ION to allocate large contiguous media buffers.  
For example, the still camera library
may allocate a capture buffer to be used by the camera device. Once the
buffer is fully populated with video data,
the library can pass the buffer to the kernel 
to be processed by a JPEG encoder hardware block. 
<p>   
A user space C/C++ program must have been granted access to the <tt>/dev/ion</tt> device before 
it can allocate memory from ION.  
A call to  
<tt>open("/dev/ion", O_RDONLY)</tt> returns a file descriptor as a handle representing 
an ION client. Yes, one can allocate writable memory with an <tt>O_RDONLY</tt> open.
There can be no more than one client per user process. To allocate a buffer,
the client needs to fill in all the fields except the <tt>handle</tt> field in 
this data structure:
<pre>
   struct ion_allocation_data {
        size_t len;
        size_t align;
        unsigned int flags;
        struct ion_handle *handle;
   }
</pre>
The <tt>handle</tt> field is the output parameter, while the first three fields specify 
the alignment, length and flags as input parameters. The <tt>flags</tt> field is a bit mask 
indicating one or more ION heaps to allocate from, with the fallback ordered according to which ION heap was 
first added via calls to
<tt>ion_device_add_heap()</tt> during boot.
In the default implementation, <tt>ION_HEAP_TYPE_CARVEOUT</tt> is added
before <tt>ION_HEAP_TYPE_CONTIG</tt>. 
 The flags of <tt>ION_HEAP_TYPE_CONTIG | ION_HEAP_TYPE_CARVEOUT</tt>
indicate the intention to allocate from <tt>ION_HEAP_TYPE_CARVEOUT</tt>
with fallback to <tt>ION_HEAP_TYPE_CONTIG</tt>.
<p>

User-space clients interact with ION using the <tt>ioctl()</tt> system call interface.
To allocate a buffer, the client makes this call: 
<pre>
   int ioctl(int client_fd, ION_IOC_ALLOC, struct ion_allocation_data *allocation_data)
</pre> 
This call returns a buffer represented by <tt>ion_handle</tt> which is not a CPU-accessible 
buffer pointer. The handle can only  be used to obtain a file descriptor for buffer 
sharing as follows:
<pre>
   int ioctl(int client_fd, ION_IOC_SHARE, struct ion_fd_data *fd_data);
</pre>
Here <tt>client_fd</tt> is the file descriptor corresponding to
<tt>/dev/ion</tt>,  and 
<tt>fd_data</tt> is a data structure with an input <tt>handle</tt> field and an output <tt>fd</tt> field, as defined below:
<pre>
   struct ion_fd_data {
        struct ion_handle *handle;
        int fd;
   }
</pre>

The <tt>fd</tt> field is the file descriptor that can be 
passed around for sharing. On Android devices the <tt>BINDER</tt> IPC mechanism 
may be used to send <tt>fd</tt> to another process for sharing.
To obtain the shared buffer, the second user process must obtain 
a client handle first via the <tt>open("/dev/ion", O_RDONLY)</tt> system call. 
ION tracks its user space clients by the PID of the process (specifically, the PID
of the thread that is the "group leader" in the process).   Repeating the 
<tt>open("/dev/ion", O_RDONLY)</tt> call in the same process will get back 
another file descriptor corresponding to the same client structure in 
the kernel. 
<p>
To free the buffer, the second client needs to undo the effect of <tt>mmap()</tt> with a
call to <tt>munmap()</tt>, and the first client needs to close the file descriptor it obtained
via <tt>ION_IOC_SHARE</tt>, and call <tt>ION_IOC_FREE</tt> as follows:
<pre>
     int ioctl(int client_fd, ION_IOC_FREE, struct ion_handle_data *handle_data);
</pre>
Here <tt>ion_handle_data</tt> holds the handle as shown below:
<pre>
     struct ion_handle_data {
	     struct ion_handle *handle;
     }
</pre>
The <tt>ION_IOC_FREE</tt> command causes the handle's reference counter 
to be decremented by one. When this reference counter reaches zero, the <tt>ion_handle</tt> object
gets destroyed and the affected ION bookkeeping data structure is updated. 


<p>
User processes can also share ION buffers with a kernel driver, as explained
in the next section. 
<p>

<h4>Sharing ION buffers in the kernel</h4>
<p>
In the kernel, ION supports multiple clients, one for each driver that uses the ION functionality.

A kernel driver calls the following function to obtain an ION client handle:   
<p>
<pre>
   struct ion_client *ion_client_create(struct ion_device *dev, 
                   unsigned int heap_mask, const char *debug_name)
</pre>
<p>
The first argument, <tt>dev</tt>, is the global ION device associated with  
<tt>/dev/ion</tt>; why a global device is needed, and why it must be passed
as a parameter, is not entirely clear. The second argument,
<tt>heap_mask</tt>, selects one or more ION heaps 
in the same way as the <tt>ion_allocation_data.
The flags</tt> field was covered in the previous section.

For smart phone use cases involving multimedia middleware, 
the user process typically allocates the buffer from ION, obtains a file descriptor using 
the <tt>ION_IOC_SHARE</tt> command, then passes the file desciptor to a
kernel driver. 
The kernel driver calls 
<tt>ion_import_fd()</tt> which converts the file descriptor to an <tt>ion_handle</tt> object,
as shown below: 
<pre>
    struct ion_handle *ion_import_fd(struct ion_client *client, int fd_from_user);
</pre>
The <tt>ion_handle</tt> object is the driver's client-local reference to
the shared buffer. The
<tt>ion_import_fd()</tt> call looks up the physical address of the buffer to see whether the client
has obtained a handle to the same buffer before, and if it has, this call simply increments
the reference counter of the existing handle.  
<p>
Some hardware blocks can only operate on physically-contiguous buffers with
physical addresses, so 
affected drivers need to convert <tt>ion_handle</tt> to a physical buffer via this call:
<pre>
   int ion_phys(struct ion_client *client, struct ion_handle *handle,
	       ion_phys_addr_t *addr, size_t *len)
</pre>
<p>
Needless to say, if the buffer is not physically contiguous, this call will
fail.
<p>
When handling calls from a client, ION always validates 
the input file descriptor, client and handle arguments. For example, when importing a file descriptor, ION
ensures the file descriptor was indeed created by an <tt>ION_IOC_SHARE</tt> 
command.
When <tt>ion_phys()</tt> is called, ION validates whether the buffer handle belongs to the list of handles 
the client is allowed to access, and returns error if the handle is not on the list.
This validation mechanism reduces the likelihood of unwanted accesses and inadvertent resource 
leaks. 
<p>
 ION provides debug visibility through <tt>debugfs</tt>. It organizes debug information under <tt>/sys/kernel/debug/ion</tt>,
with bookkeeping information in stored files associated with heaps and
clients identified by symbolic names or PIDs.  
<p>
<h4>Comparing ION  and DMABUF</h4>
<P>
ION and DMABUF share some common concepts. The <a href="http://lwn.net/Articles/474819/"><tt>dma_buf</tt> concept</a>
 is similar to <tt>ion_buffer</tt>, while <tt>dma_buf_attachment</tt>
 serves a similar
purpose as <tt>ion_handle</tt>. Both ION and DMABUF use anonymous file descriptors
as the objects that can be passed around to provide reference-counted access to shared buffers.

On the other hand, ION focuses on allocating and freeing memory from provisioned 
memory pools in a manner that can be shared and tracked, while DMABUF focuses 
more on buffer importing, exporting and synchronization in a manner that is consistent with buffer sharing
solutions on non-ARM architectures.

<p>
The following table presents a feature comparison between ION and DMABUF:

<p>
<table cellpadding="4">
<tr>
<th>  Feature</th>
<th> ION </th>
<th> DMABUF </th>
</tr>
<tr class="Odd">
<td> Memory Manager Role </td>
<td> ION replaces PMEM as the manager of provisioned memory pools. 
The list of ION heaps can be extended per device. </td>
<td> DMABUF is a buffer sharing framework, 
designed to integrate with the memory allocators in DMA mapping frameworks, like the work-in-progress DMA-contiguous allocator, also known as the  
<a href="http://lwn.net/Articles/450286/"> Contiguous Memory 
Allocator</a> (CMA). DMABUF exporters have the option to implement custom allocators. </td>
</tr>
<tr class="Even">
<td> User Space Access Control  </td>
<td> ION offers the <tt>/dev/ion</tt> interface for user-space programs to allocate and share buffers. 
Any user program with ION access can cripple the system by depleting the ION heaps. Android 
checks user and group IDs to block unauthorized access to ION heaps. </td>
<td> DMABUF offers only kernel APIs. Access control is a function of the permissions on the devices using the DMABUF feature. </td>
</tr>
<tr class="Odd">
<td> Global Client and Buffer Database </td>
<td> ION contains a device driver associated with <tt>/dev/ion</tt>. The device structure contains a database that tracks the allocated ION buffers, 
handles and file descriptors, all grouped by user clients and kernel clients. ION validates all client calls according to the rules of the database. 
For example, there is a rule that a client cannot have two handles to the same buffer. </td>
<td>  The <a href="http://lxr.linux.no/linux+v3.2.2/lib/dma-debug.c"> DMA debug facility </a> 
implements a global hashtable, <tt>dma_entry_hash</tt>, to track DMA buffers, but only when the kernel was built with the <tt>CONFIG_DMA_API_DEBUG</tt> option. </td> 
</tr>
<tr class="Even">
<td> Cross-architecture Usage</td>
<td> ION usage today is limited to architectures that run the Android kernel. </td>
<td> DMABUF usage is cross-architecture. 
The <a href="http://lists.linaro.org/pipermail/linaro-mm-sig/2011-December/000902.html">DMA mapping redesign preparation patchset</a> modified the DMA mapping code in 9 architectures besides the ARM architecture.  </td>
</tr>
<tr class="Odd"> 
<td> Buffer Synchronization </td>
<td> ION considers buffer synchronization to be an orthogonal problem.  </td>
<td> DMABUF provides a pair of APIs for synchronization. The buffer-user calls
<tt>dma_buf_map_attachment()</tt> whenever it wants to use the buffer for DMA . Once the DMA for the current buffer-user is over, 
it signals 'end-of-DMA' to the exporter via a call to <tt>dma_buf_unmap_attachment() </tt>. </td>
</tr>

<tr class="Even">
<td> Delayed Buffer Allocation </td>
<td> ION allocates the physical memory before the buffer is shared. </td>
<td> DMABUF can defer the allocation 
until  the first call to  <tt>dma_buf_map_attachment()</tt>. The exporter of DMA buffer has 
the opportunity to scan all client attachments, collate their buffer constraints, then choose 
the appropriate backing storage. 
 </td>
</tr>

</table>
<p>
ION and DMABUF can be separately integrated into multimedia applications written using 
<a href="http://lwn.net/Articles/203924/">the Video4Linux2 API</a>.
In the case of ION, these multimedia
programs tend to use PMEM now on Android devices, so switching to ION from PMEM should have a
relatively small impact. 
<p>
Integrating DMABUF into Video4Linux2 is another story.
It has taken  
<a
href="http://lists.linaro.org/pipermail/linaro-mm-sig/2012-January/001040.html">ten
patches</a> to integrate the <tt>videobuf2</tt> mechanism with DMABUF; in
fairness, many of these revisions were the result of changes to DMABUF as
that interface stabilized. 
The effort should pay dividends in the long run because the DMABUF-based 
sharing mechanism is designed with DMA mapping hooks for CMA and IOMMU. 
CMA and IOMMU hold the promise to reduce the amount of carveout memory that it takes to build an Android smart phone. 
In <a href="http://lists.linaro.org/pipermail/linaro-mm-sig/2012-January/001132.html">this email</a>, 
Andrew Morton was urging the completion of the patch review process so that CMA can get through the 3.4 merge window.

<p>
Even though ION and DMABUF serve similar purposes, the two are not mutually exclusive.
The Linaro Unified Memory Management team has started <a href="https://blueprints.launchpad.net/linaro-mm-sig/+spec/linaro-mmwg-cma-ion"> to integrate CMA into ION.</a>
To reach the state where a release of the mainline kernel can boot the Android user space, the <tt>/dev/ion</tt> interface to user space must obviously be preserved.
In the kernel though, ION drivers may be able to use
some of the DMABUF APIs to hook into CMA and IOMMU to take advantage
of the capabilities offered by those subsystems. Conversely, DMABUF might be able to leverage ION to present a unified interface to user space, 
especially to the Android user space. 
DMABUF may also benefit from adopting some of the ION heap debugging features in order to become more developer friendly.
Thus far, many signs indicate that Linaro, Google, and the kernel community are working together to bring the combined strength of ION and DMABUF to the mainline kernel.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Android">Android</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Device_drivers-Support_APIs">Device drivers/Support APIs</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#ION">ION</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Large_allocations">Memory management/Large allocations</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Zeng_Thomas_M.">Zeng, Thomas M.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/480055/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor480197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Android ION memory allocator</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 9, 2012 9:31 UTC (Thu)
                               by <b>blackwood</b> (guest, #44174)
                              [<a href="/Articles/480197/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Small correction on the dma_buf attach/detach functions: They're just used to reconfigure the pipeline - the exporter is allowed to delay the allocation up to map time and needs to because only by then all devices will be attached. Similarly it's map/unmap that should enforce cache coherency and synchronization and not attach/detach. We'll likely add an extension to allow streaming dma with persistent device mappings.<br>
<p>
Also note that map/unmap doesn't synchronize hw access in the sense of gl sync objects. Imo that's an orthogonal issue to buffer sharing and dma buffer allocation. But something we might need to support in the kernel, too, because some SoC have hw-based semaphores and mailboxes to sync up different blocks without the cpu being woken up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/480197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482876"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Android ION memory allocator</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2012 1:42 UTC (Wed)
                               by <b>zengtm</b> (guest, #74989)
                              [<a href="/Articles/482876/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the article it does say that map/unmap is the place to handle cache coherency and buffer synchronization. Did I have wording to indicate attach/detach is for synchronization?<br>
<p>
And I agree that the persistent device mappings seem to be the more common smart phone use cases. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482876/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor480781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Integration with dma_buf</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2012 16:24 UTC (Sat)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/480781/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It should not be too hard to modify the ion code so it becomes a provider of dma_buf file descriptors and integrates into that framework.<br>
<p>
When we discussed the design for dma_buf, it was intentionally made possible to have arbitrary subsystems provide interfaces that hand out dma_buf file descriptors to user space, although the focus so far was on having drm provide descriptors for buffers that it already manages. If I understand the article correctly, the design of ion is that you always have to know in advance how to allocate your buffer through the ion ioctl but then can pass it into any driver using it.<br>
<p>
We should probably look into unifying the in-kernel interfaces for the two, because they are already very similar. and make ION_IOC_SHARE return a dma_buf descriptor that can be passed into any dma_buf enabled driver. The ion_import_fd function can then be replaced with the more abstract dma_buf equivalent.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/480781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482877"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Integration with dma_buf</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 22, 2012 1:44 UTC (Wed)
                               by <b>zengtm</b> (guest, #74989)
                              [<a href="/Articles/482877/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"the design of ion is that you always have to know in advance how to allocate your buffer": the answer is yes, based on the ION implementations that I have the chance to study in the current Android 4.0.x release. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482877/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor551130"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Integration with dma_buf</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 19, 2013 6:54 UTC (Sun)
                               by <b>abai</b> (guest, #91041)
                              [<a href="/Articles/551130/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If user space change the ion memory content, how to flush cache to memery in user space?<br>
I see ION_IOC_SYNC only used for kernel space, it cannot flush user cache, right?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551130/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor484535"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Android ION memory allocator</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 29, 2012 20:43 UTC (Wed)
                               by <b>cliveb</b> (guest, #83236)
                              [<a href="/Articles/484535/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How can I get a physical address for the allocated memory from user space?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/484535/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor486429"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Android ION memory allocator</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2012 17:01 UTC (Wed)
                               by <b>zengtm</b> (guest, #74989)
                              [<a href="/Articles/486429/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You cannot get physical address from user space: not secure if you think about it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/486429/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor531472"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Android ION memory allocator</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 4, 2013 13:29 UTC (Fri)
                               by <b>vkkashyap</b> (guest, #88623)
                              [<a href="/Articles/531472/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for nice article.<br>
<p>
- What type of security risks do you foresee?<br>
- Any other reason(s) you see for limiting physical addresses api to kernel space?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/531472/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor693392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Android ION memory allocator</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2016 0:37 UTC (Tue)
                               by <b>simonwan</b> (guest, #109625)
                              [<a href="/Articles/693392/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the article, it's really helpful for me to understand the ION. <br>
<p>
Now I'm writing one simple test program for better understanding the ION device but I always got error -19 when I was trying to allocate the memory. Do you meet this error before? <br>
<p>
I'm considering this is caused by missing permission but I'm not sure. I noticed that the article mentioned that the program should be granted the permission before allocating but I don't know how to do this, could you give me some advice?<br>
<p>
Thank you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/693392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor693417"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Android ION memory allocator</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 5, 2016 13:24 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/693417/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The only necessary permission should be read access to /dev/ion, and if you didn't have that permission you wouldn't even be able to open the device.<br>
<p>
Error -19 is -ENODEV, and I think ion_alloc can only return that if there are no heaps that match the heap_id_mask in your allocation request, so you should check you're setting that correctly. /sys/kernel/debug/ion/heaps/ should list the heaps available on your device (though you probably need to read the kernel headers to find the enum definitions for them).<br>
<p>
Also check that you're calling the right version of the kernel API - lots of details have changed since this article was written (e.g. the heap mask is now a separate field in ion_allocation_data, not part of flags), so you should use libion or read the kernel source from your particular device.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/693417/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor693500"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Android ION memory allocator</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2016 0:59 UTC (Wed)
                               by <b>simonwan</b> (guest, #109625)
                              [<a href="/Articles/693500/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi excors,<br>
 <br>
Thank you for the reply. I tested the program on Android and I checked the /ion/heaps while I get the results as "adsp, audio, kmalloc, mm, qsecom, system" but I don't know where I could find the enum definitions, could you please give me some advice?<br>
<p>
Sincerely,<br>
Simon<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/693500/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor693585"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Android ION memory allocator</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2016 17:39 UTC (Wed)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/693585/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>That looks like a Qualcomm device, so I think you want the ion_heap_ids from <a href="https://android.googlesource.com/kernel/msm/+/android-6.0.1_r0.74/drivers/staging/android/uapi/linux/msm_ion.h">msm_ion.h</a>

<p>(The definitions might vary on different versions and different devices - ideally you should find the kernel source for your specific device. Probably most similar-generation Qualcomm devices will be compatible, though.)

<p>If you're using <a href="https://android.googlesource.com/platform/system/core/+/master/libion/include/ion/ion.h">libion</a>, call ion_alloc with heap_mask set to e.g. (1 &lt;&lt; ION_SYSTEM_HEAP_ID) to use the system heap. (If you're not using libion, look at its implementation to see how to call the ioctls directly.)

<p>If you want to share the ion buffer with non-CPU bits of hardware (e.g. the GPU or camera), you might need to use one of the other heaps, but the restrictions are not documented anywhere so you'll have to guess.

<p>On non-Qualcomm devices, you might need to set heap_mask to e.g. (1 &lt;&lt; ION_HEAP_TYPE_SYSTEM) instead, because some other vendors use those HEAP_TYPE enums as the heap IDs instead of inventing a whole new set of IDs - there are no common standards here. The heap configuration is either hard-coded into the kernel source or loaded from Device Tree, so you'll have to look there if you want to find out the details for other devices.
      
          <div class="CommentReplyButton">
            <form action="/Articles/693585/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor708614"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Android ION memory allocator</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2016 12:17 UTC (Fri)
                               by <b>avi141</b> (guest, #112868)
                              [<a href="/Articles/708614/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hi!<br>
<p>
From memory statistics side, i wish to know how many pages are allocated for ion memory.<br>
In structure(ion_buffer) there is a member variable 'pages' , <br>
<p>
Did it hold all pages allocated for ion memory ; and after iterating list we will get exhaustive list of pages for ion memory in system ?<br>
Please guide if any one tried it ; or if understanding is correct.<br>
===========================================<br>
<p>
struct page **pages;<br>
<p>
63 * @pages:		flat array of pages in the buffer -- used by fault<br>
64 *			handler and only valid for buffers that are faulted in<br>
71*/<br>
<p>
72struct ion_buffer {<br>
73	struct kref ref;<br>
74	union {<br>
75		struct rb_node node;<br>
76		struct list_head list;<br>
77	};<br>
78	struct ion_device *dev;<br>
79	struct ion_heap *heap;<br>
80	unsigned long flags;<br>
81	unsigned long private_flags;<br>
82	size_t size;<br>
83	union {<br>
84		void *priv_virt;<br>
85		ion_phys_addr_t priv_phys;<br>
86	};<br>
87	struct mutex lock;<br>
88	int kmap_cnt;<br>
89	void *vaddr;<br>
90	struct sg_table *sg_table;<br>
91	struct page **pages;<br>
92	struct list_head vmas;<br>
93	/* used to track orphaned buffers */<br>
94	int handle_count;<br>
95	char task_comm[TASK_COMM_LEN];<br>
96	pid_t pid;<br>
97};<br>
=========================================<br>
<p>
Regards,<br>
Avinash Jain<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/708614/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
