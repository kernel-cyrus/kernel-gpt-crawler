        <!DOCTYPE html>
        <html lang="en">
        <head><title>Three ways to rework the swap subsystem [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/1016136/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/1016367/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/1016136/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Three ways to rework the swap subsystem</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 7, 2025</br>
           <hr>
<a href="/Articles/lsfmmbpf2025/">LSFMM+BPF</a>
</div>
The kernel's swap subsystem is complex and highly optimized — though not
always optimized for today's workloads.  In three adjacent sessions during
the memory-management track of the 2025 Linux Storage, Filesystem,
Memory-Management, and BPF Summit, Kairui Song, Nhat Pham, and Usama Arif
all talked about some of the problems that they are trying to solve in the
Linux swap subsystem.  In the first two cases, the solutions take the form of
an additional layer of indirection in the kernel's swap map; the third,
which enables swap-in of large folios, may or may not be worthwhile in the
end. 

<p>
<h4>Simplifying the swap subsystem</h4>
<p>
There are some good things about the kernel's swapping code, Song began.
Since swapping is done to make memory available to the kernel, it must use
as little memory as possible itself; the swap code manages to get by with a
single byte of overhead per page of swap space.  Most swapping operations
are fast and lightweight; swap entries point directly to physical
locations.  The per-CPU swap-cluster design manages to avoid contention in
almost all cases.
<p>
<!-- middle-ad -->
On the other hand, the swap system is complex.  To show just how complex,
Song put up this slide:
<p>
<blockquote>
<a href="/Articles/1016242/#slide">
<img src="https://static.lwn.net/images/conf/2025/lsfmm/KairuiSong-slide1.jpg" alt="[Swap system
diagram]" width=2311 class="photo border=0"></a>
</blockquote>
<p>
There are a lot of components with complex interactions, he said.  New
features are hard to add to this subsystem; the long (and ongoing) effort
to add swapping for multi-size transparent huge pages (mTHPs) is one case
in point.  The whole thing is built around the one-byte-per-page design for
the swap map, meaning that there is no space to store anything beyond a
reference count and a pair of flags.  Various optimizations have been
bolted on over the years, increasing the complexity of the system.
<p>
<a href="/Articles/1016242/"><img
src="https://static.lwn.net/images/conf/2025/lsfmm/KairuiSong-sm.png" alt="[Kairui Song]"
title="Kairui Song" class="rthumb"></a>

As an example, he mentioned the <tt>SWP_SYNCHRONOUS_IO</tt> optimization,
which was <strike><a href="https://git.kernel.org/linus/1dd44c0af4fa">added to
6.14</a> by Baolin Wang</strike> <a href="https://git.kernel.org/linus/0bcac06f27d">added in 4.15</a> by
Minchan Kim.  When the kernel is swapping from a fast,
memory-based device like <a
href="https://docs.kernel.org/admin-guide/blockdev/zram.html">zram</a>, any
extra latency hurts; in such cases, the kernel can simply bypass most of
the swapping machinery and copy the data directly, preserving larger folios
as well.  Song said that this is a nice optimization, but there are now
four different ways to bring in a folio from swap.  He has tried to unify
them all, but that work failed due to performance regressions.
<p>
The distinction between the swap map and the swap cache adds complexity as
well.  The swap map is the one-byte-per-slot array that tracks the usage of
swap slots in a swap device.  It is a global resource, requiring locking
for access, so it can be a contention point on systems that are doing a lot
of swapping.  The swap cache, instead, is a <strike>per-CPU</strike> data structure that
holds a set of swap slots allocated in bulk from the swap map; it allows
many swap-related actions to be done locklessly, and enables batching of
swap-map changes when a lock must be taken.  When a swap-map entry is in
some CPU's cache, the <tt>SWAP_HAS_CACHE</tt> bit is set in the swap map to
indicate that some CPU owns the entry.  But, Song
said, that bit has acquired other meanings over time, again making it
harder to make changes to the swap machinery.
<p>
Any redesign of this system, he said, is destined to use more memory; the
one-byte design of the swap map just does not allow for much flexibility.
There is, however, memory that could be used for this purpose.  The swap
cache currently uses eight bytes per slot, and control groups can add
another two (duplicating some data in the process), so the actual memory
consumption for swapping can be eleven bytes per slot.  If that memory were
to be repurposed, the swap map could be transformed into a "swap table" with
eight bytes per entry, which would be enough for everything that he has in
mind.  Swap entries would still be managed in clusters, he said, and the
total memory use of the swap subsystem should drop as some of the existing
complexity is removed.
<p>
Song's proposed layout for this swap table (taken from <a
href="/ml/all/CAMgjq7BvQ0ZXvyLGp2YP96+i+6COCBBJCYmjXHGBnfisCAb8VA@mail.gmail.com/">his
proposal for the session</a>) looks like this:
<p>
<pre>
    | -----------    0    ------------| - Empty slot
    | SWAP_COUNT |---- Shadow ----|XX1| - Swapped out
    | SWAP_COUNT |------ PFN -----|X10| - Cached
    |----------- Pointer ---------|100| - Reserved / Unused yet
</pre>
<p>
There would be a table for each swap cluster, spreading out the accesses
and mostly eliminating locking contention; that, in turn, should allow the
elimination of the separate swap cache.  The eight-bit <tt>SWAP_COUNT</tt>
is the same reference count that is kept in the current swap map, but it no
longer needs to dedicate a couple of bits to flags like
<tt>SWAP_HAS_CACHE</tt>.  This design, he says, resolves many of the
problems with the current swapping subsystem, and performs better as well,
yielding a 10-20% improvement in the all-important kernel-build benchmark.
There is only one swap-in path, and it never bypasses the table.  Memory
usage is lower, he said, and this design allows for the removal of a lot of
complexity from the swap subsystem.
<p>
A participant asked how the new design could be faster in the absence of
the bypassing optimization currently used for zram.  The answer was that the
unification of the swap map and the swap cache means that there is no need
to check or maintain both, making the swap subsystem as a whole faster.
<p>
Future steps, Song said, include the addition of a virtual swap device that
has no storage associated with it.  Instead, it contains only entries
pointing to slots in other swap devices.  This new layer of indirection is
intended to facilitate the intact swapping of larger folios, which
currently becomes difficult when the swap devices become fragmented.  The
virtual device could be much larger than the physical swap space, making it
resistant to fragmentation.
<p>
Time was running out, so Song concluded with an idea to consider further in
the future: swap migration.  The list of swap clusters already works as a
sort of least-recently-used (LRU) list, he said, so it could be used as a way of
detecting folios that have been swapped out for a long time so that they could
be moved to cheaper storage.  Perhaps compaction could be performed at the
same time.  There was no time for the discussion of this idea, though.
<p>
<h4>Virtual swap devices</h4>
<p>
The concept of a virtual swap device returned in the next session, though,
as the topic that Pham wanted to talk about.  His original motivation, he
said, was to separate the <a
href="https://docs.kernel.org/admin-guide/mm/zswap.html">zswap</a>
compressed swap cache from the rest of the swap subsystem.  There is heavy
use of zswap at his employer (Meta), which is good, but the current design
of the swap layer requires that there be a slot assigned in an on-disk swap
device for every page that is stored in zswap.  That disk space will never
be used and is thus entirely wasted; he has seen hosts running with an
entirely unused, 100GB swap file.  In an environment where hosts can have
terabytes of installed RAM, it just is not possible to attach (and waste)
sufficiently large drives for swap files.
<p>

<a href="/Articles/1016252/"><img
src="https://static.lwn.net/images/conf/2025/lsfmm/NhatPham-sm.png" alt="[Nhat Pham]"
title="Nhat Pham" class="rthumb"></a>

Once a swap area has been added to the system, its size is fixed; the only
way to increase swap space is to add another swap area.  That is a slow
operation, though, that a heavily loaded production system cannot afford,
so Meta has to provision a suitably sized swap file ahead of time for each
host type.  There have been ongoing problems with machines running out of
memory just because the unused swap device is "full".  Pham appeared to be
of the opinion that this was not an optimal way to run things.
<p>
The problem, he said, is the tight coupling between swapped pages and
the backing store behind them.  The page-table entry for a swapped page
points to the physical location for its data.  It is, he said, a design
oriented toward the sort of two-tier swapping system that was common some
time ago.  Beyond capacity problems, this design leads to other
challenges; if, for example, zswap rejects a page, its page-table entry has
already been changed and recovery is difficult.
<p>
Solving this problem, he said, requires decoupling the various swap
backends.  A page stored in zswap should not take space in the other
backends — unless that has been dictated by policy, as can happen with
write-through caching.  The system needs to be able to support multi-tier
swapping; that would also help with the addition of new features, such as
discontiguous swap-space allocation for large folios, or swapping in folios
at different sizes than they were at swap-out time.
<p>
Thus, he is proposing the implementation of a virtualized swap subsystem,
providing swap space that is independent of whichever backend any given
page is stored to.  Each swapped-out page is assigned a virtual slot; that
is what is stored in the page-table entry.  Virtual slots can then be
resolved to a specific backing store as needed, where that backing store
could be zswap, a disk drive, a cache like zram, or something else.  Such a
system would eliminate the wasted space problem and allow pages to be moved
between backends without having to change all of the references to them.
That would make it easy for zswap to write pages back to another device,
for example; it would also make removing a swap device much easier than it
is now.
<p>
He has a working prototype now, he said, that adds two new swap maps.
There is a forward map that turns a virtual swap slot into a swap
descriptor describing the actual placement of a page; it uses the <a
href="/Articles/745073/">XArray</a> data structure, so lookups are
lockless.  The reverse map turns a physical swap slot into a virtual slot;
that is useful to support cluster readahead or the movement of pages
between backends.  The metadata for a swapped page is placed in a
dynamically allocated swap descriptor that is stored in the forward map.
<p>
The prototype is getting close to the point where he can post it, he said.
It is a big change, though, and he is worried about how he will be able to
land it.  Johannes Weiner suggested that it could perhaps operate in
parallel with the existing swap subsystem until the performance is shown to
be at least as good.
<p>
At the end, a participant asked whether this system would be able to swap
in a single page from a larger folio that has been swapped out; Pham said
that he has considered that use in the design.  Matthew Wilcox asked
whether the virtual swap space would be used sparsely or densely; Pham,
like Song, said that a large, sparse virtual space would be better for
fragmentation avoidance.
<p>
Pham has posted <a
href="https://drive.google.com/file/d/1mn2kSczvEzwq7j55iKhVB3SP67Qy4KU2/view">the
slides from this session</a>.

<p>
<h4>Large-folio swap-in</h4>
<p>
The final episode of the swapping trilogy began with Arif reminding the
crowd of the advantages of using large folios.  They allow for better
translation lookaside buffer (TLB) usage, reduce the number of page faults
the system must handle, shorten LRU lists, and allow page-table entries to
be manipulated in batches.  Large folios often do not survive their
encounter with the swap subsystem, though; they end up being split into
base pages.  Arif was there to talk about how the swap subsystem might be
improved to better handle larger folios.
<p>
<a href="/Articles/1016253/"><img
src="https://static.lwn.net/images/conf/2025/lsfmm/UsamaArif-sm.png" alt="[Usama Arif]"
title="Usama Arif" class="rthumb"></a>

He mentioned work done by Ryan Roberts around a year ago to enable swapping
out mTHPs without splitting them.  That helped to avoid the cost of
splitting these folios and avoid the fragmentation of memory.  Work has
been done to store large folios to zswap, and to be able to bring in large
folios from zram.  Compression of large folios in zram (which yields better
compression) is being worked on, but has not been merged yet.  One problem
with compressing large folios, though, is that swapping in a single base
page from that folio becomes difficult — the entire folio must be
decompressed to make that base page accessible.
<p>
Arif's large-folio swap-in work builds on these previous efforts.
Specifically, at swap-in time, it checks to see whether the swap count is
one (meaning there is a single reference to the page) and whether the page
is in zswap.  If so, the swap cache is skipped entirely, and zswap will be
checked to see if it holds a larger folio containing the page in question.
If so, the folio will be swapped in one page at a time and assembled into a
proper folio at the end.
<p>
This patch speeds 1MB folio swap-in by 36%, but also slows kernel builds.
It resulted in an overall increase in zswap activity, with a lot of
thrashing and folios being swapped in and out repeatedly.  Thus, he
concluded, perhaps large folios are not good for all workloads; would the
group be happy with a change that yielded such different results for
different workloads?  Some workloads benefit; Android, for example, swaps
out background tasks entirely and does not see this performance regression.
Perhaps a control knob could be provided to tell the system whether to swap
in large folios from zswap, but most users never change these knobs and
would not see the benefit.  Perhaps this behavior could be switched off
automatically if the refault rate is seen as being too high.
<p>
Another alternative would be to combine large-folio swapping with
large-folio compression; that might offset the regression with kernel
builds, he said.  But the inability to swap in base pages out of large
folios could get in the way here.
<p>
As the session ran down, he wondered if there was a need for large-folio
swap-in at all.  Perhaps the system should continue to swap in base pages
and let the <tt>khugepaged</tt> thread reassemble larger folios afterward.
Wilcox said that there is a need to gather more statistics to understand
what is really going on here.  At this point, the topic was swapped out for
something entirely different.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Swapping">Memory management/Swapping</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_Memory-Management_and_BPF_Summit-2025">Storage, Filesystem, Memory-Management and BPF Summit/2025</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/1016136/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor1016703"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New swap architecture</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2025 15:14 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/1016703/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't suppose you have a photo of Kairui's new architecture slide? IIRC it went from 13 boxes to 5. I almost fell out of my chair when I saw that. Let's get that merged soon!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016703/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1016704"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">New swap architecture</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2025 15:18 UTC (Mon)
                               by <b>brauner</b> (subscriber, #109349)
                              [<a href="/Articles/1016704/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is that slide here in the article meant to be the visual counterpart to memory-model.rst if the children cannot yet read?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016704/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1016705"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">&quot;After&quot; photo</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2025 15:27 UTC (Mon)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/1016705/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I did take a photo, yes, but obviously didn't work it into the article; perhaps I should have.  In any case, it's now <a href="/Articles/1016242/#after">on the photo page</a> for the curious.


      
          <div class="CommentReplyButton">
            <form action="/Articles/1016705/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1016710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Swap across multiple storage hardware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2025 18:09 UTC (Mon)
                               by <b>aeden</b> (subscriber, #116597)
                              [<a href="/Articles/1016710/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Recently I posed the following question: suppose a system has three distinct NVME SSDs. Should I create a swap partition on each device and `swapon` all of them (i.e. /dev/nvme), or should I create a mdadm RAID0 across those three swap devices and then `swapon` _that_ (i.e. /dev/md0). It seems the current best strategy's is the latter, since it looks like the swap devices are handled in a dumb way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Swap across multiple storage hardware</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 14:51 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/1017108/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To the best of my knowledge, (by default) swap is allocated a priority based on its order in fstab. So you should list devices in order of speed.<br>
<p>
Or you can explicitly assign a priority to each, and the kernel will stripe (aka create a raid-0) across all devices of equal priority. So no, actually creating your own raid-0 is not a good idea.<br>
<p>
The other thing is there's two types of raid-0 - there's the striping you're thinking of, and there's sequential (which iirc is what swap does by default) where raid will fill one device before moving on to the next.<br>
<p>
The only time raid'ing swap makes sense is if you do a raid-1, so the system is hardened against swap-device-failure.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1016713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CONFIG_SWAP_SMALL with refcount max 8?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2025 18:48 UTC (Mon)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/1016713/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;The whole thing is built around the one-byte-per-page design for the swap map, meaning that there is no space to store anything beyond a reference count and a pair of flags.</span><br>
<p>
6 bits for the reference count? Did they collect stats to show they need all 6? Can we get by with 3 bits for the table, 2 flags and 3 bits for the refcount?<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1016714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">CONFIG_SWAP_SMALL with refcount max 8?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2025 19:08 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/1016714/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If there are more than 63 references to a swap page, another page full of bytes is allocated to store the high bits. After 4095, a third page is allocated, and so on.<br>
<p>
Yes, this is stupid. No, it rarely happens.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1016721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2025 21:39 UTC (Mon)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/1016721/">Link</a>] (37 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've seen these “let's make swap faster” posts for LWN for many years now, but… it doesn't actually match the reality I'm seeing? On any kind of system, be it laptop or desktop or server, blazing-fast NVMe or HDD, once anything really starts swapping, the machine is unusable for me; I have to spend minutes frantically trying to get a killall through. (Thankfully the OOM killer is much better at finding the right target than it used to be!) It's perfectly fine for “slow” swapping (basically of initialized but not really used memory in a daemon or something), but for anything involving significant churn, I feel very disconnected from the reality in all these presentations.<br>
<p>
Is it something that's going to be radically better in, say, five years?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1016726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2025 0:03 UTC (Tue)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/1016726/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That situation happens for me too, even with no swap, only zram. Presumably it would happen even without any kind of swap too, because the issue is probably due to constantly paging in binaries from disk as they run?<br>
<p>
Probably there isn't any easy way to prevent this, but it could be mitigated if systemd could lock into RAM itself and everything needed for a rescue login console, the files needed for a VT switch, login, a root shell session and command-line and interactive tools needed to find and kill processes, so that when it happens I can instantly kill offending processes using all my RAM. Debian has a memlockd package for this, but it doesn't seem to help any more unfortunately. Perhaps the systemd folks can come up with a better design and or maintain it better.<br>
<p>
Another thing that could help is being able to automatically shut down more systemd user/system services when memory pressure begins to build, IIRC this is implemented, but probably not widespread within service configs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1016735"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2025 10:02 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/1016735/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; lock into RAM itself and everything needed for a rescue login console, the files needed for a VT switch, login, a root shell session</span><br>
<p>
This is, I suspect, more or less what Solaris had decades ago to protect emergency access in the case of a swap storm. I don't know the details unfortunately - but it had some kind of mechanism.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016735/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1016732"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2025 7:37 UTC (Tue)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1016732/">Link</a>] (34 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; It's perfectly fine for “slow” swapping (basically of initialized but not really used memory in a daemon or something), but for anything involving significant churn, I feel very disconnected from the reality in all these presentations.</span><br>
<p>
A machine in a state of memory thrashing will never feel or be "usable". That's simply a non-goal.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016732/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1016738"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2025 12:24 UTC (Tue)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/1016738/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The current situation is that once something starts thrashing, everything becomes unusable until (hopefully) the OOM killer kicks in.<br>
<p>
Is there a way to improve that situation other than simply disabling swap altogether? I mean, what's the point of swap if it doesn't solve the actual problem of allowing you to use your memory more effectively by swapping unused stuff to disk.<br>
<p>
I dunno, maybe kicking the OOM killer if it notices stuff being swapped being less than a few seconds old or something?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016738/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1016777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2025 13:59 UTC (Tue)
                               by <b>jhe</b> (subscriber, #164815)
                              [<a href="/Articles/1016777/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Disabling swap will force the thrashing onto the page cache and will not prevent the problem from occuring.<br>
<p>
You could write a program that hooks into the pressure stall information and kills a pre-defined process (Firefox, probably) when memory pressure goes above 30 or 50. You are right that the kernel OOM killer should do that on its own.<br>
<p>
I think the underlying cause is that some applications (Firefox, Electron) are too memory hungry to run on 4 or 8 GB.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 12:39 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017009/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; I think the underlying cause is that some applications (Firefox, Electron) are too memory hungry to run on 4 or 8 GB.</font>

<p>Yet, somehow, it works fine with macOS or Windows. That's what makes things really weird: Linux claims that it has very efficient and quick swap subsystem yet, in practice, it works like a crap.</p>

<p>I can open 100 Windows of Chrome and VSCode (or XCode) and pile of other apps that use 50GB or 100GB of swap on Windows and MacOS system with 8GiB RAM – and it would work. Yes, it wouldn't be flying, not with this kind of memory pressure… but system would be usable.</p>

<p>Yet on Linux with much smaller memory pressure system is totally unresponsive.</p>

<p>I always assumed that it was because no one cared or used swap on Linux, and that means it's useless… but that article claims that certain refactorings are not done because there would be regressions… regressions <b>compared to what</b>? To the non-usable swap of today? Does it even matter? Who uses swap on Linux, why and, most importantly, <b>how</b>?</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/1017009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017016"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 13:13 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/1017016/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
aiui, swapping and paging are two different beasts. Do MacOs and Windows use paging? Certainly I thought Windows had a page file.<br>
<p>
That could quite possibly be it ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017016/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 13:32 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017018/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Do MacOs and Windows use paging?</font>

<p>Windows and MacOS have essentially the same API as Linux. MacOS is POSIX and Windows can run Linux binaries (WSL1, WSL2 runs full Linux kernel).</p>

<p>So no, that's not it.</p>

<p>I'm pretty sure they both include tons of tweaks and hacks to ensure that even if system is heavily trashing it still stays responsive, but the end result: if system is heavily overloaded it, definitely, becomes “sluggish”, but noting like Linux does where switch from graphic to text console may take hours (literally) and then you couldn't log in on text console because of timeouts (measured in minutes).</p>

<p>And if keeping system usable when it's swapping is explicit non-goal then I wonder why does anyone care to benchmark things that are not supposed to be used, anyway.</p>

<p>As I have said: I always assumed that Linux just simply keeps swap in some vestigial form for a nostalgia reasons (and no one cares to do anything to it) – and this is done to keep it working great in a “normal” situation (when swap is not used).</p>

<p>This even may be a sane stance if you recall that most Linux system don't really use swap (but Android and ChromeOS use swap code to implement <a href="https://en.wikipedia.org/wiki/Zram">zram</a>… would explain these additions to that code that article discusses).</p>

<p>But when I read about some regressions and other such things… hey, that means that <i>someone</i>, <i>somewhere</i> still uses swap on Linux, <i>for something</i>.</p>

<p>The whole system have looked ever more mysterious the more I read an article: because it certainly read as if it comes from some parallel universe where something else but “zero swap but some zram” is used…</p>

<p>But… how and why? Why do they care about speed… and <b>what</b> kind of speed they do care about? Because for me swap on Linux always had one and one speed only: unusable. Was that it's 10x of “unusable” threshold or 100x of “unusable” threshold… I don't know: one thinks that should happen in seconds start taking hours system is no longer usable and measuring “speed of swap” doesn't make much sense, after that point.</p>

<p>Of course for me “speed of swap” is “slowdown compared to the situation when there are enough memory and swap is not used” and, maybe, there are some other ways to measure speed of swap, but… again: who, how and why does that?</p>

<p>That meta-mystery remained uncovered in the article…</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/1017018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1017156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 4:58 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/1017156/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Yet, somehow, it works fine with macOS or Windows. That's what makes things really weird: Linux claims that it has very efficient and quick swap subsystem yet, in practice, it works like a crap.</span><br>
<p>
Windows doesn't do overcommit (unless you REALLY try with MEM_RESERVE flag for VirtualAlloc). If a program allocates RAM, then there is a page in memory or in the swap file to back it. This naturally limits the amount of memory that has to be materialized out of thin air if there's a "bank run" on uncommitted RAM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 8:21 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017168/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>That's entirely different kettle of fish. You can disable overcommit on Linux, add 1TiB swap on the 4GiB desktop… and it would <b>still</b> become absolutely unresponsive if you would run two rustc processes that try to use 20GiB each.</p>

<p>And yes, miracles are impossible: if you would try to run some process that needs 1TiB of RAM while physically there are only 1GiB then even on macOS or Windows you would have to wait, most likely, till the heat death of universe.</p>

<p>But using 2x, 3x, 10x more RAM than your machine does have, physically? With dozen of apps? That's Ok: system is becoming more and more sluggish but it stays usable. On Linux using even 2x more is, normally, a prelude to hitting “reset”.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/1017168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017333"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2025 8:37 UTC (Mon)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/1017333/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is really less of a factor how much you overcommit and more how much of the overcommitted memory is in active use. Once that goes beyond your physical memory you have a problem no matter what you do with swap.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017333/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor1016881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2025 1:12 UTC (Wed)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/1016881/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it possible to avoid the machine getting into that thrashing state in the first place, though? On a desktop system what I typically find is that all is fine almost all of the time; but occasionally some process goes rogue (most recently it was clangd running away with all the memory). When that happens everything goes unusably noninteractive until the OOM killer kicks in and kills (hopefully) the offending process. What I would prefer is that instead of giving the offender so much of the available RAM that the whole system is unusable is that the kernel dynamically restricts the resources the rogue can have *before* that point, so the system stays interactively usable if perhaps a bit sluggish (and it's fine if the rogue makes no forward progress at all) until the OOM killer can do its thing...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1016882"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2025 2:12 UTC (Wed)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1016882/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Is it possible to avoid the machine getting into that thrashing state in the first place, though?</span><br>
<p>
There are several solutions to this problem in Linux that fit various definitions/stages of "possible". We have cgroup memory limits (which can be set manually), PSI metrics and userspace OOM killers (that can be more aggressive and/or proactive than the in-kernel one, having a chance to terminate the offending processes before the system becomes unusable), and MGLRU working set protection (albeit it's not certain if it actually causes more good than harm, cf. <a href="https://github.com/zen-kernel/zen-kernel/commit/856c3874">https://github.com/zen-kernel/zen-kernel/commit/856c3874</a>). Perhaps there are other things also.<br>
<p>
However, none of it is related to *making swap faster*. The point I was making is that once you get to the state of thrashing, no amount of "making swap faster" is going to make a system usable while it's in that state.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1016882/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017011"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 12:50 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017011/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; The point I was making is that once you get to the state of thrashing, no amount of "making swap faster" is going to make a system usable while it's in that state.</font>

<p>But why? What makes that impossible precisely and exactly on Linux while perfectly possible on other OSes?</p>

<p>I have one friend who is unfortunate enough to be developing Rust app on Macbook Air. And when <code>rustc</code> starts using 20GiB of RAM (two processes 10GiB each) on his 8GiB MBA… compilation takes ages. What takes 5 minutes for me takes 50 minutes for him. So… 10x slowdown, sure.</p>

<p>Yet… Mac remains perfectly responsive (if sluggish). Chrome works, VSCode works, you can run Word and edit something in it.</p>

<p>Try the same thing on Linux… and everything freezes entirely.</p>

<p>Do you seriously want to imply that <code>rustc</code> has that special code somewhere in it that makes it freeze Linux and specifically and exclusively Linux only? While all other OSes chug along just fine?</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/1017011/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 13:39 UTC (Thu)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1017047/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But why? What makes that impossible precisely and exactly on Linux while perfectly possible on other OSes?</span><br>
<p>
Because you are (either accidentally or deliberately) conflating swap performance and memory management strategy.<br>
<p>
<span class="QuotedText">&gt; Do you seriously want to imply that rustc has that special code somewhere in it that makes it freeze Linux and specifically and exclusively Linux only?</span><br>
<p>
Why do *you* want to imply that? I never said anything that could be interpreted as what you just said. Please stop putting words in my mouth.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 13:51 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017050/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Because you are (either accidentally or deliberately) conflating swap performance and memory management strategy.</font>

<p>I guess. For me “swap performance” is a simple ratio: without swap <i>XXX</i> takes <code>N</code> seconds, with a swap <i>XXX</i> takes <code>K</code> * <code>N</code>  seconds. And <code>K</code> is swap performance. There the question about how to more precisely measure <i>XXX</i>, obviously, but <code>K</code> looked like a non-ambiguous measure…</p>

<p>Sure, when you want to <b>improve</b> that ratio you would need some kind of more nuanced measures and maybe even introduce many other, lower-level, more tractable and less integral, numbers… but if we talk about “swap performance”… what else can you ever mean?</p>

<p><a href="https://en.wikipedia.org/wiki/Virtual_memory">Virtual memory</a> is “poor man's imitation of real memory” and swap is supposed to make it behave like real one… what other kind of measure may we want to talk about in the absence of any clarifications?</p>

<p>I even <b>every explicitly</b> wrote that I want to know what other natural way to measure “swap performance” is – preferably with explanation about who may want to know these numbers and why.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/1017050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017080"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 13:54 UTC (Thu)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/1017080/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I guess. For me “swap performance” is a simple ratio: without swap XXX takes N seconds, with a swap XXX takes K * N seconds. </span><br>
<p>
You're missing the point where "without swap" something in the system (possibly even what you're using) will be force-killed due to insufficient memory.<br>
<p>
If you have enough memory for your workload, nothing will ever get paged out.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017080/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017105"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 14:11 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017105/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; If you have enough memory for your workload, nothing will ever get paged out.</font>

<p>Bingo! That means that swap is, essentially, a cheap replacement for an expensive extra RAM. And it has a theoretical, never achievable goal: be as fast as said extra RAM (it's not really possible to make it faster, I suspect).</p>

<font class="QuotedText">&gt; You're missing the point where "without swap" something in the system (possibly even what you're using) will be force-killed due to insufficient memory.</font>

<p>Not if you would buy extra RAM. Swap is, ultimately, a replacement for an extra RAM thus it's natural to compare it's speed to speed of a computer system with said extra RAM, isn't it?</p>

<p>After that you can look on list of workloads that you use, attach some $$ measure to the time that you are losing and then decide whether purchase of an extra RAM is worth it.</p>

<p>What <b>other</b> “swap speed” may you want to talk about and why? What would you do with these numbers and why?</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/1017105/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor1017166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 7:46 UTC (Fri)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/1017166/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you are missing the point that something being killed is fundamentally a lot better than the system becoming so slow that it will never finish its task before someone force reboots it to get a usable system back.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 8:05 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017167/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>In a cloud, for server applications it's often better: fault tolerance requirements means that you have some system to cope with death of any process (if only because you have to be ready to cope with sudden death of the hardware) – and restarting work on another computer is faster than using swap.</p>

<p>On a desktop becoming sluggish and 10x slow is much better then killing any processes, you only want to kill them when these are truly rogue processes that wouldn't ever produce any useful results.</p>

<p>Satisfying both requirements is hard but that doesn't give us any useful insights into what kind of “swap speed” one may need or want if the end result is that slowdown from the use of swap is so big that the only advice about tuning of swap that one may ever get is “ensure that swap is never used”.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/1017167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 14:20 UTC (Fri)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/1017200/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; On a desktop becoming sluggish and 10x slow is much better then killing any processes, you only want to kill them when these are truly rogue processes that wouldn't ever produce any useful results.</span><br>
<p>
Only 10x would be ok. In practice it's something that's normally almost instant taking upwards of 20 minutes and your mouse pointer doesn't even move anymore. At that point killing something like firefox (which will restore from state anyway) is the right solution. Firefox is actually a good choice, because it has many subprocesses you can probably kill without the user even noticing.<br>
<p>
I'd settle for: if moving the mouse pointer has no visual effect within 10 seconds, trigger OOM killer. I just have no idea how to go about implementing that. Actually, I'd like it to happen as soon as mouse movement becomes choppy, because at that point all is lost already. At that point I'm only desperately trying to get the mouse to the close icon in the top-right hoping clicking it gets through before the system hangs entirely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2025 8:34 UTC (Mon)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/1017332/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another good indicator might be if loading files during login takes more than a second or two. I am not talking about a whole desktop worth of applications starting up but just a terminal login. At that point I almost certainly want the slow application killed as my only purpose after completing the login.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017343"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2025 10:39 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017343/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Login? <b>What</b> login? It wasn't uncommon for me to not be able to login on a text console because after I type my username and hit enter I never get to the <code>Password</code> prompt because <code>getty</code> kill that session for “inactivity” before that may happen.</p>

<p>I have no idea how much work <code>/bin/login</code> does, but couldn't imagine why that would take 5 minutes or more on any system where swap works properly.</p>

<p>This stopped, of course, after I gave up and switched to the use of Linux in container. With browser outside of it.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/1017343/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017465"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2025 22:14 UTC (Mon)
                               by <b>mbunkus</b> (subscriber, #87248)
                              [<a href="/Articles/1017465/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can confirm khim's description. It's spot on &amp; not hyperbole in the least. I've found myself in the exact same situation several times over the last several years. When this happens, no login method works at all (local console, ssh, display manager if it happens to be running on that server) due to how  incredibly long each. and. every. key. stroke. takes. Debugging in such a situation is completely impossible, let alone fixing anything. Even if I manage to log in getting a process list takes multiple tens of minutes. The only sane thing to do is to hard reboot &amp; eat the file system damage &amp; loss of data.<br>
<p>
And that sucks so much.<br>
<p>
BTW, all of those cases were severs, not desktop systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017465/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1018089"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2025 23:32 UTC (Fri)
                               by <b>Jandar</b> (subscriber, #85683)
                              [<a href="/Articles/1018089/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The only sane thing to do is to hard reboot &amp; eat the file system damage &amp; loss of data.</span><br>
<p>
I use ALT+SysReq+{s,u,s,b} in that order with a few seconds between. That's my way out of the semi-regular freezes apparently caused by swapping. Every time I have to do this I cross my fingers and pray to the filesystem-gods to spare my home directory ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1018089/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor1017175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 10:16 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/1017175/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; &gt; But why? What makes that impossible precisely and exactly on Linux while perfectly possible on other OSes?</span><br>
<p>
<span class="QuotedText">&gt; Because you are (either accidentally or deliberately) conflating swap performance and memory management strategy.</span><br>
<p>
And I may well be out of date, but people seem to be conflating swapping and paging. Am I right, in that a *swap* system *swaps processes* in and out of memory. While a *paging* system *swaps pages* in and out of memory. Which is why systems that page don't become as slow as systems that swap.<br>
<p>
So a swapping system, faced with a large executable, will pull in the entire executable in order to run it. While a paging system will map the executable, pull in the first page to execute it, and only fault in further pages as required.<br>
<p>
Same with working memory - a paging system will file-back the memory, and presumably flush dirty pages, and flag hot pages. While a swapping system will dump the entire memory, and read it all back, as required.<br>
<p>
So a swapping system will be (relatively) slow because it's forever flushing and retrieving entire processes. A paging system on the other hand, will be dropping clean cold pages if required, so any program that is actively running will normally keep its hot paths in RAM without being dropped.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 11:48 UTC (Fri)
                               by <b>daroc</b> (editor, #160859)
                              [<a href="/Articles/1017177/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not intimately familiar with Linux's swap system, but I think the distinction you're making is not one the swap system makes. On my laptop right now I have ~500MB in swap, which appears to be small sections of memory from a variety of different processes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017182"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 12:51 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017182/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>If I remember correctly <a href="https://en.wikipedia.org/wiki/%CE%9CClinux">μClinux</a> can use “a swapping system” (just like ancient Unix versions like <a href="https://winworldpc.com/product/xenix/8086">Xenix 8086</a> had to do because they worked on a system without <b>any</b> MMU, even strange and primitive ones, like 80286).</p>

<p>Mainstream Linux never had support for “a swapping system”, because it was never supported any hardware where that even makes any sense.</p>

<p>MacOS (Classic) and Windows developed very elaborate and clever system with handles and movable pages and also never did that.</p>

<p>That's why that distinction that Wol talks about is more-or-less forgotten in a world of modern software.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/1017182/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor1017181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 12:44 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017181/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; And I may well be out of date, but people seem to be conflating swapping and paging.</font>

<p>Well… there's a reason for that. Indeed, you are a bit out of date. About 30-40 years our of date, give or take.</p>

<font class="QuotedText">&gt; Am I right, in that a *swap* system *swaps processes* in and out of memory. While a *paging* system *swaps pages* in and out of memory. Which is why systems that page don't become as slow as systems that swap.</font>

<p>That's true, but the problem here is that the last system that was swapping out processes that someone may have had a chance to use was probably a DOS Shell that was included in MS DOS 4 (that's year 1988), moved to supelement disk in MS DOS 6 (that's year 1993) and excluded from Windows 95 (and later version). DR-DOS also had similar thing (it was born out of <a href="https://en.wikipedia.org/wiki/Multiuser_DOS#Concurrent_CP/M-86">Concurrent_CP/M-86</a> that was used swapping, after all), but I don't remember the dates.</p>

<p>Linux, Windows and macOS never used this strategy and thus it's very hard for anyone to even recall that ever existed.</p>

<font class="QuotedText">&gt; So a swapping system will be (relatively) slow because it's forever flushing and retrieving entire processes. A paging system on the other hand, will be dropping clean cold pages if required, so any program that is actively running will normally keep its hot paths in RAM without being dropped.</font>

<p>You are absolutely correct, but in a world where “a swapping system” is “something that briefly existed very long time ago and for a relatively short time”… most people wouldn't even understand what you are talking about when you would start discussing that difference. Paging needs support in hardware to be efficient, but after Intel made said support mandatory with introduction of 80386 in 1985 no one was even thinking about using “a swapping systems” for anything anywhere.</p>

<p>From what I understand swapping was popular before introduction of IBM/370 in 1970, but I don't know the history of computers well enough to say how exactly “a swapping systems” and “a paging system” competed 50 years ago. “A swapping systems” were already a stuff that you read in a history book and not use for work, when Linus started work on Linux, thus, of course, in the context of Linux they don't matter at all.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/1017181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 14:51 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/1017251/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; From what I understand swapping was popular before introduction of IBM/370 in 1970, but I don't know the history of computers well enough to say how exactly “a swapping systems” and “a paging system” competed 50 years ago. “A swapping systems” were already a stuff that you read in a history book and not use for work, when Linus started work on Linux, thus, of course, in the context of Linux they don't matter at all.</span><br>
<p>
I think you might be surprised then!<br>
<p>
The original linux "swapping system" is pretty much an exact copy of the original Unix swapping system, which probably does date from your aforementioned 1970!<br>
<p>
Do you remember back when Linus made a rather controversial change to linux swap, 2.4.10 or 2.6.10 I think - I remember it was roughly a 10 - that gave people running Vanilla Linux a massive shock? Do you remember the old saw that "swap must be at least twice ram" which most people - even back then - thought was an old wive's tale?<br>
<p>
Because Linus ripped out all the optimisation code, and that requirement came back! If you had a swap file, and the system tried to touch just ONE BYTE of swap, if it didn't have at least twice ram available, it locked up. HARD. (Most people didn't notice, because the distros put the code back ...)<br>
<p>
But that was sparked by Andrea Arcangeli and ?Rick van Riel? squabbling over a new approach to memory management. I don't know the end of that story, other than the "swap system" was replaced with something much better and I don't know what the new system does.<br>
<p>
I thought all this was documented by LWN, and I've tried to find it on several occasions without success. It could have been Zak's Kernel News, which was quite big back then ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 15:27 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017255/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; The original linux "swapping system" is pretty much an exact copy of the original Unix swapping system, which probably does date from your aforementioned 1970!</font>

<p>Maybe in some very early versions, I'm not familiar with what was there before Linux 1.2.<i>something</i></p>

<font class="QuotedText">&gt; Do you remember back when Linus made a rather controversial change to linux swap, 2.4.10 or 2.6.10 I think - I remember it was roughly a 10 - that gave people running Vanilla Linux a massive shock?</font>

<p>Definitely not 2.4.10 and not 2.6.10. Maybe 1.1.10? Very unlikely even back then, actually.</p>

<p>I know that with Linux 2.2 it was already possible to build MySQL by adding temporary swap on my puny machine with 16MiB RAM. I.e. Linux behaved example like macOS behaves today and how tutorials sell “virtual memory” idea normally: if your system doesn't have enough RAM… just add more swap and get more virtual RAM!</p>

<p>That's fundamentally impossible with “a swapping system” approach: if you are swapping out the whole process and there are not enough RAM to even put a single copy in memory, then that's it, you couldn't continue…</p>

<p>I think what you remember is different quirk that early versions of Linux had: in early versions of Linux each page had a static place in swap (but could be loaded into memory in different places) and that meant that total amount of virtual memory was equal to the size of swap and not to the size of swap+RAM. That was somewhat irritating, sure, but I don't remember any version of Linux (except <a href="https://en.wikipedia.org/wiki/%CE%9CClinux">μClinux</a>) that swaps out whole processes and not individual pages.</p>

<p>And yes, this is exactly what puzzles me, too: I know that it <b>was</b> possible to use Linux while using swap and a “poor man's RAM extension” quarter century ago. And it's essentially not possible to use it like that today. But what and when have changed? Was that change to Linux or to something in userspace? I actually suspect it's change to userspace: while old twm/fvwm/mwm setup designed to support dozen of hardware X terminals over slow network was very frugal in it's copying of data and thus worked even on Linux with pretty inefficient swap implementation “new way” with Compiz and its descendants now copies megabytes (or maybe gigabytes?) of data around every time it needs to redraw a single pixel… and without pile of hacks that macOS or Windows employ that means that use modern Linux UI without enough actual, real, physical RAM is, pretty much, impossible.</p>

<font class="QuotedText">&gt; I thought all this was documented by LWN, and I've tried to find it on several occasions without success. It could have been Zak's Kernel News, which was quite big back then ...</font>

<p>It would be great to find out. Because I don't remember of <b>any</b> version of Linux that had “a swapping system”, but I sure remember that time when Linux used swap inefficiently… yet it paging, just not a very efficient one… you were able to run app that needed more memory than system has physically available on all versions of Linux that I ever used.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/1017255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 11, 2025 15:49 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/1017259/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Wol is thinking about the big MM switch in 2.4.10 - see <a href="/2001/0927/kernel.php3">this page</a>.
<p>
Linux has never had full-process swapping, though.  What is called "swap" is paging for anonymous memory.



      
          <div class="CommentReplyButton">
            <form action="/Articles/1017259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor1017341"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2025 10:31 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/1017341/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      IME, Windows does better at not paging out part of a process's working set in order to page something else that the process needs in, and as a consequence is better at getting useful work from a process when it starts to thrash. It then combines this with longer timeslices, so that once you're doing useful work, you get a longer time to finish it before you're swapped out.


      
          <div class="CommentReplyButton">
            <form action="/Articles/1017341/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2025 10:52 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017344/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It definitely plays tricks with pushing processed to swap and back.</p>

<p>One way to experience “a last straw breaks the camel's back” performance issue, that plagues Linux, on Windows – is to overfill <b>both</b> memory <b>and</b> swap, too (may only do that with “permanent”, fixed size swap… that's not a default Windows setup)</p>

<p>When Windows may no longer “push out” some “victim” processes to swap then it starts behaving like Linux and, eventually, freezes, too.</p>

<p>But I have found out that adding more swap to Linux doesn't help: it may take 20 minutes to switch to a text console and then you can not login… even if there are plenty of swap left unused.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/1017344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor1017006"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 12:28 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017006/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Why is it non-goal, BTW? I know that Yandex was using FreeBSD for years because it could save money that way: with two sets of daemons on the same machine and 99%/1% split everything was perfectly behaving – the 99% side was perfectly responsive and could handle the traffic without being swapped out while 1% would get small percent of that same traffic while responding slowly because it would be trashing like hell (but responses would go to log and never to a human thus it was Ok).</p>

<p>Linux could never pull tricks like these… but I have no idea why. Because they were declared “non-goals” by someone?</p>

<p>P.S. Eventually the had to adopt a different way of doing experiments and switched to Linux… but mostly because it was becoming harder and harder to keep FreeBSD going when most hardware favors Linux.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/1017006/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 13:32 UTC (Thu)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/1017020/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's a non-goal for the swap subsystem (in the sense that no amount of making swap faster will make it as fast as RAM).<br>
<p>
It may or may not be a goal for the overall memory management strategy; limiting thrashing to some parts of the system should be somewhat doable with suitable application of cgroups or perhaps other, more auto-magic technologies (like aforementioned MGLRU working set protection). But ultimately, all that does is constrain unusability to those parts of the system that *are* thrashing (and likely degrade the overall throughput). Making *those* parts of the system usable is still a non-goal because it is fundamentally unachievable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor1017045"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Does it actually work?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 13:39 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/1017045/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Making *those* parts of the system usable is still a non-goal because it is fundamentally unachievable.</font>

<p>Why not? MacOS and Windows achieve that… somehow.</p>

<p>Sure, when it takes 50 minutes to compile something that can be compiled in 5 minutes without trashing… it's not good, absolutely – but it's still <b>usable</b>.</p>

<p>When the same thing takes <b>days</b> (not sure how many days, though, I stopped the experiment after two)… it's <b>not usable</b>.</p>

<p>You may say that it's <b>not worth it</b> (Apple did all that work, apparently, to claim that MBA with just 8GiB of RAM is as good as any other laptop with 16GiB of RAM), but that's something radically different from “fundamentally unachievable”.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/1017045/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor1017113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Might it be possible</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 10, 2025 15:51 UTC (Thu)
                               by <b>bferrell</b> (subscriber, #624)
                              [<a href="/Articles/1017113/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The desired workloads are conceptually broken?<br>
<p>
It might be the wrong problem is being solved<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/1017113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2025, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
