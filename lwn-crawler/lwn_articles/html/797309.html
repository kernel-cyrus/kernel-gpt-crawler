        <!DOCTYPE html>
        <html lang="en">
        <head><title>Inline encryption for filesystems [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/797309/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/796965/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/797309/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Inline encryption for filesystems</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 27, 2019</br>
           </div>
The encryption of data at rest is increasingly mandatory in a wide range of
settings from mobile devices to data centers.  Linux has supported
encryption at both the filesystem and block-storage layers for some time,
but that support comes with a cost: either the CPU must encrypt and decrypt vast
amounts of data moving to and from persistent storage or it must
orchestrate offloading that work to a separate device.  It was
thus only a 
matter of time before ways were found to offload that overhead to the
storage hardware itself.  Satya Tangirala's <a
href="/ml/linux-fsdevel/20190821075714.65140-1-satyat@google.com/">inline
encryption patch set</a> is intended to enable the kernel to take advantage
of this hardware in a general manner.
<p>
The Linux storage stack consists of numerous layers, so it is unsurprising
that an inline encryption implementation will require changes at a number
of those layers.  Hardware-offloaded encryption will clearly require
support from the device driver to work, but the knowledge of which
encryption keys to use typically comes from the filesystem running at the
top of the stack.  Communicating that information from the top to the
bottom requires a certain amount of plumbing.
<p>
<h4>Low-level support</h4>
At <a
href="/ml/linux-fsdevel/20190821075714.65140-2-satyat@google.com/">the
lowest level</a>, device drivers that support inline encryption will 
have to provide an operations structure like this:
<p>
<pre>
    struct keyslot_mgmt_ll_ops {
	int (*keyslot_program)(void *ll_priv_data, const u8 *key,
			       enum blk_crypto_mode_num crypto_mode,
			       unsigned int data_unit_size,
			       unsigned int slot);
	int (*keyslot_evict)(void *ll_priv_data, const u8 *key,
			     enum blk_crypto_mode_num crypto_mode,
			     unsigned int data_unit_size,
			     unsigned int slot);
	bool (*crypto_mode_supported)(void *ll_priv_data,
				      enum blk_crypto_mode_num crypto_mode,
				      unsigned int data_unit_size);
	int (*keyslot_find)(void *ll_priv_data, const u8 *key,
			    enum blk_crypto_mode_num crypto_mode,
			    unsigned int data_unit_size);
    };
</pre>
<p>
The interface is designed around hardware that provides a fixed number of
"key slots", each of which can hold a cryptographic context â€” the algorithm to be
used, associated parameters (the block size, for example), and the key.
These functions exist to program a crypto context into the hardware, remove a
crypto context from the hardware, determine whether a specific context is
supported, and to determine which slot, if any, is already programmed for a
given context.  Drivers will register this structure and provide the total
number of slots available.
<p>
Since the number of key slots provided by the hardware is fixed, it's
entirely possible that there will not be enough to handle all of the I/O
requests to a given device over a short period of time.  That may not be a
problem for a device that is occupied by a single, encrypted filesystem, but
the situation could be different if there are a lot of filesystems present,
or if per-directory encryption (as <a href="/Articles/639427/">supported by
the ext4 filesystem</a>) is in use.  So the kernel needs a way to arbitrate
access to key slots, preferably one that limits the amount of (possibly
expensive) slot reprogramming required.
<p>
That arbitration begins with a "key-slot manager" abstraction.  It
keeps track of which slots are available at any given time and, for those
that are busy, how many references (held by in-flight I/O operations) exist
to each.  The key-slot manager can 
be used to allocate slots and program encryption contexts.  In normal usage,
many I/O requests will use the same context, so the key-slot manager tries to
keep the most frequently used keys available to the hardware and avoids
programming the same key into multiple slots.
<p>
<a
href="/ml/linux-fsdevel/20190821075714.65140-3-satyat@google.com/">Moving
up a layer</a>, the patch set adds a new <tt>bio_crypt_ctx</tt> structure
to the BIO structure (which represents an I/O request).  When filesystem
code originates a request, it can add the relevant context information, and the
BIO structure will carry that information through to the block device
executing the request.  Adding this information requires changes in other
parts of the block layer; for example, two adjacent requests cannot be
merged if they are using different encryption contexts.
<p>
<h4>blk-crypto</h4>
<p>
Adding key information to the BIO structure isn't quite enough, though.
There is still the issue of slot management and actually programming crypto
contexts
into the hardware; while filesystems could arguably handle this work, it
almost certainly makes sense to handle this common task within the block
layer itself.  But there is a further complication: the device to which a
filesystem submits an I/O request may not be the device that ultimately
handles that request.  For example, a filesystem may be based on a RAID
"device" created by the device-mapper layer; code at the filesystem level
will be 
entirely unaware of the real physical devices that have been assembled into
the virtual device it sees.  So filesystems cannot directly handle details
like key-slot management.
<p>
The solution to this problem is the <a
href="/ml/linux-fsdevel/20190821075714.65140-4-satyat@google.com/">blk-crypto
subsystem</a>, which handles the details of managing key slots and getting
the key information through to the right device drivers.  Whenever a BIO is
submitted for execution, the blk-crypto code reacts to the presence of a
crypto context by allocating a slot from the key-slot manager associated with
the (immediate) target device.  That implies, for reasons that we'll return
to shortly, that subsystems like the
device mapper must implement a simple key-slot manager, even though they
perform no encryption themselves.
<p>
Layered devices like the device manager will make any necessary
modifications to BIOs they receive (including possibly splitting them into
multiple BIOs), then turn around and resubmit the resulting BIOs to the
lower-level devices.  When this happens, the blk-crypto layer will release
the key slot allocated at the intermediate level and allocate a new slot for the
lower-level device, propagating the key material downward.  This procedure
will happen as many times as necessary until the BIO reaches a device that
actually performs I/O.
<p>
The blk-crypto code has one other useful feature: if the target device does
not actually support the type of encryption requested by the filesystem (or
any encryption at all), blk-crypto will fall back to using the kernel's
crypto layer instead.  So filesystems can request encrypted data storage
without any knowledge of whether the underlying hardware supports inline
encryption or not.  This functionality may eventually replace the fscrypt
code currently used by ext4 and F2FS to implement encryption.
<p>
The crypto-layer fallback explains why intermediate block layers must
provide their own key-slot managers.  The block layer never knows whether a
given BIO will be resubmitted to a lower-level device later on, so it must
assume that every submission is the final one.  As a result, if encryption
is being performed by the kernel's crypto layer, that must happen
<i>before</i> submitting the BIO to the device; there will be no
opportunity to do so afterward.  The lack of a key-slot
manager for any given device is a signal to the block layer that inline
encryption is not supported, so the crypto-layer fallback will be performed
in that case; thereafter there is no point in using inline encryption for
that request even if turns out to be available.  Adding a key-slot manager
to layers like the device mapper 
is, among other things, a way of preventing the block layer from falling
back too soon.
<p>
The patch set includes a low-level implementation for <a
href="https://en.wikipedia.org/wiki/Universal_Flash_Storage">Universal
Flash Storage</a> devices and upper-level support for the F2FS filesystem.
As one might expect, this work is being driven by Android use cases;
encrypted filesystems are important for Android devices, and offloading the
actual encryption to the hardware should save both CPU time and power.
<p>
Given the potential value of this feature, it is not surprising that there
have been a few attempts to add support to the kernel.  The patch set
mentions three of them: a <a
href="/ml/linux-kernel/1539789476-6098-1-git-send-email-anilc@codeaurora.org/">hardware-specific
solution</a> that lacks generality, one that is <a
href="/ml/linux-kernel/192fedba-4f7d-8230-2152-b618787fd934%40synopsys.com/">implemented
within the crypto layer</a> (seen as the wrong place, since it's not a
general cryptographic primitive), and one that <a
href="/ml/linux-kernel/20181211095027.GA3316%40lvlogina.cadence.com/">requires
the device mapper</a> to function.  This implementation is an attempt to
avoid those problems and provide a more general solution.  It is in its
fourth revision and appears to be getting close to being ready to head upstream.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Filesystem_encryption">Security/Filesystem encryption</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Encryption-Filesystems">Encryption/Filesystems</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/797309/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor797477"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2019 20:39 UTC (Tue)
                               by <b>Spack</b> (subscriber, #77556)
                              [<a href="/Articles/797477/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What device could specifically benefit from this support? Can we already find such drives on the market? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797477/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797480"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2019 20:55 UTC (Tue)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/797480/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is already common in phones, where the flash controller in the SoC has support for doing the encryption in hardware.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797480/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797496"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2019 21:48 UTC (Tue)
                               by <b>theonewolf</b> (guest, #118690)
                              [<a href="/Articles/797496/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SSDs also usually implement it under the TCG OPAL standard.  Most SSDs are full self-encrypting drives (SEDs) today.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797496/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2019 22:04 UTC (Tue)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/797501/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The distinction is (to my understanding) the degree of control that the OS has over the encryption. In the Opal case, all that's exposed to the OS is the session management and authentication for encrypted regions. In the case being discussed here, you have the ability to define the encryption algorithm and even disable it - you still have direct access to the flash, which means you can read back the encrypted content and verify that the controller is encrypting in the expected manner.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797503"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2019 22:06 UTC (Tue)
                               by <b>theonewolf</b> (guest, #118690)
                              [<a href="/Articles/797503/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, you might be right on that.  I haven't explored this deeply (honestly haven't ventured much into Opal).<br>
<p>
I don't know about reading the raw data back!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797503/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor797513"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2019 23:58 UTC (Tue)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/797513/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; read back the encrypted content and verify that the controller is encrypting in the expected manner.</font><br>
<p>
Preferably after a power cycle so the controller can't lie.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797513/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797514"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2019 23:58 UTC (Tue)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/797514/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, wait. Never mind. The controller can lie regardless, can't it? That is, can't it just store the plaintext and encrypt the data on the fly when you read back the "raw" contents?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797514/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797516"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 0:22 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/797516/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even better, store all the keys and give them out if presented with a special NSA_HERE packet.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797516/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797517"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 0:24 UTC (Wed)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/797517/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, but that approach doesn't help you win on benchmarks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797517/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor797699"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2019 3:02 UTC (Thu)
                               by <b>ebiggers</b> (subscriber, #130760)
                              [<a href="/Articles/797699/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, and the CPU could do the same when it sees an AES instruction.<br>
<p>
Ultimately, you always need some level of trust in the hardware...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797699/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797702"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2019 3:09 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/797702/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's a bit more difficult with AES-NI. You have to somehow store the keys at a pretty good rate, and there's simply not enough space on the CPU die for this.<br>
<p>
But storing a handful of keys supplied for decryption of fairly large blocks of data? Easy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797702/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor798008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2019 6:03 UTC (Sat)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/798008/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And I just sent a colleague Ken Thompson's trusting trust (to point out you need to trust the writers of software *cough* bitcoin *cough*, there's no magic algo that makes it go away altogether..).<br>
<p>
Makes me smile that the paper stays relevant after all the years...! <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/798008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor798062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2019 18:15 UTC (Sun)
                               by <b>robert_s</b> (subscriber, #42402)
                              [<a href="/Articles/798062/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be many orders of magnitude harder to do this and not "get caught" at any point in the product's lifetime.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/798062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor797495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2019 21:47 UTC (Tue)
                               by <b>theonewolf</b> (guest, #118690)
                              [<a href="/Articles/797495/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Technically I think SSDs already have this kind of technology: <a href="https://www.micron.com/-/media/documents/products/white-paper/self_encrypting_drives_white_paper.pdf">https://www.micron.com/-/media/documents/products/white-p...</a><br>
<p>
I think most SSDs ship with it now: <a href="https://www.samsung.com/semiconductor/insights/news-events/samsung-ssd-self-encryption-provides-highest-level-of-protection-against-data-loss/">https://www.samsung.com/semiconductor/insights/news-event...</a><br>
<p>
They are typically based on the TCG OPAL standard for self-encrypting drives (SEDs): <a href="https://en.wikipedia.org/wiki/Opal_Storage_Specification">https://en.wikipedia.org/wiki/Opal_Storage_Specification</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor797520"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 2:13 UTC (Wed)
                               by <b>sbates</b> (subscriber, #106518)
                              [<a href="/Articles/797520/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
AFAIK there is no vendor-neutral interface into the engines (compression, encryption etc) that some of these SSDs provide. There is some activity within SNIA to try and remedy this situation and define said interfaces for at least some of the most common engines. The expectation is that this would feed into standards like T10 and NVM Express. However that's going to take time and then the vendors will need to produce product that aligns to those standard interfaces.<br>
<p>
<a href="https://www.snia.org/computational">https://www.snia.org/computational</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797520/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2019 1:02 UTC (Thu)
                               by <b>ebiggers</b> (subscriber, #130760)
                              [<a href="/Articles/797692/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Inline encryption has been part of the UFSHCI standard since 2016.  See the patchset, which adds support for it to Linux's UFS host controller driver.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor797530"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 7:38 UTC (Wed)
                               by <b>markh</b> (subscriber, #33984)
                              [<a href="/Articles/797530/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Am I the only one that is horrified by this?<br>
<p>
I thought it would be common sense to expect that encryption keys and plaintext would be restricted to the minimum number of layers possible, and that certainly under no circumstances would encryption keys be sent through several software and hardware layers to another possibly external device with its own proprietary firmware.  This seems like the perfect architecture, if your goal is to enlarge the attack surface well beyond the ability of any one entity to manage, and maximize the number of potential interception points where keys or plaintext can be stolen.<br>
<p>
I really hope that I'm missing something and this is not as bad as it sounds.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797530/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 7:45 UTC (Wed)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/797532/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The controller is on the SoC. If the SoC vendor can't be trusted, there are any number of ways they can extract private data already.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797538"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 10:47 UTC (Wed)
                               by <b>juliank</b> (guest, #45896)
                              [<a href="/Articles/797538/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This does not apply to devices where the storage is replaceable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797538/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797601"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 15:20 UTC (Wed)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/797601/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Using this for devices where the storage is replaceable is already a bad idea - you've then got unencrypted information going over a bus that's trivial to interpose.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797601/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor797730"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2019 11:02 UTC (Thu)
                               by <b>LtWorf</b> (subscriber, #124958)
                              [<a href="/Articles/797730/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes but building a CPU that understands what is a key and what isn't is a bit complicated. If you have an instruction "set key" it's all suddenly very very easy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797730/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor797547"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 13:14 UTC (Wed)
                               by <b>grove</b> (guest, #1721)
                              [<a href="/Articles/797547/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't see a need to be "horrified by this". It's a way to make a feature available in some modern hardware available to the end user. If you don't trust all the hardware your information will have to pass through to use this, you should abstain from using that feature of your hardware.<br>
<p>
For that reason (and probably a couple more) I don't expect the pure software encryption options will go away (we are too many who can see the problems in giving secret information to our hardware), but allowing others to use this feature of their hardware seems fine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797547/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797580"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 15:02 UTC (Wed)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/797580/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even so, the API shown has a surprising number of methods that take key data and seems to be using the key data itself as the identifier of the key, rather than something less secret. Will keyslot_find be implemented in a way that doesn't leak bits of other keys via timing attacks or leave key bits beyond the end of the stack or in memory that could be reused uninitialized?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797580/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797698"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2019 2:35 UTC (Thu)
                               by <b>ebiggers</b> (subscriber, #130760)
                              [<a href="/Articles/797698/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, the code always uses constant-time comparisons when comparing keys, and always zeroizes keys when they're no longer needed.<br>
<p>
We could try to implement something fancy where the keyslot manager only remembers a cryptographic hash of each programmed key.  But that would add extra overhead, and for now wouldn't truly buy us anything since the key still needs to be in kernel memory anyway, in case it needs to be programmed into a keyslot again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797698/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797705"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2019 5:19 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/797705/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there a single keyslot manager? I thought that was going to be up to each driver to implement, with the risk that some drivers wouldn't do as good a job of it as the implementation in the original patch set.<br>
<p>
Why not remember a struct key * instead of the data directly? It'd still be a pointer to the secret in kernel memory, but my impression is that they're not generally duplicated, so you could do all your management based on pointer equality, and leaking the values that have to be in your data structures to userspace would be less immediately bad.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797705/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor797583"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 15:09 UTC (Wed)
                               by <b>markh</b> (subscriber, #33984)
                              [<a href="/Articles/797583/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Trust is important but not the only concern; it is also about greatly increasing the attack surface.  It's a lot easier to find a vulnerability if there are several possible software and hardware layers to choose from, many of which were not even designed with security in mind.  It is only necessary to find a single weak spot to exploit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797583/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor797696"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Inline encryption for filesystems</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2019 2:14 UTC (Thu)
                               by <b>ebiggers</b> (subscriber, #130760)
                              [<a href="/Articles/797696/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As noted by another commenter, you need to trust the SoC vendor anyway.<br>
<p>
I'll also note that inline encryption is, effectively, already standard practice on mobile devices.  All iOS devices use it, and currently the major Android SoC vendors are providing their own inline encryption solutions, including out-of-tree kernel patches, which are already used on most new mid to high end Android devices.<br>
<p>
It will be much better to have vendor-independent, well-reviewed, and well-tested upstream Linux kernel code to support inline encryption, and common tests that everyone has to pass, rather than continue the status quo of everyone using their own out-of-tree patches.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797696/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor797541"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Usual vendor-firmware levels of quality and trustworthiness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2019 12:03 UTC (Wed)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/797541/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Required reading:<br>
<p>
<a href="https://www.ru.nl/publish/pages/909282/draft-paper.pdf">https://www.ru.nl/publish/pages/909282/draft-paper.pdf</a><br>
<p>
I am not sure I would trust the SoC vendors would do any better than the SSD vendors named in the paper.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797541/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor797693"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Usual vendor-firmware levels of quality and trustworthiness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2019 1:38 UTC (Thu)
                               by <b>ebiggers</b> (subscriber, #130760)
                              [<a href="/Articles/797693/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Self-encrypting drives normally take a password, which can be changed later; they don't take the encryption key directly.  Therefore, they have to implement key generation and wrapping themselves --- which is where the vulnerabilities actually are.  It also means that software can't test the encryption for correctness.<br>
<p>
Inline encryption hardware is different, since for standards complaint (e.g. UFSHCI 2.1) inline encryption hardware, software provides the encryption key(s) directly.  Thus, the hardware doesn't do any key generation or wrapping, and the results can be compared with a software implementation.<br>
<p>
So it's simply not possible to screw up the UFSHCI 2.1 crypto in the same ways that ATA Security and TCG OPAL self-encrypting drives have been screwed up.  And if someone does nevertheless screw it up somehow, it's easily detectable by some basic comparison tests, unless the vendor *really* went out of their way to very deliberately do something malicious.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797693/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor797755"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Final paper</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2019 13:28 UTC (Thu)
                               by <b>CChittleborough</b> (subscriber, #60775)
                              [<a href="/Articles/797755/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here's the final paper, from the 40th IEEE Symposium on<br>
Security and Privacy: <br>
<a href="https://www.ieee-security.org/TC/SP2019/papers/310.pdf">https://www.ieee-security.org/TC/SP2019/papers/310.pdf</a><br>
<p>
Not good news.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/797755/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
