        <!DOCTYPE html>
        <html lang="en">
        <head><title>User-space interrupts [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/871113/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/871391/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/871113/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>User-space interrupts</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 30, 2021</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2021-Linux_Plumbers_Conference">LPC</a>
</div>
The term "interrupt" brings to mind a signal that originates in the
hardware and which is handled in the kernel; even software interrupts are a
kernel concept.  But there is, it seems, a use case for enabling user-space
processes to send interrupts directly to each other.  An upcoming Intel
processor generation includes support for this capability; at the <a
href="https://linuxplumbersconf.org/">2021 Linux Plumbers Conference</a>,
Sohil Mehta ran <a
href="https://linuxplumbersconf.org/event/11/contributions/985/">a
Kernel-Summit session</a> on how Linux might support that feature.
<p>
At its core, Mehta began, the user-space interrupts (or simply "user
interrupts") feature is a fast way to do event signaling.  It delivers signals
directly to user space, bypassing the kernel to achieve lower latency.  Our
existing interprocess communication mechanisms all have limitations, he
said.  The synchronous mechanisms often require a dedicated thread,
have high latency, and are generally inefficient.  Asynchronous mechanisms

<a href="/Articles/871117/"><img
src="https://static.lwn.net/images/conf/2021/lpc/SohilMehta-sm.png" alt="[Sohil Mehta]"
title="Sohil Mehta" class="rthumb"></a>

(signals, for example) have even higher latency.  So often the only
alternative is polling, which wastes CPU time.  It would be nice to have a
fast, efficient alternative.
<p>
That alternative is user-space interrupts, which will first appear in
Intel's "Sapphire Rapids" CPUs.  <a
href="/ml/linux-kernel/20210913200132.3396598-1-sohil.mehta@intel.com/">RFC
patches</a> supporting this feature were posted in mid-September.
Those patches support user-to-user signaling without going through the
kernel; instead, the new <tt>SENDUIPI</tt> instruction allows one process
to send an
interrupt directly to another process.  Future versions will also include
kernel-to-user signaling and, eventually, interrupts sent directly to user
space from devices.
<p>
Mehta put up some benchmark results (which can be seen in <a
href="https://linuxplumbersconf.org/event/11/contributions/985/attachments/756/1417/User_Interrupts_LPC_2021.pdf">the
slides</a>) showing that user-space interrupts are nine times faster than
using <a
href="https://man7.org/linux/man-pages/man2/eventfd.2.html"><tt>eventfd()</tt></a>,
and 16&nbsp;times faster than using pipes or signals.  The advantage is
lower if the receiving process is blocked in the kernel, since it is not
possible to avoid a context switch in that case.  Even then, user-space
interrupts are 10% faster for the recipient, and significantly faster for
the sender, which need not enter the kernel at all.  Florian Weimer asked
how user-space interrupts compared to futexes, but evidently that testing
has not been done.
<p>
Use cases for this feature include fast interprocess communication, of
course.  User-mode CPU schedulers should be able to benefit from it, as can
user-space I/O stacks (networking, for example).  Getting the full benefit
from this feature will require enhancements to libraries like libevent and
liburing.  There are no real-world applications using this feature yet,
Mehta said; he is interested in hearing about other applications that might
benefit from it.  Ted Ts'o suggested host-to-guest wakeups in
virtualization environments; evidently that use case is being investigated,
but there are no real results yet.
<p>
For any number of good reasons, user-space processes cannot just
arbitrarily send interrupts to others; there is some setup required.  On
the receiving side, it all starts with a call to:
<p>
<pre>
    uintr_register_handler(handler, flags);
</pre>
<p>
Where <tt>handler()</tt> is the function that is called to handle a
user-space interrupt, and <tt>flags</tt> must be zero.  The definition of
the handler function requires a bit of special care; its prototype is:
<p>
<pre>
    void __attribute__ ((interrupt))
        handler(struct __uintr_frame *frame, unsigned long long vector);
</pre>
<p>
The next step is to
create at least one file descriptor associated with this handler:
<p>
<pre>
    int uintr_create_fd(u64 vector, unsigned int flags);
</pre>
<p>
Here, <tt>vector</tt> is a number between zero and 63; one file descriptor
can be created for each vector.  The process then hands that file
descriptor to the sending side.  If the sender is another thread in the
same process, the hand-off is trivial; otherwise a Unix-domain socket can be
used to transfer the descriptor.  The sender then performs its setup with:
<p>
<pre>
   int uintr_register_sender(int fd, unsigned int flags);
</pre>
<p>
Where <tt>fd</tt> is the file descriptor passed by the recipient and
<tt>flags</tt>, as always, is zero.  The return value is a handle that can
be used with the <tt>_senduipi()</tt> intrinsic that is supported by
GCC&nbsp;11 to actually send an interrupt to the receiver.
<p>
Actual delivery of the interrupt depends on what the receiver is doing at
the time; if that process is running in user space, the handler function
will be called immediately with the appropriate vector number.  Once the
handler returns, execution will continue at the point of interruption.  If
the receiver is blocked in a system call in the kernel, the interrupt will
be delivered on return to user space without interrupting the in-progress
system call.  There is a <tt>uintr_wait()</tt> system call in the patch set
that will block until a user-space interrupt arrives then
return immediately, but it is described as a "placeholder" until
the desired behavior for this case is worked out.
<p>
Prakesh Sangappa asked whether it was really necessary to exchange the file
descriptor with all senders; in a system where there could be large numbers
of senders, that could get expensive.  Mehta replied that there are a
couple of optimizations that are being looked at.  Ts'o asked whether
user-space interrupts could be broadcast to multiple recipients; the answer
is that broadcast is not supported.
<p>
Arnd Bergmann wanted to know if any thought had been given to emulating
this feature on older CPUs.  The answer appears to be yes; the kernel will
trap the relevant instructions and transparently emulate them.  Mehta asked for
feedback on the emulation mechanism and, in particular, whether it should
be implemented for other architectures.  Bergmann discouraged that idea,
saying that if user-space interrupts are implemented for those
architectures, they will surely not be compatible with the emulated
version.  Emulation for other architectures, he said, should only be done
once those architectures have defined their own instructions.
<p>
Greg Kroah-Hartman asked about whether the Clang compiler has support for
the <tt>_senduipi()</tt> intrinsic; that support is being worked on, but is
not yet ready.  Kroah-Hartman also asked about more details on workloads
that benefit from this feature, to which Mehta replied that he did not have
anything specific to point to yet.
<p>
Mehta closed the session (which was running out of time) by asking what
should happen when the recipient is blocked in a system call.  As
mentioned, the current patch set waits for the system call to return before
delivering the interrupt.  Should the behavior be changed to be closer to
signals, with the interrupt delivered immediately and the system call
returning with an <tt>EINTR</tt> status?  Nobody had an opinion to share on
that question, so the session ended there.
<p>
The video of this talk is <a
href="https://www.youtube.com/watch?v=gpFfJkrrEEs&t=2h27m18s">available on
YouTube</a>.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Architectures-x86">Architectures/x86</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2021">Linux Plumbers Conference/2021</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/871113/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor871449"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 30, 2021 20:11 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/871449/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Mehta closed the session (which was running out of time) by asking what should happen when the recipient is blocked in a system call. As mentioned, the current patch set waits for the system call to return before delivering the interrupt. Should the behavior be changed to be closer to signals, with the interrupt delivered immediately and the system call returning with an EINTR status? Nobody had an opinion to share on that question, so the session ended there.</font><br>
<p>
IMHO it depends on multiple factors:<br>
<p>
* EINTR is annoying to handle from userspace, so much so that some languages (Python at least) just transparently handle it for you. But you already have to handle it anyway, unless you&#x27;re exclusively doing SIG_IGN/SIG_DFL for all signals.<br>
* The &quot;wait for something to happen&quot; syscalls (nanosleep, epoll_wait, etc.) should probably be interrupted, regardless of what is decided for other syscalls.<br>
* Since this is supposed to be a &quot;low latency&quot; mechanism, for when signals aren&#x27;t fast enough, it would be very odd if you had to wait around for the kernel before you could get the interrupt, given that signals actually do interrupt the kernel...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871449/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor871533"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2021 12:10 UTC (Fri)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/871533/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Would it not be possible to service the interrupt and then finish the system call? Or would that put too strong a constraint on what could be done by the handler?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871533/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor871537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2021 13:46 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/871537/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The handler could twiddle with memory the syscall is working with from the userspace side, no? You&#x27;ll need a context swap at least anyways so the handler has the right memory mappings.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor871580"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2021 16:30 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/871580/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another thread in the same process can already change memory (and mappings) while the first thread is in a system call, either because a reschedule occurred during the system call or because the other thread is running on a different CPU. A signal handler doesn&#x27;t seem like it would change anything in that regard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871580/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor871654"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2021 2:25 UTC (Sun)
                               by <b>kepstin</b> (subscriber, #72391)
                              [<a href="/Articles/871654/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m kinda confused about why hardware support is needed for this. For normally scheduled programs, as likely as not, the process being &quot;interrupted&quot; isn&#x27;t actually running, so wouldn&#x27;t the kernel need to step in and schedule the process before the interrupt could be delivered anyways? What&#x27;s the benefit over a syscall there? <br>
<p>
Or... Is this primarily for real time processes maybe? If the processes are carefully scheduled and known to be running concurrently on different cpus, I guess a direct userspace interrupt would be a win for latency. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871654/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor871702"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 3, 2021 18:35 UTC (Sun)
                               by <b>Bigos</b> (subscriber, #96807)
                              [<a href="/Articles/871702/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the idea is: when two threads are running at the same time on different CPUs one can interrupt the other at an order of magnitude lower latency than the alternatives. The thread might be in the middle of execution of a long running task that does not touch any syscalls. And if the receiving thread is not running, the latency is not worse.<br>
<p>
User mode scheduling (aka &quot;green threads&quot;) was given as an example use case. If I understand correctly, one thread can preempt the other using a userspace interrupt. The interrupt handler can then modify the state so that on return something else is called, similar to how kernel scheduler works, but without any context switches. However, green threads are usually used when scheduling small short-living (or often-waiting) tasks, so cooperative preemption is enough. And when forceful preemption is necessary, it happens seldom enough for it not to be a bottleneck.<br>
<p>
Jens Axboe mentioned io_uring cq notification [1], though that is about kernel -&gt; userspace which has not been implemented yet.<br>
<p>
There might be a better use case example that I am not thinking about. In fact, this has been stated as one of the issues on the mailing list [2].<br>
<p>
At first, I wanted to point out that userspace RCU (URCU) could be a possible use case as well, but that was already resolved by membarrier() syscall years ago [3]. However, userspace interrupts might improve the performance of this even without broadcast support.<br>
<p>
[1] <a href="https://lwn.net/ml/linux-kernel/ecf3cf2e-685d-afb9-1a5d-1382714cc60c@kernel.dk/">https://lwn.net/ml/linux-kernel/ecf3cf2e-685d-afb9-1a5d-1...</a><br>
[2] <a href="https://lwn.net/ml/linux-kernel/456bf9cf-87b8-4c3d-ac0c-7e392bcf26de@www.fastmail.com/">https://lwn.net/ml/linux-kernel/456bf9cf-87b8-4c3d-ac0c-7...</a><br>
[3] <a href="https://lwn.net/Articles/369567/">https://lwn.net/Articles/369567/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871702/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor872731"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2021 21:57 UTC (Tue)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/872731/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
EINTR is annoying to handle from userspace, so much so that some languages (Python at least) just transparently handle it for you. 
</blockquote>

My understanding of EINTR (especially after reading Gabriel's Worse-is-better paper) is that it's too complicated to deal with the situation (dealing with a signal) in the kernel, so the kernel returns to user space with EINTR, the signal can be delivered, and afterwards user space sees the EINTR and restarts the system call.

<p>Based on this understanding, I would expect the system-call wrapper to deal with EINTR, i.e., higher-level user programs should never see it.  But strangely, AFAIK the system-call wrappers just deliver EINTR to the higher-level user code.  Why?  Is my understanding of EINTR wrong?


      
          <div class="CommentReplyButton">
            <form action="/Articles/872731/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872737"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2021 22:54 UTC (Tue)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/872737/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Imagine a daemon in an call to select() with a long or infinite timeout on a collection of sockets, or in a blocking read() on a socket.<br>
<p>
Imagine further that you send that daemon SIGHUP, telling it to reload its configuration files.<br>
<p>
Do you really want it to wait until it receives its next packet before reloading its configuration files? After all, your config change might mean it needs to close one or more of the sockets it&#x27;s currently waiting on and/or open new sockets.<br>
<p>
I don&#x27;t.<br>
<p>
I&#x27;d much rather that its signal handler for SIGHUP just sets a flag saying &quot;config must be reloaded&quot;, and that the system call wrapper then returns -1 and sets errno to EINTR, so that my daemon can check its config-reload flag and go &quot;oh hey I&#x27;ve been reconfigured&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872737/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2021 5:51 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/872769/">Link</a>] 
      </p>
      
      </div>
      </summary>
      In this scenario the signal will be handled right after the system call (not the wrapper) returns, i.e., immediately.  The default for SIGHUP is to terminate the process, so the parent process can reread the configuration file and restart the process (just one example on how to deal with that).


      
          <div class="CommentReplyButton">
            <form action="/Articles/872769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor872759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2021 23:45 UTC (Tue)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/872759/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your description of EINTR roughly matches my understanding of ERESTART. <br>
<p>
In many cases a syscall that returns EINTR should *not* be restarted.  A blocking read is an obvious case.  The application should be given the opportunity to choose whether to restart.<br>
It *might* be possible for a platform (such as python) to require that syscalls which cannot be restarted don&#x27;t get used.  e.g. reads must be non-blocking. But that is a higher-level design choice than the libc syscall wrapper.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872770"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2021 6:37 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/872770/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      Looking at the wrapper of read() (one of the system calls that , it does not handle ERESTART, and ERESTART is not documented as an error returned from read(), while EINTR is.

<p>Why do you think that a blocking read() should not just continue (by restarting the system call) if the signal handler just returns after doing whatever it was doing?  Why should every user of read() have to deal with EINTR?


      
          <div class="CommentReplyButton">
            <form action="/Articles/872770/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2021 13:19 UTC (Wed)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/872786/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That doesn&#x27;t work: the user needs to deal with the signal that was received, and since signal handlers are so restricted it usually needs to happen in &quot;normal context&quot; not inside the handler.  And after dealing with it, they might or might not want to restart the read().  Perhaps the program got a SIGCHLD and before we restart reading we need to deal with our dead child process.  Or maybe the interrupt was SIGINT and we want to shut down the process in a reliable way after doing cleanup, so the signal handler set a flag but now we definitely don&#x27;t want to re-enter the read() at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2021 22:47 UTC (Wed)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/872899/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Why should every user of read() have to deal with EINTR? </font><br>
<p>
It&#x27;s not &quot;every user of read()&quot;, but only every user of read() reading from a file descriptor on which reads can block.<br>
That does NOT include regular files - mainly char devices and sockets.<br>
When you read from something that can block, you usually want more than you can be sure of getting in a single read.  You&#x27;ll usually need to be prepared to read some more anyway (not always, but often).<br>
So you need to be prepared for a short read, and handling EINTR as well is not a whole lot more effort.<br>
<p>
You certainly *could* have a platform where read() always retries EINTR, and signal handlers have to use longjmp if they want to abort a system call.  But I don&#x27;t think that would be *clearly* better than the current situation.  Maybe marginally better - I don&#x27;t know.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2021 23:23 UTC (Wed)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/872901/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  But I don&#x27;t think that would be *clearly* better than the current situation. Maybe marginally better - I don&#x27;t know.</font><br>
<p>
When an idea involves normalizing the use of longjmp() in code written by mere mortals, that creates in my mind the (theoretically, but probably not practically, rebuttable) presumption that the idea is absolutely terrible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2021 17:18 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/872969/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I found writing a signal handler more of a challenge than performing the longjmp() (and I don't remember ever having a bug due to the longjmp()).  The problem is that asynchronous signals can be invoked anywhere, including in the middle of updating some data structure, so you have a chance of corrupting the data structure if you longjmp() out of a signal handler for an asynchronous signal.


      
          <div class="CommentReplyButton">
            <form action="/Articles/872969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor872967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2021 17:13 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/872967/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Unix has the very good idea that everything is a file.  One of the benefits is that you can write some general routine on top of the system calls, and it is useful for all kinds of things.  This admittedly does not work all the time, but we should strive for it.

<p>In the present case, requiring the general routine to know whether it is used on a file that can result in EINTR, and how to behave in that case (which is very likely application-dependent) breaks modularity.

<p>The application and its signal handler know how to deal with the situation, and the longjmp() approach is a good one in that sense.  Of course, leaving an asynchronous signal with longjmp() has its dangers, but that's still the way we chose in Gforth (where asynchronous signals are rare).


      
          <div class="CommentReplyButton">
            <form action="/Articles/872967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872982"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2021 19:51 UTC (Thu)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/872982/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IMHO the unnecessary complication here is that &quot;regular files&quot; are treated specially. When your &quot;regular file&quot; could be backed by a network filesystem, FUSE, NBD, etc. it really ought to be considered more like a socket, subject to potential short reads and returning EINTR on signals whether or not any data has been read.<br>
<p>
Users generally expect to be able to use sockets and pipes in place of regular files, e.g. using process substitution in Bash or named FIFOs or Unix-domain sockets in the filesystem, or arbitrary paths under /proc/$PID/fd/. Unless there is a good reason to require capabilities specific to regular files, for example lseek() or mmap()—or the application creates the file itself with O_EXCL—then applications ought to expect that read() and write() may process less data than requested even if the normal case involves regular files.<br>
<p>
As for the longjmp() approach, that only works because the kernel backs out of the blocking call before invoking the signal handler. (A longjmp() call from a signal handler can&#x27;t perform a non-local return out of arbitrary *kernel* stack frames.) At that point it&#x27;s mostly a matter of policy whether the kernel restarts the system call after the handler returns or just returns EINTR to the caller—either always restarting or always returning EINTR would not simplify the kernel signficantly—and in general matters of policy are best left to application or library code rather than the kernel. Wrapping every non-interruptable read() in a loop to restart it until you get all the data you wanted is not substantially more code, or more *complex* code, than wrapping every read() which you might want to interrupt in a call to setjmp() and communicating that fact to the signal handler so it can decide whether to call longjmp().<br>
<p>
POSIX also has these caveats regarding longjmp() from a signal handler:<br>
<p>
<font class="QuotedText">&gt; It is recommended that applications do not call longjmp() or siglongjmp() from signal handlers. To avoid undefined behavior when calling these functions from a signal handler, the application needs to ensure one of the following two things: … After the call to longjmp() or siglongjmp() the process only calls async-signal-safe functions and does not return from the initial call to main(). … Any signal whose handler calls longjmp() or siglongjmp() is blocked during *every* call to a non-async-signal-safe function, and no such calls are made after returning from the initial call to main().</font><br>
<p>
It would be difficult to guarantee either of these restrictions are met in a complex application with many library dependencies. For example, if you return from a signal handler with longjmp() and then call printf() without masking every signal whose handler could call longjmp() then you&#x27;ve already broken both of those rules and invoked undefined behavior.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872982/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor990648"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2024 6:23 UTC (Wed)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/990648/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IMHO the CPU should provide a 'wait for interrupt' instruction (maybe with different power saving level configurable).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/990648/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor990649"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2024 6:43 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/990649/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
x86 has it: <a href="https://en.wikipedia.org/wiki/HLT_">https://en.wikipedia.org/wiki/HLT_</a>(x86_instruction)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/990649/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor990650"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2024 7:09 UTC (Wed)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/990650/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Like Cyberax said... this is exactly the instruction(s) that the kernel runs in each and every idle loop :-) And, incidentally, this is exactly how cpuidle works at least on x86 — via different "wait for interrupt" instructions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/990650/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor871752"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2021 9:23 UTC (Mon)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/871752/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another half-baked Intel CPU feature that promises performance gains? Sounds to me as if Intel hasn&#x27;t really learned much from overly focussing on performance at the cost of correctness and security in the past.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/871752/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2021 3:17 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/872088/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Now that Intel has lost the lead in silicon and raw performance, they&#x27;re focusing on specialized hardware features that can directly benefit highly specific aspects of the software engineering problem space, particularly those aspects most important to their biggest customers (e.g. Google and Facebook application fleets, cloud hosting providers, etc), while also promoting vendor lock-in. Of course, the stagnation in clock rates and the weight of Amdahl&#x27;s law also promote this shift. But we&#x27;ve seen this shift to specialized processor features many times before, most recently with HP and especially Sun as they struggled to compete with Intel. Many of Intel&#x27;s recent hardware features are conspicuous for leveraging peculiarities of their ISA and architecture, for example TSX.<br>
<p>
I don&#x27;t know how self-aware Intel&#x27;s strategies are, but it matters very little as their strategic options are strongly dictated by classic market dynamics. You can easily predict the directions they&#x27;ll take, though that&#x27;s not the same thing as predicting their success, and definitely not a prediction of their imminent demise.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor872087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2021 2:52 UTC (Thu)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/872087/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, the eternal dance between interrupts and polling. It plays out across the entire design space of hardware and software, with preferences seasonly shifting according to predominating concerns and constraints, but rarely aligning even between adjacent spaces. The majority of people working on internet application software might know this dance as events vs threads, and people who implement such frameworks eventually (hopefully) come to understand that it&#x27;s turtles all the way down--thread scheduler could be based on events/signals/interrupts, which in turn might be triggered by some blocking/waiting/polling mechanism, etc. Processes, signals, actors, CSP, coroutines, even banalities like call stacks, are all just variations on the same basic theme centering around questions of state and control flow management and their reification. They sometimes purported to be the final, concluding step in the dance, at least for large swathes of the problem space, yet invariably the dance continued without missing a beat.<br>
<p>
There&#x27;s no right answer except that it would especially harmonious and pleasing if a user-space interrupts facility was merged at the same time as Google&#x27;s user-space context switching patches for its User-Managed Concurrency Groups (UCMG) framework: <a href="https://lwn.net/Articles/856816/">https://lwn.net/Articles/856816/</a> An earlier incarnation, SwitchTo, is described at <a href="https://pdxplumbers.osuosl.org/2013/ocw/system/presentations/1653/original/LPC%20-%20User%20Threading.pdf">https://pdxplumbers.osuosl.org/2013/ocw/system/presentati...</a> (<a href="https://web.archive.org/web/20200926200828/https://pdxplumbers.osuosl.org/2013/ocw/system/presentations/1653/original/LPC%20-%20User%20Threading.pdf">https://web.archive.org/web/20200926200828/https://pdxplu...</a>).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor872228"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 0:34 UTC (Fri)
                               by <b>dancol</b> (guest, #142293)
                              [<a href="/Articles/872228/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Here, vector is a number between zero and 63; one file descriptor can be created for each vector.</font><br>
<p>
Ugh. So do I understand correctly that we have yet another process-wide resource --- uipi vector numbers in this case --- not centrally allocated by any process-wide authority? How is a shared library supposed to know what vector number to use? Should it guess? What if two libraries do that?<br>
<p>
Either the vector number namespace needs to be expanded or libc needs to grow an allocator.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872228/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872305"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 19:00 UTC (Fri)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/872305/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Plus you can only have one handler function per thread (or process? it&#x27;s not clear). So there will have to be some definitive user-space library (not necessarily the C library) to manage this resource.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872305/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor872300"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How does CPU state save/restore work with user interrupts?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 17:03 UTC (Fri)
                               by <b>tpo</b> (subscriber, #25713)
                              [<a href="/Articles/872300/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m confused:<br>
<p>
<font class="QuotedText">&gt; [user interrupts] deliver[s] signals directly to user space, bypassing the kernel to achieve lower latency. [...] interprocess [...]</font><br>
<p>
As far as I understand an interrupt on Intel architectures will essentially only store the PC/IP to the stack. To save/restore of the rest of the CPU registers is up to the interrupt handler. Similar for the TLB and the process&#x27; memory map.<br>
<p>
Enter user interrupts where a process can trigger an interrupt without going through the kernel.<br>
<p>
So who will do the CPU state save/restore? The process itself in its own interrupt handler? Thus it will be able to set up random virtual memory maps for itself? And if the interrupting process forgets to flush CPU state, then that will be a information leak from the interrupting process to the interrupted?<br>
<p>
What is it that I am missing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872300/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872304"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How does CPU state save/restore work with user interrupts?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 18:57 UTC (Fri)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/872304/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The receiving thread has to already be running on a different CPU, for the interrupt to be delivered directly. If any context switch is needed, it&#x27;s mediated by the kernel, unless I&#x27;ve very much misunderstood.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872304/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor872314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">How does CPU state save/restore work with user interrupts?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2021 20:14 UTC (Fri)
                               by <b>tpo</b> (subscriber, #25713)
                              [<a href="/Articles/872314/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh! I see, thanks a lot for helping my understanding Ben!<br>
<p>
Nevertheless the mechanisms looks quite tricky in practice: the inter-CPU communication/synchronization needs to be flawless otherwise it seems like anarchy and chaos could ensue... let&#x27;s hope for rock solid CPU engineering!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/872314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor875272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 6, 2021 10:04 UTC (Sat)
                               by <b>mcortese</b> (guest, #52099)
                              [<a href="/Articles/875272/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Isn't an important piece missing here? This patch set must impose additional burden on every context switch in order to keep track of where the receiving process is actually running. Inter-process communications might get some benefits, but has anyone evaluated the penalty for the rest of the code?


      
          <div class="CommentReplyButton">
            <form action="/Articles/875272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor890239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-space interrupts</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 5, 2022 11:13 UTC (Tue)
                               by <b>pskocik</b> (guest, #130865)
                              [<a href="/Articles/890239/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looking forward to this.<br>
<p>
I feel the interface/semantics should follow signals as closely as possible. In particular I strongly think those interrupts should break system calls with EINTR if it&#x27;s not possible to choose (like with SA_RESTART in the case of signals). You can always get SA_RESTART semantics by looping around a EINTR-returning systemcalls (possibly in a library) but if a hung system call won&#x27;t return, there&#x27;s nothing userspace can do to react to a signal/interrupt.<br>
<p>
As for the fd interface—I don&#x27;t know if it&#x27;s the right one. Intuitively it feels like threads should be able to interrupt themselves via their id (so there could be an interrupt version of pthread_kill). Same-process threads implicitly via pid_t and foreign threads via pid_t after acquiring permission somehow, preferable without involving fds, but maybe that&#x27;s wrong intuition.<br>
<p>
I&#x27;m curious what other similarities and disimilarities with signals there will be.  Blocking masks? SA_NODEFER? alternative stacks?<br>
<p>
I also hear the Linux kernel cannot use the x86_64 red zone because interrupts would clobber it. Will these userspace interrupts be able to respect the red zone?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/890239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
