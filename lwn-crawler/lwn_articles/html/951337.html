        <!DOCTYPE html>
        <html lang="en">
        <head><title>The real realtime preemption end game [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/951337/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/951632/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/951337/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The real realtime preemption end game</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>November 16, 2023</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2023-Linux_Plumbers_Conference">LPC</a>
</div>
The addition of realtime support to Linux is a long story; it first 
<a href="/Articles/106010/">shows up in LWN</a> in 2004.  For much of that
time, it has seemed like only a little more work was needed to get across
the finish line; thus we ran headlines like <a href="/Articles/345076/">the
realtime preemption endgame</a> — in 2009.  At the <a
href="https://lpc.events/">2023 Linux Plumbers Conference</a>, Thomas
Gleixner informed the group that, now, the end truly is near.  There is
really only one big problem left to be solved before all of that work can
land in the mainline.
<p>

<a href="/Articles/951340/"><img
src="https://static.lwn.net/images/conf/2023/lpc/ThomasGleixner-sm.png" alt="[Thomas Gleixner]"
title="Thomas Gleixner" class="rthumb"></a>

The point of realtime preemption is to ensure that the highest-priority
process will always be able to run with a minimum (and predictable) delay.
To that end, it makes the kernel preemptible in as many situations as
possible, with the exceptions being tightly limited in scope.  The basic
mechanics of how that works have been established for a long time, but
there have been a lot of details to resolve along the way.  The realtime
preemption work has resulted in the rewriting of much of the core kernel
over the years, with benefits that extend far beyond the realtime use case.
<p>
Gleixner started by noting that, while the realtime preemption project has
been underway for nearly 20&nbsp;years, it is actually closer to
25&nbsp;years for him — he started working on realtime support for Linux in
1999.  Once it's done, he said, there will be "a big party".  Is that point
at hand?  The answer, he said, is "yes — kind of".  There is one last
holdout to be dealt with: <tt>printk()</tt>.
<p>
Whenever code in the kernel needs to send something to the system consoles
and logs, it calls <tt>printk()</tt> or one of the numerous functions built
on top of it.  One might not think that printing a message would be a
challenging task, but it is.  A call to <tt>printk()</tt> can come from any
context, including in non-maskable-interrupt handlers or other
<tt>printk()</tt> calls.  The information being printed may be crucial,
especially in the case of a system crash, so <tt>printk()</tt> calls have
to work regardless of the context.  As a result, there are a lot of
concurrency and locking issues, and lots of driver-related complications.
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
<tt>printk()</tt>, Gleixner said, is fully synchronous in current kernels;
a call will not return until the message has been sent to all of the
configured destinations.  That is "stupid"; much of what is printed is
simply noise, especially during the boot process, and there is no point to
waiting for it all to go out.  Beyond being pointless, that waiting
introduces latency, which runs counter to the goals of the realtime work,
so the realtime developers have long since moved <tt>printk()</tt> output
into separate threads, making it asynchronous.  That code is a bunch of
hacks rather than a real solution, though.  A better job must be done to
make this work useful for the rest of the kernel.
<p>
The <tt>printk()</tt> problem has been worked on seriously since 2018,
resulting in about 300 patches that have either gone upstream or are
waiting in linux-next; this work has been <a
href="/Articles/780556/">covered here</a> at times.  There are, he said,
three final patch sets currently in the works to finish the job.  A few
tricky details are still being worked on.  One of those is the handover
mechanism; if the kernel has an emergency message to put out (it's
crashing, for example), it may need to grab control of a console that is
currently printing a lower-priority message.  Doing that safely from any
context is not an easy thing to do.
<p>
Another ongoing task is marking console drivers that are not safe to use in
some contexts; if, for example, outputting a message during a non-maskable
interrupt requires doing video-mode setting, it's just not going to work.
<p>
Gleixner finished the prepared part of his talk by saying that, even
though it's getting close, nobody should ask him when the work will be
done.  <tt>printk()</tt> is unpredictable, and he is no longer willing to
even try.  Even so, he expressed hopes that the rest of the realtime
preemption code would be in mainline before the 20th anniversary comes late
in 2024.
<p>


<a href="/Articles/951341/"><img
src="https://static.lwn.net/images/conf/2023/lpc/JohnOgness-sm.png" alt="[John Ogness]"
title="John Ogness" class="rthumb"></a>


An audience member asked whether there had been any interesting changes in
the <tt>printk()</tt> code over the last year; Gleixner answered that there
have been no fundamental conceptual changes.  John Ogness, who has done
much of the <tt>printk()</tt> work, said that the handover code has been
reduced somewhat, but that some work remains; there are 76 console drivers
in the kernel that need to be fixed, and it may take a while until they are
all done.  The handover code has been changed to allow drivers to be
updated one at a time rather than requiring that this work all be done at
once.  (See <a href="/Articles/909980/">this article</a> for more
discussion on the recent <tt>printk()</tt> work).
<p>
Masami Hiramatsu asked which kernel messages need to be printed
synchronously; Gleixner answered that almost everything should be made
asynchronous.  Beyond reducing latency associated with <tt>printk()</tt>
calls, asynchronous output allows the creation of a separate kernel thread for
each console, letting the faster consoles go at full speed rather than
waiting for the slowest one.  He also said that the code has been changed
to ensure that important messages are fully copied into the message buffer
before the first line is output, just in case a faulty console driver brings
the whole system down in flames.  Further safety is obtained by writing to
the known-safe consoles first.  If, for example, there is a
persistent-memory store available, messages are put there before being sent
to physical devices, once again preserving the output even if a faulty
driver kills the system.
<p>
As the session closed, Clark Williams asked whether, once the
<tt>printk()</tt> patches go upstream, Gleixner would try to push the rest
of the realtime code (which wasn't discussed in this session) in the same
merge window.  The answer was a qualified "yes"; he might try if all of the
code is staged in linux-next and seems ready to go.
<p>
[Thanks to the Linux Foundation, LWN's travel sponsor, for supporting our
travel to this event.]
<br clear="all"><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Kernel_messages">Kernel messages</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Realtime">Realtime</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2023">Linux Plumbers Conference/2023</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/951337/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor951704"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2023 14:17 UTC (Thu)
                               by <b>grawity</b> (subscriber, #80596)
                              [<a href="/Articles/951704/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; printk(), Gleixner said, is fully synchronous in current kernels; a call will not return until the message has been sent to all of the configured destinations.</span><br>
<p>
I remember when I was managing a large Linux-based gateway, and I configured serial console (over IPMI), and later I added some iptables LOG rules, and it turned out that just a few matching packets per second would DoS it because it wasn't processing any packets while waiting for each log message to go out through ttyS1...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951704/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951763"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2023 1:30 UTC (Fri)
                               by <b>areilly</b> (subscriber, #87829)
                              [<a href="/Articles/951763/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I remember a microVax that I used as an undergrad that had a real teletype set up as the (serial) console.  Had the effect of (a) rebooting the machine if it was ever accidentally turned off, and (b) halting the machine whenever it ran out of paper.  I was always amazed that the Ultrix would keep going as though nothing had happened as soon as more paper was loaded and it was put back on line.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951763/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951767"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2023 5:51 UTC (Fri)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/951767/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nothing tops the feeling when a bugcheck on vax/vms system causes all these hex dumps to be printed slowly and noisily to the paper of your hardcopy console. Physical printout and slowness signifies importance while stackdumps with hex values signify secret knowledge. This is not for mortals.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951767/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951768"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2023 6:23 UTC (Fri)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/951768/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, and of course everybody had to wait for you, while you carefully read through the secret scripture, which nobody but you could understand, until you decide to enter "b &lt;ret&gt;", which initiated thr printing of another few pages of startup messages during the next 10 minutes :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951768/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor951716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2023 16:17 UTC (Thu)
                               by <b>IanKelling</b> (subscriber, #89418)
                              [<a href="/Articles/951716/">Link</a>] 
      </p>
      
      </div>
      </summary>
      https://wiki.linuxfoundation.org/realtime/start link to latest development version patch, cloc says:

<pre>
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
diff                             1           1899           5676           8032
</pre>

That is pretty small. I've enjoyed reading about this over the years.



      
          <div class="CommentReplyButton">
            <form action="/Articles/951716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor951751"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2023 21:44 UTC (Thu)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/951751/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That has me wondering... in general, is it possible to create a protected memory space that survives rebooot?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951751/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951754"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 16, 2023 22:53 UTC (Thu)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/951754/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In general? No. You have no guarantees about the behaviour of the firmware over reboot, and it's legitimate for it to just wipe the entire contents of RAM before booting anything else. But there are specific cases where this can be guaranteed - check the various pstore backends for examples.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951754/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951762"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2023 0:47 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/951762/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Maybe something like this could preserve a range of memory? However I wouldn't know if that could be interesting in this context...<br>
<p>
<a href="https://en.wikipedia.org/wiki/Reboot#Warm">https://en.wikipedia.org/wiki/Reboot#Warm</a><br>
<p>
"The Linux family of operating systems supports an alternative to warm boot; the Linux kernel has optional support for kexec, a system call which transfers execution to a new kernel and skips hardware or firmware reset. The entire process occurs independently of the system firmware. The kernel being executed does not have to be a Linux kernel.[citation needed]"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951762/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951766"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2023 5:33 UTC (Fri)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/951766/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
kexec certainly provides a mechanism for preserving memory ranges over kernel switches, but it's not really what most people would describe as reboot<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951766/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor951856"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2023 5:36 UTC (Sat)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/951856/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It works in practice on BSD, dmesg shows the previous run’s messages as well.<br>
<p>
In practice here means x86 hardware like Thinkpads and other assorted PCs and servers whose BIOS will not overwrite the entire memory during warm reboot, as well as SPARCstations whose OpenBoot will similarily not clear the high-up memory used for the kernel log buffer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951856/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 3:20 UTC (Sun)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/951884/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
“ It works in practice on BSD, dmesg shows the previous run’s messages as well.”<br>
<p>
And surely this is only possible through the retention of data in memory over reboot!  What other magic could do this?<br>
<p>
Sorry, but I’d lay a lot of money this is done with storage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951886"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 5:15 UTC (Sun)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/951886/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How much money are you willing to hand over?<br>
<p>
<a href="https://mbsd.evolvis.org/cvs.cgi/src/sys/kern/subr_log.c?rev=HEAD">https://mbsd.evolvis.org/cvs.cgi/src/sys/kern/subr_log.c?...</a><br>
(I’m using a somewhat beefier mirror here to not get the main server slashdotted)<br>
look for initmsgbuf near the beginning of the file, which gets a pointer to the RAM region.<br>
<p>
It is called for SPARC from:<br>
<a href="https://mbsd.evolvis.org/cvs.cgi/src/sys/arch/sparc/sparc/machdep.c?rev=HEAD">https://mbsd.evolvis.org/cvs.cgi/src/sys/arch/sparc/sparc...</a><br>
(initmsgbuf called with an almost fixed (only the oldest systems avoid the first page) address…)<br>
<p>
For i386, the call is at…<br>
<a href="https://mbsd.evolvis.org/cvs.cgi/src/sys/arch/i386/i386/machdep.c?rev=HEAD">https://mbsd.evolvis.org/cvs.cgi/src/sys/arch/i386/i386/m...</a><br>
… where msgbufp comes from…<br>
<a href="https://mbsd.evolvis.org/cvs.cgi/src/sys/arch/i386/i386/pmap.c?rev=HEAD">https://mbsd.evolvis.org/cvs.cgi/src/sys/arch/i386/i386/p...</a><br>
(the __OpenBSD__ ifdef) which sets the virtual address. The physical address (MMU mapping) is done somewhere between locore.s and there, and it looks to me like its location depends on the size of the kernel image, so you’d only get the log messages if you boot the same or a very similar-sized kernel after warm reboot.<br>
<p>
And yes, it’s purely memory-based. It helps immensely in copying e.g. the remainder of a ddb(4) session (in-kernel debugger) out if you don’t have a serial console.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951886/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951887"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 5:17 UTC (Sun)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/951887/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Heh, and of course just as I posted this, the hoster fell off the ’net (including not only the hoster’s own homepage but also their status page, which is not hosted at a different site as is usual).<br>
<p>
Oh well, it’ll be back at some point.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951887/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor951896"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 18:29 UTC (Sun)
                               by <b>kreijack</b> (guest, #43513)
                              [<a href="/Articles/951896/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My understanding is that (at least in the x86 world), the memory is cleaned during the reboot.<br>
<p>
So the problem is not to find a fixed area where store the data, but avoid that this area is cleaned up during a reboot.<br>
And this cannot be done in a generic way.<br>
<p>
The kind of reboot that I am talking, is the one that allow you to exit from a "crash", so I think that we are talking about an hard reboot. And an hard reboot implies the memory cleanup.<br>
Think if this wouldn't exists: this would allow to extract from the memory some secret with a simple reboot at the "right time"; it would be a giant security hole.<br>
<p>
The pstore back-ends in the x86 are mostly two: the first one relies on the UEFI variable storage; the second one relies on the ACPI-ERST, which is like a flash memory.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951896/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 18:35 UTC (Sun)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/951898/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I’m afraid your understanding has always been wrong, then.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 18:40 UTC (Sun)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/951899/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hm, perhaps a bit more elaborating.<br>
<p>
Yes, it’s not a persistent storage like the BIOS (or EFI) settings.<br>
<p>
No, a boot does not imply memory cleaning (except for memory used during boot, of course). It usually does imply some kind of memory test, and several kinds of memory amount probing by different places in the boot process, but these are often nōn-intrusive enough to keep the memory contents.<br>
<p>
A cold boot does have empty memory simply because the memory had no power and the memory controller likewise did not refresh the memory banks.<br>
<p>
A warm reboot does not have a period of such, so the memory is *usually* retained.<br>
<p>
A hard reboot can fall into either category, depending on how it is executed and wired. The usual power button long-press will be a poweroff followed by a mostly-cold boot; a watchdog reboot, or if the kernel crashed but is still able to reboot-ish (even if just by causing a triple-fault) can be warm reboots (this mostly depends on the memory controller to continue refreshing the memory during that, and of course the firmware not overwriting it).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor952028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2023 19:57 UTC (Mon)
                               by <b>kreijack</b> (guest, #43513)
                              [<a href="/Articles/952028/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; A warm reboot does not have a period of such, so the memory is *usually* retained.</span><br>
<p>
I think that the key word is "*usually*". On my UEFI system I build a UEFI program that dump the first 4 bytes of the following address:<br>
- 3GB<br>
- 7GB<br>
- 14GB<br>
<p>
Then it sets these bytes to a specific value, and then it dump again.<br>
<p>
What I saw is:<br>
1) the first time that I run the program, I saw "random values", like 0 and other non 0 values.<br>
2) the 2nd time that I run the program, I saw the same values that I set in the first iteration.<br>
<p>
This proof that UEFI doesn't reset the memory between different program invocation.<br>
<p>
Then I "warm rebooted" the system, and I saw the "random values" at 1). So it seemed that in my system the memory is cleared between the reboot.<br>
<p>
What I'm telling is that at least some bios clears the memory. In may case (a ASUS B550 desktop mainboard) it seems that the BIOS clear the memory.<br>
<p>
What I found is that it is possible to force the BIOS to not clear the memory after a reset [1]. But again this is not typically what happens after a crash; after a crash you push the reset physical buttons.<br>
<p>
<p>
<p>
[1] <a rel="nofollow" href="https://stackoverflow.com/questions/36608101/does-a-soft-reset-in-x86-32-bit-clear-ram-after-reset">https://stackoverflow.com/questions/36608101/does-a-soft-...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor952160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2023 23:31 UTC (Tue)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/952160/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, that’s precisely what I meant with “usually”: a sufficient amount of systems keeps sufficient amounts of memory alive to make this feature worth being in existence, even if counter-examples exist and no spec supports this usage.<br>
<p>
The reset button as the only way out of a crash is such a PC thing though. Some machines have watchdogs, and some have something like ddb(4) on BSD or SysRq on Linux that allow for warm reboots even in the face of a crash.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor951888"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 5:40 UTC (Sun)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/951888/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It works as long as your firmware behaves in a specific way, something no specification requires of it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951888/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 18:22 UTC (Sun)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/951897/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, of course. Which is why I said that “it works in practice”: it works on a sufficiently large array of machines that OpenBSD (and probably NetBSD before) chose to implement it so, and even if it doesn’t work on one machine it’s no big loss.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor951890"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 9:40 UTC (Sun)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/951890/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In my expierience, pstore is the only reliable way to get a stack trace on panic, unless one is in a VM.  Serial consoles don’t work because end-user systems don’t have them.  Graphical consoles don’t work because the user is in an X11 or Wayland session.<br>
<p>
How does Windows manage to display the BSOD message?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951890/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951892"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 14:10 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/951892/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; How does Windows manage to display the BSOD message?</span><br>
<p>
I guess it just seizes control of the graphics card, or puts it into text mode, or whatever.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951892/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor951901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 20:38 UTC (Sun)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/951901/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It displays the BSOD at start up, and then prints the normal screen as an overlay on top of it. This way, when something goes wrong, the overlay disappears and you see the BSOD. That is why the option "customize the BSOD" requires you to reboot. That is also why, if you set the background to an image with transparency, you get the BSOD.<br>
<p>
(just jocking of course)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor951903"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 21:07 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/951903/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  How does Windows manage to display the BSOD message?</span><br>
<p>
Windows drivers are much more resilient than the drivers in Linux. A surprising amount of functionality remains working in Windows even if half the kernel is going haywire.<br>
<p>
In particular, modesetting and simple framebuffer access have always been a part of the kernel driver. And each driver is also responsible for pre-allocating its object pools, so there's much less dependency on memory allocation. The IRQL system also has a side effect of forcing driver writers to avoid putting anything too involved inside the critical pathways.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951903/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor954135"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2023 17:45 UTC (Fri)
                               by <b>pawel44</b> (guest, #162008)
                              [<a href="/Articles/954135/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wishful thinking. USB driver failure will bring Windows down. Not to mention Windows Driver Model and Windows Driver Frameworks are holey like Swiss cheese.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/954135/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor952630"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The real realtime preemption end game</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 24, 2023 21:06 UTC (Fri)
                               by <b>mtthu</b> (subscriber, #123091)
                              [<a href="/Articles/952630/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This would maybe be doable if you have control over all stages of the boot process and the environment the kernel runs in. I guess it would be easier to be introduced in virtualized environments as a memory region could be mapped into a file on the host where it could be synced to disk before a restart. Memory integrity could be checked on that level as well, for example for the case that the host has an uncontrolled reboot.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952630/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
