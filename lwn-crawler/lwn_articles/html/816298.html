        <!DOCTYPE html>
        <html lang="en">
        <head><title>A full task-isolation mode for the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/816298/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/816654/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/816298/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A full task-isolation mode for the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="GAByline">
           <p>April 6, 2020</p>
           <p>This article was contributed by Marta Rybczyńska</p>
           </div>
<p>Some applications require guaranteed access to the CPU without even
brief interruptions; realtime systems and high-bandwidth networking
applications with user-space drivers can fall into the category.
While Linux provides some support for CPU isolation 
(moving everything but the critical task off of one or more CPUs)
now, it is an
imperfect solution that is still subject to some interruptions.   Work has
been continuing in the 
community to improve the kernel's CPU-isolation capabilities, notably with 
improvements in the nohz (tickless) mode, but it is not finished yet.
Recently, Alex Belits <a
href="/ml/linux-kernel/aed12dd15ea2981bc9554cfa8b5e273c1342c756.camel@marvell.com/">submitted
a patch set</a> (based on <a
href="/Articles/659490/">work by Chris  
Metcalf in 2015</a>) that introduces a completely predictable environment for
Linux applications &mdash; as long as they do not need any kernel
services.</p>

<h4>Nohz and task isolation</h4>

<p>Currently, the <a href="/Articles/549580/">nohz
mode</a> in Linux allows partial task isolation. It decreases the
number of interrupts that the CPU receives; for example, the clock tick
interrupt is disabled for nearly all CPUs. However, nohz does not
guarantee there will be no interruptions; the running task can still be
interrupted by page faults (careful design of an application can avoid
that) or delayed workqueues. The advantage of this mode is that the
tasks can run regular code, including system calls. In addition to
that, any additional overhead is limited to the system-call entry and exit
paths.</p>

<p>For some applications, the lack of absolute guarantees from nohz may cause
problems. As an example, high-performance, user-space network drivers
that have a <a href="/Articles/629155/">small
number of CPU cycles in which to handle each packet</a>; for those, interrupt and interrupt
handling may cause a significant delay in their response and use up to
the entire time available. Realtime
operating systems (RTOSes) can provide the needed guarantees, but they have
limited 
hardware support; the authors of the patch feel that it is less work
to develop and maintain interrupt-free applications than to support a
RTOS next to Linux, as Belits <a
href="https://lwn.net/ml/linux-kernel/4473787e1b6bc3cc226067e8d122092a678b63de.camel@marvell.com/">explained</a>:</p>

<div class="BigQuote">
    The alternative, running RTOS instead of Linux, is becoming more
    and more labor-consuming because modern CPUs and SoCs have very
    complex device/resource configuration and management procedures,
    and at this point for some hardware it is clearly in the realm
    of impractical to maintain an RTOS with hardware support on par
    with Linux kernel, reliable and secure at the same time.
</div>

<p>In these times, even embedded systems often contain a number of cores,
and system 
designers are adding more for tasks requiring predictability.
Belits explained that further:</p>
<p>
<div class="BigQuote">
    Therefore OS ability to switch a CPU core into RTOS-ish mode [...]
    is an important feature for modern embedded systems development.
    Probably more important than even real-time interrupts latency
    and preemption, now that people, when they don't like how their
    interrupts are handled, can just add CPU cores.
</div>

<p>

The kernel currently has a couple of features meant to make it possible to
run applications without interruptions: nohz (described above) and CPU
isolation (or "isolcpus").  The latter feature isolates one
or more CPUs — making them unavailable to the scheduler and only accessible
to a process via an explicitly set affinity — so that any processes running
there need not compete with the rest of the workload for CPU time.
These features reduce interruptions on the isolated CPUs, but do not fully
eliminate them; task isolation is an attempt to finish the job by removing
<i>all</i> interruptions.
A process that enters the isolation mode will be able to run
in user space with no interference from the kernel or other processes.</p>

<h4>Configuring and activating task isolation</h4>

<p>The authors assume
that isolation is not needed in kernel space or during the
task's initialization phase. A task enters the isolation mode at some point 
in time and stays in this mode until it leaves the isolation on its
own, performs some action that causes the isolation to be broken, or
receives a signal that was directed to it.</p>

<p>The kernel needs to be compiled with the
<tt>CONFIG_TASK_ISOLATION</tt> flag and then booted with the same
options as for nohz mode with CPU isolation:
<p>
<pre>
    isolcpus=nohz,domain,CPULIST
</pre>
<p>
where <tt>nohz</tt> disables the
timer tick on the specified CPUs, <tt>domain</tt> removes the CPUs
from the scheduling algorithms, and <tt>CPULIST</tt>
is the list of CPUs where the isolation options are applied. Optionally,
the <tt>task_isolation_debug</tt> kernel 
command-line option causes a stack backtrace when a task loses
isolation.</p>

<p>When a task has finished its initialization, it can activate
isolation by using the <tt>PR_TASK_ISOLATION</tt> operation provided by the
<tt><a
href="http://man7.org/linux/man-pages/man2/prctl.2.html">prctl()</a></tt>
system call.  This operation may fail for
either permanent or temporary reasons. An example of a permanent error is
when the task is set up on a CPU without isolation; in this case, entering
isolation mode is not possible. Temporary errors are indicated by the
<tt>EAGAIN</tt> error code; examples include a time when the delayed
workqueues could not be stopped. In such cases, the task may retry the
operation if it wants to enter isolation, as it 
may succeed the next time.</p>

<p>In the <tt>prctl()</tt> call, the developer may also configure the
signal to be sent to the task when it loses isolation. The additional
macro to use is <tt>PR_TASK_ISOLATION_SET_SIG()</tt>, passing it
the signal to send. The command then becomes similar
to the one in the <a
href="https://github.com/abelits/libtmc/blob/feb17688baa9680fad3cdb2dff16c0a47d86f6b4/isol.c#L896">example  
code</a>:</p>

<pre>
    prctl(PR_SET_TASK_ISOLATION, PR_TASK_ISOLATION_ENABLE
          | PR_TASK_ISOLATION_SET_SIG(SIGUSR1), 0, 0, 0);
</pre>

Here, the process has requested the receipt of a <tt>SIGUSR1</tt> signal
rather than the default <tt>SIGKILL</tt> 
should it lose isolation.
<p>
<h4>Losing isolation</h4>

<p>The task will lose isolation if it enters kernel space 
as the result of a system call, a page fault, an exception, or an
interrupt.  The (fatal by default) signal will be sent when this happens,
with a couple of exceptions: a <tt>prctl()</tt> call to turn off
isolation, or <tt>exit()</tt> and <tt>exit_group()</tt>; these calls
cause the task to exit, so the isolation mode is finished at that
point.</p>

<p>When the task loses isolation by any means other than the above system
calls, it will receive a signal, <tt>SIGKILL</tt> by default, which causes termination of the task. The
signal can be modified, in the case the application prefers to catch
it. This can be used, for example, if an application wants to log the
information about lost isolation before exiting or attempt to rerun the
code without isolation guarantees.</p>

<p>The task can enter and exit isolation when it desires. To leave
isolation without a signal it should call:</p>
<pre>
    prctl(PR_SET_TASK_ISOLATION, 0, 0, 0, 0);
</pre>

<h4>The internals</h4>

<p>
When a process calls <tt>prtcl()</tt> to enable task isolation, it is
marked with the <tt>TIF_TASK_ISOLATION</tt> flag in the kernel.
The main part of the job of setting up task isolation, though, is done when
returning from the <tt>prctl()</tt>. When the kernel 
returns to user space and sees the <tt>TIF_TASK_ISOLATION</tt>
flag set, it arranges for the task not to be interrupted in the
future.  Interrupts are disabled, and the kernel disables any
events that may interrupt the isolated CPU(s). In current patches, it
disables the 
scheduler's clock tick and vmstat delayed work, and drains pages out of
the per-CPU pagevec to avoid inter-processor interrupts (IPIs) for cache
flushes. More isolation actions may be added in the future.</p>

<p>This isolation work is more straightforward in the current version
than it was in the 2015 patch set.  Since then, Linux has gained the
ability to offload timer ticks from the isolated CPUs to so-called
"housekeeping" CPUs &mdash; all that are not on the CPU list of the
<tt>isolcpus</tt> kernel option. That removes the need to make additional
requirements for dealing with pending timers on CPUs before they can be
isolated. 

<p>The patch set also adds diagnostics on the non-isolated CPUs. If the
kernel finds itself
about to interrupt an isolated CPU, it will generate diagnostics
(a warning in the kernel log by default, but a stack dump is also possible) on the interrupting
CPU. Examples of such situations include sending an IPI or TLB
flush. If an interrupt is not handled by Linux, for example a
hypervisor interrupt, it can end up sending a reschedule IPI to an isolated
CPU, causing  the signal to notify the isolated task to be generated. With
regard to that problem, Frédéric Weisbecker <a
href="https://lwn.net/ml/linux-kernel/20200305183313.GA29033@lenoir/">wondered</a>
if  support for hypervisors is even necessary, but no conclusion has
been reached on this topic.</p>

<p>The task-isolation mode requires changes in the architecture code;
the patch set includes implementations for x86, arm, and arm64. An
architecture needs to define <tt>HAVE_ARCH_TASK_ISOLATION</tt> and the
new <tt>TIF_TASK_ISOLATION</tt> task flag. It needs to change its
interrupt and page-fault entry routines to add a call to
<tt>task_isolation_interrupt()</tt> so that any isolated tasks will exit
isolation. The reschedule IPI should call
<tt>task_isolation_remote()</tt> for the same purpose. Finally the
system-call code should invoke <tt>task_isolation_syscall()</tt> to
check if the call is allowed. When exiting to user space it should
call <tt>task_isolation_check_run_cleanup()</tt> to run pending
cleanup and <tt>task_isolation_start()</tt>  if the
isolation flag is set for the current task.</p>

<p>Apart from the changes in the architecture-specific code, adding
the isolation feature caused several changes in other kernel subsystems.
For example, in the network code, <tt>flush_all_backlogs()</tt> will
enqueue work only on non-isolated CPUs.  The trace ring buffer behaves on
isolated CPUs in a similar way to offline ones &mdash; any updates will
be done when the task exits isolation. Another change in the isolation
mode is that  kernel jobs are scheduled on housekeeping CPUs only.
This includes tasks like probing for PCIe devices.  Finally,
<tt>kick_all_cpus_sync()</tt> has been modified to avoid scheduling
interrupts on CPUs with isolated tasks.  Weisbecker <a
href="/ml/linux-kernel/20200306153446.GC8590@lenoir/">did
not agree</a> with this approach and <a
href="/ml/linux-kernel/20200309022829.GB9615@lenoir/">listed
a number of race conditions</a> that may happen between this function
and the task entering isolation. He suggested fixing the callers
instead.</p>

<h4>Summary</h4>

<p>The patch set has received initial favorable reviews and it seems
that this feature is of interest to developers. There are still some
unresolved comments to be addressed and some patches did not receive
a review yet. The patch set changes some basic kernel functions in a
subtle way, so there will surely be questions asked about testing of
the feature. In addition, of course, to the possible regressions.
When those issues are resolved, it will likely be included in one of
the upcoming kernel releases.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Scheduler">Scheduler</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Rybczynska_Marta">Rybczynska, Marta</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/816298/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor816923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2020 21:43 UTC (Mon)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/816923/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
About time.<br>
<p>
But instead of the isolated process needing to call prctl(), it should happen automatically, for any process running on (and, by inference, bound to) an isolated CPU, after no system calls / page faults have occurred for a few milliseconds. The prctl() call should be needed only if that wouldn't be soon enough.<br>
<p>
Also, "nohz" and "domain" should be _the_default_ on any isolcpu. I am not going to isolate a core, yet still want a load of crap interruptions sent to it. I isolated it for reasons. If I want interruptions I can ask for them.<br>
<p>
Files that are mapped to an isolated process image (and the file descriptor closed) should never, ever cause the process to be blocked, even if the kernel decides it is time to copy changes in mapped memory to the spinny disk image. If tearing would be a problem, it is the process's problem to solve.<br>
<p>
Finally, taskset should be able to designate, _all_by itself_, that the core the process is bound to is to be fully isolated. This business of needing to reserve isolcpus at boot time is nonsense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2020 23:04 UTC (Mon)
                               by <b>martin.langhoff</b> (subscriber, #61417)
                              [<a href="/Articles/816929/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Gotta walk before you run, but long term I completely agree.<br>
<p>
Ideally this feature evolves towards essentially being as automagic as possible... <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816933"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2020 23:18 UTC (Mon)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/816933/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OK, but sensible defaults for isolcpus is no more work than crazy defaults.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816933/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor816932"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 6, 2020 23:15 UTC (Mon)
                               by <b>f18m</b> (guest, #133856)
                              [<a href="/Articles/816932/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I fully agree with ncm: what's the sense of isolating a CPU core other than the need of using it without any sort of interrupt to emulate a real-time OS ?<br>
<p>
However I'm unsure whether having the kernel deciding that a taskset should be "fully isolated" after a few milliseconds of zero-system-calls... <br>
<p>
Anyway this patch set would be greatly useful to e.g. DPDK applications, which are mostly often using isolcpus and nohz options already.<br>
Looking forward for it!<br>
<p>
I'd also love to have this RTOS-like as a post-boot option somewhere (maybe a sysctl setting?) rather than being forced to create scripts that must interact with the bootloader (GRUBv1, GRUBv2, etc) to deploy a new Linux boot option... moreover the reboot required to apply this change may not be acceptable in some contexts...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816932/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816939"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 1:13 UTC (Tue)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/816939/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
“Soft” isolation is still useful for HPC work, where you'd like to have something stronger than SCHED_BATCH, but nobody's going to end up taken away in an ambulance if it only gets 99.99% of the CPU.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816939/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor816936"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 0:07 UTC (Tue)
                               by <b>erkki</b> (guest, #124843)
                              [<a href="/Articles/816936/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Preventing TLB shootdowns due to writeback of file backed mmaps would really interesting. Maybe through a new mmap flag?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816936/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 1:44 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/816941/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
TLB shootdowns are the least of the problem. I see multi-millisecond pauses caused by the behavior in question. Such files have to live in a tmpfs, shmfs, or the like, and snapshots of the stats normally kept in them have to be produced by copying to another file in the same fs, and then out, to prevent pathological stalls.<br>
<p>
The core that is busy writing out the page necessarily generates contention on the isolated core's cache bus, as dirty cache lines are copied out of it, but no TLB shenanigans ought to be needed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor816944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 3:18 UTC (Tue)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/816944/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I’m afraid this can’t really be done.  Suppose CPU A runs an isolated task and writes to a mapped page.  Now CPU A has a writable dirty TLB entry for the page.<br>
<p>
Then CPU B starts writeback.  Subsequently,  CPU A writes to the page again.<br>
<p>
Without a TLB flush, the kernel has no way to know that the page has been dirtied again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 10:07 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/816948/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is no reasonable expectation of coherence anyway, because there is no sychronization available. It will get dirty again, and get copied out again, later.<br>
<p>
If I wanted it clean, I would do something else and take the hit. The whole point of isolcpus is not to stall. If it takes a stall to get magickal feature X, it means I don't want magickal X. Just give me whatever approximation to X can be done without stalling.<br>
<p>
Isolcpus: not want stalls. What is not clear?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor817023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 22:35 UTC (Tue)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/817023/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In your model, if an isolcpus task maps a file writably, the kernel will have to write back every mapped page every 30 seconds or so regardless of whether it’s written. Or, at least, every page that has ever been written.  I don’t think this is wise.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/817023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor817024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 23:45 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/817024/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok, thank you. It sounds like the multi-millisecond stall is not necessary, but flushing the TLB entry for the page is.<br>
<p>
In practice, though, a mapped stats file will *always* be dirty, no matter how frequently it is flushed. Maybe what we need is an mmap flag to tell the kernel that it should always assume a given mapping is dirty, and should skip the dance of checking. At least mmap flags are discoverable, unlike (e.g.) ioctls.<br>
<p>
Mapping from an unbacked fs and copying from there works, but is a deployment problem. The user wants the stats file where they want it, and it is not easy to discover whether the place they want it is backed.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/817024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor817025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 8, 2020 2:01 UTC (Wed)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/817025/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could have a little daemon that periodically copies the file from tmpfs to the real backing store and have the isolated code write to tmpfs.<br>
<p>
Years ago, I worked a little bit on reducing the stalls from writing to a recently written-back mmapped file.  I made some progress but never upstreamed it.  Some day I'll finish the job.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/817025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor817087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 9, 2020 0:30 UTC (Thu)
                               by <b>erkki</b> (guest, #124843)
                              [<a href="/Articles/817087/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Right, that makes sense. At least the kernel could allow for writeback without guaranteeing per page atomicity. In that case writeback CPU and the isolated CPU can operate on the page concurrently. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/817087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor816938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 1:09 UTC (Tue)
                               by <b>gus3</b> (guest, #61103)
                              [<a href="/Articles/816938/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This could be an exploit waiting to happen.<br>
<p>
Scenario: a multi-core system with N cores. What's to stop a process from forking N times, then each process isolating itself? Perhaps the Nth isolation attempt will fail, but now, you have N-1 isolated processes, and the last core is saturated as if running on a single-core system.<br>
<p>
Does this now provide a new opportunity to use Meltdown/Spectre-style exploits against N-1 non-isolated processes?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor816940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 1:34 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/816940/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Claiming a core for isolation would reasonably require a capability normally provided only to root.<br>
<p>
Systems that configure isolated cores are rarely shared between organizations, although that will probably change as it becomes increasingly impractical to run without.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor816943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 2:18 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/816943/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, why use SIGKILL, and then provide a back-door way to change it to some other signal, instead of using one of the numerous other defaults-to-terminate, or even defaults-to ignore, signals? That seems like complexity for the sake of complexity. Even inventing a new signal number for the purpose would be simpler.<br>
<p>
Using a defaults-to-ignore signal would be more compatible with an eventual goal of automatic task isolation for programs that spin. If you want to drop core if your program violates isolation, a handler is the right way to make it happen. We don't need another.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor816949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 13:07 UTC (Tue)
                               by <b>caliloo</b> (subscriber, #50055)
                              [<a href="/Articles/816949/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder how this interacts with the new system calls that can be placed on a buffer ring, sounds to me like you’d be able to place system calls without leaving isolation, which is kind of nice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/816949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor817004"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 14:52 UTC (Tue)
                               by <b>liralon</b> (guest, #124426)
                              [<a href="/Articles/817004/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems to me that raising a fatal signal to the isolated task (which will kill it) when the task invokes a system call is an issue.<br>
<p>
It should be quite common for a fast-path running as an isolated task, to use a system call to wake-up some slow-path. For example, GCP Andromeda (<a href="https://www.usenix.org/system/files/conference/nsdi18/nsdi18-dalton.pdf">https://www.usenix.org/system/files/conference/nsdi18/nsd...</a>) use system calls to wake-up the coprocessor thread or set irqfd (To raise a virtual interrupt to guest).<br>
<p>
I would have expected instead, that the fatal signal will be raised to the isolated task when the kernel will reach some code that is about to block the task. E.g. wait for completion of some I/O request or sleep until some eventfd is set.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/817004/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor817009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 7, 2020 17:03 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/817009/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What would it take to eliminate the periodic wakeups for vmstats entirely, not just on isolated CPUs but in general? That seems like something the kernel could account for incrementally as it performs operations, and then just sum up when something wants the statistics.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/817009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor817334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 12, 2020 16:57 UTC (Sun)
                               by <b>dave4444</b> (guest, #127523)
                              [<a href="/Articles/817334/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<p>
Looks like some good progress here, but what about events that may (or may not) be out of the control of the kernel?  Such as:<br>
<p>
SMM/SMI/NMI on that CPU, this may not be preventable, but could it be detected?<br>
<p>
ECC errors can cause very unpredictable slowdowns (especially correctable ones).<br>
<p>
Some applications require more than just a CPU core's resources to itself, memory contention (L3, or beyond), common IO paths etc...  can produce slow or even starved applications.  Another app on another core can hog and consume L3 and DRAM bandwidth at the detrement to others for example.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/817334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor817600"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2020 18:43 UTC (Wed)
                               by <b>jithu83</b> (guest, #134793)
                              [<a href="/Articles/817600/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Some applications require more than just a CPU core's resources to itself, memory contention (L3, or beyond), common IO paths etc... can produce slow or even starved  applications. Another app on another core can hog and consume L3 and DRAM bandwidth at the detrement to others for example.</font><br>
<p>
<p>
X86_CPU_RESCTRL  kernel config option does provide some fine grained control over memory bandwidth, L2/L3 cache  partitioning/locking etc. This is available only on certain newer processors and requires additional effort to correctly provision these to the appropriate process etc<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/817600/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor828493"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A full task-isolation mode for the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 11, 2020 0:46 UTC (Tue)
                               by <b>rezete22</b> (guest, #140723)
                              [<a href="/Articles/828493/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hello <br>
<p>
Any update on this patchset. Is it pushed upstream? Which version of Linux works with this patchset?<br>
<p>
R/<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828493/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
