        <!DOCTYPE html>
        <html lang="en">
        <head><title>BPF as a safer kernel programming environment [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/909095/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/909008/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/909095/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>BPF as a safer kernel programming environment</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="GAByline">
           <p>September 23, 2022</p>
           <p>This article was contributed by David Vernet</p>
           <hr>
<a href="/Archives/ConferenceByYear/#2022-Linux_Plumbers_Conference">LPC</a>
</div>
<p>For better or worse, C is the <i>lingua franca</i> in the world of kernel
engineering. The core logic of the Linux kernel is written entirely in
C (with a bit of assembly), as are its drivers and modules. While C is
rightfully celebrated for
its powerful yet simple semantics, it is an older language that lacks
many of the features present in modern languages such as
<a href="/Articles/907685/">Rust</a>. The
<a href="/Articles/599755/">BPF</a> subsystem, on the other hand,
provides a programming environment that allows engineers to write
programs that can run safely in kernel space. At the <a
href="https://lpc.events">2022 Linux Plumbers 
Conference</a> in Dublin, Ireland, Alexei Starovoitov presented an overview
of how BPF has evolved over the years to provide a new model for kernel
programming.

<h4>The mission of BPF</h4>

<p>Starovoitov began by describing his "mission statement" for BPF:
"To innovate and enable others to innovate".
Programming in the kernel has historically taken place in one of two
contexts:

<ul>

<li> 
<p><em>Core kernel programming</em>, which includes major core subsystems such
as the memory manager, the scheduler, read-copy-update, and more.

</li>

<li> 
<p><em>Kernel-module programming</em>, which refers to building objects that
are not compiled into the main kernel image, and which are, instead, loaded by
the module loader at a later time. For example, drivers are
written as kernel modules, as are other features, such as filesystems,
network protocols, and more.
</li>
</ul>
<p>This was the state of the kernel for a long time, until the initial
extended BPF (eBPF) virtual machine was added to the kernel in version
3.15. With this, BPF programs could be written in a highly restrictive
version of C that was compiled into BPF bytecode and which would
allow users to write code that is verifiably safe to run in kernel
space.

<a href="/Articles/907943/"><img
src="https://static.lwn.net/images/conf/2022/lpc/AlexeiStarovoitov-sm.png" alt="[Alexei
Starovoitov]" title="Alexei Starovoitov" class="rthumb"></a>

<p>Since then, BPF has steadily grown both in terms of the size of the
code  and in the size of the community of users and
contributors. According to Starovoitov, email 
traffic reaches 50-70 messages being received every day on the BPF mailing
list and approximately 2000 emails being received per month. The number
of active monthly contributors to BPF has grown in tandem as well,
reaching approximately 140 as of September 2022.  At this point, a majority
of the contributions to the BPF subsystem come from outside the Meta BPF
group.

<h4>The BPF programming environment</h4>

<p>While most BPF programs are written in C and compiled with the LLVM Clang
compiler, BPF
programs are just binary BPF bytecode object files, and do not need to
be written in a particular language. For example, BPF programs can be
written in Rust using <a href="/Articles/859784/">Aya</a>, or even
directly in BPF assembly language. That said, C is the canonical
programming language for BPF programs; Starovoitov’s presentation
continued with an overview of how the C programming environment has
evolved for BPF programs.

<p>This new programming environment is implemented with a combination of
C language extensions and a runtime environment featuring
collaboration between Clang, the user-space BPF loader library (libbpf),
and the BPF subsystem in the kernel. To create a BPF program, the user
writes a program in a C language which is emitted as <a
href="https://docs.kernel.org/bpf/instruction-set.html">BPF
instructions</a> by a
Clang backend implementation. In order to run a program, libbpf loads
the BPF program into memory, performs relocations on the program to make
it portable across platforms and different kernel versions, and then
calls into the kernel to load the program. Finally, in the
kernel, the verifier statically verifies that the program is safe to
run, and then enables it.

<p>The BPF programming environment was not always so rich, however. In the
early days of BPF, programs were required to use what Starovoitov called
"restricted C". All functions in a BPF program had to be fully inlined,
loops, static and global variables, and memory allocations were
all disallowed. There was also no type information, so BPF programs
could only receive a single, fixed input context for tracing and
network-filtering functions.

<p>While it was useful to write BPF programs even in such a highly
restrictive environment, it was clear that there was significant
opportunity to extend the use cases supported by BPF. One such extension
was allowing static functions in BPF programs. Doing so required using
libbpf to perform relocations in kernel BPF
programs at program load time. Support for
<a href="/Articles/794934/">bounded loops</a> was eventually added
after years of designs and attempts, as were iterators.

<h4>Extending the programming environment past full C</h4>

<p>While this brought BPF closer to full C support, it eventually became
clear that BPF programs required features that were not available even
in the full C language standard. It was at this point that the BPF
community began to extend the BPF programming environment to include new
features that distinguished it from traditional C. One of those
extensions is Compile Once - Run Everywhere (CO-RE).

<p>CO-RE makes BPF programs portable across different
kernel versions and platforms. It is common in BPF programs to access
kernel data structures. The kernel provides no ABI guarantees
for struct layouts, however, so a BPF program doing a read at a static
offset into a kernel structure could read the wrong value if that
structure changes in a future version or a different configuration
of the kernel. CO-RE addresses this by leveraging the
<a href="https://docs.kernel.org/bpf/btf.html">BPF Type Format (BTF)</a>
data present in
the running kernel. When a program is loaded, libbpf performs
relocations for all struct accesses so that the
fields being accessed match the offsets of the fields according to the
BTF information of the currently running kernel.

<p>Starovoitov described a number of other interesting extensions to the
BPF programming environment as well. One such feature is
<a href="/Articles/900749/">kptrs</a>, which allows pointers to
kernel memory to be stored in BPF maps. Another is allowing programs to
access kernel-configuration parameters at load time.
Kernel modules can only use the configuration values that were set when
they were compiled, but BPF programs can adjust to the current kernel's
configuration when they are loaded.  Yet another
feature is "type tags", which allow programs to annotate variables to
describe how they’re meant to be used. For example, kptrs can
be annotated with <tt>__kptr</tt> and <tt>__kptr_ref</tt> type tags to show
that
they’re either unreferenced or referenced kptrs respectively.
Eventually, pointers may similarly be annotated with <tt>__user</tt> or
<tt>__percpu</tt> to tell the compiler and the verifier that they point to user
memory or per-CPU memory respectively.

<h4>Plans for the future</h4>

<p>More extensions are currently being designed and implemented as well,
including lock-correctness verification and allowing BPF programs to
include assertions. Lock verification would seem at first glance to be a
difficult problem to solve, though Dave Marchevsky and Kumar Kartikeya
Dwivedi have both already sent out RFC patch sets for new map types with
verified locking. 
<a
href="/ml/bpf/20220722183438.3319790-1-davemarchevsky@fb.com/">Marchevsky’s
patch set</a> proposes a new red-black-tree map type, whereas 
<a
href="/ml/bpf/20220904204145.3089-1-memxor@gmail.com/">Dwivedi’s patch
set</a>
proposes a list map type. Both patch sets implement semantics that allow
BPF programs to perform locking which is checked and validated by the
verifier.

<p>Assertion verification is still in the planning phase, and will
potentially be complex to implement. Assertions will serve as a
signal to both the compiler and the verifier, with assertions being used
to indicate some invariant in the program whose failure should cause the
program to abort. Starovoitov claimed that figuring out how to implement
program abort would be a "fun" problem, as it requires safe stack
unwinding, invoking kptr destructors, and possibly more.

<p>Starovoitov concluded his presentation by sharing his vision for the
future of BPF: replacing kernel modules as the de-facto means of
extending the kernel. Whereas the early versions of BPF programs looked
more like user-space programs with fixed sets of BPF helper functions
and fixed map types, the new BPF allows users to extend the kernel in
ways that fit more individualized use cases. Such use cases have in fact
already been proposed in the upstream community. Benjamin Tissoires, who
spoke at LPC following Starovoitov, has been iterating on a
<a
href="/ml/bpf/20220902132938.2409206-1-benjamin.tissoires@redhat.com/">patch
set</a>
that allows human-input device (HID) quirks to be fixed with BPF
programs. No kernel 
module has fully been replaced by a BPF program as of yet, though it
will be interesting to see what other parts of the kernel can be
implemented in BPF programs moving forward.

<p>An audience member asked for more details
on the lock-correctness verification that Starovoitov had alluded to.
Starovoitov said it was still a work in progress, but that he was
optimistic that 
a way to do static lock checking that verifies
proper data protection and guarantees that no deadlocks can occur could be
found. Dave
Miller responded that, if locks could be statically checked by the
verifier, it may be worth investigating whether the locking logic could
be automatically <i>generated</i> by the verifier. Starovoitov responded that
this was what they were hoping to achieve, with the current design
aggregating locks and the data under protection as part of the same
allocation. For data that cannot be aggregated with a
lock, a BTF Type tag could be used to specify that it needs explicit lock
protection.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#BPF">BPF</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Vernet_David">Vernet, David</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2022">Linux Plumbers Conference/2022</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/909095/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor909248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 17:18 UTC (Fri)
                               by <b>mdaverde</b> (guest, #151459)
                              [<a href="/Articles/909248/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I'm excited for the future that's laid out by ast. It feels like a new primitive has been added to the kernel where the value that is to be unlocked on top of it is still unknown but leans powerful. 


One aspect I will be critical in is that if that is the stated "mission statement" then a lot of work has to be done outside of core kernel technical work to allow others to innovate. Hopefully the eBPF foundation can successfully foster a community around documentation, tooling, standardization in an accessible way. 




      
          <div class="CommentReplyButton">
            <form action="/Articles/909248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor909266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 19:11 UTC (Fri)
                               by <b>gray_-_wolf</b> (subscriber, #131074)
                              [<a href="/Articles/909266/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Given all the work on making eBPF more powerful (and portable between kernel versions), can we expect new wave of proprietary closed-source kernel modules, but this time implemented as eBPF programs?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 22:17 UTC (Fri)
                               by <b>tux3</b> (subscriber, #101245)
                              [<a href="/Articles/909289/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;ve seen one instance already. Crowdstrike has a thoroughly closed-source endpoint surveillance sensor program that until now relied on a kernel module to do most of the snooping and hooking. This involves them shipping about 800MB of kernel modules binaries in an .xz archive, one for every supported system under the sun. And of course it breaks if you update your system.<br>
They&#x27;re apparently giving up on maintaining their module and planning to replace it with eBPF, even if that currently means losing some functionality.<br>
<p>
I suspect the main limitation to a wave of proprietary eBPF programs is that it&#x27;s still pretty far from parity with a full blown module. For vendors that don&#x27;t mind the loss (or that can do everything in eBPF), I suppose we&#x27;ll have to see how much worse the eBPF binary blobs are to deal with than the binary modules. <br>
<p>
My hope is that decompilers will eventually handle eBPF bytecode as well if not better than compiled C. At the end of the day this could even be a slightly lesser evil for end-users, if it turns out that the blobs are easier to reverse.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2022 15:12 UTC (Sat)
                               by <b>gray_-_wolf</b> (subscriber, #131074)
                              [<a href="/Articles/909325/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I suspect the main limitation to a wave of proprietary eBPF programs is that it&#x27;s still pretty far from parity with a full blown module.</font><br>
<p>
If that is indeed the case, I must say I&#x27;m unhappy about it from the freedom point of view :/<br>
<p>
I know that kernel does have some functions exposed only for GPL-licensed modules, at least that is my understanding. Is something similar also in the eBPF or there every program has everything available, regardless of licensing?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2022 15:19 UTC (Sat)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/909327/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Most symbols (including all kfuncs as I understand it) for BPF programs are GPL-only.  Of course, the kernel has to trust a BPF program that declares itself to be GPL-licensed, but the situation is no different that for modules in that regard.


      
          <div class="CommentReplyButton">
            <form action="/Articles/909327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor909309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2022 7:23 UTC (Sat)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/909309/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So, BPF and eBPF are still restricted to bounded loops — no infinite loops, and no recursion? In other words they are not Turing complete. (This is not a criticism, just want to clarify.)<br>
<p>
In a way the use of BPF to replace kernel modules reminds me of Firefox extensions moving from the original C++ compiled blobs to JavaScript. And that suggests that in some cases BPF might be useful as an extension language in user space. I don’t think it will ever replace JavaScript for web browsers but maybe for in-house use? Like how Emacs has a core in C and the rest in Lisp. For soft real-time applications you might want to guarantee that the non-core code can never hang or get stuck in a loop. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2022 8:05 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/909312/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So, BPF and eBPF are still restricted to bounded loops — no infinite loops, and no recursion? In other words they are not Turing complete. (This is not a criticism, just want to clarify.)</font><br>
<p>
I believe that is in the language specification - a program must complete in bounded time or fail. This precludes Turing completeness ... :-)<br>
<p>
(Enforced by the checker - if it cannot solve the Halting Problem for that particular executable, it is not allowed to start.)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor909354"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2022 9:10 UTC (Sun)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/909354/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For all the hype of eBPF—is it actually widely used? I mean, I&#x27;ve used xfsslower and such from bfpcc-tools (which is neat, although it takes way too long to start up and is fairly primitive), but in my normal day-to-day work, I don&#x27;t really feel like all these kernel hooks is something I _need_ or even can make good use of. I&#x27;m sure hyperscalers can do all sorts of weird and wonderful things with it, but it still feels like a long way to go before this is mainstream?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909354/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2022 13:16 UTC (Sun)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/909357/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If something is used by hyperscalers, doesn&#x27;t it automatically cover 90+% of Linux use (excluding Android)?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor909376"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2022 20:34 UTC (Sun)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/909376/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes. Systemd is using it to implement firewall (AllowedIP stanza). It&#x27;s sound ironic, but ebpf is used as bpf...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909376/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor909374"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2022 19:55 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/909374/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can we just switch from BPF to WASM? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909374/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909378"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2022 21:30 UTC (Sun)
                               by <b>Subsentient</b> (guest, #142918)
                              [<a href="/Articles/909378/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why bother with WASM? Just use Rust. It&#x27;s now possible to write good kernel drivers in Rust, though support isn&#x27;t mainline until 6.1. Still should be good enough in the meantime, especially if you&#x27;re writing a proprietary module that doesn&#x27;t need to be mainlined.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909378/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2022 5:07 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/909397/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BPF is used mostly for dynamic instrumentation, which should be a perfect use-case for WASM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909406"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2022 14:33 UTC (Mon)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/909406/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Would  not lack of 64bit WASM be a problem ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909406/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909472"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2022 15:39 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/909472/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is a fairly straightforward proposal to add 64-bit indexes to WASM: <a href="https://github.com/WebAssembly/memory64">https://github.com/WebAssembly/memory64</a><br>
<p>
But it won&#x27;t even be necessary, because WASM is used in a sandbox and works with the external world via well-defined accessors only. Just like eBPF for that matter.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909472/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor909476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2022 17:18 UTC (Mon)
                               by <b>kid_meier</b> (subscriber, #93987)
                              [<a href="/Articles/909476/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can WASM be verified as safe in the same way that the BPF verifier currently is able to validate eBPF?<br>
<p>
I am ignorant of details myself but had the impression that BPF is designed to be (easily?) verifiable and maybe WASM is less suitable in this context. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909484"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 26, 2022 18:14 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/909484/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
WASM is designed from ground up to be safe, as it&#x27;s used in browsers (which is probably the most aggressive computing medium imaginable). eBPF verifier is far less robust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909484/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909652"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2022 11:13 UTC (Wed)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/909652/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BPF verifier does have the notable feature (or misfeature) of being able to prove that the program will successfully complete in a bounded execution time.<br>
<p>
Wasm doesn&#x27;t do that. A wasm program is allowed to loop forever, or to abort.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909652/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 28, 2022 16:36 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/909721/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; BPF verifier does have the notable feature (or misfeature) of being able to prove that the program will successfully complete in a bounded execution time.</font><br>
<p>
WASM programs can be suspended after a given number of instructions (&quot;fuel&quot;), at least if you&#x27;re using the &quot;wasmtime&quot; runtime. This is essentially the same functionality. Moreover the &quot;fuel&quot; limits can be configured during the runtime so you can easily have different settings for different types of instrumentation.<br>
<p>
<font class="QuotedText">&gt;  Wasm doesn&#x27;t do that. A wasm program is allowed to loop forever, or to abort.</font><br>
<p>
The only thing you really need to add to WASM is the &quot;default value&quot; that would be returned on termination or fuel exhaustion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor910544"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2022 21:53 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/910544/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the issue is that if your program is mutating kernel structures, then it may not be safe to kill it mid-stream -- you need some strategy for safely unwinding from an arbitrary point in execution. This seems like a pretty reasonable thing to me, but I guess so far eBPF has decided to make the tradeoff of investing in the verifier infrastructure instead of unwinding infrastructure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910544/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor910056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2022 6:12 UTC (Sun)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/910056/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
can&#x27;t you just check assertions during verification? if everything is known beforehand, just check if they&#x27;re reachable given current values.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor910923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2022 8:47 UTC (Wed)
                               by <b>sammythesnake</b> (guest, #17693)
                              [<a href="/Articles/910923/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the eBPF program is to do anything useful, it has to calculate something that isn't already calculated. In the general case, the only way to know what values it will be manipulating is to run it. C.f. the halting problem.<br>
<p>
There's still value in assertions at the start of the program regarding its input state (e.g. a range parameter must be under a certain size, perhaps) which might be checked before execution, but that's a fairly small subset of the assertions that might be useful within the eBPF program.<br>
<p>
The approach taken by the verifier has been to verify the subset and reject anything it doesn't know how to verify. I guess there could be a mode that understands some subset of assertions (perhaps defined declaratively in metadata alongside the eBPF program) and falls back to executing assertion statements for others but that requires some means to respond to a failed assertion during execution, which might be decidedly nontrivial in some cases...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor910354"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BPF as a safer kernel programming environment</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2022 5:48 UTC (Wed)
                               by <b>hiraditya</b> (guest, #161341)
                              [<a href="/Articles/910354/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there any document describing the type system of eBPF? I&#x27;m curious if we can provide the semantics of linear types using eBPF<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910354/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
