        <!DOCTYPE html>
        <html lang="en">
        <head><title>Interview: the return of the realtime preemption tree [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/319544/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/318953/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/319544/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Interview: the return of the realtime preemption tree</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 16, 2009</br>
           </div>
The realtime preemption project is a longstanding effort to provide
deterministic response times in a general-purpose kernel.  Much code
resulting from this work has been merged into the mainline kernel over the
last few years, and a number of vendors are shipping commercial products
based upon it.  But, for the last year or so, progress toward getting the
rest of the realtime work into the mainline has slowed.
<p>
On February 11, realtime developers Thomas Gleixner and Ingo Molnar
resurfaced with the announcement of <a
href="http://lwn.net/Articles/318949/">a new realtime preemption tree</a>
and a newly reinvigorated development effort.  Your editor asked them if
they would be willing to answer a few questions about this work; their
response went well beyond the call of duty.  Read on for a detailed look at
where the realtime preemption tree stands and what's likely to happen in
the near future.
<p>


<b>LWN</b>: The 2.6.29-rc4-rt1 announcement notes that you're coming off a 
1.5-year sabbatical.  Why did you step away from the RT patches so 
long; have you been hanging out on the beach in the mean time? :)
<P>
<div class="BigQuote">
<b>Thomas</b>: 

We spent a marvelous time at the x86 lagoon, a place with an extreme
contrast of antiquities and modern art. :)
<p>
Seriously, we underestimated the amount of work which was necessary to 
bring the unified x86 architecture into shape. Nothing to complain 
about; it definitely was and still is a worthwhile effort and I would 
not hesitate longer than a fraction of a second to do it again.
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
<b>Ingo</b>:

Yeah, hanging out on the beach for almost two years was well-deserved 
for both of us. We met Linus there and it was all fun and laughter, with 
free beach cocktails, pretty sunsets and camp fires. [ All paid for by 
the nice folks from Microsoft btw., - those guys sure know how to please 
a Linux kernel hacker! ;-) ]
</div>
<p>
So what has brought you back to the realtime work at this time?
<p>
<div class="BigQuote">
<b>Thomas</b>: 

Boredom and nostalgia :) In fact I never lost track of the real time 
work since we took over x86 maintenance, but my effort was restricted to 
decode hard to solve problems and make sure that the patches were kept 
in a usable shape. Right now I have the feeling that we need to put more 
development effort into preempt-rt again to keep its upstream visibility 
and make progress on merging the remaining parts.
<p>

The most important reason for returning was of course our editors
challenge in <a href="http://lwn.net/Articles/313045">The Grumpy Editor's
guide to 2009</a>: 
  "The realtime patch set will be mostly merged by the end of the year..."
<p>
<b>Ingo</b>:

When we left for the x86 land more than 1.5 years ago, the -rt 
patch-queue was a huge pile of patches that changed hundreds of critical 
kernel files and introduced/touched ten thousand new lines of code.

Fast-forward 1.5 years and the -rt patchqueue is a humungous pile of 
patches that changes nearly a thousand critical kernel files and 
introduces/touches twenty-thirty thousand lines of code.

So we thought that while the project is growing nicely, it is useful and 
obviously people love it - the direction of growth was a bit off and 
that this particular area needs some help.
<p>
Initially it started as a thought experiment of ours: how much time and 
effort would it take to port the most stable -rt patch (.26-rt15) to the 
.29-tip tree and could we get it to boot?

Turns out we are very poor at thought experiments (just like we are 
pretty bad at keeping patch queues small), so we had to go and settle 
the argument via some hands-on hacking.

Porting the queue was serious fun, it even booted after a few dozen 
fixes, and the result was the .29-rt1 release.
<p>
Maintaining the x86 tree for such a long time and doing many difficult 
conceptual modernizations in that area was also very helpful when 
porting the -rt patch-queue to latest mainline.
<p>
Most of the code it touched and most of the conflicts that came up 
looked strangely familiar to us, as if those upstream changes went 
through our trees =;-)
<p>
(It's certainly nothing compared to the beach experience though, so we 
  are still looking at returning for a few months to a Hawaii cruise.)
</div>
<p>
How well does the realtime code work at this point?  What do you think 
are the largest remaining issues to be tackled?
<p>
<div class="BigQuote">
<b>Thomas</b>: 

The realtime code has reached quite a stable state. The 2.6.24/26
based versions can definitely be considered production ready. I spent
a lot of time to sort out a huge amount of details in those versions
to make them production stable. Still we need to refactor a lot of the
patches and look for mainline acceptable solutions for some of the
real time related changes.
<p>
<b>Ingo</b>:

To me what settled quite a bit of "do we need -rt in mainline" questions 
were the spin-mutex enhancements it got. Prior that there were a handful 
of pretty pathologic workload scenarios where -rt performance tanked 
over mainline. With that it's all pretty comparable.
<p>
The patch splitup and patch quality has improved too, and the queue we 
ported actually builds and boots at just about every bisection point, so 
it's pretty usable. A fair deal of patches fell out of the .26 queue 
because they went upstream meanwhile: tracing patches, scheduler 
patches, dyntick/hrtimer patches, etc.
<p>
It all looks a lot less scary now than it looked 1.5 years ago - albeit 
the total size is still considerable, so there's definitely still a ton 
of work with it.
</div>
<p>

What are your current thoughts with regard to merging this work into 
the mainline?

<p>
<div class="BigQuote">

<b>Thomas</b>: 

First of all we want to integrate the -rt patches into our -tip git 
repository which makes it easier to keep -rt in sync with the ongoing 
mainline development. The next steps are to gradually refactor the 
patches either by rewriting or preferably by pulling in the work which 
was done in Stevens git-rt tree, split out parts which are ready and 
merge them upstream step by step.
<p>
<b>Ingo</b>:

IMO the key thought here is to move the -rt tree 'ahead of the upstream 
development curve' again, and to make it the frontier of Linux R&amp;D.

With a 2.6.26 basis that was arguably hard to do.

With a partly-2.6.30 basis (which the -tip tree really is) it's a lot 
more ahead of the curve, and there are a lot more opportunities to merge 
-rt bits into upstream bits wherever there's accidental upstream 
activity that we could hang -rt related cleanups and changes onto.

We jumped almost 4 full kernel releases, that moves -rt across 1 year 
worth of upstream development - and keeps it at that leading edge.
<p>
Another factor is that most of the top -rt contributors are also -tip 
contributors so there's strong synergy.
<p>
The -tip tree also undergoes serious automated stabilization and 
productization efforts, so it's a good basis for development _and_ for 
practical daily use.

For example there were no build failures reported against .29-rt1, and 
most of the other failures that were reported were non-fatal as well and 
were quickly fixed. One of the main things we learned in the past 1.5 
years was how to keep a tree stable against a wild, dangerous looking 
flux of modifications.
<p>
YMMV ;-)
</div>
<p>

Thomas once told me about a scheme to patch rtmutex locks into/out of 
the kernel at boot time, allowing distributors to ship a single kernel 
which can run in either realtime or "normal" mode.  Is that still 
something that you're working on?
<p>
<div class="BigQuote">
<b>Thomas</b>: 

We are not working on that right now, but it is still on the list of 
things which need to be investigated.

<p>
<b>Ingo</b>:

That still sounds like an interesting feature, but it's pretty hard to 
pull it off. We used to have something rather close to that, a few years 
ago: a runtime switch that turned the rtmutex code back into spinning 
code. It was fragile and hard to maintain and eventually we dropped it.
<p>
Ideally it should be done not at boot time but runtime - via the 
stop-machine-run mechanism or so. [extended perhaps with hibernation 
bits that force each task into hitting user-mode, so that all locks in 
the system are released]
<p>
It's really hard to implement it, and it is definitely not for the faint 
hearted.
</div>
<p>

The RT-preempt code would appear to be one of the biggest exceptions 
to the "upstream first" rule, which urges code to be merged into the 
mainline before being shipped to customers.  How has that worked out 
in this case? Are there times when it is good to keep shipping code 
out of the mainline for such a long time?
<p>
<div class="BigQuote">
<b>Thomas</b>: 

It is an exception which was only acceptable because preempt-rt does not 
introduce new user space APIs. It just changes the run time behaviour of 
the kernel to a deterministic mode.
<p>
All changes which are user space API related (e.g. PI futexes) were
merged into mainline before they got shipped to customers via
preempt-rt and all bug fixes and improvements of mainline code were
sent upstream immediately. Preempt-rt was never a detached project
which did not care about mainline.
<p>
When we started preempt-rt there was huge demand on the customer side 
- both enterprise and embedded - for an in kernel realtime solution. The 
dual kernel approaches of RTAI, RT-Linux and Xenomai had no chance to 
get ever accepted into the mainline and the handling of the dual kernel 
environment has never been an easy task. With preempt-rt you just switch 
the kernel under a stock mainline user space environment and voila your 
application behaves as you would expect - most of the time :) Dual 
kernel environments require different libraries, different APIs and you 
can not run the same binary on a non -rt enabled kernel. Debugging 
preempt-rt based real time applications is exactly the same as debugging 
non real time applications.
<p>

<span class="PullQuote">
<span class="invisible">[PULL QUOTE: </span>
While we never had doubts that it would be possible to turn Linux into a 
real time OS, it was clear from the very beginning that it would be a 
long way until the last bits and pieces got merged.
<span class="invisible"> END QUOTE]</span>
</span>


While we never had doubts that it would be possible to turn Linux into a 
real time OS, it was clear from the very beginning that it would be a 
long way until the last bits and pieces got merged. The first question 
Ingo asked me when I contacted him in the early days of preempt-rt was: 
"Are you sure that you want to touch every part of the kernel while 
working on preempt-rt?". This question was absolutely legitimate; in the 
first days of preempt-rt we really touched every part of the kernel due 
to problems which were mostly locking and preemption related. The fixes 
have been merged upstream and especially in the locking area we got a 
huge improvement in mainline due to lock debugging, conversion to 
mutexes, etc. and a general better awareness of locking and preemption 
semantics.
<p>
preempt-rt was always a great breeding ground for fundamental changes in 
the kernel and so far quite a large part of the preempt-rt development 
has been integrated into the mainline: PI-futexes, high-resolution 
timers ... I hope we can keep that up and provide soon more interesting 
technological changes which emerged originally from the preempt-rt 
efforts.
<p>
<b>Ingo</b>:

Preempt-rt turns the kernel's scheduling, lock handling and interrupt 
handling code upside down, so there was no realistic way to merge it all 
upstream without having had some actual field feedback.

It is also unique in that you need _all_ those changes to have the new 
kernel behavior - there's no real gradual approach to the -rt concept 
itself.

That adds up to a bit of a catch-22: you don't get it upstream without 
field use, and you don't get field use without it being upstream.
<p>
Deterministic execution is a major niche, one of which was not 
effectively covered by the mainstream kernel before. It's perhaps the 
last major technological niches in existence that the stock upstream 
kernel does not handle yet, and it's no wonder that the last one out is 
in that precise position for conceptually hard reasons.
<p>
In short: all the easy technologies are upstream already ;-)
<p>
Nevertheless we strictly got all user-ABI changes upstream first: 
PI-futexes in particular. The rest of -rt is "just" a new kernel option 
that magically turns kernel execution into deterministic mode.
</div>
<p>

Where would be the best starting point for a developer who wishes to 
contribute to this effort?
<p>
<div class="BigQuote">

<b>Thomas</b>:

Nothing special with the realtime patches. Just kernel development as 
usual: get the patches, apply them, run them on your machine and test. 
If problems arise, provide bug reports or try to fix them yourself and 
send patches. Read through the code and start providing improvements, 
cleanups ...
<p>
<b>Ingo</b>:

Beyond the "try it yourself, follow the discussions, and go wherever 
your heart tells you to go" suggestion, there's a few random areas that 
might need more attention:
<p>
<ul>
<li> Big Kernel Lock removal. It's critical for -rt. We still have the
   tip:core/kill-the-BKL branch, and if someone is interested it would 
   be nice to drive that effort forward. A lot of nice help-zap-the-BKL
   patches went upstream recently (such as the device-open patches), so 
   we are in a pretty good position to try the kill-the-BKL final hammer
   approach too.
<p>
   [I have just done a (raw!) refresh and conflict resolution merge of 
     that tree to v2.6.29-rc5. Interested people can find it at:
<p>
<pre>
      git pull \
        git://git.kernel.org/pub/scm/linux/kernel/git/tip/linux-2.6-tip.git \
        core/kill-the-BKL
</pre>
     Warning: it might not even build. ]
<p>
<li> Look at Steve's git-rt tree and split out and gradually merge bits. A 
   fair deal of stuff has been cleaned up there and it would be nice to 
   preserve that work.
<p>
<li> Latency measurements and tooling. Go try the latency tracer, the 
  function graph tracer and ftrace in general. Try to find delays in 
   apps caused by the kernel (or caused by the app itself), and think 
   about whether the kernel's built-in tools could be improved.
<p>
<li> Try Thomas's cyclictest utility and try to trace and improve those 
   worst-case latencies. A nice target would be to push the worst-case 
   latencies on a contemporary PC below 10 microseconds. We were down to 
   about 13 microseconds with a hack that threaded the timer IRQ with 
   .29-rt1, so it's possible to go below 10 microseconds i think.
<p>
<li> And of course: just try to improve the mainline kernel - that will 
   improve the -rt kernel too, by definition :-)
</ul>
<p>
But as usual, follow your own path. Independent, critical thinking is a 
lot more valuable than follow-the-crowd behavior. [As long as it ends 
up producing patches (not flamewars) that is ;-)]
<p>
And by all means, start small and seek feedback on lkml early and often. 
Being a good and useful kernel developer is not an attribute but a 
process, and good processes always need time, many gradual steps and a 
feedback loop to thrive.
</div>
<p>
Many thanks to Thomas and Ingo for taking the time to answer (in detail!)
this long list of questions.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Preemption">Preemption</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Realtime">Realtime</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/319544/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor319566"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">at last!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2009 21:27 UTC (Mon)
                               by <b>nettings</b> (subscriber, #429)
                              [<a href="/Articles/319566/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
wow. this is major news for the linux audio crowd. i took the liberty of posting a subscriber's link to a public mailing list, i hope that's ok. thanks for this coverage!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319566/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor319599"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">at last!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2009 5:04 UTC (Tue)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/319599/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Erm, I would have asked before sending out that link.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319599/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor319600"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">subscriber links</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2009 5:14 UTC (Tue)
                               by <b>garrison</b> (subscriber, #39220)
                              [<a href="/Articles/319600/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>From the LWN FAQ:</p>

<blockquote><p>Where is it appropriate to post a subscriber link?</p>

<p>Almost anywhere. Private mail, messages to project mailing lists, and weblog entries are all appropriate. As long as people do not use subscriber links as a way to defeat our attempts to gain subscribers, we are happy to see them shared.</p></blockquote>
      
          <div class="CommentReplyButton">
            <form action="/Articles/319600/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor319619"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Interview: the return of the realtime preemption tree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2009 11:42 UTC (Tue)
                               by <b>mtk77</b> (guest, #6040)
                              [<a href="/Articles/319619/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting article.  But I don't quite follow "All paid for by the nice folks from Microsoft btw".  Is Ingo working there now?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319619/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor319626"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Interview: the return of the realtime preemption tree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2009 12:34 UTC (Tue)
                               by <b>dambacher</b> (subscriber, #1710)
                              [<a href="/Articles/319626/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="http://en.wikipedia.org/wiki/Irony">http://en.wikipedia.org/wiki/Irony</a><br>
/dambacher<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319626/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor319632"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Interview: the return of the realtime preemption tree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2009 13:37 UTC (Tue)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/319632/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
He is working for Red Hat for a long time now. He is obviously just joking.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319632/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor319640"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Interview: the return of the realtime preemption tree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2009 14:25 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/319640/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's just what you think. In fact Ingo is an emissary of the Dark Side, <br>
but this goes unknown as any attempt to discuss it on public fora leads to <br>
argh argh aaarrrghhh...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319640/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor319659"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Interview: the return of the realtime preemption tree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2009 16:26 UTC (Tue)
                               by <b>drag</b> (guest, #31333)
                              [<a href="/Articles/319659/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Whatever. <br>
<p>
He is just throwing a hint out to Microsoft. Basically he is saying:<br>
<p>
"Hey Microsoft, if you want stop Linux domination all you have to do is keep all the Linux developers fat, happy, drunk, rich, and hand out beach homes like candy"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319659/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor319760"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Interview: the return of the realtime preemption tree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2009 1:11 UTC (Wed)
                               by <b>SEJeff</b> (guest, #51588)
                              [<a href="/Articles/319760/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good point, then instead of being paid to work on Linux, a lot of them <br>
would just do it for fun... Oh wait, a lot of them ALREADY work on Linux <br>
for fun. Hmmmm Microsoft is in a heap of trouble then.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319760/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor319895"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Whatever?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2009 19:54 UTC (Wed)
                               by <b>man_ls</b> (guest, #15091)
                              [<a href="/Articles/319895/">Link</a>] 
      </p>
      
      </div>
      </summary>
      What do you mean, "whatever"? So despite all his good work (and his personal friendship with Linus), Ingo is just a minion of Microsoft? This is completely outrageous! We should discuss this issue because argh argh aaarrrghhh...
      
          <div class="CommentReplyButton">
            <form action="/Articles/319895/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor319911"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Another Hard real time Linux </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2009 21:51 UTC (Wed)
                               by <b>razb</b> (guest, #43424)
                              [<a href="/Articles/319911/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hello<br>
I have written a piece of software called offline scheduler(offsched). It is based on Linux ability to offload a running processor. what i do is very simple:<br>
1. offload a processor.<br>
2. let this processor wonder in my hook.<br>
<p>
currently, i have written a 1-us timer. I will happy for any criticism.<br>
It is my master work.   <br>
<p>
<a href="http://sos-linux.svn.sourceforge.net/viewvc/sos-linux/offsched/trunk/Documentation/OFFSCHED.pdf">http://sos-linux.svn.sourceforge.net/viewvc/sos-linux/off...</a><br>
<p>
Raz<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319911/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor319964"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Another Hard real time Linux </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2009 6:44 UTC (Thu)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/319964/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If I understood your idea correctly, you basically just run some very limited kernel code on a dedicated core with all unrelated interrupts etc. disabled?<br>
<p>
That seems so limited that it has not much practical use. Biggest problems are that it can't run user code and that any communication with other cores easily breaks the real-time guarantuee.<br>
<p>
Examples:<br>
<p>
- 1us accurate timer.<br>
Standard gettimeofday gives me that. The system has plenty very accurate timers, the problem is transferring that info fast enough to where it's needed.<br>
<p>
- Firewall/routing/etc. offloading.<br>
This is totally real-time unrelated. Basically it wastes one whole core on doing that instead of letting that core do also other things, and adds extra communication overhead between cores/subsystems (still need to get the packets from somewhere and tell which ones go where etc). It seems the same can be achieved by pinning the NIC interrupts to one core and giving all network related stuff highest priority.<br>
<p>
You basically replace standard processes with very limited kernel code running on dedicated core. I don't say this is a bad idea in itself, but for this to make sense you want to have many (independent, low power) cores. I suspect that PC hardware isn't very suitable for this, because too much is shared by cores. It probably makes more sense for embedded systems, but even there it's questionable because of the kernel code only limitation.<br>
<p>
What's the advantage of offsched compared to running a user space process at real-time priority pinned on a core with interrupts disabled?<br>
<p>
Or in other words, what problem does your approach solve?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319964/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor319972"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Another Hard real time Linux </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2009 8:34 UTC (Thu)
                               by <b>razb</b> (guest, #43424)
                              [<a href="/Articles/319972/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;If I understood your idea correctly, you basically just run some very limited kernel code on a dedicated core with all unrelated interrupts etc. disabled?</font><br>
<p>
correct. but it is limited only to:<br>
1. accessing ***vmalloc**** space ***directly*** . You can access any kmalloc'ed address directly  ,  and access vmalloc'ed space by walking on the pages. what I mean is that you can access everything. <br>
2.  unable to kmalloc<br>
3.  unable to free memory. ( For example : kfree ).<br>
<p>
<font class="QuotedText">&gt;- 1us accurate timer.</font><br>
<font class="QuotedText">&gt;Standard gettimeofday gives me that. The system has plenty very accurate timers, the problem is transferring that info fast enough to where it's needed.</font><br>
gettimeofday is not a timer, it is a clock. try and schedule a task to be run T microseconds from now, you will skew, and the more tasks , it will skew more.<br>
<p>
<font class="QuotedText">&gt;- Firewall/routing/etc. offloading.</font><br>
<font class="QuotedText">&gt;This is totally real-time unrelated. Basically it wastes one whole core on doing that instead of letting that core do also other things, and adds extra communication overhead between cores/subsystems (still need to get the packets from somewhere and tell which ones go where etc). It seems the same can be achieved by pinning the NIC interrupts to one core and &gt;giving all network related stuff highest priority.</font><br>
<p>
First, you are correct . It is real time unrelated. offsched is not just for real time use, but for many other things.having high ingest traffic means you will probably enable NAPI, and NAPI disables incoming interrupts to reduce interrupts overhead, and even with NAPI you may get your system to be jammed, and worst of all even with unrelated traffic, offsched suggests another approach of containing incoming traffic to a single or more cores. This way cpu0 , the main operating system processor, will not be at risk. Also, in regard to the waste of processors, again you are correct; but offsched is not meant to be used on your laptop, but on appliances with several cores; which , unfortunately never achieve linear speed-up.<br>
<p>
<font class="QuotedText">&gt;You basically replace standard processes with very limited kernel code running on dedicated core. I don't say this is a bad idea in itself, but for this to make sense you want to have many (independent, low power) cores. I suspect that PC hardware isn't very suitable for this, because too much is shared by cores. It probably makes more sense for embedded systems, but even there it's questionable because of the kernel code only limitation.</font><br>
You can access any facility in the kernel. you can send or receive packets. and I do it on AMD-Intel machines successfully.<br>
<p>
<font class="QuotedText">&gt;What's the advantage of offsched compared to running a user space process at real-time priority pinned on a core with interrupts disabled?</font><br>
you cannot run user space with interrupts disabled. So you probably meant kernel space, and it will look something like this:<br>
cli<br>
foo()<br>
sti<br>
but you will fail.<br>
a processor must walk trough a quiescent state ; if you try it, you will have RCU starvation, and I have been there... :) . one of my papers explains that. <br>
<p>
<font class="QuotedText">&gt;Or in other words, what problem does your approach solve?</font><br>
I merely suggest a different approach for real time and security for machine with several cores or hyper threading.<br>
I am using offsched on my appliances for network work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319972/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor319981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Another Hard real time Linux </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2009 10:12 UTC (Thu)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/319981/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; correct. but it is limited only to:</font><br>
<font class="QuotedText">&gt; 1. accessing ***vmalloc**** space ***directly*** . You can access any</font><br>
<font class="QuotedText">&gt; kmalloc'ed address directly , and access vmalloc'ed space by walking</font><br>
<font class="QuotedText">&gt; on the pages. what I mean is that you can access everything.</font><br>
<font class="QuotedText">&gt; 2. unable to kmalloc</font><br>
<font class="QuotedText">&gt; 3. unable to free memory. ( For example : kfree ).</font><br>
<p>
What's dangerous about accessing vmalloced space directly if it's pinned? Or did I misunderstand?<br>
<p>
<font class="QuotedText">&gt; You can access any facility in the kernel. you can send or receive</font><br>
<font class="QuotedText">&gt; packets. and I do it on AMD-Intel machines successfully.</font><br>
<p>
Though those facilities may not access vmalloc space directly, nor allocate/free memory? Seems very fragile, because you can't know if they will in the future (assuming you audited all the code that may be executed by those facilities, which is a lot of tricky work).<br>
<p>
How can you send and receive packets if you can't allocate the space needed for them? Not with the standard networking stack, can you?<br>
<p>
<font class="QuotedText">&gt; gettimeofday is not a timer, it is a clock. try and schedule a task to</font><br>
<font class="QuotedText">&gt; be run T microseconds from now, you will skew, and the more tasks, it</font><br>
<font class="QuotedText">&gt; will skew more.</font><br>
<p>
Right, totally different, sorry. But you only run one task, so the timer is just a more efficient way of not doing anything in the meantime?<br>
<p>
<font class="QuotedText">&gt; even with NAPI you may get your system to be jammed, and worst of all</font><br>
<font class="QuotedText">&gt; even with unrelated traffic, offsched suggests another approach of</font><br>
<font class="QuotedText">&gt; containing incoming traffic to a single or more cores. This way cpu0,</font><br>
<font class="QuotedText">&gt; the main operating system processor, will not be at risk.</font><br>
<p>
This is a generic problem: Any (user or kernel) process can use too many resources, slowing down the machine as a whole. Offsched doesn't solve that at all, except for some explicit kernel cases which are 'ported' to offsched, which is a lot of work.<br>
<p>
realtime preemption, on the other hand, tries to solve this problem in a more generic way.<br>
<p>
And moving networking to offsched may contain the damage to one core, but it doesn't solve the real problem, e.g. sshing into the box doesn't work quicker or better in any way. If the NIC generates more packets than can be handled, the right solution is to drop some early. Basically what you always do in an overload situation: Don't try to do everything, drop some stuff.<br>
<p>
Now the nasty thing is that it's hard to see the difference between a DoS and just a very high load.<br>
<p>
Besides, handling the network packets with all cores instead of one may be the difference between being DoSed and just slowed down.<br>
<p>
<font class="QuotedText">&gt; you cannot run user space with interrupts disabled. So you probably</font><br>
<font class="QuotedText">&gt; meant kernel space, and it will look something like this:</font><br>
<p>
Bad wording on my part, sorry. No, I meant that all interrupt handlers are executed on other cores than the "special" one, and the few that would happen anyway are disabled semi-permanently. (The scheduling clock can be disabled because a rt task is running and no involuntary scheduling should happen. Easier now with dynticks though.)<br>
<p>
Basically moving the special kernel task running on that core to a special user space task running on that core. Or at least add it as an option. Add some special syscalls or character drivers to do the more esoteric stuff and voila, all done.<br>
<p>
<font class="QuotedText">&gt; but you will fail.</font><br>
<font class="QuotedText">&gt; a processor must walk trough a quiescent state ; if you try it, you will</font><br>
<font class="QuotedText">&gt; have RCU starvation, and I have been there... :) . one of my papers</font><br>
<font class="QuotedText">&gt; explains that.</font><br>
<p>
This problem is still there though. But it seems like a minor adjustment to RCU to teach it that some cores should be ignored, or to keep track if some cores did any RCU stuff at all (perhaps it already does that now, didn't check).<br>
<p>
All in all what you more or less have is standard Linux kernel besides a special mini-RT-OS, running on a separate core. Only, you extend the current kernel to include the functionality of that RT-OS, and use other bits and pieces of the kernel when convenient. This is better than a totally separate RT-OS, but still comes with the disadvantages of one: Very limited and communication with the rest of the system is tricky. If done well it's a small step forwards, but why not think bigger and try to solve the tougher problems?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/319981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor320209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Another Hard real time Linux </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2009 22:19 UTC (Fri)
                               by <b>razb</b> (guest, #43424)
                              [<a href="/Articles/320209/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Another Hard real time Linux</font><br>
<font class="QuotedText">&gt; [Kernel] Posted Feb 19, 2009 10:12 UTC (Thu) by i3839</font><br>
&gt;<br>
<font class="QuotedText">&gt;&gt; correct. but it is limited only to:</font><br>
<font class="QuotedText">&gt;&gt; 1. accessing ***vmalloc**** space ***directly*** . You can access any</font><br>
<font class="QuotedText">&gt;&gt; kmalloc'ed address directly , and access vmalloc'ed space by walking</font><br>
<font class="QuotedText">&gt;&gt; on the pages. what I mean is that you can access everything.</font><br>
<font class="QuotedText">&gt;&gt; 2. unable to kmalloc</font><br>
<font class="QuotedText">&gt;&gt; 3. unable to free memory. ( For example : kfree ).</font><br>
&gt;<br>
<font class="QuotedText">&gt; What's dangerous about accessing vmalloced space directly if it's</font><br>
<font class="QuotedText">&gt; pinned? Or did I misunderstand?</font><br>
vmalloc pages are updated to the kernel master page table in the<br>
VMALLOC area. when the processor mmu tries to access these pages it<br>
faults. but, hey , offsched cannot fault.<br>
kmalloc pages are static and do not require faults.<br>
<font class="QuotedText">&gt;&gt; You can access any facility in the kernel. you can send or receive</font><br>
<font class="QuotedText">&gt;&gt; packets. and I do it on AMD-Intel machines successfully.</font><br>
&gt;<br>
<font class="QuotedText">&gt; Though those facilities may not access vmalloc space directly, nor</font><br>
<font class="QuotedText">&gt; allocate/free memory? Seems very fragile, because you can't know if they</font><br>
<font class="QuotedText">&gt; will in the future (assuming you audited all the code that may be</font><br>
<font class="QuotedText">&gt; executed by those facilities, which is a lot of tricky work).</font><br>
vmalloc memory is rarely used. it is used in audio drivers, and for<br>
loading modules which is no more than an annoying problem.<br>
<p>
<font class="QuotedText">&gt; How can you send and receive packets if you can't allocate the space</font><br>
<font class="QuotedText">&gt; needed for them? Not with the standard networking stack, can you?</font><br>
Recv: offsched is used for mere packet parsing . once done with the<br>
parsing packet will be moved to kernel or dropped.<br>
Send: pre-allocate all you need.<br>
I am using a private UDP stack. udp is not a big deal.<br>
<p>
<font class="QuotedText">&gt;&gt; gettimeofday is not a timer, it is a clock. try and schedule a task to</font><br>
<font class="QuotedText">&gt;&gt; be run T microseconds from now, you will skew, and the more tasks, it</font><br>
<font class="QuotedText">&gt;&gt; will skew more.</font><br>
&gt;<br>
<font class="QuotedText">&gt; Right, totally different, sorry. But you only run one task, so the timer</font><br>
<font class="QuotedText">&gt; is just a more efficient way of not doing anything in the meantime?</font><br>
Only one task ? why not have both recv and transmit ? why do you think<br>
an OS processor is fully utilized ?<br>
Benchmarks show a speed up of 2.8 for an 8 cores machine.<br>
<font class="QuotedText">&gt;&gt; even with NAPI you may get your system to be jammed, and worst of all</font><br>
<font class="QuotedText">&gt;&gt; even with unrelated traffic, offsched suggests another approach of</font><br>
<font class="QuotedText">&gt;&gt; containing incoming traffic to a single or more cores. This way cpu0,</font><br>
<font class="QuotedText">&gt;&gt; the main operating system processor, will not be at risk.</font><br>
&gt;<br>
<font class="QuotedText">&gt; This is a generic problem: Any (user or kernel) process can use too many</font><br>
<font class="QuotedText">&gt; resources, slowing down the machine as a whole. Offsched doesn't solve</font><br>
In NAPI we consume entire system computation power, in offsched we don't. I decided to call it offsched containment concept.<br>
<font class="QuotedText">&gt; that at all, except for some explicit kernel cases which are 'ported' to</font><br>
<font class="QuotedText">&gt; offsched, which is a lot of work.</font><br>
Yes, it is a lot of work, unfortunately. currently i do not know how<br>
much work it is to climb up a TCP stack in offsched context. Do you know of a good RT tcp stack ?<br>
Also, rule of 80-20 proves that 20% of the code can handle 80% of the<br>
cases,so i may find ,myself fixing only 20% of the tcp code. very much depends whether offsched will ever reach mainline. <br>
<font class="QuotedText">&gt; realtime preemption, on the other hand, tries to solve this problem in a</font><br>
<font class="QuotedText">&gt; more generic way.</font><br>
<p>
<font class="QuotedText">&gt; And moving networking to offsched may contain the damage to one core,</font><br>
<font class="QuotedText">&gt; but it doesn't solve the real problem, e.g. sshing into the box doesn't</font><br>
<font class="QuotedText">&gt; work quicker or better in any way. If the NIC generates more packets</font><br>
<font class="QuotedText">&gt; than can be handled, the right solution is to drop some early. Basically</font><br>
<font class="QuotedText">&gt; what you always do in an overload situation: Don't try to do everything,</font><br>
<font class="QuotedText">&gt; drop some stuff.</font><br>
why a single NIC ? Many appliances if not most are shipped with an<br>
administration interface, and a public interface.<br>
The public is the exposed interface. if it is under attack, the entire<br>
system is under attack , especially in a world 10G interfaces.<br>
In offsched, we assign OFFSCHED-NAPI over 10G interface....<br>
<font class="QuotedText">&gt; Now the nasty thing is that it's hard to see the difference between a</font><br>
<font class="QuotedText">&gt; DoS and just a very high load.</font><br>
&gt;<br>
<font class="QuotedText">&gt; Besides, handling the network packets with all cores instead of one may</font><br>
<font class="QuotedText">&gt; be the difference between being DoSed and just slowed down.</font><br>
who says a single OFFSCHED core is used ?<br>
<font class="QuotedText">&gt;&gt; you cannot run user space with interrupts disabled. So you probably</font><br>
<font class="QuotedText">&gt;&gt; meant kernel space, and it will look something like this:</font><br>
&gt;<br>
<font class="QuotedText">&gt; Bad wording on my part, sorry. No, I meant that all interrupt handlers</font><br>
<font class="QuotedText">&gt; are executed on other cores than the "special" one, and the few that</font><br>
This is soft real time. user space cannot do hard real time. you can<br>
never guarantee meeting deadlines because you are in ring 3. If you want to use a high priority kernel thread, you probably pre-allocate memory(..well... i do.. ) . so ? better use offsched.<br>
<font class="QuotedText">&gt; would happen anyway are disabled semi-permanently. (The scheduling clock</font><br>
<font class="QuotedText">&gt; can be disabled because a rt task is running and no involuntary</font><br>
<font class="QuotedText">&gt; scheduling should happen. Easier now with dynticks though.)</font><br>
It is a good idea, why not wrap offsched timer with clockevents?<br>
thanks.<br>
<font class="QuotedText">&gt; Basically moving the special kernel task running on that core to a</font><br>
<font class="QuotedText">&gt; special user space task running on that core. Or at least add it as an</font><br>
<font class="QuotedText">&gt; option. Add some special syscalls or character drivers to do the more</font><br>
<font class="QuotedText">&gt; esoteric stuff and voila, all done.</font><br>
<font class="QuotedText">&gt;&gt; but you will fail.</font><br>
<font class="QuotedText">&gt;&gt; a processor must walk trough a quiescent state ; if you try it, you</font><br>
<font class="QuotedText">&gt; will</font><br>
<font class="QuotedText">&gt;&gt; have RCU starvation, and I have been there... :) . one of my papers</font><br>
<font class="QuotedText">&gt;&gt; explains that.</font><br>
&gt;<br>
<font class="QuotedText">&gt; This problem is still there though. But it seems like a minor adjustment</font><br>
<font class="QuotedText">&gt; to RCU to teach it that some cores should be ignored, or to keep track</font><br>
<font class="QuotedText">&gt; if some cores did any RCU stuff at all (perhaps it already does that</font><br>
<font class="QuotedText">&gt; now, didn't check).</font><br>
&gt;<br>
<font class="QuotedText">&gt; All in all what you more or less have is standard Linux kernel besides a</font><br>
<font class="QuotedText">&gt; special mini-RT-OS, running on a separate core. Only, you extend the</font><br>
<font class="QuotedText">&gt; current kernel to include the functionality of that RT-OS, and use other</font><br>
<font class="QuotedText">&gt; bits and pieces of the kernel when convenient. This is better than a</font><br>
<font class="QuotedText">&gt; totally separate RT-OS, but still comes with the disadvantages of one:</font><br>
<font class="QuotedText">&gt; Very limited and communication with the rest of the system is tricky. If</font><br>
<font class="QuotedText">&gt; done well it's a small step forwards, but why not think bigger and try</font><br>
<font class="QuotedText">&gt; to solve the tougher problems?</font><br>
correct. I decided to call it "hybrid system",this is because you<br>
enjoy the stabilty of linux server and OFFSCHED. If A is the size of<br>
your software, and B is the size of the Real time code, B/A is likely<br>
to be small. Why mess with a big RT system for such small fraction ?<br>
You are more than welcome to suggest other strategies.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/320209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor320146"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Another Hard real time Linux </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2009 13:25 UTC (Fri)
                               by <b>saffroy</b> (guest, #43999)
                              [<a href="/Articles/320146/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another approach is to use a real-time hypervisor: you can have real-time scheduling, (almost) full access to the bare-metal, and even (more or less) friendly APIs to communicate with the other OS. You can even have a full-featured RTOS running there.<br>
<p>
BTW, is it reasonable to imagine the RT-preempt tree running kvm running a RTOS ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/320146/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor320211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Another Hard real time Linux </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2009 22:26 UTC (Fri)
                               by <b>razb</b> (guest, #43424)
                              [<a href="/Articles/320211/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Another Hard real time Linux</font><br>
<font class="QuotedText">&gt; [Kernel] Posted Feb 20, 2009 13:25 UTC (Fri) by saffroy</font><br>
&gt;<br>
<font class="QuotedText">&gt; Another approach is to use a real-time hypervisor: you can have</font><br>
<font class="QuotedText">&gt; real-time scheduling, (almost) full access to the bare-metal, and even</font><br>
<font class="QuotedText">&gt; (more or less) friendly APIs to communicate with the other OS. You can</font><br>
<font class="QuotedText">&gt; even have a full-featured RTOS running there.</font><br>
Funny you mention it. I actually thought of using this technology to have a solution for a single cpu machines. But it turned out that hyper-threading is good enough for offsched, so i did not try it. But i very much agree, we do not utilize the machines enough. <br>
<font class="QuotedText">&gt; BTW, is it reasonable to imagine the RT-preempt tree running kvm running</font><br>
<font class="QuotedText">&gt; a RTOS ?</font><br>
don't know.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/320211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor320008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Interview: the return of the realtime preemption tree</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2009 14:59 UTC (Thu)
                               by <b>Lovechild</b> (guest, #3592)
                              [<a href="/Articles/320008/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Back in the day there was a very handy yum repo available. This made it trivially easy to test for users and was a good way to detect problem scenerios. I am hoping to see something like that return with this reinvigorated rt effort.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/320008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor320053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">yum repo?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2009 19:41 UTC (Thu)
                               by <b>bkoz</b> (guest, #4027)
                              [<a href="/Articles/320053/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looking for kernel-rt as well, but don't see details on a new yum repo for the renewed realtime work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/320053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2009, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
