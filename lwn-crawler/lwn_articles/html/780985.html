        <!DOCTYPE html>
        <html lang="en">
        <head><title>A kernel unit-testing framework [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/780985/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/780941/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/780985/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A kernel unit-testing framework</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>March 1, 2019</br>
           </div>
For much of its history, the kernel has had little in the way of formal
testing infrastructure.  It is not entirely an exaggeration to say that
testing is what the kernel community kept users around for.  Over the
years, though, that situation has improved; internal features like
kselftest and services like the 0day testing system have increased our test
coverage considerably.  The story is unlikely to end there, though; the
next addition to the kernel's testing arsenal may be a unit-testing framework
called <a
href="/ml/linux-kernel/20190214213729.21702-1-brendanhiggins@google.com/">KUnit</a>.
<p>

The KUnit patches, currently in their fourth revision, have been developed
by Brendan Higgins at Google.  The intent is to enable the easy and rapid
testing of kernel components in isolation — unit testing, in other words.
That distinguishes KUnit from kernel's <a
href="https://www.kernel.org/doc/html/latest/dev-tools/kselftest.html">kselftest
framework</a> in a couple of significant ways.  Kselftest is intended to
verify that a given feature works in a running kernel; the tests run in
user space and exercise the kernel that the system booted.  They thus can
be thought of as a sort of end-to-end test, ensuring that specific parts of
the entire system
are behaving as expected.  These tests are important to have, but they do
not necessarily test specific kernel subsystems in isolation from all of
the others, and they require actually booting the kernel to be tested.
<p>

KUnit, instead, is designed to run more focused tests, and they run inside
the kernel itself.  To make this easy to do in any setting, the framework
makes use of user-mode Linux (UML) to actually run the tests.  That may
come as a surprise to those who think of UML as a dusty relic from before
the kernel had proper virtualization support (its <a
href="http://user-mode-linux.sourceforge.net/">home page</a> is hosted on
SourceForge and offers a bleeding-edge 2.6.24 kernel for download), but UML
has been maintained over the years.  It makes a good platform for something
like KUnit without rebooting the host system or needing to set up
virtualization. 
<p>

Using KUnit is a matter of writing a set of test cases to exercise the code
in question and check the results.  Each test case is a function with this
signature:
<p>
<pre>
    void test_case(struct kunit *test);
</pre>
<p>
A test case function that returns normally is deemed to have succeeded; a
failure can be indicated by a call to <tt>KUNIT_FAIL()</tt>:
<p>
<pre>
    void always_fails(struct kunit *test)
    {
        KUNIT_FAIL(test, "I'm so bad I always fail");
    }
</pre>
<p>
One could thus write a test case with a bunch of <tt>if</tt> statements and
<tt>KUNIT_FAIL()</tt> calls but, naturally, a set of helper macros exists to
reduce the amount of boilerplate code required.
For example:
<p>
<pre>
    KUNIT_EXPECT_EQ(test, v1, v2);
</pre>
<p>
will test <tt>v1</tt> and <tt>v2</tt> for equality and complain loudly if
the test fails.  A module testing low-level string handling might feature
calls like:
<p>
<pre>
    KUNIT_EXPECT_EQ(test, strcmp("foo", "foo"), 0);
    KUNIT_EXPECT_NE(test, strcmp("foo", "bar"), 0);
    /* ... */
</pre>
<p>
As one would expect, there are a number of these macros for different kinds
of tests; see <a 
href="https://google.github.io/kunit-docs/third_party/kernel/docs/api/test.html">this
page</a> for the full set.  Note that a test case will continue after one
of these "expectations" fails; that may not be desirable if a particular
failure means that the remaining tests cannot be performed.  For such
cases, there is a mirror set of macros with <tt>ASSERT</tt> instead of
<tt>EXPECT</tt> in their names; if an assertion fails, the rest of the test
case (but not any other test cases) will be aborted.
<p>
Once a set of test cases are written, they should be gathered together into
an array with code like:
<p>
<pre>
    static struct kunit_case test_cases[] = {
        KUNIT_CASE(my_case_1),
	KUNIT_CASE(my_case_2),
	{},
    };
</pre>
<p>
This array is then packaged into a <tt>kunit_module</tt> structure this
way:
<p>
<pre>
    static struct kunit_module test_module = {
        .name = "My fabulous test module",
	.init = my_test_init,
	.exit = my_test_exit,
	.test_cases = test_cases,
    };
    module_test(test_module);
</pre>
<p>
The <tt>init()</tt> and <tt>exit()</tt> functions can be provided if they
are needed to set up and clean up after the test cases.
The resulting source file implements a special type of kernel module; the next step
is to add it to the <tt>Kconfig</tt> file:
<p>
<pre>
    config MY_TEST_MODULE
        bool "This is my test module and nobody else's"
	depends on KUNIT
</pre>
<p>
and to add an appropriate line to the makefile as well.  Then, running the
<tt>kunit.py</tt> program 
that comes with KUnit will build a UML kernel and boot it to run any tests
that are enabled in the current kernel configuration.
<p>
For more information, see <a
href="https://google.github.io/kunit-docs/third_party/kernel/docs/">the
detailed documentation</a> written by Higgins.  There is also <a
href="/ml/linux-kernel/20190214213729.21702-16-brendanhiggins@google.com/">an
extended example</a> provided with the patch set in the form of the
conversion of the existing device-tree unit tests to the KUnit framework.
There have been some comments on the details of how test cases are written,
but the code would appear to be getting closer to ready for merging into
the mainline.  Then the kernel will have another tool in its testing
toolbox.  That is just the beginning of course; then somebody has to
actually write the tests to go with it.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Testing">Development tools/Testing</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/780985/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor781098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2019 18:27 UTC (Fri)
                               by <b>jorgegv</b> (subscriber, #60484)
                              [<a href="/Articles/781098/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <i>"Then the kernel will have another tool in its testing toolbox. That is just the beginning of course; then somebody has to actually write the tests to go with it."</i>
<br/>
<br/>

After the unit testing infrastructure has been put in place, the next step in my opinion would be to set some kind of policy which asks for unit tests to be written in order for a patch to be considered for inclusion in mainline. You set up the tools, then you make people use them.
      
          <div class="CommentReplyButton">
            <form action="/Articles/781098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781146"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2019 21:02 UTC (Sat)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/781146/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Policies like this do little to improve code quality, and instead turn into a needless box-ticking exercise where people will write bullshit tests just to get a commit in, we've doubtlessly all observed this in userspace projects, commercial or otherwise.<br>
<p>
Tests that are written half-heartedly for the most part contribute to brittleness and inflexibility more than anything else. If someone is motivated to write a good test, they will do it by default. If they're forced to write a test, the chance is very low that the test will do much more than validate what the programmer already knew about his code<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781146/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781147"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2019 21:04 UTC (Sat)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/781147/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(oh, how times are changing. I am forced to rebuke myself for use of 'his' in the parent comment!)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781147/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor782682"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2019 1:03 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/782682/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All this says is that women write tests without being forced to. (In my experience, this is true -- but that's probably because in order to survive against all the headwinds as a female free software developer you need to be really, really good, and writing good tests is strongly correlated with that. Writing good tests is *hard*.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/782682/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor781149"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2019 21:41 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/781149/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I worked in many projects that had strict 80% coverage requirement for new code. There was a fair amount of bullshit tests, but:<br>
1) Even bullshit tests periodically helped.<br>
2) The advantages of non-bullshit tests far outweighed the occasional discomfort of having to write BS tests to tick the right box.<br>
<p>
Nothing is perfect, but with tests it's pretty much impossible to have too many of them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781149/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781150"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2019 22:25 UTC (Sat)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/781150/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Tests aren't free -- while they increase the accuracy of future change, they also increase the cost. An ornately tested app is one of the most painful to refactor, because more than half the cost of refactoring is usually paid fixing up tests. If they're bullshit tests, that is very much wasted effort<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781150/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2019 22:28 UTC (Sat)
                               by <b>dw</b> (guest, #12017)
                              [<a href="/Articles/781152/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(In the interests of honesty, it's worth noting I also appreciate the value of near-100% coverage, but still prefer selective testing.. our difference of opinion here is merely a proxy for that religious war)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor781153"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2019 23:26 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/781153/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would argue the total opposite. Tests makes refactoring much easier. Sure, you have to go and fix them but they also provide you a lot of, well, testing. <br>
<p>
It's often way too easy to overlook some implicit invariant during a refactoring.<br>
<p>
And for trivial refactorings (like renaming stuff) modern IDEs automate these changes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781153/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781154"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2019 5:03 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/781154/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's exactly right. Tests let you refactor with confidence.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781154/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor781156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2019 5:13 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/781156/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can adjust the level at which you write tests (unit tests vs system tests and the spectrum in between) to trade off refactoring costs with other variables.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor781155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2019 5:11 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/781155/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If they're forced to write a test, the chance is very low that the test will do much more than validate what the programmer already knew about his code</font><br>
<p>
The point of requiring tests with a patch is not to catch bugs in the patch at the time of submission. Those tests are to catch people breaking that code in the future. Thus, even "does this feature work at all" tests are useful in the long run.<br>
<p>
For a very long time Firefox has had a policy of requiring tests with patches, or else an explanation of why a test is impractical. I was involved before and after the policy was introduced and that policy has been extremely valuable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 17:26 UTC (Mon)
                               by <b>hkario</b> (subscriber, #94864)
                              [<a href="/Articles/781255/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The point of requiring tests with a patch is not to catch bugs in the patch at the time of submission.</font><br>
<p>
they also show the expected use of the code (they are a form of documentation) and they show (together with CI) that indeed the code meets those expectations (if both sides of a corner case are handled correctly)<br>
<p>
ability to refactor code with confidence is definitely worth the occasional BS test<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor781168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2019 14:36 UTC (Sun)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/781168/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your comment reads like you think that one bad experience invalidates the whole practice. Unit-testing, as an approach to rigour in software engineering, is not easy but has enormous payoffs. As roc points out, preventing regressions is a great reason to have a suite of unit tests that a developer can use, on her own machine, before committing, to make sure that there aren't any unintended consequences to the code changes she's making. This has a second benefit in having a quick cycle time -- being able to fix bugs and regressions while the intent of your code is in your head, and you find another way to solve the problem at hand. (We get for free a third benefit to an extensive unit test suite: other developers have said what they intend their functional code to deal with, recorded as examples of positive and negative behaviour in their test suite.)<br>
<p>
Read the articles [1], [2], [3] and join to community of practitioners.<br>
<p>
Let's not bike-shed different flavours of automated testing. Let's not re-invent something well covered by history. Consider Chicago-style "red-green-refactor" to write failing test cases, fill in merely enough code to pass the tests and then to reshape your code structure to something you and other people can maintain or London-style 'design the interactions between components in your system': test their interfaces with contracts, and use your own inteface contracts with 'test doubles' of external systems (i.e. a mock evolved into a wrapper around external libraries, with a standardised interface[4]) to avoid your unit tests escaping their unitary boundaries. <br>
<p>
1: <a href="https://github.com/testdouble/contributing-tests/wiki/London-school-TDD">https://github.com/testdouble/contributing-tests/wiki/Lon...</a><br>
2: <a href="https://github.com/testdouble/contributing-tests/wiki/Detroit-school-TDD">https://github.com/testdouble/contributing-tests/wiki/Det...</a><br>
3: <a href="https://github.com/testdouble/contributing-tests/wiki/Don%27t-mock-what-you-don%27t-own">https://github.com/testdouble/contributing-tests/wiki/Don...</a><br>
3: <a href="http://codemanship.co.uk/parlezuml/blog/?postid=987">http://codemanship.co.uk/parlezuml/blog/?postid=987</a><br>
<p>
<font class="QuotedText">&gt;Tests that are written half-heartedly for the most part contribute to brittleness and inflexibility more than anything else. If someone is motivated to write a good test, they will do it by default. If they're forced to write a test, the chance is very low that the test will do much more than validate what the programmer already knew about his code[.]</font><br>
<p>
Let's reconsider your first sentence: were we to add some training on test case design to our edict mandating test cases, what might happen? And those brittle and inflexible tests will need reliability designed into them or they don't warrant the trust we grant our automated test suites. A significant part of test case lifecycle is to cull the redundant ones -- something which happens naturally when unit-level test cases are the 'record of intent' from the author of the functional or production code. That's to say that irrelevant functionality will have failing unit tests, and nobody would advocate writing code so that these irrelevant tests pass.<br>
<p>
Second sentence: People don't know what good code, good design or good tests look like without training and connection to a community of experts. We can work together to grow a pool of knowledge about this.<br>
<p>
Third sentence: We can use this record of assumptions about the code as examples of intent. On top of that, we can train people to consider the equivalence classes of test inputs which cause the software to do the same work and arrive at the same output -- and have tests for these. We can also train people to consider and test what happens to bad input data -- which usually results in systems built defensively to reject bad input and to recover from unintended behaviour. <br>
<p>
It sounds like you had a bad experience, which sucks, I'm sure. There are ways to pick yourself up and to practise better unit testing.<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2019 20:06 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/781171/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW I don't think *unit* tests are necessarily the main kind of tests people should be writing.<br>
<p>
For example Firefox has very few true "unit tests", i.e. tests that test the functionality of one code module in isolation. Firefox tests are almost entirely "system tests", tests written in HTML, CSS or JS that test specific Web APIs, each test touching a lot of Firefox modules. There are good reasons to test this way. Those interfaces are public and therefore quite stable (especially after a feature has shipped), so tests need refactoring less often than tests that depend on internal interfaces. Also tests at this level can often be written to work on multiple different browsers, which is extremely useful. And testing modules in isolation often means mocking the interfaces of other modules which can be extremely expensive to build and maintain.<br>
<p>
So while I think a policy of requiring tests with patches is important, I don't think they need to be *unit* tests.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor782539"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2019 10:22 UTC (Thu)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/782539/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  FWIW I don't think *unit* tests are necessarily the main kind of tests people should be writing.</font><br>
Yeah, I railed on unit tests, when I also believe that there's a need, like security-in-depth, for testing-in-depth of different layers of the system in ways that are appropriate and convenient. <br>
<p>
The traditional sales pitch for predominant unit testing is lightweight, quick-to-evaluate method-level unit tests as the foundation of the Testing Pyramid thing: build trust in your program functions or methods, then build trust in your internal interfaces as you integrate components, then build trust in your external interfaces (user, API), finally trust you've installed it correctly with few fail-fast smoke tests.<br>
<p>
I'm reconsidering whether that's right -- given the London School of Test-Driven design builds tests that reflect your design rather than (Chicago School's approach for) a test approach that evaluates every input (or class of inputs that get equivalent results) to the system via its component pieces. Somewhere, an automated framework reflects the full system in a second-system kind of way -- clearly not an acknowledged part of in-depth automated testing.<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/782539/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor781170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2019 16:45 UTC (Sun)
                               by <b>rgmoore</b> (<b>&#x272D; supporter &#x272D;</b>, #75)
                              [<a href="/Articles/781170/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote> Policies like this do little to improve code quality, and instead turn into a needless box-ticking exercise where people will write bullshit tests just to get a commit in,</blockquote>

<p>This seems like a cultural problem rather than a technical one.  Demanding that tests be written but not caring about their quality is indeed a box-ticking exercise rather than a serious attempt at improving code quality.  But that doesn't say it's wrong to demand tests; it just says that it's wrong to demand tests without treating those tests as seriously as the code they're testing.  Tests need to be seen as an essential part of the coding process rather than an afterthought.  Tests that are written half-heartedly don't cause the code they're testing to be brittle and inflexible; they are a symptom of the kind of coding practice that produces brittle and inflexible code.
      
          <div class="CommentReplyButton">
            <form action="/Articles/781170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor781328"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2019 11:17 UTC (Tue)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/781328/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If your project has robust code review process then bullshit tests will have a much harder way in. I require tests to be present for new code while I'm doing the code review mostly because it shows that the developer thought about the API, about what inputs are valid and what inputs are invalid and how the code should react to those (also: failure modes and error handling). I review the tests just as hard as the actual code (though it's often tempting to skip this part or make it less thorough).<br>
<p>
And as others said, even bullshit tests have value sometimes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781328/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor781107"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2019 21:05 UTC (Fri)
                               by <b>mfuzzey</b> (subscriber, #57966)
                              [<a href="/Articles/781107/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can see this working well for testing "library" like functionality (like the device tree functions that were converted).<br>
<p>
I have much more difficulty seeing how it will work for, say, a device driver.<br>
A typical device driver will call many kernel functions, many of which will have to be mocked / stubbed to enable unit testing. <br>
<p>
While that would be technically possible it is likely to be a lot of work.<br>
<p>
The other problem is how much will testability be allowed to impact the design of the code? Today  things like abstraction layers are frowned on and not generally accepted for mainline code.  Making code testable in isolation requires doing similar things.<br>
<p>
A few years ago I did write unit tests for a new kernel driver. They ran in user space and compiled the kernel driver code linking with stub functions. It did work but was a lot of work and resulted I  somewhat "polluted driver source.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781107/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2019 11:23 UTC (Tue)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/781331/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess this is precisely the reason why Linux survived that long (25 years?!) without an official low-level testing framework. Long overdue, IMO, but apparently there were reasons for that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor781124"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2019 8:26 UTC (Sat)
                               by <b>gps</b> (subscriber, #45638)
                              [<a href="/Articles/781124/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please, for the love of software, YES!  😁<br>
I preached the need for user space unittesting without booting a system to kernel teams last decade. Too much community fear. No takers. I moved on.<br>
<p>
Accept this concept. Get it in. Reject all future proposed kernel patches without small test coverage for their logic. Build meaningful frameworks within it for mock devices, mock and fuzzy event sequences, galore. Bug fixes could come with regression tests! *Gasp*<br>
<p>
Leave the basement. Become a real world software project. Be proud of your work instead of lying to everybody that you just don't write bugs despite repeated evidence to the contrary as documented in CVEs. Write tests, you'll earn respect!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781124/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 1:12 UTC (Mon)
                               by <b>shemminger</b> (subscriber, #5739)
                              [<a href="/Articles/781183/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Last I checked most of the kernel was device drivers and related infrastrucure. How would a generic unit test work for that?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781188"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 2:51 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/781188/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Like most other external-facing code under unit tests - by mocking the device behavior.<br>
<p>
This is admittedly less useful than testing with physical devices, but it still is useful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781188/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781191"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 4:51 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/781191/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To add, I actually would LOVE to see a device behavior emulator that can allow to create a programmatic model of a device. With DMA, timed interrupts and so on. In particular to test the error recovery code that right now might never even get run.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781191/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 12:46 UTC (Mon)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/781199/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Testing DMA recovery is easy: hack the DMAC to let dmaengine_prep_slave_*() fail every Nth invocation.<br>
<p>
Perhaps we need a kernel commandline option to enable that at the generic dmaengine level?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781275"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 20:11 UTC (Mon)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/781275/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is already standard infrastructure for fault injection which could be used: <a href="https://lwn.net/Articles/209257/">https://lwn.net/Articles/209257/</a><br>
<p>
I once had a similar idea for injecting failures into USB transmissions (inspired a kernel crash in the USB hub code which would occur if he device was unplugged at a precise moment) but sadly, didn't implement it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781275/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor781253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 17:04 UTC (Mon)
                               by <b>gps</b> (subscriber, #45638)
                              [<a href="/Articles/781253/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed.  It also allows for people who don't have the hardware in question make meaningful changes with higher confidence.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor781270"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 19:48 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/781270/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do it in QEMU. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781270/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781343"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2019 14:14 UTC (Tue)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/781343/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is essentially asking for double the work to be done for every driver. (My rough rule of thumb is that a device model is about the same amount of work as writing a driver -- assuming you have the specs for the device at all...) It also risks ending up with a QEMU model and a Linux driver that have the inverse of each others' bugs, neatly cancelling out. (I have actually seen this with a PCI controller driver for an Arm devboard -- the kernel code didn't actually work on the real hardware for more than one PCI card, but everybody was testing against QEMU...)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781343/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781374"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2019 19:08 UTC (Tue)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/781374/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Spending double the development effort to have reasonable (not perfect) automated tests isn't outrageous. It's in the right ballpark for projects I've worked on like Firefox and rr. Under the right conditions that spend pays for itself pretty easily.<br>
<p>
The "right conditions" include the software living long enough for tests written today to pay off in the future, and bugs in deployed releases being costly because you have a lot of users or your software does important things or bugs found in the field are difficult to debug remotely.<br>
<p>
Ironically the work I'm doing on improving debugging makes writing good tests slightly less important!<br>
<p>
Tests are never perfect. I can see that device models diverging from hardware would be a problem. But it also seems to me that you could engineer around some of the problems, e.g. have a testing framework that *by default* tests for multiple instances of each hardware element, hotplugging of each hardware element, randomization of interrupt delays, etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781374/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor782684"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2019 1:14 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/782684/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Spending double the development effort to have reasonable (not perfect) automated tests isn't outrageous. It's in the right ballpark for projects I've worked on like Firefox and rr. Under the right conditions that spend pays for itself pretty easily.
</blockquote>
In glibc, which is very much following the 'everything should have tests dammit' policy (and long has), the tradeoff is sometimes much higher: it can easily take five times longer to write a decent test for some bugfixes than to fix the bug, even (sometimes especially!) when the bug is a real monster to find.
<p>
Linux would probably have terrible threading despite NPTL if Uli hadn't written a massive heap of tests for NPTL at the same time to make sure that the damn thing actually worked and did not regress. More than one bug I've looked at in the past which came down to one missed assembler instruction that triggered problems only in ludicrously obscure slowpath cases was tickled by one or more of those tests...

      
          <div class="CommentReplyButton">
            <form action="/Articles/782684/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor781267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 19:23 UTC (Mon)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/781267/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That essentially amounts to writing an emulated version of the hardware. But it would be an enormous undertaking to do this in such an accurate way that e.g. wrong clock setups would be detected. The device model would probably be bigger than the driver&amp;mdash;and given that it would be effectively giving away a lot of the firmware, it's probably not the kind of code that producers want or are able to release.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 19:32 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/781268/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Some devices will probably always be impractical, like GPUs. These days they are separate computers in their own right and probably should be emulated with something like qemu.<br>
<p>
However lots of other devices most definitely can be simulated.<br>
<p>
Simulation also doesn't have to be perfect to be useful. Just something good enough will suffice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor781281"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 21:13 UTC (Mon)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/781281/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Simulation also doesn't have to be perfect to be useful. Just something good enough will suffice.</font><br>
<p>
"All models are wrong.  Some are useful."<br>
<p>
But the "useful" threshold varies widely depending on what you're trying to accomplish.<br>
<p>
The majority of my headaches with respect to device drivers was due to the hardware not working the way it was documented.  Spurious interrupts, clock phasing, interactions/collisions with shared resources, subtle sleep/wake sequencing issues, sensitivity to environmental conditions (eg clocks drifting between -40C -&gt; 85C), dma peripheral quirks, workarounds for things fixed in later revisions.. and so forth.<br>
<p>
Granted, I also had plenty of headaches due to the upper stacks not behaving as specified either.  Or perhaps I should say significantly underspecified -- While it was actually well-tested (unit and system-level) the tests were written from the same incorrect/incomplete set of spherical-cow specifications/assumptions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781281/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor781294"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2019 22:51 UTC (Mon)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/781294/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
WiFi would also be all but impractical.<br>
<p>
USB would only be practical if you also emulated all the broken devices around to ensure they don't regress. Same for the "generic" drivers like AHCI or SDHCI.<br>
<p>
Some mock devices are there, for example scsi_debug, the tests are in user space rather than kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781294/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor783001"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2019 3:22 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/783001/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
WiFi is actually quite practical, its control protocols are quite complicated and are a prime target for mock-based unit tests. Integration tests are indeed very complicated, though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/783001/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor781352"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2019 15:49 UTC (Tue)
                               by <b>shemminger</b> (subscriber, #5739)
                              [<a href="/Articles/781352/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was hoping for more exhaustive test suites for common device API's. There are some pieces for networking, but being able to hit more complicated cases would help. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781352/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor781323"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2019 8:58 UTC (Tue)
                               by <b>knuto</b> (subscriber, #96401)
                              [<a href="/Articles/781323/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is why we take a more pragmatic approach to unit testing with KTF (Kernel Test Framework) (<a href="https://github.com/oracle/ktf">https://github.com/oracle/ktf</a>, <a href="https://lwn.net/Articles/735034/">https://lwn.net/Articles/735034/</a>) which we created to serve our needs to be able to test the semantics of kernel level APIs against drivers/hardware. <br>
<p>
We're in the process of making patch set of KTF suitable for inclusion in the kernel, while keeping the features we have in place to have one test code base applied to multiple kernel versions, an important need for anyone trying to maintain stable kernels for production use in addition to bleeding edge.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/781323/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor782672"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2019 22:17 UTC (Fri)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/782672/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are plenty of virtual device drivers out there that could use the testing. They could serve as useful starting points for real hardware.<br>
<p>
Filesystems don't need specific hardware either. Wouldn't it be nice if Btrfs had RAID5/6 regression tests?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/782672/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor782678"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 8, 2019 23:25 UTC (Fri)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/782678/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Filesystem testing is pretty comprehensively done in xfstests. E.g. btrfs does have some sort of RAID regression tests: <a href="https://github.com/kdave/xfstests/blob/6ab53c6c6825c16d8a7ed38660a000bd6511bec6/tests/btrfs/151">https://github.com/kdave/xfstests/blob/6ab53c6c6825c16d8a...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/782678/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor782547"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 7, 2019 14:31 UTC (Thu)
                               by <b>smitty_one_each</b> (subscriber, #28989)
                              [<a href="/Articles/782547/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A secondary objective might be lowering the learning curve for getting into kernel development.<br>
<p>
I have made use of unit tests in other code as a roadmap to understanding what's at stake.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/782547/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor783000"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel unit-testing framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 14, 2019 3:18 UTC (Thu)
                               by <b>jflombera</b> (guest, #100225)
                              [<a href="/Articles/783000/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Don't stop there, add support for property-based testing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/783000/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
