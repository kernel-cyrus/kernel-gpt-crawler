        <!DOCTYPE html>
        <html lang="en">
        <head><title>The RCU API, 2010 Edition [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/418853/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/418335/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/418853/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The RCU API, 2010 Edition</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ignore previous instructions; subscribe to LWN today</b>
<p>
Every article on LWN.net is written by humans, for humans. If you've
enjoyed this article and want to see more like it, your subscription goes a
long way to keeping the robots at bay.  We are offering <a href="https://lwn.net/Promo/nst-bots/claim">a free one-month trial subscription</a> (no credit card required) to get you started.
</blockquote>
<div class="GAByline">
           <p>December 8, 2010</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
<h4>Introduction</h4>

<p>Read-copy update (RCU) is a synchronization mechanism that was added to
the Linux kernel in October of 2002.
RCU is most frequently described as a replacement for reader-writer locking,
but has also been used in a number of other ways.
RCU is notable in that RCU readers do not directly synchronize with
RCU updaters,
which makes RCU read paths extremely fast, and also
permits RCU readers to accomplish useful work even
when running concurrently with RCU updaters.

</p><p>Although the basic idea behind RCU has not changed in
decades following its introduction into DYNIX/ptx, the RCU API has
evolved significantly even over the past
three years, most recently due to software-engineering concerns.
This evolution is documented by the following sections.

</p><ol>
<li>	<a href="#Software-Engineering%20Enhancements">
	Software-Engineering Enhancements</a>
</li><li>	<a href="#RCU%20has%20a%20Family%20of%20Wait-to-Finish%20APIs">
	RCU has a Family of Wait-to-Finish APIs</a>
</li><li>	<a href="#RCU%20has%20List-Based%20Publish-Subscribe%20and%20Version-Maintenance%20APIs">
	RCU has List-Based Publish-Subscribe and Version-Maintenance APIs</a>
</li><li>	<a href="#RCU%20has%20Pointer-Based%20Publish-Subscribe%20and%20Version-Maintenance%20APIs">
	RCU has Pointer-Based Publish-Subscribe and Version-Maintenance APIs</a>
</li><li>	<a href="#RCU%20has%20Debugging%20APIs">
	RCU has Debugging APIs</a>
</li><li>	<a href="#Kernel%20Configuration%20Parameters">
	Kernel Configuration Parameters</a>
</li><li>	<a href="#What Next for the RCU API?">
	What Next for the RCU API?</a>
</li></ol>

<p>These sections are followed by
<a href="#Answers%20to%20Quick%20Quizzes">answers to the Quick Quizzes</a>.

</p><h4><a name="Software-Engineering Enhancements">
Software-Engineering Enhancements</a></h4>

<p>Pre-Linux experience with RCU-like primitives featured either
a small number of uses, a small number of developers, or both.
That experience gave no reason to believe that Linux would ever
contain more than a few hundred RCU call sites which could easily
be validated by inspection on each release of the Linux kernel,
thus making computer-assisted validation unnecessary.
Nevertheless, Linux developers quickly added checking in the form of
&ldquo;scheduling while atomic&rdquo; that triggered if a thread blocked
within an RCU read-side critical section in <code>CONFIG_PREEMPT</code>
kernels.
This provided as much checking as did any previous RCU implementation,
so life was good, at least for a while.
</p>

<p>Around 2005, the uptake of RCU in the Linux kernel increased
substantially.  Where it took about four years for the first thousand
RCU call sites, the second thousand took only about 18 months,
as did the third thousand.
Even given only the three thousand RCU call sites that were
in the kernel at the beginning of 2010, rechecking each instance
during the week after each release's merge window
would leave less than two minutes for each instance, assuming
an 80-hour week.
The odds of spotting subtle bugs on that kind of schedule are
vanishingly small.
This point was underscored by a
<a href="http://lkml.org/lkml/2009/12/9/479">patchset</a>
from Thomas Gleixner fixing a number of
<code>rcu_read_lock()</code>-omission bugs;
Tetsuo Handa
<a href="http://lkml.org/lkml/2009/12/10/496">followed up with a list of no fewer than 47 similar bugs</a>.
</p>

<p>I therefore started work on a patch that used
<a href="http://lwn.net/Articles/185666/">lockdep</a> to ensure that
<code>rcu_dereference()</code> calls are properly protected, either
by an RCU read-side critical section, by the update-side lock, or
by being inaccessible to readers, as
<a href="https://lwn.net/Articles/371986/">reported on LWN</a>.
I naively expected this to be the end of the story, but experience
with problems reported by lockdep RCU resulted in a number of changes
to the RCU API, which are documented below.
</p>

<p>Mathieu Desnoyers took interest in another set of RCU-usage bugs
in which the developer passes a given structure to <code>call_rcu()</code>
twice within a given grace period, and submitted a
<a href="http://lkml.org/lkml/2010/3/18/417">patch</a>
that uses debug objects to detect this sort of abuse.
Because the debug-objects facility does not track on-stack variables,
Mathieu added an additional pair of RCU APIs to control tracking of on-stack
<code>rcu_head</code> structures.
</p>

<p>Arnd Bergmann noted that lockdep RCU cannot be expected to
locate bugs where an RCU-protected pointer is accessed directly, without
the benefit of <code>rcu_dereference()</code>.
He therefore enlisted the aid of the
<a href="https://sparse.wiki.kernel.org/index.php/Main_Page">sparse</a>
static analysis tool by annotating
declarations of RCU-protected pointers with a new
<code>__rcu</code> macro.
This macro allows sparse to complain when an RCU-protected pointer is
accessed without the assistance of one of the <code>rcu_dereference()</code>
family of RCU APIs, which required some modifications to those APIs.
</p>

<p>A few other RCU API changes resulted from usage, filling out the
API as the need for additional RCU primitives arose.
The next sections discuss aspects of the RCU API, highlighting
recent changes.
</p>

<h4><a name="RCU has a Family of Wait-to-Finish APIs">
RCU has a Family of Wait-to-Finish APIs</a></h4>

<p>The most straightforward answer to &ldquo;what is RCU&rdquo; is that RCU is
an API used in the Linux kernel, as summarized by <a
href="/Articles/419086/">the big API table</a>
and the following discussion.
Or, more precisely, RCU is a four-member family of APIs as shown
in the table,
with each column corresponding to one of the family members.

</p><p>If you are new to RCU, you might consider focusing on just one
of the columns in the big RCU API table.
For example, if you are primarily interested in understanding how RCU
is most frequently used in the Linux kernel, &ldquo;RCU&rdquo;
would be the place to start.
On the other hand, if you want to understand RCU for its own sake,
&ldquo;SRCU&rdquo; has the simplest API.
You can always come back to the other columns later.
If you are already familiar with RCU, this table  can
serve as a useful reference.

</p>
<p><a name="Quick Quiz 1"><b>Quick Quiz 1</b>:</a>
Why are some of the cells in the big table colored green?

<p><a name="Quick Quiz 2"><b>Quick Quiz 2</b>:</a>
Why are some of the cells in the big table colored blue?

</p><p>The &ldquo;RCU&rdquo; column corresponds to the
original RCU implementation,
in which RCU read-side critical sections are delimited by
<code>rcu_read_lock()</code> and <code>rcu_read_unlock()</code>, which
may be nested.
The corresponding synchronous update-side primitives,
<code>synchronize_rcu()</code>, along with its synonym
<code>synchronize_net()</code>, wait for any currently executing
RCU read-side critical sections to complete.
The length of this wait is known as a &ldquo;grace period&rdquo;.
If grace periods are too long for you, <code>synchronize_rcu_expedited()</code>
speeds things up by about an order of magnitude, but at the expense of
significant CPU overhead.
The asynchronous update-side primitive, <code>call_rcu()</code>,
invokes a specified function with a specified argument after a
subsequent grace period.
For example, <code>call_rcu(p,f);</code> will result in
the &ldquo;RCU callback&rdquo; <code>f(p)</code>
being invoked after a subsequent grace period.
There are situations,
<a href="http://lwn.net/Articles/217484/">
such as when unloading a module that uses <code>call_rcu()</code></a>,
when it is necessary to wait for all
outstanding RCU callbacks to complete.
The <code>rcu_barrier()</code> primitive does this job.

</p><p>In the &ldquo;RCU BH&rdquo; column, <code>rcu_read_lock_bh()</code> and
<code>rcu_read_unlock_bh()</code> delimit RCU read-side critical
sections, and <code>call_rcu_bh()</code> invokes the specified
function and argument after a subsequent grace period.
There are also <code>synchronize_rcu_bh()</code>,
<code>synchronize_rcu_bh_expedited()</code>, and
<code>rcu_barrier_bh()</code> primitives, which are analogous to their
&ldquo;RCU&rdquo; counterparts.

</p><p>In the &ldquo;RCU Sched&rdquo; column, anything that disables preemption
acts as an RCU read-side critical section, and <code>synchronize_sched()</code>
waits for the corresponding RCU grace period.
This RCU API family was added in the 2.6.12 kernel, which split the
old <code>synchronize_kernel()</code> API into the current
<code>synchronize_rcu()</code> (for RCU) and
<code>synchronize_sched()</code> (for RCU Sched).
There are also <code>synchronize_sched()</code>,
<code>synchronize_sched_expedited()</code>, and
<code>rcu_barrier_sched()</code> primitives, which are analogous to their
&ldquo;RCU&rdquo; counterparts.

</p><p><a name="Quick Quiz 3"><b>Quick Quiz 3</b>:</a>
What happens if you mix and match RCU and RCU Sched?

</p><p>The "SRCU" column displays a specialized RCU API that permits
general sleeping in RCU read-side critical sections, as was
described in the LWN article
<a href="http://lwn.net/Articles/202847/">Sleepable RCU</a>.
Of course,
use of <code>synchronize_srcu()</code> in an SRCU read-side
critical section can result in
self-deadlock, so should be avoided.
SRCU differs from earlier RCU implementations in that the caller
allocates an <code>srcu_struct</code> for each distinct SRCU
usage.
This approach prevents SRCU read-side critical sections from blocking
unrelated <code>synchronize_srcu()</code> invocations.
In addition, in this variant of RCU, <code>srcu_read_lock()</code>
returns a value that must be passed into the corresponding
<code>srcu_read_unlock()</code>.

</p><p><a name="Quick Quiz 4"><b>Quick Quiz 4</b>:</a>
Why does SRCU lack an asynchronous <code>call_srcu()</code> interface?

</p><p><a name="Quick Quiz 5"><b>Quick Quiz 5</b>:</a>
Can <code>synchronize_srcu()</code> be safely
used within an SRCU read-side critical section?
If so, why?  If not, why not?

</p><p>The Linux kernel currently has a surprising number of RCU APIs and
implementations.
There is some hope of reducing this number, but
careful inspection and analysis will be required before
removing either an implementation or any API members, just as
would be required before removing one of the many locking APIs
in the Linux kernel.

</p><h4><a name="RCU has List-Based Publish-Subscribe and Version-Maintenance APIs">
RCU has List-Based Publish-Subscribe and Version-Maintenance APIs</a></h4>

<p>Fortunately, most of RCU's list-based publish-subscribe and
version-maintenance primitives shown in the following
table apply to all of the variants of RCU discussed above.
This commonality can in some cases allow more code to be shared,
which certainly reduces the API proliferation that would otherwise
occur.
However, it is quite likely that software-engineering considerations
will eventually result in variants of these list-handling primitives
that are specialized for each given flavor of RCU.

</p><table cellpadding="3" border=3>
<tbody><tr><th>Category</th>
	<th>Primitives</th>
		<th>Purpose</th>
</tr>
<tr class="Odd"><th rowspan=4 align="left">List traversal</th>
	<td><code>list_for_each_entry_rcu()</code></td>
		<td>Iterate over an RCU-protected list from the beginning.</td>
</tr>
<tr class="Odd">
	<td bgcolor=lightblue><code>list_for_each_entry_continue_rcu()</code></td>
		<td>Iterate over an RCU-protected list from the specified
		    element.</td>
</tr>
<tr class="Odd">
	<td bgcolor=lightblue><code>list_entry_rcu()</code></td>
		<td>Given a pointer to a raw <code>list_head</code>
		    in an RCU-protected list, return a pointer to
		    the enclosing element.</td>
</tr>
<tr class="Odd">
	<td bgcolor=lightblue><code>list_first_entry_rcu()</code></td>
		<td>Return the first element of an RCU-protected list.</td>
</tr>
<tr class="Even"><th rowspan="5" align="left">List update</th>
	<td><code>list_add_rcu()</code></td>
		<td>Add an element to the head of an RCU-protected list.</td>
</tr>
<tr class="Even">
	<td><code>list_add_tail_rcu()</code></td>
		<td>Add an element to the tail of an RCU-protected list.</td>
</tr>
<tr class="Even">
	<td><code>list_del_rcu()</code></td>
		<td>Delete the specified element from an RCU-protected
		    list, poisoning the <code>-&gt;pprev</code> pointer
		    but not the <code>-&gt;next</code> pointer.</td>
</tr>
<tr class="Even">
	<td><code>list_replace_rcu()</code></td>
		<td>Replace the specified element in an RCU-protected
		    list with the specified element.</td>
</tr>
<tr class="Even">
	<td><code>list_splice_init_rcu()</code></td>
		<td>Move all elements from an RCU-protected list
		    to another RCU-protected list.</td>
</tr>
<tr class="Odd"><th rowspan=4 align="left">Hlist traversal</th>
	<td><code>hlist_for_each_entry_rcu()</code></td>
		<td>Iterate over an RCU-protected hlist from the beginning.</td>
</tr>
<tr class="Odd">
	<td bgcolor=lightblue><code>hlist_for_each_entry_rcu_bh()</code></td>
		<td>Iterate over an RCU-bh-protected hlist from the
		    beginning.</td>
</tr>
<tr class="Odd">
	<td bgcolor=lightblue><code>hlist_for_each_entry_continue_rcu()</code></td>
		<td>Iterate over an RCU-protected hlist from the specified
		    element.</td>
</tr>
<tr class="Odd">
	<td bgcolor=lightblue><code>hlist_for_each_entry_continue_rcu_bh()</code></td>
		<td>Iterate over an RCU-bh-protected hlist from the specified
		    element.</td>
</tr>
<tr class="Even"><th rowspan="6" align="left">Hlist update</th>
	<td><code>hlist_add_after_rcu()</code></td>
		<td>Add an element after the specified element in an
		    RCU-protected hlist.</td>
</tr>
<tr class="Even">
	<td><code>hlist_add_before_rcu()</code></td>
		<td>Add an element before the specified element in an
		    RCU-protected hlist.</td>
</tr>
<tr class="Even">
	<td><code>hlist_add_head_rcu()</code></td>
		<td>Add an element at the head of an RCU-protected hlist.</td>
</tr>
<tr class="Even">
	<td><code>hlist_del_rcu()</code></td>
		<td>Delete the specified element from an RCU-protected
		    hlist, poisoning the <code>-&gt;pprev</code> pointer
		    but not the <code>-&gt;next</code> pointer.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>hlist_del_init_rcu()</code></td>
		<td>Delete the specified element from an RCU-protected
		    hlist, initializing the element's reverse pointer
		    after deletion.</td>
</tr>
<tr class="Even">
	<td><code>hlist_replace_rcu()</code></td>
		<td>Replace the specified element in an RCU-protected
		    hlist with the specified element.</td>
</tr>
<tr class="Even"><th rowspan="1" align="left">Hlist nulls traversal</th>
	<td bgcolor=lightblue><code>hlist_nulls_for_each_entry_rcu()</code></td>
		<td>Iterate over an RCU-protected hlist-nulls list
		    from the beginning.</td>
</tr>
<tr class="Even"><th rowspan="3" align="left">Hlist nulls update</th>
	<td bgcolor=lightblue><code>hlist_nulls_del_init_rcu()</code></td>
		<td>Delete the specified element from an RCU-protected
		hlist-nulls list, initializing the element after
		deletion.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>hlist_nulls_del_rcu()</code></td>
		<td>Delete the specified element from an RCU-protected
		    hlist-nulls list, poisoning the <code>-&gt;pprev</code>
		    pointer but not the <code>-&gt;next</code> pointer.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>hlist_nulls_add_head_rcu()</code></td>
		<td>Add an element to the head of an RCU-protected
		    hlist-nulls list.</td>
</tr>
</tbody></table>

<p>The first pair of categories operate on the Linux kernel's
<code>struct&nbsp;list_head</code> lists, which are circular, doubly-linked
lists.
These primitives permit lists to be modified in the face of concurrent
traversals by readers.
The list-traversal primitives are implemented with simple instructions,
so are extremely lightweight, though they also
<a href="http://www.openvms.compaq.com/wizard/wiz_2637.html">execute a memory barrier on DEC Alpha</a>.
The list-update primitives that add elements to a list incur memory-barrier
overhead, while those that only remove elements from a list are implemented
using simple instructions.
The <code>list_splice_init_rcu()</code> primitive incurs not only
memory-barrier overhead, but also grace-period latency, and is therefore
the only blocking primitive shown in the table.

</p><p><a name="Quick Quiz 6"><b>Quick Quiz 6</b>:</a>
Why doesn't <code>list_del_rcu()</code> poison both the <code>next</code>
and <code>prev</code> pointers?

</p><p>The second pair of categories operate on the Linux kernel's
<code>struct&nbsp;hlist_head</code>, which is a linear linked list.
One advantage of <code>struct&nbsp;hlist_head</code> over
<code>struct&nbsp;list_head</code> is that the former requires only
a single-pointer list header, which can save significant memory in
large hash tables.
The <code>struct&nbsp;hlist_head</code> primitives in the table
relate to their non-RCU counterparts in much the same way as do the
<code>struct&nbsp;list_head</code> primitives.
Their overheads are similar to that of their list counterparts in the
first two categories in the table.

</p><p>The third and final pair of categories operate on Linux-kernel
hlist-nulls lists, which are made up of <code>hlist_nulls_head</code> and
<code>hlist_nulls_node</code> structures.
These lists have special multi-valued <code>NULL</code> pointers, which
have the low-order bit set to 1 with the upper bits available to the
programmer to distinguish different lists.
There are hlist-nulls interfaces for non-RCU-protected lists as well.

</p><p><a name="Quick Quiz 7"><b>Quick Quiz 7</b>:</a>
Why would anyone need to distinguish lists based on their NULL
pointers?  Why not just remember which list you started searching???

</p><p>A major advantage of hlist-nulls lists is that updaters can
free elements to <code>SLAB_DESTROY_BY_RCU</code> slab caches without
waiting for an RCU grace period to elapse.
However, readers must be extremely careful when traversing such lists:
Not only must they conduct their searches within a single RCU read-side
critical section, but because any element might be freed and then
reallocated at any time, readers must also validate each element that
they encounter during their traversal.

</p><p><a name="Quick Quiz 8"><b>Quick Quiz 8</b>:</a>
Why is there no <code>hlist_nulls_add_tail_rcu()</code>?

</p><h4><a name="RCU has Pointer-Based Publish-Subscribe and Version-Maintenance APIs">
RCU has Pointer-Based Publish-Subscribe and Version-Maintenance APIs</a></h4>

<p>Although RCU's list-based APIs are quite useful, there are times when
a hand-crafted data structure is required, for example, RCU-protected
arrays and trees.
RCU provides for these situations with the pointer-access and -update
APIs in the following table:
</p>

<table cellpadding="3" border=3>
<tbody><tr><th>Category</th>
	<th>Primitives</th>
		<th>Purpose</th></tr>
<tr class="Odd"><th align="left">Pointer update</th>
	<td><code>rcu_assign_pointer()</code></td>
		<td>Assign to an RCU-protected pointer.</td>
</tr>
<tr class="Even"><th rowspan="12" align="left">Pointer access</th>
	<td><code>rcu_dereference()</code></td>
		<td>Fetch an RCU-protected pointer, giving an
		    lockdep-RCU error message if not in an RCU read-side
		    critical section.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>rcu_dereference_bh()</code></td>
		<td>Fetch an RCU-protected pointer, giving an
		    lockdep-RCU error message if not in an RCU-bh read-side
		    critical section.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>rcu_dereference_sched()</code></td>
		<td>Fetch an RCU-protected pointer, giving an
		    lockdep-RCU error message if not in an RCU-sched read-side
		    critical section.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>srcu_dereference()</code></td>
		<td>Fetch an RCU-protected pointer, giving an
		    lockdep-RCU error message if not in the specified SRCU
		    read-side critical section.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>rcu_dereference_protected()</code></td>
		<td>Fetch an RCU-protected pointer with no protection
		    against concurrent updates, giving an lockdep-RCU
		    error message if the specified lockdep condition does not
		    hold.  This primitive is normally used when the
		    update-side lock is held.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>rcu_dereference_check()</code></td>
		<td>Fetch an RCU-protected pointer, giving an
		    lockdep-RCU error message if (1) the specified lockdep condition
		    does not hold and (2) not under the protection of
		    <code>rcu_read_lock()</code>.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>rcu_dereference_bh_check()</code></td>
		<td>Fetch an RCU-bh-protected pointer, giving an
		    lockdep-RCU error message if (1) the specified lockdep condition
		    does not hold and (2) not under the protection of
		    <code>rcu_read_lock_bh()</code> (2.6.37 or later).</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>rcu_dereference_sched_check()</code></td>
		<td>Fetch an RCU-sched-protected pointer, giving an
		    lockdep-RCU error message if (1) the specified lockdep condition
		    does not hold and (2) not under the protection of
		    <code>rcu_read_lock_sched()</code> or friend
		    (2.6.37 or later).</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>srcu_dereference_check()</code></td>
		<td>Fetch an SRCU-protected pointer, giving an
		    lockdep-RCU error message if (1) the specified lockdep condition
		    does not hold and (2) not under the protection of
		    the specified
		    <code>srcu_read_lock()</code> (2.6.37 or later).</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>rcu_dereference_index_check()</code></td>
		<td>Fetch an RCU-protected integral index, giving an
		    lockdep-RCU error message if the specified lockdep condition
		    does not hold.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>rcu_access_pointer()</code></td>
		<td>Fetch an RCU-protected value (pointer or index), but
		    with no protection against concurrent updates.
		    This primitive is normally used to do pointer
		    comparisons, for example, to check for a
		    <code>NULL</code> pointer.</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>rcu_dereference_raw()</code></td>
		<td>Fetch an RCU-protected pointer with no lockdep-RCU
		    checks.  Use of this primitive is strongly
		    discouraged.
		    If you must use this primitive, add a comment stating
		    why, just as you would with <code>smp_mb()</code>.</td>
</tr>
</tbody></table>

<p>The <code>rcu_assign_pointer()</code> primitive assigns a new value to an
RCU-protected pointer, but ensuring that any
prior initialization of the pointed-to structure remains
ordered before the assignment to the
pointer, even on weakly ordered machines.
You can think of <code>rcu_assign_pointer()</code> as publishing a new
data structure to RCU readers.

</p><p>Similarly, the <code>rcu_dereference()</code> primitive reads from
an RCU-protected pointer, but ensuring that subsequent
code dereferencing that pointer will see the effects of initialization code
prior to the corresponding <code>rcu_assign_pointer()</code>, prohibiting
aggressively optimizing compilers (and the Alpha CPU) from reordering the
dereferencing in a way that causes it to  precede the
<code>rcu_dereference()</code>. 
In addition, <code>rcu_dereference()</code> documents which pointer
dereferences are protected by RCU.
You can think of <code>rcu_dereference()</code> and similar primitives
as subscribing to the current version of an RCU-protected pointer.

</p><p><a name="Quick Quiz 9"><b>Quick Quiz 9</b>:</a>
Normally, any pointer subject to <code>rcu_dereference()</code> should
always be updated using <code>rcu_assign_pointer()</code>.
What is an exception to this rule?

</p><p>Recent changes introduced the <code>CONFIG_PROVE_RCU</code>
kernel configuration parameter, which causes <code>rcu_dereference()</code>
to verify that it is being used under the protection of
<code>rcu_read_lock()</code>, emitting a lockdep-RCU error message
(also called &ldquo;lockdep-RCU splat&rdquo;) if not.
Of course, there are multiple flavors of RCU, so that the Linux
kernel now has corresponding flavors of <code>rcu_dereference()</code>,
adding <code>rcu_dereference_bh()</code>, <code>rcu_dereference_sched()</code>,
and <code>srcu_dereference()</code>.
Use of these primitives allows you to make your code automatically
check for proper use of RCU.

</p><p>It is of course also legal to access RCU-protected pointers while
holding the update-side lock, in which case the data structure cannot
change, which means that the compiler constraints and (on Alpha) memory
barriers can be omitted.
The <code>rcu_dereference_protected()</code> primitive is designed for
this situation.
It takes the RCU-protected pointer as its first argument and a lockdep
expression as its second argument, allowing the code to verify that
the required locks really are held.

</p><p>It is also legal to access RCU-protected pointers in functions
that are invoked by both readers and updaters.
In this case, protection against concurrent updates is still required,
but the lockdep checks must allow for the possibility of RCU read-side
critical sections as well as lock-based critical sections.
The <code>rcu_dereference_check()</code> primitive is the tool for this
job.
It correctly handles concurrent updates, but also provides a second
argument for a lockdep expression for update-side locks.
If <code>rcu_dereference_check()</code> is called outside of the
protection of <code>rcu_read_lock()</code> and of the specified locks,
it will emit a lockdep-RCU splat.
There are also <code>rcu_dereference_bh_check()</code>,
<code>rcu_dereference_sched_check()</code>,
and <code>srcu_dereference_check()</code> for RCU-bh, RCU-sched,
and SRCU, respectively.

</p><p>One of the side-effects of Arnd's sparse-based checking for
misuse of RCU-protected pointers is that all of the members of
the <code>rcu_dereference()</code> family now require a real
pointer of a type that really can be dereferenced.
Further, this pointer must be a C lvalue rather than an rvalue,
so that <code>rcu_dereference(p)</code> is legal, but
<code>rcu_dereference(i)</code> (where <code>i</code> is an integer) and
<code>rcu_dereference(p+1)</code> are not.
Because there really is code in the Linux kernel with RCU-protected
indexes (as opposed to pointers), the
<code>rcu_dereference_index_check()</code>
primitive handles the index case, and takes a lockdep expression identifying
the locks and types of RCU that protect the access (see table below).
Unfortunately, this also disables sparse-based checking, so it is possible
that this primitive will be deprecated in the future in favor of
pointers.  (So if you know of an RCU-protected index that cannot be
easily converted to an RCU-protected pointer, this would be a really
good time to speak up!)

</p><p>In some cases, only the value of the RCU-protected pointer is
used without being dereferenced; for example, the RCU-protected pointer
might simply be compared against <code>NULL</code>.
There is no need to protect against concurrent updates, and there is
also no need to be under the protection of <code>rcu_read_lock()</code>
or friends.
The <code>rcu_access_pointer()</code> primitive is designed for this
situation.

</p><p>Finally, RCU is used by some data structures such as radix
trees, where any flavor of RCU might be used for read-side protection,
or where locking might provide protection, depending on the
usage.
The <code>rcu_dereference_raw()</code> primitive is designed for this
purpose.
Note however, that this disables all lockdep-RCU checking, so please
avoid using this where possible.
Where it must be used, include a comment saying why its use is safe.

</p><h4><a name="RCU has Debugging APIs">RCU has Debugging APIs</a></h4>

<p>RCU has also gained a number of debugging APIs, shown in the following
table:

</p><table cellpadding="3" border=3>
<tbody><tr><th>Category</th>
	<th>Primitives</th>
		<th>Purpose</th>
</tr>
<tr class="Odd"><th rowspan=1 align="left">RCU pointer declaration</th>
	<td bgcolor=lightblue><code>__rcu</code></td>
		<td>Tell sparse that a given pointer is intended to
		    be protected by RCU.</td>
</tr>
<tr class="Even"><th rowspan=2 align="left">Callback tracking</th>
	<td bgcolor=lightblue><code>init_rcu_head_on_stack()</code></td>
		<td>Prepare on-stack callback for debug-objects
		    (<code>CONFIG_DEBUG_OBJECTS_RCU_HEAD</code>).</td>
</tr>
<tr class="Even">
	<td bgcolor=lightblue><code>destroy_rcu_head_on_stack()</code></td>
		<td>Prepare on-stack callback for exiting scope.</td>
</tr>
<tr class="Odd"><th rowspan="4" align="left">Critical section validation</th>
	<td bgcolor=lightblue><code>rcu_read_lock_held()</code></td>
		<td>Splat unless under <code>rcu_read_lock()</code>.</td>
</tr>
<tr class="Odd">
	<td bgcolor=lightblue><code>rcu_read_lock_bh_held()</code></td>
		<td>Splat unless under <code>rcu_read_lock_bh()</code>
		or unless interrupts are disabled.</td>
</tr>
<tr class="Odd">
	<td bgcolor=lightblue><code>rcu_read_lock_sched_held()</code></td>
		<td>Splat unless under <code>rcu_read_lock_sched()</code>
		    or friend.</td>
</tr>
<tr class="Odd">
	<td bgcolor=lightblue><code>srcu_read_lock_held()</code></td>
		<td>Splat unless under specified
		    <code>srcu_read_lock()</code>.</td>
</tr>
</tbody></table>

<p>The first debugging API is used to mark an RCU-protected pointer, for
example:

<pre>
    struct foo __rcu *foo_p;
</pre>

<p>If a pointer is marked with <code>__rcu</code>, then all accesses to
this pointer must be made via <code>rcu_assign_pointer()</code> or via
one of the <code>rcu_dereference()</code> family of APIs, otherwise
sparse will flag the error when the <code>CONFIG_SPARSE_RCU_POINTER</code>
kernel configuration parameter is set.
Note that <code>__rcu</code> may be used to tag arguments passed in to
functions as well as global variables, struct fields, and the like.

</p><p>Just as a double <code>kfree()</code> is a bug, so is a double
invocation of <code>call_rcu()</code> using the same pointer.
If the <code>CONFIG_DEBUG_OBJECTS_RCU_HEAD</code> kernel configuration
parameter is set, then debug objects will flag this sort of abuse.
However, the debug-objects mechanism does not track objects on the
stack by default.
Therefore, when working with a stack-based <code>rcu_head</code>
structure, use <code>init_rcu_head_on_stack()</code> before the
first use and <code>destroy_rcu_head_on_stack()</code> before the
corresponding stack frame is deallocated.

</p><p>Finally, it is common practice to include a header comment on
functions that require RCU protection.
Although this is good practice, it is far better to enlist the
computer's help in locating cases where RCU protection has been omitted.
The <code>rcu_read_lock_held()</code>,
<code>rcu_read_lock_bh_held()</code>,
<code>rcu_read_lock_sched_held()</code>, and
<code>srcu_read_lock_held()</code> primitives enable debug checks in the
code itself.
These primitives provide the most useful information when the
<code>CONFIG_PROVE_RCU</code> kernel parameter is set.

</p><p>These debugging APIs can be extremely helpful.
It does take a little extra work to get them set up correctly,
but much less work than is required to debug RCU usage problems
the hard way!!!

</p><p><a name="Quick Quiz 10"><b>Quick Quiz 10</b>:</a>
Why isn't there a debugging API to check for mismatching read-side
and grace-period primitives, for example, using <code>rcu_read_lock()</code>
on the read side, but incorrectly using <code>synchronize_sched()</code>
during updates?

</p><h4><a name="Kernel Configuration Parameters">
Kernel Configuration Parameters</a></h4>

<p>RCU's kernel-configuration parameters can be considered to be part of the
RCU API, most especially from the viewpoint of someone building a
kernel intended for a specialized device or workload.
This section summarizes the RCU-related configuration parameters.

</p><p>The first set of parameters controls the underlying behavior of
the RCU implementation itself, and is defined in <code>init/Kconfig</code>.

<ol>
<li>	<code>CONFIG_TREE_RCU</code>: selects the non-preemptible
	tree-based RCU implementation that is appropriate for
	server-class SMP builds.  It can accommodate a very large
	number of CPUs, but scales down sufficiently well for
	all but the most memory-constrained systems.
	The following kernel parameters may also be specified
	when <code>CONFIG_TREE_RCU</code> is specified:
	<ol type=a>
	<li>	<code>CONFIG_RCU_TRACE</code> enables <code>debugfs</code>-based
		tracing.
	<li>	<code>CONFIG_RCU_FANOUT</code> controls the fanout
		of the tree.  Lower fanout values reduce lock contention,
		but also consumes more memory and increases the
		overhead of grace-period computations.
		To the best of my knowledge, the default values have
		been always been sufficient.
	<li>	<code>CONFIG_RCU_FANOUT_EXACT</code> forces the tree
		to be as balanced as possible.
		Again, to the best of my knowledge, the default values
		have always been sufficient.
	<li>	<code>CONFIG_RCU_FAST_NO_HZ</code> causes the last
		non-dyntick-idle CPU to be more aggressive about
		entering dyntick-idle state.
		If you are not working with an SMP battery-powered
		device, you probably don't care about this parameter.
	</ol>
	In addition, the following  parameters may be specified,
	either on the boot command line or via <code>sysfs</code>:
	<ol type=a>
	<li>	<code>blimit</code>: This specifies the maximum number
		of RCU callbacks that may be processed consecutively,
		and defaults to 10.
	<li>	<code>qhimark</code>: If the number of callbacks waiting
		on a given CPU exceeds this number, which defaults to
		10,000, then <code>blimit</code> is ignored and RCU
		callbacks will be processed indefinitely if need be.
	<li>	<code>qlomark</code>: If a given CPU is in indefinite-callback
		mode, then it will return to normal <code>blimit</code>-based
		callback processing once the number of outstanding
		RCU callbacks drops below <code>qlomark</code>, which
		defaults to 100.
	</ol>
<p>
<li>	<code>CONFIG_TREE_PREEMPT_RCU</code>: selects the
	preemptible tree-based RCU implementation that is appropriate
	for real-time and low-latency SMP builds.
	It can also accommodate a very large number of CPUs, and
	also scales down sufficiently well for all but
	the most memory-constrained systems.
	The <code>CONFIG_RCU_TRACE</code>,
	<code>CONFIG_RCU_FANOUT</code>,
	<code>CONFIG_RCU_FANOUT_EXACT</code>,
	<code>blimit</code>,
	<code>qhimark</code>, and
	<code>qlomark</code>
	parameters are supported as noted above.
<p>
<li>	<code>CONFIG_TINY_RCU</code>: selects the non-preemptible
	uniprocessor RCU implementation that is appropriate for
	non-real-time UP builds.  It has the smallest memory
	footprint of any of the current in-kernel RCU implementations.
<p>
<li>	<code>CONFIG_TINY_PREEMPT_RCU</code>: selects the preemptible
	uniprocessor RCU implementation that is appropriate for
	real-time UP builds.  It also boasts a small memory
	footprint, though not quite so small as
	<code>CONFIG_TINY_RCU</code>.
	This implementation was produced as part of the
	<a href="http://www.linaro.org/">Linaro</a> effort.
</ol>

<p>The second set of kernel configuration parameters controls debugging
options:

<ol>
<li>	<code>CONFIG_SPARSE_RCU_POINTER</code> enables sparse-based
	checks of proper use of RCU-protected pointers.
	Please note that this is a build-time check: Use
	&ldquo;make C=1&rdquo; to cause sparse to check source files that
	would have been rebuilt by &ldquo;make&rdquo;, and use
	&ldquo;make C=2&rdquo; to cause sparse to unconditionally
	check source files.
<p>
<li>	<code>CONFIG_DEBUG_OBJECTS_RCU_HEAD</code> enables
	debug-objects checking of multiple invocations of
	<code>call_rcu</code> (and friends) on the same structure.
<p>
<li>	<code>CONFIG_PROVE_RCU</code> enables lockdep-RCU checking.
	If <code>CONFIG_PROVE_RCU_REPEATEDLY</code> is also
	specified, then the lockdep-RCU checking can output multiple
	lockdep-RCU &ldquo;splats&rdquo;, otherwise only a single
	lockdep-RCU splat will be emitted per boot.
<p>
<li>	<code>CONFIG_RCU_TORTURE_TEST</code> enables RCU torture
	testing.
	This is a tri-state parameter, permitting <code>rcutorture.c</code>
	to be compiled into the kernel, built as a module, or omitted
	entirely.
	When <code>rcutorture.c</code> is built into the kernel
	(<code>CONFIG_RCU_TORTURE_TEST=y</code>), then
	<code>CONFIG_RCU_TORTURE_TEST_RUNNABLE</code>
	starts RCU torture testing during boot.
	Please don't try this on a production system!
<p>
<li>	<code>CONFIG_RCU_CPU_STALL_DETECTOR</code>, which is enabled
	by default for <code>CONFIG_TREE_RCU</code> and
	<code>CONFIG_TREE_PREEMPT_RCU</code> kernels, provides RCU-based
	checking for CPU stalls, which occur when a CPU or task
	fails to find its way out of an RCU read-side critical section
	in a timely manner.
	CPU stalls can be caused by a number of bugs, as described
	in <code>Documentation/RCU/stallwarn.txt</code>.
	The stall-warning timeout is controlled by
	<code>CONFIG_RCU_CPU_STALL_TIMEOUT</code>, which defaults
	to 60 seconds.
	If <code>CONFIG_RCU_CPU_STALL_DETECTOR_RUNNABLE</code> is
	set, which it is by default, then CPU stalls are checked
	for starting early in boot, otherwise, the
	<code>rcu_cpu_stall_suppress</code> module parameter must
	be manually specified (via either the boot-time command line
	or via <code>sysfs</code>) in order to start CPU stall checking.
	If <code>CONFIG_RCU_CPU_STALL_VERBOSE</code> is set,
	which it also is by default, then detailed per-task
	information is printed when a CPU stall is encountered.
</ol>

<p>If you are working with code that uses RCU, please do us all
a favor and test that code with <code>CONFIG_PROVE_RCU</code>
and <code>CONFIG_DEBUG_OBJECTS_RCU_HEAD</code> enabled.
Please also consider running sparse with
<code>CONFIG_SPARSE_RCU_POINTER</code>.
If you are modifying the RCU implementation itself, you will need to
run rcutorture, with multiple runs covering the relevant kernel
configuration parameters.
A one-hour rcutorture run on an 8-CPU machine qualifies as light
rcutorture testing.
</p>

<p>Yes, running extra tests can be a hassle, but I am here to tell you
that extra testing is <i>much</i>
easier than trying to track down bugs in your RCU code!!!
</p>

<h4><a name="What Next for the RCU API?">
What Next for the RCU API?</a></h4>

<p>The most honest answer is that I do not know.
The next steps for the RCU API will be decided as they always have
been, by the needs of RCU's users and by the limits of the technology
at the time.
That said, the following seem to be a few of the more likely directions:

<ol>
<li>	Complete implementation of RCU priority boosting
	(<code>TINY_RCU</code> submission slated for 2.6.38,
	<code>TREE_RCU</code> implementation in progress).
<p>
<li>	Support for running certain types of user applications without
	scheduler ticks.
	There was a spirited discussion on this topic at Linux Plumbers
	Conference, but at this writing it appears that only small
	tweaks to RCU will be required.
<p>
<li>	Merge the implementation of SRCU into <code>TINY_RCU</code>
	and <code>TREE_RCU</code>.
	A design for this is in mostly in place.
	This effort is likely to result in <code>call_srcu()</code>
	and <code>srcu_barrier()</code>.
	If it does, please be <i>very</i> careful with these primitives!!!
<p>
<li>	Make <code>RCU_FAST_NO_HZ</code> work for <code>TREE_PREEMPT_RCU</code>.
<p>
<li>	Drive the choice between <code>TINY_PREEMPT_RCU</code>,
	<code>TINY_RCU</code>, <code>TREE_PREEMPT_RCU</code>, and
	<code>TREE_RCU</code> entirely off of <code>SMP</code>
	and <code>PREEMPT</code>.
	This would allow cutting code and test scenarios, but
	first <code>TINY_PREEMPT_RCU</code> must prove itself.
<p>
<li>	It is possible that <code>rcu_dereference_index_check()</code> will
	be retired if it is reasonable to convert all current use of
	RCU-protected indexes into RCU-protected pointers.
<p>
<li>	It is quite possible that large systems might encounter problems
	with <code>synchronize_rcu_expedited()</code> scalability.
<p>
<li>	Make RCU be more aggressive about entering
		dyntick-idle state when running on lightly
		loaded systems with four or more CPUs.
<p>
<li>	Numerous other items listed on the
	<a href="http://kernel.org/pub/linux/kernel/people/paulmck/rcutodo.html">RCU to-do list</a>.
</ol>

<p>But if the past is any guide, new use cases and workloads will place
unanticipated demands on RCU.

</p><h4>Acknowledgments</h4>

<p>We are all indebted to Andy Whitcroft, Jon Walpole, Gautham Shenoy,
and LWN member jarkao2,
whose review of early drafts of this document greatly improved it.
A great many people helped find and address issues located by the
software-engineering enhancements to RCU, including
Andi Kleen, Andrew Morton, Avi Kivity, Ben Greear, Daniel J Blueman, David
Howells, Dhaval Giani, Eric Dumazet, Eric Paris, Frederic Weisbecker, Greg
Thelen, Heiko Carstens, Ilia Mirkin, Ingo Molnar, Jens Axboe, Jiri Slaby,
Johannes Berg, KAMEZAWA Hiroyuki, KOSAKI Motohiro, Lai Jiangshan, Marcelo
Tosatti, Mathieu Desnoyers, Miles Lane, Minchan Kim, Oleg Nesterov,
Paul Moore, Peter Zijlstra, Robert Olsson, Sergey Senozhatsky, Subrata
Modak, Tetsuo Handa, Thomas Gleixner, Trond Myklebust, Valdis Kletnieks,
Vegard Nossum, Vivek Goyal, and Zdenek Kabelac.
I owe thanks to the members of the Relativistic Programming project
and to members of PNW TEC for many valuable discussions.
I am grateful to Dan Frye for his support of this effort.

</p><p>This work represents the view of the author and does not necessarily
represent the view of IBM.

</p><p>Linux is a registered trademark of Linus Torvalds.

</p><p>Other company, product, and service names may be trademarks or
service marks of others.


<h4><a name="Answers to Quick Quizzes">
Answers to Quick Quizzes</a></h4>

<p><b>Quick Quiz 1</b>:
Why are some of the cells in the above table colored green?

</p><p><b>Answer</b>: The green API members (<code>rcu_read_lock()</code>,
<code>rcu_read_unlock()</code>, and <code>call_rcu()</code>) were the
only members of the RCU (then called &ldquo;rclock&rdquo;) API back in
the mid-90s.
During this timeframe, Paul was under the mistaken impression that
he knew all that there is to know about RCU.

</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>

</p><p><b>Quick Quiz 2</b>:
Why are some of the cells in the above table colored blue?

</p><p><b>Answer</b>: Because the corresponding API members are new
since the 2008 version of
<a href="http://lwn.net/Articles/264090/">RCU part 3: the RCU API</a>.

</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>

</p><p><b>Quick Quiz 3</b>:
What happens if you mix and match RCU and RCU Sched?

</p><p><b>Answer</b>: In a <code>CONFIG_TREE_RCU</code> or a
<code>CONFIG_TINY_RCU</code> kernel, mixing these
two works "by accident" because in those kernel builds, RCU and RCU
Sched map to the same implementation.
However, this mixture is fatal in <code>CONFIG_TREE_PREEMPT_RCU</code>
and <code>CONFIG_TINY_PREEMPT_RCU</code> builds,
due to the fact that RCU's read-side critical
sections can then be preempted, which would permit
<code>synchronize_sched()</code> to return before the
RCU read-side critical section reached its <code>rcu_read_unlock()</code>
call.
This could in turn result in a data structure being freed before the
read-side critical section was finished with it,
which could in turn greatly increase the actuarial risk experienced
by your kernel.

</p><p>Even in <code>CONFIG_TREE_RCU</code> and
<code>CONFIG_TINY_RCU</code> builds, such mixing and matching is of
course very strongly discouraged.
Mixing and matching other flavors of RCU is also a very bad idea.

</p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>

</p><p><b>Quick Quiz 4</b>:
Why does SRCU lack an asynchronous <code>call_srcu()</code> interface?

</p><p><b>Answer</b>: Given an asynchronous interface, a single task
could register an arbitrarily large number of SRCU callbacks,
thereby consuming an arbitrarily large quantity of memory.
In contrast, given the current synchronous
<code>synchronize_srcu()</code>
interface, a given task must finish waiting for a given grace period
before it can start waiting for the next one.

</p><p>However, there is a good chance that a <code>call_srcu()</code>
will become available in the near future.
If it does, and if you decide to use it, please be careful!!!

</p><p><a href="#Quick%20Quiz%204"><b>Back to Quick Quiz 4</b>.</a>

</p><p><a name="Quick Quiz 5"><b>Quick Quiz 5</b>:</a>
Can <code>synchronize_srcu()</code> be safely
used within an SRCU read-side critical section?
If so, why?  If not, why not?

</p><p><b>Answer</b>: In principle, you can use
<code>synchronize_srcu()</code> with a given <code>srcu_struct</code>
within an SRCU read-side critical section that uses some other
<code>srcu_struct</code>.
In practice, however, such use is almost certainly a bad idea.
In particular, the following could still result in deadlock:

</p><blockquote>
<pre>idx = srcu_read_lock(&amp;ssa);
synchronize_srcu(&amp;ssb);
srcu_read_unlock(&amp;ssa, idx);

/* . . . */

idx = srcu_read_lock(&amp;ssb);
synchronize_srcu(&amp;ssa);
srcu_read_unlock(&amp;ssb, idx);
</pre>
</blockquote>

<p>The reason that this code fragment can result in deadlock is that we
have a cycle.
The <code>ssa</code> read-side critical sections can wait on an
<code>ssb</code> grace period, which waits on <code>ssb</code> read-side
critical sections, which contains a <code>synchronize_srcu()</code>, which
in turn waits on <code>ssa</code> read-side critical sections.

</p><p>So if you do include <code>synchronize_srcu()</code> in SRCU
read-side critical sections, make sure to avoid cycles.
Of course, the simplest way to avoid cycles is to avoid using
<code>synchronize_srcu()</code> in SRCU read-side critical sections
in the first place.

<p><a href="#Quick%20Quiz%205"><b>Back to Quick Quiz 5</b>.</a>

</p><p><b>Quick Quiz 6</b>:
Why doesn't <code>list_del_rcu()</code> poison both the <code>next</code>
and <code>prev</code> pointers?

</p><p><b>Answer</b>: Poisoning the <code>next</code> pointer would interfere
with concurrent RCU readers, which must use this pointer.
However, RCU readers are forbidden from using the <code>prev</code>
pointer, so it may safely be poisoned.

</p><p><a href="#Quick%20Quiz%206"><b>Back to Quick Quiz 6</b>.</a>

</p><p><b>Quick Quiz 7</b>:
Why would anyone need to distinguish lists based on their NULL
pointers?  Why not just remember which list you started searching???

</p><p><b>Answer</b>: Suppose that CPU 0 is traversing such a list
within an RCU read-side critical section,
where the elements are allocated from <code>SLAB_DESTROY_BY_RCU</code>
slab cache.
The elements could therefore be freed and reallocated at any time.
If CPU 0 is referencing an element while CPU 1 is freeing that element,
and if CPU 1 then quickly reallocates that same element and adds it to
some other list,
then CPU 0 will be transported to that new list along with the element.
In this case, remembering the starting list would clearly be unhelpful.

</p><p>To make matters worse, suppose that CPU 0 searches a list and
fails to find the element that it was looking for.
Was that because the element did not exist?
Or because CPU 0 got transported to some other list in the meantime?
Readers traversing <code>SLAB_DESTROY_BY_RCU</code> lists must carefully
validate each element and check for being moved to another list.
One way to check for being moved to another list is for each list to
have its own value for the <code>NULL</code> pointer.
These checks are subtle and easy to get wrong, so please be careful!

</p><p><a href="#Quick%20Quiz%207"><b>Back to Quick Quiz 7</b>.</a>

</p><p><b>Quick Quiz 8</b>:
Why is there no <code>hlist_nulls_add_tail_rcu()</code>?

</p><p><b>Answer</b>: Suppose that CPU 0 is traversing an hlist-nulls
list under RCU protection.
Suppose that while CPU 0 is referencing list element A, CPU 1 frees
it and reallocates it, adding
it to another list, which CPU 0 unwittingly starts traversing.
Suppose further that while CPU 0 is referencing an element B in the
new list, CPU 2 frees and reallocates it, moving it back to the original list.
When CPU 0 comes to the end of the original list, it sees that the
<code>NULL</code> pointer has the proper value, so does not realize that it
has been moved.

</p><p>If CPU 2 had added element B at the tail of the list,
CPU 0 would be within its rights to conclude that it had fully searched
this list when in fact it had not.
But given that it is only possible to add elements to the head of an
hlist-nulls list, any CPU coming to the end of the same list it started
traversing can be sure that it really did search the entire list.
Possibly several times, if it was extremely unlucky.

</p><p>Therefore, there is not and should never be a primitive to
add to the middle or the end of an RCU-protected hlist-nulls list.
Except maybe at initialization time, before any readers have access
to the list.

</p><p><a href="#Quick%20Quiz%208"><b>Back to Quick Quiz 8</b>.</a>

</p><p><b>Quick Quiz 9</b>:
Normally, any pointer subject to <code>rcu_dereference()</code> <i>must</i>
always be updated using <code>rcu_assign_pointer()</code>.
What is an exception to this rule?

</p><p><b>Answer</b>: One such exception is when a multi-element linked
data structure is initialized as a unit while inaccessible to other
CPUs, and then a single <code>rcu_assign_pointer()</code> is used
to plant a global pointer to this data structure.
The initialization-time pointer assignments need not use
<code>rcu_assign_pointer()</code>, though any such assignments that
happen after the structure is globally visible <i>must</i> use
<code>rcu_assign_pointer()</code>.

</p><p>However, unless this initialization code is on an impressively hot
code-path, it is probably wise to use <code>rcu_assign_pointer()</code>
anyway, even though it is in theory unnecessary.
It is all too easy for a "minor" change to invalidate your cherished
assumptions about the initialization happening privately.
Besides, Arnd's sparse-based checks will yell at you if you
apply simple assignment to a pointer that has been marked as protected
by RCU using <code>__rcu</code>.

</p><p><a href="#Quick%20Quiz%209"><b>Back to Quick Quiz 9</b>.</a>

</p><p><b>Quick Quiz 10</b>:
Why isn't there a debugging API to check for mismatching read-side
and grace-period primitives, for example, using <code>rcu_read_lock()</code>
on the read side, but incorrectly using <code>synchronize_sched()</code>
during updates?

</p><p><b>Answer</b>: Because we have not yet come up with a good
way to do this.
One challenge is that <code>synchronize_sched()</code> doesn't say
which RCU pointer it is waiting on.
Even if the pointer was known, the connection to the read-side primitives
might well be in some other compilation unit.
One approach would be to use separate pointer tags for each flavor
of RCU rather than the current <code>__rcu</code>, but early attempts
in that direction resulted in mind-numbing complexity &mdash; even
from an RCU perspective.

</p><p>If you have a good idea, give it a try and let us know how
it goes!

</p><p><a href="#Quick%20Quiz%2010"><b>Back to Quick Quiz 10</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Read-copy-update">Read-copy-update</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/418853/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor419273"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2010 Edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2010 4:35 UTC (Thu)
                               by <b>cma</b> (guest, #49905)
                              [<a href="/Articles/419273/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Any use on user land?
      
          <div class="CommentReplyButton">
            <form action="/Articles/419273/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor419280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The RCU API, 2010 Edition</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2010 8:12 UTC (Thu)
                               by <b>JohnLenz</b> (guest, #42089)
                              [<a href="/Articles/419280/">Link</a>] 
      </p>
      
      </div>
      </summary>
      There is <a href="http://lttng.org/urcu">urcu</a> for userspace RCU.
      
          <div class="CommentReplyButton">
            <form action="/Articles/419280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2010, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
