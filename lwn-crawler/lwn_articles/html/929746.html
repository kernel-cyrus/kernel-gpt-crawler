        <!DOCTYPE html>
        <html lang="en">
        <head><title>Unprivileged BPF and authoritative security hooks [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/929746/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/930369/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/929746/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Unprivileged BPF and authoritative security hooks</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 27, 2023</br>
           </div>
When the developers of the Linux security module (LSM) subsystem find
themselves disagreeing with other kernel developers, it tends to be because
those other developers don't think to — or don't want to — add security
hooks to their shiny new subsystems.  Sometimes, though, the addition of
new hooks by non-LSM developers can also create some friction.  Andrii
Nakryiko's posting of <a
href="/ml/bpf/20230412043300.360803-1-andrii@kernel.org/">a pair of
BPF-related security hooks</a> raised a couple of interesting questions,
one of which spurred a fair amount of discussion, and one that did not.
<p>
Nakryiko proposed the addition of two new LSM hooks to control access to
BPF functionality.  The <a
href="/ml/bpf/20230412043300.360803-5-andrii@kernel.org/">first</a> would
govern the creation of BPF maps, while the <a
href="/ml/bpf/20230412043300.360803-8-andrii@kernel.org/">second</a> was
meant to control the loading of BPF type format (BTF) data that describes
functions and data structures within the kernel.  The plan is to not stop
there, though:
<p>
<blockquote class="bq">
	This patch set implements and demonstrates an overall approach
	starting with BPF map and BTF object creation, first two steps in
	the lifetime of a typical BPF applications. Next step would be to
	do similar changes for BPF_PROG_LOAD command to allow BPF program
	loading and verification.
</blockquote>
<p>
There is nothing in this part of the plan that is inherently controversial;
if there are use cases for access control over these features beyond
checking for the <tt>CAP_BPF</tt> capability, then the addition of these
hooks to enable the creation of a policy to implement that control can make
sense.  But that is not quite how these hooks are meant to operate.
Instead, they can be used to <i>bypass</i> the <tt>CAP_BPF</tt> check
entirely, meaning that they can make the covered functionality available to
processes that lack that capability.
<p>
<h4>Authoritative hooks</h4>
<p>
The LSM subsystem has its origin in <a
href="/2001/features/KernelSummit/">the first Kernel Summit</a> in 2001.
At that time, there was a desire to get an early version of SELinux into
the kernel, but Linus Torvalds pointed out that there were other approaches
to increased security under development, and he did not want to commit the
kernel to any one of them.  Instead, he asked for the creation of a
framework that would allow multiple security mechanisms to be supported.
<p>
That framework, implementing an extensive set of hooks that can make
security decisions at the relevant points in the system-call paths,
eventually was merged as the Linux security module subsystem.  But, before
that could happen, there was a heated discussion (<a
href="/2001/1108/kernel.php3">covered in LWN at the time</a>) over whether
the LSM subsystem should support hooks that could grant privileges that a
process did not have, or whether they would only be able to add
restrictions to those already implemented by the kernel's other
access-control mechanisms.  In the end, the decision was made that
"authoritative hooks" — those that could increase privilege — would not be
allowed.  Among other things, this rule was seen as a way of keeping
security modules from introducing security holes in their own right.
<p>
There have been a number of security modules added in the 21&nbsp;years
since that decision was made, but they have all been held to that rule.
Easing the ban on authoritative hooks has occasionally been discussed over
those years, but has never really been considered.  So, when Nakryiko
proposed adding a couple of authoritative hooks, LSM maintainer Paul Moore
quickly <a
href="/ml/bpf/CAHC9VhQHmdZYnR=+rX-3FcRh127mhJt=jAnototfTiuSoOTptg@mail.gmail.com/">responded</a>:
<p>
<blockquote class="bq">
	One of the hallmarks of the LSM has always been that it is
	non-authoritative: it cannot unilaterally grant access, it can only
	restrict what would have been otherwise permitted on a traditional
	Linux system.  Put another way, a LSM should not undermine the
	Linux discretionary access controls, e.g. capabilities.
</blockquote>
<p>
The real solution, he said, would be to revise how the BPF code implements
the <tt>CAP_BPF</tt> capability.  Kees Cook <a
href="/ml/bpf/6436eea2.170a0220.97ead.52a8@mx.google.com/">disagreed</a>,
suggesting that these hooks could be seen as "<q>fine-grained access
control</q>" rather than actually bypassing enforcement, but Moore <a
href="/ml/bpf/CAHC9VhR6ebsxtjSG8-fm7e=HU+srmziVuO6MU+pMpeSBv4vN+A@mail.gmail.com/">stood
firm</a> in his opposition to the idea.
<p>
Nakryiko <a
href="/ml/bpf/CAEf4BzY9GPr9c2fTUS6ijHURtdNDL4xM6+JAEggEqLuz9sk4Dg@mail.gmail.com/">protested</a>
that the idea was to increase security by making it finer-grained than the
single <tt>CAP_BPF</tt> capability allows.  The restriction-only model, he
<a
href="/ml/bpf/CAEf4BzaRkAtyigmu9fybW0_+TZJJX2i93BXjiNUfazt2dFDFbQ@mail.gmail.com/">said</a>,
would be more brittle in the end.  He also <a
href="/ml/bpf/CAEf4BzZa26JHa=gBgMm-sqyNy_S71-2Rs_-F6mrRXQF9z9KcmA@mail.gmail.com/">added</a>
that there are a couple of real problems with capability-based enforcement
when user namespaces are involved.  The first is that many BPF programs,
such as those that interact with tracing, inherently have a view of the
entire system and cannot really be contained within a namespace.  So a
capability check for <tt>CAP_BPF</tt> cannot be namespace-aware.
<p>
Beyond that, though, it is currently not even possible to give a process
<tt>CAP_BPF</tt> if it's running within a user namespace due to the way
that the capability checks are implemented in the BPF subsystem.  As a
result, he argued, it is not really possible for programs running within a
user namespace to make use of BPF at all.  The proposed hooks were intended
to provide a way around this shortcoming.
<p>
Casey Schaufler, who had been in favor of authoritative hooks back in 2001,
<a
href="/ml/bpf/ad70ee53-c774-6b50-33fc-d4568a3b5559@schaufler-ca.com/">was
unsympathetic</a> now:
<p>
<blockquote class="bq">
	This doesn't sound like a problem, it sounds like BPF is explicitly
	designed to prevent interference by namespaces. But in some cases
	you now want to limit it by namespaces.
<p>
	It appears that the desired uses of BPF are no longer compatible
	with its original security model. That's unfortunate, and likely to
	require a significant change to the implementation of BPF.
</blockquote>
<p>
Or, as Moore <a
href="/ml/bpf/CAHC9VhRH6Z2r_A7YkDEmW7kiCA8e5j2u270gE48jpQmqS+t75A@mail.gmail.com/">put
it</a>: "<q>Changing the very core behavior of the LSM layer in order to
work around an issue with another access control mechanism is a
non-starter</q>".  Nakryiko has <a
href="/ml/bpf/CAEf4Bzb4TW+sYSGLFVxsvYsEHM0cXsEA2aVtaiT2QQCuQ+fnDw@mail.gmail.com/">received
the message</a> and has promised to come back with a different approach.
It thus seems that a complete solution to the problems encountered by the
BPF community is a somewhat distant prospect at this point.
<p>
<h4>Unprivileged BPF</h4>
<p>
The quiet part of the discussion is an apparent change within the BPF
community with regard to security.  Quoting again from Nakryiko's cover
letter:
<p>
<blockquote class="bq">
	Such LSM hook semantics gives ability to have safer-by-default
	policy of not giving applications any of the
	CAP_BPF/CAP_PERFMON/CAP_NET_ADMIN capabilities, normally required
	to be able to use BPF subsystem in the kernel. Instead, all the BPF
	processes could be left completely unprivileged, and only
	allowlisted exceptions for trusted and verified production use
	cases would be granted permission to work with bpf() syscall, as if
	those application had root-like capabilities.
</blockquote>
<p>
In the early days of extended BPF, <a href="/Articles/660331/">some
effort</a> went into making it possible to use BPF without any special
privileges.  By 2019, though, the idea of unprivileged BPF use had been <a
href="/Articles/796328/">explicitly deprecated</a>.  BPF co-maintainer
Alexei Starovoitov described Linux as "<q>a single-user system</q>" and
proclaimed that no further attempts would be made to enable use of BPF
without privilege.  The amount of pain involved in keeping the system
secure had simply become too much; the advent of the Spectre
vulnerabilities just made things worse.
<p>
So it is interesting to see the BPF developers talking about unprivileged
operation again, even if done under the watchful eye of a security policy. 
There does not appear to have been any discussion on the BPF list about
changes in the privilege model overall, so it is not entirely clear how
this all came about.
<p>
What does seem clear is that, if the BPF developers want to move away from
the simple <tt>CAP_BPF</tt> check, they are going to have to revisit many
of the security-related decisions that they have made so far.  The method
of adding authoritative LSM hooks does not appear to be viable for mainline
inclusion, so some thought is going to have to be put into other solutions,
including perhaps rethinking the user-namespace issue.  This does not look
like a problem that is amenable to a quick solution.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#BPF-Security">BPF/Security</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Modules-Security_modules">Modules/Security modules</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Security_modules">Security/Security modules</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/929746/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor930395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2023 15:23 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/930395/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For a second, I thought that Linux would add authoritative LSM hooks. Which would have been great. Oh well...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor930398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2023 19:57 UTC (Thu)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/930398/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm thinking about the suggestion in the list discussion to grant all users CAP_BPF and use the LSM to restrict it again, and the absurdum that you might as well grant all users root and use the LSM to restrict their abilities, and whether it actually is absurd.<br>
<p>
If you look at it from another angle, it seems like the problem is that the standard Linux security controls - caps, file ownership/permissions, user IDs and their namespacing, etc. - basically constitute an LSM with unusual rules: it cannot be turned off and it sits in front of any other LSM. What you really want is for the standard controls to be treated like any other stackable LSM (now that LSMs are stackable), removable, and most importantly configurable. Just like you can tell AppArmor or SELinux to e.g. label or not label packets, you should be able to tell the standard security controls to get out of the way for a particular thing, like BPF. Or like user account checks, for that matter.<br>
<p>
There is in fact a little bit of precedent for turning off user account checks in the form of the CONFIG_MULTIUSER option, which when disabled gets rid of UIDs and GIDs and capabilities and all associated system calls and effectively runs everything as root. And now that I go look up the history of it, I see there was objection to it precisely because of the no-authoritative-LSMs rule: <a href="https://lwn.net/Articles/631853/">https://lwn.net/Articles/631853/</a><br>
<p>
So maybe this really isn't that absurd and we should treat "running without permission checks" as no more technically unreasonable than "running without SELinux." This would basically redefine the problem so that the authoritativeness of an LSM is no longer a concept: if the traditional-permissions LSM is loaded and is configured to enable checks for an operation, then it stacks just like any other LSM, and the remaining LSMs in the stack are "non-authoritative" in current speak. If not, they're effectively "authoritative."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930425"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2023 7:31 UTC (Fri)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/930425/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem would still exist though. Even if every mechanism to make security decisions is a stackable LSM (or some other, newly designed security plug-in system) you still need to decide what each of those can do.<br>
<p>
Can each LSM only block operations, making the operation forbidden if any of them does? Can each LSM on its own allow operations even if other LSMs want to block it? Can each LSM veto decisions of other LSMs that run earlier or later than itself only?<br>
<p>
If you aren't careful with permission systems you design something overly complex that leads to more accidental errors while its expressiveness goes unused due to its complexity.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930425/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930430"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2023 11:10 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/930430/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>If everything's stackable LSMs, and you assume a competent administrator, you only need the ability to remove permissions at each layer.
<p>Before the LSM stack gets to make decisions, your user is omnipotent, and can do everything. Each layer of the stack can reject the user's request; if nothing in the stack rejects the request, then the user is allowed to do the thing.
<p>It then becomes debuggable - all requests are approved by default, and the kernel can tell you which part of the LSM stack rejected any given request. You can thus design your stack so that all layers deny by default, and use the kernel's advice to open up permissions as and when you need them.


      
          <div class="CommentReplyButton">
            <form action="/Articles/930430/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2023 6:35 UTC (Thu)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/930869/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This sounds good in theory. What I've found is that you often land up with situations where only layer C has the knowledge necessary to say that some particular case should be an exception to the more general rules applied by higher layers. But doesn't know enough to enforce the restriction elsewhere.<br>
<p>
The "campus" layer knows you can only use your key card at the campus you study at. The correct keycard is sufficient to grant access.<br>
<p>
The "police and emergency services" layer knows that you can get if you know the right keypad code, but doesn't know anything about key cards and campuses.<br>
<p>
The "rich alumini" layer knows that no matter what anyone else says, you WILL let them in anywhere unconditionally because you want their cheque book.<br>
<p>
It's hard to compose security with orthogonal layers of checks if each layer can only give a final denial or a no-decison.<br>
<p>
With that said, authoratative permit rules are massive foot guns and it's incredibly hard to design a system that's secure and easy to understand when you use them. I'm more interested in having a default-deny model where each layer can say "yep that's ok", "abstain" or "deny". An approve decision requires at least one explicit approval from a module and no denies. Most of the time most modules would abstain or approve, not deny.<br>
<p>
I've always found it easier to layer these sorts of models where you default to denying then you layer grants.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930883"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2023 10:14 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/930883/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I've always found it easier to layer these sorts of models where you default to denying then you layer grants.</span><br>
<p>
I personally think this sounds like a better approach than "default allow with layered rejections", because it sounds like it has a better chance to "fail closed", which seems like a better security paradigm than "fail open".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930883/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor930885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2023 11:30 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/930885/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I like this - because you have three states ("no decision", "allow", "deny"), the policy can fail closed on no decision.
<p>And it avoids the composability issue that "authoritative allow" brings in - if your policy includes a "deny this access" rule, you can't be surprised by a later "allow this access" rule, since the "allow" rule can't override you.


      
          <div class="CommentReplyButton">
            <form action="/Articles/930885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor930920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2023 15:10 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/930920/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is why I don't like the Windows and Linux implementations of ACLs as I understand it. All sorts of confusing rules.<br>
<p>
Pr1me ACLs were simple. Default whatever (defaulted to none). Groups were additive and over-rode default. Named were absolute and over-rode everything else.<br>
<p>
So if I didn't want Jo Bloggs to see anything in my project directory, an acl of "Jo Bloggs : none" was definitive. <br>
<p>
So provided your security layer could categorise an "allow" or "deny" as being at the group or personal level, a personal deny would be final, a group allow could be over-ridden.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor930608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 1, 2023 18:27 UTC (Mon)
                               by <b>bartoc</b> (guest, #124262)
                              [<a href="/Articles/930608/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One problem with this is that it means you are trusting the LSM to actually get the security model right, and when designing a new subsystem you then have a wider field of possible security models that you need to analyze to figure out if what you're doing is secure or could break any of them.<br>
<p>
It might make sense to do this but have the LSM implementing the initial restrictions developed as part of the kernel and always applied in front of any other LSM, just like the classical DAC model is used today. However, because LSMs are code this doesn't really help you that much. There also may well be some hooks that you want this "base" LSM to have access to but shouldn't be available to other LSMs, and at that point you've almost gotten back to where you started. <br>
<p>
Ultimately you need a security model to _actually_ analyze. Today most LSMs act more as security firebreaks that have a high probability of mucking up at least one link in some exploit chain than they do as airtight security where any mechanism of bypassing them is considered a bug. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor930414"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2023 1:38 UTC (Fri)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/930414/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If linux has truly become single user (single user of servers, personal computers, and embedded devices) then might as well strip out all the user IDs, group IDs, filesystem permissions, access lists, and all the other access control mechanisms. After all, who needs to access control one's self? :P<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930414/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2023 2:09 UTC (Fri)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/930415/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Android uses user IDs to great effect to sandbox applications from each other, even though Android is almost always used as a single-user OS. (On the other hand, iOS runs everything as a single user and has a separate kernel sandboxing thing, kind of like a mix between seccomp and LSMs. Both approaches have had bugs but have basically been sound designs overall, so maybe this is an argument that single-user machines don't really need UIDs.) <br>
<p>
I'm not sure if this is what was meant, but I can see the argument that Linux is a single-person OS and powerful features like BPF should be controlled and assigned to UIDs by a single person.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2023 3:21 UTC (Fri)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/930416/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  can see the argument that Linux is a single-person OS</span><br>
<p>
Sure, most Linux systems are owner-operated, but as soon as you accept a use case where this isn't true, then you end up needing all the complexity and policy for multi-user systems, so you might as well plan for that from the start.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930502"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2023 6:36 UTC (Sat)
                               by <b>developer122</b> (guest, #152928)
                              [<a href="/Articles/930502/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder if the entire concept of user IDs, filesystem permissions, etc could be exported into one or more LSMs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930502/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 3, 2023 10:36 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/930721/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No reason it can't be AFAIK.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor930418"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2023 4:45 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/930418/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite a few container workloads basically do just that. I won't mind an option to just disable all DAC entirely in containers for a small speedup.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930418/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor930495"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2023 22:36 UTC (Fri)
                               by <b>dbnichol</b> (subscriber, #39622)
                              [<a href="/Articles/930495/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
CAP_DAC_OVERRIDE?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930495/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor930428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2023 9:24 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/930428/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Even though I am the only user of my laptop, I have multiple Linux users on it with different permissions; they provide a form of sandboxing between tasks for me, so that (for example) I can run a build as a user that can only pull from my local git repo, and cannot read my files otherwise, nor is it permitted network access. This, in turn, helps me catch stupid mistakes before I trigger CI - forgetting to git add a new file is one of my favourite tricks.
<p>I was inspired to do this by Android, which uses a similar trick for isolation between applications.


      
          <div class="CommentReplyButton">
            <form action="/Articles/930428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor930436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2023 13:59 UTC (Fri)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/930436/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please read this in the context it was written.<br>
The context was that userspace bpf made so easy do privilege escalation we could as well run everything as root.<br>
It was not a comment on personnal computer use.<br>
&lt;<a href="https://lwn.net/ml/netdev/20190813215823.3sfbakzzjjykyng2@ast-mbp/">https://lwn.net/ml/netdev/20190813215823.3sfbakzzjjykyng2...</a>&gt;<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor930486"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2023 18:17 UTC (Fri)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/930486/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, sometimes it's nice to be unable to accidentally overwrite your boot sector when you're just trying to dial the modem. ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930486/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor930524"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unprivileged BPF and authoritative security hooks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2023 22:39 UTC (Sat)
                               by <b>rcampos</b> (subscriber, #59737)
                              [<a href="/Articles/930524/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seccomp notify (notify to a user space agent when a sus all is done) wouldn't be useful here?<br>
<p>
I mean, the agent can execute the syscall in behalf of the unprivileged process if it deems it safe to do so. The process has no privileges nor capabilities.<br>
<p>
Or going to user space is too slow for this use case?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/930524/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
