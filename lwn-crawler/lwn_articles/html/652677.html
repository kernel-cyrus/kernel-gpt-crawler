        <!DOCTYPE html>
        <html lang="en">
        <head><title>RCU requirements part 2 — parallelism and software engineering [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/652677/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/653183/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/652677/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>RCU requirements part 2 — parallelism and software engineering</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>August 5, 2015</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
This is the second of a three-article series on the requirements that have
driven the read-copy-update (RCU) design toward its current form.  <a
href="/Articles/652156/">Part&nbsp;1</a> covered the fundamental
requirements that make RCU what it is.  In this installment, we'll get into
the issues that affect how those fundamental requirements are met; in
particular, we'll look at:
<p>
<ul>
<li>	<a href="#Parallelism Facts of Life">
	Parallelism facts of life</a>
<li>	<a href="#Quality-of-Implementation Requirements">
	Quality-of-implementation requirements</a>
<li>	<a href="#Software-Engineering Requirements">
	Software-engineering requirements</a>
</ul>
<p>
Also, of course, no RCU article would be complete without the <a
href="#qqanswers">answers to the quick quizzes</a> at the end.
<p>

<h4><a name="Parallelism Facts of Life">Parallelism facts of life</a></h4>

<p>
These parallelism facts of life are by no means specific to RCU, but
the RCU implementation must abide by them.
They therefore bear repeating:

<ol class="spacylist">
<li>	Any CPU or task may be delayed at any time,
	and any attempts to avoid these delays by disabling
	preemption, interrupts, or whatever are completely futile.
	This is most obvious in preemptible user-level
	environments and in virtualized environments (where
	a given guest OS's virtual CPUs can be preempted at any time by
	the underlying hypervisor), but can also happen in bare-metal
	environments due to ECC errors, NMIs, and other hardware
	events.
	Although a delay of more than about 20 seconds can result
	in warnings, the RCU implementation is obligated to use
	algorithms that can tolerate extremely long delays, but where
	&ldquo;extremely long&rdquo; is not long enough to allow
	wraparound when incrementing a 64-bit counter.
<li>	Both the compiler and the CPU can reorder memory accesses.
	Where it matters, RCU must use compiler directives and
	memory-barrier instructions to preserve ordering.
<li>	Conflicting writes to memory locations in any given cache line
	will result in expensive cache misses.
	Greater numbers of concurrent writes and more-frequent
	concurrent writes will result in more dramatic slowdowns.
	RCU is therefore obligated to use algorithms that have
	sufficient locality to avoid significant performance and
	scalability problems.
<li>	As a rough rule of thumb, only one CPU's worth of processing
	may be carried out under the protection of any given exclusive
	lock.
	RCU must therefore use scalable locking designs.
<li>	Counters are finite, especially on 32-bit systems.
	RCU's use of counters must therefore tolerate counter wrap,
	or be designed such that counter wrap would take way more
	time than a single system is likely to run.
	An uptime of ten years is quite possible, a runtime
	of a century much less so.
	As an example of the latter, RCU's dyntick-idle nesting counter
	allows 54 bits for the interrupt-nesting level (this counter
	is 64 bits even on a 32-bit system).
	Overflowing this counter requires 2<sup><font size="smaller">54</font></sup>
	half-interrupts on a given CPU without that CPU ever going idle.
	If a half-interrupt happened every microsecond, it would take
	570 years of runtime to overflow this counter, which is currently
	believed to be an acceptably long time.
<li>	Linux systems can have thousands of CPUs running a single
	Linux kernel in a single shared-memory environment.
	RCU must therefore pay close attention to high-end scalability.
</ol>

<p>
This last parallelism fact of life means that RCU must pay special
attention to the preceding facts of life.
The idea that Linux might scale to systems with thousands of CPUs would
have been met with some skepticism in the 1990s, but these requirements
would have otherwise have been unsurprising, even in the early 1990s.

<h4><a name="Quality-of-Implementation Requirements">Quality-of-implementation requirements</a></h4>

<p>
These sections list quality-of-implementation requirements.
Although an RCU implementation that ignores these requirements could
still be used, it would likely be subject to limitations that would
make it inappropriate for industrial-strength production use.
Classes of quality-of-implementation requirements are as follows:

<ol class="spacylist">
<li>	<a href="#Specialization">Specialization</a>
<li>	<a href="#Performance and Scalability">Performance and scalability</a>
<li>	<a href="#Composability">Composability</a>
<li>	<a href="#Corner Cases">Corner cases</a>
</ol>

<p>
These classes are covered in the following sections.

<h4><a name="Specialization">Specialization</a></h4>

<p>
RCU is and always has been intended primarily for read-mostly situations, as
illustrated by the following figure.
This means that RCU's read-side primitives are optimized, often at the
expense of its update-side primitives.

<blockquote>
<img src="https://static.lwn.net/images/2015/rcu/RCUApplicability.png" alt="RCU Applicability" class="photo">
</blockquote>

<p>
<div class="tlr">
<a name="Quick Quiz 11"><b>Quick Quiz 11</b>:</a>
What about sleeping locks?
<br><a href="#qq11answer">Answer</a>
</div>
This focus on read-mostly situations means that RCU must interoperate
with other synchronization primitives.
For example, the <tt>add_gp()</tt> and <tt>remove_gp_synchronous()</tt>
examples discussed earlier use RCU to protect readers and locking to
coordinate updaters.
However, the need extends much farther, requiring that a variety of
synchronization primitives be legal within RCU read-side critical sections,
including spinlocks, sequence locks, atomic operations, reference
counters, and memory barriers.

<p>
It often comes as a surprise that many algorithms do not require a
consistent view of data, but many can function in that mode,
with network routing being the poster child.
Internet routing algorithms take significant time to propagate
updates, so that by the time an update arrives at a given system,
that system has been sending network traffic the wrong way for
a considerable length of time.
Having a few threads continue to send traffic the wrong way for a
few more milliseconds is clearly not a problem:  In the worst case,
TCP retransmissions will eventually get the data where it needs to go.
In general, when tracking the state of the universe outside of the
computer, some level of inconsistency must be tolerated due to
speed-of-light delays if nothing else.

<p>
Furthermore, uncertainty about external state is inherent in many cases.
For example, a pair of veterinarians might use heartbeat to determine
whether or not a given cat was alive.
But how long should they wait after the last heartbeat to decide that
the cat is in fact dead?
Waiting less than 400 milliseconds makes no sense because this would
mean that a relaxed cat would be considered to cycle between death
and life more than 100 times per minute.
Moreover, just as with human beings, a cat's heart might stop for
some period of time, so the exact wait period is a judgment call.
One of our pair of veterinarians might wait 30 seconds before pronouncing
the cat dead, while the other might insist on waiting a full minute.
The two veterinarians would then disagree on the state of the cat during
the final 30 seconds of the minute following the last heartbeat.

<p>
Interestingly enough, this same situation applies to hardware.
When push comes to shove, how do we tell whether or not some
external server has failed?
We send messages to it periodically, and declare it failed if we
don't receive a response within a given period of time.
Policy decisions can usually tolerate short
periods of inconsistency.
The policy was decided some time ago, and is only now being put into
effect, so a few milliseconds of delay is normally inconsequential.

<p>
However, there are algorithms that absolutely must see consistent data.
For example, the translation between a user-level System&nbsp;V semaphore
ID to the corresponding in-kernel data structure is protected by RCU,
but it is absolutely forbidden to update a semaphore that has just been
removed.
In the Linux kernel, this need for consistency is accommodated by acquiring
spinlocks located in the in-kernel data structure from within
the RCU read-side critical section, and this is indicated by the
green box in the figure above.
Many other techniques may be used, and are in fact used within the
Linux kernel.

<p>
In short, RCU is not required to maintain consistency, and other
mechanisms may be used in concert with RCU when consistency is required.
RCU's specialization allows it to do its job extremely well, and its
ability to interoperate with other synchronization mechanisms allows
the right mix of synchronization tools to be used for a given job.

<h4><a name="Performance and Scalability">Performance and scalability</a></h4>

<p>
Energy efficiency is a critical component of performance today,
and Linux-kernel RCU implementations must therefore avoid unnecessarily
awakening idle CPUs.
I cannot claim that this requirement was premeditated.
In fact, I learned of it during a telephone conversation in which I
was given &ldquo;frank and open&rdquo; feedback on the importance
of energy efficiency in battery-powered systems and on specific
energy-efficiency shortcomings of the Linux-kernel RCU implementation.
In my experience, the battery-powered embedded community will consider
any unnecessary wakeups to be extremely unfriendly acts.
So much so that mere Linux-kernel-mailing-list posts are
insufficient to vent their ire.

<p>
Memory consumption is not particularly important in most
situations, and it has become decreasingly so as memory sizes have expanded
and memory 
costs have plummeted.
However, as I learned from Matt Mackall's
<a href="http://elinux.org/Linux_Tiny-FAQ">bloatwatch</a>
efforts, memory footprint is critically important on single-CPU systems with
non-preemptible (<tt>CONFIG_PREEMPT=n</tt>) kernels, and thus
<a href="http://lkml.org/lkml/2009/1/14/449">tiny RCU</a>
was born.
Josh Triplett has since taken over the small-memory banner with his
<a href="https://tiny.wiki.kernel.org/">Linux kernel tinification</a>
project, which resulted in
<a href="/Articles/202847/">SRCU</a>
becoming optional for those kernels not needing it.

<p>
The remaining performance requirements are, for the most part,
unsurprising.
For example, in keeping with RCU's read-side specialization,
<tt>rcu_dereference()</tt> should have negligible overhead (for
example, suppression of a few minor compiler optimizations).
Similarly, in non-preemptible environments, <tt>rcu_read_lock()</tt> and
<tt>rcu_read_unlock()</tt> should have exactly zero overhead.

<p>
In preemptible environments, in the case where the RCU read-side
critical section was not preempted (as will be the case for the
highest-priority realtime process), <tt>rcu_read_lock()</tt> and
<tt>rcu_read_unlock()</tt> should have minimal overhead.
In particular, they should not contain atomic read-modify-write
operations, memory-barrier instructions, preemption disabling,
interrupt disabling, or backward branches.
However, in the case where the RCU read-side critical section was preempted,
<tt>rcu_read_unlock()</tt> may acquire spinlocks and disable interrupts.
This is why it is better to nest an RCU read-side critical section
within a preempt-disable region than vice versa, at least in cases
where that critical section is short enough to avoid unduly degrading
realtime latencies.

<p>
The <tt>synchronize_rcu()</tt> grace-period-wait primitive is
optimized for throughput.
It may therefore incur several milliseconds of latency in addition to
the duration of the longest RCU read-side critical section.
On the other hand, multiple concurrent invocations of
<tt>synchronize_rcu()</tt> are required to use batching optimizations
so that they can be satisfied by a single underlying grace-period-wait
operation.
For example, in the Linux kernel, it is not unusual for a single
grace-period-wait operation to serve more than
<a href="https://www.usenix.org/conference/2004-usenix-annual-technical-conference/making-rcu-safe-deep-sub-millisecond-response">1,000 separate invocations</a>
of <tt>synchronize_rcu()</tt>, thus amortizing the per-invocation
overhead down to nearly zero.
However, the grace-period optimization is also required to avoid
measurable degradation of realtime scheduling and interrupt latencies.

<p>
In some cases, the multi-millisecond <tt>synchronize_rcu()</tt>
latencies are unacceptable.
In these cases, <tt>synchronize_rcu_expedited()</tt> may be used
instead, reducing the grace-period latency down to a few tens of
microseconds on small systems, at least in cases where the RCU read-side
critical sections are short.
There are currently no special latency requirements for
<tt>synchronize_rcu_expedited()</tt> on large systems, but,
consistent with the empirical nature of the RCU specification,
that is subject to change.
However, there most definitely are scalability requirements:
a storm of <tt>synchronize_rcu_expedited()</tt> invocations on 4096
CPUs should at least make reasonable forward progress.
In return for its shorter latencies, <tt>synchronize_rcu_expedited()</tt>
is permitted to impose modest degradation of realtime latency
on non-idle online CPUs.
That said, it will likely be necessary to take further steps to reduce this
degradation, hopefully to roughly that of a scheduling-clock interrupt.

<p>
There are a number of situations where even
<tt>synchronize_rcu_expedited()</tt>'s reduced grace-period
latency is unacceptable.
In these situations, the asynchronous <tt>call_rcu()</tt> can be
used in place of <tt>synchronize_rcu()</tt> as follows:

<blockquote>
<pre>
 1 struct foo {
 2   int a;
 3   int b;
 4   struct rcu_head rh;
 5 };
 6 
 7 static void remove_gp_cb(struct rcu_head *rhp)
 8 {
 9   struct foo *p = container_of(rhp, struct foo, rh);
10 
11   kfree(p);
12 }
13 
14 bool remove_gp_asynchronous(void)
15 {
16   struct foo *p;
17 
18   spin_lock(&amp;gp_lock);
19   p = rcu_access_pointer(gp);
20   if (!p) {
21     spin_unlock(&amp;gp_lock);
22     return false;
23   }
24   rcu_assign_pointer(gp, NULL);
25   call_rcu(&amp;p-&gt;rh, remove_gp_cb);
26   spin_unlock(&amp;gp_lock);
27   return true;
28 }
</pre>
</blockquote>

<p>
<div class="tlr">
<a name="Quick Quiz 12"><b>Quick Quiz 12</b>:</a>
Why does line&nbsp;19 use <tt>rcu_access_pointer()</tt>?
After all, <tt>call_rcu()</tt> on line&nbsp;25 stores into the
structure, which would interact badly with concurrent insertions.
Doesn't this mean that <tt>rcu_dereference()</tt> is required?
<br><a href="#qq12answer">Answer</a>
</div>
A definition of <tt>struct foo</tt> is finally needed, and appears
on lines&nbsp;1-5.
The function <tt>remove_gp_cb()</tt> is passed to <tt>call_rcu()</tt>
on line&nbsp;25, and will be invoked after the end of a subsequent
grace period.
This gets the same effect as <tt>remove_gp_synchronous()</tt>,
but without forcing the updater to wait for a grace period to elapse.
The <tt>call_rcu()</tt> function may be used in a number of
situations where neither <tt>synchronize_rcu()</tt> nor
<tt>synchronize_rcu_expedited()</tt> would be legal,
including within preempt-disable code, <tt>local_bh_disable()</tt> code,
interrupt-disable code, and interrupt handlers.
However, even <tt>call_rcu()</tt> is illegal within NMI handlers.
The callback function (<tt>remove_gp_cb()</tt> in this case) will be
executed within the softirq (software interrupt) environment within the
Linux kernel 
(either within a real softirq handler or under the protection
of <tt>local_bh_disable()</tt>).
In both the Linux kernel and in user space, it is bad practice to
write an RCU callback function that takes too long.
Long-running operations should be relegated to separate threads or
(in the Linux kernel) workqueues.

<p>
However, all that <tt>remove_gp_cb()</tt> is doing is
invoking <tt>kfree()</tt> on the data element.
This is a common idiom, and is supported by <tt>kfree_rcu()</tt>,
which allows &ldquo;fire and forget&rdquo; operation as shown below:

<blockquote>
<pre>
 1 struct foo {
 2   int a;
 3   int b;
 4   struct rcu_head rh;
 5 };
 6 
 7 bool remove_gp_faf(void)
 8 {
 9   struct foo *p;
10 
11   spin_lock(&amp;gp_lock);
12   p = rcu_dereference(gp);
13   if (!p) {
14     spin_unlock(&amp;gp_lock);
15     return false;
16   }
17   rcu_assign_pointer(gp, NULL);
18   kfree_rcu(p, rh);
19   spin_unlock(&amp;gp_lock);
20   return true;
21 }
</pre>
</blockquote>

<p>
<div class="tlr">
<a name="Quick Quiz 13"><b>Quick Quiz 13</b>:</a>
Earlier it was claimed that <tt>call_rcu()</tt> and
<tt>kfree_rcu()</tt> allowed updaters to avoid being blocked
by readers.
But how can that be correct, given that the invocation of the callback
and the freeing of the memory (respectively) must still wait for
a grace period to elapse?
<br><a href="#qq13answer">Answer</a>
</div>
Note that <tt>remove_gp_faf()</tt> simply invokes
<tt>kfree_rcu()</tt> and proceeds, without any need to pay any
further attention to the subsequent grace period and <tt>kfree()</tt>.
It is permissible to invoke <tt>kfree_rcu()</tt> from the same
environments as for <tt>call_rcu()</tt>.
Interestingly enough, DYNIX/ptx had the equivalents of
<tt>call_rcu()</tt> and <tt>kfree_rcu()</tt>, but not
<tt>synchronize_rcu()</tt>.
This was due to the fact that RCU was not heavily used within DYNIX/ptx,
so the very few places that needed something like
<tt>synchronize_rcu()</tt> simply open-coded it.

<p>
But what if the updater must wait for the completion of code to be
executed after the end of the grace period, but has other tasks
that can be carried out in the meantime?
The polling-style <tt>get_state_synchronize_rcu()</tt> and
<tt>cond_synchronize_rcu()</tt> functions may be used for this
purpose, as shown below:

<blockquote>
<pre>
 1 bool remove_gp_poll(void)
 2 {
 3   struct foo *p;
 4   unsigned long s;
 5 
 6   spin_lock(&amp;gp_lock);
 7   p = rcu_access_pointer(gp);
 8   if (!p) {
 9     spin_unlock(&amp;gp_lock);
10     return false;
11   }
12   rcu_assign_pointer(gp, NULL);
13   spin_unlock(&amp;gp_lock);
14   s = get_state_synchronize_rcu();
15   do_something_while_waiting();
16   cond_synchronize_rcu(s);
17   kfree(p);
18   return true;
19 }
</pre>
</blockquote>

<p>
On line&nbsp;14, <tt>get_state_synchronize_rcu()</tt> obtains a
&ldquo;cookie&rdquo; from RCU,
then line&nbsp;15 carries out other tasks,
and finally, line&nbsp;16 returns immediately if a grace period has
elapsed in the meantime, but otherwise waits as required.
The need for <tt>get_state_synchronize_rcu</tt> and
<tt>cond_synchronize_rcu()</tt> has appeared quite recently,
so it is too early to tell whether they will stand the test of time.

<p>
RCU thus provides a range of tools to allow updaters to strike the
required tradeoff between latency, flexibility and CPU overhead.

<h4><a name="Composability">Composability</a></h4>

<p>
Composability has received much attention in recent years, perhaps in part
due to the collision of multicore hardware with object-oriented techniques
designed in single-threaded environments for single-threaded use.
And, in theory, RCU read-side critical sections may be composed, and in
fact may be nested arbitrarily deeply.
In practice, as with all real-world implementations of composable
constructs, there are limitations.

<p>
Implementations of RCU for which <tt>rcu_read_lock()</tt>
and <tt>rcu_read_unlock()</tt> generate no code, such as
Linux-kernel RCU when <tt>CONFIG_PREEMPT=n</tt>, can be
nested arbitrarily deeply.
After all, there is no overhead.
Except that if all these instances of <tt>rcu_read_lock()</tt>
and <tt>rcu_read_unlock()</tt> are visible to the compiler,
compilation will eventually fail due to exhausting memory,
mass storage, or user patience, whichever comes first.
If the nesting is not visible to the compiler, as is the case with
mutually recursive functions each in its own translation unit,
stack overflow will result.
If the nesting takes the form of loops, either the control variable
will overflow or (in the Linux kernel) you will get an RCU CPU stall warning.
Nevertheless, this class of RCU implementations is one
of the most composable constructs in existence.

<p>
RCU implementations that explicitly track nesting depth
are limited by the nesting-depth counter.
For example, the Linux kernel's preemptible RCU limits nesting to
<tt>INT_MAX</tt>.
This should suffice for almost all practical purposes.
That said, a consecutive pair of RCU read-side critical sections
between which there is an operation that waits for a grace period
cannot be enclosed in another RCU read-side critical section.
This is because it is not legal to wait for a grace period within
an RCU read-side critical section:  to do so would result either
in deadlock or
in RCU implicitly splitting the enclosing RCU read-side critical
section, neither of which is conducive to a long-lived and prosperous
kernel.

<p>
In short, although RCU read-side critical sections are highly composable,
care is required in some situations, just as is the case for any other
composable synchronization mechanism.

<h4><a name="Corner Cases">Corner cases</a></h4>

<p>
A given RCU workload might have an endless and intense stream of
RCU read-side critical sections, perhaps even so intense that there
was never a point in time during which there was not at least one
RCU read-side critical section in flight.
RCU cannot allow this situation to block grace periods:  as long as
all the RCU read-side critical sections are finite, grace periods
must also be finite.

<p>
That said, preemptible RCU implementations could potentially result
in RCU read-side critical sections being preempted for long durations,
which has the effect of creating a long-duration RCU read-side
critical section.
This situation can arise only in heavily loaded systems, but systems using
realtime priorities are of course more vulnerable.
Therefore, RCU priority boosting is provided to help deal with this
case.
That said, the exact requirements on RCU priority boosting will likely
evolve as more experience accumulates.

<p>
Other workloads might have very high update rates.
Although one can argue that such workloads should instead use
something other than RCU, the fact remains that RCU must
handle such workloads gracefully.
This requirement is another factor driving batching of grace periods,
but it is also the driving force behind the checks for large numbers
of queued RCU callbacks in the <tt>call_rcu()</tt> code path.
Finally, high update rates should not delay RCU read-side critical
sections, although some read-side delays can occur when using
<tt>synchronize_rcu_expedited()</tt>, courtesy of this function's use
of <tt>try_stop_cpus()</tt>.
(In the future, <tt>synchronize_rcu_expedited()</tt> will be
converted to use lighter-weight inter-processor interrupts (IPIs),
but this will still disturb readers, though to a much smaller degree.)

<p>
Although all three of these corner cases were understood in the early
1990s, a simple user-level test consisting of <tt>close(open(path))</tt>
in a tight loop
in the early 2000s suddenly provided a much deeper appreciation of the
high-update-rate corner case.
This test also motivated addition of some RCU code to react to high update
rates, for example, if a given CPU finds itself with more than 10,000
RCU callbacks queued, it will cause RCU to take evasive action by
more aggressively starting grace periods and more aggressively forcing
completion of grace-period processing.
This evasive action causes the grace period to complete more quickly,
but at the cost of restricting RCU's batching optimizations, thus
increasing the CPU overhead incurred by that grace period.

<h4><a name="Software-Engineering Requirements">
Software-engineering requirements</a></h4>

<p>
Between Murphy's Law and &ldquo;to err is human&rdquo;, it is necessary to
guard against mishaps and misuse:

<ol class="spacylist">
<li>	It is all too easy to forget to use <tt>rcu_read_lock()</tt>
	everywhere that it is needed, so kernels built with
	<tt>CONFIG_PROVE_RCU=y</tt> will complain if
	<tt>rcu_dereference()</tt> is used outside of an
	RCU read-side critical section.
	Update-side code can use <tt>rcu_dereference_protected()</tt>,
	which takes a
	<a href="https://lwn.net/Articles/371986/">lockdep expression</a>
	to indicate what is providing the protection.
	If the indicated protection is not provided, a lockdep "splat"
	(a warning and traceback) is emitted.
	<p>
	Code shared between readers and updaters can use
	<tt>rcu_dereference_check()</tt>, which also takes a
	lockdep expression, and emits a lockdep splat if neither
	<tt>rcu_read_lock()</tt> nor the indicated protection
	is in place.
	In addition, <tt>rcu_dereference_raw()</tt> is used in those
	(hopefully rare) cases where the required protection cannot
	be easily described.
	Finally, <tt>rcu_read_lock_held()</tt> is provided to
	allow a function to verify that it has been invoked within
	an RCU read-side critical section.
	I was made aware of this set of requirements shortly after Thomas
	Gleixner audited a number of RCU uses.
<li>	A given function might wish to check for RCU-related preconditions
	upon entry, before using any other RCU API.
	The <tt>rcu_lockdep_assert()</tt> does this job,
	asserting the expression in kernels having lockdep enabled
	and doing nothing otherwise.
<li>	It is also easy to forget to use <tt>rcu_assign_pointer()</tt>
	and <tt>rcu_dereference()</tt>, perhaps (incorrectly)
	substituting a simple assignment.
	To catch this sort of error, a given RCU-protected pointer may be
	tagged with <tt>__rcu</tt>, after which running sparse
	with <tt>CONFIG_SPARSE_RCU_POINTER=y</tt> will complain
	about simple-assignment accesses to that pointer.
	Arnd Bergmann made me aware of this requirement, and also
	supplied the needed
	<a href="http://lwn.net/Articles/376011/">patch series</a>.
<li>	Kernels built with <tt>CONFIG_DEBUG_OBJECTS_RCU_HEAD=y</tt>
	will splat if a data element is passed to <tt>call_rcu()</tt>
	twice in a row, without a grace period in between.
	(This error is similar to a double free.)
	The corresponding <tt>rcu_head</tt> structures that are
	dynamically allocated are automatically tracked, but
	<tt>rcu_head</tt> structures allocated on the stack
	must be initialized with <tt>init_rcu_head_on_stack()</tt>
	and cleaned up with <tt>destroy_rcu_head_on_stack()</tt>.
	Similarly, statically allocated non-stack <tt>rcu_head</tt>
	structures must be initialized with <tt>init_rcu_head()</tt>
	and cleaned up with <tt>destroy_rcu_head()</tt>.
	Mathieu Desnoyers made me aware of this requirement, and also
	supplied the needed
	<a href="https://lkml.org/lkml/2010/3/18/417">patch</a>.
<li>	An infinite loop in an RCU read-side critical section will
	eventually trigger an RCU CPU stall-warning splat.
	However, RCU is not obligated to produce this splat
	unless there is a grace period waiting on that particular
	RCU read-side critical section.
	This requirement made itself known in the early 1990s, pretty
	much the first time that it was necessary to debug a CPU stall.
<li>	Although it would be very good to detect pointers leaking out
	of RCU read-side critical sections, there is currently no
	good way of doing this.
	One complication is the need to distinguish between pointers
	leaking and pointers that have been handed off from RCU to
	some other synchronization mechanism, for example, reference
	counting.
<li>	In kernels built with <tt>CONFIG_RCU_TRACE=y</tt>, RCU-related
	information is provided via both debugfs and event tracing.
<li>	Open-coded use of <tt>rcu_assign_pointer()</tt> and
	<tt>rcu_dereference()</tt> to create typical linked
	data structures can be surprisingly error-prone.
	Therefore, RCU-protected
	<a href="http://lwn.net/Articles/609973/#RCU List APIs">linked lists</a>
	and, more recently, RCU-protected
	<a href="https://lwn.net/Articles/612100/">hash tables</a>
	are available.
	Many other special-purpose RCU-protected data structures are
	available in the Linux kernel and the user-space RCU library.
<li>	Some linked structures are created at compile time, but still
	require <tt>__rcu</tt> checking.
	The <tt>RCU_POINTER_INITIALIZER()</tt> macro serves this
	purpose.
<li>	It is not necessary to use <tt>rcu_assign_pointer()</tt>
	when creating linked structures that are to be published via
	a single external pointer.
	The <tt>RCU_INIT_POINTER()</tt> macro is provided for
	this task and also for assigning <tt>NULL</tt> pointers
	at runtime.
</ol>

<p>
This is not a hard-and-fast list:  RCU's diagnostic capabilities will
continue to be guided by the number and type of usage bugs found
in real-world RCU usage.

<p>
The final installment in this series will cover issues specific to the
Linux kernel and the future of RCU.  

<a name="qqanswers"></a>
<h4>Answers to the quick quizzes</h4>
<p>
<a name="qq11answer"></a>
<p><b>Quick Quiz 11</b>:
What about sleeping locks?


</p><p><b>Answer</b>:
These are forbidden within Linux-kernel RCU read-side critical sections
because it is not legal to place a quiescent state (in this case,
voluntary context switch) within an RCU read-side critical section.
However, sleeping locks may be used within user-space RCU read-side critical
sections, and also within Linux-kernel sleepable RCU
(SRCU)
read-side critical sections.
In addition, the -rt patchset turns spinlocks into a sleeping lock so
that the corresponding critical sections can be preempted, which
also means that these sleeplockified spinlocks (but not other sleeping locks!)
may be acquired within -rt-Linux-kernel RCU read-side critical sections.

<p>
Note that it <i>is</i> legal for a normal RCU read-side critical section
to conditionally acquire a sleeping lock (as in <tt>mutex_trylock()</tt>),
but only as long as it does not loop indefinitely attempting to
conditionally acquire that sleeping lock.
The key point is that things like <tt>mutex_trylock()</tt>
either return with the mutex held, or return an error indication if
the mutex was not immediately available.
Either way, <tt>mutex_trylock()</tt> returns immediately without sleeping.


</p><p><a href="#Quick%20Quiz%2011"><b>Back to Quick Quiz 11</b>.</a>

<a name="qq12answer"></a>
<p><b>Quick Quiz 12</b>:
Why does line&nbsp;19 use <tt>rcu_access_pointer()</tt>?
After all, <tt>call_rcu()</tt> on line&nbsp;25 stores into the
structure, which would interact badly with concurrent insertions.
Doesn't this mean that <tt>rcu_dereference()</tt> is required?

</p><p><b>Answer</b>:
Presumably the <tt>-&gt;gp_lock</tt> acquired on line&nbsp;18 excludes
any changes, including any insertions that <tt>rcu_dereference()</tt> would
protect against.
Therefore, any insertions will be delayed until after
<tt>-&gt;gp_lock</tt> is released on line&nbsp;25, which in turn means
that <tt>rcu_access_pointer()</tt> suffices.


</p><p><a href="#Quick%20Quiz%2012"><b>Back to Quick Quiz 12</b>.</a>

<a name="qq13answer"></a>
<p><b>Quick Quiz 13</b>:
Earlier it was claimed that <tt>call_rcu()</tt> and
<tt>kfree_rcu()</tt> allowed updaters to avoid being blocked
by readers.
But how can that be correct, given that the invocation of the callback
and the freeing of the memory (respectively) must still wait for
a grace period to elapse?


</p><p><b>Answer</b>:
We could define things this way, but keep in mind that this sort of
definition would say that updates in garbage-collected languages
cannot complete until the next time the garbage collector runs,
which does not seem at all reasonable.
The key point is that in most cases, an updater using either
<tt>call_rcu()</tt> or <tt>kfree_rcu()</tt> can proceed to the
next update as soon as it has invoked <tt>call_rcu()</tt> or
<tt>kfree_rcu()</tt>, without having to wait for a subsequent
grace period.


</p><p><a href="#Quick%20Quiz%2013"><b>Back to Quick Quiz 13</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Read-copy-update">Read-copy-update</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/652677/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor653684"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RCU requirements part 2 — parallelism and software engineering</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2015 7:13 UTC (Thu)
                               by <b>mlankhorst</b> (subscriber, #52260)
                              [<a href="/Articles/653684/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Having used rcu a little the answer to quick quiz 12 was surprising. :-)<br>
<p>
rcu_dereference is also wrong here and will fail with PROVE_RCU. ;-)<br>
<p>
It would need to be rcu_dereference_check(.., lockdep_is_held(&amp;gp_lock));<br>
<p>
It's a bit overkill since we locked it in the previous line, but when locking and assigning is done in a different function it would make sense.<br>
<p>
Am I wrong that rcu_access_pointer would be allowed if call_rcu is called after spin_unlock?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/653684/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor653770"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RCU requirements part 2 — parallelism and software engineering</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2015 21:21 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/653770/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good catch on the need for rcu_dereference_check()!<br>
<p>
But assuming that holding the lock prevents concurrent insertions, rcu_access_pointer() would in fact work just fine.<br>
<p>
So this was quite the trick question.  Beyond even the author's intent.  :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/653770/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor653701"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RCU requirements part 2 — parallelism and software engineering</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2015 11:34 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/653701/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>I am not sure I understand the answer to Quick Quiz 12 as well.
<p>In particular, say I have the following function:

<pre>
    void destroy_thing(struct thing *t)
    {
        struct frob *old = rcu_dereference(t-&gt;frob);

        rcu_assign_pointer(t-&gt;frob, NULL);
        kfree_rcu(old, rh);

        /*
         * The old frobnicator had a back pointer to t, so we cannot free t
         * until the next grace period, either.
         */
        kfree_rcu(t, rh);
    }
</pre>

<p>Based on the answer to the Quick Quiz, I am using <tt>rcu_dereference</tt> to dereference <tt>t-&gt;frob</tt> before freeing it; so far so good.  However, who is supposed to call rcu_dereference on <tt>t</tt>'s fetch?  The caller of <tt>destroy_thing</tt> might not even be aware that <tt>struct thing</tt> is using RCU.

<p>(The above is simplified from real code in QEMU).
      
          <div class="CommentReplyButton">
            <form action="/Articles/653701/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor653784"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RCU requirements part 2 — parallelism and software engineering</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 6, 2015 21:32 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/653784/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, as it turns out, you were quite right not to understand the answer because the answer was wrong.  :-)<br>
<p>
If the thing that t was fetched from is always RCU-protected, but the caller doesn't know that, one approach is to create a wrapper macro that applies the rcu_dereference():<br>
<p>
#define destroy_thing(t) _destroy_thing(rcu_dereference(t))<br>
<p>
Or am I missing the point?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/653784/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor653811"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RCU requirements part 2 — parallelism and software engineering</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2015 7:10 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/653811/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that it falls under "holding the lock prevents concurrent insertions" (modifications in this case) so rcu_access_pointer() would be fine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/653811/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor654078"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Quick Quiz 12 has been updated, thank you!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 10, 2015 18:57 UTC (Mon)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/654078/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quick Quiz 12 has been updated based on the previous comments, as has the code example that it refers to.<br>
<p>
I guess the good news is that the community has picked up enough RCU experience to catch my mistakes.  :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/654078/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
