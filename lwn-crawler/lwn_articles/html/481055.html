        <!DOCTYPE html>
        <html lang="en">
        <head><title>Linux support for ARM big.LITTLE [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/481055/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/480304/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/481055/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Linux support for ARM big.LITTLE</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we donâ€™t have to get good at marketing.
</blockquote>
<div class="GAByline">
           <p>February 15, 2012</p>
           <p>This article was contributed by Nicolas Pitre</p>
           </div>
<p>
ARM Ltd recently announced the <a href="http://www.arm.com/products/processors/technologies/bigLITTLEprocessing.php">big.LITTLE architecture</a> consisting of 
a twist on the SMP systems that we've all gotten accustomed to.  Instead of
having a bunch of identical CPU cores put  
together in a system, the big.LITTLE architecture is effectively pushing 
the concept further by pulling two different SMP systems together: one 
being a set of "big" and fast processors, the other one consisting of 
"little" and power-efficient processors.

<p>
In practice this means having a cluster of <a href="http://www.arm.com/products/processors/cortex-a/cortex-a15.php">Cortex-A15</a> cores, a 
cluster of <a href="http://www.arm.com/products/processors/cortex-a/cortex-a7.php">Cortex-A7</a> cores, and ensuring cache coherency between 
them. The advantage of such an arrangement is that it allows for
significant power  
saving when processes that don't require the full performance of the 
Cortex-A15 are executed on the Cortex-A7 instead.  This way, 
non-interactive background operation, or streaming multimedia decoding, 
can be run on the A7 cluster for power efficiency, while sudden screen 
refreshes and similar bursty operations can be run on the A15 cluster to 
improve responsiveness and interactivity.

<p>
Then, how to support this in Linux?  This is not as trivial as it may 
seem initially.  Let's suppose we have a system comprising a cluster of 
four A15 cores and a cluster of four A7 cores.  The naive approach would 
suggest making the eight cores visible to the kernel and letting the 
scheduler do its job just like with any other SMP system.  But here's 
the catch: SMP means Symmetric Multi-Processing, and in the big.LITTLE 
case the cores aren't symmetric between clusters.

<p>
The Linux scheduler expects all available CPUs to have the same 
performance characteristics.  For example, there are provisions in the 
scheduler to deal with things like hyperthreading, but this is still an 
attribute which is normally available on all CPUs in a given system. 
Here we're purposely putting together a couple of CPUs with significant 
performance/power characteristic discrepancies in the same system, and 
we expect the kernel to make the optimal usage of them at all times, 
considering that we want to get the best user experience together with 
the lowest possible battery consumption.

<p>
So, what should be done?  Many questions come to mind:
<ul>
<li>Is it OK to reserve the A15 cluster just for interactive tasks and the
  A7 cluster for background tasks?
<li>What if the interactive tasks are sufficiently light to be processed by
  the small cores at all times?  
<li>What about those background tasks that the user interface is actually 
  waiting after?  
<li>How to determine if a task using 100% CPU on a small core should be 
  migrated to a fast core instead, or left on the small core because
  it is not critical enough to justify the increased power usage?  
<li>Should the scheduler auto-tune its behavior, or should user-space 
  policies influence it?
<li>If the latter, what would the interface look like to be useful and
  sufficiently future-proof?
</ul>

<p>  
Linaro started an <a
href="https://blueprints.launchpad.net/linux-linaro/+spec/linaro-kernel-q112-baby-steps-to-big-little-mp">initiative</a>
during the most recent <a href="http://connect.linaro.org/events/event/lcq1-12/">Linaro Connect</a> to 
investigate this problem.  It will require a high degree of 
collaboration with the upstream scheduler maintainers and a good amount 
of discussion. And given past history, we know that scheduler changes 
cannot happen overnight... unless your name is Ingo that is.  
Therefore, it is safe to assume that this will take a significant amount 
of time.

<p>
Silicon vendors and portable device makers are not going to wait though.  
Chips implementing the big.LITTLE architecture will appear on the market 
in one form or another, way before a full heterogeneous multi-processor 
aware scheduler is available.  An interim solution is therefore needed 
soon. So let's put aside the scheduler for the time being.

<p>
ARM Ltd has produced a prototype software solution 
consisting of a small hypervisor using the virtualization extensions of 
the Cortex-A15 and Cortex-A7 to make both clusters appear to the 
underlying operating system as if there was only one Cortex-A15 cluster. 
Because the cores within a given cluster are still symmetric, all the 
assumptions built into the current scheduler still hold. With a 
single call, the hypervisor can atomically suspend execution of the 
whole system, migrate the CPU states from one cluster to the other, and 
resume system execution on the other cluster without the underlying 
operating system being aware of the change; just as if nothing has 
happened.

<p>
Taking the example above, Linux would see only four Cortex-A15 CPUs at all 
times.  When a switch is initiated, the registers for each of the 4 CPUs 
in cluster A are transferred to corresponding CPUs in cluster B, 
interrupts are rerouted to the CPUs in cluster B, then CPUs in cluster B are 
resumed exactly where cluster A was interrupted, and, finally, the CPUs in 
cluster A are powered off.  And vice versa for switching back to the 
original cluster. Therefore, if there are eight CPU cores in the system, 
only four of them are visible to the operating system at all times. The 
only visible difference is the observable execution speed, and of course 
the corresponding change in power consumption when a cluster switch 
occurs.  Some latency is implied by the actual switch of course, but 
that should be very small and imperceptible by the user.

<p>
This solution has advantages such as providing a mechanism which should 
work for any operating system targeting a Cortex-A15 without 
modifications to that operating system. It is therefore OS-independent 
and easy to integrate. However, it brings a certain level of complexity 
such as the need to virtualize all the differences between the A15 and 
the A7.  While those CPU cores are functionally equivalent, they may 
differ in implementation details such as cache topology. That would force
every  
cache maintenance operation to be trapped by the hypervisor and 
translated into equivalent operations on the actual CPU core when the 
running core is not the one that the operating system thinks is running.

<p>
Another disadvantage is the overhead of saving and restoring the full 
CPU state because, by virtue of being OS-independent, the hypervisor 
code may not know what part of the CPU is actually being actively used 
by the OS.  The hypervisor could trap everything to be able to know what 
is being touched allowing partial context transfers, but that would be 
yet more complexity for a dubious gain.  After all, the kernel already 
knows what is being used in the CPU, and it can deal with differing 
cache topologies natively, etc. So why not implement this switcher 
support directly in the kernel given that we <i>can</i> modify Linux and do 
better?

<p>
In fact that's exactly what we are doing i.e. take the ARM Ltd BSD 
licensed <a href="http://git.linaro.org/gitweb?p=arm/big.LITTLE/switcher.git;a=summary">switcher code</a> and use it as a reference to actually put the 
switcher functionality directly in the kernel.  This way, we can get 
away with much less support from the hypervisor code and improve 
switching performances by not having to trap any cache maintenance 
instructions, by limiting the CPU context transfer only to the minimum 
set of active registers, and by sharing the same address space with the 
kernel.

<p>
We can implement this switcher by modeling its functionality as a CPU 
speed change, and therefore expose it via a <a href="http://www.ibm.com/developerworks/linux/library/l-cpufreq-1/index.html">cpufreq</a> driver.  This 
way, contrary to the reference code from ARM Ltd which is limited to a 
whole cluster switch, we can easily pair each of the A15 cores with one 
of the A7 cores, and have each of those CPU pairs appear as a single 
pseudo CPU with the ability to change its performance level via cpufreq.  
And because the cpufreq governors are already available and understood 
by existing distributions, including Android, we therefore have a 
straightforward solution with a fast time-to-market for the big.LITTLE 
architecture that shouldn't cause any controversy.

<p>
Obviously the "switcher" as we call it is not replacing the ultimate 
goal of exposing all the cores to the kernel and letting the scheduler 
make the right decisions.  But it is nevertheless a nice self-contained 
interim solution that will allow pretty good usage of the big.LITTLE 
architecture while removing the pressure to come up with scheduler 
changes quickly.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Architectures-Arm">Architectures/Arm</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#big.LITTLE">big.LITTLE</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Scheduler-big.LITTLE">Scheduler/big.LITTLE</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Pitre_Nicolas">Pitre, Nicolas</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/481055/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor481655"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 14:54 UTC (Wed)
                               by <b>SEJeff</b> (guest, #51588)
                              [<a href="/Articles/481655/">Link</a>] (36 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Doesn't Nvidia's Tegra3 "Kal El" processor already do this?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481655/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481657"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 15:02 UTC (Wed)
                               by <b>tajyrink</b> (subscriber, #2750)
                              [<a href="/Articles/481657/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it's NVIDIA's own approach to the same thing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481657/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481660"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 15:08 UTC (Wed)
                               by <b>SEJeff</b> (guest, #51588)
                              [<a href="/Articles/481660/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Right. Nvidia had the first shipping implementation vs ARM. I wonder if they got the idea from ARM, or ARM got the idea from the Tegra 3.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481660/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481662"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 15:21 UTC (Wed)
                               by <b>gioele</b> (subscriber, #61675)
                              [<a href="/Articles/481662/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I wonder if they got the idea from ARM, or ARM got the idea from the Tegra 3.</font><br>
<p>
The idea _per se_ is not new at all, see the asymmetric multi-CPUs [1] in the '70s or the Cell architecture in 2000 [2].<br>
<p>
[1] <a href="https://en.wikipedia.org/wiki/Asymmetric_multiprocessing">https://en.wikipedia.org/wiki/Asymmetric_multiprocessing</a><br>
[2] <a href="https://en.wikipedia.org/wiki/Cell_%28microprocessor%29">https://en.wikipedia.org/wiki/Cell_%28microprocessor%29</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481662/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor481665"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 15:33 UTC (Wed)
                               by <b>hamjudo</b> (guest, #363)
                              [<a href="/Articles/481665/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Anybody who programmed a <a href=http://en.wikipedia.org/wiki/CDC_6600>CDC Cyber 6600</a> thought, wouldn't it be great if we could make a system where the little processors ran the same instruction set as the big processors?<p>

Wikipedia says the Cyber came out in 1964. There are many earlier examples.
      
          <div class="CommentReplyButton">
            <form action="/Articles/481665/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor481688"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 16:50 UTC (Wed)
                               by <b>drag</b> (guest, #31333)
                              [<a href="/Articles/481688/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's very common for ARM systems to have disparate processors. My GP2X handheld is dual core system. It has a regular ARM processor and then a second processor for accelerating some types of multimedia functions. <br>
<p>
Then, of course, there is modern x86-64 systems were the GPU is a now a coprocessor that can be used for anything, rather then something dedicated just for graphics. <br>
<p>
I don't know how common it is to have disparate general purpose processors, however. With my GP2X the application had to be optimized to take advantage of the second processor. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481688/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 17:04 UTC (Wed)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/481692/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Right, but IIRC, the OS runs as a single processor OS, and the second CPU is treated as more like a peripheral.  You write your video / graphics processing code for the second ARM and then it becomes an application specific accelerator, not too much different than dedicated hardware, but tuned for a particular app.<br>
<p>
Heck, even desktop PCs have been asymmetric multiprocessor since their introduction (8038 in the keyboard controller, 8088 running the apps), but the OS really only thinks about the main CPU.<br>
<p>
The A7/A15 split is rather different:  This wants to run SMP Linux across both types of cores, dynamically moving tasks between the A7 and A15 side of the world seamlessly.  All of the processor cores are considered generic resources, just with different performance/power envelopes.  That's rather different from the GP2X model.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481701"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 18:16 UTC (Wed)
                               by <b>jmorris42</b> (guest, #2203)
                              [<a href="/Articles/481701/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Right, but IIRC, the OS runs as a single processor OS, and the</font><br>
<font class="QuotedText">&gt; second CPU is treated as more like a peripheral.</font><br>
<p>
True but that is because of reasons above the silicon.  In a typical bottom of the line Android phone you already have multiple processing cores.  Mine has two ARM cores, two DSPs plus the GPU.  One ARM and one DSP are dedicated to the radio to keep that side a silo but the processors can talk to each other and share one block of RAM.  So there isn't a techinical reason an OS couldn't be written for that old hardware that unified all five processing elements and dispatched executable code between the ARM cores as needed.  It just wouldn't be a phone anymore.<br>
<p>
The 'innovation' here is deciding to encourage the rediscovery of asymetrical multiprocessing and to relearn and update the ways to deal with the problems it brings. There was a reason everyone moved to SMP, it made the software a lot easier; now power consumption drives everything and software is already very complex so the balance shifts.  <br>
<p>
Then they will stick in an even slower CPU for the radio in chips destined for phone use and wall it off in the bootloader just like now.  It is the only way to keep the lawyers (and the FCC) happy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481701/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 20:51 UTC (Wed)
                               by <b>phip</b> (guest, #1715)
                              [<a href="/Articles/481769/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You need more than just shared DRAM to enable an MP OS.  The CPUs need to be cache-coherent.<br>
<p>
In a low-end multicore SOC with noncoherent CPUs, the DRAM is usually statically partitioned between the CPUs which run independant OS images.  Any interprocessor communication is done through shared buffers that are uncached or else carefully fushed at the right times (similar to DMA)<br>
<p>
-Phil<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481787"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 21:55 UTC (Wed)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/481787/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nah. There's no real reason the hardware has to be cache coherent. It is just a lot easier if it is.<br>
<p>
For example, the OS could force a cache flush on both CPUs when migrating a task.<br>
<p>
Threaded applications would have a tough time, but even that has been handled in the past. For example, the compiler and/or threading library could either track memory writes between locks so as to make sure those cache addresses are flushed, or it could use the big hammer of a full cache flush before unlock.<br>
<p>
Cache coherency is really just a crutch. Lots of embedded programmers and Cell programmers (no cache protocol on the SPE's) know how to work without it. :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481787/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 22:31 UTC (Wed)
                               by <b>phip</b> (guest, #1715)
                              [<a href="/Articles/481797/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Strictly speaking that's true, but it is cumbersome enough in practice<br>
that nobody does it for any mainstream OS.<br>
<p>
It's not just migrating processes &amp; threads - any global operating<br>
system data structures need to be synchronized with cache flushes,<br>
memory ordering barriers, mutexes, etc. before and after each access.<br>
<p>
If you want to use multiple noncoherent cores to run a general-purpose,<br>
the best approach is to treat it as a cluster (with each CPU running<br>
its own OS image).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 22:35 UTC (Wed)
                               by <b>phip</b> (guest, #1715)
                              [<a href="/Articles/481799/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't know of anyone running a general-purpose OS on the Cell<br>
Synergestic Processors (or on a GPU for that matter).<br>
<p>
Having a different instruction set on the different processor<br>
cores moves the complexity to another level above noncoherence.<br>
<p>
The usual programming model is to run a general-purpose OS on the<br>
PowerPC processor(s), and treat the SPEs as a type of coprocessor<br>
or peripheral device.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481801"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 23:02 UTC (Wed)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/481801/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For the Cell SPEs or GPU shaders they probably aren't capable enough to bother with having the OS run them directly. I only brought them up because there's no automatic cache coherence with them. They read the data into cache (the local 256 KB). They write the data out. Both read and write are done explicitly.<br>
<p>
No one runs a MP system of different instruction sets, true. It isn't impossible though.  The OS would need to be built twice, once for each instruction set. It could share the data structures. <br>
<p>
I wonder if Intel ever played around with this for an Itanium server? It seems that I remember Itanium once shared the same socket layout as a Xeon so this would have been possible on a hardware level.<br>
<p>
Now, if you got very tricky and decided to require that all software be in an intermediate language, the OS could use LLVM, Java, .NET or whatever to compile the binary to whichever CPU was going to execute the process. That would really make core switching expensive! And you'd need some way to mark where task switches were allowed to happen, and maybe run the task up to the next switch point so you could change over to the same equivalent point in the other architecture.<br>
<p>
A bit more realistic would be cores with the same base instruction set, but specialized functions on different cores. That could work really well. When the program hit an "Illegal Instruction" fault, the OS could inspect the instruction and find one of the system cores that supports it, then migrate the task there or emulate the instruction. Or launch a user-space helper to download a new core design off the internet and program the FPGA!. That would let programmers use specialized vector, GPU, audio or regular expression instructions without worrying about what cores to use.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481801/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor482415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2012 18:06 UTC (Sun)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/482415/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
zlynx comments:<br>
<p>
"it could use the big hammer of a full cache flush before unlock.<br>
Cache coherency is really just a crutch. Lots of embedded programmers and Cell programmers (no cache protocol on the SPE's) know how to work without it. :-)"<br>
<p>
Full cache flush == embedded "Big Kernel Lock" equivalent?<br>
<p>
-- Alison Chaiken, alchaiken@gmail.com<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482443"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2012 21:51 UTC (Sun)
                               by <b>phip</b> (guest, #1715)
                              [<a href="/Articles/482443/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Big Kernel Lock...<br>
<p>
Hmm, that brings up another point I should have thought of earlier:<br>
Non-coherent multi-CPU SOCs are also likely to not implement<br>
atomic memory access primatives (i.e. Compare/Exchange, Test and Set,<br>
Load-Linked/Store-Conditional, etc.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482443/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor481696"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 17:27 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/481696/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
It's very common for ARM systems to have disparate processors. My GP2X handheld is dual core system. It has a regular ARM processor and then a second processor for accelerating some types of multimedia functions. 
</blockquote>
This goes right back to the ARM's prehistory. The BBC microcomputer's 'Tube' coprocessor interface springs to mind, allowing you to plug in coprocessors with arbitrary buses, interfacing them to the host machine via a set of FIFOs. People tended to call the coprocessor 'the Tube' as well, which was a bit confusing given how variable the CPUs were that you could plug in there.

      
          <div class="CommentReplyButton">
            <form action="/Articles/481696/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor483396"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2012 19:41 UTC (Thu)
                               by <b>wmf</b> (guest, #33791)
                              [<a href="/Articles/483396/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the canonical reference here is "Single-ISA Heterogeneous Multi-Core Architectures" from MICRO 2003: <a rel="nofollow" href="http://www.microarch.org/micro36/html/pdf/kumar-SingleISAHeterogen.pdf">http://www.microarch.org/micro36/html/pdf/kumar-SingleISA...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/483396/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor481673"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ARM big.LITTLE vs. nvidia Tegra 3 Kal-El</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 15:50 UTC (Wed)
                               by <b>Felix.Braun</b> (guest, #3032)
                              [<a href="/Articles/481673/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
However, as I understand it, in Tegra 3 doesn't expose all processors to the OS. Instead it makes the decisions in hardware, when to use the smaller processor (it's only one small processor in Kal-El's case IIRC) and when to switch on the big processors.<br>
<p>
A software approach seems more flexible to me, which is a good thing considering the complexity of the issue. This seems impossible to get right in the first try.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481673/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481677"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ARM big.LITTLE vs. nvidia Tegra 3 Kal-El</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 15:55 UTC (Wed)
                               by <b>Felix.Braun</b> (guest, #3032)
                              [<a href="/Articles/481677/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here's the link to the White-Paper describing the Kal-El architecture: <a href="http://www.nvidia.com/content/PDF/tegra_white_papers/Variable-SMP-A-Multi-Core-CPU-Architecture-for-Low-Power-and-High-Performance.pdf">http://www.nvidia.com/content/PDF/tegra_white_papers/Vari...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481677/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor481913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 14:46 UTC (Thu)
                               by <b>yaap</b> (subscriber, #71398)
                              [<a href="/Articles/481913/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Some overall idea, but different implementations. <br>
<p>
In Nvidia approach, you have 1 slow Cortex A9 optimized for low power, and 4 fast Cortex A9 optimized for performance. The slow one will run at 500 MHz while the fast ones could be 1 GHz or more. They use a mixed 40nm LP/G process, so I would assume that the slow A9 is LP (low power) while the others are in G (generic/high performance), but that's just a guess. Anyway, there are other ways to optimize for speed vs. low power.<br>
The switch is between the single "slow" A9 and the other(s). If the slow is not enough, the load is switched to a fast A9. Then when on the fast side (with the slow disabled), one or several cores may be enabled depending on the workload.<br>
<p>
With LITTLE.big, for now you have as many A7 as A15 cores. The current approach switch between all A7 or all A15. But "all" is misleading, in that not all cores may be needed of course.<br>
ARM approach may also support later on a finer approach where you have pairs of A7/A15, and each pair can switch (or be disabled) independently. Nicer of course. But still as many A7 as A15 cores.<br>
<p>
The NVidia approach applied to LITTLE.big would be a single A7 and 4 A15. But it doesn't seem to be in the plans yet. And I guess that as ARM gets more money the more cores are used, they don't have much incentive to get there ;) Still, as far as I know, nothing would prevent a licensee to do that on its own.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481982"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 19:51 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/481982/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I recall, the individual CPUs in an A15 cluster can be powered on/off independently of the others.  I would be surprised if A7 didn't also allow that.<br>
<p>
So, you could set up "migration pairs", pairing each A15 CPU with an A7 CPU, and only keep one on at a time, migrating back and forth as needed.  If all CPUs in a cluster are off, then you can shut off the cluster as a whole.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481982/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481985"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 19:57 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/481985/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
what's the reason to pair up CPUs like this rather than just using the processing power of all of the CPUs? (assuming they are all powered on)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481985/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 21:21 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/481999/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The last three paragraphs of the article really summarize why.  <br>
<p>
The current scheduler does not really understand heterogeneous CPU mixes.  But, you can still do better than ARM's hypervisor-based switcher by pushing the logic into the kernel, and doing this pair-wise switcheroo.  Then, the existing Linux infrastructure just models it as a frequency change within its existing governor framework.<br>
<p>
Longer term, of course, you do want to teach Linux how to load balance properly between disparate cores, so at the limit, you could have all 2*N CPUs active on a machine with an N-CPU A15 cluster next to an N-CPU A7 cluster.  But in the short run, pulling ARM's BSD-licensed switching logic to do the pair-wise switch at least gets something running that works better than leaving it to the hypervisor.  The short run use model really does appear to be to have N CPUs powered on when you have an N CPU A15 cluster next to an N CPU A7 cluster.<br>
<p>
Another thought occurs to me:  Even if Linux were able to schedule for all 8 CPUs, the possibility exists that the environment around it doesn't really support that.  It might not have the heat dissipation or current carrying capacity to have all 2*N CPUs active.  So, that's another reason the pair-wise switch is interesting to consider.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482002"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 21:23 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/482002/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Keeping my abstraction straight, I should have said "Even if Linux were able to schedule for all 2*N CPUs."  And carrying the thought further, I mean "schedule efficiently and appropriately for the CPU mix."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482002/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor482004"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 21:35 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/482004/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok, that may be a short-term hack, but such a hack should probably not go into the mainline scheduler.<br>
<p>
My point is that we already have these 'problems' on mainstream systems.<br>
<p>
On Intel and AMD x86 CPUs we already have cases where turning off some cores will let you run other cores at a higher clock speed (thermal/current limitations), and where you can run some cores at lower speeds than others<br>
<p>
These may not be as big a variation as the ARM case has, but it's a matter of degree, not a matter of being a completely different kind of problem.<br>
<p>
I agree that the current scheduler doesn't have explicit code to deal with this today, but I think that for the most part the existing code will 'just work' without modification. The rebalancing code pulls work off of a core if the core is too heavily loaded. a slower core will be more heavily loaded for the same work than a faster core would be, so work will naturally be pulled off of a heavily loaded slow core.<br>
<p>
The two points where the current scheduler doesn't do the right thing are in the rebalancing code when considering moving processes between cores of different speeds (but only if you have CPU hog processes that will max out a core). As I note above, fixing this doesn't seem like that big a change, definitely less intrusive than the NUMA aware parts.<br>
<p>
<p>
let userspace figure out all the nuances of what combinations of clock speeds on the different cores will work in the current environment (if it's limited by thermal factors, then different cooling, ambient temperatures, etc will change these limits, you really don't want that code in the kernel)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482004/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482135"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 16:40 UTC (Fri)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/482135/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>On Intel and AMD x86 CPUs we already have cases where turning off some cores will let you run other cores at a higher clock speed (thermal/current limitations), and where you can run some cores at lower speeds than others.</blockquote>
<p>The Linux scheduler already generically supports the grouping of CPU threads that share resources, and tends to spread runnable tasks out across groups (although it can also be configured to concentrate them in order to save power). I think that this should result in enabling the 'turbo' mode where possible.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482135/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482185"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 19:05 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/482185/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My point is that deciding to try to enable 'turbo' mode, or to slow down some cores to speed up other cores, etc is an area that is so complex and machine specific that trying to do it in the kernel is wrong.<br>
<p>
Part of the decision process will also need to be to consider what programs are running, and how likely are these programs to need significantly more CPU than they are currently using (because switching modes takes a significant amount of time), this involves a lot of policy, and a lot of useage profiling, exactly the types of things that do not belong in the kernel.<br>
<p>
<p>
With the exception of the case where there is a single thread using all of a core, I think the existing kernel scheduler will 'just work' on a system with different speed cores.<br>
<p>
Where I expect the current scheduler to have problems is in the case where a single thread will max out a CPU, I don't think that the scheduler will be able to realize that it would max one CPU, but not max another one<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482185/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482196"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 19:24 UTC (Fri)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/482196/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While I understand that policy decisions should be set by user-space, the kernel generally and the scheduler in particular cannot make synchronous calls to ask userland what to do. Also, upcalls are relatively expensive. So the kernel has to be given the information to get on and implement the policy without asking too many questions.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482196/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 19:38 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/482200/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm in no way suggesting that the kernel make calls to userspace (synchronous or otherwise)<br>
<p>
I view this as a three tier system<br>
<p>
At the first tier you have the scheduler on each core making decisions about what process that is assigned to that core should run next<br>
<p>
At the second tier you have a periodic rebalancing algorithm that considers moving jobs from one core to another. preferably run by a core that has idle time (that core 'pulls' work from other cores)<br>
<p>
These two tiers will handle cores of different speeds without a problem as-is, as long as no thread maxes out the slowest core.<br>
<p>
I am saying that the third tier would be the userspace power management daemon, which operates completely asynchronously to the kernel, it watches the overall system and makes decisions on when to change the CPU configuration. When it decides to do so, it would send a message to the kernel to make the change (change the speed of any core, including power it off or on)<br>
<p>
until the userspace issues the order to make the change, the kernel scheduler just works with what it has, no interaction with userspace needed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482214"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 20:26 UTC (Fri)
                               by <b>BenHutchings</b> (subscriber, #37955)
                              [<a href="/Articles/482214/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, what you're suggesting is still likely to be too slow. Look how successful the 'userspace' cpufreq governor isn't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482214/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482227"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 22:34 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/482227/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't see what's so performance critical about this, you shouldn't be making significant power config changes to your system hundreds of times a second, <br>
<p>
doing the analysis every second (or even less frequently) should be pretty good in most cases<br>
<p>
the kernel can do some fairly trivial choices, but they are limited to something along the lines of<br>
<p>
here is a list of power modes, if you think you are being idle too much, move down the list, if you think you are not being idle enough move up the list<br>
<p>
but anything more complicated than this will quickly get out of control<br>
<p>
for example,<br>
<p>
for the sake of argument, say that 'turbo mode' is defined as:<br>
<p>
turn off half your cores and run the other half 50% faster, using the same amount of power. (loosing 25% of it's processing power, probably more due to memory pipeline stalls)<br>
<p>
how would the kernel ever decide when it's appropriate to sacrifice so much of it's processing power for no power savings?<br>
<p>
I could say that I would want to do so if a single thread is using 100% of a cpu in a non-turbo mode.<br>
<p>
but what if making that switch would result in all the 'turbo mode' cores being maxed out? it still may be faster to run overloaded for a short time to finish the cpuhog task faster.<br>
<p>
I don't see any way that this sort of logic can possibly belong in the kernel. And it's also stuff that's not very timing sensitive (if delaying a second to make the decision results in the process finishing first, it was probably not that important a decision to make, for example)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482227/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482235"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 23:25 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/482235/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">I don't see what's so performance critical about this, you shouldn't be making significant power config changes to your system hundreds of times a second,</font></blockquote>

<p>Why do you think so?</p>

<blockquote><font class="QuotedText">And it's also stuff that's not very timing sensitive (if delaying a second to make the decision results in the process finishing first, it was probably not that important a decision to make, for example)</font></blockquote>

<p>What you are talking about? It looks like this whole discussion comes from different universe. Perhaps it's the <a href="http://lwn.net/Articles/474557/">well-discussed phenomenon</a> where <i>an important requirement that was not at all obvious to</i> one party is <i>so obvious to</i> other one <i>that they didn't think to state it</i>.</p>

<p>We are discussing all that in the context of <a href="http://www.arm.com/products/processors/technologies/bigLITTLEprocessing.php">big.LITTLE</a> processing, right? Which is used by things like tablets and mobile phones, right?</p>

<p>Well, the big question here is: do I need to unfreeze and use hot and powerful Cortex-A15 core to perform some kind of UI task or will slim and cool Cortex-A7 be enough to finish it? And the cut-off is dictated by physiology: the task should be finished in less then 70-100ms if it's reaction to user input or in 16ms if it's part of the animation. This means that decision to wake up Cortex-A15 or not must be taken in 1-2ms, tops. Better to do it in about 300-500Âµs. Any solution which alters power config once per second is so, <b>so</b>, <b>SO</b> beyond the event horison it's not even funny.</p>

<blockquote><font class="QuotedText">I could say that I would want to do so if a single thread is using 100% of a cpu in a non-turbo mode.</font></blockquote>

<p>Wrong criteria. If Cortex-A7 core can calculate the next frame in 10ms then there are no need to wake up Cortex-A15 core even if for these 10ms Cortex-A7 is 100% busy.</p>

<p>The problems here are numerous and indeed quite time-critical. The only model which makes sense is in-kernel demon which actually does the work quickly and efficiently - but it uses information collected by userspace daemon.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/482235/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2012 0:47 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/482243/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm trying to address the general problem, not just a tablet specific problem.<br>
<p>
waking from some sleep modes may take 10ms, so if you have deadlines like that you better not put the processor to sleep in the first place.<br>
<p>
I also think that a delay at the start of an app is forgivable, so if the system needs the faster cores to render things, it should find out quickly, start up those cores, and continue.<br>
<p>
I agree that if you can specify an ordered list of configurations and hand that to the kernel you may be able to have the kernel use that.<br>
<p>
on the other hand, the example that you give:<br>
<p>
<font class="QuotedText">&gt; Wrong criteria. If Cortex-A7 core can calculate the next frame in 10ms then there are no need to wake up Cortex-A15 core even if for these 10ms Cortex-A7 is 100% busy.</font><br>
<p>
sort of proves my point. how can the kernel know that the application completed it's work if it's busy 100% of the time? (especially if you have an algorithm that will adapt to not having quite enough processor and will auto-scale it's quality)<br>
<p>
this sort of thing requires knowledge that the kernel does not have.<br>
<p>
Also, the example of the 'turbo mode' where you can run some cores faster, but at the expense of not having the thermal headroom to run as many cores. In every case I am aware of, 'turbo mode' actually reduces the clock cycles available overall (and makes the cpu:memory speed ratio worse, costing more performance), but if you have a single threaded process that will finish faster in turbo mode, it may be the right thing to do to switch to that mode.<br>
<p>
it doesn't matter if you are a 12 core Intel x86 monster, or a much smaller ARM chip.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482282"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2012 11:09 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/482282/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">it doesn't matter if you are a 12 core Intel x86 monster, or a much smaller ARM chip.</font></blockquote>

<p>Well, sure. But differences between interactive tasks and batch processing modes are acute. With batch processing you are optimizing time for the [relatively] long process. With interactive tasks you optimize work in your tiny 16ms timeslice. It makes no sense to produce result in 5ms (and pay for it) but if you spent 20ms then you are screwed.</p>

<p>Today the difference is not so acute because the most power-hungry part of the smartphone or tablet is LCD/OLED display. But if/when technologies like <a href="http://en.wikipedia.org/wiki/Interferometric_modulator_display">Mirasol</a> will be adopted these decisions will suddenly start producing huge differences in the battery life.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/482282/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2012 11:58 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/482285/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
agreed, I'd love to have a passive LCD display netbook that was able to transparently sleep between keystrokes, but realistically we are a long way from that in terms of the hardware capabilities, and even further away from that in terms of being able to predict the future workloads correctly.<br>
<p>
i don't think we are ever going to get away from having to make the choice between keeping things powered up to be able to be responsive, and powering things down aggressively to save power.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482491"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 20, 2012 12:17 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/482491/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Hardware is in labs already (and should reach the market in a few years), it's time to think about software side.</p>

<p>If we are talking about small tweaks then such hardware it not yet on the radar, but if we plan to create the whole new subsystem (task which will itself need two or three years to mature) then it must be considered.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/482491/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor483133"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2012 1:35 UTC (Thu)
                               by <b>scientes</b> (guest, #83068)
                              [<a href="/Articles/483133/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The big.LITTLE whitepaper here: <a href="http://www.arm.com/files/downloads/big_LITTLE_Final_Final.pdf">http://www.arm.com/files/downloads/big_LITTLE_Final_Final...</a><br>
implies that the "big.LITTLE MP Use Model" or running all the cores at once<br>
is supported. Of course this doesn't mean that implamenters that are only testing for the "Task Migration Use Model" will implament it adaquately for a use model they are not using.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/483133/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor481693"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 17:03 UTC (Wed)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/481693/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For a moment I thought ARM had introduced some funky new instructions to switch rapidly between bigendian and littleendian data, perhaps converting between uppercase and lowercase at the same time...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481693/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481810"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 23:59 UTC (Wed)
                               by <b>cmccabe</b> (guest, #60281)
                              [<a href="/Articles/481810/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or a system where one of the CPUs was big-endian, and the other was little-endian.  Just for fun<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481810/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor481885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 13:03 UTC (Thu)
                               by <b>ssvb</b> (guest, #60637)
                              [<a href="/Articles/481885/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW, the funky "SETEND BE"/"SETEND LE" instructions for runtime switching of default endiannes in load/store operations have been supported since ARMv6 :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor481708"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is needed even for bigger systems.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 19:02 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/481708/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There was a issue within the last few weeks related to the scheduler and the debate of what should be in the scheduler vs what should be in a userspace daemon (IIRC it was power / sleep related, but I don't remember exactly what)<br>
<p>
It seems to me that there are two answers that jump out<br>
<p>
1. policy belongs in userspace, so the question of when to power up the fast cores, when to power them down, etc belongs in userspace.<br>
<p>
2. the kernel scheduler needs the ability to handle CPUs with different performance, be it the big.LITTLE approach, or just a many-core x86 box with some cores running at a reduced clock speed.<br>
<p>
For this latter problem, it seems to me that the system shouldn't care abut what the speed of an available CPU is, but should instead be balancing on how close to being maxed out it is. If none of the cores are maxed out, then (except for power management, which we've deferred to userspace on), it doesn't matter how fast any of the cores are.<br>
<p>
The one exception to the "scheduler doesn't need to know the core speeds" is if a core _is_ maxed out, the scheduler needs to know the relative speeds of the different cores to decide if it should move the process to a "better" core.<br>
<p>
However, the speed of the core isn't the only possible reason to move it to a different core, in a NUMA system, you may want to move a job to a different core to get it nearer to the memory that it accesses.<br>
<p>
the good news (at least as it seems to me) is that this is not something that needs to be in the scheduler hot path, this is something that can be in the periodic rebalancing routine, probably as an abstraction of NUMA aware pulling to tinker with the definition of the "optimal" cpu for a job.<br>
<p>
It's definantly not correct to try and schedule interactive tasks on one type of CPU and non-interactive tasks on a different type.<br>
<p>
<p>
In terms of what the API to the userspace daemon needs to be. I can't define details, but to kick off  the conversation, I think it needs to be able to allow the following:<br>
<p>
1. the userspace daemon needs to be able to tell the kernel to alter the configuration of a particular core (power up/down, change it's speed, engage "turbo" mode. This would include turning off some cores so that others can run at higher clock speed), etc.<br>
<p>
2. For some systems this should probably be something close to an atomic change, so the API probably should allow passing a data structure to the kernel, not just individual setting changes.<br>
<p>
3. the userspace daemon needs to be able to see what the existing settings are<br>
<p>
4. the userspace daemon needs to be able to gather infromation about the per-core performance. I think this information is already available today, although there may be reasons to improve the efficiency of gathering it (which would help other performance analysis tools ad well).<br>
<p>
the devil is in the details as always, but this doesn't look like a situation where the broad-brush design options are that difficult.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481708/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575080"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">This is needed even for bigger systems.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2013 23:14 UTC (Tue)
                               by <b>plugwash</b> (subscriber, #29694)
                              [<a href="/Articles/575080/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"It's definantly not correct to try and schedule interactive tasks on one type of CPU and non-interactive tasks on a different type."<br>
In many systems most threads wake up from time to time, do some chunk of work and go back to sleep. The problem is the kernel has no idea either how long the work will take or how important it is that the work is completed quickly. Without that information it is not possible to determine if the job should be run on a cheap (in terms of power per work done) but slow core or an expensive but fast core.<br>
<p>
Assuming that user interaction tasks are time important (that is the user will be pissed off if they don't complete quickly) while background tasks are not time important (that is the user doesn't care how long they take to comlete) is not perfect but it's probablly a better approximation than not having any information at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575080/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor481800"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 22:51 UTC (Wed)
                               by <b>jengelh</b> (subscriber, #33263)
                              [<a href="/Articles/481800/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p><i>&gt;The Linux scheduler expects all available CPUs to have the same performance characteristics.</i></p><p>Does it? Even today, cores can be set to different speeds and therefore performance levels. (It seems the i7-920 has an own will, but certainly HT threads factory in here as well in this oddball printout.)</p><pre>analyzing CPU 0:
  The governor "powersave" may decide which speed to use
  current CPU frequency is 2.67 GHz (asserted by call to hardware).
analyzing CPU 1:
  The governor "performance" may decide which speed to use
  current CPU frequency is 1.60 GHz (asserted by call to hardware).
analyzing CPU 2:
  The governor "performance" may decide which speed to use
  current CPU frequency is 1.60 GHz (asserted by call to hardware).
analyzing CPU 3:
  The governor "performance" may decide which speed to use
  current CPU frequency is 1.60 GHz (asserted by call to hardware).
analyzing CPU 4:
  The governor "performance" may decide which speed to use
  current CPU frequency is 2.67 GHz (asserted by call to hardware).
analyzing CPU 5:
  The governor "performance" may decide which speed to use
  current CPU frequency is 1.60 GHz (asserted by call to hardware).
analyzing CPU 6:
  The governor "performance" may decide which speed to use
  current CPU frequency is 2.67 GHz (asserted by call to hardware).
analyzing CPU 7:
  The governor "performance" may decide which speed to use
  current CPU frequency is 2.67 GHz (asserted by call to hardware).</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/481800/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481805"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 15, 2012 23:24 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/481805/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think both statements are correct<br>
<p>
1. the linux scheduler expects all available CPUs to have the same performance characteristics<br>
<p>
and <br>
<p>
2. even on commodity systems this isn't the case already.<br>
<p>
ARM big.LITTLE is just a more extreme case of the existing problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481805/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor481815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 0:56 UTC (Thu)
                               by <b>rusty</b> (guest, #26)
                              [<a href="/Articles/481815/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's important to realize that the the A15 cores are likely heat-limited in a mobile device.  To paraphrase a conversation with Paul McKenney, the big cpus are like a sportscar you can rent for 3 seconds at a time :)<br>
<p>
Cheers,<br>
Rusty.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481835"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Short-term rental of sports cars</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 7:01 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/481835/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Perhaps a good analogy would be with the <a href="http://wikicars.org/en/Bugatti_Veyron">Bugatti Veyron</a>, which can generate more than 1,000 horsepower and reach speeds in excess of 400 kilometers per hour, but which when operated at full throttle will empty its fuel tank in about twelve minutes.

<p>Excessively high temperatures on the one hand, limited fuel tank on the other, but either way you go really fast for a very short time.  ;&ndash;)
      
          <div class="CommentReplyButton">
            <form action="/Articles/481835/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor481828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 4:01 UTC (Thu)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/481828/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This also complicates the "race to idle" issue even more than usual. Now, not only do we have the choice of variably clocking one CPU or set of CPUs, but a choice of an entirely different set to use!<br>
<p>
Determining where the [time x watts-per-instruction ] optimum is is even harder when you have two *different* curves for (instructions,power) x clock speed, one for the A7s and one for the A15s. Which will use more power for a given task - an A7 at full power, an A7 at half power, an A15 at full power or an A15 at half power? Is the task going to be short lived or long-running? Is it time critical or background/non-interactive? What is the user's preference about responsiveness vs power use?<br>
<p>
I can't help but think that apps are going to have to start giving the OS a lot more knowledge of what they're doing using hints to the scheduler. "This thread is doing periodic non-time-critical background work," "This thread is currently running a short job that must complete quickly," etc.<br>
<p>
How to make that accessible to high level app developers in a way they won't screw up is another thing entirely, too. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481834"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 7:06 UTC (Thu)
                               by <b>fredrik</b> (subscriber, #232)
                              [<a href="/Articles/481834/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In Android you already have a api that allows the application to indicate how important a background task is. You can tell the system to schedule background activities only when it is otherwise awake. And you can tell it to schedule activities inexactly, coordinated with being awake for other tasks. <br>
<p>
See the documentation for the AlarmManager and compare the flags RTC_WAKEUP vs RTC and methods setRepeating vs setInexactRepeating. <br>
<p>
<a href="http://developer.android.com/reference/android/app/AlarmManager.html">http://developer.android.com/reference/android/app/AlarmM...</a><br>
<p>
Now I don't know if these options are communicated all the way down to the kernel scheduler today. Though you could easily imagine a scheduler execute the inexact non-wakeup tasks on a low-power cpu, while executing tasks that are registered with the exact method and wakeup flag could be scheduled on a high-performance cpu.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481834/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481839"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 7:58 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/481839/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the linux kernel already has the ability to relax timing for wakeups so that they can be combined with other events.<br>
<p>
as for scheduling different types of tasks on different cores, unless the slow core is not fast enough to keep up with the running application, there's no reason to use the fast core at all.<br>
<p>
I can guarantee you that you cannot trust the application to tell you what it's needs really are, the only sane way is to watch the application and if it's trying to do more than the slow core can keep up with (with the other tasks that are also running), then and only then should you migrate it to a faster core.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481839/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor481891"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 13:39 UTC (Thu)
                               by <b>const-g</b> (guest, #5006)
                              [<a href="/Articles/481891/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
KISS principle should apply here.<br>
<p>
Let us consider:<br>
* ALL CPUs are visible<br>
* we have two CGROUPs (that set affinity among other things) -- one for cluster of "BIG" CPUs, one for cluster of "Little" CPUs<br>
* user-space policy (dynamic or static) sets which task/thread belongs to which group.<br>
* drivers decide statically where their interrupts run (on BIG or LITTLE CPUs) -- via affinity masks. This can be adjusted, (possibly event set to start with) from a user-space policy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481891/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor481959"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 19:09 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/481959/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you are still adding unneded complexity.<br>
<p>
if you have all the CPUs running, why do you care which CPU is running which process? The only reason to care would be if a process can't get it's work done on the slow CPU, and the answer to that is to have the scheduler consider this when re-balancing jobs between CPUs<br>
<p>
Similar statements can be made about interrupt handling. If both types of CPU can handle the interrupt, why do you care which one does it?<br>
<p>
Userspace can then control what CPUs are running, and if needed, can set affinity masks for interrupts and processes that it determines "need" to avoid the slow processors, but I really think that a slightly smarter rebalancing algorithm is the right answer in just about all cases.<br>
<p>
the rebalancing algorithm should already be looking at more than just the number of processes, it should be looking at how much time those processes are using, and it should be considering NUMA considerations as well. If you have two cores, one slow and one fast, both running the same load, the slow one will have a much higher utilization than the fast one, and so the fast one should end up pulling work from the slow one with the existing algorithm.<br>
<p>
There is one factor (which shows up in two aspects) that the current scheduler doesn't consider, which is the relative speed of the cores<br>
<p>
when pulling work to the slow cpu, it assumes that if it can run on the current cpu it can run on the new cpu, this needs a scaling check<br>
<p>
if the process is using 100% of a current cpu, it's not considered for being pulled to a new cpu on the assumption that it won't gain anything, this needs a scaling check to see if the new CPU is faster<br>
<p>
this is all 'slow path' checks in the scheduler rebalancing code, so it shouldn't be too bad.<br>
<p>
And as noted elsewhere, this is needed for current x86 multi-core systems because they can run different cores at different speeds.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/481959/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 16, 2012 21:45 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/482010/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess I'm saying that it doesn't seem as if the long-term scheduler changes are very significant, and as such I don't see a lot of value in producing such a short-term hack to deal with the issue.<br>
<p>
especially as the long term fix is needed to deal with shipping Intel/AMD x86 systems<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor482056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 5:06 UTC (Fri)
                               by <b>hamish</b> (subscriber, #6282)
                              [<a href="/Articles/482056/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This (very appealing) simplification doesn't take into account the race to completion - so you might end up using more total power staying on the slow cpu than would have been used up by bouncing the process to the fast cpu.<br>
<p>
I suppose a large part of this depends on the power usage profile of the two speed cpu's - if the power used by the slow cpu running at full speed is the same or less than the power used by the fast cpu (when the fast cpu is at a cpu freq that produces equivalent numbers of MIPS) then this pattern could be used.<br>
<p>
There still would need to be some way to work out that a process could benefit from a lower latency - and allow it to use the higher speeds available on the fast cpu.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 5:17 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/482058/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
right, but this sort of decision is too system specific to put into the kernel. Instead you want to have a userspace daemon decide what processors to use.<br>
<p>
If the load if heavy enough, you want to use every processing cycle you have available. If the load is a little lighter, you may turn off some of the slow cores to save power (if your "race to idle" logic applies to the use case and you really will go idle), let the load drop some more and you will want to turn on the slow cores and turn off a fast one, etc<br>
<p>
the possible combinations are staggering, and include user policy trade-offs that can get really ugly<br>
<p>
race-to-idle is not an absolute, it's an observation that at the current time, the power efficiency of CPUs is such that for a given core, you are more efficient to race-to-idle than to reduce your clock speed. But when you then compare separate cores with different design frequencies, the situation may be very different.<br>
<p>
remember that you can run a LOT of low-power cores for the same power as a single high-power core, enough that if your application can be parallelized well you are far better off with 100 100MHz cores than one 1GHz core, both in the amount of power used and the amount of processing you can do.<br>
<p>
race-to-idle also assumes that as soon as you finish the job you can shut down. This is very true in batch job situations, but most of the time you don't really go into your low-power mode immediatly, instead you run idle for a little bit, then shift to a lower power mode, wait some more, etc (and or much of this you keep the screen powered, etc), all these things need to be taken into consideration for a particular gadget when you are deciding what your best power strategy is going to be.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 6:29 UTC (Fri)
                               by <b>hamish</b> (subscriber, #6282)
                              [<a href="/Articles/482059/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be good to be able to have some generic logic available in the kernel - as a default, with knobs to take control from userspace if there is a policy daemon available.<br>
<p>
Perhaps something like a blending of the scheduler with a cpu-freq governor:<br>
A busy cpu is interpreted as a signal to increase the frequency, but if the frequency cannot be increased (due to big.LITTLE or a package power usage limitation, or something else I cannot envisage) but there are other cpus that have faster speeds still available then one (or more) processes can be selected to migrate cpus (but not necessarily all the processes from the slow cpu).  (And I have not thought about how to decide to migrate back to the slower cpu either ...)<br>
<p>
Obviously, this would not suit all workloads, but would provide a good starting point and seems like it could be of use in other asymmetric scenarios.<br>
<p>
Sure, race-to-idle is possibly only applicable to current hardware (and maybe only batch jobs), but I also think that similar principles are likely to apply to user-perceived latencies during interactive tasks - especially if you can powerdown what is likely to be a power hungry core and keep the residual activity running on the slow core.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor482189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 17, 2012 19:09 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/482189/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
in the existing scheduler, a busy core is a signal for other cores to pull load from it. Unless you have individual threads that max out the slow CPU, this should just work. This includes moving load to the slower cores.<br>
<p>
the userspace power management daemon should look at the load and make decisions on what cores to power up/down or speed up/slow down.<br>
<p>
Part of powering down a core is telling the system to pull all of the load from that core.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/482189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor483205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2012 9:44 UTC (Thu)
                               by <b>slashdot</b> (guest, #22014)
                              [<a href="/Articles/483205/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How about using the cpufreq algorithms, but applying them to the union of all CPUs in the system?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/483205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor483208"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2012 9:47 UTC (Thu)
                               by <b>slashdot</b> (guest, #22014)
                              [<a href="/Articles/483208/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(where obviously the "power states" would be A7-only, A15-only and A7+A15).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/483208/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor483210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2012 9:55 UTC (Thu)
                               by <b>slashdot</b> (guest, #22014)
                              [<a href="/Articles/483210/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And if you can really power up/down each core independently with power savings, then have (n + 1) * (n + 1) power states consisting of all #A7 ad #A15 combinations, sorted either by increasing total energy consumption or increasing total bogomips.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/483210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor483401"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 23, 2012 19:49 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/483401/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
there are corner cases that need to be figured out even with this model<br>
<p>
1. if you have a CPU hog, how well/poorly does it work if you have one core that is 2x (or 10x) the power of a different core? can your cpu hog get stuck on a slow core?<br>
<p>
2. how do you deal with software that will adapt to not having enough processor<br>
<p>
3. what about software that's constrained by memory bandwidth, not cpu cycles, it may be just as fast on a slow core as a fast one, but use 100% cpu in both cases (since CPU utilisation doesn't reflect time spent waiting for memory access)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/483401/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor501716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Linux support for ARM big.LITTLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2012 7:38 UTC (Wed)
                               by <b>revmischa</b> (guest, #74786)
                              [<a href="/Articles/501716/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Don't the CPUs have (slightly) different instruction sets and optimizations? Ideally, wouldn't software need to be compiled and optimized for both architectures?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/501716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
