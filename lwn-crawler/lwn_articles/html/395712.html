        <!DOCTYPE html>
        <html lang="en">
        <head><title>The USB composite framework [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/395712/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/395458/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/395712/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The USB composite framework</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="GAByline">
           <p>July 14, 2010</p>
           <p>This article was contributed by Michal "mina86" Nazarewicz</p>
           </div>
<p>
Linux is widely used in mobile devices, which should not come as a surprise.
It is a powerful and versatile system, and one of its strengths is its support
for USB devices of all kinds.  That includes "gadgets" &mdash; devices that act as
USB slaves &mdash; like USB flash drives (i.e. pendrives).  The USB
composite framework makes writing drivers for these kinds of devices
relatively easy. 

    <p>As users keep more data on their mobile devices, the demand for
    interoperability with desktop computers increases. No one wants to
    buy a special cable or a "docking station" just to copy a few
    photos. What users want is to connect the device via a USB cable
    and get it working out of the box. Linux can give that to
    them.</p>

    <p>Have you ever wondered how this actually works? What happens
    behind the scenes when a USB connection is established? Better yet,
    have you wondered how to write a USB gadget for your new and shiny
    embedded evaluation board?</p>

    <p>In this article, I will try to shed some light on that topic.


    <h4>USB overview</h4>

    <p>The Universal Serial Bus (or USB) standard defines
    a master-slave communication protocol.  This means that there is
    one control entity (a <dfn>master</dfn> or a <dfn>host</dfn>),
    which decides who can transmit data through the wire.  The other
    entities (<dfn>slaves</dfn>, <dfn>devices</dfn>, or
    <dfn>gadgets</dfn>) must obey and respond to the host's requests.
    Slaves do not communicate with each other.  A host is usually
    a desktop computer, while the gadgets are devices such as mice,
    keyboards, phones, printers, etc.</p>

    <p>People are used to seeing Linux systems in the master or host
    role on a USB bus.  But the Linux USB stack also provides support
    for the slave or gadget role &mdash; the device at the other end
    of the wire. For example, when one connects a pendrive to
    a Linux host, it handles it with a <a
    href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;f=drivers/usb/storage/usb.c;h=bbeeb92a213101d7eeab4314c91532da707247f7;hb=e40152ee1e1c7a63f4777791863215e3faa37a86">usb-storage</a>
    driver.  
    However, if we had a Linux machine with a USB Device Controller (or
    UDC), we could run Alan Stern's <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/file_storage.c;h=b49d86e3e45b639d2d3f4760d027e38a0fd52d44;hb=e40152ee1e1c7a63f4777791863215e3faa37a86">File
    Storage Gadget</a> (or FSG). FSG is, as its name implies, a gadget driver
    which implements the USB mass storage device class (or UMC).  That
    would allow the machine in question to act as a USB drive (aka pendrive).

    <p>When a device is connected, an <dfn>enumeration</dfn> process
    begins.  During this process, the device is assigned a unique
    7-bit identifier used for addressing.  As a consequence, up to 127
    slaves (including hubs) can be connected to a single host.</p>

    <p>Communication is based on logical <dfn>pipes</dfn> which join
    the master with one of a slave's <dfn>endpoints</dfn> (or
    <dfn><font class="SpellingError">EPs</font></dfn>).
    There can be up to 16 endpoints (numbered from 0
    to 15) on a device.  Endpoint zero (or <dfn>EP0</dfn>) is
    reserved for setup requests (eg. a query for descriptors,
    request to set a particular configuration, etc.).</p>

    <p>Pipes are unidirectional (one-way) and data can go to (via an
    <dfn>IN</dfn> endpoint) or from (via an <dfn>OUT</dfn> endpoint)
    the host.  (It is important to remember that from a slave's point
    of view, an IN endpoint is the one it writes to and an OUT
    endpoint is the one it reads from.)  There are also four transfer
    modes: bulk, isochronous, interrupt, and control.</p>

    <img src="https://static.lwn.net/images/2010/usb-gadget.png" hspace=3
    alt="[USB Gadget's descriptors structure]" align="right">

    <p>Endpoints are grouped into <dfn>interfaces</dfn> which are then
    grouped into <dfn>configurations</dfn>.  Different configurations
    may contain different interfaces, as well as have different power
    demands.  All that information is saved in various
    <dfn>descriptors</dfn> requested by the host during enumeration.
    One can see them using the <tt>lsusb</tt> tool.  Here is the stripped-down
    (and annotated) output for a Kingston pendrive:</p>

<pre id="lsusb">
    Bus 001 Device 004: ID 0951:1614 Kingston Technology
    Device Descriptor:
      idVendor           0x0951 Kingston Technology
      idProduct          0x1614
      bNumConfigurations      1     <i>[only one configuration]</i>
      Configuration Descriptor:     <i>[the first and only config]</i>
        bNumInterfaces          1   <i> [only one interface]</i>
        MaxPower              200mA
        Interface Descriptor:       <i> [the first and only intf.]</i>
          bNumEndpoints           2 <i>  [two endpoints]</i>
          bInterfaceClass         8 Mass Storage
          bInterfaceSubClass      6 SCSI
          bInterfaceProtocol     80 Bulk (Zip)
          Endpoint Descriptor:      <i>  [the first endpoint]</i>
            bEndpointAddress     0x81  EP 1 IN
            bmAttributes            2
              Transfer Type            Bulk
              Usage Type               Data
          Endpoint Descriptor:      <i>  [the second endpoint]</i>
            bEndpointAddress     0x02  EP 2 OUT
            bmAttributes            2
              Transfer Type            Bulk
              Usage Type               Data
</pre>

    <p>After the host receives the descriptors and learns what kind of
    a gadget has been connected, it can choose a configuration to be
    used and start communicating.  At most one configuration can be
    active at a time.</p>


    <h4>Linux USB composite framework</h4>

    <p>There is, however, another module that implements UMC: my <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/mass_storage.c;h=705cc1f76327c6cc953f4b2efcc6788a77ef760d;hb=e40152ee1e1c7a63f4777791863215e3faa37a86">Mass
    Storage Gadget</a> (or MSG).  The obvious question is, why there
    are two drivers that seem to do the very same thing.  This has
    something to do with the Linux USB composite framework.</p>

    <p>The "old way" of creating gadgets is to get the specification
    and implement everything as a single, monolithic module.  <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/zero.c;h=807280d069f96e815ea11c1eddddb29cbe6692fd;hb=e40152ee1e1c7a63f4777791863215e3faa37a86">Gadget
    Zero</a>, File Storage Gadget, and <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/inode.c;h=de8a83803505032542db52582f5258bdcb6473f1;hb=e40152ee1e1c7a63f4777791863215e3faa37a86">GadgetFS</a>
    are examples of such gadgets.</p>

    <p>This approach has two rather big disadvantages:</p>

    <ul>
      <li>many of the common USB functionalities (core device setup
      requests on EP0) have to be implemented in each and every
      module; and</li>
      <li>it can be tricky to combine the code from several gadgets into a
      new gadget with combined functionality.</li>
    </ul>

    <p>For those reasons, David Brownell came up with the <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=include/linux/usb/composite.h;h=738ea1a691cb8a5dab64d631792871273fd45053;hb=e40152ee1e1c7a63f4777791863215e3faa37a86"><dfn>composite
    framework</dfn></a> which has two advantages over the old
    approach:</p>

    <ul>
      <li>all of the core USB requests are implemented by the
      framework; and</li>
      <li>a single functionality or a <dfn>USB composite
      function</dfn> is developed separately from other
      functions as well as from the USB bus logic that is not directly related
      to this function.  Later, such functions are combined
      using the composite function to form a <dfn>composite
      gadget</dfn>.</li>
    </ul>

    <img src="https://static.lwn.net/images/2010/usb-composite-gadget.png"
    alt="[USB Composite Gadget's descriptors
    structure]" hspace=3 align="right">

    <p>From a composite gadget's perspective, a device has some
    functions grouped into configurations.  One function may be
    present in any number of configurations.  Each function may have
    several interfaces and other descriptors but that is transparent
    to the kernel module.</p>

    <p>Put on top of the "raw" USB descriptors structure, a USB
    composite function can be regarded as an abstraction for a group
    of interfaces.</p>

    <p>That is another excellent property of the framework &mdash;
    most implementation details are hidden "under the hood" and one
    does not need to think about them when developing a gadget.
    Instead of thinking about endpoints and interfaces, one thinks
    about functions. Therefore, FSG is a gadget developed in the "old way", whereas
    MSG is a composite gadget which uses only one composite function
    &mdash; the <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86">Mass
    Storage Function</a> (or MSF).
As a matter of fact, MSF has been created from FSG to allow for
    the creation of more complicated drivers that would have UMC as
    part of their functionality.</p>


    <h4>Overall driver structure</h4>

    <p>In this article, I will try to explain how to create a mass
    storage composite gadget.  It is in the kernel already,
    but let's forget that FSG and MSG exist for a moment.</p>

    <p>What is great about Linux, is that a lot has already been done
    and one can get results with relatively little effort.  As such,
    I will show how to create a working driver using MSF and some
    "composite glue".</p>

    <p>I will start with the structure of the <a
    href="http://lwn.net/Articles/395889/">module</a>, while skipping the details of the Mass
    Storage Function. The first step is to define a device descriptor.  It
    stores 
    some basic information about the gadget:</p>

<pre>
    static struct usb_device_descriptor msg_dev_desc = {
    	.bLength =		sizeof msg_dev_desc,
    	.bDescriptorType =	USB_DT_DEVICE,
    	.bcdUSB =		cpu_to_le16(0x0200),
    	.idVendor =		cpu_to_le16(FSG_VENDOR_ID),
    	.idProduct =		cpu_to_le16(FSG_PRODUCT_ID),
    };
</pre>

    <p>The <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=include/linux/usb/ch9.h;h=e58369ff8168b7a81058efa3b060a807284ff73f;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l217"><tt>usb_device_descriptor</tt>
    structure</a> has some more fields but they are not required or
    not important for our module.  What has been set is:</p>

    <dl>
      <dt><tt>bLength</tt> and <tt>bDescriptorType</tt></dt>
      <dd>A standard fields each descriptor has.</dd>

      <dt><tt>bsdUSB</tt></dt>
      <dd>The version of USB specification the device supports encoded
      in BCD (so <tt>0x200</tt> means <tt>2.00</tt>).</dd>

      <dt><tt>idVendor</tt> and <tt>idProduct</tt></dt>
      <dd>Each device must have a unique vendor and product
      identifier pair.  To avoid collisions, companies (vendors) can
      buy a vendor ID which gives them a namespace of 65536 product
      IDs to use.
      NetChip has donated some product IDs to the Linux community.
      Later, the Linux Foundation got the whole vendor ID for use
      with Linux.
      <a
      href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/storage_common.c;h=868d8ee86756671192a2fd1e93c866ae06121229;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l60"><tt>FSG_VENDOR_ID</tt></a>
      is actually NetChip's vendor ID and, along with
      <tt>FSG_PRODUCT_ID</tt>, that is what FSG uses.</dd>
    </dl>


    <p>The next step is to define an USB configuration which will be
    provided by the driver.  It is described by a <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=include/linux/usb/composite.h;h=738ea1a691cb8a5dab64d631792871273fd45053;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l157"><tt>usb_configuration</tt>
    structure</a> which, among other things, points to a <tt>bind</tt>
    callback function. Its purpose is to bind all USB composite functions
    to the configuration.  Usually, it is a simple function, as most of
    the job is done prior to its invocation.</p>

    <p>Put together it looks as follows:</p>

<pre id="msg_do_config">
    static struct usb_configuration msg_config = {
    	.label			= "Linux Mass Storage",
    	.bind			= msg_do_config,
    	.bConfigurationValue	= 1,
    	.bmAttributes		= USB_CONFIG_ATT_SELFPOWER,
    };

    static int __ref msg_do_config(struct usb_configuration *c)
    {
    	return <a href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l2968">fsg_add</a>(c->cdev, c, &amp;msg_fsg_common);
    }
</pre>

    <p>The <tt>msg_config</tt> object specifies a label (used for debug
    messages), the <tt>bind</tt> callback, configuration's number
    (each configuration must have a unique, non-zero number), and
    indicates that the device is self powered.  All that the
    <tt>msg_bind</tt> does is bind the MSF to the configuration.</p>


    <p>That definition is then used by the <tt>msg_bind()</tt> function,
    which is a callback to set up composite functions,
    prepare descriptors, add all configurations supported by the
    device, etc.:</p>

<pre id="msg_bind">
    static int __ref msg_bind(<a href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=include/linux/usb/composite.h;h=738ea1a691cb8a5dab64d631792871273fd45053;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l237">struct usb_composite_dev</a> *cdev)
    {
    	int ret;

    	ret = msg_fsg_init(cdev);
    	if (ret &lt; 0)
    		return ret;

    	ret = <a href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/composite.c;h=09289bb1e20fcf984b388b32f55a6c404cc1dcb3;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l469">usb_add_config</a>(cdev, &amp;msg_config);
    	if (ret >= 0)
    		set_bit(0, &amp;msg_registered);
    	<a href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l2660">fsg_common_put</a>(&amp;msg_fsg_common);
    	return ret;
    }
</pre>

The <tt>msg_bind()</tt> function does the following: initializes the Mass
      Storage Function, adds the previously defined configuration to the USB
      device, and (at the end) <i>puts</i> the <tt>msg_fsg_common</tt> object.
.     If everything succeeds, it sets the <tt>msg_registered</tt>
      flag so it is recorded that the gadget has been registered and
      initialized. 


    <p>With all of the above, a <dfn>composite device</dfn> can be
    defined.  For this purpose, the <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=include/linux/usb/composite.h;h=738ea1a691cb8a5dab64d631792871273fd45053;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l237"><tt>usb_composite_driver</tt>
    structure</a> is used.  Besides specifying the name, it points to
    the device descriptors and the bind callback:</p>

<pre>
    static <a href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=include/linux/usb/composite.h;h=738ea1a691cb8a5dab64d631792871273fd45053;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l237">struct usb_composite_driver</a> msg_device = {
    	.name		= "g_my_mass_storage",
    	.dev		= &amp;msg_dev_desc,
    	.bind		= msg_bind,
    };
</pre>


    <p>At this point, all that is left are the init and exit module
    functions:</p>

<pre>
    static int __init msg_init(void)
    {
    	return usb_composite_register(&amp;msg_device);
    }

    static void msg_exit(void)
    {
    	if (test_and_clear_bit(0, &amp;msg_registered))
    		usb_composite_unregister(&amp;msg_device);
    }
</pre>

    <p>They use the <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/composite.c;h=09289bb1e20fcf984b388b32f55a6c404cc1dcb3;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l1109"><tt>usb_composite_register()</tt></a>
    and <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/composite.c;h=09289bb1e20fcf984b388b32f55a6c404cc1dcb3;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l1138"><tt>usb_composite_unregister()</tt></a>
    functions to register and unregister the device.  The
    <tt>msg_registered</tt> variable is used to ensure the device is
    unregistered only once.</p>


    <p>To sum things up:</p>

    <ul>
      <li>A composite device (<tt>msg_device</tt>) is registered when
      in <tt>msg_init()</tt> when the module loads.</li>
      <li>It has a device <tt>bind</tt> callback (<tt>msg_bind()</tt>)
      that initializes MSF and adds configuration to the gadget.</li>
      <li>The configuration (<tt>msg_config</tt>) has its own
      <tt>bind</tt> callback (<tt>msg_do_config()</tt>), which binds MSF
      to the configuration.</li>
      <li>The really hard work is done inside the MSF.</li>
    </ul>


    <h4>Mass Storage Function</h4>

    <p>With the big picture in mind, lets get into the finer details: the
    inner workings of the Mass Storage Function.  There are a couple
    of things to watch out for when dealing with it.</p>

    <p>First of all, because MSF can be bound to several
    configurations, it needs to share some data between the instances
    and at the same time store information specific for each
    configuration.  The <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l318"><tt>fsg_common</tt>
    structure</a> is used for shared data.  An instance of this
    structure needs to be initialized prior to binding MSF.</p>

    <p>Because the common object is used by several MSF instances, it
    has no single owner thus a reference counter is needed to decide
    when it can be destroyed.  That's the reason for the <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l2660"><tt>fsg_common_put()</tt></a>
    call at the end of <a href="#msg_bind"><tt>msg_bind()</tt>
    function</a>.</p>

    <p>Closely connected with the <tt>fsg_common</tt> structure is
    a <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l2559">worker
    thread</a> which MSF uses to handle all the host's requests.  When
    a <tt>fsg_common</tt> object is created, a thread is started as well.
    It terminates either when the <tt>fsg_common</tt> object is
    destroyed or when it is killed with an INT, TERM, or KILL signal.
    In the latter case, the <tt>fsg_common</tt> object may still exist
    even after worker's death.  Whatever reason, when thread exits
    a <tt>thread_exits</tt> callback is invoked.</p>

    <p>It is important to note that a signal may terminate the worker
    thread, but why would one want to do that? The reason is simple.  As
    long as MSF is holding any open 
    files, the filesystems which those files belong to cannot be
    unmounted.  That is bad news for a shutdown script.</p>

    <p>What Alan Stern came up with in FSG, is to close all backing
    files when the worker thread receives an INT, TERM, or KILL signal.
    Because MSF is to be used with various composite gadgets, rather
    than hardcoding that behavior a callback has been introduced.</p>

    <p>The last thing to note is that MSF is customizable.  The UMC
    specification allows for a single device to have several
    <dfn>logical units</dfn> (sometimes called <dfn>LUNs</dfn>, which
    is strictly speaking incorrect since LUN stands for Logical Unit
    Number).  Each logical unit may be read-only or read-write, may emulate
    a CD-ROM or disk drive, and may be removable or not.</p>

    <p>All of this configuration must be specified when the
    <tt>fsg_common</tt> structure is initialized.  The <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l383"><tt>fsg_config</tt>
    structure</a> is used for exactly that purpose.  In most cases,
    a module author does not want to fill it themselves, but rather let
    a user of the module decide the settings.</p>

    <p>To make it as easy as possible, an <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l3010"><tt>fsg_module_parameters</tt>
    structure</a> and an <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l3033"><tt>FSG_MODULE_PARAMETERS()</tt>
    macro</a> are provided by the MSF.  The former stores
    user-supplied arguments, whereas the latter defines several module
    parameters.</p>

    <p>Having an <tt>fsg_module_parameters</tt> object, one may use <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l3048">fsg_config_from_params()</a>
    followed by <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l2666">fsg_common_init()</a>
    to create an <tt>fsg_common</tt> object.  Alternatively, <a
    href="http://git.kernel.org/?p=linux/kernel/git/hpa/linux-2.6-allstable.git;a=blob;f=drivers/usb/gadget/f_mass_storage.c;h=f4911c09022e92c2c16cc1b294045a56a0aca231;hb=e40152ee1e1c7a63f4777791863215e3faa37a86#l3084">fsg_common_from_params()</a>
    can be used which merges the call to the other two functions.</p>

    <p>Here is how it all works when put together:</p>

<pre>
    static struct fsg_module_parameters msg_mod_data = { .stall = 1 };
    FSG_MODULE_PARAMETERS(/* no prefix */, msg_mod_data);

    static struct fsg_common msg_fsg_common;

    static int msg_thread_exits(struct fsg_common *common)
    {
    	msg_exit();
    	return 0;
    }

    static int msg_fsg_init(struct usb_composite_dev *cdev)
    {
    	struct fsg_config config;
    	struct fsg_common *retp;

    	fsg_config_from_params(&amp;config, &amp;msg_mod_data);

    	config.thread_exits = msg_thread_exits;

    	retp = fsg_common_init(&amp;msg_fsg_common, cdev, &amp;config);
    	return IS_ERR(retp) ? PTR_ERR(retp) : 0;
    }
</pre>

    <p>The <tt>msg_exit()</tt> function has been chosen as MSF's
    <tt>thread_exits</tt> callback.  Since MSF is nonoperational after
    the thread has exited, there is no need to keep the composite
    device registered, instead the gadget is unregistered.</p>

    <p>At this point, it should become obvious why the
    <tt>msg_registered</tt> flag is being used.  Since
    <tt>usb_composite_unregister()</tt> can be called from two different
    places, a mechanism to guarantee that it will be called only once
    is needed &mdash; atomic bit operations are perfect for such
    tasks.</p>


    <p>And that would be it.  We are done.  One can grab <a
    href="http://lwn.net/Articles/395889/">the full source code</a> and start playing with
    it.</p>

    <p>The beauty of the composite framework is that all the really
    hard stuff has been already written.  One can write devices and
    experiment with different configurations without deep knowledge of
    the USB specification or the Linux gadget API.  At the same time,
    it is a perfect introduction to some more serious USB
    programming.</p>


    <h4>Running</h4>

    <p>To use the gadget, one needs to provide a disk image that will
    act as a real USB device to the USB host.  Using <tt>dd</tt> on
    the device is perfect for creating one:</p>

<pre>
    # <b>dd if=/dev/zero of=disk.img bs=1M count=64</b>
</pre>

    <p>With disk image in place, the module can be loaded:</p>

<pre>
    # <b>insmod g_my_mass.ko file=$PWD/disk.img</b>
</pre>

    <p>Connecting the device to the host should produce several
    messages in the host system log, among others:</p>

<pre>
    usb 1-4.4: new high speed USB device using ehci_hcd and address 8
    usb 1-4.4: New USB device found, idVendor=0525, idProduct=a4a5
    usb-storage: device scan complete
    sd 6:0:0:0: [sdb] Attached SCSI removable disk
    sd 6:0:0:0: [sdb] 131072 512-byte logical blocks: (67.1 MB/64.0 MiB)
     sdb: unknown partition table
</pre>

    <p>All that is left is creating a partition with a filesystem and
    starting using the pendrive:</p>

<pre>
    # <b>fdisk /dev/sdb</b>
    ...
    # <b>dmesg -c</b>
    sd 6:0:0:0: [sdb] Assuming drive cache: write through
     sdb: sdb1

    # <b>mkfs.vfat /dev/sdb1</b>
    mkfs.vfat 3.0.9 (31 Jan 2010)
    # <b>mount /dev/sdb1 /mnt/</b>
    # <b>touch /mnt/foo</b>
    # <b>umount /mnt</b>
</pre>

    <p>As has been shown, the gadget works like a charm.</p>

<h4>Conclusion</h4>

<p>
The Linux USB composite framework provides a way to add USB devices in a
fairly straightforward way.  Before the composite framework came along,
developers 
needed to implement all USB requests for each gadget they wanted to add to
the system.  The framework handles basic USB requests and separates each
USB composite function, which allows gadget authors to think in terms of
functions rather than low-level interfaces and communication handling.
<p>
As one might guess, this article just scratches the surface of what the
composite framework can do.  The driver that was shown is a
single-configuration, single-function gadget, so the advantages over
non-composite gadgets is not readily apparent.  A future article may look
at drivers for more powerful gadgets using the composite framework.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Device_drivers">Device drivers</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#USB">USB</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Nazarewicz_Michal_mina86">Nazarewicz, Michal “mina86”</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/395712/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor396099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2010 9:31 UTC (Thu)
                               by <b>linusw</b> (subscriber, #40300)
                              [<a href="/Articles/396099/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The first part of the article looks very inspired by the Wikipedia article on USB so why not link it:<br>
<a href="http://en.wikipedia.org/wiki/Universal_Serial_Bus">http://en.wikipedia.org/wiki/Universal_Serial_Bus</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor396168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2010 16:16 UTC (Thu)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/396168/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm finding this article very confusing. <br>
When you say things like "The really hard work is done inside the MSF", it sounds like you're talking about the fsg_* functions, which are separate (but mostly copied) from Alan Stern's FSG?  So a function like fsg_main_thread in f_mass_storage.c is part of MSF, but the function<br>
fsg_main_thread in file_storage.c is part of FSG?<br>
<p>
Having 5 ".c" files #included directly in "the full source code" doesn't help clarify things.  Doesn't that also cause symbol conflicts if we wanted to write two modules and install them both?<br>
<p>
I guess this article mostly is focused on how to use the composite framework, but the actual implementation of the device (MSF/FSG/whatever) seems to be the more interesting part from a USB driver writer point of view.  Does the composite framework make that part any easier?<br>
<p>
I'd really look forward to a future article on "more powerful gadgets" as you mention.  Particularly interesting would be how such a composite gadget is treated and works on typical operating systems (can each function usually be bound to a driver independently?) and how to deal with hardware limitations (as I understand, most hardware has various limitations on numbers of endpoints or restricts their sizes, etc).<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor396190"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2010 18:38 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/396190/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>I guess this article mostly is focused on how to use the composite framework, but the actual implementation of the device (MSF/FSG/whatever) seems to be the more interesting part from a USB driver writer point of view. Does the composite framework make that part any easier?</blockquote>

My impression is that the framework is not intended to make the interesting part any easier, but rather to make the uninteresting part trivial. Having written a USB gadget (not on Linux), I've found that handling EP0 is a big chunk of uninteresting code that needs to be correct and involves fiddly interactions with your drivers, in that you have to make sure that your driver, your descriptor as sent on EP0, and your hardware registers all agree on how the endpoints are configured, and weird things happen if they don't.

      
          <div class="CommentReplyButton">
            <form action="/Articles/396190/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor397304"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2010 11:49 UTC (Sun)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/397304/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I've mentioned, Mass Storage Function is merely a conversion of the File-Storage Gadget so most of the code in MSF is copied with modifications from FSG. As such, your understanding is correct, by MSF I mean all the functions in f_mass_storage.c as well as storage_common.c (the latter is code that is identical (or nearly identical) in both MSF and FSG).<br>
<p>
The prefix of the function names may be confusing. At one point I even wanted to use fsg_ for FSG stuff, msf_ for MSF stuff and stor_ for commons but Alan convinced my that it's too much hustle and modification not worth the effort. Hence, the fsg_ prefix stayed.<br>
<p>
<p>
As far as including .c files... to be honest, I'm not entirely convinced why this is done this way but that's the way it is done in other composite gadget drivers as well.  The comment you may find in those is:<br>
<p>
<font class="QuotedText">&gt; Kbuild is not very cooperative with respect to linking separately compiled library objects into one module.  So for now we won't use separate compilation ... ensuring init/exit sections work to shrink the runtime footprint, and giving us at least some parts of what a "gcc --combine ... part1.c part2.c part3.c ... " build would.</font><br>
<p>
<p>
Going further in your comment, the situation with composite is just like iabervon described. It makes uninteresting things trivial. I would also add that it makes the more interesting part a bit harder.<br>
<p>
This is because composite function has to worry about registering interface and string IDs and never knows in how many configurations it will be present or ever how many configurations gadget has.<br>
<p>
One of the most complicated thing about converting File-Storage Gadget to Mass Storage Function was to allow for it to be added to several USB configurations. To achieve that I have created the fsg_common structure with reference counting and some such.<br>
<p>
<p>
As of next articles I can only thank you for interest and get back to work. ;) Nonetheless, the my next article probably won't cover most of your questions but should be valuable addition to this one.<br>
<p>
I may only quickly point out that you deal with hardware limitations by obeying them. :P If your UDC has limited number of endpoints you won't be able to stash many composite functions in a single configuration in your gadget. Mass storage is rather simple since in bulk-only mode (the one implemented by MSF) it uses only one IN and one OUT endpoint but generally functions may need more endpoints.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/397304/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor396238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2010 4:38 UTC (Fri)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/396238/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be great to be able to modprobe a mass-storage gadget, a serial gadget and a network gadget and a userland gadget and instantly get a composite device that supports all four.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor397306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2010 11:53 UTC (Sun)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/397306/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yep! It would.<br>
<p>
As a matter of fact, I've been thinking about something like that for quite some time now (ever since I've started working on USB gadgets I think). I also have some ideas regarding such functionality.<br>
<p>
I was thinking more along the lines that you modprobe a stub gadget which merely describes what configurations it want to support and then modprobe all the functions. In essence that's what you've described.<br>
<p>
I hope to find time for actually implementing it so maybe it'll be even easier then before to write gadgets. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/397306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor432551"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2011 21:35 UTC (Wed)
                               by <b>spectrum</b> (guest, #73494)
                              [<a href="/Articles/432551/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would like to create a USB composite driver that has functionalities of both file storage gadget and RNDIS gadget. <br>
<p>
Is this possible?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/432551/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor521883"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2012 20:12 UTC (Mon)
                               by <b>DABraun</b> (guest, #39500)
                              [<a href="/Articles/521883/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I just ran across this article and tried to follow the link to your Mass Storage Gadget. It's broken. Is the source still available somewhere?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521883/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521974"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 29, 2012 21:03 UTC (Mon)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/521974/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Look at the link: it's just drivers/usb/gadget/mass_storage.c in the kernel.  In Linus's tree, it would be <a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=blob;f=drivers/usb/gadget/mass_storage.c">here</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/521974/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor522982"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2012 20:40 UTC (Mon)
                               by <b>DABraun</b> (guest, #39500)
                              [<a href="/Articles/522982/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah - didn't see the path - thanks<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/522982/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor522983"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2012 22:58 UTC (Mon)
                               by <b>DABraun</b> (guest, #39500)
                              [<a href="/Articles/522983/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What is it about the Device Descriptor that makes it a composite device?<br>
<p>
I created one of your composite devices on a Freescale based embedded system and looked at the device descriptor on the host (Windows) side and there are a number of "Unknown Descriptors" looking like<br>
  Unknown Descriptor:<br>
  bDescriptorType:      0x24<br>
  bLength:              0x05<br>
  05 24 00 10 01 <br>
(this is from MS usbview.exe utility)<br>
What are these? The descriptor type 0x24 is from the USB 3 spec and is called "USB_DT_PIPE_USAGE" - I searched for this in the 2.6.29.4 sources and couldn't find any references. This leads me to think some trash has been included in the device decriptors. But then again I could have missed something.<br>
<p>
Any ideas?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/522983/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor523011"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 5, 2012 23:48 UTC (Mon)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/523011/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think USB_DT_PIPE_USAGE is related to UAS (USB Attached SCSI).  Maybe "lsusb -vvv" on a Linux host can parse the descriptor better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/523011/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor651875"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2015 17:51 UTC (Tue)
                               by <b>sebastien536</b> (guest, #103603)
                              [<a href="/Articles/651875/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hello !<br>
I wonder something about USB composite devices. What's the point of using a USB composite driver instead of modprobing several USB drivers ? If we just pay attention that each USB drivers has a different major number, we will be able to modprobe them one by one isnt it ? Or am I wrong ?<br>
 <br>
Thanks in advance for your answers <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651875/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor651936"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The USB composite framework</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2015 9:33 UTC (Wed)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/651936/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This framework is for gadget drivers.<br>
<p>
Loading the drivers one after the other would modify the device's descriptors, which would require a reset to tell the host about the changes.<br>
In any case, even supposedly independet interfaces need to coordinate with each other because they share interface/endpoint/string numbers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/651936/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2010, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
