        <!DOCTYPE html>
        <html lang="en">
        <head><title>User-managed concurrency groups [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/879398/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/879698/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/879398/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>User-managed concurrency groups</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>December 28, 2021</br>
           </div>
The kernel's thread model is relatively straightforward and performs
reasonably well, but that's not enough for all users.  Specifically, there
are use cases out there that benefit from a lightweight threading model
that gives user space control over scheduling decisions.  Back in May 2021,
Peter Oskolkov posted a patch set implementing an abstraction known as <a
href="/ml/linux-kernel/20210520183614.1227046-1-posk@google.com/">user-managed
concurrency groups</a>, or UMCG.  Several revisions later, many observers
still lack a clear idea of what this patch is supposed to do, much less
whether it is a good idea for the kernel.  Things have taken a turn,
though, with Peter Zijlstra's <a
href="/ml/linux-kernel/20211214204445.665580974@infradead.org/">reimplementation
of UMCG</a>.
<p>
One developer reimplementing another's patch set is likely to raise
eyebrows.  Zijlstra's motivation for doing that work can perhaps be seen in
<a
href="/ml/linux-kernel/20211215222524.GH16608%40worktop.programming.kicks-ass.net/">this
message</a>, where he notes that the UMCG code looked little like the rest
of the scheduler code.  He also remarked that it required "<q>reverse
engineering</q>" to figure out how UMCG was meant to be used.  By the
time that work was done, perhaps, it was just easier to recast the code in
the form he thought it should take.

<p>
In truth, the documentation for UMCG is no better than before — a
significant problem for a major proposed addition to the system-call API.
But it is possible to dig through the code (and a "<q>pretty
rough</q>" <a
href="/ml/linux-kernel/20211214210016.GD16608@worktop.programming.kicks-ass.net/">test
application</a> posted by Zijlstra) to get a sense for what is going on.
In short, UMCG calls for a multi-threaded application to divide itself into
"server" and "worker" threads, where there is likely to be one server
thread for each CPU on the system.  Server threads make scheduling
decisions, while workers run according to those decisions and get the
actual work done.  The advantage of a system like UMCG
 is that scheduling can happen quickly and with little overhead
from the kernel — assuming the server threads are properly implemented, of
course.
<p>
<h4>Setting up</h4>
<p>
UMCG introduces three new system calls and one new structure that handles
most of the communication with the kernel.  Every thread participating in
UMCG must have a <tt>umcg_task</tt> structure, which looks like this:
<p>
<pre>
    struct umcg_task {
	__u32	state;
	__u32	next_tid;
	__u32	server_tid;
	__u64	runnable_workers_ptr;
	/* ... */
    };
</pre>
<p>
Some fields have been omitted here.  Note that this structure, as
it will eventually be provided by the C libraries, is likely to look
different.  The specific fields will be discussed as they become relevant.
<p>
The first new system call is <tt>umcg_ctl()</tt>, which is used to register
and unregister threads with the UMCG subsystem:
<p>
<pre>
    int umcg_ctl(unsigned int flags, struct umcg_task *self, clockid_t which_clock);
</pre>
<p>
The <tt>flags</tt> argument describes the operation to be performed,
<tt>self</tt> is the <tt>umcg_task</tt> structure corresponding to the
current thread, and <tt>which_clock</tt> controls the clock used for
timestamps for this thread.
<p>
If <tt>flags</tt> contains <tt>UMCG_CTL_REGISTER</tt>, then this call is
registering a new thread with the subsystem.  There are two alternatives,
depending on which type of thread is being registered:
<p>
<ul class="spacylist">
<li> If <tt>flags</tt> contains <tt>UMCG_CTL_WORKER</tt>, then this is
     a new worker task.  In this case, <tt>self-&gt;state</tt> must be
     <tt>UMCG_TASK_BLOCKED</tt>, indicating that the worker is not
     initially running.  The thread ID of the server that will handle this
     worker must be provided in <tt>server_tid</tt>.
<li> Otherwise, this is a server task.  Its initial state must be
     <tt>UMCG_TASK_RUNNING</tt> (since it is indeed running) and
     <tt>server_tid</tt> must be the calling thread's ID.
</ul>
<p>
Workers and servers must be threads of the same process (more specifically,
they must share the same address space).
The system call returns zero if all goes well.  For workers, though, that
return will be delayed, as the calling thread will be blocked until the
server schedules it to run.  Registering a new worker will cause the
indicated server to wake up.
<p>
The other thing that happens when a worker is registered is that its state
is set to <tt>UMCG_TASK_RUNNABLE</tt> and it is added to the server's
singly-linked list of available workers.  The list is implemented using the
<tt>runnable_workers_ptr</tt> field in each task's <tt>umcg_task</tt>
structure.  The kernel will push a new task onto the head of the list with
a compare-and-exchange operation; the server will normally use a similar
operation to take tasks off the list.
<p>
<h4>Scheduling</h4>
<p>
Most scheduling is done with calls to <tt>umcg_wait()</tt>:
<p>
<pre>
    int umcg_wait(unsigned int flags, unsigned long timeout);
</pre>
<p>
The <tt>flags</tt> field must be zero in the current patches.  The calling
thread must be registered as a UMCG thread or the call will fail.  If the
caller is a worker thread, the <tt>timeout</tt> must also be zero; this
call will suspend execution of the worker and wake the associated server
process for the next scheduling decision.  If the worker's state is
<tt>UMCG_TASK_RUNNING</tt> (as it should be if the task is running to make
this call), it will be set back to <tt>UMCG_TASK_RUNNABLE</tt> and the task
will be added to the server's <tt>runnable_workers_ptr</tt> list.  Thus,
for a worker task, a call to <tt>umcg_wait()</tt> is a way to yield to
another thread while remaining runnable.
<p>
In the case of the server, the usual reason for calling
<tt>umcg_wait()</tt> is to schedule a new worker to run; this is done by
setting the worker's thread ID in the <tt>next_tid</tt> field of the
server's <tt>umcg_task</tt> structure before the call.  If this is done,
and the indicated thread is a UMCG worker in the
<tt>UMCG_TASK_RUNNABLE</tt> state, it will be queued to run.  The server,
instead, will be blocked until either some sort of wakeup event happens
or the specified <tt>timeout</tt> (if it is not zero) expires.
<p>
One important detail is that the kernel, once it successfully wakes the new
worker thread, will set the server's <tt>next_tid</tt> field to zero.  That
allows the server to quickly check, on return from <tt>umcg_wait()</tt>,
whether the thread was actually scheduled or not.
<p>
There are a few events that will cause a server to wake.  If the current
running worker blocks in a system call, for example, its state will be
changed to <tt>UMCG_TASK_BLOCKED</tt>; the server can detect this by
looking at the (previously) running worker's <tt>umcg_task</tt> structure.
As noted above, a new task becoming runnable will cause a wakeup.  If your
editor's reading of the code is correct, there does not currently appear to
be a way to notify the server that a worker task has exited entirely.
<p>
<h4>Preemption</h4>
<p>
The <tt>timeout</tt> parameter to <tt>umcg_wait()</tt>  can be
used by server threads to implement forced preemption after a worker has
run for a period of 
time.  If <tt>umcg_wait()</tt> returns <tt>ETIMEDOUT</tt>, the server knows
that the current worker has been running for the full timeout period; the
server may then choose to make it surrender the CPU.  That is done in a
two-step process, the first of which is to add the <tt>UMCG_TF_PREEMPT</tt>
flag to the running worker's <tt>state</tt> field (again, using a
compare-and-exchange operation).  Then a call should be made to the third
new system call:
<p>
<pre>
    int umcg_kick(unsigned int flags, pid_t tid);
</pre>
<p>
Where <tt>flags</tt> must be zero and <tt>tid</tt> is the thread ID of the
worker to be preempted.  This call will cause the worker to re-enter the
scheduler, at which point the <tt>UMCG_TF_PREEMPT</tt> flag will be
noticed, the worker will be suspended, and it will be placed back onto the
server's <tt>runnable_workers_ptr</tt> list.  Once that completes, the
server will wake again to schedule a new thread.
<p>
That is pretty much the entirety of the new API at this point.  This work
is still clearly in an early state, though, and it would not be surprising
to see a fair amount of evolution take place before it is considered for
merging.  UMCG arises out of Google's internal systems and reflects its use
case, but there will almost certainly be other use cases for this sort of
functionality, and those users have not yet made their needs known.  As
awareness of this work spreads, that situation can be expected to change.
<p>
Oskolkov, meanwhile has, as one might expect, <a
href="/ml/linux-kernel/CAFTs51Xb6m=htpWsVk577n-h_pRCpqRcBg6-OhBav8OadikHkw@mail.gmail.com/">required
some convincing</a> that his work really needed to be rewritten by somebody
else or that the new implementation is better.  He <a
href="/ml/linux-kernel/CAPNVh5fenLG7uvdF1tjyfcOe8Ff3_L0-UqeCu9=tn-NMaJ3ikA@mail.gmail.com/">expressed</a>
discomfort with some of the changes, most notably Zijlstra's switch from a
single queue of runnable workers to per-server queues.  In the end, though,
he said "<q>I'm OK with having it your way if all needed features are
covered</q>".  So it seems fair to assume that Zijlstra's patch reflects
the future of this work.  Time will tell where it goes from here.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Scheduler-User-managed_concurrency_groups">Scheduler/User-managed concurrency groups</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#User-managed_concurrency_groups">User-managed concurrency groups</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/879398/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor879960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 28, 2021 16:01 UTC (Tue)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/879960/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Anyone else reading this and thinking of Cilk?  The mapping from multi-queue to a single-queue idea is through work stealing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/879960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor879964"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 28, 2021 16:45 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/879964/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I find it really strange that word “fiber” is never mentioned in the context of these patchsets. Even if it's clearly mentioned <a href="https://lwn.net/ml/linux-kernel/20210520183614.1227046-1-posk@google.com/">in the very first message</a>.</p>

<p>Basically the whole things, it seems, rests on the following observation: Windows <a href="https://devblogs.microsoft.com/oldnewthing/20211217-00/?p=106040">reserves 12KiB of of stack</a> for the “Stack Overflow” exception handling — but that's not needed on GNU/Linux and you may use that same amount of memory to equip each fiber with it's own, personal, thread (8KiB in kernel + 4KiB in GLibC).</p>

<p>Add couple of syscalls and now you have <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/fibers">fibers</a> which are full-blown threads so they can be used with tools which are used for threads, there are no need for special “fibers” API (like <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-getfiberdata">GetFiberData</a>) and so on.</p>

<p>They are probably still a tiny bit heavier than purely-userspace fibers, but advantage sounds really compelling: no need to use onlyh fiber-aware libraries, etc… I guess there should be some experience with Windows Fibers which would be relevant when this patchset is considered.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/879964/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor879967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 28, 2021 16:51 UTC (Tue)
                               by <b>ms</b> (subscriber, #41272)
                              [<a href="/Articles/879967/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This feels a lot like green threads, which a lot of languages have, e.g. Go, Erlang. My question is how can it help, getting the kernel involved? I&#x27;ve sometimes read one of the reasons green threads have fast context switching is because the kernel isn&#x27;t involved. About the only reason I can think of is you&#x27;d gain pre-emptive eviction, which is not nothing, but I&#x27;m curious if it&#x27;s worth it, or if there are other benefits too?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/879967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor879968"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 28, 2021 17:11 UTC (Tue)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/879968/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; I've sometimes read one of the reasons green threads have fast context switching is because the kernel isn't involved.</font>

<p>Switching to kernel and back is not that slow (even green threads do syscalls). What's slow is waiting for next thread to be scheduled by kernel to become executable.</p>

<font class="QuotedText">&gt; My question is how can it help, getting the kernel involved?</font>

<p>Basically a band-aid for the fact that many years ago GNU/Linux rejected <a href="https://lwn.net/Articles/10741/">NGPT and went with NPTL</a>.</p>

<p>If you allocate, essentially, a dedicated kernel thread for your “green thread” then you may use all syscalls and libraries which are allowed for regular threads: parts of the program where “green threads” are cooperating would work like proper “green threads”, but if you call some “heavy” function the instead of freezing your whole “green thread” machinery you would just get one-time hit when kernel would save your beacon and would give you a chance to remove misbehaving  “green thread” from the cooperating pool.</p>

<font class="QuotedText">&gt; About the only reason I can think of is you'd gain pre-emptive eviction, which is not nothing, but I'm curious if it's worth it, or if there are other benefits too?</font>

<p>Proper TLS area is another benefit. In systems where (like in Windows) fibers (AKA “green threads”) their own <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/nf-winnt-getfiberdata">private storage</a> but share TLS for “kernel threads” it's much easier to mess things up.</p>

<p>Of course <b>that one</b> is possible without kernel help, but you get it for free if you use kernel thread machinery as “safety net” for misbehaving fibers.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/879968/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor880016"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 29, 2021 22:39 UTC (Wed)
                               by <b>nksingh</b> (subscriber, #94354)
                              [<a href="/Articles/880016/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This mechanism and the very similar Windows UMS one which was added in 2009 and ripped out in 2020 help userspace control thread scheduling in the face of arbitrary system calls with arbitrary blocking.  <br>
<p>
With traditional M:N scheduling like fibers, if the user threaded code blocks, no code in the app gets control to choose what&#x27;s going to run next, unless the blocking is going through the userspace threading library.  This is a major part of the reason that Go or LibUV wrap all of the IO calls, so that they can control their green thread scheduling.<br>
<p>
UMS allows such a runtime to effectively get a callback to decide what to do next (e.g. schedule a new lightweight task) when something blocks.  This is a great idea if you have a set of syscalls from your task that may or may not block in an unpredictable manner, like a read from the pagecache where you don&#x27;t know if you&#x27;ll miss.  You can be optimistic, knowing that you&#x27;ll get a callback if something goes wrong.<br>
<p>
However using this mechanism requires some significant investment in the language ecosystem, like has been done with GoRoutines.  And I don&#x27;t think there&#x27;s a massive performance uplift in the best of cases, but perhaps Google has measured something worthwhile in their workloads.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880016/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880017"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 29, 2021 22:43 UTC (Wed)
                               by <b>nksingh</b> (subscriber, #94354)
                              [<a href="/Articles/880017/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here&#x27;s the paper from the early 90s, where this idea was introduced:<br>
<a href="https://dl.acm.org/doi/abs/10.1145/146941.146944">https://dl.acm.org/doi/abs/10.1145/146941.146944</a><br>
<p>
It&#x27;s not clear that the premises have aged well, since threads are quite popular and do actually perform well enough. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880017/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor880018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 29, 2021 23:08 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/880018/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However using this mechanism requires some significant investment in the language ecosystem, like has been done with GoRoutines</font><br>
<p>
This kind of scheduling is not very useful for Go, because it needs to manage stacks for goroutines. Basically, Go reuses a pool of system threads, switching the current stack when needed instead of just letting the thread go to sleep.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880019"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 29, 2021 23:49 UTC (Wed)
                               by <b>nksingh</b> (subscriber, #94354)
                              [<a href="/Articles/880019/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it still helps because Go can&#x27;t always control all sources of blocking.  Think for instance about a pagefault.  Being able to switch stacks and TLS vectors in usermode is independent of being able to know about all sources of blocking.  If the go runtime gets the scheduled activation due to blocking, it can grab another system thread to run any remaining runnable goroutines immediately, rather than waiting for another thread to wake up and notice the blockage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880019/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880071"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2021 10:51 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/880071/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  I think it still helps because Go can&#x27;t always control all sources of blocking. </font><br>
<p>
It doesn&#x27;t really need to. <br>
<p>
If a goroutine blocks for some unforeseen reason (because the underlying physical thread is processing a signal, for example), then the queued work (goroutines ready to run) associated with the physical thread will be &quot;stolen&quot; by other threads.<br>
<p>
Additionally, if the goroutine got blocked inside a syscall or a C library call, it won&#x27;t be counted towards GOMAXPROCS limit, so the Go scheduler will be able to launch a new thread to replace the blocked one.<br>
<p>
It&#x27;s theoretically possible to have a situation where all threads are blocked for some reason, but I can&#x27;t think of a reason why.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880071/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880101"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2021 16:11 UTC (Fri)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/880101/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The mechanism go uses for this today is ugly. It must surround every syscall which might block with &quot;entersyscall&quot;/&quot;exitsyscall&quot;. &quot;Enter&quot; effectively sets a timer -- if &quot;exit&quot; isn&#x27;t reached within 20μs and there are runnable goroutines waiting, it&#x27;s assumed that the syscall blocked and an additional OS thread should be started/resumed to allow one of those other goroutines to run.<br>
<p>
Yet, a syscall could take longer than that on-cpu (without blocking), in which case you&#x27;ve over-scheduled work vs number of cpus. Alternately, a syscall might block immediately, in which case you&#x27;ve wasted time, where you could&#x27;ve run another goroutine.<br>
<p>
To ameliorate those issues in common cases, there&#x27;s two other variants of syscall entry, one for invoking a syscall that &quot;never&quot; blocks, and another for syscalls that are considered to very likely immediately block, which resumes another goroutine immediately.)<br>
<p>
This mechanism clearly works, but it really doesn&#x27;t seem ideal. If the kernel could, instead, notify the go scheduler when a thread has blocked, all this guessing and heuristics could be eliminated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880101/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2021 22:47 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/880123/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This mechanism clearly works, but it really doesn&#x27;t seem ideal. If the kernel could, instead, notify the go scheduler when a thread has blocked, all this guessing and heuristics could be eliminated.</font><br>
<p>
I&#x27;m not sure if it would help. You still need a scheduler thread and checking for a stuck thread right now is pretty fast. I guess one thing that might be helpful is ability to force-preempt threads. Right now Go uses signals for that, and signals have their drawbacks.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor879974"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 28, 2021 23:30 UTC (Tue)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/879974/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Windows introduced User Mode Scheduling as a similar feature in Windows 7 I believe. It’s purpose is to overcome the issue with fibres caused by a lot of Windows Kernel APIs are thread identity dependent in some way. I have no idea how widespread it’s use is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/879974/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 29, 2021 22:24 UTC (Wed)
                               by <b>nksingh</b> (subscriber, #94354)
                              [<a href="/Articles/880015/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
UMS was recently ripped out of Windows due to lack of usage.  This new Linux mechanism is extremely similar to the Windows one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880048"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 30, 2021 18:24 UTC (Thu)
                               by <b>glenn</b> (subscriber, #102223)
                              [<a href="/Articles/880048/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It could be quite challenging for applications to code against this API.  A popular userspace library on top of it would help facilitate adoption.  A Cilk runtime, as ejr calls out, might be a good fit.  Unfortunately, the framework&#x27;s recent advocate, Intel, appears to have given up on it.  Cilk support has also been dropped from gcc8.<br>
<p>
What kind of ecosystem grew up around the Windows framework?  Did it fail despite an ecosystem?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880048/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 30, 2021 19:26 UTC (Thu)
                               by <b>nksingh</b> (subscriber, #94354)
                              [<a href="/Articles/880050/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There was concrt and SQL server.  SQL didn&#x27;t see that big gains for their usecase at the time and concrt wasn&#x27;t heavily adopted.<br>
<p>
This was way before nodejs and Go and the dotnet tasking and async library was still in it&#x27;s infancy. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880051"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 30, 2021 19:27 UTC (Thu)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/880051/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Concrt removed support from UMS pretty quickly. They found no significant performance boost in their use cases as well. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880051/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor880056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 30, 2021 22:21 UTC (Thu)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/880056/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Merely pining for the fjords: <a href="https://cilk.mit.edu/">https://cilk.mit.edu/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor879985"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 29, 2021 14:18 UTC (Wed)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/879985/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Waaait... No ebpf involved??<br>
<p>
(But seriously, doesn&#x27;t making a scheduling decision like this feel like the perfect use case for it?)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/879985/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor880026"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 30, 2021 13:21 UTC (Thu)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/880026/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This seems like the kind of feature one platform adds and then nobody uses it because they all need to support half a dozen platforms which don&#x27;t have anything similar and you would have to restructure your entire application architecture to make use of it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880026/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2021 2:02 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/880062/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The same could be said of io_uring, at least prior to Microsoft&#x27;s clone--https://windows-internals.com/ioring-vs-io_uring-a-comparison-of-windows-and-linux-implementations/. (Also, to be fair, io_uring is easier to implement as a compatibility library given the lack of a need to shim old syscalls. Still need to rearchitect applications, though.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor880108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2021 17:58 UTC (Fri)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/880108/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a serious question, but are there really any other server platforms besides Linux used in the real world anymore? At a scale that matters? If so, are there a half dozen?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2022 11:16 UTC (Mon)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/880210/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Windows is highly relevant as a server platform.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880238"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2022 14:37 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/880238/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not really. It&#x27;s been relegated to a few legacy areas (AD controllers, Exchange servers, etc.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880238/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor880164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 2, 2022 18:15 UTC (Sun)
                               by <b>thoughtpolice</b> (subscriber, #87455)
                              [<a href="/Articles/880164/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is that really unusual? Linux has tons of functionality that is (broadly speaking) most useful to e.g. service providers or other specialized use cases. People who write cross platform &quot;systems&quot; applications that will utilize this have already had to support/architect their applications to work across broad environments for many years, this is just One More Thing, like io_uring or sandboxing or what have you. The average bog standard utility will probably keep getting written in Python or whatever so it doesn&#x27;t matter honestly.<br>
<p>
In fact, part of the reason this work is useful is because it actually allows *more* code reuse than alternative options on Linux when you want finer control over the scheduling policy — libraries no longer need to be fiber/user-mode thread aware — the alternatives also require restructuring your applications anyway...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor880177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 2, 2022 23:26 UTC (Sun)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/880177/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That could be said about e.g. user-mode network stacks. I don&#x27;t get the point myself but people are evidently getting enough mileage out of that to justify having it in Linux.<br>
<p>
Sometimes you can&#x27;t scale vertically with faster hardware or horizontally with more hardware (especially in present times), and then the only option left is to scale inwards by re-examining old software assumptions. Or scaling backwards, by asking for less - but that doesn&#x27;t lead to cool hacks...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880178"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 2, 2022 23:29 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/880178/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or look back in time for a better solution that&#x27;s been forgotten in all the hype about &quot;new!&quot; &quot;shiny!&quot; (don&#x27;t get me started!).<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880178/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor880066"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 31, 2021 3:13 UTC (Fri)
                               by <b>Ptolemy</b> (subscriber, #153718)
                              [<a href="/Articles/880066/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The restriction that usersapce can only manage threads in the same process strictly conforms to the definition of M:N threading. However, for practical purposes, why not consider cross process thread management? In other words, in userspace, one process can control the scheduling of another process.<br>
Didn&#x27;t the previous BPF hook also consider exposing the scheduling capability of the kernel to the userspace? Therefore, this is a good opportunity to extend the kernel scheduling, so that the kernel can support the user-defined scheduling algorithm or scheduling strategy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880066/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor880145"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 1, 2022 23:59 UTC (Sat)
                               by <b>alkbyby</b> (subscriber, #61687)
                              [<a href="/Articles/880145/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, I think what is needed most is someone from Google fibers team perhaps with help of some writer experts to post in-depth description of how this will be used. Otherwise people get all kinds of ideas.<br>
<p>
Indeed, this is basically an attempt to implement go-style &quot;cheap&quot; concurrency in C setting. With few twists.<br>
<p>
There is video from 2013 LPC conference with some background: <a href="https://www.youtube.com/watch?v=KXuZi9aeGTw">https://www.youtube.com/watch?v=KXuZi9aeGTw</a>. Slides are sadly gone. (<a href="https://blog.linuxplumbersconf.org/2013/ocw/system/presentations/1653/original/LPC%20-%20User%20Threading.pdf">https://blog.linuxplumbersconf.org/2013/ocw/system/presen...</a> linked from <a href="https://blog.linuxplumbersconf.org/2013/ocw/events/LPC2013/schedule">https://blog.linuxplumbersconf.org/2013/ocw/events/LPC201...</a>)<br>
<p>
First, fibers (equivalent of goroutines) are regular posix threads. I.e. all the usual stuff various C codes are used to do, like calling gettid, sending signals, finding all threads via procfs (i.e. GC implementations do that and send signals), all works as before. And gdb will see all the fibers too as threads without any special modifications. And core dumps have all fibers stack traces present too in usual way. This also implies all the thread local storage works as usual.<br>
<p>
Second, it provides userspace with ability to schedule CPU time itself, which also includes ability to limit actual parallelism in some cases. Some of it is cheapness of scheduling itself. Linux kernel scheduler has to do all kinds of heurstics which cost CPU cycles and not always are useful. Paul&#x27;s presentation in 2013 has lots on this (of course this days syscalls are not cheap anymore after all the security crap, but there is hope that madness will end with time). Some of it is limiting actual parallelism in order to help caching effects. I.e. when you have thread/fiber/goroutine-per-request model, you often do stuff like sending RPCs to your backends. Concurrently. So with &quot;child&quot; fibers. And those child fibers not bouncing around all the hundreds of cores we have this days helps efficiency a lot. There are other uses too, so IMHO whoever represents google in discussion should post decent list with specific examples and numbers when possible. Otherwise people should/will ask why not simply make kernel scheduler cheap and &quot;right&quot; enough.<br>
<p>
And third, there is this essentially scheduler activations implementation to deal with fibers blocking inside syscalls. So that IO doesn&#x27;t suck as much as it would otherwise.  I.e. this is classic and well known challenge of M:N or green threads.<br>
<p>
Notably, this is what Google-internal fibers don&#x27;t have yet (as Peter points out too). As inside google most processes only do &quot;IO&quot; by RPCing to other services. And pretty much all the actual blocking/sleeping is via abseil mutex/condition-variable which has facilities to call to fiber scheduler. I.e. those functions are weak for a reason: <a href="https://github.com/abseil/abseil-cpp/blob/1ae9b71c474628d60eb251a3f62967fe64151bb2/absl/synchronization/internal/per_thread_sem.cc#L71">https://github.com/abseil/abseil-cpp/blob/1ae9b71c474628d...</a><br>
<p>
And those services that actually handle local SSDs and disks use proper async io facilities to do their job. Stuff like blocking on page faults/mm syscalls and what not, are indeed not that important in practice to schedule around anyways.<br>
<p>
But obviously to get this kind of threading implementation ready for non-datacenter world, it definitely requires efficient and general way to deal with blocking syscalls.<br>
<p>
Basically, when all this works as intended, we&#x27;ll simply get cheaper and faster threading facility that will be not too much slower than goroutines, but doesn&#x27;t have suck-ful IO even in corner cases.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880145/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor880170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 2, 2022 21:37 UTC (Sun)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/880170/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Anyone else reading this and thinking of Erlang?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/880170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor880255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">User-managed concurrency groups</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 3, 2022 17:48 UTC (Mon)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/880255/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Here we go again: As soon as somebody learns that 1:1 threading is both useful and works in the real world, someone else <em>discovers</em> how much more efficient m:n or even 1:n threading <b>must</b> be.  Always coming to a cinema near you as exciting new movie for the last 40 years.


      
          <div class="CommentReplyButton">
            <form action="/Articles/880255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
