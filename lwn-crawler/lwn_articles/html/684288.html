        <!DOCTYPE html>
        <html lang="en">
        <head><title>Persistent-memory error handling [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/684288/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/683849/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/684288/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Persistent-memory error handling</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 20, 2016</br>
           <hr>
<a href="/Articles/lsfmm2016/">LSFMM 2016</a>
</div>
One of the key advantages of persistent memory is that it is, for lack of a
better word, persistent; data stored there will be available for recall in
the future, regardless of whether the system has remained up in the
meantime.  But, like memory in general, persistent memory can fail for a
number of reasons and, 
given the quantities in which it is expected to be deployed, failures are a
certainty.  How should the operating system and applications deal with
errors in persistent memory?  One of the first plenary sessions at the <a
href="http://events.linuxfoundation.org/events/linux-storage-filesystem-and-mm-summit/">2016 
Linux Storage, Filesystem, and Memory-Management Summit</a>, led by Jeff Moyer,
took on this question.
<p>
Error handling with traditional block storage is relatively easy: an I/O
request will fail with an <tt>EIO</tt> error, and the application, assuming
it is prepared, can handle the error in whatever way seems best.  But
persistent memory looks like memory to the system, and memory errors are
handled differently; in particular, they can trigger a low-level machine-check
error.  Some systems can recover from that machine check, others will be
forced to reboot.  Either way, the system has to be able to handle the
problem. 
<p>
Time for a bit of terminology that caused some confusion in the session.
Jeff was talking in particular about errors in "load" operations â€” reading
from persistent memory using normal CPU instructions.  Those were
differentiated from "reads," which are file operations performed with a
system call like <tt>read()</tt>.  Similarly, "stores" (using memory
operations) and "writes" (file operations) are seen differently.  Errors
with reads and writes can be returned via the normal system call status;
errors with loads and stores are a bit more complicated.
<p>
In cases where a machine check from a load operation is recoverable, the
kernel can simply deliver the error to the application via a
<tt>SIGBUS</tt> signal.  But, even there, it became clear that the
situation is not entirely simple: Keith Packard noted that the discussion
was about load errors, and asked what happens when a store goes wrong.  The
problem there is that store operations are not usually synchronous, so
there will be no immediate indication of an error.  Paranoid software can

<a href="/Articles/684296/"><img
src="https://static.lwn.net/images/conf/2016/lsfmm/JeffMoyer-sm.jpg" width=200 height=251
alt="[Jeff Moyer]" title="Jeff Moyer" border=0 hspace=3 vspace=3
align="left"></a> 

do a flush and a load after every store to ensure that the data has been
stored properly; there does not seem to be any better way.
<p>
On "less expensive" systems where the machine check is not recoverable,
it's entirely possible that the system will end up in a reboot loop where,
after each boot, it tries again to access the failing persistent-memory
range.  This behavior is generally seen as undesirable. 
As it turns out, even fancier hardware is sometimes subject to
non-recoverable machine checks, so something has to be done to ensure
reliable operation on all systems.
<p>
The ACPI specification includes a mechanism for scrubbing an address range
for errors; the UEFI firmware can run it as part of the boot process.
Address ranges with errors can be flagged, and the operating system can,
once it boots, query that list of ranges with errors and create a bad-block
list that
it knows must be avoided.  When an application tries to access a range
with an error via <tt>mmap()</tt>, the bad pages can be left unmapped and,
should the application try to access them, the <tt>SIGBUS</tt> can be
delivered.  The scrubbing operation is not necessarily fast, so it would be
unsurprising if it didn't run on every boot, but it can be run when errors
begin happening.
<p>
The solution as described so far, though, only works at the level of
pages.  The error granularity reported by the hardware can be as fine as a
single 64-byte cache line; marking an entire (4KB) page as being bad when
only 64&nbsp;bytes have been truly lost is less than ideal.  One way of
narrowing things down would be for the application to open the file with
the reported data loss and issue a series of 512-byte reads, narrowing the
problem down to a single 512-byte "sector."  But, Jeff said, that "still
seems a little perverse."  It would be nice to be able to directly inform
an application about exactly what has been lost.
<p>
A number of possibilities for providing that information were discussed.
Christoph Hellwig suggested that the information provided with the
<tt>SIGBUS</tt> signal could be expanded to include the exact range that
was lost.  Dan Williams said that the application could read the bad-block
list from sysfs, then use the <a href="/Articles/440255/"><tt>FIEMAP</tt>
<tt>ioctl()</tt> operation</a> to figure out which block in the file was
bad.  That works today, he said, except that the bad-block list is not
updated while the system is live.  Ted Ts'o said it would be useful to have
a new <tt>ioctl()</tt> command to query the failing byte range directly.
<p>
James Bottomley said that the most friendly approach would be to remap the
bad block and hide it entirely, only informing applications if data has
actually been lost.  It was agreed that remapping would work if an error is
detected on a write operation, but the real problem is with reads (or,
properly, loads) where data is known to have been lost.  In that case,
applications should not be forced to dig through the bad-block list; there
should be a more direct interface.  There also needs to be some sort of
interface to clear the error (typically remapping the block) so that the
given address range becomes usable again.
<p>
As the session wound down, a few residual questions came up, but no real
decisions were reached.  Ted asked whether the problem of non-recoverable
machine checks would go away as the hardware improves; Jeff answered that
it might, but that doesn't change the real issue of how to convey problems
to user space.  Ted also asked whether this information should be provided
to applications at all â€” isn't that assuming a fundamental change in
application behavior?  Ric Wheeler answered that applications that care
about data integrity already keep multiple copies of the data; they just
need to know where things go wrong.
<p>
As has been seen for a while, persistent memory raises a number of
questions with regard to how it should be presented to user space.  While
many of the problems are being solved, it seems likely that
persistent memory will be a discussion topic at events like this for some
time yet.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Nonvolatile_memory">Memory management/Nonvolatile memory</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_and_Memory-Management_Summit-2016">Storage, Filesystem, and Memory-Management Summit/2016</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/684288/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor684457"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2016 15:50 UTC (Wed)
                               by <b>clugstj</b> (subscriber, #4020)
                              [<a href="/Articles/684457/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't see why "persistent memory" needs to be treated any different than RAM and RR (rotating rust).  mmap'ing disk files has exactly the same problems with "load" and "store", why are these same problems more of an issue for persistent memory?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684457/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2016 17:45 UTC (Wed)
                               by <b>sashal</b> (<b>&#x272D; supporter &#x272D;</b>, #81842)
                              [<a href="/Articles/684473/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Failed read from block storage can fail and you'll get a nice error you can handle. Failed load from RAM will generate a machine check and reboot your box.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor684474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 20, 2016 18:04 UTC (Wed)
                               by <b>smoogen</b> (subscriber, #97)
                              [<a href="/Articles/684474/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So if you have bad memory it causes the system to reset and reboot in most hardware. In a drive, if you have a bad sector, it causes a localized reset in the hardware (eg the disk drive CPU OS will reset and figure out how to recover/map a sector.) The persistent memory does not have that hardware CPU to catch those errors, reset and fix. Instead it is the main CPU which sees the error which looks like a bad RAM module and will then do what it does with all bad ram, (which in the case of most hardware is reboot and hope the problem was transient).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684648"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2016 0:08 UTC (Fri)
                               by <b>stellarhopper</b> (subscriber, #84666)
                              [<a href="/Articles/684648/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can't just "reboot and hope the problem was transient" as you can do with DRAM because this is not memory, this is _storage_, and you have to let the owner of the data know that some data has been lost. The DIMMs have the ability to remap sectors and 'heal' the bad location, but that needs to be initiated by the user/application for the above reason. It only gets interesting because reads/writes to persistent memory are but memcpys, and they don't return the nice and friendly -EIOs we're used to, and instead crash the machine.. There has been some work done to try and handle/intercept these when possible to return EIOs, but that isn't always the case (notably, for mmap/DAX, and for latent errors yet to be discovered)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684648/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor684560"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2016 21:52 UTC (Thu)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/684560/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Modern hd and ssd have a mechanism to hide bad blocks from the OS by having spare blocks, because for manufacturing reason, they are sold with bad blocks (that is also why when the OS start to report bad blocks, the disk is toast)<br>
<p>
I would expect persistent memory to be similar. Maybe I am wrong.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684560/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684917"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 25, 2016 9:56 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/684917/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is that even with spinning rust, you can only hide a bad block on write, because you know what data is supposed to be there (since it's just been written). On read, there is no alternative but -EIO: the data is *gone*. It's only on the next write that the sector is spared. (Frankly, I'd rather you get one -EIO and spare it right away, because the only way to be sure of writing to that location again with a filesystem in the way is a full e2fsck -cc or analogue, and that takes *ages*.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684917/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor685016"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 25, 2016 18:07 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/685016/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Frankly, I'd rather you get one -EIO and spare it right away, because the only way to be sure of writing to that location again with a filesystem in the way is a full e2fsck -cc or analogue, and that takes *ages*.</font><br>
<p>
That would result in silent data corruption if you tried to read the same bad sector twice. The first -EIO may not even be seen by the OS, or durably recorded, depending on various race conditions. The current approach ensures that the data is reported as bad on every read until the sector is rewritten. Moreover, there is no real need to scrub the bad sector from the disk. If the filesystem moves data to a different sector when you rewrite a file then the problem is effectively solved: the original sector is now considered free space and won't be read again until after it's been filled with new data, giving the drive a chance to replace it. Until then, leaving the bad sector in place does no harm.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/685016/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor685068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2016 10:27 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/685068/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
True! I guess what I'm really wishing for is some layer or daemon or something that knows about all -EIOs and can immediately trigger a spare, because as it is nothing deals with them and every bad block needs human intervention. This is very far from optimal!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/685068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor685101"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2016 14:27 UTC (Tue)
                               by <b>gioele</b> (subscriber, #61675)
                              [<a href="/Articles/685101/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I guess what I'm really wishing for is some layer or daemon or something that knows about all -EIOs and can immediately trigger a spare,</font><br>
<p>
Couldn't the daemon just poll the state of the SMART values?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/685101/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor685156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2016 18:40 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/685156/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SMART values end up not being very good predictors.<br>
<p>
And the issue here is that when a block on disk goes bad, the data on it is lost, so you have to figure out what that block contained and how important it was to be able to recover from it.<br>
<p>
That is a very non-trivial thing to do.<br>
<p>
But in any case, we are talking about memory here, not disk, there aren't SMART values, you either succeed in accessing the memory address or you fail.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/685156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor685219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2016 7:17 UTC (Wed)
                               by <b>gioele</b> (subscriber, #61675)
                              [<a href="/Articles/685219/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But in any case, we are talking about memory here, not disk, there aren't SMART values, you either succeed in accessing the memory address or you fail.</font><br>
<p>
Grand-grand-grand-parent was talking (also) about "spinning rust".<br>
<p>
Anyway, I suppose that some kind of out-of-band reporting will be added to persistent memory as it get more widespread. And I would not be surprised if this reporting system were a variation of SMART, hopefully with more stringent and precise specs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/685219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor684518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2016 0:13 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/684518/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The question on my mind here is "Who cares?" - asked seriously, not rhetorically.<br>
<p>
Can we identify an application that would do something other than die horribly when there is a memory error?  Once we do, we ask the application "How can we make your life better?"<br>
<p>
Inventing recovery mechanisms without a clear goal isn't likely to achieve much (though it is fun!).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684531"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2016 3:15 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/684531/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The difference is that with Persistant Memory the corruption doesn't get cleared in a reboot. If the program is running from PM and expects to pick up where it left off, it will just hit the corruption again and die again (think an OS that sleeps by flushing the CPU caches and then powering down)<br>
<p>
If you use PM as a data store, every time you try to access something the system reboots. Then you try and access it after the reboot, and you crash again. If this is a config used by the system to boot (think any /etc files) it becomes very hard to deal with.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684531/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684538"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2016 4:45 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/684538/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You seem to be saying that the filesystem is someone "who cares".<br>
<p>
Filesystems do "reads" rather than "loads" don't they?  So they can just get a read error and behave in exactly the same way that they do now.<br>
<p>
Or maybe you are assuming DAX is being used so the filesystem doesn't actually read the data.<br>
In that case, the concern expressed in the article:<br>
<p>
<font class="QuotedText">&gt; marking an entire (4KB) page as being bad when only 64 bytes have been truly lost is less than ideal. </font><br>
<p>
is irrelevant (so we need to find someone else who cares to resolve that).<br>
<p>
The "send a sigbus when accessing a non-available page" seems completely appropriate for the filesystem use case, and I got the impression that approach was already handled??<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684538/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2016 9:11 UTC (Thu)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/684554/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The parent was saying that a cycle of reboots -- because random-access memory is transient -- isn't helpful when the faulty data persists a reset, whoever accesses it.<br>
<p>
I assume there are more lines of code beyond DAX, spawned by not-invented-here and hiding in corners of the kernel tree, that will access persistent memory as if it's transient and trigger MCE-reboot on error. ^Maybe^ that's wrong and the infrastructure ^is^ in place already to mitigate this behaviour and everyone ^is^ using the best of the kernel's helper libraries. ^Maybe^. :-)<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor684649"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2016 0:14 UTC (Fri)
                               by <b>stellarhopper</b> (subscriber, #84666)
                              [<a href="/Articles/684649/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While the blast radius magnification (64B -&gt; 4KB) is probably not a concern for filesystem data or even databases using pmem as storage, it could be for an application using, say, the NVML to store data structures persistently.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684649/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor684604"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2016 15:25 UTC (Thu)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/684604/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Can we identify an application that would do something other than die horribly when there is a memory error?</font><br>
<p>
A database with replication mechanisms.  Or a filesystem with RAID-style parity.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684604/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor684816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2016 10:10 UTC (Sat)
                               by <b>mslusarz</b> (guest, #58587)
                              [<a href="/Articles/684816/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When an application uses NVML, administrator can enable transparent replication, which NVML could use to semi-transparently resolve memory errors by downloading clean data from the copy. And by "could use" I mean "will use" when an information about the error is properly exposed by the kernel - the best would be byte-level granularity even if the whole page is unmapped.<br>
<p>
For now replication is implemented only for libpmemobj (only local, remote is under development), but there's nothing which prevents it from being implemented for other libraries.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor684566"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 21, 2016 11:56 UTC (Thu)
                               by <b>itvirta</b> (guest, #49997)
                              [<a href="/Articles/684566/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ugh, seriously, is somebody planning on creating hardware with significant amounts of persistent memory where an access error can only be<br>
resolved by rebooting? Surely there must be some saner way? Right...?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684566/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684707"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 22, 2016 13:03 UTC (Fri)
                               by <b>JFlorian</b> (guest, #49650)
                              [<a href="/Articles/684707/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's how I felt reading this too.  I'll admit I'm naive with this PM technology but why not treat it like storage and hide it behind a controller/CPU/OS like today's hard drives have?  Then if it the appropriate thing is a machine check/reboot, it can do so locally.  Of course I still have no idea how *that* controller would deal with the persistent problem upon trying to access it again later.  Maybe that's the crux of the problem; pushing it down a layer really doesn't solve anything other than shift the responsibility to someone else.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684707/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2016 0:34 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/684799/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The fancy thing about PM is that it doesn't require separate controllers, it's just a different type of DIMM that plugs into your normal memory socket, and could be used just like normal RAM if you wanted to.<br>
<p>
saying that it can't be used this way, and needs to be behind some sort of controller to mask errors and things like that will drasticly slow the performance of it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684839"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 23, 2016 16:28 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/684839/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The fancy thing about PM is that it doesn't require separate controllers, it's just a different type of DIMM that plugs into your normal memory socket, and could be used just like normal RAM if you wanted to.</font><br>
<p>
So, let's plug a persistent storage technology into a complete different and totally inappropriate volatile memory interface and see what engineering surprises that can bring. Job security for granted.<br>
<p>
<font class="QuotedText">&gt;   behind some sort of controller [...] will drasticly slow the performance of it.</font><br>
<p>
First make it run; then make it run fast.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/684839/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor684858"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 24, 2016 1:36 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/684858/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
This thread has wandered badly from the subject of the talk/article.  The talk is about persistent memory, which by definition is not behind a controller/CPU/OS like a disk drive.  Something that is <em>like</em> persistent memory, but is behind a controller/CPU/OS like a disk drive is what we call an SSD and indeed, it does not have the issues described in the talk.
<p>
The benefits of persistent memory over other storage technologies, especially relative to costs like these error handling problems, are debatable, but a big selling point is that persistent memory is faster.

      
          <div class="CommentReplyButton">
            <form action="/Articles/684858/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor685591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Persistent-memory error handling</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 1, 2016 8:57 UTC (Sun)
                               by <b>ddd</b> (guest, #108539)
                              [<a href="/Articles/685591/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The question Keith Packard raised is valid, but I don't think that loads are any different than store in that respect. Since a load usually comes from a cache, it's not unlikely that some loads will succeed even after the corresponding memory has failed.<br>
<p>
Reporting such errors through a signal seems like the right thing to do. But is SIGBUS the right one? SIGBUS was invented at a time where a bus error was synchronous with a single load or store operation. Should we revisit SIGBUS to tell applications that care that the value in si_addr is not precise? Or should we consider that persistent memory errors warrant a new signal? I'd vote for the first solution, but I feel it's not clear cut.<br>
<p>
As others have pointed out, the problem does not seem different from a disk I/O error on a mmap-ed range. I believe that the two error scenarios should be unified as much as possible.<br>
<p>
Let's first consider a store. For an mmap write-back, you still have an accessible copy of the data to store somewhere (in RAM), so you can write elsewhere on the disk. For a store write-back, either you have a copy of the data in cache (which may not be easy to send elsewhere without hardware support), or at least you can retry the store instruction after remapping. So at least theoretically, it's possible to remap. For a cached store, you have a granularity of one cache line. For a non-cached store, a granularity of one word. For mmap, a granularity of one page. If remapping is not possible, then the application gets a signal and has to deal with it, e.g. by dying.<br>
<p>
For a load, things are more complicated. As others have pointed out, only the application can have a valid recovery strategy, but then, not for all data. While it seems reasonable to expect that new code dealing with some fancy in-memory database would know what to do if a load to the database fails, legacy code will have no clue. Say you use the C++ STL and you lookup some data in a std::map, and some load in the middle fails. What should the STL do? What can the application possibly do to recover from that?<br>
<p>
I believe we cannot make the economy of partitioning memory based on usage. We should extend madvise with hints about persistency and error management, with explicit mechanisms for checkpointing and restarting an application. We can make some guarantees about a transactional checkpoint/restart mechanism that we will never be able to do with random loads and stores.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/685591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2016, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
