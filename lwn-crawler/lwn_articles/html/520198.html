        <!DOCTYPE html>
        <html lang="en">
        <head><title>EPOLL_CTL_DISABLE, epoll, and API design [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/520198/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/520346/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/520198/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>EPOLL_CTL_DISABLE, epoll, and API design</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Michael Kerrisk</b><br>October 23, 2012</br>
           </div>
<p> <a href="/Articles/520012/">In an article last week</a>, we saw that
the <tt>EPOLL_CTL_DISABLE</tt> operation proposed by Paton Lewis provides a
way for multithreaded applications that cache information about file
descriptors to safely delete those file descriptors from an epoll interest
list.  For the sake of brevity, in the remainder of this article we'll use
the term "the <tt>EPOLL_CTL_DISABLE</tt> problem" to label the underlying
problem that <tt>EPOLL_CTL_DISABLE</tt> solves.

<p> This article revisits the <tt>EPOLL_CTL_DISABLE</tt> story from a
different angle, with the aim of drawing some lessons about the design of
the APIs that the kernel presents to user space. The initial motivation for
pursuing this angle arises from the observation that the
<tt>EPOLL_CTL_DISABLE</tt> solution has some difficulties of its own. It is
neither intuitive (it relies on some non-obvious details of the epoll
implementation) nor easy to use. Furthermore, the solution is somewhat
limiting, since it forces the programmer to employ the
<tt>EPOLLONESHOT</tt> flag. Of course, these difficulties arise at least in
part because <tt>EPOLL_CTL_DISABLE</tt> is designed so as to satisfy one of
the cardinal rules of Linux development: interface changes must not break
existing user-space applications.

<!--

<p> As <a href="/Articles/520012/">last week's article</a> on the
<tt>EPOLL_CTL_DISABLE</tt> operation illustrates, the issues faced by
multithreaded programs that deal with the kernel API can be rather
subtle. In this article, we revisit the <tt>EPOLL_CTL_DISABLE</tt> story
from another angle in order to draw some lessons about the design of APIs
that the kernel presents to user space.

<p> <tt>EPOLL_CTL_DISABLE</tt> provides a way for multithreaded
applications that cache information about file descriptors to safely delete
those file descriptors from an epoll interest list. For brevity, in the
remainder of this article, we'll call the problem that
<tt>EPOLL_CTL_DISABLE</tt> solves "the <tt>EPOLL_CTL_DISABLE</tt>
problem". However, the solution provided by <tt>EPOLL_CTL_DISABLE</tt>
itself has a number of problems: it is neither intuitive (it relies on some
non-obvious details of the epoll implementation) nor easy to
use. Furthermore, the solution is somewhat limiting, since it forces the
programmer to employ the <tt>EPOLLONESHOT</tt> flag. Of course, these
problems arise at least in part because <tt>EPOLL_CTL_DISABLE</tt> is
designed so as to satisfy one of the cardinal rules of Linux
development&mdash;interface changes must not break existing user-space
applications.

-->

<p> If there had been an awareness of the <tt>EPOLL_CTL_DISABLE</tt>
problem when the epoll API was originally designed, it seems likely that a
better solution would have been built, rather than bolting on
<tt>EPOLL_CTL_DISABLE</tt> after the fact.  Leaving aside the question of
what that solution might have been, there's another interesting question:
could the problem have been foreseen?

<p> One might suppose that predicting the <tt>EPOLL_CTL_DISABLE</tt>
problem would have been quite difficult. However, the synchronized-state
problem is well known and the epoll API was designed to be thread
friendly. Furthermore, the notion of employing a user-space cache of the
ready list to prevent file descriptor starvation was documented in the <a
href="http://man7.org/linux/man-pages/man7/epoll.7.html"><tt>epoll(7)</tt>
man page</a> (see the sections "Example for Suggested Usage" and "Possible
Pitfalls and Ways to Avoid Them") that was supplied as part of the original
implementation.

<p> In other words, almost all of the pieces of the puzzle were known when
the epoll API was designed. The one fact whose implications <i>might</i>
not have been clear was the presence of a blocking interface
(<tt>epoll_wait()</tt>) in the API. One wonders if more review (and
building of test applications) as the epoll API was being designed might
have uncovered the interaction of <tt>epoll_wait()</tt> with the remaining
well-known pieces of the puzzle, and resulted in a better initial design
that addressed the <tt>EPOLL_CTL_DISABLE</tt> problem.

<p> So, the first lesson from the <tt>EPOLL_CTL_DISABLE</tt> story is that
more review is necessary in order to create better API designs (and we'll
see further evidence supporting that claim in a moment). Of course, the
need for more review is a general problem in all aspects of Linux
development. However, the effects of insufficient review can be especially
painful when it comes to API design. The problem is that once an API has
been released, applications come to depend on it, and it becomes at the
very least difficult, or, more likely, impossible to later change the
aspects of the API's behavior that applications depend upon. As a
consequence, a mistake in API design by one kernel developer can create
problems that thousands of user-space developers must live with for many
years.

<p> A second lesson about API design can be found in <a
href="/Articles/520168/">a comment</a> that Paton made when responding to a
question from Andrew Morton about the design of
<tt>EPOLL_CTL_DISABLE</tt>. Paton was speculating about whether a call of
the form:

<pre>
    epoll_ctl(epfd, EPOLL_CTL_DEL, fd, &amp;epoll_event);
</pre>

<p> could be used to provide the required functionality. The
<tt>EPOLL_CTL_DEL</tt> operation does not currently use the fourth argument
of <tt>epoll_ctl()</tt>, and applications should specify it as
<tt>NULL</tt> (but more on that point in a moment). The idea would be that
"<q>epoll_ctl [EPOLL_CTL_DEL] could set a bit in epoll_event.events
(perhaps called EPOLLNOTREADY)</q>" to notify the caller that the file
descriptor was in use by another thread.

<p> But Paton noted a shortcoming of this approach:

<div class="BigQuote">

However, this could cause a problem with any legacy code that relies on the
fact that the epoll_ctl epoll_event parameter is ignored for
EPOLL_CTL_DEL. Any such code which passed an invalid pointer for that
parameter would suddenly generate a fault when running on the new kernel
code, even though it worked fine in the past.

</div>

<p> In other words, although the <tt>EPOLL_CTL_DEL</tt> operation doesn't
use the <tt>epoll_event</tt> argument, the caller is <i>not</i> required to
specify it as <tt>NULL</tt>. Consequently, existing applications are free
to pass random addresses in <tt>epoll_event</tt>. If the kernel now started
using the <tt>epoll_event</tt> argument for <tt>EPOLL_CTL_DEL</tt>, it
seems likely that some of those applications would break. Even though those
applications might be considered poorly written, that's no justification
for breaking them. <a
href="http://thread.gmane.org/gmane.linux.kernel/361522/focus=361828">Quoting</a>
Linus Torvalds:

<div class="BigQuote">

We care about user-space interfaces to an insane degree. We go to extreme
lengths to maintain even badly designed or unintentional
interfaces. Breaking user programs simply isn't acceptable.

</div>

<p> The lesson here is that when an API doesn't use an argument, usually
the right thing to do is for the implementation to include a check that
requires the argument to have a suitable "empty" value, such as
<tt>NULL</tt> or zero. Failure to do that means that we may later be
prevented from making the kind of API extensions that Paton was talking
about. (We can leave aside the question of whether this particular
extension to the API was the right approach. The point is that the option
to pursue this approach was unavailable.) The kernel-user-space API
provides numerous examples of failure to do this sort of checking.

<p> However, there is yet more life in this story. Although there have been
many examples of system calls that failed to check that "empty" values were
passed for unused arguments, it turns out that
<tt>epoll_ctl(EPOLL_CTL_DEL)</tt> fails to include the check for another
reason. Quoting the BUGS section of the <a
href="http://man7.org/linux/man-pages/man2/epoll_ctl.2.html#BUGS"><tt>epoll_ctl()</tt>
man page</a>:

<div class="BigQuote">

In kernel versions before 2.6.9, the <tt>EPOLL_CTL_DEL</tt> operation
required a non-NULL pointer in <tt>event</tt> [the <tt>epoll_event</tt>
argument], even though this argument is ignored.  Since Linux 2.6.9,
<tt>event</tt> can be specified as NULL when using <tt>EPOLL_CTL_DEL</tt>.
Applications that need to be portable to kernels before 2.6.9 should
specify a non-NULL pointer in event.

</div>

<p> In other words, applications that use <tt>EPOLL_CTL_DEL</tt> are not
only <i>permitted</i> to pass random values in the <tt>epoll_event</tt>
argument: if they want to be portable to Linux kernels before 2.6.9 (which
<a
href="http://thread.gmane.org/gmane.linux.kernel.commits.head/40275">fixed</a>
the problem), they are <i>required</i> to pass a pointer to some random,
but valid user-space address. (Of course, most such applications would
simply allocate an unused <tt>epoll_event</tt> structure and pass a pointer
to that structure.)  Here, we're back to the first lesson: more review of
the initial epoll API design would almost certainly have uncovered this
fairly basic design error. (It's this writer's contention that one of the
best ways to conduct that sort of review is by thoroughly documenting the
API, but he admits to a <a href="/Articles/247788/">certain bias</a> on
this point.)

<p> Failing to check that unused arguments (or unused pieces of arguments)
have "empty" values can cause subtle problems long after the fact. Anyone
looking for further evidence on that point does not need to go far: the
<tt>epoll_ctl()</tt> system call provides another example.


<a name="EPOLLWAKEUP"></a>

<p> Linux 3.5 added a new epoll flag, <tt><a
href="/Articles/495473/">EPOLLWAKEUP</a></tt>, that can be specified in the
<tt>epoll_event.events</tt> field passed to <tt>epoll_ctl()</tt>. The
effect of this flag is to prevent the system from being suspended while
epoll readiness events are pending for the corresponding file
descriptor. Since this flag has a system-wide effect, the caller must have
a capability, <tt>CAP_BLOCK_SUSPEND</tt> (<a
href="/Articles/520770/">initially misnamed
<tt>CAP_EPOLLWAKEUP</tt></a>).

<p> In the initial <tt>EPOLLWAKEUP</tt> implementation, if the caller did
not have the <tt>CAP_BLOCK_SUSPEND</tt> capability, then
<tt>epoll_ctl()</tt> returned an error so that the caller was informed of
the problem. However, Jiri Slaby <a href="/Articles/520774/">reported</a>
that the new flag caused a regression: an existing program failed because
it was setting formerly unused bits in <tt>epoll_event.events</tt> when
calling <tt>epoll_ctl()</tt>. When one of those bits acquired a meaning (as
<tt>EPOLLWAKEUP</tt>), the call failed because the program lacked the
required capability. The problem of course is that <tt>epoll_ctl()</tt> has
never checked the flags in <tt>epoll_event.events</tt> to ensure that the
caller has specified only flag bits that are actually implemented in the
kernel. Consequently, applications were free to pass random garbage in the
unused bits.

<p> When one of those random bits suddenly caused the application to fail,
what should be done? Following the logic outlined above, of course the
answer is that the kernel must change. And that is exactly what happened in
this case. <a href="/Articles/520775/">A patch</a> was applied so that if
the <tt>EPOLLWAKEUP</tt> flag was specified in a call to
<tt>epoll_ctl()</tt> and the caller did not have the
<tt>CAP_BLOCK_SUSPEND</tt> capability, then <tt>epoll_ctl()</tt>
<i>silently ignored</i> the flag instead of returning an error. Of course,
in this case, the calling application might easily carry on, unaware that
the request for <tt>EPOLLWAKEUP</tt> semantics had been ignored.

<p> One might observe that there is a certain arbitrariness about the
approach taken to dealing with the <tt>EPOLLWAKEUP</tt> breakage. Taken to
the extreme, this type of logic would say that the kernel can never add new
flags to APIs that didn't hitherto check their bit-mask arguments&mdash;and
there is a long list of such system calls (<tt>mmap()</tt>,
<tt>splice()</tt>, and <tt>timer_settime()</tt>, to name just a
few). Nevertheless, new flags are added. So, for example, Linux 2.6.17
added the epoll event flag <tt>EPOLLRDHUP</tt>, and since no one complained
about a broken application, the flag remained. It seems likely that the
same would have happened for the original implementation of
<tt>EPOLLWAKEUP</tt> that returned an error when <tt>CAP_BLOCK_SUSPEND</tt>
was lacking, if someone hadn't chanced to make an error report. 

<p> As an aside to the previous point, in cases where someone reports a
regression <i>after</i> an API change has been officially released, there
is a conundrum. On the one hand, there may be old applications that depend
on the previous behavior; on the other hand, newer applications may
already depend on the newly implemented change. At that point, there is no
simple remedy: to fix things almost certainly means that some applications
must break.

<p> We can conclude with two observations, one specific, and the other more
general. The specific observation is that, ironically,
<tt>EPOLL_CTL_DISABLE</tt> itself seems to have had surprisingly little
review before being accepted into the 3.7 merge window. And in fact, now
that more attention has been focused on it, it <a
href="/Articles/520358/">looks as though</a> the proposed API will see some
changes. So, we have a further, very current, piece of evidence that there
is still insufficient review of kernel-user-space APIs.

<p> More generally, the problem seems to be that&mdash;while the kernel
code gets reviewed on many dimensions&mdash;it is relatively uncommon for
kernel-user-space APIs to be reviewed on their own merits. The kernel has
maintainers for many subsystems. By now, the time seems ripe for there to
be a kernel-user-space API maintainer&mdash;someone whose <i>job</i> it is
to actively review and ack every kernel-user-space API change, and to
ensure that test cases and sufficient documentation are supplied with the
implementation of those changes. Lacking such a maintainer, it seems likely
that we'll see many more cases where kernel developers add badly designed
APIs that cause <a
href="http://man7.org/conf/lcna2012/Why_kernel_space_sucks-2012-08-29.pdf">years
of pain [PDF]</a> for user-space developers.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Epoll">Epoll</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#User-space_API-Design">User-space API/Design</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/520198/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor520854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 23, 2012 16:19 UTC (Tue)
                               by <b>dankamongmen</b> (subscriber, #35141)
                              [<a href="/Articles/520854/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://raw.github.com/dankamongmen/libtorque/master/doc/mteventqueues">https://raw.github.com/dankamongmen/libtorque/master/doc/...</a><br>
<p>
I really wish I'd have followed this out to its conclusion back in 2010. :/<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor520864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 23, 2012 20:27 UTC (Tue)
                               by <b>Yorick</b> (guest, #19241)
                              [<a href="/Articles/520864/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <p>This is unfortunate. There is nothing more important to review than immutable interfaces (except for security audits). I'm going to be grossly unfair here, but in neglecting basic software engineering principles, the developers here come out as bumbling amateurs. (Of course I've made similar mistakes myself, but with slightly less severe consequences.)

<p>With a cast-in-stone policy, these APIs must be subject to extreme scrutiny. I would like to go further than the editor of the excellent article: There should be working applications present, not just tiny test cases or proofs of concept, in addition to full documentation, before any proposals can be accepted. It's not just a matter of verifying that the APIs work, but that they are useful and complete as well.

<p>The importance of checking unused parameter bits was learned dearly in the 1960s, over and over again, both for hardware and software. We should know this by know.

      
          <div class="CommentReplyButton">
            <form action="/Articles/520864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 23, 2012 20:30 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/520869/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
even working applications aren't going to identify all the drawbacks and problems with an API.<br>
<p>
The early applications that use an API are going to be written by people who are very familiar with the API and know not only what the API does, but how it _should_ be used.<br>
<p>
a few years later, you get applications developed by people who don't know how it _should_ be used, and as they start trying to use it in other ways (some of them very good ways), they expose limitations that the people who were involved with the development, testing, and reviews of the API missed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520872"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 23, 2012 21:01 UTC (Tue)
                               by <b>Yorick</b> (guest, #19241)
                              [<a href="/Articles/520872/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You are right, but there is not much we can do about that other than devising more sophisticated mechanisms for API evolution than the rather simplistic policy in Linux. User-space libraries (with versioned symbols or similar ways of evolving APIs) provide one possible answer, but from what I understand, the kernel maintainers aren't too keen on such layers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520872/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520875"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 23, 2012 21:07 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/520875/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I disagree.<br>
<p>
If applications will be broken, then the API shouldn't change.<br>
<p>
If there are no applications using an API, that API can be removed.<br>
<p>
But If applications are using that API, creating new versions of the API doesn't solve the problem. Existing applications are not going to disappear.<br>
<p>
This attitude that "the APIs are versioned, we can drop support for old versions" is exactly what's causing the problems in the Linux Desktop Environment world.<br>
<p>
It doesn't matter how justified you think you are in getting rid of an old version, if it breaks users it's a regression and you should not do so.<br>
<p>
Maintaining lots of different, incompatible versions of an API is a huge amount of work, so just versioning the API isn't nearly enough, and it's questionable if it really helps in the long run.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520875/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520887"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 23, 2012 23:04 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/520887/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In cases like this one, where the problem is just unused parameters which weren't checked, it seems like a simple enough thing to fix. Just create a new API for new applications that follow the rules, and make the old one forward to the new one after masking out the unused parts. For example, epoll_ctl(epfd, op, fd, event) could call epoll_ctl_v2(epfd, op, fd, NULL), ignoring event; anything that wants to use the last parameter would call epoll_ctl_v2 directly. The same principle would work for bitfields. The new API could easily be made automatic for new programs through versioned library symbols.<br>
<p>
However, I agree that in general maintaining multiple API versions, where the old one is not a simple subset of the new one, is not likely to go well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520887/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2012 9:42 UTC (Thu)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/521197/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However, I agree that in general maintaining multiple API versions, where the old one is not a simple subset of the new one, is not likely to go well.</font><br>
<p>
For that reason we should be putting much more effort into API design. In fact, tacking into account that API _will_ outlive its implementation (maybe several of them), most of the effort should be towards getting the API right.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor521591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Re API (and ABI) design and maintenance </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2012 18:31 UTC (Fri)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/521591/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Creating new versions is one *step* in a disciplined (anal) process of evolution.  It's been done continuously since the days of the mainframe, but people don't realize it's happening.<br>
<p>
I spent three years at the (late, lamented) Sun Microsystems doing ABI stability, and ended up sensitized enough that I notice it when it happens.<br>
<p>
An easy example was a company's linker, which needed a different data structure for a method call that it had.  We added a new "record type" in tghe linker, and converted the compilers to produce only it. We supported the old format for a year, then made its use produce a warning, and a year after that, made it require a link-line option.<br>
<p>
We got two complaints, total, about the option. Out of all our customers, only two were so very very far behind that they ran one of the old compilers. A year or two later a hardware change made those compilers produce impossibly lousy code, and the two outliers upgraded to the new compilers. Then we retired the old interface.<br>
<p>
If we had moved any faster, we would have annoyed at least two customers.  If we had moved any slower in switching the compilers over, we would have made the OS developers unhappy.  The time between the first switch and the final stages of the retirement made the maintainers unhappy, but there weren't many bugs in that interface nor were there many user of it, so the time cost of maintaining it was low.<br>
<p>
We did have to manage it, and we had to do a fair bit of work behind the scenes to make it invisible to the users, but we succeeded at evolution. <br>
<p>
Just as with humans, if you don't evolve, you might just die out.  Homo habilis, anyone?<br>
<p>
--dave<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor524645"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Re API (and ABI) design and maintenance </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 13, 2012 12:39 UTC (Tue)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/524645/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; We did have to manage it, and we had to do a fair bit of work behind the scenes to make it invisible to the users, but we succeeded at evolution. </font><br>
<p>
I suspect that Linus' view on never, ever, binning old binary interfaces will mean that there will be (un)dead interfaces supported forever. My thoughts on a management plan look like:<br>
(*) build a test suite round existing, in-use interfaces to maintain their intended functionality<br>
(*) build a versioning API where a version-aware program can call in to use versioned interfaces<br>
(*) attach version info to the existing APIs and handle a 'this interface is not implemented in your version of Linux' error<br>
(*) develop a plumbing metalanguage to support disabled/legacy interface functionality via newer intefaces<br>
(*) have all the interfaces configurable in the makefile, defaulting to enabled<br>
(*) stop talking and show you some code<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/524645/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor525252"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Re API (and ABI) design and maintenance </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 15, 2012 17:15 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/525252/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's pointless. With memory sizes continuing to shoot up as they are, the memory overhead of maintaining old interfaces is minimal: and as long as the interfaces have no significant maintenance overhead, why not maintain them? I mean, Linux still supports uselib(), which is IIRC useless unless you're still using a.out shared libraries and libc4!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/525252/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor525674"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Re API (and ABI) design and maintenance </h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2012 6:44 UTC (Mon)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/525674/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This article itself supplies an example where an older interface design has caused internal plumbing designs to be less than the best. This will happen again, and will cause a kind-of scarring to the structure of the Linux Kernel. Wouldn't you like to be able to offer end-users of the Kernel a clean set of interfaces, easy to comprehend and unhindered by history's quirks?<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/525674/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor520902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2012 4:25 UTC (Wed)
                               by <b>daniels</b> (subscriber, #16193)
                              [<a href="/Articles/520902/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p><em>the developers here come out as bumbling amateurs</em></p>
<p>Err? They made a mistake, which in the context of something as complex and genuinely impressive as the Linux kernel, can be forgiven.  How many kernels which scale from embedded to clusters have you written?</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/520902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520916"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2012 10:40 UTC (Wed)
                               by <b>Yorick</b> (guest, #19241)
                              [<a href="/Articles/520916/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As the article points out, changes to the internal kernel code tend to get much more scrutiny than those that affect user-visible interfaces, despite the fact that those are the ones that really need to be right from the start. That comes out as sloppy, but is really more a sign of a development process in the need of improvement.<br>
<p>
When we suffer from badly thought-out APIs made by Microsoft, say, we pour scorn over the developers who designed the mess and call them incompetent, fairly or not. Linux kernel programmers are not exempt and should not be.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520916/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor520917"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2012 10:51 UTC (Wed)
                               by <b>mkerrisk</b> (subscriber, #1978)
                              [<a href="/Articles/520917/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
That comes out as sloppy, but is really more a sign of a development process in the need of improvement.
</blockquote>

<p>
Yes. Having watched what goes on for quite a while now, I consider this mainly a process problem, rather than a problem of individual developers (though obviously some do a better job than others).
      
          <div class="CommentReplyButton">
            <form action="/Articles/520917/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521203"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2012 9:45 UTC (Thu)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/521203/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A good start would be to find out how is that some do a better job that others, and how we can get that to happen more often.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521203/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor520980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 24, 2012 16:30 UTC (Wed)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/520980/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This should probably have been a comment on the previous article, but I'm not sure if anyone is watching that any more.<br>
<p>
I am sure that there is a good reason why it won't work, but couldn't the original problem be solved, in user space, if the user space file descriptor cache included not just a "should be deleted" flag, but also a reference count of threads currently using a file descriptor?  Then, before accessing the descriptor, a thread could check the "should be deleted" flag and if it is set decrease the reference count instead of accessing it, freeing the resources if the count reached zero.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/520980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2012 0:02 UTC (Thu)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/521113/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
See my comment about 'weak reference' in the comments of the original article.  I agree, that this looks fundamentally like a solution in search of a problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2012 21:57 UTC (Thu)
                               by <b>Jandar</b> (subscriber, #85683)
                              [<a href="/Articles/521379/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I had missed this comment in the original article, reading LWN too early has it's disadvantages.  There should be a way to step later through unread comments.<br>
<p>
The solution using the cookie is simple and elegant.  I don't understand the comments about not using the cookie because someone would like to use it otherwise.  This line of reason means nobody should use the cookie.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2012 22:03 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/521382/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
take a look at <a rel="nofollow" href="https://lwn.net/Comments/unread">https://lwn.net/Comments/unread</a><br>
<p>
it shows you comments for all stories that you haven't read since the last time you viewed that page (and that you haven't read by going to the specific article page)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2012 0:21 UTC (Fri)
                               by <b>Jandar</b> (subscriber, #85683)
                              [<a href="/Articles/521402/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nearly all content of <a href="https://lwn.net/Comments/unread">https://lwn.net/Comments/unread</a> I have already seen. <br>
<p>
I read LWN in the "One big page" mode and go to the comments (in a new tab) with the "Comments (xxx posted)" button.  After I have read the comments for one article I close the tab.  Is there something I can do to make Comments/unread more useful?<br>
<p>
What I would really like would be some means to hop from one unread comment to the next within the complete comment-section to see the surrounding context.  It could be a link at each unread comment pointing to an anchor at the next. E.g. <a href="http://lwn.net/Articles/520198/#Comments-UnRead42">http://lwn.net/Articles/520198/#Comments-UnRead42</a>.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521414"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2012 0:46 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/521414/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you were logged in when you saw those other comments, and still see them on the /unread page, there is a bug that you should send to lwn@lwn.net<br>
<p>
However, I suspect that if you go to the unread page again, you will not see all those comment any more and you will find it much more useful.<br>
<p>
you should also look at the greasemonkey script for lwn, I think it does more of what you are looking for.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521414/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521419"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2012 1:22 UTC (Fri)
                               by <b>Jandar</b> (subscriber, #85683)
                              [<a href="/Articles/521419/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was logged in while reading this weekly edition.  Next week I make a few tests and see if a bug is reproducible.<br>
<p>
I use konqueror not firefox but greasemonkey with fancyLWNComments seems to be a reason to switch for reading LWN.  Thanks for pointing me to it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521419/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor521448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2012 5:01 UTC (Fri)
                               by <b>dirtyepic</b> (guest, #30178)
                              [<a href="/Articles/521448/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What would be really useful is a way to mark an article as watched and have any new comments on it sent by email.  Seeing all unread comments is just too much noise for me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2012 6:00 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/521455/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
if you are reading while logged in, you should see that when you revisit an article, new posts show up with an orange border while old posts show up with a grey border.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor521576"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 26, 2012 17:03 UTC (Fri)
                               by <b>Jandar</b> (subscriber, #85683)
                              [<a href="/Articles/521576/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For me there is no visual difference between old and new comments.  In "LWN account customization" there is a setting "Old (seen) comment background color" but this doesn't work, neither in konqueror nor in iceweasel.<br>
<p>
Greasemonkeys fancyLWNComments is the first working method to tell read and unread apart.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521576/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor521652"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 27, 2012 2:54 UTC (Sat)
                               by <b>dirtyepic</b> (guest, #30178)
                              [<a href="/Articles/521652/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yep, and that's handy.  But I'd like a better way to follow comments than bookmarking individual articles and scanning through the whole list periodically.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521652/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor521180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2012 9:05 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/521180/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm coming around to wahern's position noted in comments on the previous article: it's an architectural design error for threads to share a resource but not keep track of which are using it.  If you design that way, no amount of EPOLL_CTL_DISABLE can make your design good. No end of similar problems will be waiting to surface.<br>
<p>
I'm also much more impressed with kjp's solution than is our esteemed author.  It attacks the problem at the root, even enabling rescue of such poorly architected designs (anyway until the next flaw uncloaks).  Using the field suggested doesn't "burn" it: other uses can piggyback on the same hash node.  By such reasoning any use at all would burn it, so no use can be deserving enough, and it never gets used for anything.<br>
<p>
Unless I am misunderstanding the argument...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/521180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor522310"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 1, 2012 0:45 UTC (Thu)
                               by <b>kevinm</b> (guest, #69913)
                              [<a href="/Articles/522310/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p><i>By now, the time seems ripe for there to be a kernel-user-space API maintainer—someone whose job it is to actively review and ack every kernel-user-space API change, and to ensure that test cases and sufficient documentation are supplied with the implementation of those changes.</i></p>
<p>Hark, is that the sound of volunteering? ;)</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/522310/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor522394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">EPOLL_CTL_DISABLE, epoll, and API design</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 1, 2012 13:19 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/522394/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought we already had one, and his name was Linus<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/522394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2012, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
