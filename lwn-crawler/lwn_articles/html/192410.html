        <!DOCTYPE html>
        <html lang="en">
        <head><title>OLS: A proposal for a new networking API [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/192410/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/192080/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/192410/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>OLS: A proposal for a new networking API</h1>
<div class="Byline">[Posted July 22, 2006 by corbet]
               <p>
               </div>
</div>
<div class="ArticleText">
Ulrich Drepper has been the maintainer of the core glibc library since
1995; he also represents the community to the POSIX standardization
effort.  So, when Ulrich proposes a new user-space API, more than the
usual number of people are likely to listen.  Ulrich has been putting his
mind to the problems of high-performance network I/O; the results were
presented at his Ottawa Linux Symposium talk.
<p>

The current POSIX APIs are, increasingly, not up to the task.  The socket
abstraction has served us for a long time, but it is a synchronous
interface which is not well suited to zero-copy I/O.  POSIX does provide an
asynchronous I/O interface, but it was never intended for use with
networking, and does not provide the requisite functionality.  So it has
been clear for a while that something better is needed; the developers
working on <a href="http://lwn.net/Articles/169961/">network channels</a>
have also been talking about the need for a new networking API.
<p>

There are three components to a new networking API, all of which will lead
to a more complex - but much more efficient - interface for
high-performance situations.  The first of those is to address the need for
zero-copy I/O.  As the data bandwidth through the system increases, the
cost of copying data (in CPU utilization and cache pressure) increase.
Much of this cost can be avoided by transferring data directly between the
network interface and buffers in user space.  Direct user-space I/O
requires cooperation from both the kernel and the application, however.
<p>

Ulrich proposes the creation of an interface for the explicit management
of user-space DMA areas.  Such an area would be created with a call that
looks something like:
<p>
<pre>
    int dma_alloc(dma_mem_t *handle, size_t size, int flags);
</pre>
<p>
If all goes well, the result would be a memory area of the given
<tt>size</tt>, suitable for DMA purposes.  Note that user space gets an
opaque handle type in return - there is, at this point, no virtual address
which is directly accessible to the application.
<p>
To use a DMA area for network I/O, the application must associate it with a
socket.  The call for this operation would look like:
<p>
<pre>
    int dma_assoc(int socket, dma_mem_t handle, size_t size, int flags);
</pre>
<p>
There is still the issue of actually managing memory within this DMA area.
An application which is generating data to send over the net would request
a buffer from the kernel with a call like:
<p>
<pre>
    int sio_reserve(dma_mem_t handle, void **buffer, size_t size);
</pre>
<p>
If all goes well, the result will be a pointer (stored in <tt>*buffer</tt>)
to an area where the outgoing data can be constructed.  For incoming data,
the application will receive a pointer to the buffer from the kernel (just
how is something we'll get to shortly); the application will own the given
buffer until it returns it to the kernel with:
<p>
<pre>
    int sio_release(dma_mem_t handle, size_t size);
</pre>
<p>

Before an application can start to use asynchronous network I/O, however,
it must have a way to learn about the results of its operations.  To that
end, Ulrich proposes the addition of an event reporting API to the
kernel.  This mechanism, which he calls "event channels," would have an
interface like:
<p>
<pre>
    ec_t ec_create(int flags); /* Create a channel */
    ec_next_event();           /* Get the next event */
    ec_to_fd();                /* Send events to a file descriptor */
    ec_delay();                /* Wait for an event directly */
</pre>
<p>
The exact form of this interface (like all of those discussed here) is
subject to change.  But the core idea is that it is a quick way for the
kernel to return notifications of events (such as I/O completions) to user
space.  Most applications would be likely to use the file descriptor
interface, which would allow events to enter an application's main loop via
<tt>poll()</tt> or <tt>epoll_wait()</tt>.
<p>
The final step is to make some extensions to the existing POSIX asynchronous
I/O interface.  The <tt>aiocb</tt> structure would be extended to include
an event channel descriptor; that channel would be used to report the
results of asynchronous operations back to user space.  Then, an
application could initiate data transmission with a call like:
<p>
<pre>
    int aio_send(int socket, void *buffer, size_t size, int flags);
</pre>
<p>
(One presumes there would be an <tt>aiocb</tt> argument as well, but
Ulrich's slides did not show one).  This call would start the process of
transmitting data from the given <tt>buffer</tt>, with completion likely
happening sometime after the call returns.  For data reception, the call
would look like:
<p>
<pre>
    int aio_recv(int socket, void **buffer, size_t size, int flags);
</pre>
<p>
The relevant point here being that <tt>buffer</tt> is a double pointer; the
kernel would pick the actual destination for the data and tell the calling
application where to look.
<p>

The result of all these changes would be a complete programming interface
for high-performance, asynchronous network I/O.  As an added bonus, the use
of an event channel interface would simplify the work of porting
applications from other operating systems.

<p>
All of these interfaces, says Ulrich, are simply a proposal and subject to
massive change.  The core purpose is to allow applications to get their
work done while giving the kernel the greatest possible latitude to
optimize the data transfers.  This proposal is not the only one out there;
Evgeniy Polyakov's <a href="http://lwn.net/Articles/172844/">kevent
proposal</a> is similar in many ways, though it does not have the explicit
management of DMA areas.  It may be some time before something is actually
adopted - a new API will stay around for many years and should not be added
in haste - but the discussion is getting started in earnest.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Asynchronous_IO">Asynchronous I/O</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Events_reporting">Events reporting</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Kevent">Kevent</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking">Networking</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/192410/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor192444"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2006 7:54 UTC (Sun)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/192444/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      I think explicit DMA buffer management from user space is a good idea. Right now network cards use DMA extensivly, but so do graphics cards via DRI. Additionally, sound cards, scanners, camaras, printers, MPEG decoders/encoders, tv cards, etc could all benefit from a clear way to manage DMA buffers from user space. Rather than each subsystem coming up with their own allocation/deallocation routines.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192444/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192447"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2006 11:01 UTC (Sun)
                               by <b>Los__D</b> (guest, #15263)
                              [<a href="/Articles/192447/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      Management should only be pushed to userspace as long as there is a clear reason for it, we don't want a situation where the userspace app is expected to make their own driver to use the device.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192447/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192451"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2006 13:07 UTC (Sun)
                               by <b>mattdm</b> (subscriber, #18)
                              [<a href="/Articles/192451/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Even then, there'd be no reason for *every* app to do it -- that's what libraries are for....<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192451/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor192459"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2006 16:51 UTC (Sun)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/192459/">Link</a>] 
      </p>
      
      </div>
      </summary>
      In cases where the DMA is of bulk uninterpreted or standard data, a driver wouldn't be necessary in userspace. It should work for userspace to ask the kernel a DMA handle that an MPEG-2 stream can be sent to to have the video card decode it with the hardware decoder, and then userspace plays video by passing the video data unmodified to the handle. Obviously, there's more going on, but the kernelspace driver would take care of that.<br>
<p>
In the case of networking, the data is going to be the application's data, to be sent over the network, and it wouldn't matter what the device is to the userspace side.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192459/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor192988"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2006 3:02 UTC (Thu)
                               by <b>ianw</b> (guest, #20143)
                              [<a href="/Articles/192988/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Well, why not?  We might call this a "userspace driver", and abstract it to a library.<br>
<p>
Suddenly (with an IOMMU) this driver can not crash the system any more than any other userspace process.  If it does crash, we have a much higher chance that we can just restart it.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192988/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor192445"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2006 9:53 UTC (Sun)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/192445/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      Sounds good.  But, and call me crazy for asking this, why couldn't sockets be extended to <br>
support such a thing?  Must we invent a totally new API? <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192445/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2006 11:09 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/192448/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      One of the possible underlying media over which these events may flow *is* a netlink socket.<br>
<p>
But fundamentally the BSD sockets API is ugly, quite non-Unixlike, and hard to use and even harder to use correctly, and the thought of using it for *everything* including files is horrible. So no matter what the underlying layer is composed of, we need something better for people to actually *use*. (Ulrich is focused on that, not the implementation details alone: he *is* the libc maintainer.)<br>
<p>
The replacement for select() had me cheering. At last, One Inner Loop! :)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192478"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2006 23:58 UTC (Sun)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/192478/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>I'm curious what a new, socket-replacing API would look like.  Keeping in mind that sockets 
are 
more than just "networking", they're "generic IPC", I imagine one improvement would be to 
eliminate the distinction between "Unix domain" and "network" sockets.  Since currently you have 
to specify one or the other, either limiting your application to local connections only, or using a 
relatively heavyweight IP or other networking protocol when its overhead wasn't necessary, OR 
coding in unpleasant and inelegant conditionals to detect which situation you're in, for each 
connection or message.</p>

<p>Yick.  It would be really really nice if, instead of having to say "I want local namespace" or "I 
want 
internet namespace", you could just tell the kernel "I want a socket", and the kernel would 
determine based on the destination of your message what type of internal semantics was 
needed.  That way, you could code for both local performance and network transparency.</p>

<p>Along with that, I could see real value in adding permissions to sockets themselves.  Right 
now, 
you can get permissions on Unix domain sockets through the filesystem, but internet sockets 
don't have that protection.  If you could, instead, assign permissions to a socket itself, you could 
have a daemon that would only accept connections from certain users, or with certain credentials 
such as RSA keys or Kerberos tickets.</p>

<p>Alternatively, imagine making ALL sockets files, including internet domain sockets.  Now, a 
socket would have a file name, no matter what namespace or protocol you use, and you would 
still get the benefit of permissions on the sockets.  Plus, instead of using special system calls to 
connect with them, all you'd need is calls to open(), read(), write(), and close().  A server program 
would just call "makesocket()", which would take parameters for address, protocol, port, and so 
on, to create a socket, and then start reading on it (assuming blocking I/O); a client would call 
"makesocket()" and then open it to start writing data.  The kernel would handle connection 
details (if TCP or something else connection-oriented), or else just start sending datagrams (UDP 
or something else connectionless) or byte streams (address was for a local socket), and neither 
the client nor server programs themselves would need to know or care where the connection was 
coming from.</p>

<p>Hmm...now that I think about it, this has potential.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192478/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2006 5:47 UTC (Mon)
                               by <b>BrucePerens</b> (guest, #2510)
                              [<a href="/Articles/192483/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <i>I'm curious what a new, socket-replacing API would look like.</i><p><blockquote><pre>
open("/net/localhost/http", O_RDWR, 0)</pre></blockquote><p>Maybe this is not quite what you were asking for :-) . Of course, it's inspired by Plan 9. Using this, or using the socket calls, you get back the same object: a file descriptor. I think socket calls come from BBN's ARPA-sponsored Unix TCP/IP implementation, filtered through Berkeley BSD. They are indeed non-Unix-like, as are the net devices which live in their own unique name space.<p>Once you get the FD, you can call magic DMA functions on it as Ulrich proposes, which should be valid for plain files, not just network devices. Sometimes, however, what you need to do will fit the simpler sendfile().<p><i>Bruce</i>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192486"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2006 6:59 UTC (Mon)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/192486/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <pre>
The (a) problem with
   open("/net/localhost/http", O_RDWR, 0)
type approaches is that they combine "socket" and "connect" into one
call, and so there is no room for doing anything in between like bind
or setsockopt.  Those things aren't always needed, but sometimes they are.

You could try
  open("/net/local/http:bind=1023;sourceaddr=xx.xx.xx.xx;tcp_syncnt=5")
but I don't think you would get very far.

Unfortunately IPC is simply very different from for file IO and trying
to use the same API will be a problem.  Having an open_url library call
is about the best you can do.
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192486/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192526"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2006 15:14 UTC (Mon)
                               by <b>mheily</b> (subscriber, #27123)
                              [<a href="/Articles/192526/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Or better yet, extend the path heirarchy to include the IP address and port, then allow setsockopt to operate on file descriptors:<br>
<p>
fd = open("/net/localhost/ip/192.168.0.1/1023", O_RDWR, 0);<br>
setsockopt(fd, O_TCPSYNCNT, 5);<br>
<p>
You could bind to all interfaces by binding to 0.0.0.0 like so:<br>
<p>
fd = open("/net/localhost/ip/0.0.0.0/1023", O_RDWR, 0);<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192526/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor192482"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2006 6:15 UTC (Mon)
                               by <b>drag</b> (guest, #31333)
                              [<a href="/Articles/192482/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      The way things go everything should be network capable.<br>
<p>
In fact there was a group that did a presentation this year at the Usenix conference that did something very odd with computers buses and IP.<br>
<p>
Basicly they made the entire computer and all the communication run IP.<br>
See <a href="http://www.usenix.org/events/usenix06/tech/ben-yehuda.html">http://www.usenix.org/events/usenix06/tech/ben-yehuda.html</a><br>
<p>
Of course it's closed to non-members until next year.. (Is anybody here a member?)<br>
<p>
The way things are going pretty soon ethernet networks will be faster then local disk I/O. If latencies decrease along with that, or something like that, then shared memory scemes may start to work. <br>
<p>
Distributed operating systems maybe? Or something like treating a small cluster of machines as a single Numa machine with single kernel?<br>
<p>
If most IPC stuff uses something that could just as easily be local as network'd then that would make something like that more easily workable. Like how X is mostly network transparent.<br>
<p>
er.. or something like that.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192482/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192492"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2006 9:39 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/192492/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I am a member and went and read the paper.<br>
<p>
what they did was to create a pci card that claimed to be a VGA/keyboard/mouse card and remoted that out to another machine via IP (the purpose being to investigate the potential for more 'legacy free' motherboards, including being free of any graphics, keybard, usb, IDE, etc ports)<br>
<p>
they found a 40-60% performance hit for doing so, but point out that normal sysadmin tasks don't use these channels so it was deemed acceptable.<br>
<p>
while this is a very interesting idea for server manufacturers (and performance can be improved with a custom ASIC instead of the slow FPGA)it's of much less interest for home use (where you don't normally have another machine to serve as the head for your systems, and gamers aren't willing to sacrafice any performance)<br>
<p>
while an interesting paper it doesn't seem to be very relavent to the issues being dicussed here.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192492/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192494"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2006 10:03 UTC (Mon)
                               by <b>drag</b> (guest, #31333)
                              [<a href="/Articles/192494/">Link</a>] 
      </p>
      
      </div>
      </summary>
      ah, I see.<br>
<p>
Thank you. I was curious about what exactly they were talking about.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192494/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor194175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Old news?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2006 5:36 UTC (Fri)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/194175/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I'm fairly sure I've seen cards on the market that do exactly that - and have for a while. The IBM RSA (Remote Supervisor Adapter) comes to mind, and I think Dell do something similar for their servers.<br>
<p>
(By the way: I WANT ONE VERY BADLY. I hate the way x86 servers - even Intel server boards etc - can't handle serial console access for POST and BIOS. It's completely retarded, and one area where Sun has been trouncing `PC' servers for years.).<br>
<p>
There are also older approaches, such as the `PC Weasel' VGA+keyboard -&gt; serial console cards that've been around for yonks.<br>
<p>
That said, you just wrote a summary, so I'm sure there's more in the details.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/194175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor192457"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2006 15:55 UTC (Sun)
                               by <b>dps</b> (guest, #5725)
                              [<a href="/Articles/192457/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      One of the limitations of poll(2) and select(2) is that to deteremine which file descritpitors met the conditions you need to use a loop. If there are a large number of sockets and high preformance is critical is arguably suboptimal. Swithcing to SIGIO is not a complete solution becuase two fd's changing generate only one SIGIO, unless I have misunderstood something.<br>
<p>
An equivialnet interface which more directly indicate the file descriptions that met the conditions would be useful.<br>
<p>
One could propose implementing zero copy I/O by marking the pages that read() or write() refer to copy on write, using them directly in kernel space, and giving those that scribble on those pages a copy. I can see that read(2) might need to know this happenned and perform a copy after all. Disclaimer: I have not investigated the limitations of real hardware or size of any mm changes required.<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192457/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192461"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2006 17:16 UTC (Sun)
                               by <b>cventers</b> (guest, #31465)
                              [<a href="/Articles/192461/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; One could propose implementing zero copy I/O by marking the pages that</font><br>
<font class="QuotedText">&gt; read() or write() refer to copy on write, using them directly in kernel</font><br>
<font class="QuotedText">&gt; space, and giving those that scribble on those pages a copy. I can see</font><br>
<font class="QuotedText">&gt; that read(2) might need to know this happenned and perform a copy after</font><br>
<font class="QuotedText">&gt; all. Disclaimer: I have not investigated the limitations of real</font><br>
<font class="QuotedText">&gt; hardware or size of any mm changes required.</font><br>
<p>
Something like this was already proposed. The trouble is that the faulting <br>
process is fairly expensive, and once you have to do the copy _plus_ the <br>
TLB flushing you've just spent measurably more time than you would have <br>
just doing the copy in the first place.<br>
<p>
Copy on write is good in some places. During a fork, you have to <br>
invalidate the TLB anyways, so it doesn't hurt too much to implement CoW <br>
there (especially since many of the pages won't ever be copied, either due <br>
to the application calling execve() or the application being a daemon like <br>
Apache wherein every child only has some portion of non-shared data).<br>
<p>
But playing tricks with virtual memory elsewhere (such as in the <br>
networking hot path) is a really bad idea.<br>
<p>
Further discussion: <a href="http://kerneltrap.org/node/6506">http://kerneltrap.org/node/6506</a><br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192461/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor192470"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2006 19:10 UTC (Sun)
                               by <b>busterb</b> (subscriber, #560)
                              [<a href="/Articles/192470/">Link</a>] 
      </p>
      
      </div>
      </summary>
      There are a number of poll/select alternatives in various operating 
systems that work around this limitation by returning a list of pointers 
to only the descriptors that have received an event. On Linux, see 
epoll(4). <a href="http://www.monkey.org/~provos/libevent/">libevent</a> 
is a nice library that abstracts away OS-specific mechanisms such as 
these.
      
          <div class="CommentReplyButton">
            <form action="/Articles/192470/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor192514"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2006 13:01 UTC (Mon)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/192514/">Link</a>] 
      </p>
      
      </div>
      </summary>
      This is where real-time signals come in. They queue, so if two signals were sent you receive two (mostly). You can also arrange to have data attached to the signal so you know who sent it.<br>
<p>
I say mostly because there's one caveat: while the signals do queue, they don't queue indefinitly. I think linux cuts the queue at 32. Once the queue is full, the program has to go back to polling the sockets, which is what you're trying to avoid.<br>
<p>
I beleive that's the reason they never caught on.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192514/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor194169"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2006 4:43 UTC (Fri)
                               by <b>efexis</b> (guest, #26355)
                              [<a href="/Articles/194169/">Link</a>] 
      </p>
      
      </div>
      </summary>
      ...or even swapping with a fresh page? For example, you allocate a 4k page, construct the message, and 'send' it. At that moment, the page table entry that the user process sees is swapped with the one the kernel/driver sees. The user process now has an empty page at that location, ready to write the next message into, and the kernel has access to the page to send to the device.<br>
<p>
Same with recieving; device writes page to memory, kernel figures out where it has to go, and adds it to the virtual address space of that process where the process has requested it. That page is now allocated to that process, so the next read would come into a different address. There's no need for copy-on-write, as a page is no longer needed after being passed along, so an empty page in it's place would suffice.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/194169/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor192505"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other headers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2006 11:50 UTC (Mon)
                               by <b>christian.convey</b> (guest, #39159)
                              [<a href="/Articles/192505/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      I hope this question isn't born out of ignorance...<br>
<p>
The DMA idea sounds great, but I'm curious how this works when protocol layers will want to add headers to the region of memory that exactly preceeds my application-level data.<br>
<p>
For example, suppose I have application-data messages that are 256 byte long.  So I request a 256-byte-long user-space DMA region, and it's mapped to my process' VM address range x10000000 - x100000FF.  And I then populate all 256 bytes of that region with application-level data.<br>
<p>
If the TCP and IP layers are going to bolt their headers onto the beginning of the data I'm sending, won't each of those layers (1) allocate a buffer big enough for that layer's header + the data from the higher protocol level, and then (2) copy the higher-level's data into that new buffer?  If so, I don't see how zero-copy is achieved.<br>
<p>
It seems to me like we'd almost need the application to announce the purpose for which it intends to use the DMA region, so that the allocator can include extra space at the beginning/end for the network stack to use.<br>
For example (not ideal, but just to clarify my point):<br>
   int dma_alloc(AF_INET, SOCK_STREAM, dma_mem_t *handle, size_t size, int flags);<br>
<p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192505/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192532"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other headers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2006 15:55 UTC (Mon)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/192532/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      not nessasarily, the kernel support scatter-gather internally which would let you identify the TCP header (in one area of memory) and the data (in another area or areas of memory) and tell the driver where they are, the driver will get all the pieces in one operation (this is even easier with an IOMMU, with that the kernel can program the address space so that the driver doesn't know that the pieces are seperated)<br>
<p>
I don't know if this can be done with the userspace DMA work, but I'm not seeing a reason it couldnt'.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192532/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192911"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other headers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2006 18:33 UTC (Wed)
                               by <b>mikov</b> (guest, #33179)
                              [<a href="/Articles/192911/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      Do all (most) Ethernet adapters support scatter-gather DMA ?<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192911/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192919"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other headers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2006 19:11 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/192919/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      the higher-end cards support scatter-gather, but with an Opteron and it's IOMMU this functionality is available without the card needing to support it (the IOMMU remaps the address space so that the card thinks it's doing a old-fashiond single-area DMA, when it's really pulling/pushing the info to multiple sections of ram)<br>
<p>
David Lang<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192919/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192974"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other headers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2006 1:11 UTC (Thu)
                               by <b>mikov</b> (guest, #33179)
                              [<a href="/Articles/192974/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Thanks for pointing this - I must be falling behind the times because I didn't know about Opteron's IOMMU. I found a good description here: <a href="http://www.amd.com/us-en/assets/content_type/white_papers_and_tech_docs/34434.pdf">http://www.amd.com/us-en/assets/content_type/white_papers...</a><br>
<p>
Is there equivalent functionality in Intel's chipsets (since they can't put it in the CPU) ?  If not, it doesn't seem prudent to rely on it for zero-copy. <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192974/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor192978"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">What about other headers?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2006 1:51 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/192978/">Link</a>] 
      </p>
      
      </div>
      </summary>
      My understanding is that the Intel chips do not have an IOMMU at this time.<br>
<p>
however this just means that the kernel and drivers have to fall back to the non-zero-copy mechanism if the hardware doesn't support scatter-gather nativly<br>
<p>
it's a matter of useing it if it's there, and doing the best you can if it's not (and remember that if you compile the kernel for Opteron-only as opposed to K8 architecture you get more performance becouse you get to leave out the tests for the IOMMU and the code to handle it, so it doesn't always cost you :-)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/192978/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor193209"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory mapped files</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2006 10:44 UTC (Fri)
                               by <b>addw</b> (guest, #1771)
                              [<a href="/Articles/193209/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Will you be able to do this with memory mapped files ?<br>
<p>
If so things like samba &amp; apache could benefit greatly.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/193209/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor194253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">OLS: A proposal for a new networking API</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2006 21:37 UTC (Fri)
                               by <b>krause</b> (guest, #39696)
                              [<a href="/Articles/194253/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Why not use the Sockets Extensions API which provide both explicit memory management which is suitable for copy avoidance as well as asychronous communication and event management calls?  The API is available today from the OpenGroup and was developed by Socket implementers based on experience with a variety of Socket and AIO / POSIX implementations.  <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/194253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2006, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
