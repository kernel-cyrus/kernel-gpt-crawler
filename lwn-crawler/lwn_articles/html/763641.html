        <!DOCTYPE html>
        <html lang="en">
        <head><title>C considered dangerous [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/763641/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/763253/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/763641/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>C considered dangerous</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>August 29, 2018</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2018-Linux_Security_Summit_NA">LSS NA</a>
</div>
<p>
At the North America edition of the <a
href="https://events.linuxfoundation.org/events/linux-security-summit-north-america-2018/">2018
Linux Security Summit</a> (LSS NA), which was held in late August in Vancouver,
Canada, Kees Cook gave a presentation on some of the dangers that come with
programs written in C.  In particular, of course, the Linux kernel is
mostly written in C, which means that the security of our systems rests on
a somewhat dangerous foundation.  But there are things that can be done to
help firm things up by "<q>Making C Less Dangerous</q>" as the title
of his talk suggested.
</p>

<p>
He began with a brief summary of the work that he and others are doing as
part of the <a
href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project">Kernel
Self Protection Project</a> (KSPP).  The goal of the project is to get
kernel protections merged into the mainline.  These protections are not
targeted at protecting user-space processes from other (possibly rogue)
processes, but are, instead, focused on protecting the kernel from
user-space code.  There are around 12 organizations and ten individuals
working on roughly 20 different technologies as part of the KSPP, he said.   The
progress has been "slow and steady", he said, which is how he thinks it
should go.
</p>

<a href="/Articles/763644/">
<img src="https://static.lwn.net/images/2018/lssna-cook-sm.jpg" border=0 hspace=5 align="right"
alt="[Kees Cook]" title="Kees Cook" width=214 height=300>
</a>

<p>
One of the main problems is that C is treated mostly like a fancy assembler.
The kernel developers do this because they want the kernel to be as fast
and as small as possible.  There are other reasons, too, such as the need to do
architecture-specific tasks that lack a C API (e.g. setting up page tables,
switching to 64-bit mode).
</p>

<p>
But there is lots of undefined behavior in C.  This "operational baggage"
can lead to various problems.  In addition, C has a weak standard library
with multiple utility functions that have various pitfalls.  In C, the content
of uninitialized automatic variables is undefined, but in the machine code that it
gets translated to, the value is whatever happened to be in that memory
location before.  In C, a function pointer can be called even if the type
of the pointer does not match the type of the function being
called—assembly doesn't care, it just jumps to a location, he said.
</p>

<p>
The APIs in the standard library are also bad in many cases.  He asked: why
is there no argument to <tt>memcpy()</tt> to specify the maximum
destination length?  He noted a recent <a
href="https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html">blog
post</a> from Raph Levien entitled "With Undefined Behavior, Anything is
Possible".  That obviously resonated with Cook, as he pointed out his
T-shirt—with the title and artwork from the post.
</p>

<h4>Less danger</h4>

<p>
He then moved on to some things that kernel developers can do (and are
doing) to get away from some of the dangers of C.  He began with
variable-length arrays (VLAs), which can be used to overflow the stack to
access 
data outside of its region.  Even if the stack has a guard page, VLAs can
be used to jump past it to write into other memory, which can then be used
by some other kind of attack.  The C language is "perfectly fine with
this".  It is easy to find uses of VLAs with the <tt>-Wvla</tt> flag, however.
</p>

<p>
But it turns out that VLAs are <a href="/Articles/749064/">not just bad
from a security perspective</a>, 
they are also slow.  In a micro-benchmark associated with a <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=02361bc77888">patch
removing a VLA</a>, a 13% performance boost came from using a fixed-size
array.  He dug in a bit further and found that much more code is being
generated to handle a VLA, which explains the speed increase.  Since Linus
Torvalds has <a
href="https://lore.kernel.org/lkml/CA+55aFzCG-zNmZwX4A2FQpadafLfEzK6CC=qPXydAacU1RqZWA@mail.gmail.com/T/#u">declared
that VLAs should be removed</a> from the kernel because they cause security
problems and also slow the kernel down; Cook said "don't use VLAs".
</p>

<p>
Another problem area is <tt>switch</tt> statements, in particular where
there is no <tt>break</tt> for a <tt>case</tt>.  That could mean that the
programmer expects and wants to fall through to the next case or it could
be that the <tt>break</tt> was simply forgotten.  There is a way to get a
warning from the compiler for fall-throughs, but there needs to be a way to
mark those that are truly meant to be that way.  A special fall-through
"statement" in the form of a comment is what has been agreed on within the
static-analysis community.  He and others have been going through each of
the places where there is no <tt>break</tt> to add these comments (or a
<tt>break</tt>); they 
have "found a lot of bugs this way", he said.
</p>

<p>
Uninitialized local variables will generate a warning, but not if the
variable is passed in by reference.  There are some GCC plugins that will
automatically initialize these variables, but there are also patches for
both GCC and Clang to provide a compiler option to do so.  Neither of those
is upstream yet, but Torvalds has praised the effort so the kernel would
likely use the option.  An interesting side
effect that came about while investigating this was a warning he got about
unreachable code when he 
enabled the auto-initialization.  There were two variables declared just
after a <tt>switch</tt> (and outside of any <tt>case</tt>), where they
would never be reached.
</p>

<p>
Arithmetic overflow is another undefined behavior in C that can cause various
 problems.  GCC can check for signed overflow, which performs well
(the overhead is in the noise, he said), but adding warning messages for it does grow
the kernel by 6%;  making the overflow abort, instead, only adds 0.1%.
Clang can check for both signed and unsigned overflow; signed overflow is
undefined, while unsigned overflow is defined, but often unexpected.
Marking places where unsigned overflow is expected is needed; it
would be nice to get those annotations put into the kernel, Cook said.
</p>

<p>
Explicit bounds checking is expensive.  Doing it for
<tt>copy_{to,from}_user()</tt> is a less than 1% performance hit, but
adding it to the <tt>strcpy()</tt> and <tt>memcpy()</tt> families are
around a 2% hit.  Pre-Meltdown that would have been a totally impossible
performance regression for security, he said; post-Meltdown, since it is
less than 5%, maybe there is a chance to add this checking.
</p>

<p>
Better APIs would help as well.  He pointed to the evolution of
<tt>strcpy()</tt>, through <tt>str<b>n</b>cpy()</tt> and
<tt>str<b>l</b>cpy()</tt> (each with their own bounds flaws) to
<tt>str<b>s</b>cpy()</tt>, which seems to be "OK so far".  He also mentioned
<tt>memcpy()</tt> again as a poor API with respect to bounds checking.
</p>

<p>
Hardware support for bounds checking is available in the application
data integrity (ADI) feature for SPARC and is coming for Arm; it may also be
available for Intel processors at some point.  These all use a form of
"memory tagging", where allocations get a tag that is stored in the
high-order byte of the address.   An offset from the address can be checked
by the hardware to see if it still falls within the allocated region based
on the tag.
</p>

<p>
Control-flow integrity (CFI) has become more of an issue lately because
much of what attackers had used in the past has been marked as "no execute"
so they are turning to using existing code "gadgets" already present in the
kernel by hijacking existing indirect function calls.  In C, you can just call
pointers without regard to the type as it just treats them as an 
address to jump to.  Clang has a CFI-sanitize feature that enforces the
function prototype to restrict the calls that can be made.  It is done at
runtime and is not perfect, in part because there are lots of functions in
the kernel that take one unsigned long parameter and return an unsigned long.
</p>

<p>
Attacks on CFI have both a "forward edge", which is what CFI sanitize
tries to handle, and a "backward edge" that comes from manipulating the stack
values, the return address in particular.  Clang has two methods available
to prevent the stack manipulation.  The first is the "safe stack", which
puts various important items (e.g. "safe" variables, register spills, and
the return address) on a separate stack.  Alternatively, the "shadow stack"
feature creates a separate stack just for return addresses.
</p>

<p>
One problem with these other stacks is that they are still writable, so if
an attacker can find them in memory, they can still perform their attacks.
Hardware-based protections, like Intel's Control-Flow Enforcement
Technology (CET), <a href="/Articles/758245/">provides a read-only shadow
call stack</a> for return addresses.  Another hardware protection is <a
href="/Articles/718888/">pointer authentication</a> for Arm, which adds a
kind of encrypted tag to the return address that can be verified before it
is used.
</p>

<h4>Status and challenges</h4>

<p>
Cook then went through the current status of handling these different
problems in the kernel.  VLAs are almost completely gone, he said, just a
few remain in the crypto subsystem; he hopes those VLAs will be gone by 4.20 (or
whatever the number of the next kernel release turns out to be).  Once that
happens, he plans to turn on <tt>-Wvla</tt> for the kernel build so that
none creep back in.
</p>

<p>
There has been steady progress made on marking fall-through cases in
<tt>switch</tt> statements.  Only 745 remain to be handled of the 2311 that
existed when this work started; each one requires scrutiny to determine
what the author's intent is.  Auto-initialized local variables can be done
using compiler plugins, but that is "not quite what we want", he said.
More compiler support would be helpful there.  For arithmetic overflow, it
would be nice to see GCC get support for the unsigned case, but memory
allocations are now doing explicit overflow checking at this point. 
</p>

<p>
Bounds checking has seen some "crying about performance hits", so we are
waiting impatiently for hardware support, he said.  CFI forward-edge
protection needs <a href="/Articles/744507/">link-time optimization</a>
(LTO) support for Clang in the kernel, but it is currently working on
Android.  For backward-edge mitigation, the Clang shadow call stack is
working on Android, but we are impatiently waiting for hardware support for
that too.
</p>

<p>
There are a number of challenges in doing security development for the
kernel, Cook said.  There are cultural boundaries due to conservatism
within the kernel community; that requires patiently working and reworking
features in order to get them upstream.  There are, of course, technical
challenges because of the complexity of security changes;  those kinds of
problems can be solved.  There are also resource limitations in terms of
developers, testers, reviewers, and so on.  KSPP and the other kernel
security developers are still making that "slow but steady" progress.
</p>

<p>
Cook's <a href="https://outflux.net/slides/2018/lss/danger.pdf">slides
[PDF]</a> are available for interested readers; before long, there should
be a video available of the talk as well.

<p>
[I would like to thank LWN's travel sponsor, the Linux Foundation, for
travel assistance to attend the Linux Security Summit in Vancouver.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Kernel_hardening">Security/Kernel hardening</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-Hardening">Linux kernel/Hardening</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Security_Summit_North_America-2018">Linux Security Summit North America/2018</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/763641/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor763748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2018 21:46 UTC (Wed)
                               by <b>halla</b> (subscriber, #14185)
                              [<a href="/Articles/763748/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, I read Levien's blog post, and agreed, and got the t-shirt. Not for me, but for my wife; I don't wear t-shirts. But it was a very good read, and a good design. I wonder, was it Levien's own?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763831"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 16:06 UTC (Thu)
                               by <b>raph</b> (guest, #326)
                              [<a href="/Articles/763831/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I art-directed it. The actual execution of the image was by "dbeast32," as credited on my blog.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763831/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor763921"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 18:24 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/763921/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Indeed, it's an excellent read, but that phrase about "this can’t be done with a simple model where pointers are just numbers. The best way to understand the actual C standard is that programs run on an exotic, complex machine" just totally surprised me.</p>

<p>I mean: look on this <a href="https://en.wikipedia.org/wiki/IBM_Personal_Computer#Original_PC">exotic, complex machine</a>. Does it look familiar to you? Well, it should, there are billion or so of it's descendants, you probably used one of them at some point. How does it illustrate aliasing feature of C? Very simple: <a href="https://en.wikipedia.org/wiki/Intel_8088">8088</a> does not deal with floating point numbers, <a href="https://en.wikipedia.org/wiki/Intel_8087">8087</a> does. And, more importantly, in these early years that separate piece of silicone used DMA to write results of operations - <b>completely asynchronyously</b> from operations executed on main CPU. Which means that if you write <code>float</code> into memory and then read <code>int</code> from that some piece of memory - you could get old value, new value, or, theoretically, even some mix of these two (although that later version never happen on original IBM PC). Heck, it's easy to imagine simple modification of that scheme where attempt to access the same memory from both 8088 and 8087 would just crash the whole system... or corrupt memory somewhere else.</p>

<p>Keep that real world example of aliasing violation disaster in mind when you read specs... and suddenly they stop being exotic and complex and become easy to see and understand! No need for tagging and virtual machines, just an old piece of silicone which is very simple (by today's standards).</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/763921/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 22:48 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/763940/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Small nitpick and a pet peeve: CPUs are built with silicon. Breast enhancements are built with silicone.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor763749"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2018 22:44 UTC (Wed)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/763749/">Link</a>] (28 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure another argument to memcpy would help; unlike with strcpy, you have the number of bytes that would be copied anyway. The common cases for getting it wrong are (a) you copy something into a buffer that you think is big enough, but is actually not the size you expected, in which case you'd just pass the wrong length and (b) you copy something into a buffer that's big enough, but you're not putting it at the beginning, in which case you'd probably use the total length instead of the remaining length.<br>
<p>
Also, chances seem slim that the caller will do something secure in the case where memcpy stops early, given that they didn't think to compare lengths and do something particular in that situation.<br>
<p>
I could see having an "end of allocation" value that you get from your allocator and pass around along with your pointers, which has the advantage that getting it wrong is likely to be extremely obvious, it's hard to synthesize it yourself (which you might get wrong), and you don't need to adjust it (ditto).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763749/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 1:12 UTC (Thu)
                               by <b>balkanboy</b> (guest, #94926)
                              [<a href="/Articles/763756/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sound good, though ultimately I'd like kernel devs to adopt Rust as their main Linux kernel development language. Beats the crap out of C and C++ combined. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763974"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2018 11:23 UTC (Sun)
                               by <b>xav</b> (guest, #18536)
                              [<a href="/Articles/763974/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There are a number of challenges in doing security development for the kernel, Cook said. There are cultural boundaries due to conservatism within the kernel community;</font><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763974/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor763762"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 4:44 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/763762/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What you want is basically memcpy_s: <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/memcpy-s-wmemcpy-s">https://docs.microsoft.com/en-us/cpp/c-runtime-library/re...</a><br>
<p>
It's surprisingly useful. I wish C11 Annex K (the standard that describes the *_s functions) had taken off outside the Windows world. The annex K functions have much nicer properties than the BSD-style "safe" ones (like strlcpy). In particular...<br>
<p>
<font class="QuotedText">&gt; I'm not sure another argument to memcpy would help; unlike with strcpy, you have the number of bytes that would be copied anyway</font><br>
<p>
Sometimes, you use only part of a larger buffer. Passing in the buffer size can catch situations in which your partial-buffer size accidentally grows larger than the buffer.<br>
<p>
<font class="QuotedText">&gt; Also, chances seem slim that the caller will do something secure in the case where memcpy stops early</font><br>
<p>
You're right: there's nothing secure that can be done generically in this situation. That's why memcpy_s just aborts. In the kernel, that would be a panic. A panic is just a DoS and is much better than an escalation of privilege attack.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763762/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763834"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 16:48 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/763834/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      They look useful, but...
<blockquote>If the source and destination overlap, the behavior of memcpy_s is undefined.</blockquote>
How hard would it have been to fix that sharp edge at the same time as the other things?  It could just be defined as equivalent to memmove_s() in that case.  Hopefully a future version of the standard will tidy that up.
      
          <div class="CommentReplyButton">
            <form action="/Articles/763834/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763852"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 21:49 UTC (Thu)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/763852/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Only people using x86 compatible Core2 or later CPUs think this is a good idea.<br>
<p>
memcpy and memmove are *NOT IDENTICAL*.<br>
<p>
That extra comparison to determine copy direction costs time and branch prediction failure. The only reason everyone seems to think it's free is that common CPU types now run ahead and prime the branch prediction.<br>
<p>
I had evidence from oprofile in 2005 that showed memmove was most definitely slower than memcpy. That was on Pentium 3 and 4. Pipeline bubbles on P4 were painful.<br>
<p>
Just like all the other sharp edges in C like pointer aliasing, programmers need to *read the documentation* and *know what they're doing* when using memcpy. Having it blow up their program is entirely fair.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763852/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 6:07 UTC (Fri)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/763865/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Having it blow up the program would be fine. But the standard says the behaviour is undefined. That allows for silent memory corruption or indeed anything else. If I wanted something marginally faster but which would magnify the effect of programmer error, I would use plain memcpy(). The whole point of the _s variants is to add extra safety, even if it does cost a couple of extra instructions. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763868"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 6:40 UTC (Fri)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/763868/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would probably be good enough to define memcpy_s() to write to only locations in the destination, and write values that are in the corresponding point in the source either before the operation or afterwards, independently for each location. If you don't realize the buffers overlap, and you intend to keep using the source buffer, memmove doesn't save you anyway. It's worth allowing memcpy_s to have the obvious performance optimization without also allowing the compiler to infer that the buffers don't overlap and start doing really unexpected things.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763868/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor764073"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 5:19 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/764073/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Generally nowadays memmove is *faster* than memcpy, by a remarkably wide margin for smallish N.<br>
<p>
Complicating the interface for this and similar functions amounts to piling deck chairs on the Titanic into an obstacle course.<br>
<p>
It is more than a little stupid to write a new program in C.  All the typical pitfalls of pointer manipulations just don't arise in C++. C++ does still have integer overflow UB, as does Rust, and anyway unsigned integers wrapping around is nowhere near so benign as many like to believe.<br>
<p>
There would be no problem with C++ in the Linux kernel if not for mindless bigotry, with many fewer opportunities for silly-bugger mistakes, and both faster and shorter code. It will happen eventually. It might happen first in FreeBSD, as the blinkered ancients there are closer to retirement.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764073/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764077"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 6:46 UTC (Tue)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/764077/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Generally nowadays memmove is *faster* than memcpy, by a remarkably wide margin for smallish N.</font><br>
<p>
That's absurd nonsense. You must be talking about different implementations of memcpy and memmove. so it's not an apples-to-apples comparison. You can always implement memcpy by taking memmove and baking in the memory-direction branches, which means that no matter how efficient your memmove, you can generate an even _more_ efficient memcpy out of it.<br>
<p>
I can imagine memmove and memcpy being equally fast, but memmove being faster, by doing more work? Something is clearly wrong with the comparison.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764077/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764228"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">memmove faster than memcpy for small N</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2018 23:03 UTC (Wed)
                               by <b>jreiser</b> (subscriber, #11027)
                              [<a href="/Articles/764228/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The key is "for small N".  The glibc implementation of memcpy favors speed for non-small N, and has several checks and conditional branches before doing much "useful work".  The penalty for a mis-predicted conditional branch is often about 12 cycles. The implementation of memmove has fewer initial checks (mostly for overlap or not), and starts doing "useful work" sooner.  For small N, the fewer mis-predicted conditional branches enable faster memmove.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764228/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764231"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">memmove faster than memcpy for small N</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2018 23:45 UTC (Wed)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/764231/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That makes no sense. A memcpy could turn those branches into unconditional jumps and avoid any mispredict penalties.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764231/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">memmove faster than memcpy for small N</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2018 3:42 UTC (Thu)
                               by <b>jreiser</b> (subscriber, #11027)
                              [<a href="/Articles/764237/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Code, please.  I'll bet a beer that your code will be slower for small N (or incorrect.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">memmove faster than memcpy for small N</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2018 6:55 UTC (Thu)
                               by <b>liw</b> (subscriber, #6379)
                              [<a href="/Articles/764250/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think both sides need to provide code and benchmarks to settle this question. Hypotheticals and claims based on mental models only go far. Even arguing based on code is insuffident, given how complex an issue performance analysis can be.<br>
<p>
I tried writing a benchmark. GCC optimised it away.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor764252"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">memmove faster than memcpy for small N</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2018 7:14 UTC (Thu)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/764252/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, you write the code. I'm not the one making the absurd claim. A program is never made slower by converting always-taken conditionals into jumps.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764252/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor766159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2018 18:14 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/766159/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; C++ does still have integer overflow UB, as does Rust</font><br>
<p>
No, Rust defines integer overflow as twos-complement (though in debug builds it will panic). You can use an always-panicking addition however, but that's not the default.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/766159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor763957"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2018 16:12 UTC (Sat)
                               by <b>rurban</b> (guest, #96594)
                              [<a href="/Articles/763957/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; there's nothing secure that can be done generically in this situation. That's why memcpy_s just aborts. In the kernel, that would be a panic. A panic is just a DoS and is much better than an escalation of privilege attack.</font><br>
<p>
Wrong. memcpy_s does not abort, it returns an error code. With the safeclib (which can be used with the kernel) it returns ESNOSPC: <a rel="nofollow" href="https://github.com/rurban/safeclib/blob/master/src/mem/memcpy_s.c">https://github.com/rurban/safeclib/blob/master/src/mem/me...</a><br>
<p>
The kernel code can then decide what to do. It doesn't need to be a panic.<br>
<p>
Regarding overlap: memcpy_s detects EOVERFLOW and ESOVRLP. The slow variant memmove_s does allow overlapping regions, but is much slower. People demand a fast memcpy. The safeclib with clang5+ even has a faster memcpy_s than the optimized glibc assembler variants. clang can do these optimizations much better than the handwritten assembler. gcc not so.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763957/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763958"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2018 17:31 UTC (Sat)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/763958/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Wrong. memcpy_s does not abort, it returns an error code.</font><br>
<p>
Wrong. Annex K functions call the global error handler on constraint violation, which almost always aborts, at least in any sane implementation. Yes, you can set it to do something else, and if the error handler returns, memcpy_s will return an error code. I would not recommend using the functions this way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763958/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor763765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 6:59 UTC (Thu)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/763765/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>I'm not sure another argument to memcpy would help; unlike with strcpy, you have the number of bytes that would be copied anyway.</blockquote>

Yes.  So now the programmer has two numbers, and only one parameter.  What will he do?  Will he write a long sequence that takes both numbers into account? Or will he just call memcpy() with the source length, because he knows that the destination buffer is bug enough?  Maybe he is right in his knowledge, and maybe that knowledge does not become wrong during maintenance.  But would you bet your program's security on that?

<p>Better give him a library function with two length parameters, and an appropriate reaction (probably reporting an error) if the destination buffer is too small.
      
          <div class="CommentReplyButton">
            <form action="/Articles/763765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 7:47 UTC (Thu)
                               by <b>rschroev</b> (subscriber, #4164)
                              [<a href="/Articles/763769/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>&gt; ... because he knows that the destination buffer is <b>bug</b> enough</blockquote>

Well played, sir :)
      
          <div class="CommentReplyButton">
            <form action="/Articles/763769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor763929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 20:46 UTC (Fri)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/763929/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm sorry but this is nonsense. memcpy copies a fixed number of bytes from a source buffer to a destination buffer. This means it's up to other code to ensure that the destination buffer is large enough. Considering that the number of bytes which will be copied is necessarily known, that's easy enough to do. This is a code correctness issue and the bug (buffer to small) doesn't go away because memcpy compares some random numbers.<br>
<p>
I mean, your fictional programmer who can't be trusted to get something as simple as that right suddenly can be trusted to always pass another parameter reflecting the actual size of the buffer correctly? How so? Why shouldn't he just pass (size_t)-1 because he knows "the buffer will be big enough", IOW, doesn't care?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763955"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2018 14:04 UTC (Sat)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/763955/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, a sloppy and careless programmer will write dangerous code with memcpy_s() or any other routine. And the elite-level programmer will use memcpy() and do so safely, because he or she has carefully tracked the sizes of all buffers and not made any mistakes. It’s the average schmoes in the middle, who do our best but are fallible, who can be helped by an interface that takes some redundant information. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763955/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764006"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2018 15:49 UTC (Mon)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/764006/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All humans are fallible (and all computer are prone to mechanical defects:-) but that's besides the point.<br>
<p>
The interesting question is "Does one gain anything tangible by passing a destination buffer size to a block memory copy routine which already takes a number-of-bytes-to-copy parameter" and the answer is no:  The application programmer still has to ensure that the buffer whose address is passed is large enough so that the intended number of bytes can be copied into it. Ie, the only change is that the programmer now has to track two lengths instead of one.  Assuming that tracking one length correctly is already considered too difficult for people to do reliably, how can the situation possibly be improved by introducing another length value application programmers have to worry about?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764006/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2018 8:56 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/764156/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Let's take a look at an example:

<pre>
char buf[BUFLEN];
</pre>

And we want to copy len bytes from src to buf, and we know that len&lt;=BUFLEN.  Doing the copy with

<pre>
memcpy(buf,src,len);
</pre>

would be correct, as would be

<pre>
memcpy_s(buf,BUFLEN,src,len);
</pre>

Now, during maintenance, there are changes that can cause len&gt;BUFLEN.  Now the first variant has a buffer overflow, while the second does not (but, as written, does not report the error).  Tracking BUFLEN and len is not the problem here; it's tracking whether the assumption implied in the memcpy-using code is true.

<p>The tangible benefit that one gets with the memcpy_s variant is that we do not get a buffer overflow even if there is a mistake in tracking whether the assumption is true.  True, we do not get that benefit if we write the wrong value as the second parameter of memcpy_s, but that's a less likely mistake in this case, and probably in many others.

<p>You can make the assumption explicit by writing

<pre>
assert(len&lt;BUFLEN);
</pre>

before the memcpy, but then you have to "track two lengths" again, and in addition, assertion checking can be disabled, or the length in the memcpy can be changed without changing the assertion.

      
          <div class="CommentReplyButton">
            <form action="/Articles/764156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2018 9:08 UTC (Wed)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/764158/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To be fair, in your example the size of the buffer could also be changed without changing BUFLEN (which is your objection to the assert), so you should write<br>
<p>
memcpy_s(buf,sizeof(buf),src,len);<br>
<p>
in this case, I guess.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2018 9:23 UTC (Wed)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/764159/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, that's even better.  I was actually thinking about the maintenance programmer changing the len parameter of memcpy (to, say, len+a-b), and forgetting to change the assertion; there are often stale comments, so I would not be surprised about stale assertions (unless the tests cause them to trigger).
      
          <div class="CommentReplyButton">
            <form action="/Articles/764159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor764162"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2018 10:12 UTC (Wed)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/764162/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just be careful if someone might move that into a separate function like "void do_copy(char buf[BUFLEN], ...) { memcpy_s(buf, sizeof(buf), ...); }", and either ignores compiler warnings or is using an older compiler, since sizeof(buf) is now 8 regardless of BUFLEN. C is fun. Better to use a decent ARRAY_SIZE macro (like the one in the Linux kernel) that fails to compile if the argument is not an array.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764162/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor764163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2018 10:21 UTC (Wed)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/764163/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unless, of course, 'buf' is just a raw pointer -- then sizeof(buf) won't give you what you want.<br>
<p>
(Personally, most uses of 'memcpy' in my code involve assembling chunks of data into a buffer.  Nearly all of the memcpy()s' destinations are at nonzero offsets of the original buffer, so memcpy_s() really doesn't do me any good...)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor764215"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2018 20:12 UTC (Wed)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/764215/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, for the sake of the contrived example, let's assume that "during maintenance",<br>
<p>
memcpy_s(buf, BUFLEN, src, len)<br>
<p>
is changed to<br>
<p>
memcpy_s(src, len, buf, BUFLEN)<br>
<p>
now, there's no buffer overflow but likely a very serious memory corruption problem.<br>
<p>
There's exactly no reason for this assumption except that's it's another way to break the working code but there wasn't any reason for your assumption, either.<br>
<p>
<p>
<p>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764215/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor763759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 3:27 UTC (Thu)
                               by <b>nevets</b> (subscriber, #11875)
                              [<a href="/Articles/763759/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm curious to how shadow stacks will affect function graph tracer and kretprobes. Both rely on modifying the return address of the function in order to inject a trampoline to trace the function return.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor763768"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 7:14 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/763768/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Uninitialized local variables will generate a warning, but not if the variable is passed in by reference. </font><br>
<p>
BTW do the compiler options of the kernel still reject C99 variable declarations and if yes why?<br>
<a href="https://stackoverflow.com/questions/288441/variable-declaration-placement-in-c/4105334">https://stackoverflow.com/questions/288441/variable-decla...</a><br>
<p>
To more easily gauge stack sizes maybe?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763768/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 9:52 UTC (Thu)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/763772/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; do the compiler options of the kernel still reject C99 variable declarations</font><br>
<p>
[citation needed] for compiler options *ever* rejecting C99 variable declarations. And if they used to they definitely no longer do, just ‘git grep 'for (int '’ to find a few examples.<br>
<p>
It’s true that predominant style is to declare variables at the start of a function (I also like sorting declarations from the ones that are the longest ;) ).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763775"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 10:13 UTC (Thu)
                               by <b>lkundrak</b> (subscriber, #43452)
                              [<a href="/Articles/763775/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I also like sorting declarations from the ones that are the longest</font><br>
<p>
I recently learned that this is called a "Reverse Christmas Tree"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763775/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor763777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 11:06 UTC (Thu)
                               by <b>jani</b> (subscriber, #74547)
                              [<a href="/Articles/763777/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And if they used to they definitely no longer do, just ‘git grep 'for (int '’ to find a few examples.</font><br>
<p>
I occasionally do git grep popularity contests across the kernel tree to get a feeling whether the use of some function or construct or style is generally accepted or needs caution. Your suggested git grep leads to 28 matches, of which only 3 are actual kernel code and the rest are tools or scripts. Of about 83k for loops in the kernel tree. Conclusion, don't use it.<br>
<p>
Variable declarations inline in code are harder to grep, but the short gut feeling answer is, don't use them either. The declaration in the for loop is more likely to be accepted I think.<br>
<p>
<font class="QuotedText">&gt; It’s true that predominant style is to declare variables at the start of a function</font><br>
<p>
Not just at the start of a function. Declarations at the start of a block are widely used.<br>
<p>
Uniform style serves a purpose too, as it makes the code faster and easier for the human readers to grasp.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor763781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 12:30 UTC (Thu)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/763781/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the kernel we use -Wdeclaration-after-statement.  It causes a compile error.  I introduced one just to show what the warning looks like:<br>
<p>
drivers/video/fbdev/sm501fb.c: In function ‘sm501fb_start’:<br>
drivers/video/fbdev/sm501fb.c:1613:2: error: ‘for’ loop initial declarations are only allowed in C99 or C11 mode<br>
  for (int k = 0; k &lt; (256 * 3); k++)<br>
  ^~~<br>
<p>
It's an aesthetic preference.  <a href="https://lkml.org/lkml/2005/12/13/223">https://lkml.org/lkml/2005/12/13/223</a><br>
<p>
One thing that I do is I have "foo-&gt;bar" and I want to find out what type it is, so i highlight "bar" then I scroll to the top of the function where "foo" is declared and then I use cscope to jump to the type definition.  So it's nice if you kind of know all the variables are declared at the start of the function.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763783"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 12:34 UTC (Thu)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/763783/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In the kernel we use -Wdeclaration-after-statement.</font><br>
<p>
I stand corrected.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763783/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor763798"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 13:43 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/763798/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; One thing that I do is I have "foo-&gt;bar" and I want to find out what type it is, so i highlight "bar" then I scroll to the top of the function where "foo" is declared and then I use cscope to jump to the type definition.</font><br>
<p>
That sounds like a consequence of not using an IDE that has a decent go-to-declaration feature (which would work for local variables and would properly understand scopes, #includes, macros, etc). And you probably wouldn't even need to look at the original type definition, you could just put the mouse over 'bar' to get a tooltip showing its type, or press the autocomplete key after 'foo-&gt;' to see all the members and their types, or use one of several other features.<br>
<p>
So it's not only about aesthetic preferences of coding style, it's also about personal choice of editing tool that makes certain styles harder to work with. Since people get very attached to their tools, that seems an impossible conflict to resolve.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763798/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763801"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 14:37 UTC (Thu)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/763801/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hm...  It turns out that Vim can jump to the declaration.  I feel dumb now.<br>
<p>
I'm not actually too tied to Vim though and I really don't like cscope.  I'm not eager to use KDevelop.  What other IDEs are people using on Debian?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763801/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 7:11 UTC (Fri)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/763869/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well there's emacs, which supports it too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764064"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Finding the declaration of a variable in Emacs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2018 22:08 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/764064/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Well there's emacs, which supports it too.
</blockquote>
<p>
Do tell.  How do I point to a local variable use and have Emacs show me where its declaration is?
<p>
I know about Etags - But I don't think this is among its functions.

      
          <div class="CommentReplyButton">
            <form action="/Articles/764064/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Finding the declaration of a variable in Emacs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 9:34 UTC (Tue)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/764084/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can use exuberant-ctags. By default, it doesn't include local variables but you can have them with --c-kinds=+l.<br>
To produce file for emacs you also need -e.<br>
So something like:<br>
ctags -e --c-kinds=+l .<br>
<p>
Then you can jump to local variable declarations using M-.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor764357"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Finding the declaration of a variable in Emacs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 7, 2018 10:57 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/764357/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can have Semantic / CEDET show you the definition of the symbol under point after a short delay in the echo area via semantic-idle-local-symbol-highlight-mode, also enableable globally for all buffers, and automatically via adding global-semantic-idle-local-symbol-highlight-mode to semantic-default-submodes.<br>
<p>
Doing this for non-local symbols requires CEDET to know how to locate things in your project, which usually happens more or less automatically, particularly if you use etags or GNU GLOBAL.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764357/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor763840"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Searching LKML?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 17:39 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/763840/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It's an aesthetic preference. <a href="https://lkml.org/lkml/2005/12/13/223">https://lkml.org/lkml/2005/12/13/223</a></font><br>
<p>
Thanks for remembering this and digging out that sub-thread buried in another massive and totally unrelated thread, impressive feat. Now because lkml.org just went down right while I was browsing it, I went and found some alternative locations:<br>
<p>
<a href="https://marc.info/?l=linux-kernel&amp;m=113449080512291">https://marc.info/?l=linux-kernel&amp;m=113449080512291</a><br>
<a href="https://groups.google.com/d/msg/linux.kernel/e0W-NpF0Kr0/SCuxk_Qjj9AJ">https://groups.google.com/d/msg/linux.kernel/e0W-NpF0Kr0/...</a> (click on "Topic options-&gt;Tree view" below the Subject: to help with the thread dilution issue)<br>
<p>
I was once again amazed at how time-consuming it can be to search LKML archive(s) *even when* I already had the complete message information from lkml.org still cached in my browser window!<br>
<p>
Eventually I found that (my?) Google groups' default search option was sorting by date which is useless: <a href="https://groups.google.com/forum/#!searchin/linux.kernel/%22MUTEX$3A$20Introduce$20simple$20mutex$20implementation%22%7Csort:date">https://groups.google.com/forum/#!searchin/linux.kernel/%...</a><br>
Simply asking to "Sort by relevance" fixes it: <a href="https://groups.google.com/forum/#!searchin/linux.kernel/%22MUTEX$3A$20Introduce$20simple$20mutex$20implementation%22%7Csort:relevance">https://groups.google.com/forum/#!searchin/linux.kernel/%...</a><br>
<p>
Any additional "lkml search education" welcome (and sorry for being off-topic)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763840/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764090"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Searching LKML?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 11:41 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/764090/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have always used <a href="http://lkml.iu.edu/hypermail/linux/kernel/">http://lkml.iu.edu/hypermail/linux/kernel/</a> which is a normal readable mailman-style archive rather than one of these horrible modern ones which makes conversations almost impossible to follow. (Seriously, lkml.org throws away branches of the thread tree that you're just about to read so it can show the tree to you in a 5cm box, and then doesn't visibly offer a 'next in thread' button. What on earth were they thinking?!)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764090/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764109"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Searching LKML?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 15:00 UTC (Tue)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/764109/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Where has this been all my life!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764109/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor764136"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Searching LKML?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 17:02 UTC (Tue)
                               by <b>peda</b> (subscriber, #5285)
                              [<a href="/Articles/764136/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While I don't like every aspect of lkml.org, one thing it does is link things together even if time has passed.<br>
<p>
E.g. <a href="https://lkml.org/lkml/2018/8/30/877">https://lkml.org/lkml/2018/8/30/877</a> has a link to <a href="https://lkml.org/lkml/2018/9/1/41">https://lkml.org/lkml/2018/9/1/41</a> (and back).<br>
<p>
Now, that's only 2 days, but its different months/weeks/whatwever, and that tends to work very badly with archives of the style you prefer, as all threading is broken every so often.<br>
<p>
The above two messages in your preferred archive are<br>
<a href="http://lkml.iu.edu/hypermail/linux/kernel/1808.3/04944.html">http://lkml.iu.edu/hypermail/linux/kernel/1808.3/04944.html</a><br>
<a href="http://lkml.iu.edu/hypermail/linux/kernel/1809.0/00008.html">http://lkml.iu.edu/hypermail/linux/kernel/1809.0/00008.html</a><br>
<p>
Please tell me where the thread-next/thread-prev links for these two messages can be found in that archive, because I can't find them, and it really make the whole thing less appealing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764136/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764358"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Searching LKML?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 7, 2018 10:58 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/764358/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is the downside :( I wish Mailman next/prev links weren't constrained to within a single month/week like that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764358/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor763841"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 17:58 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/763841/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It's an aesthetic preference. <a href="https://lkml.org/lkml/2005/12/13/223">https://lkml.org/lkml/2005/12/13/223</a></font><br>
<p>
Well, I'm disappointed: I expected some technical reason and not just a pseudo-"readability" choice.  As pointed out there and/or in the stackoverflow discussion, if you can't easily find types in your function then you have a bigger problem because the function is too big in the first place.<br>
In some cases having the type closer to where it's used will actually make the type more obvious.<br>
Afraid people don't look at types often anyway - even less often than they should.<br>
<p>
In any case this entire readability debate weighs little compared to uninitialized variables which compilers may not all catch + the noise of compilers reporting false positives. No modern language forces declarations at the top, it's a legacy. Safer languages even tend to force the opposite.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763841/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor763780"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 12:26 UTC (Thu)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/763780/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; do the compiler options of the kernel still reject C99 variable declarations and if yes why?</font><br>
<p>
Unfortunately, yes:<br>
error: 'for' loop initial declarations are only allowed in C99 or C11 mode<br>
<p>
Kernel is -std=gnu89.<br>
<p>
<a rel="nofollow" href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=51b97e354ba9fce1890cf38ecc754aa49677fc89">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763780/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor763797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 13:38 UTC (Thu)
                               by <b>cyrus</b> (subscriber, #36858)
                              [<a href="/Articles/763797/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Clang was frequently mentioned in this article. If I followed the discussions correctly, Clang can successfully compile the kernel for various ARM flavors. The Chromebook Pixel, for instance, is shipped with a Clang-compiled kernel. What's the situation for x86, though? Last I heard the kernel now requires asm-goto for x86 which Clang does not support. What's the status of asm-goto support for Clang? When can we expect that the kernel will "just compile" and the compiled kernel will "just run" on x86?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763802"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 14:33 UTC (Thu)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/763802/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The minimum gcc version to compile the kernel has just been raised to 4.6 on all architectures (<a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=cafa0010cd51fb711fdcb50fc55f394c5f167a0a">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/...</a>), and clang still pretends to be gcc 4.2, so the kernel won't compile with clang anymore. It's not just a matter of the version number; the fallback code for compatibility with old gcc versions has been removed, and AFAIK clang doesn't implement all the new gcc features.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763802/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 16:27 UTC (Tue)
                               by <b>ndesaulniers</b> (subscriber, #110768)
                              [<a href="/Articles/764134/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've fixed this in: <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=815f0ddb346c196018d4d8f8f55c12b83da1de3f">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/...</a><br>
<p>
Clang can compile a working kernel for x86_64 if the asm goto #error is removed; asm-goto is under development in llvm currently.<br>
<p>
Clang can compile arm64 without CONFIG_LSE_ATOMICS.  -ffixed and friends need to be implemented.<br>
<p>
Other architectures aren't on my radar.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor763837"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 17:16 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/763837/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The Chromebook Pixel, for instance, is shipped with a Clang-compiled kernel. </font><br>
<p>
Much more than the Pixelbook, currently all devices running chromeos-4.4 and chromeos-4.14:<br>
<a href="https://chromium.googlesource.com/chromiumos/overlays/chromiumos-overlay/+/3d00e3bbbee48d185761b63%5E%21/#F0">https://chromium.googlesource.com/chromiumos/overlays/chr...</a><br>
<p>
That's a fairly large number of devices: <a href="https://www.chromium.org/chromium-os/developer-information-for-chrome-os-devices">https://www.chromium.org/chromium-os/developer-informatio...</a><br>
(not the one expected but the "Year of the Linux desktop" has finally arrived :-)<br>
<p>
Hint: check Kees' current employer.<br>
<p>
<font class="QuotedText">&gt; What's the situation for x86, though? </font><br>
<p>
? like most chromebooks the Pixelbook is x86<br>
<p>
<font class="QuotedText">&gt; When can we expect that the kernel will "just compile" and the compiled kernel will "just run" on x86?</font><br>
<p>
For reference:<br>
<a href="https://chromium.googlesource.com/chromiumos/third_party/kernel/+log/chromeos-4.4">https://chromium.googlesource.com/chromiumos/third_party/...</a><br>
<a href="https://chromium.googlesource.com/chromiumos/third_party/kernel/+log/chromeos-4.14">https://chromium.googlesource.com/chromiumos/third_party/...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763837/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor763832"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 16:41 UTC (Thu)
                               by <b>smitty_one_each</b> (subscriber, #28989)
                              [<a href="/Articles/763832/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; a function pointer can be called even if the type of the pointer does not match the type of the function being called—assembly doesn't care, it just jumps to a location</font><br>
<p>
Is C a honey badger at heart?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763832/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor763855"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2018 22:50 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/763855/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; He noted a recent blog post from Raph Levien entitled "With Undefined Behavior, Anything is Possible".</font><br>
<p>
tl;dr: for safety C is broken beyond repair. As a meta-assembler it was a "stroke of genius" but it just can't scale beyond that.<br>
<p>
<font class="QuotedText">&gt; <a href="https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html">https://raphlinus.github.io/programming/rust/2018/08/17/u...</a></font><br>
<font class="QuotedText">&gt; &gt; If one’s interest is in safe, portable code – C can be a very fine choice. One must use it well, though [...] C’s sharp edges can be managed safely two ways, at least: One is through careful use of well-designed coding standards. Large program authors should make key architectural decisions very early on, define a safe, constrained, style – and have the team stick to that style.</font><br>
<p>
In other words: 1. either your C project has a very expensive team of world-class rock stars, or: 2. your software is full of bugs and security holes cut by C' sharp edges. As observed in the mainstream (!) news almost every week.<br>
<p>
PS: C programmers shouldn't worry about their retirement; COBOL people can apparently still make a lot of money :-) <a href="https://www.npr.org/sections/money/2018/01/10/576879734/episode-489-the-invisible-plumbing-of-our-economy">https://www.npr.org/sections/money/2018/01/10/576879734/e...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763855/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor763873"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Switch-case fall-through dangerous?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 9:19 UTC (Fri)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/763873/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">where there is no break for a case. That could mean that the programmer expects and wants to fall through to the next case</font></blockquote>

<p>Pity that this is considered a &quot;dangerous&quot; aspect of the C language; I have been known to exploit case fall-through in some of my own code.  E.g. printing out a date based on an input string (think format string on <a href="http://man7.org/linux/man-pages/man1/date.1.html"><tt>date</tt> (1)</a>):</p>

<pre>
case 'Y':
  /* print century 2-digits only */
  /* NO break; here! */
case 'y':
  /* print 2-digit year */
  break;
</pre>

<p>I would imagine this is slightly faster (and smaller code) than isolating each case separately, but perhaps I'm wrong here... Of course, I was (am) careful to document this verbosely with a comment.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763873/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Switch-case fall-through dangerous?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 12:02 UTC (Fri)
                               by <b>karkhaz</b> (subscriber, #99844)
                              [<a href="/Articles/763881/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Certainly fall-through is useful, but the vast majority of case statements I've seen don't use it; this suggests that it should not be the default. With hindsight, breaking ought to be the default, and there should be a keyword called `fall` which does that explicitly.<br>
<p>
The article mentions that the comment is used by "the static analysis community," can anyone elaborate on this? In particular, is there an external tool that goes through the code looking for (the absence of) these comments? If so, I wonder whether a compiler extension might be better than an external tool; instead of a comment, there could actually be a `fall` keyword, together with a -Wfall-thru compiler switch that emits a warning if it sees a case that has neither a `break` nor a `fall`. With any luck, this keyword might even be adopted into the standard if it's useful. It would basically be a no-op in terms of emitted machine code, but the compiler could see and warn about its absence.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Switch-case fall-through dangerous?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 12:26 UTC (Fri)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/763884/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The compiler switch already exists for GCC 7, it is -Wimplicit-fallthrough. And it knows to how to parse a comment like /* fall through */ as described.<br>
<p>
The usage of comments as "keywords" to guide static analysis is a pretty old thing. The convention dates back at least to the original 'lint' tool for UNIX from 1978! See: <a href="http://files.cnblogs.com/files/bangerlee/10.1.1.56.1841.pdf">http://files.cnblogs.com/files/bangerlee/10.1.1.56.1841.pdf</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763886"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Switch-case fall-through dangerous?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 12:34 UTC (Fri)
                               by <b>karkhaz</b> (subscriber, #99844)
                              [<a href="/Articles/763886/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for this information! Though the use of comments seems ugly, like it would complicate the design of the compiler...compilers should be free to lex the comments out without considering the possibility that they contain interpretable information. On the other hand, I suppose comments are better than nonstandard keywords, which would tie you to using only compilers that understand them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/763886/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor763926"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Switch-case fall-through dangerous?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2018 19:00 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/763926/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Well, you could use C++, where it's <a href="https://en.cppreference.com/w/cpp/language/attributes/fallthrough">standard keyword</a> instead.
      
          <div class="CommentReplyButton">
            <form action="/Articles/763926/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor764083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 9:13 UTC (Tue)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/764083/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A thought which occurred to me only recently, despite spending years thinking about this: All this harping on on what "undefined behaviour" could or might be is nothing but a logic error commonly known as "appeal to ignorance". <br>
<p>
Behaviour the C standard doesn't define is just that: Behaviour the C standard doesn't define, hence, no information about it can be derived from this text. Other applicable documentation might, eg, according to ISO-C, arithmetic on void-pointers has undefined behaviour, yet, there's a longstanding gcc-extension to treat void-pointers like char-pointers in this respect, despite it's entirely unclear what - besides causing silent memory corruption - this is actually supposed to be good for (one can guess that "legacy GNU C" is "just more equal than other C", obviously, but that's just a guess some people might consider probable).<br>
<p>
In absence of such other documentation or other information on real world behaviour, there's not only no point in speculating wildy about what "undefined behaviour" could mean, it's also either fallacious or intellecutally dishonest: A claim of the form "We don't know that A is false, hence it could be true" or "We don't know that A is true, hence, it could be false" is a non-sequitur: Nothing follows from ignorance.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764089"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 11:14 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/764089/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Even if the behaviour is not defined by the standard, or by the compiler's documentation, it is implicitly defined by the compiler's implementation. The standard doesn't prohibit nasal demons, but you can look at GCC's code and see there is no possible way they can occur. Or you can take a more scientific approach, and make a hypothesis (aka speculation) and try to find evidence to disprove it, in the context of a specific compiler. None of that tells you definitively what another standards-conforming compiler might do, but in practice people only really care about a small group of compilers and compiler versions, and most them behave very similarly to each other. I don't think it's necessary or helpful to simply give up and say we can't even attempt to understand that behaviour.<br>
<p>
(Incidentally, I've found void pointer arithmetic convenient for things like "void create_packet(void *buf, Header *hdr, void *payload, size_t len) { memcpy(buf, hdr, sizeof(Header)); memcpy(buf + sizeof(Header), payload, len); }", since void* seems the appropriate type for buffers that don't correspond to a specific C type, and sometimes you want to refer to byte offsets within those buffers. Explicitly casting to char* every time you do arithmetic is ugly and semantically inappropriate.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764089/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764095"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 12:35 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/764095/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>The problem with defining behaviour in terms of "this specific implementation does this" is that absent some form of promise from the implementers (either because they promise to comply with a standard that does what you want, or because they document the behaviour you want as deliberate), you can't distinguish "this behaviour is a consequence of a compiler bug that will be fixed removing the desired behaviour" from "this is desirable behaviour that the implementers will try to keep" from "the implementers will treat the absence of this behaviour as a bug and fix it".
<p>This is especially true of behaviour that comes from interacting bugs - it may be true that with GCC 6.7.9.1 on an Intel Xeon E3-1285 v3 with a fixed microcode version and C code compiled with -march=haswell -O3 you get a behaviour you want, but if that's not promised and a <em>microcode</em> update breaks things, you're stuffed.
<p>Hence the interest in what is defined in documentation - yes, I can validate a given implementation's behaviour for a given machine if I so desire, but what I'm normally interested in is "if I upgrade my machine and/or compiler, will my code continue to do what I want?". Nasal demons is simply a short cut for "even though you could validate behaviour, because no-one is trying to maintain this behaviour in future, you don't want to depend on it."
      
          <div class="CommentReplyButton">
            <form action="/Articles/764095/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764139"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 20:08 UTC (Tue)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/764139/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This seems to be an entirely generic text which isn't related to the one I wrote, especially considering that I gave a specific example of documented gcc behaviour for a construct with undefined behaviour insofar the C standard is concerned.<br>
<p>
"Nasal daemon" and other such nonsense is just the appeal to ignorance I wrote about, though: Behaviour which isn't defined by ISO-C is not a defined phenomenon properties like "you don't want to depend on it" can be assigned to for some rational reason. Eg, the only I/O facilities defined by ISO-C are stdio-streams and no behaviour is defined for the case when data written by the stdio of one C implementation is later read via the stdio of a different implemention. It follows that the behaviour of a program compiled with clang is undefined whenever it tries to read data written by a program compiled with gcc. Surely, clang is something nobody would ever want to depend on!<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764139/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 20:38 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/764141/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>"Nasal demon" is just a short-cut to saying that "the behaviour of a program is not defined by the standards you are relying upon to define the progam's meaning, and thus anything could go". This isn't <em>just</em> the ISO C standard, but also POSIX, and even implementation defined standards; in the cases you're talking about, "nasal demons" is a distraction, as there <em>are</em> standards that define the behaviour in question, even if ISO C permits a wider variety of standards-compliant behaviour.
<p>Further, "undefined" behaviour in the sense that "nasal demons" refers to is more than just behaviour where the implementation defines it - it's behaviour where the implementation is allowed to refuse to define what it means. E.g. <tt>int i = 0; ++i++ += i++ + ++i;</tt> is a common example of undefined behaviour - because it breaks the rules on sequence points, the implementation does not have to give it any meaning at all.
      
          <div class="CommentReplyButton">
            <form action="/Articles/764141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2018 21:17 UTC (Tue)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/764143/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; "Nasal demon" is just a short-cut to saying that "the behaviour of a program is not defined by the standards you are relying upon to &gt; define the progam's meaning, and thus anything could go". </font><br>
<p>
As I already wrote: "It is unknown, hence ..." is logically invalid.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 5, 2018 8:45 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/764157/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Exactly, but that sort of reasoning about a standard is common - e.g. "The POSIX standard says that int must be at least 32 bits in size, therefore I can assume that long is 64 bits in size". The point of "nasal demons" is that it is equally correct to say "The POSIX standard says that int must be at least 32 bits in siz, therefore assuming long is 64 bits in size will make demons fly out of your nose" - both are logically invalid statements, but while the first sounds plausible, the second does not.
<p>In other words, it's a way of pointing out that your conclusion does not follow from your antecedents in a comical fashion, and thus that you need to go back and fill in your chain of reasoning.
      
          <div class="CommentReplyButton">
            <form action="/Articles/764157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764262"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2018 10:17 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/764262/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In other words, the well-known proof "reductio ad absurdam".<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764262/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor764340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2018 22:45 UTC (Thu)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/764340/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In theory, there is nothing but ignorance. September 7th, 2018 has never happened before, so we don't know what will happen on September 7th, 2018. In practice, we can usually use what has gone on in the past to get a good guess at what will happen in the future.<br>
<p>
At the extreme, C compilers, when encountering implementation defined behavior, have stopped compiling and ran a game. (Early versions of GCC did so upon encountering a #pragma in C code.) Current versions of GCC regularly assume that undefined behavior can't happen, meaning that conditional checks can be deleted; branches of "if" statements disappear and "while" loops are compiled into infinite loops. We have heard in practice lots of complaints about C compilers doing unexpected things in the presence of implementation defined behavior.<br>
<p>
Just as much to the point, ignorance is information. If we have no idea what's going to happen, then we should generally expect the unexpected; lacking knowledge, our presumptions about what is going to happen are just wrong.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 7, 2018 18:41 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/764410/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; At the extreme, C compilers, when encountering implementation defined behavior, have stopped compiling and ran a game.</font><br>
<p>
Given that C has always been considered a "super-assembly" language, and most of the undefined behaviours were, I believe, down to the fact that the original writers of C knew that different hardware behaves in different ways, I would have thought that the C spec should have said "When behaviours are undefined because different hardware behaves differently, it is down to the compiler writers to provide a definition for their implementation".<br>
<p>
Bit like the Z80 scenario where the right shift instruction behaved as expected (integer divide by two) but thanks to a bug the left shift did a "double and increment" operation. If the C language didn't specify the behaviour of a left shift thanks to this, then it should have placed the onus on the compiler writers to specify it, not just leaving the behaviour in doubt.<br>
<p>
(And this silicon bug really did exist, and quite a few assembler programs took advantage of it, I believe ... left-shift-and-increment it got known as :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764453"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2018 15:40 UTC (Sun)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/764453/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>The Z-80 <b>did</b> have a working shift left instruction (SLA), in addition to two working shift right instructions (SRA and SRL). The "bug" you are referring to is an undocumented opcode which, by chance, behaved like you describe.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764453/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764519"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2018 18:14 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/764519/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I heard it, it was undocumented BECAUSE it didn't work.<br>
<p>
You mention SRA and SRL. Therefore you should have a matching SLA and SLL. The story as I heard it was that some programmers used that exact logic, worked out what the opcode for SLL should be, and discovered what I called "shift left and increment".<br>
<p>
In other words, a perusal of the documentation led to people deducing a "missing" opcode, and when they tried it, it ALMOST did what was expected.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764519/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764522"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2018 19:17 UTC (Mon)
                               by <b>mgb</b> (guest, #3226)
                              [<a href="/Articles/764522/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You mention SRA and SRL. Therefore you should have a matching SLA and SLL.</font><br>
<p>
How would you have expected the functionality of these hypothetical SLA and SLL to have differed?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764522/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor764530"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2018 22:28 UTC (Mon)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/764530/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
The main difference between an arithmetic shift to the right and a logical shift to the right is that the logical shift will make the MSB zero while the arithmetic shift will keep the MSB (the sign of a signed number) whatever it was before the shift. This doesn't make a huge amount of sense when shifting to the left, because the LSB in a signed number isn't special, so processor makers often didn't bother with arithmetic shifts to the left (especially with the simpler late-20th-century-vintage CPUs).
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/764530/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor764487"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Undefined behaviour</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2018 15:08 UTC (Mon)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/764487/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><em>I would have thought that the C spec should have said "When behaviours are undefined because different hardware behaves differently, it is down to the compiler writers to provide a definition for their implementation".</em></blockquote>
<p>
The C standard, at least back when I was still programming in C, did in fact make that distinction. When dealing with a C implementation, you distinguish between behaviour that is specified in the standard, “implementation-defined behaviour” that is not specified in the standard but requires a consistent (and documented) approach by the implementation, and “undefined behaviour”, where anything can happen, including unpredictable and inconsistent effects.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/764487/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor764439"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous: function pointers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 8, 2018 17:02 UTC (Sat)
                               by <b>DHR</b> (guest, #81356)
                              [<a href="/Articles/764439/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"In C, a function pointer can be called even if the type of the pointer does not match the type of the function being called—assembly doesn't care, it just jumps to a location, he said. "<br>
<p>
This hasn't been true for a long long time.  ANSI/ISO C copied function prototypes from C++ for their first standard.  This made parameter types part of the type of a function type (and hence of a pointer to a function type).  You could willfully program in K&amp;R style function types but generally not by accident (or use casts).<br>
<p>
The one exception: it seems easy to declare a function with no parameters using an empty parameter list.  That is a K&amp;R declaration.  You are supposed to use "void" as the parameter list in the prototype.  Somewhat awkward.<br>
<p>
I haven't looked at the slides to see if this serious error is in them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764439/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor764578"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2018 16:53 UTC (Tue)
                               by <b>DHR</b> (guest, #81356)
                              [<a href="/Articles/764578/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"An interesting side effect that came about while investigating this was a warning he got about unreachable code when he enabled the auto-initialization. There were two variables declared just after a switch (and outside of any case), where they would never be reached."<br>
<p>
A declaration does not have to be reached unless it has an initializer (or is a VLA).  So these would probably be correct C, and perhaps meaningful.<br>
<p>
Any executable code between a switch head and the first case label (or other label) is unreachable and a good compiler should flag it.  Adding an auto-initializer carelessly triggers this problem.<br>
<p>
If a declaration in the switch body (and not further nested) has a scope covering the rest of the switch body.  So all cases.<br>
<p>
The unfortunate choice of  -Wdeclaration-after-statement means that placing a declaration at the start of a switch body is sometimes a good choice.<br>
<p>
A compiler should flag any unused variable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764578/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor764580"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous: VLAs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2018 17:04 UTC (Tue)
                               by <b>DHR</b> (guest, #81356)
                              [<a href="/Articles/764580/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't really like VLAs.  They don't fit well into the C type system.  They are not part of C++.  They are now only an optional part of C, if I remember correctly (the C Committee seems to regret their addition).<br>
<p>
Having said that, they were an attempt to cleanly replace alloca (an abomination).  Stack allocation is so much cheaper than heap allocation.  But of course there is a risk when stacks must be tightly bounded.<br>
<p>
Complaining that VLAs are expensive seems wrong.  If you don't need a dynamically-sized array, why are you using a VLA?  If you do need one, the only alternative is heap allocation, and that is more expensive and error-prone than stack allocation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764580/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764687"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous: VLAs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2018 11:53 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/764687/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Complaining that VLAs are expensive seems wrong. If you don't need a dynamically-sized array, why are you using a VLA? If you do need one, the only alternative is heap allocation, and that is more expensive and error-prone than stack allocation.
</blockquote>
Quite. But of course the problem with both alloca() and VLAs is the same as the problem with automatic variables: error handling. If you run out of stack space, there is nothing you can do: it's game over. In a language without exceptions, there aren't even any edges control flow could propagate down, and no way to get the error out. Meanwhile, malloc() has always been able to return NULL (though, again, since nobody other than sqlite tests these failure cases systematically, it is questionable whether this is terribly useful).
      
          <div class="CommentReplyButton">
            <form action="/Articles/764687/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764692"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous: VLAs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2018 13:06 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/764692/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The lack of error handling means it's only safe to use VLAs (or alloca) if you know a static upper bound on the size of the array, and it's small enough that you're confident it's never going to overflow the stack. But if you know an upper bound, why not just always allocate that much? Overallocating seems unlikely to have any performance impact in typical cases. And if the stack is too small for your constant-sized array, you'll find out immediately and can fix it, rather than the failure being dependent on (possibly-attacker-controlled) variables, so it makes the behaviour more predictable and easier to debug.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764692/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor764744"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">C considered dangerous: VLAs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2018 18:51 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/764744/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good points. VLAs might still be useful if your maximum depends on some other variable, *and* you are confident you have enough space, but frankly by this point either you're in a hot inner loop or you should be using malloc() anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/764744/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
