        <!DOCTYPE html>
        <html lang="en">
        <head><title>A formal kernel memory-ordering model (part 1) [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/718628/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/719986/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/718628/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A formal kernel memory-ordering model (part 1)</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="GAByline">
           <p>April 14, 2017</p>
           <p>By Jade Alglave, Luc Maranget, Paul E. McKenney, Andrea Parri, and Alan Stern</p>
           </div>
It has been said that <a
href="https://www.kernel.org/doc/Documentation/memory-barriers.txt"><tt>Documentation/memory-barriers.txt</tt></a>
can be used to
<a href="http://lwn.net/Articles/575835/">frighten small children</a>,
and perhaps this is true.
But even if it is true, it is woefully inefficient.
After all, there is a huge number of children in this world,
so a correspondingly huge amount of time and effort would be required in order
to read it to them all.

<p>
This situation clearly calls for automated tooling, which is
now available in prototype form; it is now possible to frighten small
children at scale.
This tool takes short fragments of concurrent C code as input, and
exhaustively analyzes the possible results.
In other words, instead of perusing <tt>memory-barriers.txt</tt> to find the
answer to a memory-ordering question, you can get your answer by writing
a small test case and feeding it to the tool, at least for
test cases within the tool's current capabilities and limitations.
This two-part series gives an introduction to the tool, describing how to
use it and how it works.

<p>
To the best of our knowledge, this tool is the first realistic automated
representation of Linux-kernel memory ordering, and is also the first
to incorporate <a
href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/RCUguarantees.html">read-copy-update
(RCU)</a> ordering properties. 

<p>
This article is organized as follows, with the intended audience
for each section in parentheses:

<ol class="spacylist">
<li>	<a href="#Why Formal Memory Models?">Why formal memory models?</a>
	(all).
<li>	<a href="#Guiding Principles">Guiding principles</a>
	(all).
<li>	<a href="#Causality and Ordering">Causality and ordering</a>
	(people interested in using memory-ordering tools).
</ol>

<p>
The second article in this series will look into
the issues raised by cycles and how they are important for memory
models.  It also demonstrates how the <a
href="http://diy.inria.fr">herd</a> tool can be used for testing 
memory models.

<p> 
Those wishing to skip the preliminaries found in these two articles and
dive directly into the strong model will find it
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html">here</a>.
(Yes, there is also a
<a
href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/WeakModel.html">weak
model</a>, but it is described in terms 
of how it differs from the strong model.
So you should start with the strong model.)

<h3><a name="Why Formal Memory Models?"></a>Why formal memory models?</h3>

<p>
Even before Linux, kernel hacking has tended to involve more intuition
and less formal methods.
Formal methods can nevertheless be useful for providing definite
answers to difficult questions.

For example, how many different behaviors can a computer program exhibit?
Particularly one that uses only values in memory, with no user input
or output?
<p>
Computers being the deterministic automata they are,
most people would say only one,
and for uniprocessor systems they would be basically correct.
But multiprocessor systems can give rise to a much wider range of behaviors,
owing to subtle variations in the relative timing of the processors
and the signals transmitted between them, their caches, and main memory.
Memory models try to bring some order to the picture,
first and foremost by characterizing exactly which outcomes are possible for
a symmetric multiprocessor (SMP) system running a certain (small) program.

<p>
Even better, a <em>formal</em> memory model enables tools to automatically
analyze small programs, as described
<a href="/Articles/470681/">here</a> and
<a href="/Articles/608550/">here</a>.
However, those tools are specialized for specific CPU families.
For analyzing the Linux kernel, what we need is a tool targeted at
a higher level, one that will be applicable to every CPU architecture
supported by the kernel.

<p>
Formal memory models require extreme precision, far beyond what the
informal discussion in <tt>memory-barriers.txt</tt> can possibly provide.
To bridge this gap in the best way possible, we have formulated the
guiding principles listed in the following section.

<h3><a name="Guiding Principles"></a>Guiding principles</h3>

<p>Our memory model is highly constrained because it must match
the kernel's behavior (or intended behavior).
However, there are numerous choices to be made, so we
formulated the following principles to guide those choices:

<ol class="spacylist">
<li>	<a href="#Strength Preferred to Weakness">
	Strength preferred to weakness</a>.
<li>	<a href="#Simplicity Preferred to Complexity">
	Simplicity preferred to complexity</a>.
<li>	<a href="#Support Existing Non-Buggy Linux-Kernel Code">
	Support existing non-buggy Linux-kernel code</a>.
<li>	<a href="#Be Compatible with Hardware Supported by the Linux Kernel">
	Be compatible with hardware supported by the Linux kernel</a>.
<li>	<a href="#Support Future Hardware">
	Support future hardware, within reason</a>.
<li>	<a href="#C11 Compatibility">Be compatible with the C11
	memory model, where prudent and reasonable</a>.
<li>	<a href="#Expose Questions and Areas of Uncertainty">
	Expose questions and areas of uncertainty</a>.
</ol>

<h4><a name="Strength Preferred to Weakness"></a>
Strength preferred to weakness</h4>

<p>
When all else is equal, a stronger memory model is clearly better, but
this raises the question of what is meant by &ldquo;stronger&rdquo;.
For our purposes, one memory model is considered to be stronger than
another if it rules out a larger set of behaviors.
Thus, the weakest possible memory model is one that would allow
a program to behave in any way at all
(as exemplified by the &ldquo;undefined behavior&rdquo; so common in
programming-language standards), whereas the strongest possible
memory model is one that says no program can ever do anything.
Of course, neither of these extremes is appropriate for the Linux kernel,
or for much of anything else.

<p>
The strongest memory model typically considered is
<a href="https://en.wikipedia.org/wiki/Sequential_consistency">sequential
consistency</a> (SC),
and the weakest is
release consistency process consistency
(<a href="http://dl.acm.org/citation.cfm?id=325102">RC<sub>pc</sub></a>).
SC prohibits any and all reordering, so that all processes agree on
some global order of all processes' accesses, which is theoretically
appealing but expensive, so much so that no mainstream microprocessor
provides SC by default.
In contrast, RC<sub>pc</sub> is fairly close to the memory models we
propose for the Linux kernel, courtesy of the
Alpha, ARM, Itanium, MIPS, and PowerPC hardware that the Linux kernel
supports.

<p>
On the other hand, we don't want to go overboard.
Although strength is preferred over weakness as a general rule,
small increases in strength are not worth order-of-magnitude
increases in complexity.

<h4><a name="Simplicity Preferred to Complexity"></a>
Simplicity preferred to complexity</h4>

<p>
Simpler is clearly better; however, simplicity will always be a subjective
notion.
A formal-methods expert might prefer a model with a more elegant definition,
while a kernel hacker might prefer the model that
best matched his or her intuition.
Nevertheless, simplicity remains a useful decision criterion.
For example, assuming all else is equal,
a model with a simpler definition that better matched the
typical kernel hacker's intuition would clearly be preferred over
a complex counterintuitive model.

<h4><a name="Support Existing Non-Buggy Linux-Kernel Code"></a>
Support existing non-buggy Linux-Kernel code</h4>

<p>
The memory model must support existing non-buggy code in the Linux kernel.
However, our model (in its current form) is rather limited in scope.
Because it is not intended to be a replacement for either hardware emulators
or production compilers, it does <i>not</i> support:

<ul class="spacylist">
<li>	Any number of compiler optimizations.
	For example, our model currently does not account for compiler
	optimizations that hoist identical stores from both branches of
	an <tt>if</tt> statement to precede that 
	statement.
	(On the other hand, the model also does not cover normal variable
	access, instead requiring at least <tt>READ_ONCE()</tt> or
	<tt>WRITE_ONCE()</tt>, each of which greatly limits the
	compiler's ability to optimize.
	This restriction is therefore less of a problem than it might
	at first appear.)
<li>	Arithmetic.
	Not even integer arithmetic!
<li>	Multiple access sizes.
<li>	Partially overlapping accesses.
<li>	Nontrivial data, including arrays and structures.
	However, trivial linked lists <i>are</i> supported.
<li>	Dynamic memory allocation.
<li>	Complete modeling of read-modify-write atomic operations.
	Currently, only atomic exchange is supported.
<li>	Locking, though some subset of the Linux kernel's numerous
	locking primitives is likely be added to a future version.
	In the meantime, locking may be
	<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-locktest.litmus">emulated using atomic exchange</a>.
<li>	Exceptions and interrupts.
<li>	I/O, including DMA.
<li>	Self-modifying code, as found in the kernel's alternative
	mechanism, function tracer, Berkeley Packet Filter JIT compiler,
	and module loader.
<li>	Complete modeling of RCU.
	For example, we currently exclude asynchronous grace-period
	primitives such as <tt>call_rcu()</tt> and <tt>rcu_barrier()</tt>.
	However, we believe that this work includes the first
	comprehensive formal model of the interaction between
	RCU reader and synchronous grace periods with memory accesses
	and memory-ordering primitives.
</ul>

<p>
<div class="tlrw">
<a name="Quick Quiz 1"></a><b>Quick Quiz 1</b>:
But my code contains simple unadorned accesses to shared variables.
So what possible use is this memory model to me?
<br><a href="#qq1answer">Answer</a>
</div>

As always, adding more detail and functionality to the model slows
it down, so the goal is therefore to balance the needs for speed and for
functionality.
The current model is a starting point, and we hope to incorporate
additional functionality over time.
We also hope that others will incorporate this memory model into their
tools.

<h4><a name="Be Compatible with Hardware Supported by the Linux Kernel"></a>
Be compatible with hardware supported by the Linux kernel</h4>

<p>
The memory model must be compatible with the hardware that the
Linux kernel runs on.
Although the memory model can be (and is) looser than any given instance of
hardware, it absolutely must not be more strict.
In other words, the memory model must in some sense provide the
least common denominator of the guarantees of all memory models of all
CPU families that run the Linux kernel.
This requirement is ameliorated, to some extent, by the ability of
the compiler and the Linux kernel to mask hardware weaknesses.
For example:

<ul class="spacylist">
<li>	The Alpha port of the Linux kernel provides memory-barrier
	instructions as needed to compensate for the fact that
	Alpha does not respect read-to-read address dependencies.
<li>	The Itanium port of GCC emits <tt>ld.acq</tt>
	for volatile loads and <tt>st.rel</tt> for
	volatile stores, which compensates for the fact that
	Itanium does not guarantee read-to-read ordering for
	normal loads from the same variable.
</ul>

<p>Nevertheless, the memory model must be sufficiently weak that
it does not rule out behaviors exhibited by any of the CPU architectures
the Linux kernel has been ported to.
Different CPU families can have quite divergent properties, so that
each of Alpha, ARM, Itanium, MIPS, and PowerPC
required special attention at some point or another.
In addition, hardware memory models are subject to change over time,
as are the use cases within the Linux kernel.
The Linux-kernel memory model must therefore evolve over time to
accommodate these changes, which means that the version presented in
this paper should be considered to be an initial draft rather than as
being set in stone.
It seems likely that this memory model will have the same rate of
change as does <tt>Documentation/memory-barriers.txt</tt>.

<p>
Providing compatibility with all the SMP systems supporting Linux is one
of the biggest memory-model challenges, especially given that some
systems' memory models have not yet been fully defined and documented.
In each case, we have had to take our best guess based on
existing documentation,
consultation with those hardware architects
	willing to consult,
formal memory models (for those systems having them),
and experiments on real hardware, for those systems we have
	access to.
	In at least one case, this might someday involve a computer museum.
<p>
Thankfully, this situation has been improving.
For example, although formal memory models have been available for
quite some time (such as
<a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-95-9.pdf">here
[400-page PDF]</a>),
tools that apply memory models to litmus tests have only appeared much more
recently.
We most certainly hope that this trend toward more accessible and
better-defined memory models continues, but in the meantime we will
continue to work with whatever is available.

<h4><a name="Support Future Hardware"></a>
Support future hardware, within reason</h4>

<p>
The memory model should support future hardware, within reason.
Linux-kernel ports to new hardware must supply their
own code for the various memory barriers, and might one day also
need to supply their own code for similar common-code primitives.
But since common code is valuable, an architecture wishing to supply
its own code for (say) <tt>READ_ONCE()</tt>
will need a very good reason for doing so.

<p>
This proposal assumes that future hardware will not deviate too far
from current practice.
For example, if you are porting Linux to a quantum supercomputer,
the memory model is likely to be the least of your worries.

<h4><a name="C11 Compatibility"></a>
Be compatible with the C11 memory model, where prudent and reasonable</h4>

<p>
Where possible, the model should be compatible
with the existing C and C++ memory models.
However, there are a number of areas where it is necessary to depart from
these memory models:

<ul class="spacylist">
<li>	The <tt>smp_mb()</tt> full memory barrier is stronger
	than that of C and C++.
	But let's face it, <tt>smp_mb()</tt> was there first,
	and there is a lot of code in the kernel that might be
	adapted to <tt>smp_mb()</tt>'s current semantics.
<li>	The Linux kernel's value-returning read-modify-write
	atomics feature ordering properties that are not found
	in their C/C++ counterparts.
<li>	The <tt>smp_mb__before_atomic()</tt>,
	<tt>smp_mb__after_atomic()</tt>, and
	<tt>smp_mb__after_unlock_lock()</tt>
	barrier-amplification APIs
	have no counterparts in the C/C++ API.
<li>	The <tt>smp_read_barrier_depends()</tt>
	macro does not have a direct equivalent in the
	C/C++ memory model.
<li>    The Linux kernel's
	notion of control dependencies does not exist in C/C++.
	However, control dependencies are an important example of
	instruction ordering, so the memory model must account for them.
<li>	The Linux-kernel notion of RCU grace periods does not
	exist in C/C++.
	(However, the RCU-related proposals
	<a
	href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0190r3.pdf">P0190R3
	[PDF]</a>,
	<a
	href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0461r1.pdf">P0461R1
	[PDF]</a>,
	<a
	href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0462r1.pdf">P0462R1
	[PDF]</a>,
	<a
	href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0561r0.html">P0561R0
	[PDF]</a>, and
	<a
	href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0566r0.pdf">P0566R0
	[PDF]</a>
	are being considered by the committee.)
</ul>

<p>
On the positive side, the Linux kernel has recently been adding functionality
that is closer to that of C and C++ atomics, with the ongoing move
from <tt>ACCESS_ONCE()</tt> to <tt>READ_ONCE()</tt> and
<tt>WRITE_ONCE()</tt> being one example and the addition
of <tt>smp_load_acquire()</tt> and <tt>smp_store_release()</tt>
being another.

<h4><a name="Expose Questions and Areas of Uncertainty"></a>
Expose questions and areas of uncertainty</h4>

<p>
Defining a memory model inevitably uncovers interesting questions
and areas of uncertainty.
For example:

<ul class="spacylist">
<li>	The Linux-kernel memory model is
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0124r1.html">more strict than that of C11</a>.
	It is useful to flag the differences in order to alert people who might
	otherwise be tempted to rely solely on C11.
	It is also quite possible that some of the Linux kernel's strictness
	is strictly historical, in which case it might (or might not)
	be worth considering matching C11 semantics for those specific
	situations.
<li>	Release-acquire chains are required to provide ordering to those
	tasks participating in the chain.
	Failure to provide such ordering would have many problematic
	consequences, not least being that locking would not work
	correctly.
	For tasks external to the chain, ordering cannot be provided
	for a write preceding the first release and a read following the
	last acquire due to hardware limitations.
	For example, if one process writes to variable <tt>x</tt> while
	holding a lock and a later critical section for that same lock
	reads from variable <tt>y</tt>, the read of <tt>y</tt> might
	execute before the write of <tt>x</tt> has propagated to an
	unrelated process not holding the lock.
<li>	It turns out that release-acquire chains can be implemented
	using <tt>READ_ONCE()</tt> instead of <tt>smp_load_acquire()</tt>.
	(However, substituting <tt>WRITE_ONCE()</tt> for
	<tt>smp_store_release()</tt> does <i>not</i> work on all
	architectures.)
	Should the model require the use of <tt>smp_load_acquire()</tt>?
<li>	Some architectures can &ldquo;erase&rdquo; writes, so that
	ordering specific to a given write might not apply to a later
	write to that same variable by that same task, even though
	coherence ordering would normally order the two writes.
	This can give rise to bizarre results, such as the possible
	outcomes of a code sequence depending on the code that follows it.
	(However, such results appear to be restricted to litmus tests
	that can best be described as &ldquo;rather strange&rdquo;.)
<li>	One interesting corner case of hardware memory models is that
	weak barriers (i.e., <tt>smp_wmb()</tt>) suffice to provide
	transitive orderings when all accesses are writes.
	However, we were unable to come up with reasonable use cases,
	and furthermore, the things that looked most reasonable proved
	to be attractive nuisances.
	Should the memory model nevertheless provide ordering in this case?
	(If you know of some reason why this ordering should be respected
	by the memory models, please don't keep it a secret).
</ul>

<p>
In a perfect world, we would resolve each and every area of uncertainty,
then produce a single model reflecting full knowledge of all the
hardware that the Linux kernel supports.
However, astute readers might have noticed that the world is imperfect.
Furthermore, rock-solid certainties can suddenly be cast into doubt,
either with the addition of an important new architecture or with
the uncovering of a misunderstanding or an error in documentation of
some existing architecture.
It will therefore be sometimes necessary for the Linux kernel memory
model to say &ldquo;maybe&rdquo;.

<p>
Unfortunately, existing software tools are unable to say
&ldquo;maybe&rdquo; in response to a litmus test.
We therefore constructed not one but two formal models, one
strong and the other less strong.
These two models will disagree in &ldquo;maybe&rdquo; cases.
Kernel hackers should feel comfortable relying on ordering
only in cases where both models agree that ordering should be provided, and
hardware architects should feel the need to provide strong ordering
unless both models agree that strong ordering need not be provided.
(Currently these models are still very much under development, so
it is still unwise to trust either model all that much.)

<h3><a name="Causality and Ordering"></a>
Causality and ordering</h3>

<p>
Causality is an important property of memory models, in part because
causality looms large in most peoples' intuitive understanding of
concurrent code.
However, causality is a generic term, lacking the precision
required for a formal memory model.
In this series we will therefore use the terms
&ldquo;causality&rdquo; and &ldquo;causal relationship&rdquo;
quite sparingly, instead defining precise terms that will be
used directly within the memory model.
But a brief discussion now will help illuminate the topic and
will introduce some important relationships between causality,
ordering, and memory models.

<p>
<i>Causality</i> is simply the principle that a cause happens before
its effect, not after.
It is therefore a statement about ordering of events in time.
Let's start with the simplest and most direct example.
If CPU&nbsp;A writes a value to a shared variable in memory, and CPU&nbsp;B reads
that value back from the shared variable, then A's write must execute
before B's read.
This truly is an example of a cause-and-effect relation;
the only way B can possibly know the value stored by A is to
receive some sort of message sent directly or indirectly by A (for example,
a cache-coherence protocol message).
<p>
Messages take time to propagate from one CPU or cache to another,
and they cannot be received before they have been sent.
(In theory, B could guess the value of A's write, act on that guess,
check the guess once the write message arrived, and if the guess
was wrong, cancel any actions that were inconsistent with the actual
value written.
Nevertheless, B could not be entirely certain that its guess is correct
until the message arrives&mdash;and our memory models assume that
CPUs do not engage in this sort of guessing, at least not unless
they completely hide its effects from the software they are running.)
<p>
On the other hand, if B does not read the value stored by A but
rather an earlier value, then there need not be any particular
temporal relation between A's write and B's read.
B's read could have executed either before or after A's write,
as long as it executed before the write message reached B.
In fact, on some architectures, the read could return the old
value even if it executed a short time <i>after</i> the message's arrival.
<i>A fortiori</i>, there would be no cause-and-effect relation.

<p>
Another example of ordering also involves the propagation of writes
from one CPU to another.
If CPU&nbsp;A writes to two shared variables,
these writes need not propagate to CPU&nbsp;B in the same order as the
writes were executed.
In some architectures it is entirely possible for B to receive the
messages conveying the new values in the opposite order.
In fact, it is even possible for the writes to propagate to CPU B
in one order and to CPU C in the other order.
The only portable way for the programmer to enforce write propagation
in the order given by the program is to use appropriate memory barriers
or barrier-like constructs, such as <tt>smp_mb()</tt>,
<tt>smp_store_release()</tt>, or C11 non-relaxed atomic operations.

<p>
A third example of ordering involves events occurring
entirely within a single CPU.
Modern CPUs can and do reorder instructions, executing them in an
order different from the order they occur in the instruction stream.
There are architectural limits to this sort of thing, of course.
<a name="dependencies"></a>
Perhaps the most pertinent for memory models is the general principle
that a CPU cannot execute an instruction before it knows what that
instruction is supposed to do.
<p>
For example, consider the statement &ldquo;<tt>x&nbsp;=&nbsp;y;</tt>&rdquo;.
To carry out this statement, a CPU must first load the value of <tt>y</tt>
from memory and then store that value to <tt>x</tt>.
It cannot execute the store before the load;
if it tried then it would not know what value to store.
This is an example of a <i>data dependency</i>.
There are also <i>address dependencies</i> (for example,
&ldquo;<tt>a[n]&nbsp;=&nbsp;3;</tt>&rdquo; where the value of <tt>n</tt>
must be loaded before the CPU can know where to store the value&nbsp;3).
Finally, there are <i>control dependencies</i> (for example,
&ldquo;<tt>if&nbsp;(i&nbsp;==&nbsp;0)&nbsp;y&nbsp;=&nbsp;5;</tt>&rdquo; where the value of <tt>i</tt>
must be loaded before the CPU can know whether to store anything
into <tt>y</tt>).
In the general case where no dependency is present, however,
the only portable way for the programmer
to force instructions to be executed in the order given by the program
is to use appropriate memory barriers or barrier-like constructs.

<p>
Finally, at a higher level of abstraction, source code statements
can be reordered or even eliminated entirely by an optimizing compiler.
We won't discuss this very much here; <tt>memory-barriers.txt</tt>
contains a number of examples demonstrating the sort of shenanigans
a compiler can get up to when translating a program from source code
to object code.
<p>
<h3>To be continued</h3>
<p>
<a href="/Articles/720550/">The second half of this series</a> focuses on the
specific problem of cycles.
<p>
</p><h3>Acknowledgments</h3>

<p>We owe thanks to H.&nbsp;Peter Anvin, Will Deacon, Andy Glew,
Derek Williams, Leonid Yegoshin, and Peter Zijlstra for their
patient explanations of their respective systems' memory models.
We are indebted to Peter Sewell, Susmit Sarkar, and their groups
for their seminal work formalizing many of these same memory models.
We all owe thanks to Dmitry Vyukov, Boqun Feng, and Peter Zijlstra for
their help making this human-readable.
We are also grateful to Michelle Rankin and Jim Wasko for their support
of this effort.

<h4><a name="Answers to Quick Quizzes"></a>
Answer to the Quick Quiz</h4>

<a name="qq1answer"></a>
<p><b>Quick Quiz 1</b>:
But my code contains simple unadorned accesses to shared variables.
So what possible use is this memory model to me?


</p><p><b>Answer</b>:
You are of course free to use simple unadorned accesses to shared variables
in your code, but you are then required to make sure that the
compiler isn't going to trip you up&mdash;as has always been the case.
Once you have made sure that the compiler won't trip you up,
simply translate those accesses to use <tt>READ_ONCE()</tt>
and <tt>WRITE_ONCE()</tt> when using the model.
Of course, if your code gives the compiler the freedom to rearrange your
memory accesses, you may need multiple translations, one for each
possible rearrangement.


</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools">Development tools</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_model">Memory model</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/718628/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor721128"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A formal kernel memory-ordering model (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2017 7:53 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/721128/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <P>At a previous job, I know we used <A HREF="http://diy.inria.fr/doc/index.html">diy/litmus</A> to perform various litmus tests against our interconnect.  This was a few years ago, so obviously it was an older version than the one described there today.  But, it seems like the work and the tool are still relevant.</P>
<P>At first blush, it appears this work has some overlap with the work that team's doing.  Or, if nothing else, the two efforts seem complementary.  Your work seems focused on modeling the Linux kernel requirements, while the diy/litmus folks seem more focused on analyzing hardware implementations.</P>
<P>Is there an opportunity for some cross-pollination here?  For example:</P>
<UL><LI>Testing diy hardware models against the kernel's memory model to identify gaps between the kernel's understanding and actual hardware implementations.</LI>
<LI>Providing diy models based on the kernel's abstract model to construct hardware litmus tests for future hardware, to determine whether hardware's evolved beyond the kernel's current model.</LI>
</UL>
</P>
<P>If nothing else, diy/litmus seems like it could provide a ready-made experimental framework for testing hypotheses against current hardware.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/721128/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor721219"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A formal kernel memory-ordering model (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2017 17:51 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/721219/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Might your old colleagues be interested in this?  <a href="http://wiki.linuxplumbersconf.org/2017:linux-kernel_memory_model_workshop">http://wiki.linuxplumbersconf.org/2017:linux-kernel_memor...</a><br>
<p>
We have done some work generating and running Linux kernel modules from litmus tests, though this is limited by the fact that the automatically generated pseudo-C litmus tests lack type information.  I am looking to add the type information, which would make it easier to generate a kernel module that GCC was happy with, but haven't gotten this task done as quickly as I would like.  (Story of my life!)<br>
<p>
We have also done some comparisons against hardware memory models.<br>
<p>
In short, I completely agree that validation of memory models such as this one requires considerable time and attention!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/721219/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor724835"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A formal kernel memory-ordering model (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2017 4:26 UTC (Thu)
                               by <b>johnbender</b> (guest, #116592)
                              [<a href="/Articles/724835/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm currently working on my PhD with an emphasis on formal verification (more specifically proofs of correctness) in the weak memory setting.<br>
<p>
Some thoughts as I read through:<br>
<p>
<font class="QuotedText">&gt; Any number of compiler optimizations. For example, our model currently does not account for compiler optimizations that hoist identical stores from both branches of an if statement to precede that statement.</font><br>
<p>
This has until very recently (POPL 2017) been a very serious problem for weak memory models. There is only one that I'm aware of for C++11 that avoids the "thin air" read problem that generally arises as a consequence of supporting these types of optimizations. See [1] for more.<br>
<p>
<font class="QuotedText">&gt; The memory model must be compatible with the hardware that the Linux kernel runs on. Although the memory model can be (and is) looser than any given instance of hardware, it absolutely must not be more strict. In other words, the memory model must in some sense provide the least common denominator of the guarantees of all memory models of all CPU families that run the Linux kernel. </font><br>
<p>
This sort of "lower bound" on bad memory behavior is normally why people target C11 or C++11, but if the author's happen to see this comment I would recommend checking out the work of Karl Crary at CMU [2]. In his model he has omitted the traditional total order on writes present on all modern architectures with the intent of future proofing his semantics.<br>
<p>
As a further plug for his semantics, it is not "axiomatic" in the sense of the traditional memory models. Importantly it introduces the notion of programmer specified orders which fits more closely with programmer intuition (by my reckoning) when writing the algorithms than say, the C++11 approach of memory orderings for particular cross thread operations.<br>
<p>
In any event an enjoyable read that I will have to come back to later!<br>
<p>
[1] <a rel="nofollow" href="https://people.mpi-sws.org/~orilahav/papers/main.pdf">https://people.mpi-sws.org/~orilahav/papers/main.pdf</a><br>
[2] <a rel="nofollow" href="https://www.cs.cmu.edu/~crary/papers/2015/rmc.pdf">https://www.cs.cmu.edu/~crary/papers/2015/rmc.pdf</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724835/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A formal kernel memory-ordering model (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2017 15:14 UTC (Thu)
                               by <b>johnbender</b> (guest, #116592)
                              [<a href="/Articles/724869/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I somehow just noticed that this article was partly authored by Jade Alglave and others who will certainly be aware of the papers I linked. Great article!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
