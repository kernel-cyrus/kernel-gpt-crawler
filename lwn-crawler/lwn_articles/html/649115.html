        <!DOCTYPE html>
        <html lang="en">
        <head><title>Pathname lookup in Linux [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/649115/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/648519/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/649115/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Pathname lookup in Linux</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="GAByline">
           <p>June 24, 2015</p>
           <p>This article was contributed by Neil&nbsp;Brown</p>
           </div>
<p>One of the changes that was <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801">recently
merged</a>  for Linux
4.2 is a substantial rewrite of parts of the pathname-lookup code in
the Linux virtual filesystem (VFS) layer.  This rewrite primarily affects
the handling of 
symbolic links &mdash; though, like many such rewrites, opportunities were
found to rationalize and improve other parts of the code, too.  With all
this change, it seems like a good opportunity to document just how pathname
lookup works.  While such documentation cannot stay current 
indefinitely, writing it immediately after a big change might increase
the time until it becomes inaccurate.</p>
<p>
The most obvious aspect of pathname lookup, which very little
exploration is needed to discover, is that it is complex.  There are
many rules, special cases, and implementation alternatives that all
combine to confuse the unwary reader.  Computer science has long been
acquainted with such complexity and has tools to help manage it.  One
tool that we will make extensive use of is &quot;divide and conquer&quot;.  For
the early parts of the analysis we will divide off symlinks, leaving
them until the final part.  Well before we get to symlinks we have
another major division based on the VFS's approach to locking which will allow
us to review &quot;REF-walk&quot; and &quot;RCU-walk&quot; (a pair of
algorithms that have been
<a href="https://lwn.net/Articles/419811/">described previously</a>)
separately.  But we are getting ahead of ourselves.  There are some
important low-level distinctions we need to 
clarify first.</p>
<h4>There are two sorts of ...</h4>
<p>
Pathnames (sometimes &quot;file names&quot;), used to identify objects in the
filesystem, will be familiar to most readers.  They contain two sorts
of elements: &quot;slashes&quot; that are sequences of one or more
&quot;<tt>/</tt>&quot; 
characters, and &quot;components&quot; that are sequences of one or more
non-&quot;<tt>/</tt>&quot; characters.  These form two kinds of paths.
Those that 
start with slashes
are &quot;absolute&quot; and start from the filesystem root.
The others are &quot;relative&quot; and start from the current directory,
or from some 
other location specified by a file descriptor given to a
&quot;xxx<tt>at()</tt>&quot; 
system call such as <a
href="http://man7.org/linux/man-pages/man2/openat.2.html"><tt>openat()</tt></a>.</p> 
<p>
It is tempting to describe the second kind as starting with a
component, but that isn't always accurate: a pathname can lack both
slashes and components; it can be empty, in other words.  This is generally
forbidden 
in POSIX, but some of those &quot;xxx<tt>at()</tt>&quot; system calls in
Linux permit it 
when the <tt>AT_EMPTY_PATH</tt> flag is given.  For example, if you have an
open file descriptor on an executable file, you can execute it by calling
<a href="http://man7.org/linux/man-pages/man2/execveat.2.html"><tt>execveat()</tt></a>, passing the file descriptor, an empty path, and the
<tt>AT_EMPTY_PATH</tt> flag.</p>
<p>
These paths can be divided into two sections: the final component and
everything else.  The &quot;everything else&quot; is the easy bit.  In all cases
it must identify a directory that already exists, otherwise an error
such as <tt>ENOENT</tt> or <tt>ENOTDIR</tt> will be reported.

The final component is not so simple.  Not only do different system
calls interpret it quite differently (e.g. some create it, some do
not), but it might not even exist: neither the empty pathname nor the
pathname that is just slashes have a final component.  If it does
exist, it could be &quot;<tt>.</tt>&quot; or &quot;<tt>..</tt>&quot; which
are handled quite differently
from other components.</p>
<p>
If a pathname ends with a slash, such as &quot;<tt>/tmp/foo/</tt>&quot; it might be
tempting to consider that to have an empty final component.  In many
ways that would lead to correct results, but not always.  In
particular, <tt>mkdir()</tt> and <tt>rmdir()</tt> each create or remove a
directory named 
by the final component, and they are required to work with pathnames ending
in &quot;<tt>/</tt>&quot;.  According to <a
href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_12">POSIX</a>:
<p>
<div class="BigQuote">
A pathname that contains at least one non-&lt;slash&gt; character and
that ends with one or more trailing &lt;slash&gt; characters shall not
be resolved successfully unless the last pathname component before
the trailing &lt;slash&gt; characters names an existing directory or a
directory entry that is to be created for a directory immediately
after the pathname is resolved.</p>
</div>
<p>
The Linux pathname-walking code (mostly in <tt>fs/namei.c</tt>) deals with
all of these issues: breaking the path into components, handling the
&quot;everything else&quot; quite separately from the final component, and
checking that the trailing slash is not used where it isn't
permitted.  It also addresses the important issue of concurrent
access.</p>
<p>
While one process is looking up a pathname, another might be making
changes that affect that lookup.  One fairly extreme case is that if
<tt>a/b</tt> were renamed to <tt>a/c/b</tt> while another process were
looking up 
<tt>a/b/..</tt>, that process might successfully resolve on <tt>a/c</tt>.
Most races are much more subtle, and a big part of the task of
pathname lookup is to prevent them from having damaging effects.  Many
of the possible races are seen most clearly in the context of the
&quot;dcache&quot; and an understanding of that is central to understanding
pathname lookup.</p>
<h4>More than just a cache</h4>
<p>
The dcache caches information about names in each filesystem to
make them quickly available for lookup.  Each entry (known as a
&quot;<a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/include/linux/dcache.h?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n107">dentry</a>&quot;)
contains three significant fields: a component name, a 
pointer to a parent dentry, and a pointer to the &quot;inode&quot; which
contains further information about the object in that parent with
the given name.  The inode pointer can be <tt>NULL</tt> indicating that the
name doesn't exist in the parent.  While there can be linkage in the
dentry of a directory to the dentries of the children, that linkage is
not used for pathname lookup, and so will not be considered here.</p>
<p>
The dcache has a number of uses apart from accelerating lookup.  One
that will be particularly relevant is that it is closely integrated
with the mount table that records which filesystem is mounted where.
What the mount table actually stores is which dentry is mounted on top
of which other dentry.</p>
<p>
When considering the dcache, we have another of our &quot;two types&quot;
distinctions: there are two types of filesystems.

Some filesystems ensure that the information in the dcache is always
completely accurate (though not necessarily complete).  This can allow
the VFS to determine if a particular file does or doesn't exist
without checking with the filesystem, and means that the VFS can
protect the filesystem against certain races and other problems.
These are typically &quot;local&quot; filesystems such as ext3,
XFS, and
Btrfs.</p>
<p>
Other filesystems don't provide that guarantee because they cannot.
These are typically filesystems that are shared across a network,
whether remote filesystems like NFS and 9P, or cluster filesystems
like ocfs2 or cephfs.  These filesystems allow the VFS to revalidate
cached information and must provide their own protection against
awkward races.  The VFS can detect these filesystems by the
<tt>DCACHE_OP_REVALIDATE</tt> flag being set in the dentry.</p>

<h4>REF-walk: simple concurrency management with refcounts and spinlocks</h4>
<p>
With all of those divisions carefully classified, we can now start
looking at the actual process of walking along a path.  In particular
we will start with the handling of the &quot;everything else&quot; part of a
pathname, and focus on the &quot;REF-walk&quot; approach to concurrency
management.  This code is found in the <a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n1859"><tt>link_path_walk()</tt></a>
function, if 
you ignore all the places that only run when
&quot;<tt>LOOKUP_RCU</tt>&quot; (indicating the use of RCU-walk) is set.</p> 
<p>
REF-walk is fairly heavy-handed with locks and reference counts.  Not
as heavy-handed as in the old &quot;big kernel lock&quot; days, but
certainly not 
afraid of taking a lock when one is needed.  It uses a variety of
different concurrency controls.  A background understanding of the
various primitives is assumed, or can be gleaned from elsewhere such
as in <a href="/Articles/453685/">Meet the Lockers</a>.</p>
<p>
The locking mechanisms used by REF-walk include:</p>

<dl>
<dt><tt>dentry-&gt;d_lockref</tt></dt>
<p>
<dd>
This uses the relatively recently introduced <a href="/Articles/565734/">lockref</a> primitive to
provide both a spinlock and a reference count.  The special sauce of
this primitive is that the conceptual sequence &quot;lock; inc_ref;
unlock;&quot; can often be performed with a single, atomic memory
operation.</p> 
<p>
Holding a reference on a dentry ensures that the dentry won't suddenly
be freed and used for something else, so the values in various fields
will behave as expected.  It also protects the <tt>-&gt;d_inode</tt> reference
to the inode to some extent.</p>
<p>
The association between a dentry and its inode is fairly permanent.
For example, when a file is renamed, the dentry and inode move
together to the new location.  When a file is created the dentry will
initially be negative (i.e. <tt>d_inode</tt> is <tt>NULL</tt>), and will be assigned
to the new inode as part of the act of creation.</p>
<p>
When a file is deleted, this can be reflected in the cache either by
setting <tt>d_inode</tt> to <tt>NULL</tt>, or by removing it from the hash table
(described shortly) used to look up the name in the parent
directory.  If the dentry is still in use, the second option is used, as
it is perfectly legal to keep using an open file after it has been
deleted; having the dentry around helps.  If the dentry is not
otherwise in use (i.e. if the refcount in <tt>d_lockref</tt> is one), only
then will <tt>d_inode</tt> be set to <tt>NULL</tt>.  Doing it this way is more
efficient for a very common case.</p>
<p>
So as long as a counted reference is held to a dentry, a non-NULL
<tt>-&gt;d_inode</tt> value will never be changed.
</dd>
<p>
<dt><tt>dentry-&gt;d_lock</tt></dt>
<p>
<dd>
<tt>d_lock</tt> is a synonym for the spinlock that is part of
<tt>d_lockref</tt> above. 
For our purposes, holding this lock protects against the dentry being
renamed or unlinked.  In particular, its parent (<tt>d_parent</tt>), and its
name (<tt>d_name</tt>) cannot be changed, and it cannot be removed from the
dentry hash table.</p>
<p>
When looking for a name in a directory, REF-walk takes <tt>d_lock</tt> on
each candidate dentry that it finds in the hash table and then checks
that the parent and name are correct.  So it doesn't lock the parent
while searching in the cache; it only locks children.</p>
<p>
When looking for the parent for a given name (to handle &quot;<tt>..</tt>&quot;),
REF-walk can take <tt>d_lock</tt> to get a stable reference to <tt>d_parent</tt>,
but it first tries a more lightweight approach.  As seen in
<a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/dcache.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n810"><tt>dget_parent()</tt></a>,
if a reference can be claimed on the parent, and if 
subsequently <tt>d_parent</tt> can be seen to have not changed, then there is
no need to actually take the lock on the child.</p>
</dd>
<p>
<dt><tt>rename_lock</tt></dt>
<p>
<dd>
Looking up a given name in a given directory involves computing a hash
from the two values (the name and the dentry of the directory),
accessing that slot in a hash table, and searching the linked list
that is found there.

When a dentry is renamed, the name and the parent dentry can both
change so the hash will almost certainly change too.  This would move the
dentry to a different chain in the hash table.  If a filename search
happened to be looking at a dentry that was moved in this way, it might end
up continuing the search down the wrong chain, 
and so miss out on part of the correct chain.</p>
<p>
The name-lookup process (<tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/dcache.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n2223">d_lookup()</a></tt>)
does <em>not</em> try to prevent this 
from happening, but only to detect when it happens.

<tt>rename_lock</tt> is a seqlock that is updated whenever any dentry is
renamed.  If <tt>d_lookup</tt> finds that a rename happened while it
unsuccessfully scanned a chain in the hash table, it simply tries
again.</p>
</dd>
<p>
<dt><tt>inode-&gt;i_mutex</tt></dt>
<p>
<dd>
<tt>i_mutex</tt> is a mutex that serializes all changes to a particular
directory.  This ensures that, for example, an <tt>unlink()</tt> and a
<tt>rename()</tt> 
cannot both happen at the same time.  It also keeps the directory
stable while the filesystem is asked to look up a name that is not
currently in the dcache.</p>
<p>
This has a complementary role to that of <tt>d_lock</tt>:  <tt>i_mutex</tt>
on a directory 
protects all of the names in that directory, while <tt>d_lock</tt> on a name
protects just one name in a directory.  Most changes to the dcache
hold <tt>i_mutex</tt> on the relevant directory inode and briefly take
<tt>d_lock</tt> on one or more the dentries while the change happens.  One
exception is when idle dentries are removed from the dcache due to
memory pressure.  This uses <tt>d_lock</tt>, but <tt>i_mutex</tt> plays no role.</p>
<p>
The mutex affects pathname lookup in two distinct ways. Firstly, it
serializes lookup of a name in a directory.  <tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n1695">walk_component()</a></tt>
uses 
<tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n1503">lookup_fast()</a></tt>
first which, in turn, checks to see if the name is 
in the cache, 
using only <tt>d_lock</tt> locking.  If the name isn't found, then
<tt>walk_component()</tt> 
falls back to <tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n1601">lookup_slow()</a></tt>,
which takes <tt>i_mutex</tt>, 
checks again that 
the name isn't in the cache, and then calls in to the filesystem to get a
definitive answer.  A new dentry will be added to the cache regardless of
the result.</p>
<p>
Secondly, when pathname lookup reaches the final component, it will
sometimes need to take <tt>i_mutex</tt> before performing the last lookup
so that 
the required exclusion can be achieved.  How path lookup chooses to take,
or not take, <tt>i_mutex</tt> is one of the 
issues addressed in a subsequent section.</p>
</dd>
<p>
<dt><tt>mnt-&gt;mnt_count</tt></dt>
<p>
<dd>
<tt>mnt_count</tt> is a per-CPU reference counter on &quot;<tt>mount</tt>&quot; structures.
Per-CPU here means that incrementing the count is cheap as it only
uses CPU-local memory, but checking if the count is zero is expensive as
it needs to check with every CPU.

Taking a <tt>mnt_count</tt> reference prevents the <tt>mount</tt> structure from
disappearing as the result of regular unmount operations, but does not
prevent a &quot;lazy&quot; 
unmount.  So holding <tt>mnt_count</tt> doesn't ensure that the mount remains
in the namespace and, in particular, doesn't stabilize the link to the
mounted-on dentry.

It does, however, ensure that the <tt>mount</tt> data structure remains
coherent, and it provides a reference to the root dentry of the mounted
filesystem.

So a reference through <tt>-&gt;mnt_count</tt> provides a stable reference to
the mounted dentry, but not the mounted-on dentry.</p>
</dd>
<p>
<dt><tt>mount_lock</tt></dt>
<p>
<dd>
<tt>mount_lock</tt> is a global seqlock, a bit like <tt>rename_lock</tt>.
It can be used to 
check if any change has been made to any mount points.</p>
<p>
While walking down the tree (away from the root), this lock is used when
crossing a mount point to check that the crossing was safe.  That is,
the value in the seqlock is read, then the code finds the mount that
is mounted on the current directory, if there is one, and increments
the <tt>mnt_count</tt>.  Finally, the value in <tt>mount_lock</tt> is checked against
the old value.  If there is no change, then the crossing was safe.  If there
was a change, the <tt>mnt_count</tt> is decremented and the whole process is
retried.</p>
<p>
When walking up the tree (towards the root) by following a
&quot;..&quot; link,
a little more care is needed.  In this case the seqlock (which
contains both a counter and a spinlock) is fully locked to prevent
any changes to any mount points while stepping up.  This locking is
needed to stabilize the link to the mounted-on dentry, which the
refcount on the mount itself doesn't ensure.</p>
</dd>
<p>
<dt>RCU</dt>
<p>
<dd>
Finally the global (but extremely lightweight) RCU read lock is held
from time to time to ensure certain data structures don't get freed
unexpectedly.

In particular, it is held while scanning chains in the dcache hash
table, and the mount point hash table.</p>
</dd>
</dl>
<p>
<h4>Bringing it together with <tt>struct nameidata</tt></h4>
<p>
Throughout the process of walking a path, the current status is stored
in a <tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n494">struct
nameidata</a></tt>, &quot;namei&quot; being the traditional 
name — dating 
all the way back to First Edition
Unix — of the function that
converts a &quot;name&quot; to an &quot;inode&quot;.
<tt>struct nameidata</tt> contains (among other fields):</p>
<p>
<dl>
<dt><tt>struct path path</tt></dt>
<p>
<dd>
A <tt>path</tt> contains a <tt>struct
vfsmount</tt> (which is 
embedded in a <tt>struct mount</tt>) and a <tt>struct dentry</tt>.
Together these
record the current status of the walk.  They start out referring to the
starting point
(the current working directory, the root directory, or some other
directory identified by a file descriptor) and are updated on each
step.  A reference through <tt>d_lockref</tt> and <tt>mnt_count</tt> is always
held.</p>
</dd>
<p>
<dt><tt>struct qstr last</tt></dt>
<p>
<dd>
This is a string together with a length
(i.e. <em>not</em> <tt>nul</tt> terminated) that is the &quot;next&quot; component in the
pathname.</p>
</dd>
<p>
<dt><tt>int last_type</tt></dt>
<p>
<dd>
This is one of <tt>LAST_NORM</tt>, <tt>LAST_ROOT</tt>,
<tt>LAST_DOT</tt>, <tt>LAST_DOTDOT</tt>, or <tt>LAST_BIND</tt>.  The
<tt>last</tt> field is only 
valid if the type is <tt>LAST_NORM</tt>.  <tt>LAST_BIND</tt> is used when
following a symlink and no components of the symlink have been
processed yet.  Others should be fairly self-explanatory.</p>
</dd>
<p>
<dt><tt>struct path root</tt></dt>
<p>
<dd>
This is used to hold a reference to the
effective root of the filesystem.  Often that reference won't be
needed, so this field is only assigned the first time it is used, or
when a non-standard root is requested.  Keeping a reference in the
<tt>nameidata</tt> ensures that only one root is in effect for the entire
path walk, even if it races with a <tt>chroot()</tt> system call.</p>
<p>
The root is needed when either of two conditions holds: (1) either the
pathname or a symbolic link starts with a "<tt>/</tt>", or (2)&nbsp;a
&quot;<tt>..</tt>&quot; component is being handled, since
&quot;<tt>..</tt>&quot; from the root 
must always stay at the root.

The value used is usually the current root directory of the calling
process.  An alternate root can be provided as when <tt>sysctl()</tt>
calls <tt>file_open_root()</tt>, and when NFSv4 or Btrfs call
<tt>mount_subtree()</tt>.  In each case, a pathname is being looked up in a
very specific part of the filesystem, and the lookup must not be
allowed to escape that subtree.  It works a bit like a local
<tt>chroot()</tt>.</p> 
</dd>
</dl>
<p>
Ignoring the handling of symbolic links, we can now describe the
<tt>link_path_walk()</tt>
function, which handles the lookup of everything 
except the final component as:</p>
<blockquote>
<p>
Given a path (<tt>name</tt>) and a <tt>nameidata</tt> structure
(<tt>nd</tt>), check that the 
current directory has execute permission and then advance <tt>name</tt>
over one component while updating <tt>last_type</tt> and <tt>last</tt>.  If that
was the final component, then return, otherwise call
<tt>walk_component()</tt>
and repeat from the top.</p> 
</blockquote>
<p>
<tt>walk_component()</tt> is even easier.  If the component is
<tt>LAST_DOTS</tt>, 
it calls <tt>handle_dots()</tt>, which does the necessary locking as already
described.  If it finds a <tt>LAST_NORM</tt> component, it first calls
<tt>lookup_fast()</tt>, which only looks in the dcache, but
will ask the 
filesystem to revalidate the result if it is that sort of filesystem.
If that doesn't get a good result, it calls
<tt>lookup_slow()</tt>, which 
takes the <tt>i_mutex</tt>, rechecks the cache, and then asks the filesystem
to find a definitive answer.  Each of these will call
<tt>follow_managed()</tt> (as described below) to handle any mount points.</p>
<p>
In the absence of symbolic links, <tt>walk_component()</tt> creates a new
<tt>struct path</tt> containing a 
counted reference to the new dentry and a reference to the new
<tt>vfsmount</tt>, which is only counted if it is different from the previous
<tt>vfsmount</tt>.  It then calls <tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n814">path_to_nameidata()</a></tt>
to install the new 
<tt>struct path</tt> in the <tt>struct nameidate</tt> and drop the unneeded
references.</p>
<p>
This &quot;hand-over-hand&quot; sequencing of getting a reference to the new
dentry before dropping the reference to the previous dentry may
seem obvious, but is worth pointing out so that we will recognize its
analogue in the &quot;RCU-walk&quot; version.</p>

<h4>Handling the final component</h4>
<p>
<tt>link_path_walk()</tt> only walks as far as setting <tt>nd-&gt;last</tt> and
<tt>nd-&gt;last_type</tt> to refer to the final component of the path.  It does
not call <tt>walk_component()</tt> that last time.  Handling that final
component remains for the caller to sort out. Those callers are
<tt>path_lookupat()</tt>, <tt>path_parentat()</tt>, 
<tt>path_mountpoint()</tt>, and 
<tt>path_openat()</tt>, each of which handles the differing requirements of
different system calls.</p>
<p>
<tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n2144">path_parentat()</a></tt>
is clearly the simplest; it just wraps a little bit 
of housekeeping around <tt>link_path_walk()</tt> and returns the parent
directory and final component to the caller.  The caller will be either
aiming to create a name (via <tt>filename_create()</tt>) or remove or rename
a name (in which case <tt>user_path_parent()</tt> is used).  They will use
<tt>i_mutex</tt> to exclude other changes while they validate and then
perform their operation.</p>
<p>
<tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n2088">path_lookupat()</a></tt>
is nearly as simple; it is used when an existing 
object is wanted such as by <tt>stat()</tt> or <tt>chmod()</tt>.  It
essentially just 
calls <tt>walk_component()</tt> on the final component through a call to
<tt>lookup_last()</tt>.  <tt>path_lookupat()</tt> returns just the final dentry.</p>
<p>
<tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n2410">path_mountpoint()</a></tt>
handles the special case of unmounting, which must 
not try to revalidate the mounted filesystem.  It effectively
contains, through a call to <tt>mountpoint_last()</tt>, an alternate
implementation of <tt>lookup_slow()</tt>, which skips that step.  This is
important when unmounting a filesystem that is inaccessible, such as
one provided by a dead NFS server.</p>
<p>
Finally <tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n3270">path_openat()</a></tt>
is used for the <tt>open()</tt> system call; it 
contains, in support functions starting with
<tt>do_last()</tt>, all the
complexity needed to handle the different subtleties of <tt>O_CREAT</tt> (with
or without <tt>O_EXCL</tt>), final &quot;<tt>/</tt>&quot; characters,
and trailing symbolic 
links.  We will revisit this in the final part of this series, which
focuses on those 
symbolic links.  <tt>do_last()</tt> will sometimes, but not
always, take 
<tt>i_mutex</tt>,  depending on what it finds.</p>
<p>

Each of these, or the functions which call them, need to be alert to the
possibility that the final component is not <tt>LAST_NORM</tt>.  If the
goal of the 
lookup is to create something, then any value for <tt>last_type</tt> other than
<tt>LAST_NORM</tt> will result in an error.  For example if
<tt>path_parentat()</tt> reports <tt>LAST_DOTDOT</tt>, then the caller
won't try to
create that name.  They also check for trailing slashes by testing
<tt>last.name[last.len]</tt>.  If there is any character beyond the final
component, it must be a trailing slash.</p>

<h4>Revalidation and automounts</h4>
<p>
Apart from symbolic links, there are only two parts of the &quot;REF-walk&quot;
process not yet covered.  One is the handling of stale cache entries
and the other is automounts.</p>
<p>
On filesystems that require it, the lookup routines will call the
<tt>-&gt;d_revalidate()</tt> dentry method to ensure that the cached
information is current.  This 
will often confirm validity or update a few details from a server.  In
some cases it may find that there has been change further up the path
and that something that was thought to be valid previously isn't
really.  When this happens the lookup of the whole path is aborted and
retried with the <tt>LOOKUP_REVAL</tt> flag set.  This forces
revalidation 
to be more thorough.  We will see more details of this retry process in
the next article.</p>
<p>
Automount points are locations in the filesystem where an attempt to
lookup a name can trigger changes to how that lookup should be
handled, in particular by mounting a filesystem there.  These are
covered in greater detail in <tt><a
href="https://www.kernel.org/doc/Documentation/filesystems/autofs4.txt">autofs4.txt</a></tt>
in the Linux documentation 
tree, but a few notes specifically related to path lookup are in order
here.</p>
<p>
The Linux VFS has a concept of &quot;managed&quot; dentries which is reflected
in function names such as <tt><a
href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/namei.c?id=052b398a43a7de8c68c13e7fa05d6b3d16ce6801#n1138">follow_managed()</a></tt>.
There are three
potentially interesting things about these dentries corresponding
to three different flags that might be set in <tt>dentry-&gt;d_flags</tt>:

<dl>
<dt><tt>DCACHE_MANAGE_TRANSIT</tt></dt>
<p>
<dd>
If this flag has been set, then the filesystem has requested that the
<tt>d_manage()</tt> dentry operation be called before handling any possible
mount point.  This can perform two particular services:</p>
<ol>
<li>
It can block to avoid races.  If an automount point is being
unmounted, the <tt>d_manage()</tt> function will usually wait for that
process to complete before letting the new lookup proceed and
possibly trigger a new automount.</p>
</li>
<p>
<li>
It can selectively allow only some processes to transit through
a mount point.  When a server process is managing automounts, it may
need to access a directory without triggering normal automount
processing.  That server process can identify itself to the
<tt>autofs</tt> filesystem, which will then give it a special pass through
<tt>d_manage()</tt> by returning <tt>-EISDIR</tt>.</p>
</li>
</ol>
</dd>
<p>
<dt><tt>DCACHE_MOUNTED</tt></dt>
<p>
<dd>
This flag is set on every dentry that is mounted on.  As Linux
supports multiple filesystem namespaces, it is possible that the
dentry may not be mounted on in <i>this</i> namespace, just in some
other.  So this flag is seen as a hint, not a promise.

If this flag is set, and <tt>d_manage()</tt> didn't return <tt>-EISDIR</tt>,
<tt>lookup_mnt()</tt> is called to examine the mount hash table (honoring the
<tt>mount_lock</tt> described earlier) and possibly return a new
<tt>vfsmount</tt> 
and a new <tt>dentry</tt> (both with counted references).</p>
</dd>
<p>
<dt><tt>DCACHE_NEED_AUTOMOUNT</tt></dt>
<p>
<dd>
If <tt>d_manage()</tt> allowed us to get this far, and
<tt>lookup_mnt()</tt> didn't
find a mount point, then this flag causes the <tt>d_automount()</tt> dentry
operation to be called.
<p>
The <tt>d_automount()</tt> operation can be arbitrarily complex and may
communicate with server processes etc., but it should ultimately either
report that there was an error, that there was nothing to mount, or
should provide an updated <tt>struct path</tt> with new <tt>dentry</tt> and
<tt>vfsmount</tt>.
In the latter case, <tt>finish_automount()</tt> will be called to safely
install the new mount point into the mount table.</p>
</dd>
</dl>
<p>
There is no new locking of import here and it is important that no
locks (only counted references) are held over this processing due to
the very real possibility of extended delays.
This will become more important next time when we examine RCU-walk
which is particularly sensitive to delays.</p>
<p>
<h4>To be continued</h4>
<p>
With a dcache and a mount table, slashes at the start and the end,
final components handled multiple ways and with a variety of locking
primitives; we have already examined, and hopefully understood, a fair
degree of complexity.  There is still more to come though.  Next week
we will build on this to explore the very different challenges that
arise when we try to perform pathname lookup without taking any locks
at all.</p>
<p>
Finally, I'd like to make a note of thanks to Al Viro for reviewing an
early draft of this article and highlighting a number of errors.</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Virtual_filesystem_layer">Filesystems/Virtual filesystem layer</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Brown_Neil">Brown, Neil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/649115/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor649563"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pathname lookup in Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 27, 2015 1:04 UTC (Sat)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/649563/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      This is great!  Could we get some version of this in /Documentation?
      
          <div class="CommentReplyButton">
            <form action="/Articles/649563/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor649565"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pathname lookup in Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 27, 2015 1:14 UTC (Sat)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/649565/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I believe that is Neil's ultimate goal, yes.  Suffice to say the docs maintainer would be glad to accept it!
      
          <div class="CommentReplyButton">
            <form action="/Articles/649565/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor649985"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pathname lookup in Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 1, 2015 23:07 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/649985/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite. I'm both cursing because I had to work half this out for myself a couple of weeks ago and really happy because I didn't have anything like the whole picture...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/649985/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor649991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pathname lookup in Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 2, 2015 0:44 UTC (Thu)
                               by <b>viro</b> (subscriber, #7872)
                              [<a href="/Articles/649991/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW, there's another couple of texts germinating - started as one whitepaper, but historical parts got out of control.  Once the merge window closes...<br>
<p>
BTW, speaking of things historical - does anybody know if there might be any chance of v8 having survived somewhere?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/649991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor661955"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pathname lookup in Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 25, 2015 0:21 UTC (Sun)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/661955/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="http://man.cat-v.org/unix_8th/">http://man.cat-v.org/unix_8th/</a> has the manpages at least. Ask there.<br>
<p>
Sven Maschek also hints at having access to the source of the v8 shell, at least: <a href="http://www.in-ulm.de/~mascheck/various/ancient/">http://www.in-ulm.de/~mascheck/various/ancient/</a><br>
<p>
It appears to be very much based on 4.1cBSD, so… look there, too. TUHS is always a good start.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/661955/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor710390"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pathname lookup in Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 2, 2017 5:13 UTC (Mon)
                               by <b>maruhan2</b> (guest, #113292)
                              [<a href="/Articles/710390/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm rather confused whether dcache is completely filesystem-specific. I read that VFS has its own inodes and dentries, separate to those of the filesystems. If that is true, why does VFS need them? How do they differ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/710390/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor710498"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pathname lookup in Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 2, 2017 21:53 UTC (Mon)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/710498/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can see that you are confused, and I acknowledge that the topic can be rather confusing, but I cannot tell from what you have written just what the cause of your confusion is, so I don't know how helpful I can be.  However:<br>
1/ The dcache is used by all filesystems.<br>
2/ The dentries are almost completely owned by the VFS - filesystems only play a small role in managing them, and only add a small amount of data.  For inodes, both the VFS and the filesystem work  extensively with the inode.  See <a href="https://lwn.net/Articles/446317/">https://lwn.net/Articles/446317/</a> for more on inodes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/710498/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
