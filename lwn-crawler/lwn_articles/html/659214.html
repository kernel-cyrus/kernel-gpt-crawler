        <!DOCTYPE html>
        <html lang="en">
        <head><title>strscpy() and the hazards of improved interfaces [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/659214/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/659115/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/659214/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>strscpy() and the hazards of improved interfaces</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 7, 2015</br>
           </div>
Back in the distant past (May 2015), LWN <a href="/Articles/643376/">looked
at</a> a couple of efforts to provide improved string-handling primitives
to the kernel.  One of those two was recently merged, while the other has
run into trouble; both cases highlight a fundamental concern Linus has
about this type of kernel patch.  The end result is that it is possible to
evolve the kernel toward safer interfaces, but attempts to do so as a series
of mass changes will probably not end well.
<p>
Normally, one does not expect to see a new API merged into the mainline
for an -rc4 release, but Linus decided to make an exception when
he pulled in the <tt>strscpy()</tt> patch just before 4.3-rc4.  That patch
set has changed a bit since it was examined here, though the intent is the
same: to provide a string-copy API that is safer and easier to use than
<tt>strncpy()</tt> or <tt>strlcpy()</tt>.  The new copy function is:
<p>
<pre>
    ssize_t strscpy(char *dest, const char *src, size_t count);
</pre>
<p>
This function will copy the string found in <tt>src</tt> to <tt>dest</tt>,
taking care not to overflow <tt>dest</tt>, which is <tt>count</tt> bytes
long.  Unlike <tt>strncpy()</tt>, it always null-terminates the destination
string.  The return value is the number of characters copied (without the
trailing <tt>NUL</tt> byte) — unless the string would not fit into
<tt>dest</tt>, in which case the return value is <tt>-E2BIG</tt>.
<p>
Unlike previous versions, <tt>strscpy()</tt> will always copy what it can,
returning a truncated string in <tt>dest</tt> if the whole thing does not
fit.  That change took away the need for the <tt>strscpy_truncate()</tt>
variant, so that function is no longer provided.  Opinions may differ on
whether returning a truncated string is the right thing to do, but there
were enough opinions in favor of doing so that this change needed to be
made to get the patch merged.
<p>
There are a number of advantages claimed for this API.  It lacks an
internal race condition found in the others, making it
more robust in the face of a string that changes while it is being copied.
The return value, it is claimed, more clearly indicates overflow than the
value returned by <tt>strlcpy()</tt>.  Unlike <tt>strncpy()</tt>, the
result is always a null-terminated string.  In the end, we might have
finally come up with a reasonable string-copy function after about four
attempts — not bad for such a complex task.
<p>
Anybody who is firing up their editor to start converting call sites in the
kernel to <tt>strscpy()</tt> may want to reconsider, though.  There is a
warning in both the fate of <tt>parse_integer()</tt> and Linus's comments
around the merging of <tt>strscpy()</tt>.
<p>
<tt>parse_integer()</tt> is the other string function covered in the May
article; its purpose is to make string-to-integer conversions easier and
more robust.  Linus recently <a href="/Articles/659215/">got rather
upset</a> about this patch set which, he thought, changed the semantics of
the API and introduced bugs.  Various call sites were changed to the new
functions and, in the process, some of them were broken.
The idea was that
<tt>parse_integer()</tt> would be a replacement for the kernel's
existing integer-conversion functions (<tt>simple_strtoul()</tt>,
<tt>kstrtoul()</tt>, and the like) but that the actual act of replacing
those functions introduced regressions.
<p>
Linus was clearly afraid that the <tt>strscpy()</tt> patch could end up
being a source of regressions as well.  That wouldn't happen with the
patch set itself, which does not convert any existing <tt>strncpy()</tt> or
<tt>strlcpy()</tt> call sites.  The problem happens when other,
well-intentioned developers start doing those conversions.  Linus described
his worries in <a
href="http://git.kernel.org/linus/30c44659f4a3e7e1f9f47e895591b4b40bf62671">the
merge commit</a> that brought in <tt>strscpy()</tt>:
<p>
<div class="BigQuote">
	So why did I waffle about this for so long?
<p>
	Every time we introduce a new-and-improved interface, people start
	doing these interminable series of trivial conversion patches.
<p>
	And every time that happens, somebody does some silly mistake, and
	the conversion patch to the improved interface actually makes
	things worse.  Because the patch is mindnumbing and trivial, nobody
	has the attention span to look at it carefully, and it's usually
	done over large swatches of source code which means that not every
	conversion gets tested.
</div>
<p>
To try to head off such an outcome, Linus has made it clear that he will
not be accepting patches that do mass conversions to <tt>strscpy()</tt>
(note though that certain developers are already <a
href="/Articles/659474/">considering mass conversions</a> anyway).
It is there to be used with new code, but existing code should not be
converted without some compelling reason to do so — or without a high level
of attention to the possible implications of the change.
<p>
One might be tempted to think that this proclamation from Linus signals the
end of the "trivial clean-up patch" era.  But that would almost certainly
be reading too much into what he said.  Patches that do not make functional
changes to the code do not, one would hope, pose the same sort of risk that
API replacements do.  So the flow of white-space adjustments is likely to
continue unabated.  But developers who want to convert a bunch of working
code to a "safer" interface may want to think twice before sending in a
patch.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#String_processing">String processing</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/659214/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor659699"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 12:19 UTC (Wed)
                               by <b>gerdesj</b> (subscriber, #5446)
                              [<a href="/Articles/659699/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Linus has made it clear that he will not be accepting patches that do mass conversions"<br>
<p>
Quite right too.  It's a little worrying that a good engineering practice pronouncement from Mr T could actually cause any form of controversy. The road to OOPs is paved with good intentions and mass code changes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659699/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor659702"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 12:57 UTC (Wed)
                               by <b>sorokin</b> (guest, #88478)
                              [<a href="/Articles/659702/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the end of the "trivial clean-up patch" era.</font><br>
<p>
It is a pity that the kernel doesn't have any automated testing. Refactoring/cleanups are much less scarier when test coverage of a program is good.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659702/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 13:35 UTC (Wed)
                               by <b>compenguy</b> (guest, #25359)
                              [<a href="/Articles/659711/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Automated test coverage is difficult when most of the code paths are dead without the appropriate hardware.  It would be an incredible undertaking to try to reason about what types of hardware are needed and what types of operations need to be performed with them in order to get some acceptable amount of coverage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659722"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 14:13 UTC (Wed)
                               by <b>NAR</b> (subscriber, #1313)
                              [<a href="/Articles/659722/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess the are hardware-independent parts in the kernel like the TCP/IP stack or memory management or module loading which could be thoroughly tested with some mocking. I also guess that these are the most interesting bits in the kernel from security perspective as this code runs on all systems. There one could have good enough automatic test coverage to feel safe to do mass conversion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659722/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659761"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 16:20 UTC (Wed)
                               by <b>smckay</b> (guest, #103253)
                              [<a href="/Articles/659761/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are they really the most interesting, though? NSA has their portfolio of implants targeting very specific hardware configurations. The number of systems affected by a driver vulnerability is much lower, but you're also much more likely to be able to do things like overwriting firmware.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659761/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor660367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2015 3:57 UTC (Mon)
                               by <b>jwarnica</b> (subscriber, #27492)
                              [<a href="/Articles/660367/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Depends on what you mean by "interesting". I'm not even the slightest a kernel hacker, but given the existence of paravirtualization (e.g. fake, contrived) hardware, it isn't difficult to believe most of the OS isn't drivers, and, from that, that writing a stub driver is too difficult to stub out.<br>
<p>
If they wanted code coverage, they would have it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor659763"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 16:25 UTC (Wed)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/659763/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was thinking along the same lines, could you create a chalk line in the kernel separating the hardware-independent infrastructure of the kernel from the drivers and architecture dependent infrastructure and at least carve out a part which is testable?<br>
<p>
Heck, if you put a gateway between the highly-tested parts and the others you are half way to a micro-kernel 8-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659763/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor659823"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 20:49 UTC (Wed)
                               by <b>riddochc</b> (guest, #43)
                              [<a href="/Articles/659823/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think this would be a particularly good use of QEMU - one person can write a (relatively) high-level simulation of the hardware that a driver's targeting, and another can write the kernel driver to talk to it.  This could help with validating that the kernel works against the way you expect the hardware's interfaces to work.<br>
<p>
That said, it doesn't mean that the hardware actually works that way.  As far as testing goes, this would be a big step forward, but still not quite a substitute for having the actual hardware to test against.<br>
<p>
QEMU is a remarkable piece of software, made even better by KVM.  It enables lots of things that would have been difficult or tedious before, like this sort of testing.  It could use more documentation, but it's well worth spending some time with to see what it can offer.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659823/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor659717"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 13:54 UTC (Wed)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/659717/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are multiple independent projects for automated kernel testing. But regardless, it is extremely naive to expect that all the different overflow cases case of string processing are covered with tests. Even projects with high test coverage probably don't do that, because such code paths often don't include conditionals, thus don't count against coverage.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659717/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor660025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 20:43 UTC (Thu)
                               by <b>robclark</b> (subscriber, #74945)
                              [<a href="/Articles/660025/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  It is a pity that the kernel doesn't have any automated testing. Refactoring/cleanups are much less scarier when test coverage of a program is good.</font><br>
<p>
you mean like <a href="http://kernelci.org/">http://kernelci.org/</a> or 0-day kbuild robot thing (which iirc is doing boot tests on qemu?)<br>
<p>
(granted that probably doesn't scratch the surface when it comes to driver coverage w/ all the different hw that is out there)<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor660988"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 16, 2015 5:40 UTC (Fri)
                               by <b>ksandstr</b> (guest, #60862)
                              [<a href="/Articles/660988/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux has tens and tens of megabytes of source c^W^Wtest debt. Its various systems and subsystems are well interlinked and mostly without formal characterization even in isolation, let alone in combination. Writing tests to cover even a significant core (e.g. mm, vfs, ipc, block, char, sockets, ip stack) would be an exercise in archaeology as much as engineering, and the timetable for such an effort would easily reach into the early to mid 2020s.<br>
<p>
In addition, tests rot and turn crusty. Old tests accrete and become difficult to validate (even if test validation were automated) as the collective knowledge used as their basis fades. At that point one could insist on formal specs, and then derive tests from those specs concurrently with the implementation, so that test rot is preceded by spec rot by at least one rung on a metaphorical ladder of things I'll climb tomorrow (honest!) because The Boss wants results last week.<br>
<p>
Not to mention that there's at least two incompatible schools of test-writing, just divided by style of tool: the multiple-assertion tests (as in Check, JUnit, etc), and the multiple-point tests (Perl's Test Anywhere Protocol). The latter has great density, produces an useful output for successful tests, and offers many comforts for the programmer, whereas the former is popular and well familiar to the Java generation (those who studied after 2000).<br>
<p>
Running all these tests as part of regular development, i.e. so that a TDD-ey test replaces operator interactions, would also become more difficult as coverage increases. Tens of megabytes of code means hundreds of megabytes of test code, and if each of (say) 20,000 tests runs for five seconds, then the grand suite would execute serially in ~28 hours. That's long enough that 1/100 of it is too long a break to sustain programmer attention over an edit-compile-test cycle.<br>
<p>
So there's quite a few obstacles there, with few gains early on (the first decade?). I've not even touched on the architectural testability issues, i.e. whether it's even possible to programmatically explore significant areas of the (state * parameter) space for various important operations within the kernel.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660988/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor659710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 13:29 UTC (Wed)
                               by <b>pj</b> (subscriber, #4506)
                              [<a href="/Articles/659710/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can't this kind of change be automated via Coccinelle ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659721"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 14:23 UTC (Wed)
                               by <b>rriggs</b> (guest, #11598)
                              [<a href="/Articles/659721/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Someone has to decide, in each case it is introduced, what the right thing to do in the event -E2BIG is returned.  You cannot always simply percolate that error up the call stack or transform it to another valid return value.  Doing so may violate invariants which must be maintained before the function returns.  I would not necessarily be concerned with the 99% of code where that would work.  My concern would be with the 1% (or less) where the simple transformation is the wrong thing to do.  It is those that slip through the cracks when doing a mass replace, whether by a human or by machine.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659721/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659822"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 20:43 UTC (Wed)
                               by <b>utoddl</b> (guest, #1232)
                              [<a href="/Articles/659822/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      One could argue that, in each case it is introduced, if the code to handle -E2BIG isn't already written, then there's an existing bug waiting to be hit.
      
          <div class="CommentReplyButton">
            <form action="/Articles/659822/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor660381"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2015 9:00 UTC (Mon)
                               by <b>JdGordy</b> (subscriber, #70103)
                              [<a href="/Articles/660381/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
2 problems... <br>
<p>
1) There is going to be someone somewhere which depends on that behaviour(!)<br>
2) The code might be there but not in the immediate area so you'd miss it with mass replace (i.e the safety checks are performed up the call chain so you'd end up adding unnecessary code because "you" thought there was a preexisting bug because the code isnt understood enough.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660381/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor659703"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 13:34 UTC (Wed)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/659703/">Link</a>] (27 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's pleasing to see disrespect for strlcpy. That is on the list of interfaces that, used correctly, looks wrong, and used wrong looks OK.  It's better that gets, which is always wrong, and worse than strtok and its variants, which are just strictly worse than doing it "by hand" without introducing actual faults.<br>
<p>
Ultimately, though, all the hand-wringing is really over what a weak language C is.  I will be happy to see Rust begin to displace C, particularly in codecs, which are a particularly dense source of security holes that have no reason to exist.  Since Rust is entirely compatible with kernel code, needing no special runtime support, we might reasonably hope to see it in kernel code soon, starting probably with drivers. Torvalds has to know that any rants over it will just make him look foolish, so we should only need to wait on more maturity in the compiler.  (That is not to say that is how it will go.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659703/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 13:58 UTC (Wed)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/659720/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Torvalds has to know that any rants over it will just make him look foolish</font><br>
<p>
Was there a rant about Rust by Torvalds that I missed, or are you referencing his rants against C++?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 19:57 UTC (Wed)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/659816/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Was there a rant about Rust by Torvalds that I missed, or are you referencing his rants against C++?</font><br>
<p>
I don't know if there was any specific Rust rant, but his C++ looks really dated these days.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor660012"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 19:23 UTC (Thu)
                               by <b>lsl</b> (subscriber, #86508)
                              [<a href="/Articles/660012/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why? Linus' more well-known C++ rants are just as relevant to modern C++ as they are for C with classes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660012/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor662255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LT's C++ rants</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 28, 2015 15:39 UTC (Wed)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/662255/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How come? Linus' 2007 C++ rant, analyzed:<br>
<p>
1. C++ programmers are idiots<br>
<p>
this is one of LT's least brilliant moments, IMNSHO.<br>
<p>
2. C++ leads to bad design choices<br>
<p>
yeah, and still does somewhat but look: kernel-C uses more or less the same design choices, and loses the correctness checks that C++ would give. RAII, people. RAII.<br>
<p>
3. STL &amp; Boost are non-portable, non-stable OR<br>
<p>
old-school<br>
<p>
4. STL &amp; Boost can be nice, but are full of hidden surprises<br>
<p>
old-school<br>
<p>
5. C++ is unportable<br>
<p>
where there is gcc, there is g++ and libstdc++; and probably clang++ and libc++ too.<br>
<p>
He had reservations (in a 2004 post IIRC) about exceptions, too (because at the time they were expensive even when non-used... which nowadays is ancient history). Other thing he had ample reason (and still has, in some way) is that the type system causes ginourmous illegible error messages (but this has been mitigated a lot both by clang++ and g++ lately).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/662255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor659737"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 15:20 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/659737/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Somebody already rewrote a kernel using Rust and wrote a research paper about it.<br>
<p>
Top of the list of problems are boxed types like Arc, which require dynamic allocation. But Rust provides no way to handle OOM for these hidden allocations except to terminate the thread.<br>
<p>
Rust needs a simple exception mechanism, perhaps similar to Lua's pcall(), which allows you stop a stack unwind. But the majority of Rust developers seem adamant that it's impossible to handle OOM correctly or cleanly (correctly even, without hacks like emergency pools), despite the fact that people have been doing it for ages, and that it would be even easier with Rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659737/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659740"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 15:22 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/659740/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That last parenthetical was meant to be inserted after "for ages".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659740/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor659820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 20:31 UTC (Wed)
                               by <b>arielb1@mail.tau.ac.il</b> (guest, #94131)
                              [<a href="/Articles/659820/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust's standard collections library is very intentionally not designed to handle OOM, to keep implementation complexity under control. Rust is perfectly usable without that library - kernel applications probably want to use different data structures anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659844"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 22:55 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/659844/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>
Per the paper:
</p>

<blockquote><pre>
The standard recommendation in rust is to never
write a function that directly returns a boxed
object[5]. Instead, the function should return the object
by value and the user should place it in a box using
the box keyword. This is because (as mentioned in
subsubsection 3.1.1) rust will automatically rewrite
many functions returning objects to instead use outpointers
to avoid a copy.
(3.3.1p2 of http://scialex.github.io/reenix.pdf)
</pre></blockquote>

<p>
Rust is designed around the notion of immutability and copy-by-value, with the compiler optimizing the copies away. If you have to use mutable references everywhere you would use a pointer in C (because Rust no longer has pointers at all, AFAIU), wouldn't it make it impossible to write idiomatic Rust code? Mutable types come with significant constraints regarding what you can do with the value and when, so it seems to me like it'd be a heavy burden. But I haven't used Rust before, so probably I'm missing something here.

      
          <div class="CommentReplyButton">
            <form action="/Articles/659844/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 2:21 UTC (Thu)
                               by <b>jameslivingston</b> (guest, #57330)
                              [<a href="/Articles/659862/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not quite, it's more "exclusive mutability" than immutability. You can mutate memory provided that there cannot be any aliased pointers to the memory (using C terms), because it would be unsafe to mutate memory that something else could be reading to or writing from. If you want to allow that, you need to put the structure inside a sync::Mutex, where getting the reference to the interesting structure acquires the lock for you (and releases the lock when the reference goes out of scope).<br>
<p>
<p>
There are a lot of places in low-level code (collection implementations, concurrency things, etc) where you want to allow multiple mutable references to memory, and Rust lets you do that provided you do it in an block marked "unsafe", which turns off the compiler checking and is the programmer promising to maintain memory safety. The advantage is that those lower level bits of code can expose safe function with unsafe blocks inside them, meaning the implementer takes responsibility for correctness but the user does not have to worry, unlike something like Haskell's IO Monad which requires making everything up the call chain also in IO.<br>
<p>
<p>
Rust used in a kernel would use little to none of the standard Rust library. Unlike most recent languages, it's a library not a runtime - just like C, and the kernel doesn't use lib's malloc().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 3:37 UTC (Thu)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/659869/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The advantage is that those lower level bits of code can expose safe function with unsafe blocks inside them, meaning the implementer takes responsibility for correctness but the user does not have to worry, unlike something like Haskell's IO Monad which requires making everything up the call chain also in IO.</font><br>
<p>
... but more or less exactly like Haskell's `unsafePerformIO` primitive, which takes an IO block and executes it inside pure code, leaving it up to the implementer to take responsibility for correctness while exposing a safe (i.e. pure) interface.<br>
<p>
The IO type is for the majority of IO-based functions which do _not_ expose a pure interface.<br>
<p>
There is also the ST type, which permits mutation of local variables without the possibility of I/O. In this case the language enforces the purity of the interface; only pure values are permitted to escape the ST computation via the `runST` primitive. By taking advantage of rank-2 polymorphism, the language ensures that any attempt to pass a reference to an ST variable outside `runST` and into pure code results in a type error.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor659760"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 16:12 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/659760/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can think of more ways for strscpy to cause trouble than strlcpy. Mixing signed and unsigned types doesn't often end well, especially in C. Overloading the return value is a bad habit of many C developers, especially kernel developers.<br>
<p>
But ultimately I think the difference is slight. The scorn some people show for strlcpy goes beyond all reason. I'd be happy to see either interface become standardized, but the fact of the matter is that strlcpy is already much more widely used and is a de facto standard. Any deficiencies in the semantics are overcome by the huge amount of production and example code out there using it correctly, often with copious descriptions.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659760/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659779"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 17:53 UTC (Wed)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/659779/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
strlcpy needs to read src beyond the specified length. Not only this slows thing down for no good reason, but this is potentially very dangerous especially in kernel context. This cannot be fixed by good use.<br>
<p>
I agree that -E2BIG is dangerous.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659779/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659827"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 20:57 UTC (Wed)
                               by <b>reubenhwk</b> (guest, #75803)
                              [<a href="/Articles/659827/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; strlcpy needs to read src beyond the specified length.</font><br>
<p>
Only when dst is shorter than src right?<br>
<p>
<font class="QuotedText">&gt; Not only this slows thing down for no good reason</font><br>
<p>
The reason is to inform the caller how large dst needs to be for success in the case of a failure.  That seems like a very good reason to me.  I doubt the extra slowness would be measurable in a typical use case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659827/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor659812"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 21:04 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/659812/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>
Huh. So that's what's meant by supposedly being free of a race condition?
</p>

<p>
But if src isn't properly NUL terminated there are much bigger problems afoot. strscpy is claiming to the unwary user that it's somehow safer (or worse, safe without qualification) in a context where the src may be corruptible. But that's a guarantee it can't make. An attacker isn't always limited to writing forward in step with the loop in strscpy. I would think such a constraint would be the exception rather than the rule. As src is only being read, what we're concerned with here are information leaks or reads of unmapped memory, both of which are still possible if you can't trust the src.
</p>

<p>
strscpy seems especially problematic for making such a claim. It has the same problems as strlcpy when the user makes the wrong assumptions about the return value, but also intentionally misleads them about the semantics. And for all the ridicule, it still adopts strlcpy's poorly ordered argument list inherited from strncpy which has _actually_ been a factor or cause in many misuses of strlcpy--accidentally passing a src length (or otherwise src-derived value) instead of a destination buffer size.
</p>

<p>
If people were serious about the claimed strlcpy deficiencies, I would think they'd adopt something like error_t strscpy(char *dst, size_t *len, size_t lim, const char *src).
It's not a drop-in replacement for strncpy (or strlcpy), requiring people to pay attention to any code refactor, but just as easy to use given that to use the computed length of either strscpy or strlcpy properly you already need a named variable. The error condition and length are communicated via two separate values, significantly reducing the likelihood that the length will be used uncheck. Indeed, the length could even be set to 0 on error. And when inlined it should perform just as well as either alternative.
</p>

<p>
Otherwise, all the debate just seems like bike shedding and NIH syndrome. It seem disingenuous to fault strlcpy for problems that aren't fixed by the alternative. The only difference from strlcpy in the implied misuse scenario is the possibility of a compiler warning, notwithstanding that signed-to-unsigned conversions are legal. And strscpy could be worse because (size_t)-E2BIG is likely to be much bigger than the src length. (OTOH, it could be better, leading to segfaults more quickly.) strlcpy was a pragmatic compromise. It would seem so is strscpy, reflecting a certain set of preferred esthetics and compromises that certainly aren't objectively better than strlcpy.
</p>

<p>
At the very least the inclusion adds weight to the argument that glibc's stance has been misguided all along. These sorts of routines have utility and address a legitimate gap in C's string handling API. The real issue comes down to having to wade through the bike shedding, which I guess I can't fault glibc maintainers for wanting to avoid. musl libc has added strlcpy, though, and by most accounts musl reflects exceptional code quality. Maybe glibc will acquiesce, or at least propose an objectively better interface.
</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659812/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor660046"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 22:32 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/660046/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Last I heard glibc was going to cave on strlcpy, more's the pity.<br>
<p>
Almost always just "if (0 &gt; strscpy" suffices.  But if somebody meant to adopt a sensible interface, that would always suffice, because it would take two more arguments, a size_t* and a size_t, with the latter an offset and the former a place to record the offset of the NUL after the copy.  But sensible is too much to expect when strlcpy seems like a good idea to many.  (And, no, the pointer alone isn't enough; it's too easy to forget to initialize what it points at before the call.). The name of the sensible interface would be strto(), because long, cryptic names with mystifying initials do nobody any good.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660046/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor659818"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 20:23 UTC (Wed)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/659818/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
strlcpy isn't standard anywhere except maybe OpenBSD and even there it's almost always wrongly used (what's with the lack of return value checking?). so no, that thing should not live any longer and it's a pity that it had infected so many minds over time. strscpy is almost sane save for the badly named and placed destination size argument and allowing a size over SSIZE_MAX (both of which are easily fixable of course).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659818/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659833"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 22:05 UTC (Wed)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/659833/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Almost always used wrongly? Care to back that claim up with data? Anecdotes don't count. But FWIW when OpenBSD first settled on strlcpy, they surveyed their ports tree for misuses of strcpy and strncpy, as they tend to do when developing and adopting these kinds of interfaces.<br>
<p>
Regarding not checking the return value: many times strlcpy is replacing code that already didn't check for the return value, and added as a stop-gap. More importantly, not checking for a return value is not always a bug, or even usually a bug, in the contexts where you add strlcpy. Checking the return value is neither necessary nor sufficient as a general matter; it's context specific.[1] If the semantics of the code are garbage-in, garbage-out, then not checking for truncation is not necessary. If the semantics are that truncated input could subvert some condition, then checking for truncation is not always sufficient. Coding an algorithm so that garbage-in is safely garbage-out is arguably the most robust way to write secure code. If the data is highly structured, you probably shouldn't be using C strings much. Separating constraint checks from the core algorithm that processes input is an anti-pattern when writing secure code--it's usually better to put constraints on the _actual_ state of the algorithm processing the input. This is why, for example, Lua removed it's bytecode validator--it was neither necessary nor sufficient, and in practice added needless complexity; remove needless complexity and it becomes easier to focus on finding and fixing bugs in the code that matters.<br>
<p>
And strscpy is hardly better relative to strlcpy weak points. strscpy overloads the return value just like strlcpy does. If you don't check for a failure condition, the length will be too large (extremely large in the case of (size_t)-E2BIG). And nothing inherent in strscpy forces a developer to check for truncation.<br>
<p>
You could argue truncation checking is slightly less prone to bugs. The obvious issue with strlcpy is using n &gt; lim instead of n &gt;= lim to compare, an off-by-one. But I could just as easily envision people doing n &lt;= 0 or n == E2BIG instead of n &lt; 0 or n == -E2BIG with strscpy. What matters is the _idiom_ that people will use and adopt. And in any event, in both case the misuses are fairly easy to locate using pattern matching.<br>
<p>
It's a shame that so many otherwise rational people have adopted such an irrational aversion to strlcpy. There's so much poor reasoning involved. Even if it was the worst interface in the world, the situation is compounded by creating conditions where people constantly reimplement it, often with bugs. It's widely included in many projects; attempts at berating people into not using it have manifestly failed. It's like the war on drugs. Yes, drugs harm society--largely as a result of abuse by a small subset of individuals (sorta like the specter of strlcpy misuses). Yes society would be better off without drugs. And yet banning them does't work.<br>
<p>
<p>
[1] Grepping for an unchecked strlcpy in the OpenBSD source tree, the first hit brings me to line 776 in bin/csh/csh.c. rechist is copying a command-line into the history buffer. It's old, crufty code, dating to the 1980s. That edit was made in 2003 and replaced a use of strcpy. There's no easy way to bubble up a truncation error, and panicing or exiting failure on a truncation could break existing code; indeed it could introduce security issues of its own by obscuring the exit status of the command. And truncation in this context is about as benign as these things come in the real world. Would you suggest refactoring all of the logic in csh related to management of the history buffer? Make it all dynamicalliy allocated, as GNU developers insist upon? Reject command-lines longer than a record buffer when in interactive sessions? Yeesh.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659833/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 22:54 UTC (Wed)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/659843/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Almost always used wrongly? Care to back that claim up with data?</font><br>
<p>
check their kernel tree for strlcpy, it's called over 1800 times, 10 of which check the return value (8 of which are in ofdev.c), 2 of them blindly accumulate its return value and the rest do exactly nothing which means potential silent truncation. from here on the argument can go two ways, neither of which is good for your case. either those silent truncations cannot occur in which case strlcpy is utterly useless or they can occur in which case the use of strlcpy is wrong.<br>
<p>
<font class="QuotedText">&gt; Regarding not checking the return value: many times strlcpy is replacing code that already didn't check for the return value, and added as a stop-gap.</font><br>
<p>
you've just proved how strlcpy encouraged even more sloppy programming. the copy-paste hoard turned one kind of bug into another. i wouldn't call that progress let alone an example to set for others to follow.<br>
<p>
<font class="QuotedText">&gt; And strscpy is hardly better relative to strlcpy weak points.</font><br>
<p>
it is infinitely better as it doesn't waste cycles to compute a useless strlen that pretty much no caller cares about. in other news, you must have never written code that tries to copy out substrings from a big one using strlcpy. face it, strlcpy is a design mistake that should just die.<br>
<p>
<font class="QuotedText">&gt; And nothing inherent in strscpy forces a developer to check for truncation.</font><br>
<p>
that's a strawman, nothing forces anybody to check anything at this rate. if people care about callers doing the right thing then there's __must_check in linux (a gcc attribute so it's not really specific to the kernel) but given how nobody cares about truncation (or at least doesn't want to learn about it from str*cpy) i can understand why it's not enforced. IOW, i don't think the return value even matters, if there's a potential of truncation and it matters, the callers will already have to do something else and the return value from str*cpy is irrelevant.<br>
<p>
<font class="QuotedText">&gt; It's a shame that so many otherwise rational people have adopted such an irrational aversion to strlcpy.</font><br>
<p>
it's a shame that so many otherwise rational people have adopted such an irrational affection to strlcpy. how about you resort to rational arguments instead of cheap rhetoric?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659891"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 8:40 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/659891/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>either those silent truncations cannot occur in which case strlcpy is utterly useless or they can occur in which case the use of strlcpy is wrong.</blockquote>
I would suggest a third: they "cannot occur" as far as the programmer knows, and as far as anyone who has reviewed the code knows - but since the programmer is only human, it is possible he or she has made a mistake.  In the case of such a mistake, a silent truncation of the string is less bad than allowing a buffer overflow.
<p>
I'm not saying this is the best way to do things.  Personally, if the truncation "cannot occur", I would rather use a string-copying function which just panics the kernel if that "impossible" condition should ever happen in practice.  But I guess the programmers of OpenBSD have their reasons for preferring the way they do it.  This is defensive programming: code which is demonstrably wrong, since it is predicated on something which will "never" happen (an input not meeting a precondition, an out-of-range value in something which has already been range-checked earlier, and so on), but which given human fallibility may have some value in practice.
      
          <div class="CommentReplyButton">
            <form action="/Articles/659891/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 9:15 UTC (Thu)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/659894/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
there's no third case, i gave an exhaustive categorization ;). your 'third case' is part of my second case and that is exactly where most of the strlcpy uses get it wrong. your remaining comment shows the sad consequences of the mindset that strlcpy advocates have kept spreading: instead of solving the problem properly, just replace one problem with another (which is pretty ironic when you consider that many BSD people used to advocate for 'solutions, not hacks' in the past).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor659885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 7:37 UTC (Thu)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/659885/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But I could just as easily envision people doing n &lt;= 0 or n == E2BIG instead of n &lt; 0 or n == -E2BIG with strscpy. What matters is the _idiom_ that people will use and adopt.</font><br>
<p>
This is the kernel we're talking about and there error codes less than zero are used throughout to handle exceptions. Arguably this means this function will fit in perfectly with the rest of the kernel thus reducing errors of this sort. The idiom is the same as for the rest.<br>
<p>
Now, if they were proposing that *user-space* use this function, you'd have a point because error handling in C is all over the place, even within the C library, so that chance of issues is higher. Fortunately, no-one is proposing strscpy for user space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor659880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 6:47 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/659880/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't it more over what a weak kind of 'string' type C, and C programmers, use by default?  If K&amp;R back in the day had defined struct string { size_t s; char * buf } and not resorted to the kludge of 0-termination, most of these issues would go away.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor660056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2015 0:12 UTC (Fri)
                               by <b>Richard_J_Neill</b> (subscriber, #23093)
                              [<a href="/Articles/660056/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In addition, functions such as strlen() would be very much faster, and counting back from the end of a string (e.g. to check a file extension) would be more efficient. But we would have the problem of wasting 4 extra bytes (we'd probably need to keep the null-termination for safety/compatibility), and there would be issues when a string's length exceeded 4 GB.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor660062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2015 0:55 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/660062/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are also a lot of times when you take a string in and need to split it up. With C strings, you can frequently do this in place by replacing delimiter characters with nulls and creating pointers to the starts of the strings.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor660217"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2015 2:07 UTC (Sat)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/660217/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wrote some nice and fast URL parsing code which builds an array of {size_t len, char *buf} structures out of an immutable string. Its just like creating pointers to the start of strings except I don't scribble over the source string which means I don't have to copy it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660217/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor660389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2015 12:05 UTC (Mon)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/660389/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And with 'pointer + length' strings you can do it without having to replace delimiter character with nulls..<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor767571"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 4, 2018 0:47 UTC (Thu)
                               by <b>klossner</b> (subscriber, #30046)
                              [<a href="/Articles/767571/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's eight extra bytes (on a 32-bit machine), four each for the length and pointer.  C was developed when userspace RO data + heap couldn't exceed about 56K bytes (on a PDP-11, the first popular Unix machine).<br>
<p>
A more likely design choice at the time would have been the UCSD Pascal scheme in which the first  bytes of the char array contain the length.  On the PDP-11, a two-byte length was sufficient.  But that would have given up the convenience that a pointer to string is a pointer to the first byte of its data, allowing the same function to take either a string or a non-string buffer, e.g.<br>
write(1, "Hello, world\n", 13).<br>
<p>
Buffer overflow wasn't on the radar much for 16-bit machines.  We had so little space that we took better care of it.  Then the 32-bit VAX came along and that discipline went by the wayside.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/767571/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor659796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 18:36 UTC (Wed)
                               by <b>madscientist</b> (subscriber, #16861)
                              [<a href="/Articles/659796/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&lt;obpedant&gt;Using "count" in the function declaration is needlessly confusing, IMHO; it wasn't immediately obvious to me that this would or would not include the nul byte.  I would prefer a name like "destsz" or similar to make it more clear that it's the size of the destination buffer.  Obviously this is basically just documentation, but documentation is important...&lt;/obpedant&gt;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 19:49 UTC (Wed)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/659814/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't like the parameter order. I'd have preferred:<br>
<p>
  ssize_t strscpy(char * dest, size_t destlen, char const * src);<br>
<p>
where the destination buffer and its size are together as the first two parameters, as they are for snprintf(), fgets(), fread(), strftime(), and probably some others that I'm forgetting right now.<br>
<p>
I realise that this is to be consistent with the parameter order/meaning of strncpy() and strlcpy() (and memset()) - but I think the parameter order for those functions is daft too. Obviously we can't change them, but that doesn't stop them from being Wrong, and it doesn't mean we have to copy them in the future.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 20:37 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/659821/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Which is wrong. It's natural to place the source first and destination second.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659831"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 21:06 UTC (Wed)
                               by <b>reubenhwk</b> (guest, #75803)
                              [<a href="/Articles/659831/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seems like a stretch to use 'wrong' and 'natural' here.  It's just a matter of perspective and opinion...  Words like "works", "is appropriate", "conforms to", would be much more suitable in this case....<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659831/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor659836"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2015 21:11 UTC (Wed)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/659836/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That depends heavily on what interfaces you're used to.  Leaving aside the longstanding convention of "strcpy", which would make swapping the order confusing, putting the destination on the left evokes an assignment: "dest = src;".<br>
<p>
(See also opinions on AT&amp;T versus Intel assembly syntax.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659836/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor659993"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 18:19 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/659993/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As someone who's written a lot of C over the years, and is used to str*cpy(), mem*cpy(), memmove(), *s*printf(), strftime(), fgets() and fread(), having the destination buffer first seems very natural  to me.<br>
<p>
Yes, I know that read(), gettimeofday(), getrusage(), getrlimit() and others have the destination buffer last, but they seem like the odd ones out to me.<br>
<p>
(My sense of tidyness is less aggravated by the *_r() functions, as creating an updated API by appending a parameter to the new function seems less disruptive than reordering the existing parameters.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659993/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor659922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 12:28 UTC (Thu)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/659922/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why is truncation a good idea?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor659979"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 16:43 UTC (Thu)
                               by <b>reubenhwk</b> (guest, #75803)
                              [<a href="/Articles/659979/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Truncation, by itself, is not a good idea...but truncation is a better idea than overrunning an array or leaving a string unterminated in the case of an error...In those cases I pick truncation as a better alternative.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/659979/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor660001"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2015 18:33 UTC (Thu)
                               by <b>Karellen</b> (subscriber, #67644)
                              [<a href="/Articles/660001/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the comment was in reference to the behaviour of strscpy() in earlier versions of the patchset, which, rather than truncating the destination string (or overrunning, or leaving unterminated), instead placed a NUL byte at the very start, giving you a totally empty string.<br>
<p>
If the problem with strlcpy() is that people would still use the truncated string after ignoring the return value being too big, then I'm not entirely convinced that just changing the return value to -E2BIG will fix that. Making an overrun provide an empty string to the caller seems like it would be even less ignorable and more likely to result in even more robust code.<br>
<p>
Is truncation a better alternative than NULing the string? I am not yet convinced - but I have not read the thread where such arguments are likely to have been explored.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660001/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor660254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2015 15:20 UTC (Sat)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/660254/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My comment was about truncating the string at the end of the buffer in the case where the whole string doesn't fit into the buffer. In userspace at least this can have various consequences from breaking UTF-8 characters to incorrect filesystem access. Not sure about kernelspace though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor660902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 15, 2015 17:02 UTC (Thu)
                               by <b>dfsmith</b> (guest, #20302)
                              [<a href="/Articles/660902/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Is strscpy functionally equivalent (though presumably faster than) the following?<br/>
<tt>#define strscpy(DEST,SRC,LEN) ((strncpy(DEST,SRC,LEN)[(LEN)-1]='\0',strnlen(SRC,LEN)&gt;=(LEN))?-E2BIG:strlen(DEST))</tt></p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor660961"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strscpy() and the hazards of improved interfaces</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 15, 2015 22:47 UTC (Thu)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/660961/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
strncpy overwrites the entire destination buffer (or rather, whatever the size parameter says) whereas strscpy may not. while this should have no observable effect on a conforming program, it can have undesired (side)effects if the entire destination buffer is sent to a different privilege domain (say, kernel-&gt;userland or userland-&gt;remote system).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/660961/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
