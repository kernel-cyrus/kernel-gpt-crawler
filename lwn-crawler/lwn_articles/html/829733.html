        <!DOCTYPE html>
        <html lang="en">
        <head><title>Software and hardware obsolescence in the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/829733/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/829694/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/829733/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Software and hardware obsolescence in the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 28, 2020</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2020-Linux_Plumbers_Conference">LPC</a>
</div>
Adding code to the kernel to support new hardware is relatively easy.
Removing code that is no longer useful can be harder, mostly because it can
be difficult to know when something is truly no longer needed.  Arnd
Bergmann, who <a href="/Articles/748074/">removed support for eight
architectures</a> from the kernel in 2018, knows well just how hard this
can be.  At the <a href="https://linuxplumbersconf.org/">2020 Linux
Plumbers Conference</a>, he led two sessions dedicated to the topic of
obsolete software and hardware.  With a bit of effort, he said, it should
be possible to have a better idea of when something can be removed.
<p>
<h4>The software side</h4>
<p>
Obsolete hardware, he said, can be defined as devices that are no longer
being made, usually because they have been superseded by newer, cheaper,
and better products.  Obsolete hardware can still be useful, and often
remains in use for a long time, but it's hard to know whether any
specific device is still used.  Obsolete code is a bit different;
the hardware it enables might still be in production, but all of its users
are running older kernels and are never going to upgrade.  In such cases, the
code can be removed, since nobody benefits from its ongoing maintenance.
<p>
Bergmann's proposal is to create a way of documenting which code in the
kernel is there solely for the support of obsolete hardware; in particular, it
would note the kernel configuration symbols associated with that
hardware.  For each symbol, the document would describe why it is still in
use and for how long that situation is expected to continue.  The
consequences of removing this support (effects on other drivers that depend
on it, for example) would be noted, as would the benefits that would come
from removing it.
<p>
There are various groups that would be impacted by this change.  The kernel
retains support for a number of hobbyist platforms, for example; these
include processor architectures with no commercial value but an ongoing

<a href="/Articles/829738/"><img
src="https://static.lwn.net/images/conf/2020/lpc/ArndBergmann-sm.png" alt="[Arnd Bergmann]"
title="Arnd Bergmann" class="rthumb"></a>

hobbyist following.  The kernel still supports a number of Sun&nbsp;3
workstation models; he has no idea whether anybody is actually
running such systems or not.  Kernel developers generally like to keep
hobbyist platforms alive as long as somebody is willing to maintain them.
<p>
Then there are platforms with few users, but those users may really need
them.  These include various types of embedded systems, industrial
controllers, military systems, and more.  There are also systems that are
clearly headed toward obsolescence in the future.  These include 32-bit
architectures which, while still heavily used now, will eventually go
away.  Systems with big-endian byte order have declined 90% in the last ten
years, and may eventually vanish entirely.
<p>
So where should this sort of information be documented?  He proposed a few
options, including a new file in the documentation directory, in the
<tt>Kconfig</tt> files that define the relevant configuration symbols,
somewhere on <a href="https://wiki.kernel.org/">wiki.kernel.org</a>, or
somewhere else entirely.  Responding to a poll in the conference system, just over
half of the attendees indicated a preference for a file in the kernel tree.
<p>
At this point your editor had to jump in and ask how this idea compares to
the kernel's <tt>feature-removal-schedule.txt</tt> file.  This file was <a
href="/Articles/118844/">added in 2005</a> as a way of warning users about
features that would go away soon; this file itself was <a
href="https://git.kernel.org/linus/9c0ece069b32">removed in 2012</a> after
Linus Torvalds got fed up with it.  Why should the fate of this new
file be different?  Bergmann responded that this file would
not be a schedule for removal of support; instead, it would be a way of
documenting that support needs to be kept for at least a certain period of
time.  Users of the affected hardware could easily update the file at any
time to assure the community that they still exist.  As documentation for
the reasons to keep support in the kernel, it would be more useful.
<p>
Florian Weimer asked what the effect would be on user space if this
proposal were adopted; the answer was "none".  User-space interfaces are in
a different category, Bergmann said, with a much higher bar to be overcome
before they can be removed.  This file would cover hardware-specific
code.  Mike Rapoport added that it would be a way to know when users would
be unaffected, once it becomes clear that nobody is running upstream
kernels on the hardware in question.
<p>
Catalin Marinas suggested creating a <tt>CONFIG_OBSOLETE</tt> marker for
code that supports obsolete hardware, but Will Deacon was nervous about
that idea.  He recently did some work on the page-table code for 32-bit
SPARC machines; he got no comments on those changes, but he did get reports
when various continuous-integration systems tested them.  A
<tt>CONFIG_OBSOLETE</tt> marker might be taken as a sign by the maintainers
of such systems
that the code no longer needs to be tested, reducing the test coverage
significantly.
<p>
Bergmann added that 32-bit SPARC is an interesting case.  People have been
finding serious bugs in that code, he said, and System&nbsp;V interprocess
communication isn't working at all.  There is a lot of testing of 32-bit
SPARC user space, but the tests all run on 64-bit kernels, where these
problems do not exist.  He is confident that this code has few — if any —
remaining users.
<p>
Len Brown returned to the question of the old
<tt>feature-removal-schedule.txt</tt> file, asking what had been learned
from that experience.  Bergmann replied that his proposed documentation is
intended to help plan removal.  It is, he said, a lot of work to try to
figure out if a particular feature is being used by anybody; documenting
users in this way would reduce that work considerably.  Laurent Pinchart
added that this information could also be useful for developers who would
like to find users of a given piece of hardware to test a proposed change.
<p>
As the session came to a close, James Bottomley noted that this kind of
problem arises often in the SCSI subsystem, which tends to "keep drivers
forever".  Eventually, though, internal API changes force discussions on
the removal of specific drivers, but that is always a hard thing to do.  It
is easy to say that a removed driver can always be resurrected from the Git
history if it turns out to be needed, but that doesn't work out well in
practice.
<p>
Bergmann ended things by noting that the maintainer of a given driver is
usually the person who knows that nobody is using a given device.  But once
that happens, the maintainer often goes away as well, taking that knowledge with
them.  At that point, it's nobody's job to remove the code in question, and
it can persist for years.
<p>
<h4>System-on-chip obsolescence</h4>
<p>
Bergmann returned to this topic in another session dedicated to the life
cycle of system-on-chip (SoC) products.  Having spent a lot of time working
on various aspects of architecture support in the kernel, he has learned a
few things about how support for SoCs evolves and what that might mean for
the architectures currently supported by the kernel.
<p>
There are, he said, five levels of support for any given SoC in the kernel:
<p>
<ol class="spacylist">
<li> Full upstream support, with all code in mainline, all features
     working, and new kernel features fully supported.
<li> Minimal upstream support, but fixes and updates still make it into the
     stable kernel releases.
<li> Updates in mainline are sporadic at best; perhaps fixes go into the
     long-term-support kernels.
<li> No more upstream support; users are getting any updates directly from
     the vendor.
<li> The system runs, but there are no updates or ongoing support in the
     mainline kernel.  There might still be code in the kernel, but it is
     not used by anybody.
</ol>
<p>
The most important phase for SoC support is the bringup stage, when things are first
made to work; if at all possible, that support should be brought all the
way to the "full support" level.  The level of support normally only goes
down from there.  People stop applying updates and, eventually, those
updates stop appearing at all.
<p>
Problems at bringup tend to happen in fairly predictable areas, with GPU
drivers being at the top of the list.  That said, the situation has gotten
a lot better in recent times, with increasing numbers of GPUs having
upstream support.  Android patches can be another sticking point; that,
too, is improving over time.  Short time to market and short product
lifespan can both be impediments to full support as well.
<p>
Bergmann put up a diagram displaying the "CPU architecture world map" as of
2010; it can be seen on page&nbsp;6 of <a
href="https://linuxplumbersconf.org/event/7/contributions/655/attachments/638/1161/LPC20_SoC_support_in_the_kernel_1.pdf">his
slides [PDF]</a>:
<p>
<blockquote>
<img src="https://static.lwn.net/images/conf/2020/lpc/arnd-cpumap.png" alt="[CPU architecture
world map]" class="photo">
</blockquote>
<p>

This map plots architectures used in settings from
microcontrollers through to data-center applications on one dimension, and
their affinity to big-endian or little-endian operation on the other.
These architectures were spread across the map, with IBM&nbsp;Z occupying
the big-endian, data-center corner, and numerous architectures like
Blackfin and unicore32 in the little-endian, microcontroller corner.
<p>
There were a lot of architectures available at that time, he said, and the
future looked great for many of them.  The Arm architecture was "a tiny
thing" only used on phones, not particularly significant at the time.  But
phones turned out to be the key to success for Arm; as it increased its
performance it was able to eliminate most of the others.
<p>
The SoC part of the market, in particular, is represented by the middle
part of the map: systems larger than microcontrollers, but smaller than
data-center processors.  There are three generations of these that are
important to the kernel.  The first, typified by the Armv5 architecture,
came out around 2000 and is still going strong; these are uniprocessor
systems with memory sizes measured in megabytes.  The Armv7-A generation
launched in 2007 with up to four cores on an SoC and memory sizes up to 2GB;
this generation is completely dominated by Arm processors.
Finally, the Armv8-A (and x86-64) generation, beginning in 2014, supports
memory sizes above 2GB and 64-bit processors.
<p>
He discussed memory technologies for a while, noting that DDR3 memory tends
to be the most cost-effective option for sizes up to 2-4GB, but it is not
competitive above that.  That's significant because middle-generation
processors cannot handle DDR4 memory.
<p>
The only reason to go with first-generation processors, he said, is if
extremely low cost is the driving factor.  For most other applications,
64-bit systems are taking over; they are replacing 32-bit SoCs from a
number of vendors.  The middle, Armv7-A generation is slowly being squeezed
out.
<p>
<h4>Kernel support implications</h4>
<p>
So what are the implications for kernel support?  He started with a plot
showing how many machines are currently supported by the kernel; most of
those, at this point, are described by devicetree files.  There are a few
hundred remaining that require board files (compiled machine descriptions
written as C code).  He suggested that the time may be coming when all
board-file machines could be removed; if those machines were still in use,
he said, somebody would have converted them to devicetree.
<p>
By 2017, it became clear that many architectures were approaching the end
of their lives; that led to the removal of support for eight of them in
2018.  Some remaining architectures are starting to look shaky; there will
probably be no new products for the Itanium, SPARC&nbsp;M8, or Fujitsu
SPARC64 processors, for example.  The industry is coalescing mostly on the
x86 and Arm architectures at this point.
<p>
Those architectures clearly have new products coming out in 2020 and
beyond, so they will be around for a while.  There are some others as
well.  The RISC-V architecture is growing quickly.
The IBM Power10 and Z15
architectures are still being developed.  <a
href="https://www.kalrayinc.com/kalray-unveils-coolidge-at-ces-2020-2/">Kalray
Coolidge</a> and <a href="https://www.tachyum.com/products">Tachyum 
Prodigy</a> are under development without in-kernel support at this point.
There is a 64-bit version of the ARC architecture under development with no
kernel support yet.  There are still MIPS chips coming out from vendors
like Loongson and Ingenic and, perhaps surprisingly, still SoCs based on
the 20-year-old Armv5 core being introduced.
<p>
Big-endian systems are clearly on their way out, he said.  There were a
number of architectures that supported both; most are moving to
little-endian only.  SPARC32 and OpenRISC are holdouts, but their users are
expected to migrate to RISC-V in the relatively near future.  About the
only architecture still going forward with big-endian is IBM&nbsp;Z.
<p>
There are some new SoC architectures in the works.  The most significant one
is RISC-V, with numerous SoCs from various vendors.  Expectations for
RISC-V are high, but there are still no products supported in the kernel.
The ARC architecture has been around for 25&nbsp;years and remains
interesting; it sees a lot of use in microcontrollers.  There is not much
support for 32-bit ARC SoCs in the kernel, and no support yet for the
upcoming 64-bit version.  That support is evidently under development, though.
<p>
Where does all this lead?  Bergmann concluded with a set of predictions for
what the situation will be in 2030.  The market will be split among the
x86-64, Armv8+, and RISC-V architectures, he said; it will be difficult for
any others to find a way to squeeze in.  The upstreaming of support for
these architectures in the kernel will continue to improve.  IBM&nbsp;Z
mainframes will still be profitable. 
<p>
The last Armv7 chips, instead, have been released now, but they will still
be shipping in 2030 (and in use for long after that).  So 32-bit systems
will still need to be supported well beyond 2030.  For those reasons and
more, he is not expecting to see further removals of architecture support
from the kernel for at least the next year.
<p>

At the other end, 128-bit architectures, such as <a
href="https://www.cl.cam.ac.uk/research/security/ctsrd/cheri/cheri-faq.html">CHERI</a>,
will be coming into their own.  That is likely to be a huge challenge to
support in the kernel.  The original kernel only supported 32-bit systems
until the port to the Alpha architecture happened; that port was only
feasible because the kernel was still quite small at the time.  The (now
much larger) kernel
has the assumption that an <tt>unsigned long</tt> is the same size as a
pointer wired deeply into it; breaking that assumption is going to be a
painful and traumatic experience.  Fixing that may be a job for a new
generation of kernel hackers.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Architectures">Architectures</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2020">Linux Plumbers Conference/2020</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/829733/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor829862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2020 22:37 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/829862/">Link</a>] (48 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s interesting, why have BigEndian architectures died out? What makes LE better/easier?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2020 23:11 UTC (Fri)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/829864/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m just thinking &quot;isn&#x27;t it because Intel ate their lunch?&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829871"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 1:21 UTC (Sat)
                               by <b>nevets</b> (subscriber, #11875)
                              [<a href="/Articles/829871/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The biggest issue I&#x27;ve run in with BE systems, is passing in a 64 bit integer pointer and reading it as a 32 bit one. That works fine for LE but crashes on BE.<br>
<p>
But I do miss working on BE systems, as it makes reading raw memory out one byte at a time still makes sense <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829871/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829872"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 1:25 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/829872/">Link</a>] (30 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A technical reason is because width-changing casts of pointer types can be performed without modifying the pointer value. E.g. you can cast uint16_t* to uint8_t* to get the low 8 bits of the value, and you much more often need the low 8 bits than the high 8 bits.<br>
<p>
The market reason is that Intel took over and a lot of code accidentally or deliberately requires little-endian.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829872/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 16:18 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/829913/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Because the name &quot;endianness&quot; comes from a story about its futility, I assumed for a too long time there was no technical difference between little endian and big endian. Indeed there is a technical difference: <a href="https://en.wikipedia.org/wiki/Endianness#Optimization">https://en.wikipedia.org/wiki/Endianness#Optimization</a><br>
<p>
Long story short, little endian is more machine-friendly while big endian is more user-friendly: hexdump output is easier to read (because human numbers are big endian).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829930"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 19:31 UTC (Sat)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/829930/">Link</a>] (28 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Some human languages have big-endian numbers, some have little-endian (I believe) and some like English have a mixture (fourteen but twenty-four, tho four and twenty is an older form). <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829930/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829933"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 19:57 UTC (Sat)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/829933/">Link</a>] (27 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When written in numerals, the human textual systems in common use are big-endian.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829933/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829954"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 5:34 UTC (Sun)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/829954/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In Arabic, for example, written numerals are little-endian. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829954/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 8:16 UTC (Sun)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/829960/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hah! I&#x27;ve just realized what whose crusades really was about. Hm.. Wrong numerical (byte) order is a decent reason to declare a war or two.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829972"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 10:19 UTC (Sun)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/829972/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, yes, I misread the article. My bad; thank you for the correction.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829972/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829986"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 14:49 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/829986/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In Arabic, for example, written numerals are little-endian. </font><br>
<p>
Um, no. Arabic is written right-to-left, but numbers are written left-to-right, ie big-endian. <br>
<p>
Now the numbers may be *read* right-to-left, or a mixture of the two (&quot;125&quot; is read as &quot;one hundred five-and-twenty&quot;), but in written form, they&#x27;re left-to-right.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829986/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830002"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 18:05 UTC (Sun)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/830002/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Really? Arabic writers put down numbers in left-to-right form? So if you are writing some text (in the normal right-to-left order) and you want to put down a numeral, you stop for a moment and work out how much space you need, then write in the number from left to right, starting with the most significant digit?<br>
<p>
I always assumed that Arabic numbers were written and read in the same order as the rest of the text, in other words with the least significant digit coming first (little-endian) but I freely admit I have no knowledge of the Arabic language so it could be more complex than I thought. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830002/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830022"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 19:57 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/830022/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Really? Arabic writers put down numbers in left-to-right form? So if you are writing some text (in the normal right-to-left order) and you want to put down a numeral, you stop for a moment and work out how much space you need, then write in the number from left to right, starting with the most significant digit?</font><br>
<p>
Yep!<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830022/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 6:34 UTC (Mon)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/830038/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yikes! I guess that’s one concrete reason why left-to-right scripts are superior (apart from ink smudging). So in conclusion, numbers are *written* in big-endian direction in all common scripts, and probably read in that direction too, but this may be the opposite direction to the normal one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830146"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 17:11 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830146/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Yikes! </font><br>
<p>
This zig-zag doesn&#x27;t feel like a very hard hand writing challenge, I mean not unless you have to deal with crazy long numbers. For computers and terminals it&#x27;s apparently a bit harder :-)<br>
<p>
<font class="QuotedText">&gt; I guess that’s one concrete reason why left-to-right scripts are superior (apart from ink smudging).</font><br>
<p>
Ink smudging _and_ hiding what you just wrote. Look at how left-handed people tend to bend their wrist, even with a pencil.<br>
<p>
My urban legend is that right-to-left languages were superior for... carving. Ten commandments and all that :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830146/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 20:53 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/830166/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So in conclusion, numbers are *written* in big-endian direction in all common scripts, and probably read in that direction too, but this may be the opposite direction to the normal one.</font><br>
<p>
They&#x27;re read big-endian but written little-endian. Endianness is determined by the position (address) of each digit, not temporal order in which they&#x27;re written. The least-significant digit is located at the lowest address, closest to the beginning of the text. When &quot;serialized&quot; (read aloud or subvocalized) the numbers are converted into big-endian format, with the most significant digit spoken first.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830172"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 21:22 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830172/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The least-significant digit is located at the lowest address, closest to the beginning of the text.</font><br>
<p>
No because the numbers are not part of the text, they&#x27;re a left-to-right insert in a right-to-left text.  There are effectively two &quot;address spaces&quot; embedded in one another (a.k.a. &quot;zig-zag&quot;).<br>
<p>
As explained here, Arabic speakers start with the most significant digit when they read and write just like everyone else and that it is what should define what the &quot;lowest address&quot; is, otherwise non-Arabic speakers are misled into thinking Arabic speakers do something different which is exactly what happened in this thread. Speech readers would be confused too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830172/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830179"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 22:22 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/830179/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; No because the numbers are not part of the text, they&#x27;re a left-to-right insert in a right-to-left text.</font><br>
<p>
<font class="QuotedText">&gt; As explained here, Arabic speakers start with the most significant digit when they read and write just like everyone else and that it is what should define what the &quot;lowest address&quot; is…</font><br>
<p>
It doesn&#x27;t make sense to talk about big-endian or little-endian without a single, consistent frame of reference for the addressing which is independent of the content. In a context where you would write the elements of a list right-to-left, that means starting with the lowest address on the right and monotonically increasing toward the left. Only after having defined this addressing scheme can we venture to answer whether the components of the list are written big-endian or little-endian with respect to that surrounding context.<br>
<p>
The digit you read or write first (temporally, not spatially) has nothing to do with endianness. The order in which you wrote the digits is not part of the written record. Someone coming along later can&#x27;t even tell what order the digits were recorded in; it makes no difference to them whether you wrote the least- or most-significant digit first. All they can see is the order of the digits as they are laid out visually on the page.<br>
<p>
In serial communication the standard is different. There it matters which digit is pronounced first, because the temporal order of the symbols is *all* you can observe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830179/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 1:23 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830198/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The order in which you wrote the digits is not part of the written record. Someone coming along later can&#x27;t even tell what order the digits were recorded in</font><br>
<p>
Of course they can, that&#x27;s called &quot;reading&quot;. I can hardly believe you wrote this...<br>
<p>
Computers are not as smart though, so they may need some additional clues: <a href="https://www.w3.org/International/articles/inline-bidi-markup/uba-basics">https://www.w3.org/International/articles/inline-bidi-mar...</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 15:01 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/830277/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Of course they can, that&#x27;s called &quot;reading&quot;. I can hardly believe you wrote this...</font><br>
<p>
Are you being deliberately obtuse? If I sent you a picture of some digits I wrote left-to-right and some digits I wrote right-to-left, &quot;reading&quot; is not going to be enough to tell them apart. Here, I&#x27;ll demonstrate:<br>
<p>
1234 <br>
1234<br>
<p>
To simulate physical writing I filled both lines with spaces and then overwrote the spaces with digits. One line was filled in left-to-right, and the other line right-to-left. Please tell me, which one was written left-to-right?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830286"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 16:28 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830286/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Are you being deliberately obtuse?</font><br>
<p>
I thought you were.<br>
<p>
Natural languages are all about context, that&#x27;s why computers need Unicode bidi = a bit more help. This has been well discussed and explained in several other places in this thread (thanks to all those who did) but if not obtuse you are definitely not receptive. Never mind.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830286/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830336"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2020 3:51 UTC (Wed)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/830336/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Natural languages are all about context, that&#x27;s why computers need Unicode bidi = a bit more help.</font><br>
<p>
Indeed, natural language is all about context. I get the feeling that we are talking about two completely different things and getting frustrated because the other person&#x27;s answers make no sense in the context of what we each thought the conversation was about. I have been trying to describe how the terms &quot;big-endian&quot; or &quot;little-endian&quot; would apply to the *visual* layout of Arabic numerals *at rest*, for example as symbols written on paper—akin to the individual bytes of an integer field which is part of a larger structure stored in RAM or a file on disk. You seem to be interpreting my statements in the context of data which is *being* written, or read, or typed into a computer—a *serialization* of the data. Or perhaps you are referring to the particular way that the digits would be serialized as Unicode code points in a text file. Naturally my statements would seem like nonsense when taken that way; they were not intended for that context.<br>
<p>
For data at rest there is no &quot;time&quot; component; all that matters is the relationships between the addresses or coordinates where each of the digits is stored. For digits written in a single line on paper this  corresponds to linear physical coordinates; a digit may appear either to the left or the right of another symbol. In terms of the analogy to the storage of an array of multi-byte integers in computer memory, a system in which the most-significant digit of each number in a list of numbers is physically located on the same side as the first element of the list is &quot;big-endian&quot; and a system in which the least-significant digit is physically closest to the first element of the list is &quot;little-endian&quot;. Any given serialization of the data (the process of reading or writing, for example) may employ a different &quot;endianness&quot; independent of the visual layout, and indeed that is the case for Arabic numerals: they are stored or rendered (on paper or other visual medium) as little-endian, but read, written, typed, or spoken aloud with the most significant digit first, in big-endian format.<br>
<p>
Anyway, this debate is almost as pointless as the fictional conflict from which we get the terms &quot;big-endian&quot; and &quot;little-endian&quot;.[1] I only replied in hopes of conveying that we are arguing *past* each other more than we are actually disagreeing about anything of substance.<br>
<p>
[1] <a href="https://www.ling.upenn.edu/courses/Spring_2003/ling538/Lecnotes/ADfn1.htm">https://www.ling.upenn.edu/courses/Spring_2003/ling538/Le...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830336/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor830190"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 23:23 UTC (Mon)
                               by <b>kjpye</b> (subscriber, #81527)
                              [<a href="/Articles/830190/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually, everybody reads numbers in a zig-zag fashion.<br>
<p>
If you are reading a number like 8034175, you start &quot;eight million&quot;, but you can&#x27;t get past the &quot;eight&quot; until you have scanned from the right of the number to the left to determine the magnitude.<br>
<p>
So a non-Arabic speaker will read left to right, encounter the number and skip to the end of the number and scan back to determine the magnitude and then read the number left to right and continue reading towards the right.<br>
<p>
An Arabic speaker will encounter the right-hand end of the number first, scan across it to determine the magnitude and then read the number left to right. Then they will jump back to the left of the number and continue reading towards the left.<br>
<p>
The only real difference is in whether the jump occurs before reading the number (non-Arabic) or after (Arabic).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830190/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor830196"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 0:43 UTC (Tue)
                               by <b>notriddle</b> (subscriber, #130608)
                              [<a href="/Articles/830196/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
August 31, 2020 at 12:00 PM<br>
<p>
Figure out the endianness of THAT notation!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830196/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor829983"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 15:14 UTC (Sun)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/829983/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <p><q>In Arabic, for example, written numerals are little-endian.</q></p>
<p>
Or are they? As is common knowledge, Arabic is written right-to-left, but it is my understanding that numbers are read left-to-right. Digits are shown in the same order as in Western scripts, for example two hundred and thirty-five is "235" or "٢٣٥", depending on whether Western Arabic or Eastern Arabic (Hindi) numerals are used. When this number is read, the reader first looks at the hundreds. Likewise, when numbers are entered on a device, the input system temporarily changes direction to left-to-right, so the digits are entered in the order 2, 3, 5 and the result is displayed as "235".</p>
<p> Reference: <a href="https://www.industryarabic.com/numbers-in-arabic/"> Numbers in Arabic</a>.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/829983/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 17:31 UTC (Sun)
                               by <b>karkhaz</b> (subscriber, #99844)
                              [<a href="/Articles/829994/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Arabic is written right-to-left, but it is my understanding that numbers are read left-to-right</font><br>
<p>
This is precisely what little-endian means, right? Consider the following sequence of four numbers, written in an LTR language like English. You start reading at X and finish reading at Y.<br>
<p>
X  123 555 1234  Y<br>
<p>
In Arabic, this sequence is written as<br>
<p>
Y  ۱۲٣٤ ۵۵۵ ۱۲٣  X<br>
<p>
In English, your eyes continuously move from left-to-right. In Arabic, your eyes zig-zag across the page: from right-to-left to read the sentence, but from left-to-right when reading each of the three numbers. This is analogous to little-endian, where the bytes within a structure are laid out in opposite direction to the addresses of the structures.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 18:41 UTC (Sun)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/830010/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, little-endian means the least significant byte comes first, at the lowest address. The analogy to reading a number is that the most significant digit is read first, thus the number is &quot;big-endian&quot;. (Whether the first digit is to the left or right does not matter, and both Arabic and Western numbers are written with the most significant digit to the left.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor834226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2020 10:50 UTC (Wed)
                               by <b>immibis</b> (subscriber, #105511)
                              [<a href="/Articles/834226/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So an 8-bit x86 processor could be called big-endian if it reads the MSB first?<br>
<p>
I don&#x27;t think so.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/834226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor834307"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 14, 2020 18:31 UTC (Wed)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/834307/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So an 8-bit x86 processor could be called big-endian if it reads the MSB first?</font><br>
<p>
Yes, the serialization of the word on the 8-bit bus would be accurately labeled big-endian if the MSB is transferred first—not that this would be observable to software. The storage would still be little-endian since the LSB is stored at the lowest-numbered address. This can be confirmed by accessing the same memory address with byte- and word-oriented instructions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/834307/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor829999"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 18:51 UTC (Sun)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/829999/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Little endian would presumably mean that people using the system were comfortable getting the ones digit first, then the tens, then the hundreds. After reading a number, the information you got most recently would be the order of magnitude, and the digits would appear in the order you use them while adding numbers or multiplying by the single digit. Furthermore, scanning through a number once forward, you&#x27;d know the place-value of each digit when you encountered it, without needing to check the length of the number first like big-endian readers do.<br>
<p>
I expect that, if you grew up using big-endian numbers and then learn Arabic and see a number in it, you&#x27;ll zig-zag. But if you grew up with Arabic, you&#x27;ll read &quot;1234 555 123&quot; as &quot;three, twenty, one hundred; five, fifty, five hundred; four, thirty, two hundred, one thousand&quot;, going right-to-left through the number.<br>
<p>
I suspect that big-endian practice comes from a culture that used Roman numerals, which start with the highest-value information and don&#x27;t require knowing how many more digits are coming to assign a value to the first digit, getting Arabic texts on arithmetic and keeping the computation the same while translating the explanation, and the Arabic texts had the ones digit on the right because that&#x27;s the first digit you produce in addition, multiplication, or subtraction, and they put the first digit of a number where they put the first letter of a word.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829999/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830017"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 19:26 UTC (Sun)
                               by <b>karkhaz</b> (subscriber, #99844)
                              [<a href="/Articles/830017/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But if you grew up with Arabic, you&#x27;ll read &quot;1234 555 123&quot; as &quot;three, twenty, one hundred; five, fifty, five hundred; four, thirty, two hundred, one thousand&quot;, going right-to-left through the number.</font><br>
<p>
No, this really isn&#x27;t the case. Native Arabic readers don&#x27;t start reading the lowest-magnitude digit first, they skip to the largest digit and read left-to-right. Both when reading, and when uttering the number (with the exception that units are uttered before tens).<br>
<p>
As another example, consider the date range 1979-2020. In Arabic this is written ١٩٧٩-٢٠٢٠ and pronounced &quot;one thousand and nine hundred and nine and seventy to two thousand and twenty&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830017/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830023"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 21:23 UTC (Sun)
                               by <b>karkhaz</b> (subscriber, #99844)
                              [<a href="/Articles/830023/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My explanations may render incorrectly if you read them in a terminal emulator, since most of them [1] don&#x27;t support Unicode&#x27;s algorithm for laying out mixed LTR-RTL text [2]. I though that I had made a fool of my self on the Internet when I read my comment notification in mutt, but it turned out that I hadn&#x27;t. (Or at least not this time.)<br>
<p>
[1] <a href="https://lwn.net/Articles/749992/">https://lwn.net/Articles/749992/</a><br>
[2] <a href="https://en.wikipedia.org/wiki/Bidirectional_text#Unicode_bidi_support">https://en.wikipedia.org/wiki/Bidirectional_text#Unicode_...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830023/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830026"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 22:47 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830026/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; No, this really isn&#x27;t the case. Native Arabic readers don&#x27;t start reading the lowest-magnitude digit first, they skip to the largest digit and read left-to-right. Both when reading, and when uttering the number (with the exception that units are uttered before tens).</font><br>
<p>
Very useful thanks, I suspected such a &quot;full zig-zag&quot; but wasn&#x27;t sure.<br>
<p>
I admit I didn&#x27;t consider right-to-left languages at the time I wrote &quot;human numbers are big endian&quot; above. Thank you right-to-left languages for this making this zig-zag exception and keeping my statement correct, much appreciated :-)<br>
<p>
More seriously, it&#x27;s easy to imagine the rationale for this zig-zag:<br>
- Numbering &quot;compatibility&quot; with other languages of course, and<br>
- All humans of all languages seem interested by the Most Significant digits first; e.g.  &quot;rounding&quot;.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830026/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 20:46 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/830165/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Native Arabic readers don&#x27;t start reading the lowest-magnitude digit first, they skip to the largest digit and read left-to-right. Both when reading, and when uttering the number….</font><br>
<p>
So numbers are written in little-endian notation (given right-to-left addressing for &quot;unstructured&quot; data, i.e. plain text), and converted to big-endian when &quot;serialized&quot; (spoken aloud) without rearranging the rest of the text. That sounds exactly like a traditional little-endian network stack to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor829889"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 11:05 UTC (Sat)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/829889/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      I don't think that technical reasons are compelling enough to have caused this outcome (otherwise we would not have taken &gt;50 years to get here).  It seems to be more an issue of network effects (as can be seen by the switch of Power to little-endian).  Interestingly, in the heyday of RISC big-endian seemed to be winning (SPARC, PA-RISC, IBM RT (and later Power) and most MIPS were big-endian, only ARM, MIPS-based DecStations (and later Alpha) were little-endian); of these architectures only the little-endian ARM is really successful nowadays; MIPS and Power still exist, but Power now is mainly in the little-endian camp, and MIPS was bi-endian from the start (and looking at popcon.debian.org, little-endian seems to be more popular for MIPS these days).

<p>Concerning technical reasons, I lean towards little-endian for the following technical reasons: bit numbering and byte numbering should follow the same direction, otherwise larger bit arrays become cumbersome to program (IIRC the 68000 bit field instructions got this wrong by combining little-endian bit ordering with big-endian byte ordering).  For bit numbering (also for byte numbering, but there it does not play such a big role), big endian means that different word sizes have different numbers for the least significant bit; i.e., the number 1 has bit 63 set in a 64-bit word and bit 31 set in a 32-bit word. I find this unpleasant, but then, I grew up with the little-endian 6502, so it may just be that I am not used to it.

      
          <div class="CommentReplyButton">
            <form action="/Articles/829889/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829907"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 15:15 UTC (Sat)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/829907/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that pretty much nails it. I had some more details about MIPS on my slides, in their case most machines were hardwired one way even if the CPUs themselves could do both, unlike PowerPC and ARM that can switch at runtime on modern cores. The big-endian MIPS systems were mostly the UNIX workstations and servers that are all obsolete now, while the embedded systems were already leaning to little-endian and that effect has increased over time. Debian 11 has now dropped support for big-endian MIPS.<br>
<p>
Regarding the bit numbering, calling the MSB &#x27;bit 0&#x27; seems to be an IBM thing, all other big-endian CPUs I&#x27;ve seen still call the LSB &#x27;bit 0&#x27;, but they instead have inconsistent numbering when looking at bits vs. bytes, so the first byte of a 64-bit number contains bits 63 through 56.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829907/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 16:23 UTC (Sat)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/829910/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, Motorola calls the LSB bit 0 on both the 68000 and the 88000 architectures (88000 was also among the big-endian RISC bunch in practice (selectable in theory)). Both of these architectures have bit-field instructions, which makes bit numbering relevant; on architectures where you have to synthesize bit field operations from shifts, it does not matter for that purpose how the manufacturer numbers the bits.

<p>But if you want to extract, say, bits 30-33 of a 64-bit value on a (32-bit) 68020, this mixing of little-endian bit order and big-endian byte order gets in the way, and you know why IBM number the bits as they do.

<p>So apparently everyone (but IBM) prefers little-endian bit order, and in a some cases (like the example above) this means that little-endian byte order is also preferable.
      
          <div class="CommentReplyButton">
            <form action="/Articles/829910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 22:23 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/830181/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There&#x27;s a register in PA-RISC that reports the &quot;bit number&quot; of something. On 32-bit system, we respond by clearing 1 &lt;&lt; (31-x). On 64-bit systems, we clear 1 &lt;&lt; (63-x).<br>
<p>
The disease metastatized outside of IBM.<br>
<p>
I&#x27;m surprised nobody&#x27;s yet mentioned the mixed endian ARM FPU system (maybe it&#x27;s too old) where the bytes in each 32-bit word were stored little endian (as befitted the LE architecture that ARM was at the time), but the words were stored in the wrong order. ie 45670123<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2020 19:27 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/831302/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That looks like the opposite of PDP-endian.<br>
<p>
(Still looking back in history, the VAX had even crazier endiannesses, particularly for its weirdo floating-point formats.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor829929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 20:06 UTC (Sat)
                               by <b>ppisa</b> (subscriber, #67307)
                              [<a href="/Articles/829929/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I see one other possible reason for the shift to little-endian today.<br>
<p>
When computation goes only within CPU and memory then there is minimal difference when one or another endianing is used except for arbitrary arithmetic precision where start from LSB bit, word help to propagate carry. But it is niche case and there is no problem to have little-endian sequence of big-endian worlds which is no problem in this case. Build cores with configurable endianness is no problem regarding the memory. The data are stored on both systems in same way in the worlds in memory and only for accesses shorter than world size the bytes multiplexer/router uses different rule based on size and LSB address bits. Again minimal hardware and no software overhead.<br>
<p>
But the things change rapidly when the system needs to interact with external world. There endianness matter and there is case of nightmare when you have byte grained data buffers combined with machine word sized control registers. You want to access data buffers directly and read serialized data but you want to use fast single cycle access to registers. The same for serialized data from external world.<br>
<p>
The Internet Protocol has been probably developed on big-endian system the first so network order is defined as big-endian (I do not count Corba which is endianness neutral or modern later defined protocols or automotive CAN, but all IP, TCP, UDP, RPC, NFS... are big-endian). Big-endian addresses serialization has advantage that router can start to decide about destination queue even when only initial part of address field is received (probably no win for IPv4 today but for IPv6 there can be some advantage). So big-endian server systems have advantage for long time.<br>
<p>
But then PC has started to dominate cheap computing and started to grow even into small servers area and Intel has been successful in forming consortium which defined PCI standard under its lead in 1992. Because PCI was and is successful and defined model to design and manage mid range peripheral devices for almost 30 years already. The PCI (today PCIe) network, disk, video controller chips has been COTS products and to reduce cost they and PCI started to be used even in higher class systems in the places where their throughput has been enough. Specialized Inifiband etc... interconnect is still used for big systems for main data exchanges flow, but management peripherals are often COTS PCIs, even big systems offer PCIe slots etc...<br>
<p>
And there comes significant problem for big endian systems. They can map PCI devices in native world order, it would work well with access to control registers etc... but data stored to main memory through bus &quot;master&quot; (what is today and tomorrow sugester term there) accesses and when data are taken as serialized to byte stream or UTF-8 text etc, then swapping endianness in kernel, during buffer copy or even worse for zero copy mapped pages in target applications would be nightmare. I think I have seen in the past that some systems mapped PCI devices swapped in a early days, but today they map them in a little-endian manner which means that ioread and iowrite and related kernel functions to access peripherals registers are by default little endian and most of the drivers use these functions directly. <a href="https://lkml.org/lkml/2005/4/4/230">https://lkml.org/lkml/2005/4/4/230</a><br>
<p>
So the big-endian systems has to provide memory access instructions or mechanism to use little-endian order for peripherals to mitigate impact or have to provide fast instructins to swap endianness to limit impact to reasonable level. Because even much of the software is developed and tested by developers on their little-endian PCs then porting of projects to big-endian is only additional costs, makes problems with management peripherals and PCIe is used even for main data paths today where it provides enough bandwidth....<br>
<p>
So even that there is minimal theoretical difference and correlation between used endianness and performance for given algorithm, there are practical reasons to switch to little-endian even that network order processing of headers and protocols has some small cost (CPUs has optimized instructions for that).<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829965"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 9:06 UTC (Sun)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/829965/">Link</a>] 
      </p>
      
      </div>
      </summary>
      You work out the network effects nicely.  And I guess that PCI (and followons) have a stronger network effect than network protocols, because network latencies are so large and bandwidth on most machines so low that you can afford byte reversal easier than when accessing PCI/PCIe peripherals.

<p>XDR (used by RPC) and NFS were developed at Sun, which was big-endian (68000 and SPARC).  Concerning TCP, IP, and UDP, I don't know what hardware was used for developing that, and if it even was byte-addressed (while also supporting longer words in hardware; if not, byte order is not an issue as far as the hardware is concerned).

      
          <div class="CommentReplyButton">
            <form action="/Articles/829965/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829966"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 9:07 UTC (Sun)
                               by <b>kreijack</b> (guest, #43513)
                              [<a href="/Articles/829966/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I can add another case: filesystem. In the filesystem there are metadata which are read from the host. And it is a reasonable expectation that moving an (eg. USB) from an host to another one doesn&#x27;t result in a problem. So the endianess of the filesystem matedata have to be the same regardless the endianess of the host.<br>
<p>
This means that an architecture there is no a conversion, and that in the other one there will be some form of conversion.<br>
<p>
E.g. BTRFS use the little endian format. To access the filesystem metadata BTRFS uses a set of macros that in little endian architecture do nothing, in the big endian architecture do a translation le-&gt;be.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829966/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829993"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 16:11 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/829993/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I work with the Pick database. I believe that a Pick &quot;tape&quot; is defined as little-endian, I&#x27;m not sure.<br>
<p>
But when the particular variant I work with was ported from little-endian architectures to big-endian, the promise you could just copy a FILE (the equivalent of a SQL table) and read it was broken.<br>
<p>
So they supplied a little utility so that, when copying between different endian machines, this utility would swap the byte metadata over. Bit like the cr2lf utility.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829993/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831304"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2020 19:40 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/831304/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I did something similar when adding mixed-endianness support to binutils libctf (excluding the ctf_archive format, which predated this idea and is always little-endian: I&#x27;ll fix that in the next format rev). Cross-compilation notwithstanding, executables in general are usually read on architectures of the same endianness as the native endianness of the architecture they are generated on, so we write CTF dicts in the native endianness (historically, Solaris CTF did the same, presumably for the same reason). The only endianness-sensitivity is at open time, where we look at the dict&#x27;s magic number to determine this dict&#x27;s endianness, and endian-swap the whole dict in memory if the wrong endianness is detected.<br>
<p>
This approach has two significant advantages over endian-flipping to a format-specified hardwired endianness: firstly, you never incur endian-flipping overhead in the common case of the same endianness being used on the generator and reader, no matter what the endianness of your machine; secondly, almost the entire codebase can completely ignore all this awful stuff, and only one localized place (the place that endian-flips if a foreign endianness is detected) needs to know about it.<br>
<p>
The downside is that I need to explicitly test creating CTF on a machine with one endianness and then using it on one with the opposite endianness, or the endian-flipping code will never be exercised and will eventually silently rot. But still it seems to be much less bug-prone than forcing the format to be one specific endianness and compensating for that everywhere.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831304/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor830529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2020 15:49 UTC (Thu)
                               by <b>mchouque</b> (subscriber, #62087)
                              [<a href="/Articles/830529/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
ext2 used to be like that IIRC...<br>
<p>
You couldn&#x27;t mount a filesystem coming from a BE on a LE machine and vice-versa.<br>
<p>
e2fsck used to have an option for that:<br>
       -s     This option will byte-swap the filesystem so that  it  is  using<br>
              the  normalized,  standard  byte-order  (which is i386 or little<br>
              endian).  If the filesystem is already  in  the  standard  byte-<br>
              order, e2fsck will take no action.<br>
<p>
       -S     This  option  will  byte-swap  the filesystem, regardless of its<br>
              current byte-order.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830539"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2020 17:44 UTC (Thu)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/830539/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed, originally the big-endian Linux ports used the unmodified ext2 file system, leading to incompatible metadata layout with little-endian machines.<br>
<p>
When people realized the incompatibility, two options were considered:<br>
  1. Add non-natitve endian support to ext2, i.e. do byteswapping when needed, protected by a config option,<br>
  2. Declare ext2 to be little-endian, and provide an option to migrate the big-endian format to little-endian.<br>
Option 2 was picked, as 1 (when enabled) incurred a high runtime cost due to the conditional byteswapping code, and 2 turned out not that much slower than 1 (when disabled), due to the compiler doing a quite good job in optimizing the code.<br>
After a while, all big-endian ext2 file systems had been migrated, and e2fsck no longer needed the -s option.<br>
Similarly, XFS was declared to be big-endian, as it originated on big-endian SGI machines.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830539/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor831251"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2020 10:05 UTC (Fri)
                               by <b>rep_movsd</b> (guest, #100040)
                              [<a href="/Articles/831251/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Little endian just makes more sense - simpler.<br>
<p>
I never understood why someone would use an un-intuitive big endian format ( which is clearly based on the fact that we write numbers left to right manually )<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831251/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2020 17:18 UTC (Fri)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/831291/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Debugging based on hex dumps is much nicer on big-endian archs than little-endian ones.<br>
<p>
Of course, most people don&#x27;t have to do that very often these days.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831296"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2020 18:12 UTC (Fri)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/831296/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;ve been working on a big endian system recently and I&#x27;m finding it surprisingly hard to parse register dumps having got so used to little endian.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831296/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor829863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2020 22:38 UTC (Fri)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/829863/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  The (now much larger) kernel has the assumption that an unsigned long is the same size as a pointer wired deeply into it; breaking that assumption is going to be a painful and traumatic experience.</font><br>
<p>
Why break that assumption? We could require that 128-bit architectures have 128-bit unsigned long. (At least within the kernel, if not in userspace. But if we&#x27;re talking about a new architecture and new userspace, why *not* require that?)<br>
<p>
Yes, there are types like uintptr_t and ptrdiff_t. But why not take the path of least resistance here?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2020 23:44 UTC (Fri)
                               by <b>acarno</b> (subscriber, #123476)
                              [<a href="/Articles/829865/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Definitely not an expert here, but I&#x27;d assume because it&#x27;s wasted silicon. From a practical standpoint, there&#x27;s a lot of use for 128-bit data (e.g., see all of the fun AVX instructions), but the need for 128-bit address buses isn&#x27;t something anyone needs anytime soon (we aren&#x27;t even close to saturating 64-bit address buses). So rather than waste the silicon, you&#x27;ll assume 64-bit addresses and 128-bit integers.<br>
<p>
Now could you do some fun compiler trickery where you assume 128-bit pointers in the code but then chop them up into 64-bit memory addresses (and vice-versa)? That may be a hacky-but-workable path forward.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829868"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 0:12 UTC (Sat)
                               by <b>sbaugh</b> (guest, #103291)
                              [<a href="/Articles/829868/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
CHERI pointers are 128-bit, though. (It&#x27;s a capability-based architecture; pointers are unforgeable references to memory which include a bunch of authentication and capability bits)<br>
<p>
So it sounds like you&#x27;re in agreement with the parent - if, as you say, 128-bit data is needed, then since we already need 128-bit pointers, we might as well make unsigned long 128 bits.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829868/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829877"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 3:15 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/829877/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Don&#x27;t confuse address width with number of bits needed for the amount of memory in the machine.<br>
<p>
Intel have already moved from 4 to 5 level page tables (48 to 57 bits of virtual address space) for data centre CPUs. That&#x27;ll last about another ten years.<br>
<p>
I think the first thing we&#x27;ll need is 128 bit files (-D_FILE_OFFSET_BITS=128). Then we&#x27;ll need larger block devices. Then we&#x27;ll need larger virtual address spaces for each process.<br>
<p>
It&#x27;ll be a long time before we need 16EiB of memory in a machine, but that amount of address space will be troublesome fairly soon.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829877/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829996"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 17:47 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/829996/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>In a somewhat sane world you would be correct. But in practice nobody think much about making work for software engineers. Five-level tables <a href="https://lwn.net/Articles/716916/">were introduced to address <b>physical</b> memory, not for anything else</a>.</p>

<p>Other points are valid, though.</p>

<p>We may need more than 16EiB of memory in a machine and when that would happen we would either need PAE or extend pointers again.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/829996/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 18:11 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/829997/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I work quite closely with Kirill. I know 5 level page tables were introduced to expand the amount of physical memory. But there was no reason to expand the size of a pointer at that time. 57 bits is still significantly smaller than 64 bits. Six level page tables probably don&#x27;t make sense; if x86 needs to go beyond 57 bits of physical, there&#x27;ll probably be a new page table format (with 8kB tables at each level, we could have 62 bits of physical memory with 5 level page tables, for example).<br>
<p>
I hope we don&#x27;t get to a PAE situation, but that&#x27;s a long way off. 128 bit off_t is the next problem to address.<br>
<p>
BTW, I realised I&#x27;ve been saying 16EiB for off_t, but I forgot that off_t is signed, so actually 8EiB is the current limit.<br>
<p>
A 128-bit off_t will let us go to 76 bit file sizes with the page cache (and a 4KiB page size), which should last us until around 2045. I hope we have three credible 128-bit CPUs by then.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor829880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 5:57 UTC (Sat)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/829880/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree, even 64 bits is wasting silicon today. Exponential growth in address space, only means linear growth in the number of address bits; the number of address bit does not have to double in constant time. After going from 16 to 32 bits, the next step is 32+16 bits, and 48 bits is actually roughly where we are today. The current x86-64 CPUs only support 48 bits of effective address bits, with the exception of some really high end machines.<br>
<p>
Before 128 bits are needed, we have to go through steps 64, 80, 96, 112, each with a duration of a few decades, if Moore&#x27;s law holds.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829908"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 15:02 UTC (Sat)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/829908/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
2^128 isn&#x27;t that much bigger than the number of molecules making up the earth.  There is no way that a 128-bit address bus will be needed, ever.  We&#x27;re not even in Star Trek territory.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829908/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 18:45 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/829924/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you both. The 8 -&gt; 16 -&gt; 32 -&gt; 64 -&gt; 128 expectation reminds me of this other SD -&gt; HD -&gt; 4k -&gt; 8k -&gt; 16k  silly expectation: ignoring basic maths and science. Biology in the latter case.<br>
<p>
<a href="https://www.pcworld.com/article/3546295/why-you-cant-get-a-1440p-laptop-blame-4k-tvs.html">https://www.pcworld.com/article/3546295/why-you-cant-get-...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830043"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 7:45 UTC (Mon)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/830043/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While the actual physical bus may well not need to be &gt;64 bits wide any time soon, CHERI uses some of these bits for pointer authentication etc.. So yes we do need pointers that are that wide.<br>
<p>
128 bit kernel integers, on the other hand, make no sense whatsoever IMHO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830043/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor829945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 23:51 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/829945/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There&#x27;s a whole world of computing that&#x27;s larger than your laptop.<br>
<p>
Consider a giant cluster (eg weather forecasting). No individual machine has more than 16TiB of memory, but we want to have a unique address for each byte across the entire cluster. With 4096 nodes in the cluster, we&#x27;re at 56 bits today.<br>
<p>
We&#x27;re only 6 bits away from being out of bits. That&#x27;s pretty scary.<br>
<p>
Yes, there&#x27;s never going to be a need for a CPU with address registers bigger than 128 bits. I don&#x27;t see busses being designed for addressing more than 80 bits for a good long time. But as soon as you need more than 64 bits of address, you double the register size. So we&#x27;re going to need 128 bit CPUs sooner rather than later. Hopefully nobody makes an IA-64 sized cockup of the transition this time and we get a decent instruction set out of it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829951"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 4:15 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/829951/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; No individual machine has more than 16TiB of memory, but we want to have a unique address for each byte across the entire cluster.</font><br>
<p>
I&#x27;m not sure it&#x27;s wise to waste silicon and bandwidth with local address lines to address remote memory. RDMA is not the only option.<br>
<p>
<font class="QuotedText">&gt; So we&#x27;re going to need 128 bit CPUs sooner rather than later. </font><br>
<p>
The era of silicon custom for HPC is long gone.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829951/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829984"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 14:54 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/829984/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There&#x27;s really no such thing as address lines any more.  Everything uses packets of data on high speed serial lines. Intel&#x27;s QPI supports 46 bits of physical address space. I assume UPI supports more. PCIe supports 64 bits.<br>
<p>
But I&#x27;m not talking about supporting lots of physical address bits. I&#x27;m talking about supporting:<br>
<p>
1. Files larger than 16 EiB<br>
2. Storage devices larger than 16 EiB<br>
3. Virtual address spaces larger than 16 EiB<br>
<p>
We can hack around the missing 128 bit data types for a while. We did it on 32 bit systems for a decade before 64 bit systems were so prevalent that we stopped caring about inefficient 32 bit systems.<br>
<p>
The era of custom silicon for HPC is very much still with us. Fujitsu&#x27;s A64FX and Sunway&#x27;s SW26010 are in 2 of the top 5 supercomputers. And HPC is far from the only user of large virtual addresses.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829984/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 15:23 UTC (Sun)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/829989/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, speaking as someone who works in HPC storage, file systems are pushing towards an exabyte in total size *now* (hundreds of petabytes), which means 16 exabytes is only a few years away, and single files in that range are on the decadal horizon for sure.<br>
<p>
Also, the era of custom silicon for HPC is ... complex.  It’s *mostly* over - the machines with it tend to be exceptions.  Fujitsu is the last major vendor doing their own CPUs for HPC, and the Chinese machine noted can’t buy top class CPUs (plus they want to do their own to close that gap).<br>
<p>
IBM, the former Cray and SGI (now both HPE), Bull in Europe...  none of them have done a full up HPC CPU in quite a while.  Cray is pushing towards 20 years, SGI I think is even further out from their last MIPS.  IBM comes the closest, but their Cell and big Power chips have always been intended to have significant other markets.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830027"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 23:09 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830027/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There&#x27;s really no such thing as address lines any more. Everything uses packets of data on high speed serial lines.</font><br>
<p>
That doesn&#x27;t really change the problem: you&#x27;re still forcing all local memory addresses to pay the additional price of a significant number of extra, constant zeroes only for the programming convenience of an addressing scheme unified with non-local memories that have totally different performance characteristics.<br>
<p>
Hardware engineers &quot;wasting&quot; bandwidth and other resources in their design for software convenience? That doesn&#x27;t sound very likely.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830027/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor829957"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 7:19 UTC (Sun)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/829957/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why do you have to double the register size? An 80-bit size for addresses might be aesthetically distasteful, and would have knock-on effects on alignment and cache design, but might save a lot of silicon and electricity compared to bloating everything to 128 bits.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829957/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 14:58 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/829987/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Imagine you have an array of pointers.<br>
<p>
struct page *pages[15];<br>
<p>
Do you really want to have each of these pointers be 10 bytes long? It doesn&#x27;t even make sense for the pointers to be 12 bytes long. 16 bytes does make sense. And then you can use the top few bits for exciting things like ARM&#x27;s pointer tagging.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830003"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 18:10 UTC (Sun)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/830003/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes that’s exactly what I am saying, make the pointers 10 bytes long. Using 16 bytes would increase your hardware and electricity costs by 60% for little benefit. (Assuming a large system with lots of RAM)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830003/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830005"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 18:12 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/830005/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There&#x27;s a reason we didn&#x27;t go to 48 bit pointers from 32 bit. I don&#x27;t think you&#x27;ve thought through the consequences of 10 byte pointers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830005/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 23:26 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830028/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I don&#x27;t think you&#x27;ve thought through the consequences of 10 byte pointers.</font><br>
<p>
Please share your thoughts (or references) if you have.<br>
<p>
<p>
(as already mentioned by jem above:<br>
<a href="https://stackoverflow.com/questions/6716946/why-do-x86-64-systems-have-only-a-48-bit-virtual-address-space">https://stackoverflow.com/questions/6716946/why-do-x86-64...</a> )<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor829886"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 9:11 UTC (Sat)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/829886/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On a capability architecture like CHERI your pointers may be 128 bits, but they&#x27;re 64-bit-addr-and-capability, and the CPU&#x27;s natural integer register size is still 64 bits. A 128-bit &#x27;unsigned long&#x27; would mean all normal operations on it like addition would need two instructions, just as they would for 128-bit types on x86-64. That&#x27;s a heavy perf burden to pay if your codebase mostly uses &#x27;unsigned long&#x27; as &quot;I just wanted an integer really&quot; and didn&#x27;t need to put a pointer in it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829886/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829890"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 10:29 UTC (Sat)
                               by <b>smcv</b> (subscriber, #53363)
                              [<a href="/Articles/829890/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>ISO C says char is at least 8 bits, short and int are at least 16, long is at least 32, and (I think) long long is at least 64. On ILP32 (e.g. 32-bit Linux/Windows), LP64 (64-bit Linux) and LLP64 (64-bit Windows) platforms, you can implement int8_t, int16_t, int32_t and int64_t as typedefs for the standard types:</p>

<pre><code>
   ILP32 LP64  LLP64
 8 char  char  char
16 short short short
32 i./l.  int  i./l.
64 l.l.  long  l.l.
</code></pre>

<p>If you make long more than 64 bits, then you don't have enough types to implement all of int8_t, int16_t, int32_t and int64_t as typedefs to the standard types: you have {char, short, int}, you want {8, 16, 32, 64}, and there are not enough types to go round. One of them would have to be a typedef for some architecture-specific type, __int64 or something, which is almost certainly going to break expectations in the kernel and/or user-space:</p>

<pre><code>
   ILP32 LP64  LLP64 new thing
 8 char  char  char  char
16 short short short short
32 i./l.  int  i./l. int?
64 l.l.  long  l.l.  __int64?
128                  long
</code></pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/829890/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829959"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 8:04 UTC (Sun)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/829959/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there any reason you couldn&#x27;t just have 8-bit char, 16-bit short, 32-bit int, 64-bit long, and 128-bit long long? All the current models have at least one redundant integer type: 16-bit short and int in LP32, 32-bit int and long in ILP32 and LLP64, and 64-bit long and long long in LP64. There is room for one more unique integer width without introducing any extended types.<br>
<p>
Also, strictly speaking the C standard doesn&#x27;t require a conforming implementation to provide all (or any) of the fixed-width integer typedefs. Leaving them out would break a lot of existing software, of course. Portable programs should be using the flexible [u]int_leastN_t or [u]int_fastN_t aliases instead, which don&#x27;t require a specific width—just something greater than or equal to the requested size.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829959/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829975"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 11:57 UTC (Sun)
                               by <b>smcv</b> (subscriber, #53363)
                              [<a href="/Articles/829975/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Is there any reason you couldn&#x27;t just have 8-bit char, 16-bit short, 32-bit int, 64-bit long, and 128-bit long long?</font><br>
<p>
That&#x27;s what I&#x27;d do if I was designing a 128-bit ABI, but then I&#x27;d be breaking the common assumption (particularly in the Linux kernel) that long and pointer are the same size (i.e. long and intptr_t are the same).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829975/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829998"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 17:56 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/829998/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Portable programs should be using the flexible [u]int_leastN_t or [u]int_fastN_t aliases instead, which don&#x27;t require a specific width—just something greater than or equal to the requested size.</font><br>
<p>
Can you list such programs somewhere? I think one screen of 25 lines would succeed if you remove one which not only use these &quot;least&quot; and &quot;fast&quot; types but would actually work if there are no precise int8_t and int32_t types.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829998/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830006"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 18:29 UTC (Sun)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/830006/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I said, it would break a lot of existing software. The assumption that there are types which are exactly 8-, 16-, 32-, and 64-bits wide runs deep; there aren&#x27;t many architectures in common use which don&#x27;t have all those sizes available. Still, the standard guarantees that int_leastN_t will exist if there is a suitable type which can hold any N-bit integer (and perhaps more), whereas intN_t only exists if there is a type with exactly N bits.<br>
<p>
In most cases switching from intN_t to int_leastN_t or int_fastN_t is a simple matter of search-and-replace. The exceptions are where programs rely on wrapping at a certain width (applicable only to unsigned values) or map C integer types directly onto external cross-architecture data structures. In the first case you just make the wrapping explicit ((x + y) &amp; 0xffffffff). In the second case it might be necessary to actually parse the data structure from bytes rather than map it directly, but then again you probably needed something similar to deal with endianness and alignment variations anyway.<br>
<p>
I suspect the main reason why more programs don&#x27;t use the more portable types is simply that the exact-width forms are shorter and easier to type. Perhaps it would have been better to standardize on something like int_exactN_t instead to put them on more even footing rather than implicitly encourage less portable code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830006/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830052"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 9:42 UTC (Mon)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/830052/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
QEMU used to use the _fast_ integer types in some places (notably the floating point emulation code). We switched to using the exact-width types, because in practice almost all of our supported host systems used the same choice of underlying size for the fast-types, and we didn&#x27;t want to find ourselves running into &quot;code works fine on almost all systems including the ones it was developed and tested on and that 99% of the dev community use, but breaks on the less-common platform that defines the size of one of these types differently&quot; bugs -- we preferred &quot;same behaviour on all platforms&quot;. (IIRC one of the BSDs made slightly different choices, maybe for the 16-bit fast type.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830052/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor829894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 11:13 UTC (Sat)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/829894/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      One clarification, as I think my explanation from the talk wasn't good enough:
<blockquote>
"The last Armv7 chips, instead, have been released now, but they will still be shipping in 2030 (and in use for long after that). So 32-bit systems will still need to be supported well beyond 2030"
</blockquote>
What I actually meant to say here is that

<ul>
<li> The current low-end pre-Armv7-A generation (Armv5/MIPS32r2/Cortex-M/PPC32/..., &lt; DDR2, &gt;=65nm) are at the end of the line for new chip designs but may be put into new devices running Linux for at most another 10 years and get used for even longer (hopefully not after y2038), but eventually these will all run microcontroller OSs.

<li> The current mid-range generation (Armv7-A, DDR3, ~28nm) will take the place at the bottom in new chip designs for maybe another 10 years, followed by more time of these chips getting put into machines running Linux.<br>It is possible that RV32 begins to take over from Armv7-A during that time, but I don't see the others (ARC, Xburst2,  Xtensa, ...) take a significant chunk of the 32-bit Linux market.

</ul>
      
          <div class="CommentReplyButton">
            <form action="/Articles/829894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 9:18 UTC (Mon)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/830050/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Probably far beyond y2038...<br>
<p>
A few years ago, someone who worked for the Australian navy told me that, given how low they kept running m68k MVME boxes, he expected the &quot;new&quot; PPC MVME boxes to keep running beyond y2038.  So yes, &quot;modern&quot; 32-bit ARM should easily surpass that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830051"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 11:46 UTC (Mon)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/830051/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Any guess how long they plan to update kernels though?<br>
<p>
If they are already on older software releases, updating to modern kernel and glibc is already going to be tricky, and getting worse as time passes. I hope we can still update a lot of the Armv7 systems that are already deployed<br>
<p>
Incidentally it seems that the last CPU used on MVME cards (64-bit QorIQ P5020) is at the end of its 10 year expected life, but support for that generation never made it upstream. The 2019 manual for the previous generation (32-bit MVME7100/MPC8641D) lists Linux-2.6.25 as the default, with Linux-2.4 still an option for older machines &quot;beyond 2020&quot;.<br>
<a href="https://github.com/voltumna-linux/meta-artesyn/blob/master/recipes-kernel/linux">https://github.com/voltumna-linux/meta-artesyn/blob/maste...</a> on the other hand does have updates for modern kernels.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830051/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 12:09 UTC (Mon)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/830058/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No idea. I hope until a version that includes proper y2038 support ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor829900"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 11:59 UTC (Sat)
                               by <b>BirAdam</b> (guest, #132170)
                              [<a href="/Articles/829900/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is actually my biggest complaint against Linux as an operating system. Software from 10 years ago often can no longer be used, and hardware that should still be useful will no longer be so. macOS does this just to force upgrades. Windows will obsolete your hardware, but they will support your software for 10 to 20 years, and sometimes longer. I love Linux, and I use it on my desktop workstation at home and work, but I feel it’s contributing to eWaste in an irresponsible manner. Similarly, I feel that Linux often changes just for change’s sake. Oh well. I know that I am the minority in my opinions, so there isn’t much I can do about anything. The majority will always prevail.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829900/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 12:14 UTC (Sat)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/829901/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m pretty sure most of Linux&#x27;s software obsolescence issues are userland&#x27;s fault, not the kernel&#x27;s. Linus is very, very spiky about &quot;don&#x27;t break userspace&quot;, but userspace extends itself no such courtesy.<br>
<p>
Statically linked binaries all the way back to the a.out-&gt;ELF horizon often work just fine (modulo being basically a giant ball of security holes... that most crackers probably aren&#x27;t aware of).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2020 4:04 UTC (Sun)
                               by <b>set</b> (guest, #4788)
                              [<a href="/Articles/831380/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For fun not to long ago I got a &gt;20 year old dynamicly linked Mosaic binary to run on my modern linux box. The problems there were 1) finding and installing the old required libraries, which was fairly trivial. 2) Layouts and assumptions about userspace 20 years ago meant that even though the program ran, it did not function well because some things just were not where they were expected back then. Also the web has changed a bit;) If it were important the program ran correctly, I would have used a vm with some old distribution in it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor829967"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 9:22 UTC (Sun)
                               by <b>kreijack</b> (guest, #43513)
                              [<a href="/Articles/829967/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is true. Windows provide the most backward compatibility. But I think this is due (in part) to the fact in linux very often the source is available, so recompiling the source (with the adaption to the new environment)  is more simple that providing a strong back compatibility. Moreover windows is x86 only. Linux is widely deployed to a very huge number of architecture<br>
<p>
Howvever, most of the problems are not due to the OS, but the new requisites. I think that Windows is capable to allow to work a lot of DOS program of 90 years. But how these program deals with (.e.g) the date after 2000 ? or the long file name ? or the network ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829967/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830000"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 18:04 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/830000/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It's chicken-and-egg problem. Most users want (and some need) long-years-gurantee, but they don't use Linux, they use Windows.</p>

<p>And the remaining few enthusiasts don't need such guarantees precisely because they were selected (by distro-makers) from the set of all users precisely by that criteria.</p>

<p>As for <i>Linux is widely deployed to a very huge number of architecture</i>... please don't make me laugh: the Linux which is deployed on tens of billions (hundred of billions) devices have nothing to do with the <a href="https://www.jwz.org/doc/cadt.html">CADT Model</a> which BirAdam complains about. <b>That one</b> is almost exclusively for x86... because yes, only there you can send users to Windows.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/830000/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor830281"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 15:10 UTC (Tue)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/830281/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think there&#x27;s an important caveat here in that you are talking about *binary* compatability. IME you can compile most software from decades ago today and it will run fine. I think this model of software compatibility is more desirable and I&#x27;m not sad about it for the same reason as I&#x27;m not sad the kernel doesn&#x27;t make an effort to have a stable abi. I don&#x27;t think anyone in FOSS should be spending extra effort just to make things right for a bunch of corporations that refuse to return the favor.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830281/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor829914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 17:34 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/829914/">Link</a>] (30 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; These include 32-bit architectures which, while still heavily used now, will eventually go away.</font><br>
<p>
I keep reading this on LWN and I still don&#x27;t get it: why would a micro-controller (embedded in a larger SoC or not) with a memory requirement measured in megabytes waste silicon, bandwidth and what else with 64 bits addresses? Doesn&#x27;t make sense to me.<br>
<p>
Maybe this should be read as: &quot;the Linux kernel is losing interest for small/embedded systems&quot;.<br>
<p>
<font class="QuotedText">&gt; There are still MIPS chips coming out from vendors like Loongson and Ingenic and, perhaps surprisingly, still SoCs based on the 20-year-old Armv5 core being introduced.</font><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 19:19 UTC (Sat)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/829922/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I keep reading this on LWN and I still don&#x27;t get it: why would a micro-controller (embedded in a larger SoC or not) with a memory requirement measured in megabytes waste silicon, bandwidth and what else with 64 bits addresses? Doesn&#x27;t make sense to me.</font><br>
<p>
My intuition at first was also that 32-bit systems would remain relevant in Linux for much longer, but after looking at it in more detail while working on the y2038 problem, I came to a different conclusion, and I tried to explain this in my presentation in some detail.<br>
<p>
The thing is that while low-end systems hang around for much longer than high-end ones, hardware companies tend to discontinue products once nobody wants to buy them because the replacements are both cheaper and better. The low-end 64-bit SoCs with Cortex-A53/A35/A55 using LP-DDR4 are already replacing the high-end of 32-bit Arm32 (and other 32-bit) SoCs with DDR3 and are eating away at that market the cheaper they get.<br>
<p>
The low end of 32-bit Linux is also disappearing because code bloat means need increasingly larger memory to do the same things as before. You would not build a system with under 128MB (10 years ago this would have been 16MB) any more unless you are extremely cost-driven and need to save those 20 it would cost to double the memory at the expense of engineering time to fit the product in less RAM. On the other hand, using a microcontroller with an RTOS might let you do the same product with the same engineering cost but even cheaper hardware.<br>
<p>
Once the two sides meet in the middle, there is no point of doing new products on 32-bit Linux and we only need to maintain the ones that are still get kernel updates. The exact time frames are speculation, but I&#x27;m convinced that the two trends are continuing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 22:17 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/829940/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There&#x27;s a lot more information on this particular memory topic at <a href="https://linuxplumbersconf.org/event/7/contributions/655/attachments/638/1161/LPC20_SoC_support_in_the_kernel_1.pdf">https://linuxplumbersconf.org/event/7/contributions/655/a...</a> than I expected, sorry I should have checked.<br>
<p>
This is what happens when LWN spoils us with great conference reports with full sentences: we don&#x27;t feel the need to look at slides and bullet points :-)<br>
<p>
Speaking of full sentences, your comment above makes this topic much clearer, thanks! Appreciated.<br>
<p>
The 128 Megabytes requirement for OpenWRT is a bit conservative; I retired about  6 months ago a wifi router with 32M and it was still running fine the latest OpenWRT version at the time, no crash observed. Even 128M is quite far from the 4G limit.<br>
This being said, OpenWRT is indeed probably the clearest measurement of the current &quot;Linux code bloat&quot; because its userspace requirements are incredibly conservative.<br>
<a href="https://openwrt.org/supported_devices/432_warning">https://openwrt.org/supported_devices/432_warning</a><br>
<p>
I remember when Linksys switched the WRT54G away from Linux to save RAM and cost... is there any more recent example? Not everyone needs/wants to run a complex media server on their wifi router. Or maybe there is none; maybe you&#x27;re right and hardware has finally become cheaper than software :-)<br>
<p>
Unless some hackers &quot;scratch their own itch&quot; some day and attempt to convert some of these well documented (thanks to OpenWRT) routers to some open source RTOS just for fun?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 23:38 UTC (Sat)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/829943/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, I&#x27;d consider a chip with 128KB RAM to be a reasonably high-end microcontroller, which is three orders of magnitude below the 128MB for a reasonably low-end Linux-compatible SoC. But they might both cost about $3 (including the RAM). Microcontrollers can scale down a lot in price and capability, and Linux SoCs can scale up a lot, but there&#x27;s a point where their prices meet and people are still choosing the microcontroller.<br>
<p>
I guess the most common issue is power - the microcontroller can run in standby mode in ~1uA and wake up almost instantly, and 128MB of DRAM can&#x27;t, so for battery-powered devices there&#x27;s often no choice. And microcontrollers seem to typically give you a lot more pins for connecting external peripherals directly, and are more likely to include features like low-power wireless protocols, so you might need one for those reasons. It&#x27;s often not about being cost-driven.<br>
<p>
There are the chips in the middle, with a few MBs of RAM and more computational ability than a microcontroller but lower power consumption than a 128MB SoC. They seem to be in the same price range again, so I think they&#x27;re chosen for their features and power and not price, and they&#x27;re not going to become obsolete just because DRAM is cheap. That&#x27;s the area where Linux and RTOSes could potentially compete, and it sounds like you&#x27;re suggesting Linux should give up and should let the RTOSes win. But even though I don&#x27;t think they&#x27;ll become obsolete, I suspect those chips will always be for fairly niche use cases - few products will have exactly the right set of feature requirements and power constraints that mean they can&#x27;t just use a microcontroller or Linux or both - so it seems fair enough to consider them not worth the effort.<br>
<p>
(RTOSes aren&#x27;t great there because there&#x27;s no standard abstraction layer to let you port code between different vendors&#x27; SDKs, and the development tools are generally very limited (probably no MMU and no Valgrind/ASan so good luck avoiding memory errors), and often the SDKs are just badly written (though they&#x27;re getting better), which is acceptable for microcontroller firmware but becomes painful when you&#x27;re writing enough code to fill several megabytes. But Linux isn&#x27;t great there because it&#x27;s not designed to scale down that far, and it&#x27;s probably less painful for the RTOSes to scale up.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829968"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 9:44 UTC (Sun)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/829968/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      ARM certainly believes that 32-bit has a significant future.  To my surprise, ARMv8-<a href="https://developer.arm.com/architectures/cpu-architecture/m-profile"><strong>M</strong></a> is a pure 32-bit architecture (it implements a variant of the T32 (Thumb) instruction set); they even developed a new vector extension (Helium) for it.  (And yes, I would prefer if they had naming that made such fundamental differences as between ARMv8-A and ARMv8-M more apparent).

<p>Will applications run on bare metal on these systems, if they have, say, 64MB?  If not, what system software will run underneath?  Is Linux (the kernel, not a distribution like Debian) really too big for such machines?
      
          <div class="CommentReplyButton">
            <form action="/Articles/829968/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829970"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 12:03 UTC (Sun)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/829970/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I don't think of Cortex-M (or MMU-less RV32 for that matter) playing a huge role in 32-bit Linux: unless you add an MMU, the pain of running Linux on these makes it similar or worse than running a simple RTOS that is designed for MMU-less operation from the start. Leaving out FPU, DSP/SIMD, L1$ and DRAM controllers on a given chip tips the scales even more away from Linux.
<p>
Where I see Cortex-M replace ARMv5 or MIPS32r2, those seem to run an either an environment supplied by the chip vendor, or an RTOS like FreeRTOS, VxWorks, NuttX, or Zephyr. Linux without MMU has filled another niche for a long time, but I don't see it growing in use.
<p>
The three most likely scenarios I see for the future of 32-bit Linux would be

<ol type="a">
<li>Cortex-A7 (and maybe Cortex-A5 because of DesignStart) continue to replace the few other remaining 32-bit cores and over time goes away itself,
<li>Arm create modern low-end cores between the current Cortex-M and Cortex-A with an MMU, to occupy the market below the Cortex-A7, or
<li>some RV32+MMU designs are successful enough to take market share away from 32-bit Arm before themselves getting replaced by RV64 based designs.
</ol>
      
          <div class="CommentReplyButton">
            <form action="/Articles/829970/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 12:21 UTC (Sun)
                               by <b>james</b> (subscriber, #1325)
                              [<a href="/Articles/829976/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      There's the ARM Cortex-A32, which is a 32-bit only ARM v8-A core explicitly below the A35 / A53 / A55 lines. You could argue that this is your option b ("below the Cortex-A7"), or you could argue that this is a modern replacement for the A7. 
      
          <div class="CommentReplyButton">
            <form action="/Articles/829976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829985"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 16:24 UTC (Sun)
                               by <b>arnd</b> (subscriber, #8866)
                              [<a href="/Articles/829985/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would consider it neither of the two, the Cortex-A32 just seems pointless and if nobody has licensed it in the past four years, then nobody ever will.<br>
<p>
Cortex-A35 and A55 are both very nice power-efficient superscalar cores that can run at high clock frequencies and 4-way SMP or larger. A32 just leaves out the 64-bit instructions from A35, which makes it unfit for a lot of the use cases that would otherwise want such a core.<br>
<p>
What I find missing is a much simpler design that sacrifices performance and scalability to get close to the power and size constraints of the higher-end Cortex-M parts without losing the MMU at the same time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829985/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor829978"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 12:46 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/829978/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can have pure 32-bit ARMv8-A cores too, like the Cortex-A32. ARMv8 isn&#x27;t a fundamentally 64-bit architecture, it&#x27;s a combination of 32-bit and 64-bit where different chips are expected to implement different subsets, across all the -A/-R/-M profiles. (The difference is just that -R/-M don&#x27;t include the option of 64-bit.)<br>
<p>
64MB sounds like a particularly awkward point, because even if you can squeeze Linux down to fit there wouldn&#x27;t be much RAM left over for your application, and it&#x27;s hard to see why you&#x27;d bother designing a 64MB system with Linux instead of e.g. a 4MB one with an RTOS (if your application is small and you care about power) or a 256MB one that fits Linux comfortably (if you don&#x27;t care much about power). (Price presumably isn&#x27;t a big factor here since DRAM is cheap.)<br>
<p>
uClinux could apparently run in 4MB RAM, but I think that&#x27;s a point where you should really just use an RTOS. If you have a choice, maybe Zephyr which is somewhat Linux-inspired but can run in 8KB RAM and can scale up to MBs and looks less amateurish than some other popular RTOSes. In the rare cases where you do have 64MB, you&#x27;ll probably have to stick with the RTOS because that&#x27;s the least unsuitable option.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829978/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 13:41 UTC (Sun)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/829980/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The -R vs -M vs -A difference is a bit more than just &quot;only A has the option of 64 bit&quot;, though that is part of it. The way I think of it is: A has an MMU; R is like A but has only an MPU (programmable regions of memory protection but no page tables); and M is the microcontroller architecture with major differences from the other two in areas like exception handling and TrustZone.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830497"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2020 13:51 UTC (Thu)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/830497/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, just announced, a 64-bit R-profile core:<br>
<a href="https://community.arm.com/iot/b/internet-of-things/posts/arm-cortex-r82-high-performance-64bit-realtime-applications-processing">https://community.arm.com/iot/b/internet-of-things/posts/...</a><br>
<p>
So &quot;A-profile means 64 bit&quot; is now wrong from the other direction too :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830497/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830528"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2020 15:37 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/830528/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmph, it&#x27;s not fair when ARM changes the definition of ARMv8-R to make me look wrong :-) . The ARMv8 ARM (<a href="https://developer.arm.com/documentation/ddi0487/fc/">https://developer.arm.com/documentation/ddi0487/fc/</a>) explicitly says the A profile &quot;Supports the A64, A32, and T32 instruction sets&quot;, the R profile &quot;Supports the A32 and T32 instruction sets&quot;, and the M profile &quot;Supports a variant of the T32 instruction set&quot;, so (according to that documentation) 64-bit is exclusively for A. The Cortex-R82 must be a new, as-yet-undocumented profile.<br>
<p>
Some of the existing documentation actually refers to the &quot;ARMv8-R AArch32 architecture profile&quot;, and the Cortex-R82 is called &quot;ARMv8-R AArch64&quot;, so it looks like that&#x27;s how they&#x27;re distinguishing it. The term &quot;ARMv8-R&quot; is now ambiguous and can refer to two very different architectures (one with an MMU, one without).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830528/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830555"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2020 19:47 UTC (Thu)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/830555/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The R82&#x27;s MMU bit is optional (per the blog post), so ARMv8R AArch64 doesn&#x27;t imply an MMU inherently. It just means it&#x27;s v8, it&#x27;s R-profile (ie primarily MPU) and it&#x27;s running 64-bit.<br>
<p>
If you&#x27;d prefer a different definition, Peter Greenhaugh is in the anandtech comments on <a href="https://www.anandtech.com/show/16056/arm-announces-cortexr82-first-64bit-real-time-processor">https://www.anandtech.com/show/16056/arm-announces-cortex...</a> defining Cortex-R as being all about low interrupt latency, tightly-coupled memory and the like. (Low-and-predictable latency has always been why the MPU.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830555/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 8:39 UTC (Fri)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/830591/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The R82 is in-order, so more predictability.<br>
Still, it has branch prediction, so less predictability.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor829947"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 0:00 UTC (Sun)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/829947/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux doesn&#x27;t really run on microcontrollers. You don&#x27;t need Linux on a toaster. Such applications work best with no OS at all, or a highly targeted one. Nothing extraneous is included, the processor runs nothing except your code, and saving power is easy because there&#x27;s nothing else to worry about. <br>
<p>
For anything larger, 32 bit is increasingly cramped. Take for instance a TV. A modern sort will deal with 4K compressed video, include a web browser, probably do voice recognition... A modern web browser takes huge amounts of RAM that a 32 bit architecture might be able to cope with, but not with a huge amount of headroom. Even a Raspberry Pi today comes with an 8GB RAM option.<br>
<p>
Plus, with everyone switching over to 64 bit you might as well go with that and save yourself the trouble with beating your head against issues that were missed because nobody tried compiling on 32 bits lately.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829947/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829952"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 4:48 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/829952/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Linux doesn&#x27;t really run on microcontrollers. </font><br>
<p>
I don&#x27;t think there&#x27;s any formal definition of &quot;micro-controller&quot; but I admit I misused the word. What I meant is &quot;system with a RAM requirements in megabytes&quot;.<br>
<p>
Now you&#x27;re raising another, interesting question: will systems with RAM requirements  in kilobytes _also_ abandon 32 bits and switch to 64? That would seem like an even bigger waste of silicon.<br>
<p>
<font class="QuotedText">&gt; For anything larger, 32 bit is increasingly cramped.  Take for instance a TV</font><br>
<p>
While the future of 32 bits addresses is debatable, I don&#x27;t believe that _all_ systems requirements of the future will be measured either in kilobytes or in gigabytes but none in megabytes. A TV is just one example, everyone with a crystal ball tells us that _all_ objects will be smart and connected in the future so I predict a continuum of requirements with no gap between kilobytes and gigabytes.<br>
<p>
BTW a wifi router, a smart thermostat and a smart speaker all need less than 1 gigabyte nowadays. Does everyone want a high resolution screen with 3D graphics on their smart thermostat? Does everyone want a wifi router or modem that is also a media server? Did people who bought cars stop using bikes?<br>
<p>
<font class="QuotedText">&gt; Plus, with everyone switching over to 64 bit you might as well go with that and save yourself the trouble with beating your head against issues that were missed because nobody tried compiling on 32 bits lately.</font><br>
<p>
Will re-using 64 bits hardware become cheaper than maintaining 32 bits software? I agree this is the real question here.  Will hardware designers who routinely underestimate the cost of software accept this fact is another interesting question. Now let&#x27;s fast forward to the future when Linux doesn&#x27;t support 32 bits anymore. Will no other 32 bits software alternative fill the gap? A bit hard to believe.<br>
<p>
If ever, many of us will be retired or dead when 32 bits architectures disappear.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829952/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 5:29 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/829953/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The thing is, if you are not making a battery-powered device then you can easily throw in a couple dozen megabytes of RAM, it won&#x27;t even make a dent in a BoM. And with that much RAM it doesn&#x27;t matter much if the code uses 64 bit pointers.<br>
<p>
Battery powered devices are still firmly in 32-bit land for now. Although phase-change memory or NVRAM might start to change that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829964"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 8:49 UTC (Sun)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/829964/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; will systems with RAM requirements in kilobytes _also_ abandon 32 bits and switch to 64</font><br>
<p>
Probably not, to begin with there is no y2038 issue there. Microcontrollers that need wakeups far in the future typically use a real-time clock which provides D/M/Y dates and second-resolution wakeups; otherwise you count cycles and then 32-bits are enough to measure several seconds in the future.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829964/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830025"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 22:36 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830025/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; to begin with there is no y2038 issue there</font><br>
<p>
I expect 64 bits arithmetic on a 32 bits system to be a bit slow but not really rocket science. A quick internet search seems to confirm that. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830025/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 21:44 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/830168/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It depends on what you&#x27;re doing. 64-bit addition and subtraction are generally plenty fast enough on 32-bit systems. Left or right shift (except by a constant 32 bits) requires a few more operations, and may get turned into a library call if the shift amount varies. 64x64 multiplication takes a bit more effort (three 32x32 multiplies and two additions) but will still generally be emitted inline. The real problem area is division (or modulus), which typically requires a call to libgcc or libcompiler-rt. The software to emulate unsigned 64-bit division on 32-bit x86 hardware runs to about 90 lines of optimized assembly code. The generic version[2] is about 170 lines of C. (Note: The generic version of __udivdi3 is implemented in terms of __udivmoddi4.)<br>
<p>
In my own extremely informal benchmarks, a series of 100M 64-bit divisions took about 40% longer to complete when compiled as a 32-bit x86 binary vs. the same code compiled for amd64. Both versions were run on the same 64-bit CPU and compiled with clang-9 -O2.<br>
<p>
[1] <a href="https://github.com/llvm-mirror/compiler-rt/blob/master/lib/builtins/i386/udivdi3.S">https://github.com/llvm-mirror/compiler-rt/blob/master/li...</a><br>
[2] <a href="https://github.com/llvm-mirror/compiler-rt/blob/master/lib/builtins/udivmoddi4.c">https://github.com/llvm-mirror/compiler-rt/blob/master/li...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor829971"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 10:26 UTC (Sun)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/829971/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Now you&#x27;re raising another, interesting question: will systems with RAM requirements in kilobytes _also_ abandon 32 bits and switch to 64? That would seem like an even bigger waste of silicon.</font><br>
<p>
Probably not. But likely not forever.<br>
<p>
Say, 3D printers started with Arduino&#x27;s ATmega, but are increasingly moving on to 32 chips. Because at some point people realized things like &quot;I&#x27;d like to take pictures of the print, but that&#x27;s not really possible on 8K RAM&quot;, and &quot;Why am making myself suffer by worrying how much RAM the serial buffer is taking, when I could use something with a few megabytes on it for just a couple bucks more?&quot;<br>
<p>
<font class="QuotedText">&gt; BTW a wifi router, a smart thermostat and a smart speaker all need less than 1 gigabyte nowadays. </font><br>
<p>
A router will probably use a 64 bit chip, because I&#x27;m going to guess that the combination of &quot;fast&quot; and &quot;low memory&quot; is a rare one. Dealing with gigabit speeds requires considerable power. Plus 64 bit architectures tend to come with new instructions that are better at mass processing data.<br>
<p>
Smart thermostats and such will probably remain on microcontrollers and not use an OS at all.<br>
<p>
<font class="QuotedText">&gt; If ever, many of us will be retired or dead when 32 bits architectures disappear.</font><br>
<p>
Yeah, but it&#x27;s likely Linux won&#x27;t be needed on those. If you add Linux you likely want a substantial userspace (which now is primarily developed on 64 bits), or want to run a web browser (which is cramped on 32 bits already).<br>
<p>
And eventually, when you can get a 64 bit chip for a dollar, it just makes little sense to bother with an old, rarely used architecture where a lot of common software doesn&#x27;t compile out of the box, even if technically it&#x27;s a bit wasteful.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829971/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830036"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 5:49 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830036/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &quot;Why am making myself suffer by worrying how much RAM the serial buffer is taking, when I could use something with a few megabytes on it for just a couple bucks more?&quot;</font><br>
<p>
So far I&#x27;ve only witnessed something opposite: time-consuming discussions between highly paid managers about how to save 20 cents on the BoM cost of a PC. Most managers totally oblivious to the software/firmware impact.<br>
<p>
I heard the TV industry is even &quot;meaner&quot;. BTW I won&#x27;t make the same mistake again when I buy my second &quot;smart&quot; TV and I will check boot time and responsiveness! The first wasn&#x27;t even a cheap brand...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830036/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 6:26 UTC (Mon)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/830037/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Consumer level 3D printers are often made by tiny companies with just a few employees and no highly paid managers whatsoever. <br>
<p>
There&#x27;s also a fierce competition at all levels. Some companies are certainly trying to make the cheapest printer possible, but others know their product will cost $1000 or more and are trying to justify such a price. And the old setup of a text based display and having to laboriously tune everything by hand is increasingly going out of favor. These days you want a pretty UI and as much self-calibration as possible and that is hard to squeeze into the cramped Atmel chips.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor830020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2020 20:31 UTC (Sun)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/830020/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We&#x27;ll probably never stop using 8-bit microcontrollers (with 16-bit pointers); I&#x27;d guess that 32-bit microcontrollers will also carve out a space for themselves once low-end computer-like systems have been out of the space long enough for new architectures to be designed optimized for the requirements of the remaining users.<br>
<p>
For example, I bet in 2040, all the available 32-bit chips will have predictable instruction latency and power usage, with no branch prediction or speculative execution, because they&#x27;re fast enough to meet requirements in the worst case, so they might as well have that be the only case. This goal may have also forced out task-switching in favor of having a core per task, leading to Linux not being as compelling on these systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830029"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 1:22 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/830029/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
8-bit microcontrollers are dying. I&#x27;m seeing plenty of people switching to 32-bit ARMs with something like 8-32kb of RAM.<br>
<p>
Turns out that the toolchains for 8-bit just suck and you have a hard limit of 64kb for direct addressability. So a switch to 32 bits will cause a hit to the code size, but you&#x27;re likely not writing anything complex involving tons of pointers anyway.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830029/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 3:34 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/830032/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can even get a 32-bit Cortex-M3 at 32MHz with 2KB of RAM (<a href="https://www.silabs.com/mcu/32-bit/efm32-tiny-gecko">https://www.silabs.com/mcu/32-bit/efm32-tiny-gecko</a>), or a Cortex-M0+ with 1KB RAM (<a href="https://www.nxp.com/docs/en/data-sheet/LPC81XM.pdf">https://www.nxp.com/docs/en/data-sheet/LPC81XM.pdf</a>). It looks like 8/16-bit MCUs are getting pushed out by the convenience of having a consistent high-quality ARM-based development environment across the whole product range, and the performance cost of 32-bit is still acceptable down to that level.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor830035"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 5:36 UTC (Mon)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/830035/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>It's a slow death. You have to take human factors into account, too. A few years ago I  met a hardware guy who had designed a <b>new</b> device based on an Atmel microcontroller. This Atmel device was available in two versions, pin compatible with identical peripherals. The only difference was that one version had an ARM core, and the other one had a 8-bit 8051 core. Of course he had chosen the 8051 version, because that was what he was familiar with writing software to (in assembly).</p>

<p>The cost of moving to a 32-bit RISC core is essentially negligible today. A RISC-V core can be <a href="https://www.sifive.com/blog/incredibly-scalable-high-performance-risc-v-core-ip">implemented in 0.28 mm<sup>2</sup></a>.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830035/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor830041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 7:19 UTC (Mon)
                               by <b>gdt</b> (subscriber, #6284)
                              [<a href="/Articles/830041/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p><i>I keep reading this on LWN and I still don't get it: why would a micro-controller (embedded in a larger SoC or not) with a memory requirement measured in megabytes waste silicon, bandwidth and what else with 64 bits addresses? Doesn't make sense to me.</i></p>

<p>Computer architecture is a balancing act. If you have a 32-bit computer with a low amount of RAM but with the speed of solid state storage and gigabit networking then if you load up the I/O then the small amount of memory versus the buffering needed will lead to the memory allocations fragmenting badly, eventually causing the computer to become unbearably slow, and then unreliable. So the speed of the world outside of the SoC puts a pressure for more memory.  Adding more memory alone may not be sufficient, because not all memory is equally addressable, especially for buffering. Add too much memory and the result is rococo wonderfulness as described in this <a href="https://lwn.net/Articles/813201/">LWN article</a>.</p>

<p>Eventually you get to the point where the balancing act gets increasingly constrained, and moving to a bigger tent makes sense.</p>

<p>You can see that same broad pressure on SoCs which have no DMA: during a file copy a modern SSD will interrupt immediately the CPU clears interrupts, starving user space. But it really hurts to being paying more money to buy slower, smaller storage.</p>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830046"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 8:21 UTC (Mon)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/830046/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not all all devices need to consume forever growing hardware resources. And if some do, new applications will spring up below that are quite happy with, say, 256 MB of RAM and a 200 MHz 32-bit CPU. For some use cases a capable A/D converter is more important than a GPU or gigabit networking. There is a myriad of chips on the market with 32-bit ARM A7 cores fully capable of running Linux. Back in the day you could boot the Linux kernel on a PC with only a few megabytes of RAM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830046/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 9:31 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/830210/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Back in the day, you ran the applications that currently use A7 cores on 8051s and similar chips. To a very large extent, this is all a balancing act; if 64 bit cores become cheaper than 32 bit, then hardware will move to 64 bit cores, even though an 8 bit core is plenty.
<p>After all, lots of devices are moving to 32 bit ARM v7-M cores, even though an 8051 is still plenty when you have 2k RAM and 16k Flash, because a 32 bit ARM is nicer to develop for, and the sheer volume of ARM cores means it's now cheaper to buy an ARM device than an 8051.
      
          <div class="CommentReplyButton">
            <form action="/Articles/830210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor830155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2020 18:08 UTC (Mon)
                               by <b>smoogen</b> (subscriber, #97)
                              [<a href="/Articles/830155/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Making chips with a specific bit size has a cost involved in that the physical space used for that manufacturing can&#x27;t be used for something else. Also while the main blue-print may not need to change, you can only use the &#x27;chip&#x27; dies for a certain amount before putting together new parts for it. Each time that happens it means you have to recertify the chip matches what was originally built. If you decide that you are going to put together a 10nm chip instead of the 30 nm 32 bit you had from a long time ago.. it is a completely new design. That takes costs and it also has a risk of failure and dealing with again a whole line of equipment being used for a specific low build chip. <br>
<p>
Instead it is a lot &#x27;cheaper&#x27; in manufacturing to come up with a 64 or 128 bit chip you can use across lines and maybe stick some stuff in front which makes it act like its 8bit or 32 bit ancestor. That means you can shrink the amount of factory space you need which cuts costs. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor829915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 17:47 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/829915/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The SoC part of the market, in particular, is represented by the middle part of the map: systems larger than microcontrollers, but smaller than data-center processors. </font><br>
<p>
That&#x27;s a surprising definition of a SoC. I&#x27;ve googled a bit and all definitions I found look like this instead:  &quot;SoC is a complete processing system contained in a single package&quot;. Also found this: &quot;Ultimately, SoCs are the next step after CPUs.&quot;<br>
<p>
Granted, none of the definitions I found are &quot;exact science&quot; because none of them define when a system is considered &quot;complete&quot;. However they all consider off-the-shelf data-center processors as &quot;SoCs&quot; considering their level of integration.<br>
<p>
BTW a SoC can by definition embed different architectures in a single chip<br>
<a href="https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git">https://git.kernel.org/pub/scm/linux/kernel/git/firmware/...</a><br>
<p>
Some SoCs could even be running multiple copies of Linux on a single chip. Well, only until Linux stops supporting 32 bits and embedded of course :-)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829917"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 18:00 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/829917/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Adding code to the kernel to support new hardware is relatively easy. Removing code that is no longer useful can be harder, mostly because it can be difficult to know when something is truly no longer needed.</font><br>
<p>
Removing code is very hard in general. <br>
<p>
- Juniors developers: with the help of project managers, flood code bases with new bugs and Duplication &amp; Divergence (a.k.a copy/paste)<br>
<p>
- Experienced developers: review code and try to keep aforementioned flood under control. <br>
<p>
- Seniors developers: root cause and fix bugs that were let in. Refactor and _remove_ duplicated or dead code.<br>
<p>
It&#x27;s sad the industry seem to still value new code more than deleted code, should be the other way around. People finding bugs should also be paid much more than people adding them. I digress.<br>
<p>
I think the main reason the kernel is high quality is because it&#x27;s pretty hard to add code to it. I vaguely remember a quote from Linus summarising the job of a maintainer: saying &quot;no&quot;.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829917/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830468"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 9:45 UTC (Fri)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/830468/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It&#x27;s sad the industry seem to still value new code more than deleted code, should be the other way around. </font><br>
<p>
An industry is going to value what sells. <br>
<p>
Maybe Minix really is a super-reliable system with crystal clear code. Does it run on x86-64? No. Does it run on ARM64? No. Does it run on a Raspberry Pi? No. So I have a super-reliable system I can run in an emulator in a system that valued working over elegance.<br>
<p>
For another example, &quot;I just downloaded a file and opened it up&quot; beats &quot;I just downloaded a file and turns out to be TIFF with CCITT T.6 bi-level encoding or a PCX file or use a Microsoft MPEG-4 Version 3 video codec&quot; and I have to dig up code that works (who cares if it&#x27;s elegant) or give up on viewing it. <br>
<p>
There are points when stuff should just go. But if you rewrite Linux filesystem code so it supports ext4 and iso9660 and drops support for all those obsolete and half-supported filesystems like NTFS and JFS and hpfs and VFAT, I don&#x27;t see why anyone not a kernel programmer should consider that an improvement, even if it did get 0.7% faster. And even among kernel programmers, it seems they&#x27;re the most likely to have a partition for other operating systems and old drives and disks around with non-ext4 filesystems. <br>
<p>
I believe Linus also talks about not breaking code that runs on Linux. It&#x27;s easy to delete obsolete features if you don&#x27;t care about code that wasn&#x27;t updated yesterday.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830468/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830667"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 4, 2020 17:07 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830667/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; An industry is going to value what sells.</font><br>
<p>
Sure but I was writing about something entirely different: removing duplication or _unused_ code, no customer cares about that. This saves maintenance costs and makes adding new features easier yet good luck &quot;selling&quot; this to your average manager in your annual review. I don&#x27;t know who is Arnd&#x27;s manager but he seems like a lucky guy ;-)<br>
<p>
Same with validation: employees who find bugs before customers save their companies a lot of money and should be rewarded correspondingly. How often have you seen that happening?<br>
<p>
There&#x27;s generally no tracking of who adds the most bugs either. If they really meant business, companies would have a &quot;guilty&quot; field in bug trackers. It wouldn&#x27;t be rocket science thanks to &quot;git blame&quot; (the command name is a good start...) but I guess &quot;creators&quot; who add new code and bugs are too venerated for that to ever happen. We even have &quot;rock stars&quot;, says a lot.<br>
<p>
I heard a rumour that Apple is... different in that respect. It seems to achieve some results wrt. to quality.<br>
<p>
tl;dr: most companies are still clueless with respect to actual development costs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830667/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2020 1:43 UTC (Sun)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/830756/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; removing duplication or _unused_ code, no customer cares about that.</font><br>
<p>
The second line of the article says:<br>
<p>
<font class="QuotedText">&gt;&gt; Removing code that is no longer useful can be harder, mostly because it can be difficult to know when something is truly no longer needed. </font><br>
<p>
<font class="QuotedText">&gt; Same with validation: employees who find bugs before customers save their companies a lot of money and should be rewarded correspondingly. How often have you seen that happening?</font><br>
<p>
<a href="https://thedailywtf.com/articles/The-Defect-Black-Market">https://thedailywtf.com/articles/The-Defect-Black-Market</a><br>
<p>
Besides the subtleties of making it work, there&#x27;s the questions of financial value. There&#x27;s a certain point where getting something out today is much better than getting something slightly better out tomorrow, especially when tomorrow is going to bring new hardware you have to run on and thus new bugs.<br>
<p>
<font class="QuotedText">&gt; most companies are still clueless with respect to actual development costs.</font><br>
<p>
I think that modern capitalism has made many companies worry about today and not tomorrow. Long-term thinking can be discouraged in these projects. There&#x27;s also developer preferences; most programmers want to write the interesting new code, not spend a week trying to figure why these 10,000 lines of spaghetti code are returning a value that it obviously can&#x27;t return. There&#x27;s other developers who will refactor and refactor even when it produces more bugs and less clarity than they started with. Neither encourage companies to go back and clean up.<br>
<p>
But I go back to my original comment; people will curse an OS that crashes once a day, but they won&#x27;t use an OS that doesn&#x27;t work on their system. Several times in business I&#x27;ve been told how to work about nasty bugs in specialized programs; maybe they got reported upstream, maybe not, but I was told e.g. to twiddle with business numbers until the report printed and then fix them in pen. The upstream is not clueless with the actual development costs in those cases; the users will curse it and work around the bugs, as long as it does what they need. Windows 95 may have sucked, but it was good enough the users tended to stick around despite the bugs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor830789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2020 19:00 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/830789/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; <a href="https://thedailywtf.com/articles/The-Defect-Black-Market">https://thedailywtf.com/articles/The-Defect-Black-Market</a></font><br>
<font class="QuotedText">&gt; Besides the subtleties of making it work,...</font><br>
<p>
If you don&#x27;t mind cheating then it&#x27;s much more valuable to sell defects _outside_ the company. Works for both testers and developers.<br>
<p>
Spy agencies and criminals wouldn&#x27;t be doing their work if they were not approaching &quot;vulnerable&quot; developers asking them to add some security &quot;mistakes&quot; in poorly reviewed and tested areas of the code. Easier to hide and deny with an unsafe language like C where intentional memory corruption mistakes are barely distinct from unintentional ones. Even more discreet in a project that does not separate security bugs from other bugs. The only thing difficult to hide is the check/reward.<br>
<p>
<font class="QuotedText">&gt; There&#x27;s also developer preferences; most programmers want... Neither encourage companies...</font><br>
<p>
I think management not studying and not questioning what &quot;their programmers want&quot; is a good indicator of &quot;companies being clueless about development costs&quot;. &quot;Rock Stars&quot; programmers is of course the extreme version of that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor830208"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Software and hardware obsolescence in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 1, 2020 8:48 UTC (Tue)
                               by <b>tdz</b> (subscriber, #58733)
                              [<a href="/Articles/830208/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another point when considering code obsolescence is how easy it is for someone to pickup the hardware and try to use it. The discussion focuses on computer architectures, which tend to remain dead after they reached their EOL. But old add-on cards and USB devices are often easy to use on modern systems. Removing the rsp drivers would be a mistake, even if the hardware is not in widespread use anymore.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/830208/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
