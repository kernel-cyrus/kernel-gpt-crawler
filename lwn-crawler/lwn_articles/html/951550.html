        <!DOCTYPE html>
        <html lang="en">
        <head><title>Preventing atomic-context violations in Rust code with klint [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/951550/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/951632/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/951550/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Preventing atomic-context violations in Rust code with klint</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>November 17, 2023</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2023-Linux_Plumbers_Conference">LPC</a>
</div>
One of the core constraints when programming in the kernel is the need to
avoid sleeping when running in atomic context.  For the most part, the
responsibility for adherence to this rule is placed on the developer's
shoulders; Rust developers, though, want the compiler to ensure that code
is safe whenever possible.  At the <a href="https://lpc.events/">2023 Linux
Plumbers Conference</a>, Gary Guo presented (via a remote link) the klint
tool, which can find and flag many atomic-context violations before they
turn into user-affecting bugs.
<p>
Rust is built on the idea that safe Rust code, as verified by the compiler,
cannot cause undefined behavior.  This behavior comes in a lot of forms,
including dereferencing dangling or null pointers, buffer overruns, data
races, or violations of the aliasing rules; code that is "safe" will not do
those things.  The Rust-for-Linux project is trying to create an
environment where much kernel functionality can be implemented with safe
code.  On the other hand, some surprising behavior, including memory leaks,
deadlocks, panics, and aborts, is considered "safe".  This behavior is
defined, thus "safe" (though still, obviously, bad).
<p>
Atomic context in the kernel raises some interesting safety questions.  If
code, for example, executes a sequence like:
<p>
<pre>
    spin_lock(&amp;lock);
    /* ... */
    mutex_lock(&amp;mutex);   /* can schedule */
    /* ... */
    spin_unlock(&amp;lock);
</pre>
<p>
the result could be a deadlock if another thread attempts to take the same
spinlock on the same CPU.  That is "safe" (but "bad") code.  But what about
code like the following?
<p>
<pre>
    rcu_read_lock();
    schedule();
    rcu_read_unlock();
</pre>
<p>
In this case, the safety of this code, even in the Rust sense, is not so
clear.  RCU assumes that there will be no context switches in code that is
running within an RCU critical section; calling into the scheduler breaks
that assumption.  In this case, the atomic-context violation can indeed be
a safety issue, creating use-after-free bugs, data races and worse.  This
is "fine" for C code, where the distinction between "safety" and
"correctness" is not so well defined.  Rust developers, though, try to live
by different rules; consequently, they cannot design a safe API that allows
sleeping in atomic context.
<p>
<a href="/Articles/951776/"><img src="https://static.lwn.net/images/conf/2023/lpc/GaryGuo-sm.png"
alt="[Gary Guo]" title="Gary Guo" class="rthumb"></a>

Avoiding that situation is not easy, though.  One possible solution would
be to make all blocking operations unsafe.  That, Guo acknowledged, is
likely to be widely seen as a bad idea.  Another approach is token types,
which are commonly used in Rust to represent capabilities; functions that
might sleep can require a token asserting the right to do so.  That
leads to complex and unwieldy APIs, though.  It is possible to do runtime
checking, using the preemption count maintained in some kernel
configurations now.  That adds runtime overhead, though, and the preempt
count is not available in all kernel configurations.
<p>
The last option would be to simply ignore the problem and trust developers
to get things right, perhaps using the kernel's lockdep locking checker to
find some problems on development systems.  That approach, though, is
unsound and not the Rust way of doing things.
<p>
The root of the problem, Guo said, is the need to optimize three objectives
(soundness, an ergonomic API, and minimal run-time overhead) in a "choose
any two" situation.  Token types optimize soundness and overhead at the
expense of an ergonomic API, for example, while run-time checking improves
the API but sacrifices the goal of avoiding run-time overhead.  Solutions
that optimize all three quantities are hard to come by; the kernel's needs
simply do not fit nicely into the Rust safety model.
<p>
The answer, Guo said, is to adapt the Rust compiler to this use case; that
has been done in the form of a tool called "klint", which will verify at
compile time the absence of atomic-context violations to the maximum extent
possible.  For the cases that cannot be verified, an escape hatch, in the
form of a run-time check or use of <tt>unsafe</tt>, will be provided to
developers so that their code can be built.
<p>
This tool was built with a number of goals in mind.  It should be easy to
explain and understand, of course, and provide useful diagnostics.  There
needs to be an escape hatch so that it does not get in the way of getting
real work done.  Its defaults, he said, should be sane, and there should be
little need for additional annotations in the kernel.  Finally, the tool
needs to be fast so that it can be run every time the code is built.
<p>
Klint gives every function two properties, the first of which is an
"adjustment" describing the change it makes (if any) to the <a
href="/Articles/831678/">preemption count</a> (which, when non-zero,
indicates that the current thread cannot be preempted).  The second is the
expected value of the preemption count when the call is made; this value
can be a range.  The klint tool tracks the possible state of the preemption
count at each location, looking for situations where a function's expected
preemption count is violated.
<p>
Thus, for example, <tt>rcu_read_lock()</tt> increments the preemption count
by one, and can be called with any value.  In Rust code, that would be
annotated as:
<p>
<pre>
    #[klint::preempt_count(adjust = 1, expect = 0.., unchecked)]
    pub fn rcu_read_lock() -&gt; RcuReadGuard { /* ... */ }
</pre>
<p>
As klint passes over the code, it tracks the possible values of the
preemption count and flags an error if an expected condition is not met.
For example, <tt>schedule()</tt> would be annotated as expecting the
preemption count to be zero; if klint sees a call to <tt>schedule()</tt>
after a call to <tt>rcu_read_lock()</tt> it will complain — unless, of course,
there is a call to <tt>rcu_read_unlock()</tt> that happens first.
<p>
The compiler's type inference makes explicit annotation unnecessary much of
the time.  There are exceptions, naturally, including at the
foreign-function interface boundary, with recursive functions, and with
indirect function calls.  Other limitations exist as well; there is, for
example, no way to annotate functions like <tt>spin_trylock()</tt>, where the
effect on the preemption count is not known in advance.  Perhaps, in the
future, that shortcoming could be addressed by adding some sort of
<tt>match</tt> expression to the annotations, he said.
<p>
Data-dependent acquisition, where, for example, a function only takes a
lock if a boolean parameter instructs it to, is also not handled by klint
at this point.  Finally, there are cases where the compiler injects code
into a function that confuses klint, leading to incorrect reports.  This
problem is currently blocking the wider use of klint, and is thus urgent to
solve.  Meanwhile, he said, klint imposes a negligible compile-time
overhead.
<p>
Guo concluded by saying that klint is <a
href="https://github.com/rust-for-linux/klint">available on GitHub</a> for
folks who want to play with it.  More information can also be found in <a
href="https://lpc.events/event/17/contributions/1431/attachments/1336/2679/klint.pdf">the
slides from the talk</a>.
<p>
[Thanks to the Linux Foundation, LWN's travel sponsor, for supporting our
travel to this event.]
<br clear="all"><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Linux_Plumbers_Conference-2023">Linux Plumbers Conference/2023</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/951550/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor951832"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2023 18:39 UTC (Fri)
                               by <b>IanKelling</b> (subscriber, #89418)
                              [<a href="/Articles/951832/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      ran cloc on klint:

<pre>
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
Rust                            30            880            532           6265
Markdown                         3             25              0             73
YAML                             2              6              3             31
TOML                             1              3              1             12
</pre>



      
          <div class="CommentReplyButton">
            <form action="/Articles/951832/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951844"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 17, 2023 21:45 UTC (Fri)
                               by <b>cytochrome</b> (subscriber, #58718)
                              [<a href="/Articles/951844/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Pardon my ignorance, but what should I make of those numbers?<br>
Is that an unusually small (or large) loc for this type of tool?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951844/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951859"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2023 8:16 UTC (Sat)
                               by <b>IanKelling</b> (subscriber, #89418)
                              [<a href="/Articles/951859/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Up to you. I suggest looking around. On debian, apt install cloc, then<br>
<p>
&lt;pre&gt;<br>
mkdir -p /tmp/s<br>
cd /tmp/s<br>
apt source SOME_PACKAGE<br>
cloc .<br>
&lt;/pre&gt;<br>
<p>
Run ncdu to find the big files. Take a stroll.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951859/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2023 8:17 UTC (Sat)
                               by <b>IanKelling</b> (subscriber, #89418)
                              [<a href="/Articles/951860/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Forgot to hit html for my comment, but it doesn't matter.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor951863"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2023 9:28 UTC (Sat)
                               by <b>burki99</b> (subscriber, #17149)
                              [<a href="/Articles/951863/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I still find your comment rather odd. You could also tell us how many times the letter u is used in this linter. But that wouldn't add much to my or other readers' understanding of this tool.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951863/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor951910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2023 1:48 UTC (Mon)
                               by <b>dfc</b> (subscriber, #87081)
                              [<a href="/Articles/951910/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I was catching up on LWN tonight and saw another comment that used cloc. Same commenter equally strange to read without any context. <br>
<p>
<a href="https://lwn.net/Articles/951716/">https://lwn.net/Articles/951716/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor951923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2023 10:00 UTC (Mon)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/951923/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a few commenters on this website known for making strange comments and nearly constantly getting into the same protracted arguments with each other. Call them say, "bold about rust", "signature conjector" and "realname with RMS".<br>
<p>
I'm afraid your current best option is just to ignore them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor952036"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2023 23:26 UTC (Mon)
                               by <b>cytochrome</b> (subscriber, #58718)
                              [<a href="/Articles/952036/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure that "commenters... making strange comments..." applies to the individual who made the first comment. It just would have been nice to have their interpretation of the LOC information they provided. However, it may have simply been their enthusiasm for applying a cool tool (cloc) and sharing the results.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952036/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor952043"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2023 0:27 UTC (Tue)
                               by <b>WolfWings</b> (subscriber, #56790)
                              [<a href="/Articles/952043/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
...that's kinda the definition of 'commenter making strange comments' though.<br>
<p>
They're providing zero context, just pasting the output from some random tool they throw at every piece of software they can, and literally expecting others to interpret it for themselves and explicitly refusing to explain.<br>
<p>
I don't know how many more boxes on the bingo-card of "boy that's a random comment" you can hit?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952043/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor951864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2023 10:35 UTC (Sat)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/951864/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>So it's a fairly small program, apparently broken out into manageably sized chunks.</p>

<p>That's good to know.</p>

<p>Did you have any particular reason for posting these statistics <em>without commentary</em>?</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/951864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor951882"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2023 21:45 UTC (Sat)
                               by <b>ttuttle</b> (subscriber, #51118)
                              [<a href="/Articles/951882/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I’m likewise curious what conclusions you intend us to draw from this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951882/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor951902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2023 19:56 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/951902/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Memory leaks in particular seem to me to be a major Red Herring.<br>
<p>
If I intentionally don't track the underlying memory allocation for some modestly sized but long-lived information I know I won't replace without terminating the software, we're not losing anything by that. In userspace Rust's Box::leak explicitly says I know this is a Box (thus it owns a heap allocation) but I'm OK with it just never being freed, give me a *reference* to the thing inside the box, the reference now lives forever, that's fine because it's never being freed.<br>
<p>
In contrast, if I have some memory allocations which I'm definitely going to release properly... but it turns out I actually only ever release them in the very moment before exit even though I haven't needed them for an extended period, that's a real problem, and yet *that* isn't formally a leak.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor952031"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2023 21:03 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/952031/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, there's two sides to it:<br>
<p>
* Rust's soundness guarantees do not cover leaks at all. As far as Rust is concerned, leaking memory (and never running its destructor, if any) is 100% sound in all cases. This is why mem::forget() and Box::leak() are safe functions. The soundness rules only require that *if* a destructor is run, then the object must not be used once the destructor returns. This can have some unintuitive consequences. For example, leaking a MutexGuard is sound, which means it is sound to lock a Mutex and never unlock it (and deadlock/starve all of the other threads that want to use that lock). The same applies to most of the other things in std::sync.<br>
* If you're writing a kernel, you really really really do not want to leak memory (unless you are e.g. constructing some static data structure at boot time). Leaking memory in userspace is bad, but the kernel will clean up after you when your process terminates. Memory leaked in kernelspace will remain leaked until the system reboots. OTOH, as described in the previous bullet, there are a lot of other things you can do that Rust considers sound, but are highly undesirable in practice.<br>
<p>
Soundness was never meant to be the same thing as correctness. It was meant to prevent UB. Leaking memory does not risk UB, so it is sound. Deadlock is not UB either, so it is sound. Etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952031/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor952039"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2023 23:22 UTC (Mon)
                               by <b>dvrabel</b> (subscriber, #9500)
                              [<a href="/Articles/952039/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Leaking memory is only non-UB behaviour if your program has access to unlimited memory, otherwise the program will panic at some undefined point in time when it runs out of memory, although I suppose rust claims this behaviour as well-defined since the outcome when it happens is deterministic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952039/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor952041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2023 0:54 UTC (Tue)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/952041/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But this is exactly why I think "leaks" are a red herring. You've gone from "leak" to "unbounded memory allocation" and now there's a big problem, but the two are only related colloquially.<br>
<p>
The sort of leaks that leakdice is written to investigate count as both and are surely a bug which must be fixed. But when you try to write down formally what isn't OK, you discover that the leak wasn't the problem, it was the unbounded thirst for memory.<br>
<p>
"We can optimise this movie player by loading all the quarter million frames into RAM and then flipping through them" blows up just as badly on a 1990s PC with 4MB of RAM regardless of whether you wrote code to free all those images at the end, we're never getting that far.<br>
<p>
And yes, it's not UB to drop dead once you're out of other options. For an OS kernel rebooting might be a reasonable option, and so might power off, neither of which is Undefined Behaviour.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor952044"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2023 1:08 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/952044/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think panicking is considered non-UB just because of determinism. Rust's goal is that safe code cannot trigger the set of behaviours it considers UB (assuming there are no soundness bugs in `unsafe` code) - that's fundamental to the relationship between safety, soundness, and UB - but safe code can trigger panics, so panics cannot be considered UB.<br>
<p>
And I think safe code is allowed to panic for ergonomic reasons: in most applications and libraries, it would be very annoying if every object allocation and every array access and every unwrapping of an Option etc had to explicitly handle errors or propagate the errors through all the APIs in its call stack. Those operations are frequently done where it's obvious they can't fail - e.g. allocation will always succeed in default Linux userspace (it just may attract the ire of the OOM killer some time later), and you might have already done some manual bounds checks before accessing the array, etc - so it's nice to be able to skip the useless error handling code there. In the rare cases where the thing you thought was 'obvious' was actually wrong, it will panic and cleanly terminate the process, and the system can recover by e.g. restarting the application, which isn't perfect but it seems a worthwhile tradeoff.<br>
<p>
That's a worse tradeoff in kernel code, where it's much harder to recover from termination and you'd be willing to put a lot more effort into writing panic-free code, and maybe it could make sense to declare panic as UB so the compiler guarantees safe code won't panic; but much of Rust's standard library was designed to panic, so changing the definition of UB would be too much divergence from regular Rust, and it's probably easier to just treat panics like any other non-statically-checked bug that you want to avoid.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952044/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor952048"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2023 9:58 UTC (Tue)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/952048/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Rust standard library isn't available in Rust-for-Linux, only core (some of which is necessary to have Rust even work as a language e.g. you can't have for loops without core::iter::IntoIterator) is provided, plus their own take on alloc, but not std.<br>
<p>
Even for writing very low level code, "This won't happen, don't bother me about it" is ergonomically necessary. It's fine if the reaction when you're wrong can be very dramatic, right down in the machine code if we have a fault but the CPU has for example not been told how to deal with any faults (or that the handlers for all faults are gone) it will just reboot.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952048/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor952094"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2023 15:58 UTC (Tue)
                               by <b>MarcB</b> (subscriber, #101804)
                              [<a href="/Articles/952094/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Something potentially happening at an undefined (better: unpredictable) point in time does not make it undefined behaviour.<br>
<p>
Undefined behaviour is generally limited to things that are undefined within a given language specification. Here the specification will most likely say that memory allocations can fail and what happens if they do.<br>
<p>
UB does not include things that are influenced by external factors. In this example, it might as well be another program that consumed all memory and causes you program's allocation to fail. So if your program panics or not does not even depend on its own quality.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952094/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor952211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2023 11:08 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/952211/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>The behaviour is well-defined, not UB, because the behaviour of Rust code in an OOM situation is well-defined; either a panic if you use the infallible allocation APIs (which assume that you can't have OOM), or a failure if you use a fallible allocation API (such as <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.try_reserve"><tt>Vec::try_reserve</tt></a>.
<p>This means that I can read Rust code, and I know exactly what will happen on OOM, and where OOM can happen (assuming I'm running on an underlying allocator that reports OOM, and not an overcommitting allocator that kills the process on OOM). In contrast, if OOM is UB, then once I hit an OOM situation, the program can behave in any fashion - including "time travel" back to before OOM happened followed by weird behaviour. In practice, UB is a huge problem when the compiler is doing any form of optimization, because the compiler can assume that UB does not happen, and reason from there.



      
          <div class="CommentReplyButton">
            <form action="/Articles/952211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor952120"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 21, 2023 16:43 UTC (Tue)
                               by <b>tbelaire</b> (subscriber, #141140)
                              [<a href="/Articles/952120/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Mem::forget started out as unsafe, and there were even scoped threading APIs which relied on the destructors being run on join guards to guarantee safety.  But then people discovered that you could put those join guards into an reference counted cycle and leak the entire cycle using only safe code.<br>
<p>
Clearly something was wrong, either RC or the scoped threading APIs were incorrect.<br>
<p>
It was easier to declare leaks safe than get ride of reference counted pointers.<br>
<p>
<p>
<p>
<a href="https://rust.cologne/2022/08/24/avoiding-leakpocalypse.html">https://rust.cologne/2022/08/24/avoiding-leakpocalypse.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952120/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor951909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2023 1:42 UTC (Mon)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/951909/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I’m not - yet - a rust programmer, but this:<br>
“ The last option would be to simply ignore the problem and trust developers to get things right, perhaps using the kernel's lockdep locking checker to find some problems on development systems. That approach, though, is unsound and not the Rust way of doing things.”<br>
Is perfect.  Why should people ever check for something a tool can check for them?  And yes, I know there are exceptions, but it’s the right place to *start*.  We forget stuff all the time or are never taught it.  Every bug the tool can find or the design can prevent is time saved for other things.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor951912"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2023 1:54 UTC (Mon)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/951912/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It'd be nice to call it something a bit more descriptive than 'klint'.<br>
<p>
That one character doesn't say a lot about what it's linting. Characters aren't expensive.<br>
<p>
I get that it's 'rust-for-linux/klint' on GitHub. But a more searchable, less collision prone name would not hurt anyway. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/951912/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor952374"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 22, 2023 19:14 UTC (Wed)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/952374/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Submit a PR with suggestions, such as krslint, maybe ;-)<br>
<p>
In fact "krs" as a prefix for kernel-rust things in general, if there is not some other small prefix already in use, seems useful...<br>
<p>
Bikeshed to taste :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/952374/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor953042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Preventing atomic-context violations in Rust code with klint</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 28, 2023 13:07 UTC (Tue)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/953042/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Smatch has a similar check for C.  Although Smatch doesn't care about concurrency issues here like Rust would.  Only about sleeping in atomic bugs.<br>
<p>
check_sleep_info.c tracks which functions sleep.  It only tracks functions which sleep on every path.  This doesn't mean that we miss bugs, but it does mean that the warning messages are not printed as close to lock as you would want.  (You want the warning as close as possible to the lock).<br>
<p>
check_preempt_info.c tracks which functions adjust the preempt count.  It only tracks simple functions which enable or disable preemption one time.  If we first disable preemption and then enable it again that's ignored.  There are a bunch of functions hard coded as disabling or enabling preemption.  I don't know if they're all necessary, but I had the list from my locking code so it was easy to cut and paste it.<br>
<p>
check_preempt.c tracks whether preemption is currently disabled.<br>
<p>
check_scheduling_in_atomic.c actually prints the warning.<br>
<p>
When Smatch prints a warning then you generally need `smdb.py preempt &lt;function&gt;` to find out which call tree is holding the lock.<br>
<p>
The code is at <a href="https://github.com/error27/smatch">https://github.com/error27/smatch</a><br>
<p>
The main advantage of the Smatch approach is that you don't need to annotate anything.  Annotations are not going to be complete and they're seldom as flexible as you would like.  For example, kmalloc() will sleep unless you pass ___GFP_DIRECT_RECLAIM (or GFP_ATOMIC) so how would you annotate that?  There must be a way, because that's the main source of sleeping in atomic bugs but it's not described in the article.<br>
<p>
The main cause of missed bugs in Smatch is that this code doesn't handle IRQ context (only preempt count).<br>
<p>
The main cause of false positives is places which set a flag or a variable can_sleep in one function and then read it again in another function five steps away.  For example, in "struct msghdr msg = { .msg_flags = MSG_DONTWAIT | MSG_EOR };", the MSG_DONTWAIT flag means that it won't sleep.  Smatch has some work arounds for some of these but still has false positives.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/953042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
