        <!DOCTYPE html>
        <html lang="en">
        <head><title>A kernel event notification mechanism [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/760714/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/760293/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/760714/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A kernel event notification mechanism</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>July 25, 2018</br>
           </div>
The kernel has a range of mechanisms for notifying user space when
something of interest happens.  These include <a
href="/Articles/604686/">dnotify and inotify</a> for filesystem events,
signals, <tt>poll()</tt>, tracepoints, uevents, and more.  One might think that
there would be little need for yet another, but there are still events of
interest that user space can only learn about by polling.  In an attempt to
fix this problem, David Howells, not content with his recent attempt to <a
href="/Articles/759499/">add seven new system calls</a> for filesystem
mounting, has put forward <a href="/Articles/760596/">a proposal</a> for a
general-purpose event notification mechanism for Linux.
<p>
The immediate use case for this mechanism is to provide user space with
notifications whenever the filesystem layout changes as the result of mount and
unmount operations.  That information can be had now by repeatedly reading
<tt>/proc/mounts</tt>, but doing so evidently can impair the performance of
the system.  The patch set also provides for superblock-level events, such as
I/O errors, filesystems running out of space, or processes running into
disk quotas.  Finally, the ability to watch for changes to in-kernel keys
or keyrings is also included.
<p>
The BSD world has long had the <a
href="https://www.freebsd.org/cgi/man.cgi?query=kevent&apropos=0&sektion=0&manpath=FreeBSD+9.0-RELEASE&arch=default&format=html"><tt>kqueue()</tt>
and <tt>kevent()</tt></a> system calls for this purpose.  Naturally, the
mechanism proposed by Howells looks nothing like that API.  It is, instead,
seemingly designed for performance even with high event rates; to get
there, user space must set up and manage a circular buffer that is used to
transfer 
events from the kernel.  (As an aside, the kernel already has a whole set of
circular-buffer mechanisms for perf events, ftrace events, network packets,
and more.  This patch set adds yet another.
It would have been nice, years ago, to create a single abstraction for these
buffers so that a set of library functions could be provided to work with
all of them, but that ship sailed some time ago.)
<p>
<h4>Setting up the event buffer</h4>
<p>
There is no system call dedicated to setting up the event buffer; instead,
the first step is to open a special device (<tt>/dev/watch_queue</tt>) for
that purpose.  User
space then uses <tt>ioctl()</tt> to configure this buffer,
starting with the <tt>IOC_WATCH_QUEUE_SET_SIZE</tt> command to set its size
(in pages).  The application will need to call <tt>mmap()</tt> on the
device file descriptor to map the event buffer into its address space.
<p>
Then, the application needs to arrange for events of interest to be
delivered into this buffer.  There are actually two separate tasks that
must be done here: asking for events to be delivered, and configuring a
filter to control which events actually make it into the ring buffer.
Requesting delivery is dependent on the event type.  For events related to
keys, there is a new command for the <a
href="http://man7.org/linux/man-pages/man2/keyctl.2.html"><tt>keyctl()</tt></a>
system call:
<p>
<pre>
    int keyctl(KEYCTL_WATCH_KEY, key_serial_t id, int buffer,
               unsigned char watch_id);
</pre>
<p>
Where <tt>id</tt> identifies the key of interest, <tt>buffer</tt> is the
file descriptor for the event buffer, and <tt>watch_id</tt> is an eight-bit
identifier that will appear in any generated events.  For filesystem
topology events, a new system call is used:
<p>
<pre>
    int mount_notify(int dfd, const char *path, unsigned int flags,
    		     int buffer, unsigned char watch_id);
</pre>
<p>
Here, <tt>dfd</tt> and <tt>path</tt> identify the mount point,
<tt>flags</tt> is one of the <tt>AT_*</tt> flags controlling how
<tt>path</tt> is followed, <tt>buffer</tt> is the file descriptor for the
event buffer, and <tt>watch_id</tt> is the user-supplied identifier.  For
superblock events, a similar system call has been added:
<p>
<pre>
    int sb_notify(int dfd, const char *path, unsigned int flags,
    		  int buffer, unsigned char watch_id);
</pre>
<p>
No doubt there will be other types of notifications added in the future if
this mechanism makes it into the mainline kernel.
<p>
Each of the calls above will generate notifications for a number of
different event types.  For example, superblock events in the current patch
set include "filesystem was toggled between read/write and read-only", "I/O
error", "disk quota exceeded", and "network status change". 
The requesting application may not be interested in all of these event
types.  Getting the right ones requires setting up a filter, which is done
by filling in a  <tt>watch_notification_filter</tt> structure:
<p>
<pre>
    struct watch_notification_type_filter {
	__u32	type;			/* Type to apply filter to */
	__u32	info_filter;		/* Filter on watch_notification::info */
	__u32	info_mask;		/* Mask of relevant bits in info_filter */
	__u32	subtype_filter[8];	/* Bitmask of subtypes to filter on */
    };

    struct watch_notification_filter {
	__u32	nr_filters;		/* Number of filters */
	__u32	__reserved;		/* Must be 0 */
	struct watch_notification_type_filter filters[];
    };
</pre>
<p>

For each entry in the <tt>filters</tt> array, <tt>type</tt> identifies the
subsystem type of the event (<tt>WATCH_TYPE_MOUNT_NOTIFY</tt>,
<tt>WATCH_TYPE_KEY_NOTIFY</tt>, or <tt>WATCH_TYPE_SB_NOTIFY</tt> in the
current patch set),
<tt>subtype_filter</tt> is a bitmask indicating the specific events that
the application is interested in â€” <tt>notify_key_instantiated</tt>,
<tt>notify_mount_unmount</tt>, or <tt>notify_superblock_error</tt>, for
example.  The <tt>info_filter</tt> field can be used to further filter on
event-specific information; it can be used to catch mount-point transitions
to read/write, for example, while ignoring transitions to read-only.
<p>
The <tt>IOC_WATCH_QUEUE_SET_FILTER</tt> <tt>ioctl()</tt> command must be
used to set the filter once the description is ready.  At that point,
events can be delivered into the circular buffer.
<p>
<h4>Receiving events</h4>
<p>
The buffer itself is defined with this structure:
<p>
<pre>
    struct watch_queue_buffer {
	union {
	    /* The first few entries are special, containing the
	     * ring management variables.
	     */
	    struct {
		struct watch_notification watch; /* WATCH_TYPE_SKIP */
		volatile __u32	head;		/* Ring head index */
		volatile __u32	tail;		/* Ring tail index */
		__u32		mask;		/* Ring index mask */
	    } meta;
	    struct watch_notification slots[0];
	};
    };
</pre>
<p>
The <tt>union</tt> setup may look a bit strange; it is designed so that the
<tt>meta</tt> information looks like a special type of event entry that
will be 
automatically skipped over by code reading through the buffer.  The
<tt>head</tt> index points to the first free slot (where the kernel will
write the next event), while <tt>tail</tt> points to the first available
event.  User space can adjust the <tt>tail</tt> pointer only.  If
<tt>head</tt> and <tt>tail</tt> are equal, the buffer is empty.
<p>
The actual events look like:
<p>
<pre>
    struct watch_notification {
	__u32			type:24;
	__u32			subtype:8;
	__u32			info;
    };
</pre>
<p>
The <tt>type</tt> and <tt>subtype</tt> fields describe the specific event;
<tt>info</tt> is rather more complicated, though, being made up of several
fields that must be masked to be used.  For example, events can take up
more than one slot in the buffer; masking with <tt>WATCH_INFO_LENGTH</tt>
yields the number of slots used.  Use <tt>WATCH_INFO_ID</tt> to get the
<tt>watch_id</tt> value provided when the event was requested.  Also
crammed into <tt>info</tt> are flags to indicate buffer overruns or lost
events, and a bunch of event-specific flags.  The <tt>info_filter</tt> in
the filter set up by user space can filter on most of the fields within
<tt>info</tt>.
<p>
Once all that is set up, it's just a matter of watching <tt>head</tt> and
<tt>tail</tt> (using appropriate barrier operations) to detect when there
are events in the structure to be consumed.  It is also possible to call
<tt>poll()</tt> on the buffer file descriptor to wait for new events to
arrive.
<p>
This is the first posting of this patch set, and the work is clearly still
changing quickly; this can be observed by noting that the API descriptions
in the changelogs are seemingly from a previous version and
do not match what the code actually implements.  Anybody
interested in how this API looks from user space can look at <a
href="/ml/linux-kernel/153235957887.32640.8025222191782276269.stgit@warthog.procyon.org.uk/">this
example program</a> included with the patch set.  About the only comment so
far has been <a
href="/ml/linux-kernel/675e5c24-36ef-4cc5-846c-1414c1195d85@schaufler-ca.com/">from
Casey
Schaufler</a>, who is concerned about how the mechanism interacts with
security modules and keeping users from receiving events that they
shouldn't.
<p>
These patches are clearly intended to create a general-purpose mechanism
that could be used throughout the kernel, so they will need a fair amount
of review before they can be accepted.  Changes seem likely.  If the
inevitable concerns can be addressed, Linux may yet have a general
event-notification mechanism, even if we'll never get <tt>kevent()</tt> and
<tt>kqueue()</tt>.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Events_reporting">Events reporting</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/760714/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor760852"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2018 20:07 UTC (Wed)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/760852/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What's wrong with netlink and a BPF filter?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760852/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor760857"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2018 20:27 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/760857/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Netlink and BPF?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760857/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor760856"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2018 20:32 UTC (Wed)
                               by <b>Lionel_Debroux</b> (subscriber, #30014)
                              [<a href="/Articles/760856/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd say that he doesn't want to tie this feature to others known for increasing the footprint and attack surface of the kernel. That's what I understand from his cover e-mail reproduced at <a href="https://lwn.net/Articles/760596/">https://lwn.net/Articles/760596/</a> : "Things I want to avoid: / (1) Introducing features that make the core VFS dependent on the network stack or networking namespaces (ie. usage of netlink)."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760856/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor760885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2018 23:31 UTC (Wed)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/760885/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, but if you follow that principle to its logical conclusion, you end up with zillions of tiny, unique interfaces for every bit of functionality. This interface is _supposed_ to be generic, but so was netlink. I'd still rather reuse the existing system event delivery approach instead of inventing another one and justifying the reinvention on the basis of surface area reduction or something. Consolidating interfaces decreases surface area even more!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor761237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2018 1:48 UTC (Mon)
                               by <b>ofranja</b> (subscriber, #11084)
                              [<a href="/Articles/761237/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
netlink depends on network support; it's not a question on how "generic" the interface is but about it's dependencies.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/761237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor761246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2018 7:02 UTC (Mon)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/761246/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it so unreasonable to require network support for this facility? We're not talking about support for TCP or routing or something --- just basic socket machinery. How many people who build weird kernels without networking support at all are going to use this new facility? Complicating an import kernel interfaces to maintain a false illusion of modularity is pointless.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/761246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor761325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2018 15:36 UTC (Mon)
                               by <b>ofranja</b> (subscriber, #11084)
                              [<a href="/Articles/761325/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One man's weird kernel is another man's Monday.<br>
<p>
Also, are you talking about "complicating" in comparison to what? Netlink? BPF may not be a bad idea for filtering events but netlink is not what I'd call a "simple" interface.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/761325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor761735"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2018 12:50 UTC (Fri)
                               by <b>dhowells</b> (subscriber, #55933)
                              [<a href="/Articles/761735/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One of the problems with netlink is that it is network-namespaced (which is what you want for networking configuration) but what I'm dealing with isn't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/761735/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor760879"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2018 22:52 UTC (Wed)
                               by <b>acarno</b> (subscriber, #123476)
                              [<a href="/Articles/760879/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For that matter, one might as well ask, "what's wrong with kqueue() and kevent()?"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760879/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor761130"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2018 18:16 UTC (Fri)
                               by <b>mskarbek</b> (guest, #115025)
                              [<a href="/Articles/761130/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One has asked ;)<br>
<a href="https://www.youtube.com/watch?v=l6XQUciI-Sc&amp;t=1h5m05s">https://www.youtube.com/watch?v=l6XQUciI-Sc&amp;t=1h5m05s</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/761130/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor760884"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2018 23:28 UTC (Wed)
                               by <b>jhoblitt</b> (subscriber, #77733)
                              [<a href="/Articles/760884/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Won't this result in an explosion of system calls that are fairly specific to implementation details?<br>
<p>
Also, how many systems have such a high rate of fs mounting (even including container hosts) that a ring buffer is necessary for performance?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760884/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor760912"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2018 8:30 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/760912/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The question is not whether mounting filesystems will ever happen so much that you need a ring buffer.<br>
<p>
It's whether this mechanism will ever be used for something that will happen so much that you need a ring buffer. The answer for that is "we don't know, and ring buffers are understood well enough that it's cheap to be ready".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760912/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor760913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2018 8:35 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/760913/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It would be nice to use it for general file event notifications.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor761062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2018 12:29 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/761062/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Before that's useful -- and before anything happens where overflows are possible and might be interesting -- it probably needs a bit in meta which is flipped on when the ring buffer overflows (i.e. head is right behind tail) so events may be lost. (The event is, obviously, flipped off only by userspace, since only it knows how and when to respond to an overflow notification.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/761062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor760894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2018 0:46 UTC (Thu)
                               by <b>markh</b> (subscriber, #33984)
                              [<a href="/Articles/760894/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      As documented in <a href="http://man7.org/linux/man-pages/man5/proc.5.html">proc(5)</a> it is already possible to detect mount changes using select(), poll(), or epoll_wait() on /proc/mounts, so that seems like an odd justification for a whole new notification system.  This existing mechanism is also much simpler, and could be extended to support change notification for any information available via /proc or /sys with no new system calls or structures.
      
          <div class="CommentReplyButton">
            <form action="/Articles/760894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor760897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2018 2:40 UTC (Thu)
                               by <b>rvolgers</b> (guest, #63218)
                              [<a href="/Articles/760897/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is that file resilient against space and newline injection yet? The documentation doesn't say anything about an escaping scheme for the root and mount point paths.<br>
<p>
With unprivileged mounting becoming more of a thing with user namespaces this seems like something that should be considered.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor760911"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2018 8:11 UTC (Thu)
                               by <b>TheJH</b> (subscriber, #101155)
                              [<a href="/Articles/760911/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
see here: <a href="https://elixir.bootlin.com/linux/latest/source/fs/proc_namespace.c#L98">https://elixir.bootlin.com/linux/latest/source/fs/proc_na...</a> - space, newline, tab and backslash are escaped in both device name and mount point.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760911/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor761336"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2018 6:17 UTC (Tue)
                               by <b>fsateler</b> (subscriber, #65497)
                              [<a href="/Articles/761336/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with this is that you need to reparse the whole mount table. This is both racy (because the mount table might hace changed between the change and you parsing it) and expensive (if the mount table is large enough).  See [1] for an example where this turns into a practical problem.<br>
<p>
<p>
[1] <a href="https://github.com/systemd/systemd/issues/8703">https://github.com/systemd/systemd/issues/8703</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/761336/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor761338"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2018 12:11 UTC (Tue)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/761338/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      If textual representation of 'the mount table' changes while its being read, this would be a kernel bug. There's no way to fix the TOCTOU race as any event notification must always happen after an event has occurred and could be stale by the time it's being processed. As to 'the time needed to parse the mount table', a Perl script (included below) can read that (using Perl I/O) with a CPU usage of 1s per 9,478,310.72 bytes (9M) and parse it with a CPU usage of 1s per 24,004,852.17 bytes (23M).
<p/>
Ergo: This is not a problem except in very peculiar circumstances (size of /proc/mounts &gt; 69M and frequently changing).
<p/>
systemd accumulating zombies in such a situation is a design problem/ feature of the program and could be fixed if considered important enough (eg, by using 2nd program, daring as the idea might seem).

<pre>
use Benchmark;

my ($total);

timethese(-3,
          {
           mounts =&gt; sub {
               my $fh;
               my @a;

               open($fh, '&lt;', '/proc/mounts');
               for (&lt;$fh&gt;) {
                   $total += length;
                   push(@a, [split ' ']);
               }
           }});

print STDERR ($total, "\n");
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/761338/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor761376"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2018 16:08 UTC (Tue)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/761376/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Out of curiosity, I've created the following, useless /proc/mounts parser in C:

<pre>
#include &lt;fcntl.h&gt;
#include &lt;mntent.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/poll.h&gt;
#include &lt;unistd.h&gt;

int main(void)
{
    struct pollfd pfd;
    struct mntent *mnt;
    FILE *fp;

    pfd.fd = open("/proc/mounts", O_RDONLY, 0);
    pfd.events = POLLPRI;
    fp = fdopen(pfd.fd, "r");
    do {
        while ((mnt = getmntent(fp)));
        lseek(pfd.fd, 0, 0);
        poll(&amp;pfd, 1, -1);
    } while (1);

    return 0;
}
</pre>

and tested that together with the following script (christianed terror-mount)

<pre>
#!/bin/sh
#

mnt()
{
    while true;
    do
        ( dir=`mktemp -d`
            sudo mount -o bind /usr/bin $dir
            sleep 1
            sudo umount $dir
            rmdir $dir ) &amp;
        wait
    done
}

max=1000
while test $max -gt 0;
do
    mnt &amp;
    max=`expr $max - 1`
done

while true;
do
    sleep 10
done
</pre>
<p/>
<strong>DO NOT TRY THIS</strong>
<p/>
This causes the system to spend almost all of its CPU time in the kernel while the /proc/mounts parser ends up being starved of cycles.
      
          <div class="CommentReplyButton">
            <form action="/Articles/761376/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor761736"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 3, 2018 13:20 UTC (Fri)
                               by <b>dhowells</b> (subscriber, #55933)
                              [<a href="/Articles/761736/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unfortunately, the current interface can lose events quite easily.  Imagine that you're a process monitoring /proc/mounts with select(): you get an event and wake up.  You then have to parse the contents of the file, but since you're no longer selecting you don't know if another event happens whilst you're doing the parse.  So now you need to do another parse to find out the answer to that (or you could also a select in another thread).  What you really need is an event counter somewhere - one that you pass to select() or get back from select().<br>
<p>
Also, it just tells you something changed, but not necessarily what.  It also doesn't tell you about superblock-level events such as EIO, EDQUOT and ENOSPC or tell you about keyring events.  What I tried to do is make an event mechanism that can be used for anything and where the buffer could be shared by a disparate set of sources simultaneously.<br>
<p>
Note also: every time you read /proc/mounts, you hold a global lock and thereby prevent *all* mount topology changes for the duration.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/761736/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor761808"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2018 5:15 UTC (Sat)
                               by <b>tao</b> (subscriber, #17563)
                              [<a href="/Articles/761808/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmmmm, so does that mean that an unprivileged user can DOS any mount operations by opening /proc/mounts and doing a partial read?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/761808/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor761814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A kernel event notification mechanism</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2018 10:55 UTC (Sat)
                               by <b>markh</b> (subscriber, #33984)
                              [<a href="/Articles/761814/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting. Would the event loss be solved by using EPOLLONESHOT?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/761814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
