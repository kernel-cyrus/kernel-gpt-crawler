        <!DOCTYPE html>
        <html lang="en">
        <head><title>Better handling of integer wraparound in the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/959189/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/959458/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/959189/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Better handling of integer wraparound in the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>January 26, 2024</br>
           </div>
While the mathematical realm of numbers is infinite, computers are only
able to represent a finite subset of them.  That can lead to problems when
arithmetic operations would create numbers that the computer is unable to
store as the intended type.  This condition, called "overflow" or
"wraparound" depending on the 
context, can be the source of bugs, including unpleasant security
vulnerabilities, so it is worth avoiding.  <a
href="/ml/linux-kernel/20240122235208.work.748-kees@kernel.org/">This patch
series</a> from Kees Cook is intended to improve the kernel's handling of
these situations, but it is running into a bit of resistance.
<p>
Cook starts by clarifying the definitions of two related terms:
<p>
<ul class="spacylist">
<li> <b>Overflow</b> happens when a signed or pointer value exceeds the
     range of the variable into which it is stored.
<li> <b>Wraparound</b> happens, instead, when an unsigned integer value
     exceeds the range that its underlying storage can represent.
</ul>
<p>
This distinction is important.  Both overflow and wraparound can create
surprises for a developer who is not expecting that situation.  But
overflow is considered to be undefined behavior in C, while wraparound is
defined.  As a result, overflow brings the possibility of a different kind
of surprise: since it is undefined behavior, compilers can feel free to
delete code that handles overflow or apply other unwelcome optimizations.
To avoid this outcome, the kernel is built with the
<tt>-fno-strict-overflow</tt> option, which essentially turns (undefined)
overflow conditions into (defined) wraparound conditions.
<p>
So, in a strict sense, overflows do not happen in the kernel, but
wraparounds do.  If a wraparound is intended, as is often the case in the
kernel (see <a
href="https://elixir.bootlin.com/linux/v6.7.1/source/net/ipv4/route.c#L457"><tt>ip_idents_reserve()</tt></a>,
for example), then all is fine.  If the developer is not expecting
wraparound, though, the results will not be so good.  As a result, there
is value in using tooling to point out cases where wraparound may happen â€”
but only the cases where it is not intended.  A wraparound detector that
creates a lot of false-positive noise will not be welcomed by developers.
<p>
In the past, the tooling, in the form of the <a
href="https://docs.kernel.org/dev-tools/ubsan.html">undefined behavior
sanitizer (UBSAN)</a> and the GCC <tt>-fsanitize=undefined</tt> option, has
indeed generated false-positive warnings.  As a result, this checking was
<a href="https://git.kernel.org/linus/6aaa31aeb9cf">disabled</a> for the
5.12 release in 2021 and has remained that way ever since.  Cook is now
trying to re-enable UBSAN's wraparound checking and make it useful; the
result was an 82-part patch set making changes all over the kernel.
<p>
The key to making this checker useful is to prevent it from issuing
warnings in cases where wraparound is intended.  One way to do that is to
explicitly annotate functions (generally of the small, inline variety) that
are expected to perform operations that might wrap around and that handle
that situation properly.  The <tt>__signed_wrap</tt> and
<tt>__unsigned_wrap</tt> annotations have been <a
href="/ml/linux-kernel/20240123002814.1396804-6-keescook@chromium.org/">duly
added</a> for this purpose; they work by disabling the checking of
potential wraparound conditions in the marked function.
<p>
The most common place where intentional wraparound is seen, though, is in
code that is intended to avoid just that behavior.  Consider <a
href="https://elixir.bootlin.com/linux/v6.7.1/source/mm/mmap.c#L3039">this
code</a> in the implementation of the <a
href="https://man7.org/linux/man-pages/man2/remap_file_pages.2.html"><tt>remap_file_pages()</tt></a>
system call:
<p>
<pre>
    /* Does pgoff wrap? */
    if (pgoff + (size &gt;&gt; PAGE_SHIFT) &lt; pgoff)
	return ret;
</pre>
<p>
Normally, the sum of two unsigned values will be greater than (or equal to)
both of those values.  Should the operation wrap around, though, the
resulting value will be <i>less</i> than either of the addends.  As a
result, wraparound can be reliably detected with a test like the above.
It is worth noting, though, that this test detects wraparound by causing
it to happen; wraparound is an expected result that is properly handled.
<p>
To a naive wraparound detector, though, that code looks like just the sort
of thing it is supposed to issue warnings about.  The resulting noise makes
such a detector useless in general, so something needs to be done.  In this
case, Cook adds a pair of macros to explicitly annotate this type of code:
<p>
<pre>
    add_would_overflow(a, b)
    add_wrap(a, b)
</pre>
<p>
The first returns a boolean value indicating whether the sum of the two
addends would wrap around, while the second returns that sum, which may have
wrapped around.  These macros are built on the kernel's existing <a
href="https://elixir.bootlin.com/linux/v6.7.1/source/include/linux/overflow.h#L54"><tt>check_add_overflow()</tt></a>
macro which, in turn, uses the compiler's <a
href="https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html"><tt>__builtin_add_overflow()</tt></a>
intrinsic function.  Using these, the above <tt>remap_file_pages()</tt>
test is <a
href="/ml/linux-kernel/20240123002814.1396804-63-keescook@chromium.org/">rewritten</a>
as:
<p>
<pre>
    /* Does pgoff wrap? */
    if (add_would_overflow(pgoff, (size &gt;&gt; PAGE_SHIFT)))
 	return ret;
</pre>
<p>
This code now clearly does not risk an unwanted wraparound, and so no
longer triggers a warning.  The patch set rewrites a large number of these
tests throughout the kernel.  Along the way, Cook also had to <a
href="/ml/linux-kernel/20240123002814.1396804-1-keescook@chromium.org/">enhance
<tt>check_add_overflow()</tt></a> to handle pointer arithmetic so that
pointer additions can be easily checked as well.
<p>
With all of this work in place, it is possible to turn on wraparound
checking in UBSAN again.  Eventually, the warnings generated should be
accurate enough that it can be used to detect code that is not written with
wraparound in mind.

First, though, this work has to find its way into the mainline.  In the
best of times, a series that changes over 100&nbsp;files across the kernel
tree is going to be challenging to merge, though Cook has gotten fairly
good at that task.
<p>
A more difficult challenge may be the <a
href="/ml/linux-kernel/CAHk-=whS7FSbBoo1gxe+83twO2JeGNsUKMhAcfWymw9auqBvjg@mail.gmail.com/">opposition</a>
expressed by Linus Torvalds.  He complained that the changelogs do not
properly describe the changes that are being made, that the new annotations
cause the compiler to generate less-efficient code, and that the tooling
should recognize wraparound tests in the above form without the need for
explicit annotation: "<q>if there's some unsigned wraparound checker that
doesn't understand this traditional way of doing overflow checking, that
piece of crap needs fixing</q>".  He <a
href="/ml/linux-kernel/CAHk-=wgMPVv-mDxA2qcywpLCRLojtaKmP13h7bVo4m=XN202xA@mail.gmail.com/">added</a>
some conditions for merging these changes.
<p>
Cook <a
href="/ml/linux-kernel/202401231058.5C5248DC3@keescook/">answered</a> that
he would rewrite the changelogs, which was one of the things Torvalds
demanded.  Another one of those demands â€” "<q>fix the so-called
'sanitizer'</q>" â€” might prove to be a bit more challenging, since it will
require work on the compiler side.  The advantage of such a fix is clear;
it would remove the need for hundreds of explicit annotations in the
kernel.  But that would come at the cost of delaying this work and dealing
with the bugs that enter the kernel in the meantime.
<p>
The history of the hardening work in the kernel suggests that these little
obstacles will indeed be overcome in time and that the kernel will
eventually be free of wraparound bugs (or close to that goal, anyway).  Of
course, as Kent Overstreet took pains to <a
href="/ml/linux-kernel/337u2jcp3s2vrvotj4jppgpr7zas5fod6k3mhe263ghpux7s5x@knz6eibm2jis/">point
out</a>, this work would not be necessary if the kernel would just take the
minor step of switching to Rust.  Cook <a
href="/ml/linux-kernel/4DE92BD2-50FE-4634-ACF3-E0CC735EDAEB@kernel.org/">answered</a>
that any such change is not happening soon, so he will continue his work of
"<q>removing as many C foot-guns as possible</q>".  As this work is wrapped
up, the result should be a more stable and secure kernel for all of us.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Kernel_hardening">Security/Kernel hardening</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-Hardening">Linux kernel/Hardening</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/959189/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor959673"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2024 17:48 UTC (Fri)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/959673/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Using size_t is obvious mistake. It should be<br>
<p>
__builtin_add_overflow_p(a, b, (typeof(0 ? a : b))0)<br>
<p>
?<br>
<p>
This whole overflow.h file feels like a loss in readability. Before you could read<br>
<p>
s = kmalloc(sizeof(struct S) + n * sizeof(u32), GFP_KERNEL);<br>
<p>
and immediately see that it is struct S is being allocated and has arbitrary length array at the end without even seeing definition.<br>
Now it is 3 identifiers, all looking equal at first glance.<br>
<p>
And of course people find a way to around SIZE_MAX:<br>
<p>
net/wireless/scan.c:<br>
<p>
request = kzalloc(struct_size(request, channels, n_channels) +<br>
                          sizeof(*request-&gt;scan_6ghz_params) * count +<br>
                          sizeof(*request-&gt;ssids) * rdev_req-&gt;n_ssids,<br>
                          GFP_KERNEL);<br>
<p>
----------------------<br>
What about "s = kmalloc([[sizeof(struct S) + n * sizeof(u32)]], GFP_KERNEL);"?<br>
<p>
Everything inside [[]] is automatically checked for overflows.<br>
<p>
Why I am not a programming language designer?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959673/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 16:17 UTC (Sat)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/959733/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Using size_t is obvious mistake.</span><br>
<p>
In "overflow: Expand check_add_overflow() for pointer addition"? Where exactly?<br>
<p>
<span class="QuotedText">&gt; __builtin_add_overflow_p(a, b, (typeof(0 ? a : b))0)</span><br>
<p>
clang does not seem to have that builtin.<br>
<p>
Why do you use `typeof(0 ? a : b)` instead of `typeof(a + b)` ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor960249"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2024 14:41 UTC (Wed)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/960249/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wrote a Smatch check for the net/wireless/scan.c code.<br>
<p>
net/wireless/scan.c:882 cfg80211_scan_6ghz() warn: using integer overflow function 'size_add()' for math<br>
<p>
I had 110 warnings on my test on linux-next last night.  The problem I ran into is that people like the struct_size() macro and use it for readability even when they aren't concerned about integer overflows.  So a lot of the warnings are false positives in the sense that the code math won't overflow.  (It could also be that people didn't choose struct_size() for readability, but it was part of a mass conversion to struct_size()).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960249/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor961757"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2024 18:18 UTC (Sun)
                               by <b>Hi-Angel</b> (guest, #110915)
                              [<a href="/Articles/961757/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Why I am not a programming language designer?</span><br>
<p>
That's not really fair regarding C. C is an ancient language, which was designed when there was very little understanding in what's good or bad. For example, it is these days that we know that 90% of values inside a function are immutable, so everything should be constant by default with "mutability" being an opt-in. So now that we know that, it is implemented in Rust.<br>
<p>
However, if you were a programmer working on this in â‰ˆ1989, you wouldn't know about any of this. I think it's fair to presume that C was designed to the best of the knowledge of its time. It's just we know more than the people living back then.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/961757/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor961758"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2024 18:35 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/961758/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Go back a bit from 1989 - C's development starts in 1972, and the first K&amp;R book is 1978. But, as with most languages, C was not cutting-edge for its day; there's nothing in C that wasn't well-understood for the decade or so before development started, and (as you'd expect) some of C's features are things that PL research knew to be bad by 1978.
<p>This is not exactly surprising; Rust doesn't take much, if anything, from post 1990s research, despite being a 2015 language release whose development started in 2006. At least in part, this happens because most people have seen and agree on the status of older work; newer work relies on people first noticing it, and then pushing it to their development community.


      
          <div class="CommentReplyButton">
            <form action="/Articles/961758/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor959679"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2024 19:32 UTC (Fri)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/959679/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder if it would be possible to get an operator into C that would take an expression without side effects and return true if it would overflow and false otherwise. Having it be an operator (like typeof) would mean that (from the point of view of C and the compiler) you're not evaluating the expression, so it's not UB, and the compiler would be able to optimize the case where, if the operator returns false, you do evaluate the expression, and also makes it easier to optimize overflow checks in general (since the optimal assembly doesn't actually do the inequality test the programmer wrote, but looks at the overflow flag after the addition).<br>
<p>
The program would still have to duplicate the expression, but at least it would be easy to have a warning if they don't match.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959679/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959781"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 10:18 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/959781/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>There's already <a href="https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html">a perfectly usable builtin</a> that does exactly that.</p>

<p>Adding new operator would be useful only if it would be shown that built-in is not enough.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/959781/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor959697"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 26, 2024 22:01 UTC (Fri)
                               by <b>rywang014</b> (subscriber, #167182)
                              [<a href="/Articles/959697/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's always better for the code to provide its intent to the compiler/detector, instead of letting the poor programs to *guess* if this is intentional test for overflow, or an accidental overflow. Just like `[[fallthrough]]`.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959697/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 4:32 UTC (Sat)
                               by <b>magfr</b> (subscriber, #16052)
                              [<a href="/Articles/959711/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I agree but if we somehow could start over fallthrough should really be a keyword and break before nonempty case should be implicit.

<pre>switch (X) {
case 0:
    // implicit fallthrough 
case 1:
    something;
    // implicit break
case 2:
    something;
    /* explicit */ fallthrough; 
case 3:
    something;
    /* explicit */ break;
case 4;
    something;
}</pre>




      
          <div class="CommentReplyButton">
            <form action="/Articles/959711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor961141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2024 8:19 UTC (Wed)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/961141/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why? Then if you meant to fall through but omitted the keyword, it would look like you intended to break. The same problem, but in reverse. <br>
<p>
Normal labels don't have implicit breaks before them. Why would case labels?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/961141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor961411"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2024 19:51 UTC (Thu)
                               by <b>mosfet_</b> (guest, #134203)
                              [<a href="/Articles/961411/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Given the history of C, I think we'd need to go further. <br>
<p>
case 0 - implicit fallthrough can be assumed for multiple empty case statements <br>
case 1 - should be a compiler error on ambiguous switch statement - should not assume break or fallthrough<br>
case 2 - ok due to new explicit keyword fallthrough;<br>
case 3 - ok due to explicit break;<br>
case 4 - ok due to fallthrough and break having identical behavior in the final case statement<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/961411/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor959703"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 0:21 UTC (Sat)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/959703/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; if (pgoff + (size &gt;&gt; PAGE_SHIFT) &lt; pgoff)</span><br>
<p>
I never understood why people keep doing those intentional overflows in such checks, when the check can simply be rewritten without any overflow at all, in which case any overflow semantics (be it UB or wrapping) simply would not matter.<br>
<p>
In this case what we intend to check for is essentially this:<br>
<p>
<span class="QuotedText">&gt; if (pgoff + (size &gt;&gt; PAGE_SHIFT) &gt; SIZE_MAX)</span><br>
<p>
Of course, that would only have worked if the left-hand expression wouldn't overflow, but we can rewrite it by moving the `(size &gt;&gt; PAGE_SHIFT)` part of the left-hand expression to the right-hand expression, given that it's never larger than the right-hand expression, using the simple math rule `a + b = c &lt;=&gt; a = c - b`:<br>
<p>
<span class="QuotedText">&gt; if (pgoff &gt; SIZE_MAX - (size &gt;&gt; PAGE_SHIFT))</span><br>
<p>
This check will never overflow (nor underflow, assuming `(size &gt;&gt; PAGE_SHIFT)` has the maximum of `SIZE_MAX`), will compile no matter the compiler options, and won't trigger any sanitizers.<br>
<p>
There's a couple of things to mention:<br>
<p>
* Sure, it might be harder to read for some people, but a comment could be left suggesting moving part of the rhs back to the lhs to understand the intention. And honestly, I think it is less cryptic than the original, at least from the mathematical point of view;<br>
<p>
* Here we assume `pgoff` and `size` are `size_t`, an assumption not required in the original check. If we're unwilling to have such an assumption, we could define a macro to get the right maximum value depending on the expression, or even add an all-encompassing macro to check for an overflow when two expressions are being added. In any case, I think simply avoiding an overflow in the first place is a much-much cleaner way to go.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959703/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959706"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 1:02 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959706/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C23 will finally introduce checked integer arithmetic functions in the stdlib. It's about 20+ years too late, but at least it's here now... I would suggest either using that or using one of the __builtin implementation-defined equivalents (you can use preprocessor magic to figure out what's available and wrap it in a macro).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959706/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959783"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 10:24 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/959783/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; you can use preprocessor magic to figure out what's available and wrap it in a macro</font>

<p>Why would you need to do that? Minimum GCC version supported by kernel is <a href="https://www.kernel.org/doc/html/next/process/changes.html">GCC 5.1</a>, all the required functions are <a href="https://gcc.gnu.org/onlinedocs/gcc-5.1.0/gcc/Integer-Overflow-Builtins.html#Integer-Overflow-Builtins">already in that version</a>.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/959783/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959813"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 2:02 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959813/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It depends on whether you want to support compilers other than GCC. I'm not sure if they all spell the intrinsic the same. I believe people have at least been looking into compiling the kernel with clang...?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959813/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959829"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 9:18 UTC (Mon)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/959829/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>They threatened to <a href="https://discourse.llvm.org/t/inline-asm-asm-goto-supporting-asm-goto-in-inline-assembly/44429/16">drop support for clang if clang wouldn't implement some obscure GCC feature</a> and yet wouldn't use some easily implementable (and actually implemented) function?</p>

<p>Hard to believe, sorry.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/959829/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 20:13 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959920/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Hard to believe, sorry.</span><br>
<p>
And you see folks, this is why I'm so reluctant to comment on LWN (or any other technical forum). I throw in a parenthetical to cover a case I'm not sure about, and get grilled about it in the replies, even though it was utterly tangential to my actual point.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959955"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Not just what one has to say, but how one chooses to say it</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2024 8:49 UTC (Tue)
                               by <b>sdalley</b> (subscriber, #18550)
                              [<a href="/Articles/959955/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Please don't go away, NYKevin. Your contributions are greatly appreciated by me and I'm sure many others. Highly knowledgeable without being condescending, able to bring another side without being contentious or wanting to always prove oneself right and get in the last word.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959955/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor959964"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 30, 2024 11:22 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/959964/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Seconded. Don't go away. What matters imho is you're well known, and you have a good reputation. If you're happy keeping a low profile, fine.<br>
<p>
Just do what I do - get to know people by their nym. Plenty of people here think I'm brilliant - plenty also think I'm an idiot! I've had a lot of people tell me I'm "the voice of reason". I chose Wol for other reasons, but as the Owl who's not as clever as he thinks he is, he seems rather appropriate. Personally, I think I'm a damn good high-level analyst, I tend to struggle with the details but I can spot design flaws a mile off!<br>
<p>
And then - it had to be Khim, didn't it ... personally, I respect him, our views are very similar about the *societal* effects around us. Him more than me, but I think we both get a bit dogmatic - and then sparks fly - Sorry Jon!<br>
<p>
But no, this is a society like anywhere else. Some people keep their heads down, some are flamboyant, some just like to sit in the corner dispensing wisdom. That last sounds like you. Just try to learn who is not worth talking to, and don't respond to them. And then they might come up with an absolute gem ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959964/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor959714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 5:36 UTC (Sat)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/959714/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I never understood why people keep doing those intentional overflows in such checks, when the check can simply be rewritten without any overflow at all, in which case any overflow semantics (be it UB or wrapping) simply would not matter.</span><br>
<p>
Using SIZE_MAX is slightly less efficient (unless compiler recognizes this idiom too and moves operands back :-).<br>
<p>
vsnprintf() does the following:<br>
<p>
char* str = buf;<br>
char* end = buf + len;<br>
if (end &lt; buf) { end = -1; len = end - buf; }<br>
<p>
and it makes sense because you have to calculate "end" anyway.<br>
<p>
For unsigned types, overflowing can't break the computer, so it simpler and faster in the assembly to just do it and compare the results.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959791"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 10:57 UTC (Sun)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/959791/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Using SIZE_MAX is slightly less efficient (unless compiler recognizes this idiom too and moves operands back :-).</span><br>
<p>
It does. At least, gcc and clang produce the same code for `a + b &lt; a` and `a &gt; UINT_MAX - b`  starting with `-O1`. On x86_64 they just add a and b and look or carry in both cases.<br>
<p>
It can be seen as a disadvantage of the second variant that it only works for unsigned types. It doesn't work analogously for signed types, because `INT_MAX - b` underflows for `b == INT_MIN`. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959791/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 2:09 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959816/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
INT_MAX - b overflows for all negative b, not just INT_MIN. The ideal way to do this is with the compiler intrinsics or stdchkdint.h (C23). If you insist on doing it with regular arithmetic, then a + b never overflows for positive a and negative b (or vice-versa), nor will overflow happen if either operand is zero, so you can write some godawful nested ternary expression to check for the four possible cases (both positive, both negative, signs differ, either operand is zero) and hope the compiler is smart enough to understand what you are doing.<br>
<p>
But don't actually do that. Just use the intrinsic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959824"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 6:29 UTC (Mon)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/959824/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; INT_MAX - b overflows for all negative b, not just INT_MIN</span><br>
<p>
Correct. Thanks for pointing that out!<br>
<p>
<span class="QuotedText">&gt; But don't actually do that. Just use the intrinsic.</span><br>
<p>
Agreed. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959824/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor959708"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 2:31 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/959708/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's problematic that C's weird choice has somehow infected people's discourse as though this is just "how it works" rather than a weird choice in the C programming language. Rust's integers don't magically have different behaviour depending on whether they're signed, if you want a wrapping 64-bit signed integer type that is named Wrapping&lt;i64&gt; just as the unsigned one is Wrapping&lt;u64&gt;. In most cases you actually want wrapping (or some other overflow behaviour) only for some singular operation, and in this case you can write what you meant, if I have two 64-bit signed integers called "offset" and "length" and I actually mean to add them together such that the result wraps at the edge of the range (which is weird, but whatever) offset.wrapping_add(length) explains what I intended and works.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959708/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 4:00 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959710/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect this is the fault of the PDP-11 and such. At the time, the notion that the compiler would just emit extra instructions for a simple add would have been seen as extravagant. If you wrote +, you got whatever behavior the architecture provided (in practice, this meant wrapping for unsigned and ðŸ¤· for signed). If the architectures of the time would've provided separate wrapping, saturating, and faulting instructions for addition, then they probably would have added all three as primitives. Of course, that would've been a very different design compared to what was actually being done at the time, and I'm sure the OEMs had valid reasons for not (consistently) providing such instructions.<br>
<p>
Nowadays we have the "abstract machine" and such affordances, so it's no longer seen as surprising that + might compile into something other than an add instruction. So you could also say this is K&amp;R's fault for designing C too close to the metal. But hey, hindsight is 20/20.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959718"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 5:49 UTC (Sat)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/959718/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think you can blame the PDP-11 here. It had a standard set of NZVC bits and used twos complement arithmetic. Instead, blame ANSI. In trying to specify a language that would run on ones-complement and sign-magnitude machines, they made overflow UB and now we all suffer.<br>
<p>
So I'd blame the CDC-6600 although you can blame the PDP-1 or LINC if you're determined to make DEC the bad guy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959718/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor959716"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 5:45 UTC (Sat)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/959716/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;Wrapping&lt;i64&gt;</span><br>
<p>
Wrapping signed integers is a funny thing by itself.<br>
<p>
I'd argue that Algebraic Types Party doesn't do _that_ better because overflowing/saturating is property of an operation not a type.<br>
<p>
In a perfect world Rust would invent new syntax for "unsafe" additions/multiplications. Cryptographers would use it and everyone else would use regular + which traps.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959716/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 8:30 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959720/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; In a perfect world Rust would invent new syntax for "unsafe" additions/multiplications. Cryptographers would use it and everyone else would use regular + which traps.</span><br>
<p>
Rust already did that. They're simple method calls on the primitive integer types (e.g. wrapping_add, saturating_sub, checked_div, etc.). Wrapping&lt;T&gt; etc. types are for cases where you want to override what + does (because writing wrapping_add all the time is obnoxious). If you want to manually spell out the operation every time, you can do that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959722"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 9:10 UTC (Sat)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/959722/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, they added wrapping_add() and friends, it's lengthy and wordy.<br>
<p>
I'm thinking more about "a [+] b" for unsafe addition , etc<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959722/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959730"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 15:36 UTC (Sat)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/959730/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I dunno, it seems like these should be rare, which makes it ok if theyâ€™re lengthy and good that the existence of that code construct is well advertised.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959730/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor959759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 22:50 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959759/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with overflow modes is that there are so many to choose from! Rust provides at least the following:<br>
<p>
* carrying_add(): A helper method for implementing bignum addition. There's also borrowing_sub() for subtraction. Probably not useful for general-purpose addition.<br>
* checked_add(): Returns an Option&lt;T&gt; which is None if overflow would happen. Nicely compatible with the question mark operator, match, if let, etc. constructs.<br>
* overflowing_add(): Returns the result of wrapping_add() as well as a bool indicating whether we overflowed.<br>
* saturating_add(): Returns (the Rust equivalent of) INT_MAX when we overflow.<br>
* unchecked_add(): Overflow is undefined behavior. Can only be called in an unsafe block (or unsafe function).<br>
* wrapping_add(): Wraps around using two's complement (signed) or modular arithmetic (unsigned).<br>
<p>
You could, hypothetically, have a menagerie of different symbols for all of these different use cases, but it's going to look like Perl or APL very quickly. You could, I suppose, pick one of them as the "best" overflow mode and just give that a symbol, but I guarantee you it won't be unchecked_add() as your comment seems to suggest (they are never adding a binary operator that can only be used in unsafe blocks). The more flexible option is picking which mode you "usually" want to use, and using the Wrapping&lt;T&gt; etc. types for that.<br>
<p>
One thing that does bother me is the fact that overflowing_add() returns a tuple instead of some kind of ADT wrapper. That would force you to explicitly destructure it and handle both the wrapping and non-wrapping cases. With a tuple, you can forget to check the bool in some code paths. It's not really a disaster because you probably won't have overly elaborate code surrounding the callsite, but it's still an opportunity for things to go wrong.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 8:13 UTC (Sun)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/959773/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In my ideal language there would also be cannot_overflow_add() which checks at compile time overflow is impossible. It would need bounded integer types like those in Ada. You can achieve something like this with template metaprogramming in C++ but I think it important enough to be part of the language. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 10:35 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/959786/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; It would need bounded integer types like those in Ada.</font>

<p>Useless, pointless and not at all helpful in real code.</p>

<font class="QuotedText">&gt; In my ideal language there would also be cannot_overflow_add() which checks at compile time overflow is impossible.</font>

<p>That's what <a href="https://github.com/google/wuffs">Wuffs</a> does.</p>

<p>Turning that into general-purpose language with pervasive <a href="https://en.wikipedia.org/wiki/Dependent_type">dependent typing</a> is surprisingly hard.</p>

<p>Maybe someone would manage to do that 10 or 20 years down the road.</p>

<font class="QuotedText">&gt; You can achieve something like this with template metaprogramming in C++ but I think it important enough to be part of the language.</font>

<p>No, you can not. The only thing you may achieve with templates are some statically-defined checks and these are not much useful for real programs with dynamically allocated externally-specified objects. And kernel is full of these.</p>

<p>You may also reject C++ entirely and built entirely separate language where <b>every type</b> would be your own template type and <b>everything</b> is done using these, but at this point you are firmly in the â€œpseudo-language written in C++ templatesâ€ and it's better to just create a separate language than pretending you are still dealing with C++.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/959786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959795"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 11:26 UTC (Sun)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/959795/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Iâ€™ve written a toy C++ template library that provides a bounded&lt;n,m&gt; type (guaranteeing n &lt;= x &lt; m) with the basic arithmetic operations yielding the bounds youâ€™d expect. Then explicit coercion with a run time check for creating a bounded type from an ordinary int, or for narrowing the bounds.<br>
<p>
Useful in practice? Perhaps not much. My concern was more about eliminating logic errors (and making explicit the places overflow can occur), rather than memory safety. The common style nowadays is to avoid arbitrary limits. Users would not be happy if grep had a maximum line length of 2000 characters.  But in the real world you can usually put a bound on things: no aeroplane carries more than ten thousand passengers and no person is aged over two hundred. Ada does not have bounded integers purely out of design by committee. In the end your integer types will have a bound, like it or not, and forcing the programmer to consider it explicitly can be helpful. <br>
<p>
So yes, I do agree with your comment. You canâ€™t realistically retrofit bounded integers into C++ given the amount of existing code; and with everything dynamically allocated (rather than static fixed size buffers) they are not that useful for memory safety. Carrying a full proof of allowed bounds alongside each variable requires more cleverness than compilers have (although even a system that required numerous â€œtrust meâ€ annotations might have its uses). I was blue-skying about my ideal language rather than proposing a practical change to an existing language or codebase.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959795/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959798"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 12:01 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/959798/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; But in the real world you can usually put a bound on things</font>

<p>No, you couldn't. Even if limit sounds sane today it would be, most definitely, be too small tomorrow.</p>

<p>Maybe embedded may work with precomputed limits, but every time I saw <code>TeX</code> there was always <code>hugeTeX</code> for people who need more or <i>something</i>.</p>

<p>Beyond certain program complexity using arbitrary limits is not useful and below that limit using them is not too helpful.</p>

<p>That's why I said such types are useless and pointless: where they are useful (small programs, limited scale) they are pointless, where they could be beneficial (large programs, complicated logic, data comes from outside) they are not useful.</p>

<font class="QuotedText">&gt; But in the real world you can usually put a bound on things: no aeroplane carries more than ten thousand passengers and no person is aged over two hundred.</font>

<p>And then someone tries to use you program for a cruise ship or tries to enter data about three hundreds years <a href="https://en.wikipedia.org/wiki/Juridical_person">Juridical person</a> and everything explodes.</p>

<p>Thanks, but no, thanks.</p>

<font class="QuotedText">&gt; Ada does not have bounded integers purely out of design by committee.</font>

<p>It does have them because ALGOL and Pascal have them. But they are not much useful in any of these languages.</p>

<p>Perhaps they were useful when they were invented and when programs were written once, run once and then discarded. But today we are not writing programs in such fashion and arbitrary static limits cause more harm than good.</p>

<font class="QuotedText">&gt; I was blue-skying about my ideal language rather than proposing a practical change to an existing language or codebase.</font>

<p>And I was thinking about practical applicability instead. I'm pretty sure with enough automation proof-carrying code may be pretty usable, but for now are stuck with Rust and that was right choice: lifetime tracking causes significantly more grief than out-of-bounds access.</p>

<p>Perhaps after Rust would become the â€œnew Câ€ we may start thinking about dependent types. They need to have lifetime tracking as their basis, anyway, or else they wouldn't be much useful in practice, thus Rust made the right choice.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/959798/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959800"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 12:15 UTC (Sun)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/959800/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's the "everything explodes" scenario I am trying to avoid.  By having the bounds explicit and tracked at every use, the program will reject the value of twenty thousand passengers when that value is first entered.  TeX is an example of an old program written in a fixed-allocation style when dynamic would nowadays be considered better.  Nobody is doing safety-critical embedded systems running typesetting with hard real-time constraints, or hardening their TeX macros against an attacker.  But then for embedded applications, as you mention, you may need to set an upper bound on memory usage or require that no dynamic allocation and freeing happens.<br>
<p>
Airline passenger management is a kind of middle ground between these two.  It's not in itself safety-critical and doesn't need to run on tiny systems.  But then, it does need to interact with parts of the real world that have fixed limits.  Perhaps the passenger number is at most three digits long, or the dot-matrix printer only has 80 columns, or there is a database system with fixed storage size.  In those cases I would prefer to be explicit about the bounds of a number rather than write code that purports to work with any number but in fact does have an upper bound somewhere, just nobody knows quite what it is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959800/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor959805"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 18:00 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/959805/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; &gt; But in the real world you can usually put a bound on things</span><br>
<p>
<span class="QuotedText">&gt; No, you couldn't. Even if limit sounds sane today it would be, most definitely, be too small tomorrow.</span><br>
<p>
Stop  being an arrogant idiot!<br>
<p>
Okay, I can't think of an example, and I guess you haven't even bothered to look, but I'm sure other people will be able to find examples where a certain positive big number indicates an error. Certainly I'm sure there are examples where the mere EXISTENCE of a negative value is an error (in other words 0 is an absolute lower bound).<br>
<p>
(Actually, as a chemist, I've just thought of a whole bunch of examples. s is either 1 or 2 (can be empty aka 0). Likewise, p is 1 to 6. d is 1 to 10. f is 1 to 14. ANY OTHER VALUE IS AN ERROR.) To have the compiler make sure I can't screw up would be a wise choice.<br>
<p>
And please, WHY ON EARTH would you want to store an entry about a company into a genealogical database? While it's possible it'll change (extremely unlikely), any value for age outside 0 - 126 is pretty much impossible. In fact, surely you DO want to limit that value, precisely in order to trigger an error if someone is stupid enough to try to enter a judicial person into the database!<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959805/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959810"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Enough</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 22:23 UTC (Sun)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/959810/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Ok let's stop this here please. Seriously.


      
          <div class="CommentReplyButton">
            <form action="/Articles/959810/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor959788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 10:53 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/959788/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; saturating_add(): Returns (the Rust equivalent of) INT_MAX when we overflow.</span><br>
<p>
(I'm sure you know this but) note that saturation occurs at _both_ ends of the range of an integer type, if you (-100i8).saturating_add(-100) that's the 8 bit signed integer -128 aka i8::MIN not i8::MAX<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor959756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 21:14 UTC (Sat)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/959756/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Rust's integers don't magically have different behaviour depending on whether they're signed</span><br>
<p>
But they magically have different behavior depending on the whether you compile in debug or release mode, because the "debug" and "release" profiles define `overflow-checks` differently. This is surprising, too, and I'm not sure, if that was a good design choice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959787"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 10:35 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/959787/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your program is wrong if you overflow the basic integer types, so only incorrect programs exhibit different behaviour depending on whether overflow-checks is set (if it's set, the program exits when it detects your mistake, if not, the integer wraps).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959787/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor961142"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2024 8:24 UTC (Wed)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/961142/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;only incorrect programs exhibit different behaviour depending on whether overflow-checks is set</span><br>
<p>
"You can only shoot yourself in the foot if you hold it wrong"<br>
<p>
"Only incorrect programs have this problem" is the exact issue Rust is meant to prevent. What's the point of Rust  if it doesn't prevent one of the most common sources of vulnerabilities?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/961142/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor961148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2024 10:48 UTC (Wed)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/961148/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've argued for enabling overflow checks by default elsewhere but:<br>
<p>
<span class="QuotedText">&gt; What's the point of Rust if it doesn't prevent one of the most common sources of vulnerabilities?</span><br>
<p>
The main reason overflows lead to vulnerabilities is by breaking bounds checks. Since bounds checks are still applied by the compiler in a safe after whatever math you did, there's not really any way to turn it into a memory vulnerability. Unless you're manually writing bound checks in unsafe Rust, which is honestly pretty rare.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/961148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor961154"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2024 10:56 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/961154/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>The different fully-defined behaviours are, in practice, not a common source of vulnerabilities; by default, in production, you get wrapping (2s complement wrapping if signed), in development you get panics.
<p>This differs from the issue in C, where overflow is a common source of vulnerabilities since it's <em>not</em> defined for signed integers, and thus the compiler is allowed to surprise a developer.


      
          <div class="CommentReplyButton">
            <form action="/Articles/961154/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor961158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2024 11:36 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/961158/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In other words, as I read it, you shouldn't get wrapping in production because it will have panic'd and been fixed in testing.<br>
<p>
Okay, okay, that's being optimistic, but that is the likely course of events ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/961158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor961161"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2024 12:07 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/961161/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>That's one component of it; the other is that if it does wrap, you're not going to be surprised by the resulting behaviour, whereas in C, you can get weirdness where overflowing signed arithmetic does unexpected things. Taking the following code as an example:
<pre>
<code>
int a = 5;
int b = INT_MIN;
int c = b - a;

if (c &lt; b) {
    printf("c less than b\n");
}
if (b &lt; c) {
    printf("b less than c\n");
}
if (c == 0) {
    printf("c is zero\n");
}
if (b == c) {
    printf("b equals c\n");
}
</code>
</pre>
<p>In standard C semantics, because arithmetic overflow is undefined, it is legal for all four comparisons to evaluate to <tt>true</tt>, and thus for all four <tt>printf</tt>s to print. In Rust semantics, because of the wraparound rule. <tt>c</tt> will be equal to (the equivalent of) <tt>INT_MAX - 4</tt>, and thus only the <tt>b &lt; c</tt> condition is true.
<p>This, in turn, means that you're less likely to be surprised by the result in Rust, since it's at least internally consistent, even if it's not what you intended. And thus, if you use the result of the arithmetic operation to do something like indexing an array, instead of the compiler being able to go "well, clearly <tt>c</tt> should be zero here, so I can elide the bounds check", the compiler does the bounds check and panics for a different reason (index out of bounds). You've now got an "impossible" error, and can debug it.
<p>Note that this relies on Rust's memory safety guarantees around indexing; if you used pointer arithmetic with <tt>c</tt> instead, you could get an out-of-bounds read, and hence have trouble. The only thing that helps here is that pointer dereferencing is <tt>unsafe</tt>, and hence if you get unexpected SIGSEGVs or similar, that's one of the first places you'll look.



      
          <div class="CommentReplyButton">
            <form action="/Articles/961161/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor959817"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 2:18 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959817/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
With my SRE hat on: I'm very happy with this behavior. I do not like it when serving code crashes at runtime. Often enough, the crash is caused by some malformed query (input), and if there are enough of those queries, they will take down your servers faster than the orchestration layer can bring them up again. Then your load balancer sees that you don't have enough servers in this datacenter (region, cluster, zone, whatever you call it), so it starts spilling to other datacenters, taking their servers down too, and before the pager has even gone off, you're having a full-blown cascade failure.<br>
<p>
Are there situations where data integrity might dictate failing rather than producing an incorrect value? Of course, but those are properly handled with checked_add() and friends, not with crashing the entire service. If there is any input that can cause your service to crash, it is an outage waiting to happen.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959817/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959825"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 7:23 UTC (Mon)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/959825/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I understand your perspective, but others might prioritize safety and accuracy, opting for a fail-safe state during unforeseen circumstances. While checked_add() is indeed appropriate for such cases, the debate was about the language's default behavior in the face of coding errors.<br>
<p>
Considering your example, isn't there a concern that your internal or external user might have other requirements and would prefer no data over wrong data? Overlooking unexpected overflows might result in serious incidents like Cloudbleed [1]. As a customer, I'd rather see a temporary service disruption than having to learn that my private data has been silently exposed and spilled into search engine caches.<br>
<p>
[1]: <a href="https://blog.cloudflare.com/quantifying-the-impact-of-cloudbleed">https://blog.cloudflare.com/quantifying-the-impact-of-clo...</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959825/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959830"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 9:25 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959830/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Considering your example, isn't there a concern that your internal or external user might have other requirements and would prefer no data over wrong data?</span><br>
<p>
This is fine if the program is running on the user's computer. If it is not, then a crash will affect everyone whose requests are being processed by that machine, and in the case of cascade failure, fallout will be wider still. There may be situations where failing rather than producing wrong data is preferred, but it is the responsibility of the programmer to understand that requirement and use checked_add etc. instead of regular arithmetic operators. This is no different to any other functional requirement of a software system - if you write the code wrong, it will not work.<br>
<p>
<span class="QuotedText">&gt; Overlooking unexpected overflows might result in serious incidents like Cloudbleed [1].</span><br>
<p>
Security is hard. I'm not going to solve the general problem of malicious inputs in an LWN comment, but in general, defensive programming is necessary (not sufficient) to deal with problems of this nature. Most languages do not provide integers that always crash on overflow, so handling overflow correctly is something that serious programmers will find themselves having to deal with on a regular basis regardless. Rust provides the necessary methods for doing this front and center, which is more than you can say for most languages (C is only standardizing the equivalent functions in C23!). If you want stronger guarantees than that, I would suggest rewriting the parser (and perhaps a small part of the parser-adjacent application logic) in wuffs.<br>
<p>
Besides, if you allow malicious inputs to cause a crash, you make yourself far more vulnerable to denial of service attacks, which are also a security concern (albeit a less serious one).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959830/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor959832"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 11:33 UTC (Mon)
                               by <b>danielthompson</b> (subscriber, #97243)
                              [<a href="/Articles/959832/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;&gt; Rust's integers don't magically have different behaviour depending on whether</span><br>
<span class="QuotedText">&gt;&gt; they're signed</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; But they magically have different behavior depending on the whether you compile</span><br>
<span class="QuotedText">&gt; in debug or release mode, because the "debug" and "release" profiles define</span><br>
<span class="QuotedText">&gt; `overflow-checks` differently. This is surprising, too, and I'm not sure, if that was a</span><br>
<span class="QuotedText">&gt; good design choice.</span><br>
<p>
I think here you are describing a choice of *defaults* for overflow-checks rather than a design choice.<br>
<p>
In other words a developer who doesn't care can leave the defaults as they are. If a developer did, for example, wanted their panic handler run for any overflow then they can change the defaults for the release build. Cargo allows them to change it both for their own code and, with a wildcard override, for any crates they depend on! <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959832/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor960980"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2024 16:34 UTC (Mon)
                               by <b>plugwash</b> (subscriber, #29694)
                              [<a href="/Articles/960980/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust's integers do however "magically" have different behaviour in debug and release mode. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960980/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2024 17:00 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/960989/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Well, <a href="https://doc.rust-lang.org/cargo/reference/profiles.html#overflow-checks">configurable different behaviour</a> with different defaults in debug and release mode - you can panic on overflow in release, and you can wrap on overflow in debug. Plus there's the types like <a href="https://doc.rust-lang.org/core/num/struct.Wrapping.html"><tt>Wrapping</tt></a> which fully define it as wrapping in both modes, plus functions like <tt>checked_add</tt> if you want to change behaviour on overflow.
<p>That said, this is a potential footgun if you're unaware that overflow is potentially problematic; the reason the default is panic in debug builds is to increase the chances of you noticing that you depend on overflow behaviour, and ensuring that it doesn't happen.


      
          <div class="CommentReplyButton">
            <form action="/Articles/960989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor961966"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2024 19:54 UTC (Tue)
                               by <b>DanilaBerezin</b> (guest, #168271)
                              [<a href="/Articles/961966/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's because the C standard doesn't define the implementation of signed integers. They could be 2's complement, 1's complement, signed bit, or whatever. So if you can have any of these representations, it's impossible to guarantee that signed overflow also wraps around. Why it doesn't define the implementation of unsigned integers as 2's complement is probably for historical purposes and backwards compatibility at this point. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/961966/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor961969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2024 20:11 UTC (Tue)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/961969/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, they could have decided to make it implementation defined instead of UB.<br>
That would make a huge difference.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/961969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor961986"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 13, 2024 22:18 UTC (Tue)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/961986/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  Well, they could have decided to make it implementation defined instead of UB.</span><br>
<span class="QuotedText">&gt; That would make a huge difference.</span><br>
<p>
Or at the very least they could have provided a sane way to check if overflow occurs. Introducing that decades after making signed overflow UB is insane. A correct implementation of checking whether the widest integer type overflows is quite painful, particularly for multiplication.<br>
<p>
Here's postgres' fallback implementation for checking if signed  64bit multiplication overflows:<br>
<p>
	/*<br>
	 * Overflow can only happen if at least one value is outside the range<br>
	 * sqrt(min)..sqrt(max) so check that first as the division can be quite a<br>
	 * bit more expensive than the multiplication.<br>
	 *<br>
	 * Multiplying by 0 or 1 can't overflow of course and checking for 0<br>
	 * separately avoids any risk of dividing by 0.  Be careful about dividing<br>
	 * INT_MIN by -1 also, note reversing the a and b to ensure we're always<br>
	 * dividing it by a positive value.<br>
	 *<br>
	 */<br>
	if ((a &gt; PG_INT32_MAX || a &lt; PG_INT32_MIN ||<br>
		 b &gt; PG_INT32_MAX || b &lt; PG_INT32_MIN) &amp;&amp;<br>
		a != 0 &amp;&amp; a != 1 &amp;&amp; b != 0 &amp;&amp; b != 1 &amp;&amp;<br>
		((a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; a &gt; PG_INT64_MAX / b) ||<br>
		 (a &gt; 0 &amp;&amp; b &lt; 0 &amp;&amp; b &lt; PG_INT64_MIN / a) ||<br>
		 (a &lt; 0 &amp;&amp; b &gt; 0 &amp;&amp; a &lt; PG_INT64_MIN / b) ||<br>
		 (a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; a &lt; PG_INT64_MAX / b)))<br>
	{<br>
		*result = 0x5EED;		/* to avoid spurious warnings */<br>
		return true;<br>
	}<br>
	*result = a * b;<br>
	return false;<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/961986/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor959729"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 15:32 UTC (Sat)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/959729/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm unclear on why the kernel style favors multiple macro layers instead of directly using features like `__builtin_add_overflow`, which all (well, both) compilers support. This approach seems to obscure the code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959729/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 16:47 UTC (Sat)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/959734/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since which version of gcc ? on which platform ? This would be useful.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959755"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 21:07 UTC (Sat)
                               by <b>donald.buczek</b> (subscriber, #112892)
                              [<a href="/Articles/959755/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  Since which version of gcc ? on which platform ? This would be useful.</span><br>
<p>
Sorry, I'm note sure, I understand that question? gcc understands  `__builtin_add_overflow` since 5.1 (2015) and clang since 3.8 (2016) . Or is this a counter-argument, because using the builtin would make the code to much dependent on the compiler version and variant? True, but the proposed macros use the builtin, too. And for the purpose to support other compilers, it would be enough to use one level of macro with no change of function or even #define __builtin_add_overflow only for those compilers which don't provide it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959755/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959757"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 23:30 UTC (Sat)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/959757/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; gcc understands `__builtin_add_overflow` since 5.1 (2015) and clang since 3.8 (2016) .</span><br>
<p>
Thanks. Most gcc builtin are CPU-specific. It seems these ones are an exception!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959757/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor959731"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 15:39 UTC (Sat)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/959731/">Link</a>] (30 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The historical reason why overflow is undefined is they came from a world where there were multiple machine representations of signed integers depending on architecture, right?  Growing up in a twos complement only world it hurts my brain slightly that these would be handled differently since in both cases - nowadays - the machine arithmetic just wraps around to the lowest value it can represent.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959731/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959732"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 16:05 UTC (Sat)
                               by <b>smcv</b> (subscriber, #53363)
                              [<a href="/Articles/959732/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The historical reason why overflow is undefined is they came from a world where there were multiple machine representations of signed integers depending on architecture, right?</span><br>
<p>
I believe so. All modern architectures are two's-complement (-1 is all-bits-1), but Standard C wanted to accommodate sign-and-magnitude (-x has all the same bits as +x, except for flipping the sign bit), and unfortunately chose to make signed overflow be undefined behaviour (compiler may assume that the whole program is meaningless if signed overflow would occur) rather than merely implementation-defined (compiler does something vaguely reasonable with it, in practice delegating to whatever way it works in hardware).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959732/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 27, 2024 17:28 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/959745/">Link</a>] (28 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  unfortunately chose to make signed overflow be undefined behaviour rather than merely implementation-defined </span><br>
<p>
<a href="https://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">https://blog.llvm.org/2011/05/what-every-c-programmer-sho...</a><br>
<p>
<span class="QuotedText">&gt; If arithmetic on an 'int' type (for example) overflows, the result is undefined. One example is that "INT_MAX+1" is not guaranteed to be INT_MIN. This behavior enables certain classes of optimizations that are important for some code. For example, ...</span><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959764"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 1:53 UTC (Sun)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/959764/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's fascinating, thanks.  Do you have any sense of the relationship to historical behavior and the reasons why this was done?  That seems like something that came along later.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959764/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960653"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2024 16:34 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/960653/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      The likely explanation for non-standardization by the C89 committee is that compilers for different targets behaved differently (and they wanted to support sign-magnitude, ones-complement and two's-complement targets, even though by that time all machines that were not followups on earlier machines had been two's-complement for more than two decades in 1989).

<p>Now why did they make it undefined rather than implementation-defined or whatever other options they had for not standardizing the behaviour (some people put a lot of weight on whether it's "undefined" or something else)?  Looking at the shifts where some cases are undefined and some are implementation-defined, it seems to me that they chose undefined for cases where a compiler for one target could trap.  Declaring the behaviour to be undefined allowed the time-travel clause to trigger, so the program could be terminated right away rather than first having to finish delayed work (in particular, writing out file buffers).





      
          <div class="CommentReplyButton">
            <form action="/Articles/960653/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960659"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2024 16:56 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/960659/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; they chose undefined for cases where a compiler for one target could trap.</span><br>
<p>
But why? A compiler trapping is surely just as implementation-defined as anything else, surely?<br>
<p>
Even if they'd gone through UB and said "here are a bunch of flags to turn it into implementation-defined", that would have stopped a lot of this nonsense.<br>
<p>
Of course, as others have pointed out, the more C moves away from the metal and towards the "C virtual machine", the worse this problem gets. But even acknowledging this difference and defining the behaviour of the virtual machine, and then allowing the user to choose between virtual machine or hardware at least gives the programmer the opportunity to reason about his program.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960659/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960676"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2024 17:56 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/960676/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      As mentioned, my guess is that "undefined behaviour" does not require writing out write buffers, while an implementation-defined behaviour of "... terminates the program" without any further provisions would require the program to flush out any buffered writes.  Maybe one could specify the implementation-defined behaviour in a way that avoids this requirement, but I guess that the C89 committee just wanted to spare the implementations from having to do such specifications. 


      
          <div class="CommentReplyButton">
            <form action="/Articles/960676/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960685"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2024 18:44 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/960685/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"trap and abort" maybe?<br>
<p>
If the implementation says "terminate with prejudice" then why would it flush buffers? At the end of the day, all the compiler writers need do is describe what happens.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960685/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2024 8:36 UTC (Sat)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/960726/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      They need to describe what happens relative to what the standard describes.  It has been <a href="https://devblogs.microsoft.com/oldnewthing/20140627-00/?p=633">claimed</a> that the C standard contains a time-travel clause.  However, looking in the C90 document, in n2794 (final C99 draft), and n1570 (final C11 draft), I don't find this clause, so maybe it is just a myth.

<p>If that clause actually exists in a C standard, the question is why they added it.  In the years preceding C89, the undefined behaviour shenanigans that C compiler writers would start with a decade or so later were non-existent practice (while standards usually standardize common practice), so I wondered where such a clause would come from.  My theory was that it was there to explain that a program terminated by trapping does not have all the output that, e.g., fwrite() calls output prior to termination; however, looking in the C standards, the buffering is there explicitly, so no time travel is needed to explain that behaviour, falsifying my theory.

<p>OTOH, if no time travel permission exists, C compilers must not assume that programs will only perform defined behaviour in the future (and base their reasoning on that assumption).  At most they can assume that only defined behaviour has happened earlier in program execution, and a number of compiler shenanigans would be non-standard (the blog post linked to above gives examples).




      
          <div class="CommentReplyButton">
            <form action="/Articles/960726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960752"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2024 13:35 UTC (Sat)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/960752/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That clause exists in C++11 (quoted in the linked article) and identically in C++98:<br>
<p>
<span class="QuotedText">&gt; A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input. However, if any such execution contains an undefined operation, this International Standard places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation).</span><br>
<p>
As far as I can see, there's no equivalent in any C specification, but that seems to be because C is unfortunately vague about the concept of conformance.<br>
<p>
C99 defines "strictly conforming program" (which "shall not produce output dependent on any unspecified, undefined, or implementation-defined behavior"), and "conforming implementation" (which "shall accept any strictly conforming program"), and "conforming program" (which "is one that is acceptable to a conforming implementation"). So if your program's output depends even on implementation-defined behaviour like INT_MAX &gt; 32767 (i.e. almost all programs), it's not a strictly conforming program, and whether it is a conforming program is entirely dependent on whether someone has written a compiler that considers your program "acceptable" (whatever that means); C99 declines to be responsible for defining that.<br>
<p>
And then it specifies "the results of executing conforming C programs" in terms of the observable behaviour (file outputs and stdio) of the abstract machine. I believe the results of executing non-conforming programs (i.e. whatever the compiler arbitrarily considers unacceptable) are not defined at all, so a conforming implementation can do whatever it wants (including time travel).<br>
<p>
That also means "strictly conforming program" is a circular definition - that's defined in terms of the program's output, which is only defined if it's a conforming program, which depends on whether it's accepted by an implementation that accepts strictly conforming programs. So C99 doesn't make much sense here. (At least that's my current interpretation; the specification seems quite unclear.)<br>
<p>
I think C++98 is much clearer by replacing the concept of "conforming program" with "well-formed program", which is defined properly within the specification and can be determined at compile time (it doesn't depend on input or output or the implementation's whims), and is separate from the concept of undefined behaviour (which can be input-dependent). That's why it added the explicit statement about well-formed programs containing undefined behaviour - that distinction did not exist in C. So I don't think it's a deliberate change in language design, it's simply that the C specification was poorly written (by modern standards) and relied on everyone guessing what it really meant and ignoring what it actually said, and the C++ specification editors did a better job.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960752/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960763"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2024 16:13 UTC (Sat)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/960763/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
That clause exists in C++11 (quoted in the linked article) and identically in C++98
</blockquote>

Thank you.  Even looking at the blog entry again, I do not see a reference to C++11 (maybe a JavaScript-only reference?).

<p>So compiler maintainers are ruining the C experience because of a C++ standard?  Ouch (but I have been suspecting so for a long time, only not in connection with time travel).

<p>According to your interpretation, everything in the C standard depends on the conformance definitions which you claim are circular and therefore does not make sense.  Of course any claim that it allows time travel does not make any sense, either.

<p>IANACLL (C language lawyer), but my interpretation up to now has been that the rest of the standard defines how an implementation has to execute a program; this does not include a time travel provision.  The conformance levels are just there to classify a program or an implementation: 

<ul>

<li>Is a program strictly conforming?  Typically no; e.g., even the classic "Hello, world" program is not strictly conforming.

<li>Is it conforming?  If it compiles and links on some C compiler, typically yes.

<li>Is an implementation conforming? if it implements the requirements of the standard correctly, yes.  Unfortunately, these requirements are pretty weak.

</ul>



      
          <div class="CommentReplyButton">
            <form action="/Articles/960763/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960882"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2024 10:08 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/960882/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
So compiler maintainers are ruining the C experience because of a C++ standard? Ouch (but I have been suspecting so for a long time, only not in connection with time travel). 
</blockquote>
<p>Note that in the case of MSVC, Microsoft used to claim only C++ standard conformance, and claimed in the product briefing that the compiler's C support was defined in terms of the C++ support, rather than being defined by the C standard. I would not be surprised if the same was true of other compilers.


      
          <div class="CommentReplyButton">
            <form action="/Articles/960882/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960891"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2024 12:15 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/960891/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What other C++ compilers exist (that aren't on their way to being LLVM-based)? GCC, EDG, Clang, MSVC are the ones I know of (and see represented at ISO meetings).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960891/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2024 14:01 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/960901/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Good question; I've not paid attention for a long time; I know of many C compilers, but not many C++ compilers, and most of the C compilers can best be described as "barely maintained" (one I'm aware of - an expensive one - is talking about having full C90 support "soon", and mostly relies on the fact that it's a qualified compiler for the purposes of various certifications to keep going).


      
          <div class="CommentReplyButton">
            <form action="/Articles/960901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor961032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2024 4:29 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/961032/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeahâ€¦those compilers aren't even really paying attention to "modern C" nevermind "modern C++" for sources of "inspiration". There are over 100 C implementations but I'd be surprised if C++ were really something that mattered to the vast majority of them (beyond what may cross-pollinate to C).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/961032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor961048"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2024 11:03 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/961048/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>AFAICT, most of them don't care about the C standard at all; they have their own dialect of C that's not the same as standard C, and a niche where it's more important that they either comply with other standards (qualified compilers etc), or a niche where they are deliberately non-standard to support legacy code bases that depend on historic behaviour that conflicts with the C standard.
<p>For example, one vendor I'm aware of has two C compilers they sell; one is LLVM-based, and does standard C; the other is their legacy compiler, which is guaranteed to interpret certain constructs the way their compilers in the 1980s did, even though that interpretation conflicts with the C standard. But this is valuable if you have legacy code that "knows" that floating point to integer casts are bitwise, while implicit conversions are value based (for example - not the actual case, but it's that sort of weirdness).


      
          <div class="CommentReplyButton">
            <form action="/Articles/961048/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor960660"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2024 18:23 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/960660/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>IIRC, the three layers of underspecified in the C standard are:
<ol>
<li>Implementation-defined; the behaviour of this construct is fully defined in the implementation's manual. The standard may or may not place restrictions on the allowed behaviours, but whatever the implementation chooses is documented.
<li>Unspecified behaviour; the implementation must choose a behaviour, but is not required to document it. The standard may 
or may not place restrictions on the allowed behaviours.
<li>Undefined behaviour; the implementation can do what it likes, and further is not required to tell you anything about its decision - it doesn't even have to tell you that your code has UB.
</ol>
<p>The issue with making this unspecified or implementation defined is that implementations must give the same result for the same operation with the same input data if it's unspecified or implementation defined (and in the latter case, it must match the documentation). If you make it undefined, then this issue goes away.
<p>Plus, there's a social perspective; when this behaviour was made undefined, the C standards committee still thought that compiler writers would mostly settle on some "sensible" behaviours for much of this stuff, and then we'd be able to do a new standard that didn't change anything concrete, just said that things that used to be undefined are now unspecified or implementation defined (or even fully defined). With hindsight, I suspect the committee would not have made it undefined behaviour if they'd known how this would turn out over the next 3 decades.


      
          <div class="CommentReplyButton">
            <form action="/Articles/960660/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor959774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 8:40 UTC (Sun)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/959774/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thatâ€™s an interesting article. It points out that if integer overflow were defined to wrap around then a simple for-loop could be an infinite loop, if the upper bound is INT_MAX. Declaring that overflow â€œcannotâ€ happen lets the compiler optimize better, knowing the loop must terminate. <br>
<p>
And this finally explains why common C programming style is to use signed integer types, even for quantities that will never be negative in practice. Naively it makes sense to use an unsigned int both as the loop counter and as the upper bound. But if you do so, it is allowed to wrap around to zero, so a loop exit condition would never be hit if the upper bound happens to be the largest possible unsigned value. And the compiler has to allow for that. <br>
<p>
(Iâ€™m sure itâ€™s not just for-loops and there are other important optimizations, just that this is one of the easier cases to explain.)<br>
<p>
But these arcane optimization side effects have very little to do with the choice between a signed quantity and an unsigned quantity. That ought to be orthogonal: so youâ€™d have signed integers with defined wraparound semantics, signed with â€œundefinedâ€ overflow, and similarly two kinds of unsigned integer. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 10:46 UTC (Sun)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/959789/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; And this finally explains why common C programming style is to use signed integer types, even for quantities that will never be negative in practice.</font>

<p>Nah, that's simply because <a href="https://en.wikipedia.org/wiki/C_(programming_language)">C</a> grew out of <a href="https://en.wikipedia.org/wiki/B_(programming_language)">B</a> and latter only had one datatype: word.</p>

<p>When B evolved into C loops started using <code>int</code> for indexes and then CPUs (sic!) grew various hacks to make these efficient (AMD and Intel have macrops fusion, RISC-V <a href="https://drive.google.com/file/d/11-dKxnp7yfl9L3HESXGCtYl90dFKGTzE/view?usp=drive_link">have special instructions</a> to cope, etc).</p>

<font class="QuotedText">&gt; Iâ€™m sure itâ€™s not just for-loops and there are other important optimizations, just that this is one of the easier cases to explain.</font>

<p>Nope. Most of the time there are no difference, but without various hacks on all levels <code>size_t</code> would have been faster, of course.</p>

<p>On base RV64G they <b>are</b> faster, but who uses these?</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/959789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor959796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 11:32 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/959796/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; And this finally explains why common C programming style is to use signed integer types, even for quantities that will never be negative in practice.</span><br>
<p>
I suspect that's almost never the real motivation. Early versions of C didn't even have unsigned types - the only types were int and char, and later float and double, so the only one suitable for a loop counter was int. The `int i; for (i=0; i&lt;n; i++) ...` idiom appears to have already been established back then (<a href="https://www.bell-labs.com/usr/dmr/www/cman.pdf">https://www.bell-labs.com/usr/dmr/www/cman.pdf</a>), and was widely used in the K&amp;R book (after unsigned had been added to the language). K&amp;R seems to use int as the default for pretty much everything, and only uses unsigned where it really needs all 16/32 bits (e.g. hash values) - and you'd almost never need all those bits for a loop counter because you wouldn't have enough RAM for such a huge array.<br>
<p>
Also, `int` is much shorter and easier to type than `unsigned`. So I think people have continued using int for 50+ years because it's idiomatic and easy and there's been little motivation to change, not because they really care about modern compiler micro-optimisations.<br>
<p>
Meanwhile in C++ it's idiomatic to use `for (size_t i = 0; ...)` (which is unsigned). As far as I can tell, that's largely because of STL: its designer preferred size_t as it means the library doesn't have to worry about being passed negative values for array sizes etc (C++ is much more interested in type-system-enforced correctness than C is), and it can always represent the largest possible object in memory (which by that time was approaching the 32-bit limit). STL was widely used, so everyone else used size_t for consistency, and to avoid implicit type conversions that could trigger overflows or compiler warnings.<br>
<p>
In C++ it's also idiomatic to use `++i` instead of `i++` in loops, because `i` might be an STL iterator that has to do more work to return a copy of the old value in post-increment (at least in old compilers that optimise poorly), and there's no downside to preferring pre-increment, so pre-increment was widely recommended for performance. But I've never heard anybody make a general recommentation of using ssize_t instead of size_t to let the compiler optimise non-overflowing bounds checks - nobody cares about performance _that_ much, except when they've got a specific benchmark to profile and optimise.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 12:10 UTC (Sun)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/959799/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Also, `int` is much shorter and easier to type than `unsigned`. So I think people have continued using int for 50+ years because it's idiomatic and easy and there's been little motivation to change, not because they really care about modern compiler micro-optimisations.</span><br>
<p>
Absolutely! I've observed that it has been the main reason I've continued to use it a lot, and for this precise reason I added "uint", "uchar", "ulong", "ullong" etc to my programs to reduce the cost of switching to unsigned. And it works.<br>
<p>
That's exactly why anything based on annotations or complex type definitions has no chance to work, too much pain for the developer, and makes the code totally unreadable. I already *introduced* bugs in my code because of GCC warnings that I was trying to shut up in good faith resulting in a lot more complex construct that had bugs. Data-related bugs are one thing, but when it becomes so complicated to tell the compiler there's no issue that you end up with control bugs, that's another story and a much more serious one.<br>
<p>
I think that some tooling is needed, and the kernel provides a lot already. For example, min_t(), max_t() are convenient to use and perform lots of checks. Anything that saves the developer from introducing casts is good, and overflow checks are good, if they're easy to use and type (i.e. not __builtin_add_overflow_foo_bar()).<br>
<p>
Readability is super critical to produce safe code and to spot bugs in others' code during reviews. Long lines and ultra-long identifiers severely affect this and can easily result in more bugs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor959808"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 21:14 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/959808/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; It points out that if integer overflow were defined to wrap around then a simple for-loop could be an infinite loop, if the upper bound is INT_MAX</span><br>
<p>
A fun interview question is to ask the candidate to write a program which prints out every number between 0 and UINT_MAX inclusive, using only 32 bit arithmetic.<br>
<p>
The object, of course, is not to see whether they can, but what mistakes they make along the way, and how they handle Socratic questions about the flaws. Some candidates are quite overconfident that they know what they're doing.<br>
<p>
I've seen some very innovative correct answers over the years too. And that's also cool because you can discuss the pitfalls and advantages of their approach over a more conventional approach.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959808/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959809"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 28, 2024 22:23 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/959809/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; A fun interview question is to ask the candidate to write a program which prints out every number between 0 and UINT_MAX inclusive, using only 32 bit arithmetic.</span><br>
<p>
There's all sorts of questions you can ask like that :-)<br>
<p>
<span class="QuotedText">&gt; The object, of course, is not to see whether they can, but what mistakes they make along the way, and how they handle Socratic questions about the flaws. Some candidates are quite overconfident that they know what they're doing.</span><br>
<p>
When I've done that, the number of people who clearly didn't hear when you say you want to see how they handle it, you don't expect the answer to be correct (or even compile!).<br>
<p>
(The problem with that is managers. I've been in interviews where they assumed that because I knew dialect A, I could write a working program in dialect B having met it for the first time in the interview!)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959809/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor959812"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 0:54 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/959812/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There will be infinitely many such numbers since 0 and UINT_MAX are definitionally different numbers, we can definitely always find a new different number between them, and so on forever. Almost All of these infinitely many numbers are also non-computable which isn't good news.<br>
<p>
Perhaps you meant specifically integers? Computers much prefer integers, but now it's a boring problem. These days I mostly write Rust, so I'd want to write<br>
<p>
let mut number: u32 = 0; loop { println!("{number}");  if number == u32::MAX { break; } number +=1; }<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959812/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 8:43 UTC (Mon)
                               by <b>gspr</b> (guest, #91542)
                              [<a href="/Articles/959828/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; There will be infinitely many such numbers since 0 and UINT_MAX are definitionally different numbers, we can definitely always find a new different number between them, and so on forever.</span><br>
<p>
As a mathematician, I'd find this response silly. If you want to be pedantic: "number" does not imply "real number" any more than it implies "integer". In fact, I'd argue that without any further context, then the fact that the name UINT_MAX seems to carry the implication of being an integer is enough for a reasonable person to at least assume that the question is about integers.<br>
<p>
Your answer would come off to me as quite obtuse. Sure, nothing wrong with clarifying along the lines of "you mean integers, right?" But assuming reals and stating that the problem cannot be solved is just silly. And problematic because you, too, made a whole bunch of assumptions about the (somewhat imprecisely specified) task.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 19:11 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/959914/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's a fair point, unlike INT_MAX (whose definition is just a number) UINT_MAX is typically defined as an actual unsigned integer using the suffix U for parsing reasons, and thus (on a platform where that's the case) it really is actually an unsigned integer like Rust's u32::MAX, not just a number.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor959818"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 2:35 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/959818/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do you allow solutions that cheat?<br>
<p>
puts("0");<br>
for(unsigned int i = 1; i != 0; i++){<br>
printf("%u\n", i);<br>
}<br>
<p>
No arithmetic other than 32-bit is done here*, but I'm not sure this is the answer you had in mind.<br>
<p>
* Assuming sizeof(unsigned int) == 4 as on the vast majority of real systems. You can write uint32_t, but I would have to look up how to pass that to printf portably. It's probably some ugly preprocessor macro.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959818/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor959819"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 2:53 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/959819/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I accept any answer because it's just a starting point for the discussion that lets me get to know you as a programmer. I'd ask you how you'd go about testing it, for example. Or if you considered other algorithms and why you chose this one over any other. Or I'd write out one that was wrong and ask what feedback you'd give in code review.<br>
<p>
I'm not looking for bug-free code in a whiteboard interview. I'm looking for a programmer who I can work with, and that means giving and receiving feedback.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959819/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor959921"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 20:24 UTC (Mon)
                               by <b>jwilk</b> (subscriber, #63328)
                              [<a href="/Articles/959921/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; You can write uint32_t, but I would have to look up how to pass that to printf portably. It's probably some ugly preprocessor macro.</span><br>
<p>
printf("%" PRIu32 "\n", i); // macro defined in &lt;inttypes.h&gt;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959921/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor959820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 29, 2024 3:47 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/959820/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's a good idea. I, too, like to make candidates discuss about pitfalls. I don't care if they can't do something, they'll have plenty of time to find a solution, what matters is how they're searching and what they care about.<br>
<p>
BTW regarding your challenge, for me that's a typical use case for do ... while since you can only test for the end after the operation, e.g  i=0; do { printf("%u\n", i); } while (++i);<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/959820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor960658"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2024 17:48 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/960658/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The stuff about this particular for loop is symptomatic for this blog series.  It gives a (non-idiomatic) example fragment, and claims that allowing the compiler to assume that this loop is not infinite "allows a broad range of loop optimizations to kick in", but does not say what they are and how little benefit they provide.  So I filled in some missing parts and tried out the result <a href="https://godbolt.org/z/soWb9nKfK">on Godbolt</a>, and I found that gcc-13.2 -O3 delivers the same result without and with -fwrapv.

<p><a href="http://people.csail.mit.edu/nickolai/papers/wang-undef-2012-08-21.pdf">Wang et al.</a> found that in only one loop in one of the SPEC Cint 2006 benchmarks there was a measurable difference between undefined and wraparound behaviour, due to sign-extending the int in the wrapping case (<a href="https://godbolt.org/z/ffhcnxxdv">condensed Godbolt example</a>).  You can avoid this problem (on AMD64) by using size_t (as suggested by Wang et al.) or any other unsigned type for the loop index (but RV64G may need zero-extensions if the index type is smaller than an address), or by using an address-sized type (e.g., long, unsigned long on Linux targets).



      
          <div class="CommentReplyButton">
            <form action="/Articles/960658/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor960151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2024 12:20 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/960151/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't understand the attraction of doing overflow tests that trigger wrapping or - worse - overflow<br>
<p>
if (x + y &lt; x)<br>
  &lt;it wrapped&gt;<br>
<p>
Why not make use of some basic arithmetical properties to get a construction that is guaranteed not to overflow?:<br>
<p>
<p>
if (x &gt; max_size_of(y,x) - y)<br>
  &lt;it wrapped&gt;<br>
<p>
max_size_of() can be engineered to produce the right answer according to type promotion of x+y. Or just use APPROPRIATE_SIZE_MAX if it's obvious.<br>
<p>
?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960383"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2024 10:06 UTC (Thu)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/960383/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Why not make use of some basic arithmetical properties to get a construction that is guaranteed not to overflow?:</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; if (x &gt; max_size_of(y,x) - y)</span><br>
<p>
So you are subtracting a possibly negative number from the maximal number that can be represented? How is this guaranteed to not overflow?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960383/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2024 10:18 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/960388/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For unsigned. With signed, the negative case is pretty trivial to check for. I'm asking just about this construct for the "check for overflow in 2 positives" case. Why do it with an overflow instead of the equivalent "always safe" construct?<br>
<p>
I see another subthread with same question, and apparently it will even compile to same assembly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor960389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2024 10:46 UTC (Thu)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/960389/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A thought of signed, especially since you distinguished between wrapping and overflow. With unsigned it will be always wrapping.<br>
<p>
And how is the negative case for signed trivial to check. With signed you have three cases, adding two positive numbers, adding two negative numbers and adding numbers with opposite sign. The last one cannot overflow, but you have to check for the two other cases. And I do not see how negative numbers are any better than positive numbers.<br>
<p>
I am happy to mostly writing rust. "x.checked_add(y)" is so much more natural. Or with overflow handling:<br>
<p>
let Some(z) = x.checked_add(y) else {<br>
  &lt; handle overflow &gt;<br>
}<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/960389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor960680"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2024 18:10 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/960680/">Link</a>] 
      </p>
      
      </div>
      </summary>
      This article uses an unfortunate mixture of Cook's unfortunate terminology and something else (maybe something like the terminology below).  Here's an attempt at something better:

<p>There are the following overflow conditions:

<ul>
<li>signed overflow (called "overflow" by Cook)
<li>unsigned overflow (called "wraparound" by Cook)
</ul>

<p>There are the following common behaviours on an overflow:

<ul>
<li>wraparound (the result is the number in the target type that is congruent with the mathematical result modulo 2^b)
<li>trapping
<li>saturating (used for DSP applications)
<li>undefined (the compiler does whatever it likes)
</ul>

With this terminology, the usage of "wraparound" for signed integers or pointers makes more sense than with Cook's terminology as presented in the article.


      
          <div class="CommentReplyButton">
            <form action="/Articles/960680/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor964314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Better handling of integer wraparound in the kernel</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2024 13:44 UTC (Sun)
                               by <b>mmjo</b> (guest, #55791)
                              [<a href="/Articles/964314/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Last sentence: "As this work is wrapped up, ..."<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/964314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
