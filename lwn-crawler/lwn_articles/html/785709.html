        <!DOCTYPE html>
        <html lang="en">
        <head><title>Expedited memory reclaim from killed processes [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/785709/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/785681/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/785709/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Expedited memory reclaim from killed processes</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 12, 2019</br>
           </div>
Running out of memory puts a Linux system into a difficult situation; in
the worst cases, there is often no way out other than killing one or more
processes to reclaim their memory.  This killing may be done by the kernel
itself or, on systems like Android, by a user-space out-of-memory (OOM)
killer process.  Killing a process is almost certain to make somebody unhappy;
the kernel should at least try to use that process's memory expeditiously
so that, with luck, no other processes must die.  That does not always
happen, though, in current kernels.  <a
href="/ml/linux-kernel/20190411014353.113252-1-surenb@google.com/">This
patch set</a> from Suren Baghdasaryan aims to improve the situation, but
the solution that results in the end may take a different form.
<p>
The kernel requires processes to clean up their own messes when they exit.
So, before a process targeted by an OOM killer can rest in peace, it must
first run (in the kernel) to free its memory resources and return them to the
system.  If the 
process is running with a low priority, or if it gets hung up waiting for a
resource elsewhere in the system, this cleanup work may take a long time.
Meanwhile, the system is still struggling, since the hoped-for influx of
free memory has not yet happened; at some point, another process will also
be killed in the hope of getting better results.
<p>
This problem led to the development of the <a
href="/Articles/668126/#reaper">OOM reaper</a> in 2015.  When the kernel's
OOM killer targets a process, the OOM reaper will attempt to quickly strip
that process of memory that the process will never attempt to access
again.  But the OOM reaper is not available to user-space OOM killers,
which can only send a <tt>SIGKILL</tt> signal and hope that the target
exits quickly.  The user-space killer never really knows how long it will take
for a killed process to exit; as Baghdasaryan pointed out, that means that
it must maintain a larger reserve of free pages and kill processes sooner
than might be optimal.
<p>
Baghdasaryan's proposal is to add a new flag (<tt>SS_EXPEDITE</tt>) to the
(new in 5.1) <tt>pidfd_send_signal()</tt> system call.  If that flag is
present, the caller has the <tt>CAP_SYS_NICE</tt> capability, and the
signal is <tt>SIGKILL</tt>, then the OOM reaper will be unleashed on the
killed process.  That should result in quicker and more predictable freeing
of the target's memory, regardless of anything that might slow down the
target itself.
<p>
The comments on the proposal were heavily negative, which is interesting
because most of the people involved were supportive of the objective
itself.  The strongest critic, perhaps, was Michal Hocko (the author of the
OOM reaper), who 
<a
href="/ml/linux-kernel/20190411105111.GR10383@dhcp22.suse.cz/">complained</a>
that it "<q>is abusing an implementation detail of the OOM
implementation and makes it an official API</q>".  He questioned whether
this capability was useful at all, saying that relying on cleanup speed is
"<q>a fundamental design problem</q>".  Johannes Weiner, though, <a
href="/ml/linux-kernel/20190411171909.GB5136@cmpxchg.org/">argued</a> that
the idea was, instead, "<q>just optimizing the user experience as
best as it can</q>".  Others generally agreed that freeing memory
quickly when a process is on its way out is a good thing.
<p>
Daniel Colascione <a
href="/ml/linux-kernel/CAKOZuesgCpyLzs3g=RxyjBMjiMMxDbA2kOZZs3YOqOv=Ri6KgQ@mail.gmail.com/">liked
the idea</a> but wanted a different interface.  Rather than adding
semantics to a specific signal, he suggested a new system call along the
lines of:
<p>
<pre>
    size_t try_reap_dying_process(int pidfd, int flags, size_t max_bytes);
</pre>
<p>
This call would attempt to strip memory from the process indicated by
<tt>pidfd</tt>, but only if the process is currently dying.  The
<tt>max_bytes</tt> parameter would tell the kernel how much memory the
caller would liked to see freed; that would allow the kernel to avoid doing
the full work of stripping the target process if <tt>max_bytes</tt> has
been reached.  Notably, the reaping would be done in the context of the
calling process, allowing user space to determine how important this work
is relative to other tasks.
<p>
Matthew Wilcox had <a
href="/ml/linux-kernel/20190411153313.GE22763@bombadil.infradead.org/">a
simpler question</a>: why not just expedite the reclaim of memory <i>every</i>
time a process exits, rather than on specific request?  Weiner <a
href="/ml/linux-kernel/20190411170540.GA5136@cmpxchg.org/">agreed</a> with
that idea, noting that the work has to be done anyway, and doing it always
would avoid the need to add a new interface for that purpose.  Daniel
Colascione <a
href="/ml/linux-kernel/CAKOZuet8-en+tMYu_QqVCxmkak44T7MnmRgfJBot0+P_A+Qzkw@mail.gmail.com/">pointed
out</a>, though, that such a mechanism would slow down the delivery of
<tt>SIGKILL</tt> in general; that slowdown might be felt when running
something like <tt>killall</tt>.
<p>
Baghdasaryan <a
href="/ml/linux-kernel/CAJuCfpGQ8c-OCws-zxZyqKGy1CfZpjxDKMH__qAm5FFXBcnWOw@mail.gmail.com/">didn't
think</a> that expedited reaping makes sense all the time.  But, he said,
there are times when it is critical.  "<q>It would be great if we can
identify urgent cases without userspace hints, so I'm open to suggestions
that do not involve additional flags</q>".  If such a solution can be
found, it is likely to end up as the preferred alternative here.  Cleaning
up after a killed process is, in the end, the kernel's responsibility, and
there is little desire to create a new interface to control how that
responsibility is carried out.  Solutions that "just work" are thus to be
preferred over the addition of yet another Linux-specific API for this
purpose.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Out-of-memory_handling">Memory management/Out-of-memory handling</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#OOM_killer">OOM killer</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/785709/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor785892"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2019 0:22 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/785892/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The fundamental design problem is overcommit. Everything else is just the interminable nightmare. Blame overcommit on fork, broken 1980s database software, or w'ever. That's almost worse as its just an admission that we traded a few years of pain for a lifetime of debilitation.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/785892/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor785896"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2019 2:05 UTC (Sat)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/785896/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Believe me, I'm no fan of overcommit --- but in this specific instance, it's amazingly not overcommit's fault. The same delay in memory reclaim can occur in a strict commit system! It's about the timing of page reclaim, not about (which is the point of overcommit) how many pages get allocated in the first place and from what sources.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/785896/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor785901"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2019 3:55 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/785901/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't doubt the criticisms of the patch. But in my most recent foray digging into the OOM logic, my general sense is that some of these timing and priority issues are largely a consequence of the complexity added to forestall the OOM killer and minimize the harm. For example, right now I'm helping to deal with the OOM killer being invoked in situations where there's plenty of uncommitted memory, but because of heavy concurrent dirtying the reclaim code attempting/waiting on page flush gives up too soon. Without overcommit there would be no reason to give up--"gives up to too soon" is a characterization only meaningful in a best effort, no guarantee environment. <br>
<p>
Overcommit seems to have resulted in kernel code that emphasizes mitigations rather than on providing consistent, predictable, and tunable behavior. There is no correct or even best heuristic for mitigating OOM. It's a constantly moving target. Any interface to those heuristic mechanisms and policies that look best today will look horrible tomorrow.<br>
<p>
One may want to opt into overcommit and wrestle with such lose-lose scenarios,  but designing *that* interface (opt-in) is much easier because you're already in a position of being able to contain the system-wide fallout--architectural, performance, code maintenance, etc. Likewise, one may want the ability to cancel ("give up") some operation, but an interface describing when to cancel (a finite set of criteria) is much easier to devise and use than one describing when not to cancel (a possibly infinite set of criteria).<br>
<p>
So, yeah, I don't doubt that one sh*t sandwich can be objectively preferable to another sh*t sandwich, but the spectacle of sh*t sandwich review is tragic.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/785901/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor785919"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2019 12:18 UTC (Sat)
                               by <b>knan</b> (subscriber, #3940)
                              [<a href="/Articles/785919/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One man's design problem, another man's feature. Cleaning up after a 1.5TB rss process takes time, regardless of overcommit.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/785919/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor785958"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2019 20:15 UTC (Sun)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/785958/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Something I implemented in the past: Imagine a system with numerous virtualized (container-based) VPN servers which uses suricata for network traffic inspection and alert generation in case of suspicious activity. Suricata processes are typically huge (&gt;3G isn't uncommon). Each virtual VPN server needs its own suricata process but they all use the same ruleset. As the memory used to store the processed rule information isn't ever written to after the corresponding data structures were created, it's possible to use a per-host suricata server process which loads the rules once. A VPN server suricata process is then created by contacting the host suricata server which forks a child and moves it into the container. All VPN server suricata processes thus share a single<br>
copy of the memory used for rule data structures. <br>
<p>
Without overcommit, that is, lazy memory/ swap allocation as the need arises, this wouldn't work (in this way).<br>
<p>
"Refuste to try because the system might otherwise run out of memory in future" is not a feature. The system might as well not. The kernel doesn't know this. Or it might run out of memory for a different reason. The original UNIX fork worked by copying the forking core image to the swap space to be swapped in for execution at some later time. This was a resource management strategy for seriously constrained hardware, not a heavenly relevation of the one true way of implementing fork.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/785958/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor785995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2019 13:56 UTC (Mon)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/785995/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That’s certainly a valid use case. Ideally, though, the overcommit would be opt-in, and the side effects would be paid only by the processes that had used it — so if a Suricata process went rogue and started writing to the shared data, causing lots of copy-on-write pages to be allocated, it could be whacked by an OOM killer. <br>
<p>
Perhaps programming languages could have better support for marking a data structure read-only, which would then notify the kernel to mark the corresponding pages read-only. Then you could allocate the necessary structure and mark it read-only before forking. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/785995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor786010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2019 15:01 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/786010/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <p>I believe opting-in to overcommit is already possible, with the <tt>MAP_NORESERVE</tt> flag - which essentially says that the mapped range can be overcommitted, and defines behaviour if you write to it when there is insufficient commit available.
<p>There's a bit of a chicken-and-egg problem here, though - heuristic overcommit exists because it's easier for system administrators to tell the OS to lie to applications that demand too much memory than it is for those self-same administrators to have the applications retooled to handle overcommit sensibly.
<p>And even if you are retooling applications, it's often easier to simply turn on features like <a href="http://static.lwn.net/kerneldoc/vm/ksm.html">Kernel Same-page Merging</a> to cope with duplication (e.g. in the Suricata ruleset in-memory form) than it is to handle al the fun that comes from opt-in overcommit.
      
          <div class="CommentReplyButton">
            <form action="/Articles/786010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor786194"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2019 6:26 UTC (Thu)
                               by <b>thestinger</b> (guest, #91827)
                              [<a href="/Articles/786194/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
MAP_NORESERVE is a no-op with overcommit disabled or full overcommit enabled. It only has an impact on heuristic overcommit, by bypassing the immediate failure heuristic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/786194/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor786200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2019 7:26 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/786200/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Ah - on other systems (Solaris, at least, and IRIX had the same functionality under a different name), which do not normally permit any overcommit, it allows you to specifically flag a memory range as "can overcommit". If application-controlled overcommit ever becomes a requirement on Linux, supporting the Solaris (and documented) semantics would be a necessary part.
      
          <div class="CommentReplyButton">
            <form action="/Articles/786200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor786195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2019 6:32 UTC (Thu)
                               by <b>thestinger</b> (guest, #91827)
                              [<a href="/Articles/786195/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
See <a href="https://www.kernel.org/doc/Documentation/vm/overcommit-accounting">https://www.kernel.org/doc/Documentation/vm/overcommit-ac...</a> and the sources.<br>
<p>
The linux-man-pages documentation is often inaccurate, as it is in this case. MAP_NORESERVE does not do what it describes at all:<br>
<p>
<font class="QuotedText">&gt;  When swap space is  not reserved one might get SIGSEGV upon a write if no physical memory is available.</font><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/786195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor786197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2019 6:40 UTC (Thu)
                               by <b>thestinger</b> (guest, #91827)
                              [<a href="/Articles/786197/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To clarify, I'm quoting the inaccurate description of MAP_NORESERVE. The actual functionality is omitting the memory from heuristic overcommit, which has no impact in the non-overcommit memory accounting mode.<br>
<p>
Mappings that aren't committed and cannot be committed without changing protections don't have an accounting cost (see the official documentation that I linked) so the way to reserve lots of address space is by mapping it as PROT_NONE.<br>
<p>
To make memory that has used not be accounted again while keeping the address space, you clobber it with new PROT_NONE memory using mmap with MAP_FIXED. It may seem that you achieve the same thing with madvise MADV_DONTNEED + mprotect to PROT_NONE but that doesn't work since it doesn't actually go through it all to check if it can reduce the accounted memory (for good reason).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/786197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor786211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Man pages</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2019 12:54 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/786211/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The man pages <i>are</i> actively maintained.  I am sure that Michael would appreciate a patch fixing the error.
      
          <div class="CommentReplyButton">
            <form action="/Articles/786211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor786253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 18, 2019 15:24 UTC (Thu)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/786253/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      JFTR: On Linux, applications can actually handle SISEGV,

<pre>
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

static void do_brk(int unused)
{
    sbrk(128);
}

int main(int argc, char **argv)
{
    unsigned *p;

    signal(SIGSEGV, do_brk);

    p = sbrk(0);
    *p = atoi(argv[1]);
    printf("%u\n", *p);
    
    return 0;
}
</pre>

If the signal handler is disabled, this program segfaults. Otherwise, the handler extends the heap and the faulting instruction then succeeds when being restarted. SIGSEGV is a synchronous signal, hence, this would be entirely sufficient to implement some sort of OOM-handling strategy in an application, eg, free some memory and retry or wait some time and retry.
      
          <div class="CommentReplyButton">
            <form action="/Articles/786253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor786308"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 19, 2019 15:03 UTC (Fri)
                               by <b>lkundrak</b> (subscriber, #43452)
                              [<a href="/Articles/786308/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is, in fact, what the original Bourne shell infamously managed memory: <a href="https://www.in-ulm.de/~mascheck/bourne/segv.html">https://www.in-ulm.de/~mascheck/bourne/segv.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/786308/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor786748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 25, 2019 14:30 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/786748/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
JFTR: On Linux, applications can actually handle SISEGV,
</blockquote>
I'd be surprised if there were any Unixes on which this was not true, given that SIGSEGV in particular was one of the original motivations for the existence of signal handling in the first place.

      
          <div class="CommentReplyButton">
            <form action="/Articles/786748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor786038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2019 15:54 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/786038/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's a bad design. You shouldn't design software that depends on implicit assumptions.<br>
<p>
A better designed software would store rules in a file and map it explicitly into the target processes. This way there's no problem with overcommit - the kernel would know that the data is meant to be immutable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/786038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor786041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2019 17:03 UTC (Mon)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/786041/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That's a bad design. You shouldn't design software that depends on implicit assumptions.</font><br>
<p>
This statement means nothing (as it stands).<br>
<p>
<font class="QuotedText">&gt; A better designed software would store rules in a file and map it explicitly into the target processes. This way there's no problem </font><br>
<font class="QuotedText">&gt; with overcommit - the kernel would know that the data is meant to be immutable.</font><br>
<p>
A much more invasive change to suricata (this is an open source project I'm not anyhow associated with) could have gotten rid of all the pointers in its internal data structures. Assuming this had been done and the code had also been changed to use a custom memory allocator instead of the libc one, one could have used a shared memory segment/ memory mapped file to implement the same kind of sharing. I'm perfectly aware of this.  But this complication isn't really necessary with Linux as sharing-via-fork works just as well and is a lot easier to implement.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/786041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor786042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2019 17:10 UTC (Mon)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/786042/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For completeness¸ before someone pulls that out of his hat and triumphantly waves it through the air: Changing to a custom allocator had been sufficient as the parent could have put all of its data into a shared memory segment/ memory mapped file and children could have inherited the mapping via fork.<br>
<p>
But that's still more complicated than just relying on the default behaviour based on knowing how the application will use the inherited memory.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/786042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor786043"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2019 17:30 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/786043/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>You could also, assuming it's backed by an <tt>mmap</tt>ed file, just use <tt>MAP_FIXED</tt> to ensure that all the pointers match in every Suricata process; this works out best on 64-bit systems, as you need a big block of VA space available that ASLR et al won't claim.
      
          <div class="CommentReplyButton">
            <form action="/Articles/786043/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor786046"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2019 19:14 UTC (Mon)
                               by <b>rweikusat2</b> (subscriber, #117920)
                              [<a href="/Articles/786046/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Considering that the amount of memory which will be needed isn't known in advance, one would need to use MAP_FIXED in a "known good" location, anyway. There are some more complication with this approach as well. And the Linux default policy of "real COW", ie do not copy anyting unless it has to be done and don't (try to) reserve anything unless it's demonstrably required handles this cause just fine.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/786046/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor786914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2019 18:26 UTC (Fri)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/786914/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why can't the Suricata rules be read from a RO map file, with a seperate means for updating &amp; changing rulesets and then the equivalent of sighup to get the ruleset re-read and container processes re-reading stuff, perhaps a counter incremented in some ruleset RW meta data, set so a newer version available can be read in by containers as they restart?<br>
<p>
The disk backed data files can be shared amongst 1000's of VMs, right?<br>
<p>
Then the VM system can be sure it's safe to fork without committing much memory and the apparent need for over-commit vanishes.  I admit I haven't tried it and as I used VMs for isolation and jails for data sharing, not the kind of efficiency hack but conceptually I don't see why software developed in a stricter world couldn't handle the case reasonably.<br>
<p>
Sparse arrays, are perhaps a better case for over-commit but again I wonder about memory map file and/or smarter data structures wouldn't be feasible for the programs which actually deliberately require these features, rather than by accident due to a permissive environment.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/786914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor785938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 13, 2019 18:51 UTC (Sat)
                               by <b>mjthayer</b> (guest, #39183)
                              [<a href="/Articles/785938/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; "It would be great if we can identify urgent cases without userspace hints, so I'm open to suggestions that do not involve additional flags"</font><br>
<p>
What about a system low memory watershed?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/785938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor785947"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2019 7:21 UTC (Sun)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/785947/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;What about a system low memory watershed?</font><br>
The Linux kernel exists in a perpetual low-available-memory state. Inherently it's a caching strategy responsible for a lot of the speed in Linux. I don't know the statistics but several multiples of your machine's physical memory are allocated in the virtual memory addressing space by a design choice called memory over-commit. <br>
<p>
But which bits are meaningful over-commit that you'd count towards a system low memory state and which are merely 'maybe useful'? This question is a cache invalidation problem for those 'maybe useful' bits -- a problem already solved elsewhere in the kernel, which provides a pattern we can follow. That pattern is the least-recently-used list so, while you can't predict what user or network interaction comes next, you keep track of access times and then have the bottom end of the list for old and unused items. Pick a level of granularity for parts of a process's memory space and track the least-recently-used bits, hoping to find a ratio of maybe-useful vs definitely-useful memory commit that you'd use to set the line at which the oom-killer gets invoked.<br>
<p>
This isn't the whole picture -- the fork()+exec() paradigm can leave child processes sharing over-committed memory with their parents, which is only moved into dedicated address space for the child when it's changed -- a pattern called copy-on-write. We'd need to do more work to be certain that this memory is definitely-useful, for example it might be read-only state that each child needs from the parent, reading it often.<br>
<p>
There's excellent write-up in lwn's history:<br>
Taming the OOM killer -- <a href="https://lwn.net/Articles/317814/">https://lwn.net/Articles/317814/</a><br>
Improving the OOM killer -- <a href="https://lwn.net/Articles/684945/">https://lwn.net/Articles/684945/</a><br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/785947/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor785952"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 14, 2019 12:45 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/785952/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
which is only moved into dedicated address space for the child when it's changed
</blockquote>
The address space is always dedicated to the child after fork(), even before CoW. The *physical memory* is not.
      
          <div class="CommentReplyButton">
            <form action="/Articles/785952/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor785991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Expedited memory reclaim from killed processes</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 15, 2019 12:20 UTC (Mon)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/785991/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
oops. thanks.<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/785991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2019, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
