        <!DOCTYPE html>
        <html lang="en">
        <head><title>Lua in the kernel? [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/830154/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/830524/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/830154/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Lua in the kernel?</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>September 9, 2020</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2020-Netdev">Netdev</a>
</div>
<p>
<a href="/Articles/740157/">BPF</a> is, of course, the language used for
network (and other) customization 
in the Linux kernel, but some people have been using the <a
href="https://www.lua.org/">Lua language</a> for the networking side of that
equation.  Two developers from <a href="https://ring-0.io/en">Ring-0
Networks</a>, Lourival Vieira Neto and Victor Nogueira, came to the virtual
<a href="https://netdevconf.info/0x14/index.html">Netdev 0x14</a> to
<a
href="https://netdevconf.info/0x14/session.html?talk-linux-network-scripting-with-lua">present
that work</a>.  It consists of a framework to allow the injection of Lua scripts
into the running kernel as well as two projects aimed at routers, one
of which is deployed on 20 million devices.
</p>

<p>
Neto introduced the talk by saying that it was also based on work from Ana
LÃºcia de Moura and  Roberto Ierusalimschy of the <a
href="https://en.wikipedia.org/wiki/Pontifical_Catholic_University_of_Rio_de_Janeiro">Pontifical
Catholic University of Rio de Janeiro</a> (PUC-Rio), which is the home
organization of the Lua language.  They have been working on kernel
scripting since 2008, Neto said, developing the <a
href="https://github.com/luainkernel">Lunatik</a> framework 
for Linux.  It allows kernel developers to make their subsystems scriptable
with Lua
and also allows users to load and run their Lua scripts in the kernel.
</p>

<h4>Lua and sandboxes</h4>

<p>
Lua was chosen because it is a small, fast language, he said.  It is also
widely used as the scripting language in networking tools such as 
<a href="https://www.wireshark.org/">Wireshark</a>, <a
href="https://nmap.org/">Nmap</a>, and <a href="https://www.snort.org/">Snort</a>.
The talk focused on scripting two networking subsystems in Linux,
netfilter using <a href="https://github.com/luainkernel/nflua">NFLua</a>
and the <a href="/Articles/750845/">express data path</a> (XDP) subsystem
with <a href="https://victornogueirario.github.io/xdplua/">XDPLua</a>. 
</p>

<a href="/Articles/830953/">
<img src="https://static.lwn.net/images/2020/netdev-neto-sm.png" border=0 hspace=5 align="right"
width=221 height=280 alt="[Lourival Vieira Neto]"
title="Lourival Vieira Neto">
</a>

<p>
It is important that any scripting in the kernel not cause it to
malfunction.  Scripts should not be able to crash the system, run
indefinitely, or corrupt other parts of the system.  To ensure that, Lunatik uses
the Lua virtual machine (VM) facilities for sandboxing the scripts so that
they run in a safe execution environment, he said.
</p>

<p>
Lua scripts cannot address memory directly; they can only access it through
Lua data types, such as strings and tables.  All of the Lua types are
allocated by the VM and garbage collected when they are no longer being
used.  But that is not enough to restrict scripts from causing harm since
they could allocate too many objects and use enough memory to harm the rest
of the system.  A custom memory allocator is used that will cap the amount
of memory available to Lua scripts in order to avoid this problem.
</p>

<p>
Lua provides "fully isolated execution states", Neto said.  Those states
are initially created with only the language operators available in them;
the developer of the subsystem can then determine which libraries get
loaded for additional capabilities given to scripts.  Those might be Lua
standard libraries or specialized libraries, such as Luadata and LuaRCU;
the former provides safe access to data external to the Lua VM, while the
latter is a mechanism for sharing data between execution states.  Both
NFLua and XDPLua use Luadata to access packet data, for example.
</p>

<p>
Lua provides a single-threaded execution environment without any
primitives, such as mutexes, for synchronization.  That means the scripts
cannot explicitly block the kernel, but they could still run indefinitely.
Lua has a facility to interrupt a script after it has run a certain number
of instructions, which is used by both NFLua and XDPLua.  Multitasking is
allowed by Lunatik via multiple execution states in the kernel.
</p>

<p>
Only network administrators with the <tt>CAP_NET_ADMIN</tt> capability can
load scripts and access the execution states. <a
href="https://man7.org/linux/man-pages/man7/netlink.7.html">Netlink</a>
sockets are used to transfer data between the kernel and user space; the
capability is checked on each access, he said.
</p>

<h4>NFLua</h4>

<p>
NFLua is a <a href="https://www.netfilter.org/">netfilter</a> extension
that targets advanced <a
href="https://en.wikipedia.org/wiki/OSI_model#Layer_7:_Application_Layer">layer&nbsp;7</a>
(application layer) filtering using Lua.  Iptables rules can be 
applied at <a
href="https://en.wikipedia.org/wiki/OSI_model#Layer_3:_Network_Layer">layer&nbsp;3</a>
(network) and <a
href="https://en.wikipedia.org/wiki/OSI_model#Layer_4:_Transport_Layer">layer&nbsp;4</a>
(transport) to send packets to NFLua; scripts can then be called to
inspect the upper layer.  Lua is 
already widely used by network operators for various tasks, including for
security and network monitoring, so Lua is a good
fit for this kind of filtering. 
</p>

<p>
NFLua is implemented as a loadable kernel module that contains the Lunatik
framework, the Lua interpreter,
and whatever libraries are being made available to execution states.  Once
it is loaded, the <tt>nfluactl</tt> command can be used to create a Lua
state and to load Lua code into it.
</p>

<p>
He gave an example of a simple filter based on the User-Agent sent with an
HTTP request.
An iptables rule is used to direct packets to
an execution state and a function in that state by name. Packets matching
the rule (being sent to port 80) get passed to NFLua, which calls the named
function with the packet data.  The function looks up the
<tt>User-Agent</tt> from the HTTP request in a table to determine whether
to block it or not.  The Lua function return value indicates whether
netfilter should terminate the connection or allow it to proceed.
</p>

<h4>XDPLua</h4>

<p>
At that point, Nogueira took over; he described XDPLua as an extension for
XDP that allows using Lua in the data path.  It represents the natural
evolution of NFLua to process packets before they are handled by the
network stack.  It creates one Lua execution state per CPU, so it can
take advantage of parallelism on modern systems.  One of the goals of the
project was to add "expressiveness and dynamism" on the data path, so that
programmers could create more complex applications to be loaded into the kernel.
</p>

<p>
XDP uses BPF, so XDPLua has added wrappers for the Lua C API as BPF
helpers, allowing BPF programs to call Lua scripts.  The XDPLua developers
want BPF and Lua to cooperate, "so we can have the best of both of them",
Nogueira said.  They wanted the performance of BPF while maintaining the
expressiveness of Lua.
</p>

<a href="/Articles/830952/">
<img src="https://static.lwn.net/images/2020/netdev-nogueira-sm.png" border=0 hspace=5 align="left"
width=280 height=246 alt="[Victor Nogueira]"
title="Victor Nogueira">
</a>

<p>
He quickly went through the same example as Neto.  The Lua program is
loaded into XDPLua, while a BPF program gets loaded into XDP.  When a
packet arrives at XDP, the BPF program can call the Lua function to
determine whether to block or allow the processing of the request; if it is
allowed, then the packet will be passed on to the networking stack.
</p>

<p>
Another example that he showed was processing cookie values, which are being used
to distinguish bots from legitimate traffic, before the packet ever reaches
the web server.  On the first request from a particular client, the web
server replies with a cookie value and some JavaScript to attach the
cookie value to further requests.  Since bots typically won't run the JavaScript, they
will not have the proper cookie value. 
</p>

<p>
When a new cookie is generated, the web server will pass its value and the
source address to the Lua code, which stores it in a table.  The code to actually
handle the
value is straightforward, simply extracting the cookie value and checking
to see that it matches what is in the table.  If it is not, the request is
dropped before it ever reaches the web server.  In addition, the XDP
program will add the IP address to its block list so that no further requests
will even need to consult the Lua program.
</p>

<p>
He also outlined an access-control example
using <a href="https://en.wikipedia.org/wiki/Server_Name_Indication">server
name indication</a> (SNI) in TLS connection requests to restrict which
domains can be connected to.  This could be used to disallow local users of
a network from accessing a forbidden site.  Using a simple block list and
function in Lua, along with a BPF program to recognize the TLS client hello
message and call the Lua function, the SNI data can be checked from XDP.
</p>

<h4>Benchmarks</h4>

<p>
In order to gather some numbers, 
the access-control example was implemented for NFLua, XDPLua, and XDP (in
BPF).  The BPF version was difficult to write and turned out to be
cumbersome to work with, he said, while the same Lua script is shared
between NFLua and XDPLua.  <a 
href="https://man7.org/linux/man-pages/man8/trafgen.8.html"><tt>trafgen</tt></a>
was then used to send TLS client hello packets, with SNI values that were
in the block list, as quickly as possible.
Two things were measured: how many connections per second are dropped on
the server (the drop rate) and the CPU usage.  It was a fully virtualized
environment, both client and server ran on 8-core 3GHz CPUs with 32GB of
RAM each; they were connected by a 10Gbps virtio network interface.
</p>

<p>
NFLua could drop roughly 0.5-million packets per second, while both
XDPLua and XDP/BPF could handle around three times that rate (1.5Mpps).  In
addition, XDPLua and XDP/BPF both used roughly 0.1% of the available CPU,
while NFLua used 50%.  Nogueira said that NFLua only gets the packets once
they have gone through the network stack and it does not take advantage of
the multiple cores, which may help explain the 500x difference.  It is
important to note that having XDP call out to Lua did not have a
significant impact in terms of CPU usage, he said.
</p>

<p>
Neto returned to the video stream to wrap things up before the speakers
took questions from attendees; roughly half of the 45-minute slot was
devoted to Q&amp;A.  He noted that NFLua is used in 20 million home routers
and that it is being used by network operators for security and monitoring
tasks.  The lessons learned from NFLua were incorporated into XDPLua, which
is designed from the outset to work cooperatively with BPF, so that
developers get the ease of use of Lua combined with the performance of
BPF.  XDPLua is currently used in Ring-0 Networks firewall products that are
deployed as part of the infrastructure at internet point of presence (POP) companies
on 10Gbps networks.
</p>

<p>
One problem area that they have faced is that XDP does not support extensions as loadable kernel
modules.  Netfilter supports that functionality, which has been beneficial
for developing the Lua-based filtering mechanisms.  Maintaining
out-of-tree bindings in order to support XDPLua has been somewhat
difficult. 
</p>

<p>
Instead of using an in-kernel verifier, as BPF does, the Lua environments
take a sandboxing approach to protect the kernel.  The BPF verifier can be
hard to work with, as they found when developing the XDP/BPF version of the
access-control benchmark, Neto said.  With that, they turned it over to questions.
</p>

<h4>Questions</h4>

<p>
Tom Herbert, who was shepherding the Netdev track, noted from the outset that it
would be an uphill struggle to try to get this work merged into the
mainline.  The BPF verifier is part of what allows the kernel developers to
be comfortable with XDP, so adding Lua to the kernel will require a similar
effort to convince them that Lua is also safe.  For example, the kernel
cannot crash because Lua has accessed memory inappropriately; what is being
done to prevent that?
Neto reiterated that Lua does not access kernel memory directlyâit has no
pointer type.  It can allocate memory, but that can be (and is) limited.
Furthermore, the number of instructions can be limited, so that infinite
loops are not possible.
</p>

<p>
Neto
said that there are various places you can enforce the safety assurances:
at compile time, load time, or run time.
BPF does load time checks with the verifier, while Lua sandboxes its programs with its VM
at run time.
There could, of course, be a bug in the VM implementation, but that is also
true with the BPF verifier.
</p>

<p>
Another question that will likely be asked, Herbert said, is why a
Lua-to-BPF compiler could not be created; there are already compilers for C
and P4, why not do that for Lua?  You could perhaps turn Lua syntax into
BPF, Neto said, but you cannot write a Lua VM that runs on BPF, so you
wouldn't get all of the features that Lua can provide.  The verifier
purposely limits the BPF that can be run, so you can't write
general-purpose code.  You might be able to have some elements of Lua, but
not the "full package" if you are targeting BPF.
</p>

<p>
Shrijeet Mukherjee said that having two VMs in the kernel was likely
to be problematic; he suggested minimizing the Lua VM component in the
kernel and to move as much as possible into user space.  The BPF VM has
momentum and acceptance; from a community perspective, adding another will
be difficult.  Neto said that getting the Lua work upstream is not
necessarily the path being pursued; if XDP could provide a mechanism to
allow dynamic extensions, like netfilter has, that could work as well.
Herbert said that will be a hard sell; XDP started with the idea that it
would be pluggable, but it is now simply a BPF hook.
</p>

<p>
Netdev organizer Jamal Hadi Salim said that there is a need for both
scripting and compiled code for networking tasks.  But there are
political and technical hurdles to getting another programming environment
added to the kernel.  The security concerns are important, but he believes that
Lua could meet the requirements, just differently than is done with BPF.
</p>

<p>
Mukherjee suggested that there might be a way to split things up, such that
the in-kernel packet-handling was done in XDP, while the policy handling
could be done with Lua in user space; communication could be done through a
shared BPF map. Packet handling is really in the
kernel's domain, he said, but the policy aspects may not be.  But, as Neto
pointed out, that will add latency.  They have tried that approach in the
past, but the performance was such that they moved on to NFLua and then to
XDPLua. 
</p>

<p>
But Mukherjee wondered if caching the policy decisions in the kernel could
avoid much of the added latency for consulting user space. The "basic
stuff" could be handled in the kernel, while the "really complicated"
pieces are handled in user spaceâwith the results of the decision somehow
cached in the kernel.  He was not sure that was a reasonable approach, but
there may be a middle ground to be found that would still allow much of
what Lua is providing without putting it into the kernel.
</p>

<p>
An attendee asked about the maturity of XDPLua.
Neto said that it is running in production, but it is also still under
development.  There is no patch ready for upstream submission at this
point.  There is cleanup work that needs to be done before that can happen.
The system used for the benchmarks was overpowered, from a CPU standpoint,
for the 10Gbps link speed, so the CPU usage difference between XDP/BPF and
XDPLua was not truly shown, an attendee said.  Neto agreed that more
testing, including using slower virtual CPUs, needs to be done. 
</p>

<p>
They are using the standard Lua, rather than the <a
href="https://luajit.org/">LuaJIT</a> fork, Neto said, in answer to another
question.  Investigation of a
"typed Lua" for compilation is something on the roadmap.  That is the
approach that the main Lua project is taking to compete with LuaJIT on
performance.  The Lunatik developers have avoided using LuaJIT directly because it is based
on an older version of the language, but they are interested in pursuing
the performance gains that could come with compiled and optimized Lua.
</p>

<p>
The entrenchment of BPF and its VM make it rather hard to see how Lua could
actually be added into the kernel itself.   Getting hooks for other
pluggable programming environments added to XDP might be a more plausible
approach, though Herbert did not seem too optimistic even though he (and
others) thought the Lua approach was interesting and potentially useful.
But, "it is a moonshot", Herbert said.  Whether the XDPLua developers can
overcome whatever resistance there will be remains to be seen, but it seems
clear that there are at least some who are chafing at the restrictions of
the BPF programming environment.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking-eXpress_Data_Path_XDP">Networking/eXpress Data Path (XDP)</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Packet_filtering">Packet filtering</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Netdev-2020">Netdev/2020</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/830154/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor831080"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 17:11 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/831080/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is cool and all, but since different versions of Lua all basically have the Python2/Python3 problem (to a much lesser extent, but enough that I suspect it interferes with kernel ABI policies), what is the plan if/when the next version of Lua comes out and has some incompatibility? Is the kernel stuck with the version of the Lua language when it was first committed to the tree? Are multiple versions of the language/VM going to be supported over time?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831080/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831086"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 17:42 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/831086/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You need to take a sensible subset of Lua and stick to it.<br>
<p>
The progression of Lua 5.1 to 5.4 with their accompanying incompatibilities is unlikely to affect a kernel-side Lua implementation. You&#x27;re not going to add introspective object-oriented Lua code or similar complicated structures to the kernel. The idea is to write hooks, traps and/or packet filters in Lua, not drivers. Thus whatever could possibly cause compatibility problems will be missing from the kernel&#x27;s Lua anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831086/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 19:20 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/831098/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
5.4 introduced (versus 5.3) consts and destructors (of a flavor), &quot;new semantics for the integer &#x27;for&#x27; loop&quot; seems like it could affect kernel-oriented Lua code (and it looks like the kernel wants the new semantics of not wrapping on overflow), and string -&gt; numbers conversions are no longer in the language, but in the stdlib. 5.3 introduced bitwise operators which seem pretty handy (5.2 added them in a library).<br>
<p>
These are not object-oriented features, but core semantics to the language itself that seem to not be on the bottom of the list of features I&#x27;d expect in these kinds of programs.<br>
<p>
<font class="QuotedText">&gt; Thus whatever could possibly cause compatibility problems will be missing from the kernel&#x27;s Lua anyway.</font><br>
<p>
I mean, if it&#x27;s going to be Lua 5.k, can we just call it that and make the incompatibilities with the other releases of Lua explicit?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor831104"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 20:59 UTC (Wed)
                               by <b>meyert</b> (subscriber, #32097)
                              [<a href="/Articles/831104/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The correct thing to do (TM) is of course to include the one and only true universal language into the kernel, i.e. common lisp!<br>
Syntax problems solved!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831104/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831107"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 21:36 UTC (Wed)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/831107/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suppose in the sense that if you force the humans to parse their own programs, machines will have more time to think :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831107/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2023 13:00 UTC (Sun)
                               by <b>oOosys</b> (guest, #167274)
                              [<a href="/Articles/946060/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I took the journey via using Lisp to script Emacs and finally arrived at Lua to script Textadept coming originally from Python. <br>
<p>
Lua appears to me to be the only language very near to support valid code which reads nearly like natural language sentences. With some more small adjustments not braking any past code Lua can be turned into the language in which it would be possible to write texts being comments explaining the code which at the same time would be valid Lua code and can be executed. Here an example:<br>
<p>
<span class="QuotedText">&gt; function let_x_be(val) x = tonumber(val) end</span><br>
<span class="QuotedText">&gt; function let_y_be(val) y = tonumber(val) end</span><br>
<span class="QuotedText">&gt; function let_z_be_sum_of_x_and_y ()  z = x + y end</span><br>
<p>
With this functions defined Lua allows to write following code:<br>
<p>
<span class="QuotedText">&gt; let_x_be '0xff' _=',' let_y_be '15' _='and' let_z_be_sum_of_x_and_y''</span><br>
<p>
The result of the code above is:<br>
<span class="QuotedText">&gt; x</span><br>
255<br>
<span class="QuotedText">&gt; y</span><br>
15<br>
<span class="QuotedText">&gt; z</span><br>
270<br>
<p>
I suppose that making in Lua possible what is possible in Python where it is not necessary to give a string literal a name should not brake anything and be not that hard to implement making then following possible:<br>
<p>
<span class="QuotedText">&gt; let_x_be '0xff' ',' let_y_be '15' 'and' let_z_be_sum_of_x_and_y''</span><br>
<p>
Implementing function calls accepting beside string literals also numbers will then allow:<br>
<p>
<span class="QuotedText">&gt; let_x_be 0xff ',' let_y_be 15 'and' let_z_be_sum_of_x_and_y''</span><br>
<p>
Going a step further allowing a dot and a comma treating them as whitespace if not in appropriate context and allowing function calls without passing any parameter will allow:<br>
<p>
<span class="QuotedText">&gt; Let_x_be 0xff 'and' let_y_be 15 . 'With x and y values set respectively to 255 and 15', let_z_be_sum_of_x_and_y .</span><br>
<p>
This would turn Lua into a programming language making it possible to write  code in way which reads like natural language sentences making a very interesting programming language out of it and the only one of this kind among all the others programming languages out there.<br>
<p>
Feel free to visit the repository for a bit more background of what I would like to use Lua for  <a rel="nofollow" href="https://github.com/oOosys/oOo">https://github.com/oOosys/oOo</a>  and try the "magic switch" ( <a rel="nofollow" href="https://github.com/oOosys/oOo/blob/main/luaLang-magicSwitch_chooseWhichOne-ofTwoSubsequentCodeBlocks-shouldBeExecuted.oOo">https://github.com/oOosys/oOo/blob/main/luaLang-magicSwit...</a> ) which is possible this way except in Lua to my current knowledge only in Python using combination of triple quote literals and line comments.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 1, 2023 17:27 UTC (Sun)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/946069/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Your site doesn't respect my time.<br>
<p>
It uses an animated gif to deliver plain English words at its own pace, independent of my reading speed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor946112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2023 11:08 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/946112/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Lua appears to me to be the only language very near to support valid code which reads nearly like natural language sentences. With some more small adjustments not braking any past code Lua can be turned into the language in which it would be possible to write texts being comments explaining the code which at the same time would be valid Lua code and can be executed.</span><br>
<p>
Ruby also has this.<br>
<p>
describe Factorial do<br>
  it "finds the factorial of 5" do<br>
    calculator = Factorial.new<br>
<p>
    expect(calculator.factorial_of(5)).to eq(120)<br>
  end<br>
end<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor946116"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2023 11:51 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/946116/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Lua appears to me to be the only language very near to support valid code which reads nearly like natural language sentences. With some more small adjustments not braking any past code Lua can be turned into the language in which it would be possible to write texts being comments explaining the code which at the same time would be valid Lua code and can be executed. Here an example:</span><br>
<p>
ACCESS. ENGLISH. INFORM.<br>
<p>
All variants of the Pick query language.<br>
<p>
And I gather there are quite a few other languages with sufficient syntactic sugar to read like English.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946116/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 2, 2023 16:43 UTC (Mon)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/946210/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And, completely unrelatedly to INFORM, Graham Nelson's "Inform 7" (briefly known as "Natural Inform"), a domain-specific language for writing parser-based interactive fiction. <a href="https://github.com/ganelson/inform/releases">https://github.com/ganelson/inform/releases</a><br>
<p>
It's a truly Knuthian project; in order to implement Inform 7, ganelson ended up implementing his own literate programming system. <a href="https://github.com/ganelson/inweb">https://github.com/ganelson/inweb</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor831083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 17:32 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/831083/">Link</a>] (43 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Adding LUA (or WebAssembly/JavaScript) has always made more sense to me than reinventing the wheel with ever-more complicated BPF. Virtual machines, JITs and scripting languages are a solved problem, why do it (badly) all over again?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 22:57 UTC (Wed)
                               by <b>Deleted user 129183</b> (guest, #129183)
                              [<a href="/Articles/831113/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Virtual machines, JITs and scripting languages are a solved problem, why do it (badly) all over again?</font><br>
<p>
I guess the problem is the entrenched FLOSS*/*n?x culture, which raises technical limitations of PDP-11 to the rank of âphilosophyâ (applied of course inconsistently), and seems to prefer homegrown, crappy, hacked-together âsolutionsâ (see âworse is betterâ) to things that are well-researched and well-designed. Oh, and of course the prevalent technological conservatism â I guess that one of reasons why Linux went with BPF is that it allows for writing the code in the holy C (1972; donât confuse with HolyC) instead of some of those newfangled things like Lua (1993).<br>
<p>
* Or maybe I should just say âopen sourceâ, since the biggest proponent of âfree softwareâ, Richard Stallman, doesnât seem to be fan of this approach â I guess that if the website on which weâre commenting was named Hurd Weekly News, we would see articles not about BPF and Lua-which-of-course-will-never-happen, but about GNU Guile integration in the Hurd servers, Scheme and, funnily â Lua and ECMAScript as the planned Guile front-ends.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2020 5:28 UTC (Fri)
                               by <b>kmweber</b> (guest, #114635)
                              [<a href="/Articles/831239/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; donât confuse with HolyC</font><br>
<p>
I feel like maybe seven people will understand this reference.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831252"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2020 11:36 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/831252/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&lt;raises hand&gt;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831252/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831284"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2020 14:07 UTC (Fri)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/831284/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;ve installed TempleOS.  I didn&#x27;t use it for anything productive though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831284/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor831609"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2020 19:19 UTC (Tue)
                               by <b>atai</b> (subscriber, #10977)
                              [<a href="/Articles/831609/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
RMs never suggested to put guile or any scripting language in the kernel<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831609/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2020 22:54 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/831799/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, but we *did* get a Lispish interpreter in GCC (removed in 2.7, IIRC: I haven&#x27;t done the archaeology to see if it was ever used for anything) and something kinda like eval in *glibc ld.so*, where you could invoke it as a program (with the usual binary name as the first arg, as per usual for direct ld.so invocations) and then feed it the names of functions with string or numeric arguments or nested function calls (more or less as in C source code) and have them executed via the distinctly nonportable __builtin_apply and __builtin_return builtins.<br>
<p>
(The latter awesome and terrible hack was done by Roland McGrath, not RMS, and I do rather wish we lived in a world where it was safe to keep in there. Honestly I think this is even more wonderfully crazy than putting an interpreter in the kernel, all the more so given that it was done in under a hundred lines, not counting the crucial builtins inside GCC.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor831340"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2020 13:16 UTC (Sat)
                               by <b>karim</b> (subscriber, #114)
                              [<a href="/Articles/831340/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I somewhat agree with this. Note, however, that this approach has already been tried in the past and was nack&#x27;ed by Ingo in as far as I can recall: <a href="https://github.com/ktap/ktap">https://github.com/ktap/ktap</a><br>
<p>
I suspect there might be some NIH going on here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831340/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2020 14:48 UTC (Sat)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/831344/">Link</a>] (35 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Kernel bpf, with the verifier, offers a staticly verified guarantee of normal program completion within a given number of executed instructions, which none of the other options offer.<br>
<p>
(But lack of such a static guarantee is also _why_ the other options can be more generally useful than bpf...)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2020 16:36 UTC (Thu)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/831756/">Link</a>] (34 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How does that work? If you can prove for every BPF program that it will terminate, then that implies that BPF is not Turing complete. If it&#x27;s not Turing complete, then you can&#x27;t compile Turing-complete languages like C to BPF. But GCC does seem to work on a backend that will emit BPF, so how does that work? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831760"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2020 17:43 UTC (Thu)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/831760/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In practice C is not Turing complete, because it runs on systems with limited memory and limited time. Outside of theoretical computer science, Turing completeness almost never seems a productive way to think about programming languages. All that matters is whether you can express a useful range of algorithms that run efficiently on your hardware.<br>
<p>
BPF can statically guarantee normal completion by forbidding loops, or forbidding loops which are not provably bounded - see <a href="https://lwn.net/Articles/794934/">https://lwn.net/Articles/794934/</a> - and avoiding function pointers and recursion etc. C compilers can unroll loops with static bounds, or convert a dynamic bound like &quot;for (i = 0; i &lt; n; ++i) ...&quot; into a static bound like &quot;for (i = 0; i &lt; MAX_N; ++i) if (i &lt; n) ...&quot;, and emit errors for code they can&#x27;t work out how to compile safely. So it only supports a restricted subset of C, but it&#x27;s a subset that still allows a lot of useful algorithms.<br>
<p>
(You could support a much larger subset of C by relaxing the requirement on &quot;normal&quot; completion and making BPF programs abort after a fixed number of instructions, and making sure the kernel safely handles aborted programs. It still wouldn&#x27;t be Turing complete but it&#x27;d be no less expressive than normal C. But at that point you&#x27;ve given up the most distinctive feature of BPF and you probably should have used WASM/etc instead.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831760/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831793"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2020 21:22 UTC (Thu)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/831793/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In practice C is not Turing complete, because it runs on systems with limited memory and limited time. Outside of theoretical computer science, Turing completeness almost never seems a productive way to think about programming languages.</font><br>
<p>
Yes it&#x27;s possible in theory solve the halting problem for C programs by running the program in question and waiting until it either terminates or reaches a state that it has been in before, one of which will necessarily happen because of the finite number of states that the machine could possibly be in.<br>
But in practice, this is utterly impractical because the number of possible states, while finite, is far too big. Thinking of C as a turing complete language thus gave the correct answer in practice: it&#x27;s not possible to determine in general whether a C program will halt. Considering the practical limitation of having finite memory on the other hand gives a positive answer that is complete bogus in practice. You got it *exactly the wrong way around*. Remember that next time you&#x27;re trying to be a smart-ass.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831793/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831928"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Turing pseudo-incompleteness</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2020 16:37 UTC (Sat)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/831928/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just to put that into perspective. The number of possible states of your computer is 2^2Â³â·, if we assume 16 GBytes of RAM. That&#x27;s a 456562320870-digit number, which I won&#x27;t paste here for obvious reasons.<br>
<p>
The number of distinct states a single computer can ever reach is about 2^(64*8+32+24+30), the exponent consisting of word size, #cores, and the log2 of cycles per seconds, seconds per year, and years until the Earth gets boiled into oblivion by way of the Sun going all red giant on us, respectively.<br>
<p>
598 is about 200 million times smaller than 2Â³â·.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831928/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831972"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2020 18:52 UTC (Sun)
                               by <b>scientes</b> (guest, #83068)
                              [<a href="/Articles/831972/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
LWN didn&#x27;t use to have so many smart-asses. They use to stick to hacker news. Yet another consequence of the very poor situation in the US and Europe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831972/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832329"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2020 23:18 UTC (Wed)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/832329/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We can do better than feeding the troll.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832329/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor831800"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 17, 2020 23:03 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/831800/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (You could support a much larger subset of C by relaxing the requirement on &quot;normal&quot; completion and making BPF programs abort after a fixed number of instructions, and making sure the kernel safely handles aborted programs. It still wouldn&#x27;t be Turing complete but it&#x27;d be no less expressive than normal C. But at that point you&#x27;ve given up the most distinctive feature of BPF and you probably should have used WASM/etc instead.)</font><br>
<p>
... or, y&#x27;know, Lua, which does exactly that.<br>
<p>
If &quot;the most distinctive feature of BPF&quot; is a restriction which dramatically limits the usefulness of programs and can provably be lifted without actually preventing the &quot;infloops prohibited&quot; thing that actually matters, while also allowing the verifier to be massively simplified at the huge cost of... an instruction counter, well, I&#x27;m not sure this is exactly a major advert for the language. However, the important thing about this feature is what it allows: JIT-compilation into native machine code which needs no interpretation (and obviously without an interpreter, instruction counting becomes impractical). *That* is the benefit of BPF&#x27;s bounded-loop guarantee.<br>
<p>
(I&#x27;d be inclined to say that for many use cases, particularly outside the networking layer, particular BPF programs are invoked rarely enough that JIT-compilation is not beneficial: it would seem nice to have a BPF variant which can only be interpreted and which *does* use instruction counting, permitting indirect calls, arbitrary looping, etc: this could then be used for contexts where speed was not crucial and instead you want generality. But that&#x27;s not what people have done, so...)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831800/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2020 5:16 UTC (Fri)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/831814/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To me, it seems entirely unclear that this feature of BPF was the right decision. It greatly increases the complexity, and TTBOMK, there exist no C (or C-ish) compilers which can actually generate code for it. (That said, there really is a trade-off -- it&#x27;s not _obviously_ the wrong decision, either.)<br>
<p>
LLVM has a BPF backend, but it basically operates on hope and luck. In general, LLVM cannot promise to generate BPF-that-will-pass-the-verifier. (See, e.g. <a href="https://lists.llvm.org/pipermail/cfe-dev/2020-June/065894.html">https://lists.llvm.org/pipermail/cfe-dev/2020-June/065894...</a> for some discussion on this). I don&#x27;t think BPF-with-verifier really even has a spec that a C compiler _could_ reasonably target! Of course, if you craft your input C code correctly, and the optimizer doesn&#x27;t do something too tricky, it does often work out in practice. But &quot;Your program will work if you&#x27;re lucky, but due to normal compiler optimizations, it might get mysteriously rejected instead -- good luck!&quot; is a really unsatisfying system design. I haven&#x27;t looked into it, but I&#x27;m gonna bet the GCC BPF backend has the same properties.<br>
<p>
But, I think you&#x27;re understating the real advantages that the BPF model provides -- KNOWING that the program is guaranteed to complete _normally_ is useful! If you instead simply count the number of executed-instructions, you can ensure that a program won&#x27;t run forever -- but only by aborting it, dynamically, once you&#x27;ve reached the limit.<br>
<p>
Imagine -- you&#x27;re running a instruction-counting version of BPF (or, say, kernel-Lua), and a BPF program is doing some important packet processing for a router. The current version of the program always executes less than $dynamic_instruction_limit instructions to process any packet, and everything is fine. You then modify the program -- adding just one more trivial &quot;clearly correct&quot; check -- and all of a sudden, you start hitting the limit and abort whenever you get a packet with a certain combination of properties which, put together, now go just over the limit. Of course, it doesn&#x27;t fail on every packet -- that would be too easy. This sort of surprise could very well cause a serious outage! And it _cannot happen_ with current BPF.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831836"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2020 13:35 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/831836/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I haven&#x27;t looked into it, but I&#x27;m gonna bet the GCC BPF backend has the same properties.</font><br>
<p>
This is unavoidable given that indirect function calling through function pointers and varargs are part of C, and BPF cannot really support either even in the absence of a verifier, though there is no need for the compiler to actually *crash* or emit invalid code when it sees such things.<br>
<p>
In theory you could implement indirect function calls using self-modifying code, implementing function pointers the way x86 compilers of yore implemented INT %reg, but that&#x27;s gross and self-modifying code isn&#x27;t a thing in BPF either, thank goodness). This is why xBPF exists, so that these things *can* be implemented, even if not verified: that way they can at least run in the simulator, so the GCC testsuite can stand a hope of passing.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831836/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2020 15:50 UTC (Fri)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/831862/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I'm afraid you've missed the point. Those issues you raise are trivial -- the compiler can simply prohibit indirect calls and varargs. You don't have a full C implementation, but that's ok. The compiler frontend can even report an error if the programmer attempts to use these features.
<p>
The <em>critical problem</em> in correctly compiling BPF is ensuring that loop iteration bounds and pointer accesses can be verified-safe, by the verifier implementation currently in the kernel (which changes, of course). Critically, the compiler optimizations should not turn a "verifiable" program into an "unverifiable" program!

<p>
You can write this function in a BPF program:
<pre>
  int foo(int* o, int v) { return o[v]; }
</pre>
<p>
And, that's fine, despite not being provably safe by itself. However, the function must only be <em>called</em> in a context where the verifier statically knows which object "o" points to, and that the integer "v" is known to be within the bounds of o's object. In order to check this, the verifier does simulated program execution through all possible branches, tracking min/max and known-bits for every value -- even across function calls. 
<p>
But this tracking cannot be 100% precise, and that imprecision breaks all sorts of normally-correct compiler transforms. One bug report for LLVM is that it optimized code like the following:
<pre>
int check_range(int v) {
  if (v &gt;= 4 &amp;&amp; v &lt;  7) return v;
  return 0;
}
</pre>
<p>
into (approximately -- of course the actual output is BPF-asm, not C):
<pre>
int check_range(int v) {
  unsigned v_offset = (unsigned)v - 4u;
  if (v_offset &lt; 3u) return v;
  return 0;
}
</pre>
<p>
This seems like a valid optimization...but it completely breaks the BPF kernel verifier. Now, the value which gets a narrowed range "v_offset", rather than "v". Ranges aren't propagated backwards, only forwards, so the narrowed range can't also be applied back to "v".
<p>
Thus, the return value of this function has the same value-range as the argument "v", rather than the intersection of the range of the argument "v", and [0, 3). If the caller subsequently calls <tt>foo(some_object, check_range(v))</tt>, the optimized program will fail to verify. Even though the unoptimized program did verify.
<p>
I have my doubts that this problem is even properly solvable in a normal C compilation model.

      
          <div class="CommentReplyButton">
            <form action="/Articles/831862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831875"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2020 16:48 UTC (Fri)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/831875/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; [0, 3)</font><br>
Minor correction: this should&#x27;ve been [0, 7).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831875/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2020 11:48 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/831913/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh yes, you&#x27;re quite right: suddenly needing perfectly accurate VRP *and* having to cope with a VRP model (in the kernel) which is, ah, intentionally not as full-blown as a compiler&#x27;s because nobody wants the verifier to slow down that much is a *big* problem. VRP before now has been the sort of thing where if it goes wrong you get a slightly worse optimization or points-to analysis or something like that. Now, suddenly, it affects correctness! And no C-like compiler I know of is really ready for that. (Obviously Rust has to, and anything else where range analysis of various sorts has semantic impact, but not C. Obviously everyone should be writing their BPF programs in Rust and targetting BPF :) )<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor831815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2020 5:28 UTC (Fri)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/831815/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; and obviously without an interpreter, instruction counting becomes impractical</font><br>
<p>
Not at all impractical. A JIT compiler can generate native code to maintain such a counter easily enough. You only need to update the counter for each basic block (and maybe split excessively-long blocks). The number of instructions in a block is constant, and there&#x27;s no need to abort _exactly_ at a particular instruction limit, as long as you guarantee to do so within some bound.<br>
<p>
You can likely further reduce overhead by only instrumenting just enough to ensure termination. (E.g., maybe you only count backwards branches and calls.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor831823"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2020 9:42 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/831823/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <p>You can compile a Turing complete language to a non-Turing complete language, by rejecting valid programs.
<p>The halting problem only says that you cannot classify all programs into one of two buckets: "halts" and "never halts"; it does not prevent you from classifying programs into three buckets: "halts", "never halts", and "probably halts, but might not halt". With this extra bucket in hand, you can now only accept programs which are in the "halts" bucket.
<p>The rest is a quality of implementation issue - how do you minimise the number of programs that halt but end up in the"probably halts, but might not halt" bucket?
      
          <div class="CommentReplyButton">
            <form action="/Articles/831823/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831888"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2020 21:41 UTC (Fri)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/831888/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You can compile a Turing complete language to a non-Turing complete language, by rejecting valid programs. </font><br>
<p>
If you reject valid programs, then you&#x27;re not compiling the Turing-complete language but a non-Turing-complete language that happens to be a subset of the Turing-complete one.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831888/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2020 13:33 UTC (Sat)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/831920/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <p>While that's true, it's a statement that only applies in theory - we compile Turing complete languages such as C down to finite state machines like x86-64 and AArch64 all the time, and there's no useful outcome from saying that we don't, in fact, compile C, we compile a non-Turing complete language that happens to be a subset of C.
      
          <div class="CommentReplyButton">
            <form action="/Articles/831920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831921"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2020 14:10 UTC (Sat)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/831921/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have already addressed this nonsense elsewhere:<br>
<p>
<a rel="nofollow" href="https://lwn.net/Comments/831793/">https://lwn.net/Comments/831793/</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831921/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831979"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2020 22:00 UTC (Sun)
                               by <b>sdalley</b> (subscriber, #18550)
                              [<a href="/Articles/831979/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
...so you are now in my rather short plonk list. The poor signal-to-noise ratio just isn&#x27;t worth it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831979/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2020 5:13 UTC (Mon)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/831991/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That remark was about the content of your post, not about your person. Thus it was not a personal insult by definition.<br>
<p>
Yes, calling a post &quot;nonsense&quot; is harsh. On the other hand, a discussion only works by listening to the other side&#x27;s arguments, and @farnz plainly didn&#x27;t do that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2020 8:48 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/831994/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <p>Actually, smurf, I believe that HelloWorld is making an argument without a point and refusing to listen to anyone who disagrees with him - this is emphasised by him pointing to a comment he made <em>in another subthread</em> ; Turing-completeness is of limited practical value, as it's an argument from theory. But in practice, we have no Turing machines to run programs on; we always run on finite state machines in as far as our physics goes (we have reason to believe that the distance over which you can communicate is finite, that everything is contained in quantum states, and that the number of quantum states in a finite space is also finite).
<p>If you are going to appeal to Turing-completeness, then you also need to explain why, in this case, the distinction you are drawing is helpful. Otherwise, it's just a claim that the observable universe is a finite space.
<p>As I said in my comment, which HelloWorld has completely and utterly failed to respond to with anything other than an insult, the question is not about Turing completeness - it's about which programs are rejected that could have been accepted. <em>That</em> is an interesting question, and worth considering. Are the programs rejected by compiling C to BPF actually interesting in this context, or are they of no consequence?
      
          <div class="CommentReplyButton">
            <form action="/Articles/831994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2020 23:31 UTC (Tue)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/832205/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Actually, smurf, I believe that HelloWorld is making an argument without a point and refusing to listen to anyone who disagrees with him - this is emphasised by him pointing to a comment he made in another subthread ; Turing-completeness is of limited practical value, as it&#x27;s an argument from theory. But in practice, we have no Turing machines to run programs on; we always run on finite state machines</font><br>
<p>
Yes, I pointed to a comment that I made in another subthread. In that thread excors wrote this:<br>
<font class="QuotedText">&gt; In practice C is not Turing complete, because it runs on systems with limited memory and limited time.</font><br>
This is the *exact same point* that you made:<br>
<font class="QuotedText">&gt; we compile Turing complete languages such as C down to finite state machines like x86-64 and AArch64</font><br>
<p>
<font class="QuotedText">&gt; If you are going to appeal to Turing-completeness, then you also need to explain why, in this case, the distinction you are drawing is helpful.</font><br>
I already did in my other comment. The point is that while the number of states a computer can be in is finite, it is still so large that there is no *practical* way for arbitrary programs whether they will halt. A computer is thus a good enough approximation of a turing machine *in practice* that results from theoretical compsci do carry over. And the âcompiling C to BPFâ use case clearly shows this: it can&#x27;t be done, which is why they can&#x27;t compile C to BPF but a less general subset of C.<br>
<p>
<font class="QuotedText">&gt; As I said in my comment, which HelloWorld has completely and utterly failed to respond to</font><br>
You just didn&#x27;t understand the response, and that is not a problem on my side. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832214"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2020 2:06 UTC (Wed)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/832214/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Consider these languages:<br>
<p>
1) C compiled to verifiable BPF<br>
2) C compiled to a finite x86 machine<br>
3) C compiled to a hypothetical unbounded machine<br>
4) C compiled to verifiable BPF then implemented on a universal Turing machine implemented in Conway&#x27;s Game of Life implemented on a hypothetical unbounded machine<br>
<p>
(By &quot;C&quot; I mean some C-like language that is appropriate for the target architecture, not strictly ISO standard C.)<br>
<p>
Theoretical CS says that the halting problem is solvable for 1, 2, and 4, but unsolvable for 3. Only 3 is Turing complete.<br>
<p>
In practice, you can only determine whether a program will halt in a reasonable amount of time on 1.<br>
<p>
Your original question was about how can GCC compile C to BPF. Obviously GCC can already compile C to x86 (and I assume you&#x27;re happy to say C-on-x86 really is C). So your question was about the difference between languages 1 and 2, and the difference is not in their Turing completeness, because both are incomplete.<br>
<p>
In general, proofs involving Turing machines seem perfectly happy to take a finite algorithm and make it exponentially more expensive, e.g. using unary representation for numbers, because it&#x27;ll remain finite (which is all they care about). The Game of Life UTM is a reasonable theoretical construction, despite being completely absurd in practice. So the techniques used to examine Turing completeness are very different to the techniques you need to practically determine if a program will halt in reasonable time. When trying to solve almost any practical problem, Turing completeness is an irrelevant distraction, which is why I pushed back against framing the question that way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832214/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor832227"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2020 8:52 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/832227/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; If you are going to appeal to Turing-completeness, then you also need to explain why, in this case, the distinction you are drawing is helpful.</font><br>
<font class="QuotedText">&gt; I already did in my other comment. The point is that while the number of states a computer can be in is finite, it is still so large that there is no *practical* way for arbitrary programs whether they will halt. A computer is thus a good enough approximation of a turing machine *in practice* that results from theoretical compsci do carry over. And the âcompiling C to BPFâ use case clearly shows this: it can&#x27;t be done, which is why they can&#x27;t compile C to BPF but a less general subset of C.</font><br>
<p>
That&#x27;s still avoiding the key point - the important question is nothing to do with the halting problem, but whether what you can compile from C to BPF (or x86-64, or AArch64) is useful. If the subset of C that compiles to BPF is sufficiently large and expressive, then it doesn&#x27;t matter that obscure capabilities are missing (e.g. true with AArch64, as the inability to have a single value in memory that needs 2**68 bits to represent it is not an issue). If it&#x27;s not large enough, then there&#x27;s a problem - but that requires not an appeal to Turing-completeness, but a pointer to language features that cannot be used in C-&gt;BPF compilation, together with an explanation of why those features matter in the real world.<br>
<p>
<font class="QuotedText">&gt; &gt; As I said in my comment, which HelloWorld has completely and utterly failed to respond to</font><br>
<font class="QuotedText">&gt; You just didn&#x27;t understand the response, and that is not a problem on my side.</font><br>
<p>
No, that is a problem on your side - you are assuming that if people don&#x27;t understand what you&#x27;re saying, it&#x27;s because they are the issue, and not your explanation. Taken to extremes, this attitude is why the British conquerors thought Africans were stupid - the Africans didn&#x27;t understand English, and therefore the problem was on their side.<br>
<p>
And I would note that this applies both ways round - you&#x27;ve ignored the meat of my disagreement in favour of showing off how clever you are and making statements about theoretical CS that don&#x27;t apply directly to the real world. Does that imply that you just don&#x27;t understand CS?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832227/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2020 10:12 UTC (Wed)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/832240/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That&#x27;s still avoiding the key point - the important question is nothing to do with the halting problem, but whether what you can compile from C to BPF (or x86-64, or AArch64) is useful.</font><br>
<p>
I started this thread, so I get to determine what the question was about. I asked how it&#x27;s possible to compile C to BPF when that is clearly impossible due to the halting problem (nitpicking about finite memory notwithstanding). And the answer is that they *don&#x27;t* compile C to BPF but only a subset. Whether that subset is useful or not is completely besides the point. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832241"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2020 10:17 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/832241/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <p>But, by that very statement, compiling C to x86-64 is also impossible, and yet you've said that the subset of C that compiles to x86-64 is fine by you, citing the fact that the limits on what C can be compiled to x86-64 are so large that they are practically not relevant.
<p>I'm asking you why you don't feel the same way about the subset of C that compiles to a practical BPF program - after all, I can just raise the limits on BPF (as we do with x86-64) to get into the same situation where the limits exist but are so huge that they amount to the same limits as x86-64.
      
          <div class="CommentReplyButton">
            <form action="/Articles/832241/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2020 12:05 UTC (Wed)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/832247/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s different precisely because you *cannot* simply raise the limits to fix the problem. BPF requires the program to be proven to normally terminate on all possible inputs, before the program can be run. This is an entirely different ball game from C or x86-64, which require no such proof.<br>
<p>
And -- of course -- most programs which in fact DO always terminate (without raising an exception, and within the proscribed run time bounds) cannot be proven to do so by the BPF verifier, and are therefore incorrectly rejected. This will not change if you increase the limits.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832300"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2020 17:40 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/832300/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Except that BPF has no such requirement - the kernel's eBPF validator will not accept a program that it cannot verify will terminate normally on all possible inputs, but that's a consequence of that restricted execution environment, and not an eBPF requirement.
<p>The same restriction would apply to x86-64 if the execution environment wanted to verify that it terminates on all possible inputs. That does not mean that you can't compile C to eBPF or x86-64 - it just means that in the context of compiling for the kernel eBPF validator (which would be the same for x86-64, or Lua bytecode, or WebAssembly), you can't use constructs that the verifier would reject.
      
          <div class="CommentReplyButton">
            <form action="/Articles/832300/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2020 21:13 UTC (Wed)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/832314/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Except that BPF has no such requirement</font><br>
<p>
Oh come on, this is a useless nitpick.<br>
<p>
There is effectively no use for eBPF, except to feed it to the Linux kernel. And for that purpose it must be verifiable. So, yes, fine -- when I said &quot;BPF requires&quot; I really meant &quot;BPF-with-verifier-as-implemented-by-the-linux-kernel-for-use-from-user-space requires&quot;. _That_ is the target we&#x27;re talking about in this whole thread, not the practically-useless &quot;BPF-without-verifier&quot; target.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2020 10:23 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/832361/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>But that limit can be raised, too - it's an artificial limit the kernel imposes so that it can safely accept user programs that get to hold the CPU. We can change that limit if it's a problem - we can (for example) allow programs that can't be proven to terminate a fixed number of executed instructions after which a default result is produced.
<p>Which puts us right back at the original problem that HelloWorld is continuing to not answer; what practical programs would you like to express in C that cannot be compiled down to eBPF right now, and can we fix that up?
      
          <div class="CommentReplyButton">
            <form action="/Articles/832361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor832323"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2020 22:34 UTC (Wed)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/832323/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I&#x27;m asking you why you don&#x27;t feel the same way about the subset of C that compiles to a practical BPF program</font><br>
<p>
Because that C subset is much, much smaller than the C subset that is implemented by common C implementations. It&#x27;s reasonable to say that C is a good approximation of a Turing machine (from a computability perspective), but the same cannot be said for the C subset that can be compiled to verified BPF.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832323/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832363"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2020 10:26 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/832363/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>Still no specifics - if there are things you want to express in C that cannot be compiled to eBPF as it stands today, what exactly are they? How difficult is it to change the rules of the verifier such that those things are accepted?
<p>The reason I don't care about x86-64 being more limited than C on a Turing Machine is that there's nothing practical we want to do with C that doesn't also run on x86-64; as far as I can see, the same currently applies with eBPF (in that, while there are things I can't do in C compiled to eBPF, they're also things I don't want to do with an eBPF program anyway).
      
          <div class="CommentReplyButton">
            <form action="/Articles/832363/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832377"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 24, 2020 12:26 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/832377/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Neither loops of runtime-computed length nor indirect function calls through function pointers are exactly unusual, yet neither are verifiable in BPF as it stands, and the latter is not even expressible (which was one of the motivations for xBPF).<br>
<p>
Indeed, both are so far from unusual that the BPF verifier itself makes extensive use of both.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832377/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832457"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 25, 2020 8:01 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/832457/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Neither loops of runtime-computed length</font><br>
<p>
And yet the original FORTRAN spec didn&#x27;t permit these either (nor did it deny them). It explicitly permitted storing the loop counter in a read-only register, which imho BPF should certainly permit.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832457/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor832303"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2020 19:31 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/832303/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I asked how it&#x27;s possible to compile C to BPF when that is clearly impossible due to the halting problem</font><br>
<p>
Well â¦ we&#x27;re pretty far away from the kind of complexity where the halting problem, in the CS theory sense of that word, would be a meaningful boundary for verifying BPF-or-whatever programs.<br>
<p>
There are lots of valid algorithms that can easily be proven to yield a correct result within some small bounded runtime â but which you cannot write in BPF because its set of operations is incomplete and/or because its verifier is too dumb.<br>
<p>
This difference matters because a somewhat-extended instruction set plus an improved verification algorithm (with back propagation and a couple of other tricks) might well be able to cope with a large-enough class of BPF programs so that the current problems, esp. with optimizing compilers, can be solved.<br>
<p>
This kind of verifier probably is too large and complex to implement inside the kernel, but doing it in userspace and signing the result would work just as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832303/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor831997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">I believe our editor already asked you to stop with the personal insults...</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2020 9:16 UTC (Mon)
                               by <b>sdalley</b> (subscriber, #18550)
                              [<a href="/Articles/831997/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;Nonsense&quot; is actually an OK thing to call an argument if it doesn&#x27;t make any sense. I had just followed HelloWorld&#x27;s own link to where he accuses subscribers worthy of a good deal more respect than his behaviour deserves, of being smart-arses. I prefer not to waste time with such unpleasantness.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor831082"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 9, 2020 17:37 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/831082/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder whether it&#x27;d be possible to run a benchmark of something like this test in both userspace interpreted-Lua and LuaJIT, in order to get a handle on the actual performance difference after optimization. Comparing BPF to &quot;plain&quot; Lua is hardly fair, after all, and 500x slowdown somewhat unacceptable.<br>
<p>
On the other hand, if nothing else running Lua is easily two orders of magnitude more accessible than BPF, to people who want to actually get things done instead of fighting with a BPF compiler and its limitations. (Been there, done that, thrown in the towel in favor of more satisfactory pursuits.) This alone is a rather powerful argument in favor of adding Lua IMHO.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831082/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831128"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2020 6:24 UTC (Thu)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/831128/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
500kpps is not kernel scale number. You can have the same performance on the usual proxy servers in userpsace. Lua in the kernel sounds like &#x27;oh, I have a hammer. Isn&#x27;t it a nice nail shines out there?&#x27;. Why in the kernel? Userspace was created for those things, wasn&#x27;t it? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831128/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831133"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2020 7:30 UTC (Thu)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/831133/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can say the same thing about BPF. A BPF interpreter should be about as fast as non-JITted Lua.<br>
<p>
Transitioning each and every message to userspace requires a context switch (and/or a cache transfer between CPUs) at minimum. That kills performance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831133/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor831134"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2020 7:30 UTC (Thu)
                               by <b>edeloget</b> (subscriber, #88392)
                              [<a href="/Articles/831134/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Doing it in the kernel means that you still use the kernel network stack. If you plan to do it in user space as afast as possible then you have to extract the network stack (for example using DPDK) which is a burden of its own (but possible: we&#x27;re doing it ; it&#x27;s not pretty and we still have rare bugs we do not understand).<br>
<p>
(but for the record, I also think this is a hammer-based solution; there is a limit to what the kernel should do &quot;in the name of performance&quot;; does this announce the return of the HTTP server module?)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831134/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor831339"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2020 13:11 UTC (Sat)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/831339/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If someone is willing to add Lua, they could also eliminate the artificial restrictions of bpf.<br>
<p>
The current state of things is really unfortunate, because you cannot _actually_ compile C to bpf. Well, rather, you can compile, but most nontrivial programs will be rejected by the bpf verifier when you try to load it into the kernel.<br>
<p>
The verifier requires that all programs be statically analyzable to determine that the program will terminate, and that it is statically impossible for the program to ever access out of bounds memory. There is, by design, no runtime &quot;failure&quot; -- every bpf program that passes the verifier is guaranteed to terminate with a valid return value from the end of the program.<br>
<p>
This is certainly an interesting property! But, this makes bpf very much not a generic architecture, and furthermore, impossible to reliably target with a C compiler. Even if you&#x27;ve carefully written your code to be verifier-safe, normal compiler optimizations may foil the static analysis, and break your program.<br>
<p>
Yet, these verifier restrictions are not necessary -- *if* you&#x27;re willing to admit the possibility of a program which can (safely!) fail to return a result when run.<br>
<p>
Supporting Lua necessarily admits such a possibility of failure (e.g. by execution timeout, excessive memory allocation, etc etc). If that&#x27;s acceptable, the same could surely be allowed for bpf, and result in a more generally usable system.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831339/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831822"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2020 9:29 UTC (Fri)
                               by <b>HelloWorld</b> (guest, #56129)
                              [<a href="/Articles/831822/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The way the BPF verifier ensures termination appears to be rather simplistic. More sophisticated mechanisms do exist, such as these:<br>
<p>
<a rel="nofollow" href="http://docs.idris-lang.org/en/latest/tutorial/theorems.html#hints-for-totality">http://docs.idris-lang.org/en/latest/tutorial/theorems.ht...</a><br>
<a rel="nofollow" href="http://ats-lang.sourceforge.net/DOCUMENT/INT2PROGINATS/HTML/x2500.html">http://ats-lang.sourceforge.net/DOCUMENT/INT2PROGINATS/HT...</a><br>
<p>
However while this does allow for more complex programs, I&#x27;m not sure how useful it is in practice at this time. For one, even if you prove that a program will run for a finite amount of time, that amount may well be longer than the age of the universe. These approaches also require additional training and education for programmers to use them effectively.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831822/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor831150"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2020 11:55 UTC (Thu)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/831150/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder why Lua with its multiple incompatibilities between releases and not WebAssembly, which is designed to provide tight sandboxes while allowing to use most programming languages these days? Big plus of WebAssembly is that it allows multi threading while tightly controlling memory consumption. Plus pure interpreter is rather small (<a href="https://github.com/wasm3/wasm3">https://github.com/wasm3/wasm3</a>  claims to fit under 100KB for code and runtime) and compatibility story for WebAssembly is very good.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831150/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2020 6:46 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/831244/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I wonder why Lua with its multiple incompatibilities between releases and not WebAssembly,</font><br>
<p>
Probably because WebAssembly is 20+ years younger.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor831295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2020 18:12 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/831295/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; there are already [BPF] compilers for C and P4,</font><br>
<p>
Any idea which language(s) most BPF code comes from? These two? I felt this is the bit of information really missing from the (excellent) report for a true &quot;Apples to Apples&quot; comparison with Lua. Maybe I&#x27;m the only non-BPF expert reading it :-)<br>
<p>
<p>
<font class="QuotedText">&gt; The BPF VM has momentum and acceptance ...</font><br>
<p>
... in the Linux kernel community. This is obviously hard to gauge but I suspect the BPF &quot;momentum&quot; is small compared to Lua&#x27;s momentum is the larger space of small, embedded VMs. Plus it&#x27;s not like no LUA user has safety and security concerns.<br>
<p>
<p>
<font class="QuotedText">&gt; Herbert said that will be a hard sell; XDP started with the idea that it would be pluggable, but it is now simply a BPF hook.</font><br>
<p>
It&#x27;s not clear to me why the _initial idea_ would be a hard sell?<br>
<p>
<p>
<font class="QuotedText">&gt; Netdev organizer Jamal Hadi Salim said that there is a need for both scripting and compiled code for networking task</font><br>
<p>
This sounds like the Lua VM runs much higher level code than the BPF VM but how higher really? Lua is a very simple language and XDPLua and XDP/BPF had the same performance in this (artificial?) example.<br>
<p>
This is what I find very impressive about Lua design choices BTW and clearly a big reason for its success: packing in one language all the programming features that are very expressive yet cost very little.<br>
<p>
PS: please share a link to the slides; couldn&#x27;t find them.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832129"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 22, 2020 10:56 UTC (Tue)
                               by <b>pctammela</b> (guest, #126687)
                              [<a href="/Articles/832129/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The material is available here: <a href="https://netdevconf.info/0x14/session.html?talk-linux-network-scripting-with-lua">https://netdevconf.info/0x14/session.html?talk-linux-netw...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832129/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor831352"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2020 16:49 UTC (Sat)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/831352/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Having seen the C side of a part-Lua application, with bad -Wcast-qual, not even âconstâ clean, etc. I wonder how this is used this much *at all*.<br>
<p>
Inspecting SNIâ¦ while I *told* people that SNI is a privacy violation and should be *REMOVED*, not furthered, this is beyond what I had foreseen.<br>
<p>
GET SNI OFF TLS *NOW!*<br>
<p>
Itâs nothing more than a bad excuse for not using IPv6 IP-based vhosts, or wildcard or multi-SNA certificates.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831352/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831376"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2020 1:16 UTC (Sun)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/831376/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is a draft rfc &quot;TLS encrypted client hello&quot; which fixes this privacy issue, finally.<br>
<p>
<a href="https://tools.ietf.org/html/draft-ietf-tls-esni-07">https://tools.ietf.org/html/draft-ietf-tls-esni-07</a><br>
<p>
China is already adjusting their country&#x27;s firewall to block connections where clients request this extension, of course...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831376/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831378"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2020 3:22 UTC (Sun)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/831378/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems unlikely that obscuring the hostname is really that feasible on the modern web, at least according to the &quot;What can you learn from an IP?&quot; paper from last year. The only solution I can think of is onion routing like Tor.<br>
<p>
<a href="https://irtf.org/anrw/2019/slides-anrw19-final44.pdf">https://irtf.org/anrw/2019/slides-anrw19-final44.pdf</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831378/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2020 16:19 UTC (Sun)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/831410/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, at the least, it can make collecting hostname data not effectively _foolproof_, which is a good thing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor831891"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 18, 2020 22:08 UTC (Fri)
                               by <b>xyzzy</b> (guest, #1984)
                              [<a href="/Articles/831891/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
SNI is great for virtual hosting behind a single IPv4 address. My small IT business used it to pack customers into containers on the same server.  I&#x27;d love a world where all the eyeballs had v6 but that&#x27;s not the world we&#x27;re in. <br>
<p>
SNI is also great for filtering. We buy filtered internet to reduce the risk of our kids seeing something they shouldn&#x27;t. I look with horror upon encrypted DNS and encrypted SNI and will block them if I can.  If Lua in the kernel lets me built an OpenWRT router with performant content filtering that sounds great to me! <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831891/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor831894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2020 0:05 UTC (Sat)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/831894/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ad 1: as I said, lame excuse. Youâd want to be looking at wildcard and multi-sAN certificates instead.<br>
<p>
Ad 2: I shudder at the distrust you do towards your kids and the amount of spying instead of doing parenting right. (Iâm not the right person to talk about this with though, so I wonât respond to this particular issue.) But even so, Iâm asking to *drop* SNI, not to merely encrypt it, and *especially* not to make it mandatory, as those idiots did.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/831894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor832112"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2020 19:57 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/832112/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Iâm asking to *drop* SNI,</font><br>
<p>
May I ask _whom_ you&#x27;re asking that nicely?<br>
<p>
<font class="QuotedText">&gt; I wonât respond to this particular issue.</font><br>
<p>
I think you already did.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/832112/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor834014"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2020 9:27 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/834014/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We&#x27;re having Lua in haproxy which has similar constraints as the kernel (limited execution time, shared memory, multi-threaded etc). While the Lua language isn&#x27;t exactly beautiful (looks more like incremental improvements over something initially much simpler), it&#x27;s definitely targetted at light embedded environments.<br>
<p>
You configure how much memory its stack may use, you also configure the maximum number of instructions it will execute before yielding, and it shows pretty decent performance. Overall there&#x27;s no way to end up eating all memory or in an infinite loop there. At best a bogus script will keep the CPU at 100% just like a userland program would, but the machine would remain totally responsive.<br>
<p>
Personally speaking I don&#x27;t regret that choice at all for haproxy. Some would have liked more modern or more elegant languages like JS, but these ones are resource hogs that cannot be embedded anywhere on a real-wolrd machine. Lua sits reasonably well at the junction of safe, fast and usable.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/834014/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor837574"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Lua in the kernel?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 18, 2020 6:44 UTC (Wed)
                               by <b>SiriusDev.Net</b> (subscriber, #115124)
                              [<a href="/Articles/837574/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would suggest we just go brave, raise the bar and include Java VM in Kernel. Field tested, industry accepted VM. Byte-code nicely maps to Spark assembly. Also lacks explicit pointers so rock solid safe. Why not?<br>
<p>
Idiotic ideas are infinite in numbers so this is why it is pointless to even discuss them. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/837574/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
