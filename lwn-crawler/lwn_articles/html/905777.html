        <!DOCTYPE html>
        <html lang="en">
        <head><title>Ushering out strlcpy() [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/905777/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/906068/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/905777/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Ushering out strlcpy()</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 25, 2022</br>
           </div>
With all of the complex problems that must be solved in the kernel, one
might think that copying a string would draw little attention.  Even with
the hazards that C strings present, simply moving some bytes should not be
all that hard.  But string-copy functions have been a frequent subject of
debate over the years, with different variants being in fashion at times.
Now it seems that the BSD-derived <a
href="https://man.openbsd.org/strlcpy.3"><tt>strlcpy()</tt></a> function
may finally be on its way out of the kernel.
<p>
In the beginning, copying strings in C was simple.
Your editor's dog-eared, first-edition copy of <i>The C Programming
Language</i> provides an implementation of <tt>strcpy()</tt> on page 101:
<p>
<pre>
    strcpy(s, t)
    char *s, *t;
    {
        while (*s++ = *t++)
	    ;
    }
</pre>
<p>
This function has a few shortcomings, the most obvious of which is that
it will overrun the destination buffer if the source string is too long.
Developers working in C eventually concluded that this could be a problem,
so other string-copying functions were developed, starting with <a
href="https://man7.org/linux/man-pages/man3/strncpy.3p.html"><tt>strncpy()</tt></a>:
<p>
<pre>
    char *strncpy(char *dest, char *src, size_t n);
</pre>
<p>
This function will copy at most <tt>n</tt> bytes from <tt>src</tt> to
<tt>dest</tt>, so, if <tt>n</tt> is no larger than the length of
<tt>dest</tt>, then that array cannot be overrun.  <tt>strncpy()</tt> has a
couple of quirks, though.  It is defined to NUL-fill <tt>dest</tt> if
<tt>src</tt> is shorter than <tt>n</tt>, so it ends up always writing the
full array.  If <tt>src</tt> is longer than <tt>n</tt>, then <tt>dest</tt>
will not be NUL-terminated at all — an invitation to trouble if the caller
does not carefully check the return value.  That return value is <strike>the
address of the first NUL character written to <tt>dest</tt> unless
<tt>src</tt> is too long, in which case <tt>strncpy()</tt> returns
<tt>&amp;dest[n]</tt> — an address beyond the actual array</strike>
<tt>dest</tt> regardless of whether truncation occurs or not.  As a result,
checking for truncation is a bit tricky and often not done.  [Thanks to
Rasmus Villemoes for pointing out the error in our earlier description of
the <tt>strncpy()</tt> return value.]
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
<h4><tt>strlcpy()</tt> and <tt>strscpy()</tt></h4>
<p>
The BSD answer to the problems with <tt>strncpy()</tt> was to introduce a
new function called <tt>strlcpy()</tt>:
<p>
<pre>
    size_t strlcpy(char *dest, const char *src, size_t n);
</pre>
<p>
This function, too, will copy a maximum of <tt>n</tt> bytes from
<tt>src</tt> to <tt>dest</tt>; unlike <tt>strncpy()</tt>, it will always
ensure that <tt>dest</tt> is NUL-terminated.  The return value is always
the length of <tt>src</tt> regardless of whether it was truncated in the
copy or not; developers must compare the returned length against <tt>n</tt>
to determine whether truncation has occurred.
<p>
The first uses of <tt>strlcpy()</tt> in the kernel entered
briefly during the 2.4 stable series — sort of.  The media subsystem had a
couple of implementations defined as:
<p>
<pre>
    #define strlcpy(dest,src,len) strncpy(dest,src,(len)-1)
</pre>
<p>
As one might imagine, there was not a lot of checking of return values
going on at that point.  That macro disappeared relatively quickly,
but a real <tt>strlcpy()</tt> implementation appeared in the <a
href="https://lore.kernel.org/lkml/Pine.LNX.4.44.0305261903330.2164-100000@home.transmeta.com/">2.5.70
release</a> in May 2003; that release also converted many callers in the
kernel over to this new function.  Everything seemed good for quite some
time.
<p>
In 2014, though, criticism of <tt>strlcpy()</tt> started to be heard,
resulting in, among other things, an <a href="/Articles/612244/">extended
discussion</a> over whether 
to add an implementation to the GNU C library; to this day, glibc lacks
<tt>strlcpy()</tt>.  Kernel developers, too,
started to feel disenchanted with this API.  In 2015, <a
href="/Articles/659214/">yet another string-copy function</a> was added to
the kernel by Chris Metcalf:
<p>
<pre>
    ssize_t strscpy(char *dest, const char *src, size_t count);
</pre>
<p>
This function, like the others, will copy <tt>src</tt> to <tt>dest</tt>
without overrunning the latter.  Like <tt>strlcpy()</tt>, it ensures that
the result is NUL-terminated.  The difference is in the return value; it
is the number of characters copied (without the trailing NUL byte) if the
string fits, and <tt>-E2BIG</tt> otherwise.
<p>
<h4>Reasons to like <tt>strscpy()</tt></h4>
<p>
Why is <tt>strscpy()</tt> better?  One claimed advantage is the return
value, which makes it easy to check whether the source string was truncated
or not.  There are a few other points as well, though; to get into
those, it is instructive to look at <a
href="https://elixir.bootlin.com/linux/v5.19.3/source/lib/string.c#L125">the
kernel's implementation of <tt>strlcpy()</tt></a>:
<p>
<pre>
    size_t strlcpy(char *dest, const char *src, size_t size)
    {
	size_t ret = strlen(src);

	if (size) {
	    size_t len = (ret &gt;= size) ? size - 1 : ret;
	    memcpy(dest, src, len);
	    dest[len] = '\0';
	}
	return ret;
    }
</pre>
<p>

One obvious shortcoming is that this function will read the entire source
string regardless of whether that data will be copied or not.  Given the
defined semantics of <tt>strlcpy()</tt>, this inefficiency simply cannot be
fixed; there is no other way to return the length of the source string.
This is not just a question of efficiency, though; as recently <a
href="/ml/linux-kernel/CAHk-=wi+xbVq++uqW9YgWpHjyBHNB8a-xad+Xp23-B+eodLCEA@mail.gmail.com/">pointed
out</a> by Linus Torvalds, bad things can happen if the source
string is untrusted — which is one of the intended use cases for this
function.  If <tt>src</tt> is not NUL-terminated, then <tt>strlcpy()</tt>
will continue merrily off the end until it <i>does</i> find a NUL byte,
which may be way beyond the source array — if it doesn't crash first.
<p>
Finally, <tt>strlcpy()</tt> is subject to a race condition.  The length of
<tt>src</tt> is calculated, then later used to perform the copy and
returned to the caller.  But if <tt>src</tt> changes in the middle, strange
things could happen; at best the return value will not match what is
actually in the <tt>dest</tt> string.  This problem is specific to the
implementation rather 
than the definition, and could thus be fixed, but nobody seems to think
it's worth the effort.
<p>
The <a
href="https://elixir.bootlin.com/linux/v5.19.3/source/lib/string.c#L151">implementation
of <tt>strscpy()</tt></a> avoids all of these problems and is also more
efficient.  It is also rather more complex as a result, of course.
<p>
<h4>The end of <tt>strlcpy()</tt> in the kernel?</h4>
<p>
When <tt>strlcpy()</tt> was first introduced, the intent was to replace
all of the <tt>strncpy()</tt> calls in the kernel and get rid of the latter
function altogether.  In the 6.0-rc2 kernel, though, there are still nearly
900 <tt>strncpy()</tt> call sites remaining; that number grew by two in the
6.0 merge window.  At the introduction of <tt>strscpy()</tt>, instead,
Torvalds explicitly <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=30c44659f4a3e7e1f9f47e895591b4b40bf62671">did
not want</a> to see any sort of mass conversion of <tt>strlcpy()</tt>
calls.  In 6.0-rc2, there are just over 1,400 <tt>strlcpy()</tt> calls and
nearly 1,800 <tt>strscpy()</tt> calls.
<p>
Nearly seven years later, the attitude seems to have changed a bit;
Torvalds now says that "<q>strlcpy() does need to go</q>".  A number of
subsystems have made conversion passes, and the number of
<tt>strlcpy()</tt> call sites has fallen by 85 since 5.19.  Whether it will
ever be possible to remove <tt>strlcpy()</tt> entirely is unclear;
<tt>strncpy()</tt> is still holding strong despite its known hazards and a
decision to get rid of it nearly 20&nbsp;years ago.  Once something gets
into the kernel, taking it out again can be a difficult process.
<p>
There may be hope, though, in this case.  As Torvalds <a
href="/ml/linux-kernel/CAHk-%3DwjGmhaE-Y8GqWKPtWYOi%3DbOarFgo7UkzHNoOVEKnkXXrQ%40mail.gmail.com/">observed</a>
in response to a set of conversions from Wolfram Sang, most of the callers to
<tt>strlcpy()</tt> never use the return value; those could all be converted
to <tt>strscpy()</tt> with no change in behavior.  All that would be needed, he
suggested, was for somebody to create a <a
href="https://coccinelle.gitlabpages.inria.fr/website/">Coccinelle</a>
script to do the work.  Sang <a
href="/ml/linux-kernel/YvhXzarjOLEJ8nsW@shikoro/">rose to the challenge</a>
and has created <a
href="https://git.kernel.org/pub/scm/linux/kernel/git/wsa/linux.git/log/?h=renesas/strlcpy">a
branch with the conversions done</a>.  That work, obviously, 
won't be considered for 6.0, but might show up in a 6.1 pull request.
<p>
That would leave relatively few <tt>strlcpy()</tt> users in the kernel.
Those could be cleaned up one by one, and it might just be possible to get
rid of <tt>strlcpy()</tt> entirely.  That would end a 20-year sporadic
discussion on the best way to do bounded string copies in the kernel — all
of those remaining <tt>strncpy()</tt> calls notwithstanding — at
least until some clever developer comes up an even better function and
starts the whole process anew.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#String_processing">String processing</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/905777/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor906093"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 16:16 UTC (Thu)
                               by <b>sub2LWN</b> (subscriber, #134200)
                              [<a href="/Articles/906093/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Whether it will ever be possible to remove strlcpy() entirely is unclear; strncpy() is still holding string despite its known hazards and a decision to get rid of it nearly 20 years ago.</font><br>
<p>
/still holding string/still holding strong/? strngcpy<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906093/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906420"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 6:51 UTC (Tue)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/906420/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Please do NOT post typos in the article as comments, send them to lwn@lwn.net instead. </font><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906420/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor906094"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 16:23 UTC (Thu)
                               by <b>IanKelling</b> (subscriber, #89418)
                              [<a href="/Articles/906094/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; strncpy() is still holding string despite its known hazards</font><br>
<p>
Funny.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906094/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906102"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 18:08 UTC (Thu)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/906102/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;n&quot; in &quot;strncpy&quot; stands for &quot;never&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906102/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906109"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 19:47 UTC (Thu)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/906109/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it&#x27;s just catastrophically named. It should be something like strtofixed() or strpad() or something; what it does is fundamentally to copy a null-terminated string into a fixed-size, non-null-terminated, buffer. Like if you have a struct of fixed-width string fields, ISAM-style. So the destination isn&#x27;t a C-style string, and shouldn&#x27;t be treated as such.<br>
<p>
Of course, this makes the function much less useful than the average C programmer assumes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906109/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906120"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strncpy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 22:03 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/906120/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I understand it, this function exists because it&#x27;s how you do exactly this operation (copy a C-style string into some fixed width buffer) somewhere in early Unix, maybe the filesystem. Its authors knew exactly what they were doing, and this function makes sense for their intended application, but as you say the name suggests somebody might find it useful in very different circumstances.<br>
<p>
But, on the other hand notice the newer APIs are still awful. The language just doesn&#x27;t give us much to work with by having this terrible string type. I think we might have been better off if C hadn&#x27;t admitted to a string type at all (ie there are no string functions, and no &quot;&quot; literal syntax) and then presumably C89 might have introduced one but there would have been a war to decide how that works (since C89 mostly codifies popular real world C implementations) and I can&#x27;t believe that 0-terminated wins such a war, even if Pascal-style (length-prefixed) wins that&#x27;s a less awful world than our world.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906120/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906125"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">strncpy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 0:46 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/906125/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Raymond Chen reports that this was the case at least as far back as System V (and yes, it was in the filesystem): <a href="https://devblogs.microsoft.com/oldnewthing/20050107-00/?p=36773">https://devblogs.microsoft.com/oldnewthing/20050107-00/?p...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906125/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor906099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 17:30 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/906099/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is checkpatch capable of complaining about new uses of deprecated functions? That seems like a good way of getting a gradual change with minimal noise, which could then be followed by an eventual cleanup in code that nobody&#x27;s touched for a few years.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor906103"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 18:15 UTC (Thu)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/906103/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Finally, strlcpy() is subject to a race condition.</font><br>
<p>
No, it doesn&#x27;t count! It&#x27;s like saying that strdup() has race condition because it calls strlen() inside. Of course, string must be stable during strlcpy().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906103/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906121"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 22:04 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/906121/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes. In fact any C code reading memory without using atomics, where that memory is concurrently modified, is undefined behaviour. So all C implementations of string copying will be &quot;subject to a race condition&quot; in that sense.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906121/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906122"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 22:42 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/906122/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I will guess that while what you wrote is literally true, the same reasoning applies for almost everything Linux (as an operating system kernel written largely in C) does and so Linus will pronounce it stupid and decide it doesn&#x27;t apply.<br>
<p>
Mechanically, reading a byte and then writing the byte works, the data you get might have tearing, but it&#x27;s still just bytes. Byte 14 of a 20 byte structure you copied might, unaccountably, be 0xF6 even though that&#x27;s inconsistent with the other bytes, but it can&#x27;t actually take some eldritch value outside of the 256 possible bit patterns. If you&#x27;re writing a GTK+ mail app, you just shouldn&#x27;t think this way, it&#x27;s going to get you into trouble - but if you&#x27;re writing an operating system kernel this is far from the shakiest proposition you&#x27;re relying on.<br>
<p>
Anyway, I think the race condition is a practical problem for untrusted input. If I know the kernel will read my program&#x27;s buffer, find there&#x27;s a NUL byte in position 814, and then cheerfully copy 814 bytes into some other structure expecting the result to be a 814 byte C-style string, then I can cause some real mischief, which might have been impossible to pull off if the kernel page-copies my entire data structure instead.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906122/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906130"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 2:12 UTC (Fri)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/906130/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Anyway, I think the race condition is a practical problem for untrusted input. If I know the kernel will read my program&#x27;s buffer, find there&#x27;s a NUL byte in position 814, and then cheerfully copy 814 bytes into some other structure expecting the result to be a 814 byte C-style string, then I can cause some real mischief, which might have been impossible to pull off if the kernel page-copies my entire data structure instead.</font><br>
<p>
Yes, userspace trying to trick the kernel is a valid concern... but I do not get how that is related to strlcpy() topic at all as that function is not anyway safe to call on a userspace pointer!<br>
<p>
This whole untrusted and/or racy source argument to strlcpy() is something I don&#x27;t understand at all... if there is no guarantee on source string being NUL-terminated, then strscpy() will read past the source buffer if it happens to be smaller than the destination buffer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906130/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 7:42 UTC (Fri)
                               by <b>LtWorf</b> (subscriber, #124958)
                              [<a href="/Articles/906148/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it will read past regardless of the size of the destination buffer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor906104"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 18:48 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/906104/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Out of curiosity, I decided to look up how Rust handles string copying/overwriting, and found that:<br>
<p>
* They call it String::replace_range(), and it&#x27;s a method rather than a free function. It also takes an argument describing which range of the string you want to replace (which can be the entire string, if desired).<br>
* Most of the actual work is in Vec::splice(), which works for arbitrary vectors (dynamic arrays).<br>
* They resize the string if the sizes don&#x27;t match.<br>
* In general, this whole operation is a lot easier in Rust than in C, because Rust&#x27;s strings are heap-allocated dynamic arrays, which can be resized in the first place. So it&#x27;s not solving the same problem (e.g. in some contexts, heap allocation might be seriously problematic).<br>
* If you don&#x27;t want to use heap-allocated strings and &quot;just want a dumb array,&quot; you can use the copy_from_slice() method on primitive slices instead, which is functionally equivalent to memcpy. It panics if the slices have different lengths, but slices know their lengths so at least it&#x27;s cheap to check for that in advance.<br>
* It is illegal to have two mutable references (or one mutable and one immutable reference) to the same slice at the same time, so you can&#x27;t copy_from_slice with overlapping arguments (hence they use memcpy instead of memmove). They provide copy_within() for the possibly-overlapping use case, or if the arguments wouldn&#x27;t actually overlap, you can use split_at_mut() to break it apart into two separate slices.<br>
* There are similar memcpy/memmove-like functions for raw pointers, but Rust considers raw pointers to be inherently unsafe, and so those functions are unsafe as well.<br>
* Rust doesn&#x27;t have a notion of null-terminated u8 arrays (that I could find), and so the exact &quot;copy a C string&quot; problem is not really a thing that exists in Rust. There is std::ffi::CString, but it doesn&#x27;t have any methods for directly manipulating its contents; it looks like it&#x27;s &quot;just&quot; an intermediary for converting between Rust strings and raw pointers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906104/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906108"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 20:31 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/906108/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; it&#x27;s a method rather than a free function</font><br>
<p>
This won&#x27;t be obvious to non-Rust people, and might not even be immediately obvious to new Rust programmers, but, in a sense all Rust&#x27;s functions are/ can be written as free functions.<br>
<p>
Here&#x27;s some idiomatic Rust using a method call:<br>
<p>
    let mut news = &quot;Linux Weekly News&quot;.to_owned();<br>
    news.replace_range(..5, &quot;FreeBSD&quot;);<br>
<p>
But while it isn&#x27;t idiomatic in this case, you could also just write:<br>
<p>
    String::replace_range(&amp;mut news, ..5, &quot;FreeBSD&quot;);<br>
<p>
As well as moving news to be the first parameter, we also need to write &amp;mut to show that we want to pass the mutable reference, not move news itself into the replace_range function as a parameter. The method call sugar does that work for us by examining the signature of the String::replace_range function and seeing how the self parameter is used.<br>
<p>
It really is just sugar, the code emitted will be identical (modulo perturbing an optimiser somewhere).<br>
<p>
This is also how Rust resolves ambiguities. If Goose implements both AirlinePassenger and Bird but both traits define a fly() method, that&#x27;s no problem in Rust, I can write:<br>
<p>
   if goose.is_wealthy() { AirlinePassenger::fly(&amp;goose); } else { Bird::fly(&amp;goose); }<br>
<p>
In contexts where the code knows about Bird but not AirlinePassenger, goose.fly() is unambiguous and does what you expect, and likewise vice versa.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906108/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906150"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 7:56 UTC (Fri)
                               by <b>nyanpasu64</b> (guest, #135579)
                              [<a href="/Articles/906150/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought that method calls on &amp;[mut] dyn T variables (trait object references, fat pointers) couldn&#x27;t be rewritten as free function calls, since you&#x27;re calling a function pointer stored behind the fat pointer itself, and I thought free function calls are statically resolved. But it turns out that `Trait::func(obj)` can actually invoke a dynamic dispatch, if `obj` is a trait object fat pointer.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906150/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor906317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2022 23:45 UTC (Sun)
                               by <b>KJ7RRV</b> (guest, #153595)
                              [<a href="/Articles/906317/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Is this the Rust equivalent of <code>str.strip(" string with padding ")</code> as opposed to <code>(" string with padding ").strip()</code> in Python?


      
          <div class="CommentReplyButton">
            <form action="/Articles/906317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906487"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 17:10 UTC (Tue)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/906487/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have used Python but I&#x27;m definitely not an expert so the rest of this may be wrong, especially in subtle ways.<br>
<p>
It&#x27;s very similar, however whereas self in Python is just a convention, self in Rust is a keyword, using it signals that you mean for this function to be a method, and so the type is implied. Not all functions implemented for a type in Rust have to be methods. Consider these two functions in the implementation of Goose:<br>
<p>
 fn is_wealthy(&amp;self) -&gt; bool { self.net_worth &gt; 1000 }<br>
<p>
 fn is_healthy(goose: &amp;Self) -&gt; bool { self.hit_points &gt; 90 }<br>
<p>
The is_wealthy function can be used as a method, the self keyword means if I have a Goose named jimmy I can write:<br>
<p>
 if jimmy.is_wealthy() { println!(&quot;Swimming in money&quot;); } else { println!(&quot;Aww, poor Jimmy&quot;); }<br>
OR<br>
 if Goose::is_wealthy(&amp;jimmy) { println!(&quot;Swimming in money&quot;); } else { println!(&quot;Aww, poor Jimmy&quot;); } <br>
<p>
But the is_healthy function is not a method, it&#x27;s only an associated function. That capitalized word &quot;Self&quot; is also a keyword, but it just means &quot;my type&quot; and so we could have written Goose instead. So I always need to write:<br>
<p>
  if Goose::is_healthy(&amp;jimmy) { println!(&quot;Feeling good&quot;); } else { println!(&quot;Jimmy needs a goose doctor&quot;); }<br>
<p>
I believe this distinction does not exist in Python. The reason it is used in Rust is that sometimes a type exists mostly as a &quot;pass through&quot; for some other type, and so by having only associated functions instead of methods it is hidden from accidental method invocations. For example Rc and Arc are smart pointers offering reference counting, but they sport associated functions not methods, so that you need to say e.g. Rc::downgrade(&amp;thing) and thus if thing.downgrade() already means something else the reference counted type doesn&#x27;t get in your way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906487/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906489"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 17:12 UTC (Tue)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/906489/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Gah, I should always check these compile before hitting submit.<br>
<p>
fn is_healthy(goose: &amp;Self) -&gt; bool { goose.hit_points &gt; 90 }<br>
<p>
There is no &quot;self&quot; parameter on is_healthy because it isn&#x27;t a method, and so the version I wrote above can&#x27;t work since it refers to a self variable which doesn&#x27;t exist.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906489/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor906138"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 6:43 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/906138/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      With all these design constraints explained, it seems quite complicated to efficiently fold HTTP headers in a request, which simply consists in replacing the optional CR and the LF preceeding a space or tab, with a space or tab (i.e. overwrite two bytes in a buffer at known positions). In C that could be as simple as:
<pre><code>
void fold(char *hdr)
{
   char *lf;
   for (lf = hdr; (lf = strchr(lf, '\n')); lf++) {
       if (*(lf + 1) != ' ' &amp;&amp; *(lf + 1) != '\t')
          continue;
       if (lf &gt; hdr &amp;&amp; *(lf - 1) == '\r')
         *(lf - 1) = ' ';
       *lf = ' ';
   }
}
</code></pre>

Here your description makes it sounds like you'd have to deal with complicated blocks of known lengths which would be error-prone, or even worse, dynamic allocation which is a total no-go in protocol parsers. Or maybe there's a way to still keep the simple solutions such as above (possibly in unsafe mode) ?



      
          <div class="CommentReplyButton">
            <form action="/Articles/906138/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 10:30 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/906152/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You&#x27;ll notice that in the newer protocols HTTP/2 and HTTP/3 the headers are no longer expressed this way. Today this folding is also considered obsolete in HTTP/1.1 and servers are entitled to just return a 400 error for requests with folded headers.<br>
<p>
However, the byte-oriented code you&#x27;ve written can indeed be expressed in Rust, from Rust&#x27;s point of view these are just bytes (type u8) in a mutable slice of some sort. Rust knows how big the slice is, (the unforgivable mistake in C is that it doesn&#x27;t know how big whatever char *hdr is pointing at is) and so we can safely change the bytes within it.<br>
<p>
I assume you don&#x27;t consider the behaviour if hdr is in fact pointing at something that is not a zero-terminated string (ie a buffer overflow with undefined behaviour) to be desirable, and so we don&#x27;t need Rust&#x27;s unsafe which is the only way to duplicate that.<br>
<p>
<a href="https://gist.github.com/rust-play/59883fd0aecbfa0c988f2bf09da34def">https://gist.github.com/rust-play/59883fd0aecbfa0c988f2bf...</a><br>
<p>
[ I have not tested this code, but I believe it does what your C does ]<br>
<p>
One very obvious difference is that Rust doesn&#x27;t have pointer arithmetic, so we&#x27;re writing the Rust in terms of indexing into the slice. The compiler, of course, is free to implement this with identical machine code.<br>
<p>
Rust doesn&#x27;t think that &quot;any slice of bytes&quot; is a string, but, on the other hand, it also thinks most of C&#x27;s &quot;string&quot; features are reasonable things to do to a slice of bytes, so this is mostly a matter of terminology. You can for example call make_ascii_lowercase() on a slice. If it wasn&#x27;t actually ASCII text before then what this does is well defined but probably not very useful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906243"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 15:48 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/906243/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You&#x27;ll notice that in the newer protocols HTTP/2 and HTTP/3 the headers are no longer expressed this way. Today this folding is also considered obsolete in HTTP/1.1 and servers are entitled to just return a 400 error for requests with folded headers.</font><br>
<p>
Yep absolutely, but I thought about it because it was a perfectly valid real-world example of something that can be done extremely efficiently when you manipulate bytes and that one cannot afford to process as individual strings using allocations nor doing memmove() etc.<br>
<p>
<font class="QuotedText">&gt; I assume you don&#x27;t consider the behaviour if hdr is in fact pointing at something that is not a zero-terminated string (ie a buffer overflow with undefined behaviour) to be desirable, and so we don&#x27;t need Rust&#x27;s unsafe which is the only way to duplicate that.</font><br>
<p>
Absolutely. These are final implementation details. Just like it would be fine to require to know the length upfront and use strnchr() if needed.<br>
<p>
<font class="QuotedText">&gt; <a href="https://gist.github.com/rust-play/59883fd0aecbfa0c988f2bf...">https://gist.github.com/rust-play/59883fd0aecbfa0c988f2bf...</a></font><br>
<font class="QuotedText">&gt; [ I have not tested this code, but I believe it does what your C does ]</font><br>
<p>
Thanks! [ I have not tested mine either :-) ]<br>
So overall once presented as a byte array like this it looks similar and should be of equivalent complexity. It may miss some optimizations that can be done for strchr() for example, that would allow to skip 8 bytes at once (or possibly even more using vector instructions), but overall it looks similar.<br>
<p>
<font class="QuotedText">&gt; One very obvious difference is that Rust doesn&#x27;t have pointer arithmetic, so we&#x27;re writing the Rust in terms of indexing into the slice</font><br>
<p>
I&#x27;m fine with this, I&#x27;m used to both forms in C as well, it&#x27;s just a matter of preference. a[b] is exactly the same as b[a] and *(a+b) or *(b+a) in C, so writing -1[ptr] is valid but only useful to confuse the reader :-)<br>
<p>
<font class="QuotedText">&gt; Rust doesn&#x27;t think that &quot;any slice of bytes&quot; is a string, but, on the other hand, it also thinks most of C&#x27;s &quot;string&quot; features are reasonable things to do to a slice of bytes, so this is mostly a matter of terminology. You can for example call make_ascii_lowercase() on a slice.</font><br>
<p>
Makes sense. The only thing you&#x27;ll miss then is the machine-specific optimizations that went into a number of C libraries for byte search, fill or move (which can be significant for strchr() or memset()).<br>
<p>
<font class="QuotedText">&gt; If it wasn&#x27;t actually ASCII text before then what this does is well defined but probably not very useful.</font><br>
<p>
Sure but the point of such protocols precisely is that you don&#x27;t care as they&#x27;re byte-oriented and very fast to process when done right.<br>
<p>
Thanks!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906243/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 16:59 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/906248/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe Rust is perfectly capable of emitting libc calls in contexts where it is safe to do so, because many of the slice primitives are described with phrases like &quot;using memcpy&quot; in the documentation. That suggests to me that they really do emit a memcpy(3) function call, or at least something which LLVM will transform into a memcpy call during compilation. So that&#x27;s probably going to perform just as well as C, because under the hood, it is C.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 18:54 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/906254/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here it&#x27;s different, it&#x27;s not a matter of relying on libc calls for other calls but rather a question of ability for a compiler to detect a well-known pattern from something that doesn&#x27;t look similar. Just like we constantly have to help the C compiler catch what we&#x27;re trying to do by sometimes making ugly constructs, any other language&#x27;s compiler will have the same problem, and it&#x27;s not necessarily trivial to match an strchr() pattern in the loop above. And that&#x27;s actually part of the things I often don&#x27;t like in more abstract or stricter languages, which is less freedom to tell the compiler what you&#x27;re trying to do.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 20:47 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/906258/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t understand. You said:<br>
<p>
<font class="QuotedText">&gt; The only thing you&#x27;ll miss then is the machine-specific optimizations that went into a number of C libraries for byte search, fill or move (which can be significant for strchr() or memset()).</font><br>
<p>
strchr and memset are libc functions, so I interpreted &quot;a number of C libraries&quot; as meaning &quot;libc, and possibly other libraries, but mostly libc.&quot; If libc has machine-specific optimizations, and Rust can emit libc calls into the LLVM IR (which can then be inlined if it is advantageous to do so), then what exactly is the problem? Most of the interesting libc functions have some sort of safe wrapper in the Rust stdlib, and the language also provides a full FFI for calling arbitrary C code, so I really don&#x27;t see what disadvantage you&#x27;re talking about here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906261"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 21:05 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/906261/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m not speaking about being able or not to emit libc calls. I can understand that it can emit them when the call is obvious. What I&#x27;m saying is that just like any compiler it&#x27;s extremely unlikely to spot situations where this is possible based on a loop like above. Even for a human it&#x27;s not trivial to spot this. If it had strings mapped to arrays for example, like in C, I would easily imagine that we&#x27;d have an equivalent of strchr() applying to that array that would rely on the libc call. But a loop like this with tests in the middle is extremely unlikely to be turned to a series of strchr() on one given value. And by the way in such a parser it should be left to the developer&#x27;s choice, because short headers would cost more with an strchr() call while long ones would benefit from a fast strchr(). Thus it would be nice to be able to call the equivalent of strchr() on positions in this array. But overall it looks like reimplementing the C string model that many people dislike.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906261/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906264"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 22:00 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/906264/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, sure, but you wouldn&#x27;t write that loop (in Rust) in the first place. You&#x27;d call str::find[1] with suitable arguments, and then it&#x27;s the implementation&#x27;s problem to emit the most efficient way to do this. Since one possible set of arguments to str::find can be statically proven to be exactly equivalent to strchr (purely in terms of the type system, so this can be done in the monomorphization pass), the implementation should emit strchr if it is optimal to do so. If the implementation does not in fact emit strchr, and you think this is suboptimal, then you should file a bug with them. But don&#x27;t tell me it&#x27;s impossible. It&#x27;s clearly possible.<br>
<p>
[1]: <a href="https://doc.rust-lang.org/std/primitive.str.html#method.find">https://doc.rust-lang.org/std/primitive.str.html#method.find</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906264/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 9:37 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/906321/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To be honest, I think you lost me, especially since initially I understood that it had to be handled as an array of bytes and not a string, but that sort of comforts me in the idea that it can quickly become very complicated to write simple yet efficient functions for a number of low-level use cases. And my fear with languages that are complicated to use is that either the developer will introduce logic bugs when trying to hack around constraints, or that they will give up and fall back to the default, much less efficient solution (which is often what we see in practice).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor906265"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 22:37 UTC (Fri)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/906265/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<a href="https://docs.rs/memchr/latest/memchr/">https://docs.rs/memchr/latest/memchr/</a> is the uh, extremely complicated result of somebody who really cares about the sort of optimizations you&#x27;re discussing attacking this problem. It is of course named after C&#x27;s memchr() function which is exactly like strchr() except not specialized for C-style 0-terminated strings.<br>
<p>
Specifically this is by BurntSushi, who also wrote ripgrep the very fast grep implementation. So yes, you certainly can (at least amortized over huge input slices) go significantly faster than the naive loop I wrote if you are willing to work a lot harder than I did, or to use somebody else&#x27;s work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906265/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 9:57 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/906322/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks! But indeed as I said above, that&#x27;s the limit, i.e. it seems it can quickly become quite complicated to achieve C-like efficiency for real-world use cases that are routinely found in low-level programming. I mean, we both spent less than 5 minutes writing each of our versions, and they&#x27;re probably as easy to read for a developer of each language so at this point that&#x27;s fine. However the rust one will be significantly less efficient on medium sized headers (user-agent, cookie, referer etc) and suddenly it seems to become quite a bit more difficult to try to recover that last part because there are different ways to hack around this that one must explore. And for me, ease of use is a concern because I want to see developers spend more time thinking about design, reliability and security than about how to find their way through strict types and constraints, otherwise these constraints can quickly reduce the quality of what they&#x27;re doing. At least that&#x27;s my feeling.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906324"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 11:42 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/906324/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And for me, ease of use is a concern because I want to see developers spend more time thinking about design, reliability and security</font><br>
<p>
Aren&#x27;t these constraints? Just different ones?<br>
<p>
<font class="QuotedText">&gt; than about how to find their way through strict types and constraints, otherwise these constraints can quickly reduce the quality of what they&#x27;re doing. At least that&#x27;s my feeling.</font><br>
<p>
I think you&#x27;re over-thinking it.<br>
<p>
The question is, are those artificial constraints, or are they real constraints that need to be addressed somewhere. I&#x27;ll give you an example - from databases of course :-)<br>
<p>
In Pick, the underlying datatype is string. The database is built around handling random-length strings. So when I&#x27;m designing my database, because Pick separates the underlying value from the display format, THERE IS NO CONCEPT OF LENGTH in the database itself. So the only time I have to concern myself with &quot;how long is a piece of string&quot; is when I&#x27;m trying to output it. Compare that with eg C, which is a plentiful source of buffer over-runs because programmers have no clue how long a piece of string is, or Fortran which iirc is a plentiful source of truncated data because programmers get it wrong ...<br>
<p>
Same thing with numbers. Why should the programmer be forced to address &quot;what sort of number is this?&quot;. Who cares whether it&#x27;s integer / float / double / whatever, and it&#x27;s far too easy to make the wrong choice and end up with precision errors etc. ffs it&#x27;s a number!<br>
<p>
Bear in mind, I don&#x27;t know Rust, but I get the impression most / all of these constraints are questions which MUST be answered - like &quot;who owns this variable, and when?&quot;. Not knowing the answer to that is a serious bug. Whereas on the other hand &quot;is this number a float or a double?&quot; most of the time is both a nuisance and an irrelevance. And mathematically meaningless to boot, but get it wrong and you&#x27;ve just corrupted your data.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906324/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 14:11 UTC (Mon)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/906325/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  ffs it&#x27;s a number!</font><br>
<p>
*hollow mathematical laughter*<br>
<p>
Once you put it in your digital computer, it&#x27;s a digital computer number.<br>
<p>
The mathematics of the many kinds of digital computer number are their own distinctive branches of mathematics, which diverge from the &quot;natural&quot; rules of &quot;everyday&quot; arithmetic in a variety of ways.<br>
<p>
When you are operating in contexts such as, say, frivolous Javascript programs for the entertainment of the idle, where enormous performance costs are routinely accepted (if they weren&#x27;t, you wouldn&#x27;t be using Javascript in the first place) and correctness is an afterthought, &quot;ffs it&#x27;s a number!&quot; is an unremarkable stance.<br>
<p>
(Javascript has two native numeric types. &quot;number&quot; is IEEE 754 double precision floating point (but you are allowed to use bitwise ops on its purported integer value!), and &quot;bigint&quot; is an &quot;arbitrary-precision&quot; computer integer type for holding integer values outside the precise integer range of IEEE 754 double precision floating point.)<br>
<p>
When you are operating in the contexts that C or Rust are intended for, where correctness, speed of execution, runtime memory footprint, etc. all matter, it is not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 14:34 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/906365/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; When you are operating in the contexts that C or Rust are intended for, where correctness, speed of execution, runtime memory footprint, etc. all matter, it is not.</font><br>
<p>
When you are operating in the contexts that Pick is intended for, where correctness (or the lack of it) can land you in jail, and speed is all important - because lack of it means that the job needed for tomorrow won&#x27;t be ready until next week ...<br>
<p>
STEP BACK AND LOOK AT THE FOREST!<br>
<p>
I&#x27;m not saying your concerns aren&#x27;t valid IN SOME CIRCUMSTANCES. But forcing the programmer to decide what sort of number, when the problem at hand doesn&#x27;t give a shit, is not wise. Equally, not bothering the programmer to worry about things like buffer over-runs, use-after-free, and all that stuff when the problem at hand lends itself to making those mistakes, is equally stupid.<br>
<p>
YOU NEED TO WORRY ABOUT THE THINGS THAT MATTER. And my worry is that wtarreau is missing the big picture. What&#x27;s the difference between a good design woefully implemented, and a crap design that works as designed? I don&#x27;t know, but both are probably useless for the intended purpose ...<br>
<p>
I see it time and time again, people can&#x27;t see the big picture, and when the resulting brown stuff hits the rotating blades, they&#x27;re completely stunned by something that was blatantly obvious to anyone who took a step back. Maybe it helps that I&#x27;m pretty new in my current work role (and I&#x27;m coming at it from a completely different angle to most of colleagues), but the amount of poor design / fire-fighting fixes / technical debt I see is horrendous. Luckily, I&#x27;m being left alone to do what I think is right to fix all this - I have to explain what and why I&#x27;m doing it, but my manager sees the benefits (and I&#x27;m new extra resource), so I leave the rest of them to carry on while I try and fix the technical debt.<br>
<p>
<font class="QuotedText">&gt; &quot;ffs it&#x27;s a number!&quot; is an unremarkable stance.</font><br>
<p>
It&#x27;s also an unremarkable stance for big accountancy systems managing huge projects - I worked on Sellafield THORP.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906391"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 17:07 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/906391/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But forcing the programmer to decide what sort of number, when the problem at hand doesn&#x27;t give a shit, is not wise.</font><br>
<p>
But you wrote the correct term: &quot;programmer&quot;. That person got some training to learn that the machine they were going to program for uses discrete numbers, doesn&#x27;t have infinite memory and so on. Otherwise it&#x27;s just a human. Programmers know that no machine can accurately represent Pi. Programmers know that it&#x27;s extremely dangerous to store numeric identifiers in Javascript because by default they&#x27;re stored as floats and that if their absolute value is larger than 2^52 they will lose precision and possibly confuse some people, sessions, digital signatures or whatever. Nowadays a lot of people think that after having hacked in a text area on an online training site they are programmers. And the day they write code like: if (a &lt; b) do_something(); else if (a == b) do_domething() else if (a &gt; b) do_something_else(), they don&#x27;t understand why there are some entire classes of values for a and b which result in no function being called. But this is taugh in computer courses, that remain an absolute necessity when writing programs aimed at running on real computers. Otherwise, as you&#x27;re saying, some bugs can put you to jail (or even put someone else to jail).<br>
<p>
Processing protocols requires to handle them using the types they were designed with. Most of the time the common type is the byte and protocol elements are just sequences of bytes. In this case it makes sense to be able to handle them as naturally as possible. That&#x27;s why C strings are overly used in that area even though they don&#x27;t shine for their efficiency in this specific purpose, but they&#x27;re wonderful for many other cases.<br>
<p>
And I really *do* want programmers to care for the machine they&#x27;re writing code for. The languages can help, the compilers as well, and in that regard C is not your ally with its absurd precedence, annoying shifts and unclear type promotion, but it remains extremely reliable, so much that it still runs almost the entierety of the internet&#x27;s core services and operating systems, many systems which would probably not exist if the only choices by then were much more lenient in terms of resource usage, or too constraining in terms of development. Some will say it&#x27;s not user-friendly, others will say it is user-friendly, it&#x27;s just selective about who its friends are. My personal feeling is that it could be way better but that I&#x27;m not willing to deal with caprices from another language that constantly puts itself in my way when I&#x27;m trying to do something simple for the machine. When I can&#x27;t do something in C I do it in asm, and I grumble that the interface between the two is ugly and not very transparent (though it improved lately in gcc by allowing to return flags).<br>
<p>
<font class="QuotedText">&gt; amount of poor design / fire-fighting fixes / technical debt I see is horrendous</font><br>
<p>
That&#x27;s true and it seems to speed up with newer languages sadly, where developers seem to prefer to throw away everything and restart again and again, without rethinking the design. When your language of choice requires a bit of thinking, you&#x27;re becoming very stingy about your code and you prefer to be certain to get the design right. You end up drawing stuff on paper before writing code and that significantly helps keeping code running well for decades with an acceptable level of maintenance.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906391/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 17:54 UTC (Mon)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/906394/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And the day they write code like: if (a &lt; b) do_something(); else if (a == b) do_domething() else if (a &gt; b) do_something_else()</font><br>
<p>
I firmly agree with the general thrust of your post, but I do feel the need to point out that even in Javascript, with its historical dedication to Doing Something That Isn&#x27;t Showing An Error And Refusing To Run when presented with ill-formed code, that code gets an ingestion-time syntax error at the first &#x27;else&#x27;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor906392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 17:08 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/906392/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is, the real numbers are uncountable, which means that there is no encoding of the real numbers in (finite-length) bit strings (even allowing for variable-length bit strings, arbitrary precision encodings, etc.). Furthermore, there exist non-computable real numbers (real numbers for which there does not exist any algorithm that can output their digits), and even if you restrict yourself to the computable reals, there are many computable numbers for which basic arithmetic is problematic (for example, zero and &quot;2^-n, if Turing machine M halts in exactly n steps, or else zero if it never halts&quot; are both computable numbers, but deciding whether they are equal is equivalent to the halting problem and hence undecidable).<br>
<p>
You can&#x27;t just say &quot;it&#x27;s a number&quot; and call it a day. The math doesn&#x27;t work out. You have to make some sort of compromise, and operate on some computable subset of the real numbers, which in practice is going to be a great deal smaller than the computable numbers. You can shout in ALL CAPS about how programmers should not be required to think about that compromise, but clearly somebody has to, at some point. If you just want to make the accountants happy, then use some sort of decimal fixed point (like SQL&#x27;s DECIMAL type) or something similar. That&#x27;s not &quot;just a number&quot; because it still does intermediate rounding, but at least it&#x27;s doing the rounding that accountants probably want it to do.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906397"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 18:26 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/906397/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; You can&#x27;t just say &quot;it&#x27;s a number&quot; and call it a day. The math doesn&#x27;t work out. You have to make some sort of compromise, and operate on some computable subset of the real numbers, which in practice is going to be a great deal smaller than the computable numbers. You can shout in ALL CAPS about how programmers should not be required to think about that compromise, but clearly somebody has to, at some point. If you just want to make the accountants happy, then use some sort of decimal fixed point (like SQL&#x27;s DECIMAL type) or something similar. That&#x27;s not &quot;just a number&quot; because it still does intermediate rounding, but at least it&#x27;s doing the rounding that accountants probably want it to do.</font><br>
<p>
:-)<br>
<p>
Pick mostly uses decimal fixed point (and makes the programmer think about it), but it really is &quot;a number is 14sf to 4dp unless you tell me otherwise&quot;, which is sufficient for most purposes. It&#x27;s a case of &quot;if the sort of number matters,  then I need to do something about it, but &quot;number&quot; covers most use cases&quot;.<br>
<p>
Apologies if I&#x27;m maligning him, but wtarreau came across as complaining about Rust&#x27;s memory checking and borrow checking and all the minutiae of system programming that causes real grief it it goes wrong.<br>
<p>
People get too bogged down in the minutiae of what they&#x27;re doing, and it can be very hard to step back and ask yourself &quot;does this REALLY matter?&quot;. Quite often the answer is &quot;no&quot;. If the computable subset is larger than your problem space (as it usually is), do you really want to be forced to pay strict attention to it? :-) And when the answer is &quot;yes&quot; then you do have to pay attention.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906397/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor906408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 23:09 UTC (Mon)
                               by <b>notriddle</b> (subscriber, #130608)
                              [<a href="/Articles/906408/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Not knowing the answer to that [ownership question] is a serious bug. </font><br>
<p>
No, it just doesn’t compile.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor906421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 7:03 UTC (Tue)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/906421/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Same thing with numbers. Why should the programmer be forced to address &quot;what sort of number is this?&quot;. Who cares whether it&#x27;s integer / float / double / whatever, and it&#x27;s far too easy to make the wrong choice and end up with precision errors etc. ffs it&#x27;s a number!</font><br>
<p>
There is no such thing as &quot;just a number&quot; in mathematics, even. An integer is a completely different sort of thing from a real number, or a rational number, or a complex number. <br>
<p>
What is the result of calling the sine function on &quot;a number&quot;? What is the result of taking the square root of &quot;a number&quot;? <br>
<p>
&quot;Bigint&quot; is a _very_ good default for a high-level programming or scripting language, for integers. But most of them keep using floating-point numbers despite their obvious flaws for a good reason: it&#x27;s very hard to come up with anything else that will survive the kinds of operations people want to do on them.<br>
<p>
You could use rational numbers, but there are lots of numbers people want to use that aren&#x27;t rationals, and the fractional representations of rationals get huge very quickly when you use them. And even if you want to keep them only within a certain user-configured precision, knowing when to perform that reduction is not trivial if you want it to be performant (it shouldn&#x27;t be after every operation).<br>
<p>
Now there are other possible representations. You could represent numbers as functions that compute the value of the number to a given precision. You could represent numbers in many ways. What exactly a &quot;number&quot; is really isn&#x27;t clear.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor906396"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2022 19:26 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/906396/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However the rust one will be significantly less efficient on medium sized headers (user-agent, cookie, referer etc)</font><br>
<p>
This might be more compelling with experimental results but I&#x27;d be astonished if it made a discernible difference actually. Without such results I don&#x27;t see any reason I shouldn&#x27;t argue the exact opposite, that your solution is needlessly complicated and dangerous.<br>
<p>
BurntSushi did this work because of ripgrep which is processing rather more data than a HTTP User-agent header. I can well believe it&#x27;s worth doing all that for running grep over an entire monorepo or a few weeks log files or whatever but I have my doubts for Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0 which is, as I count it, 70 bytes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906396/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906515"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2022 3:51 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/906515/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It actually does matter when you have to deal with DDoS for example, or when processing logs/traces.<br>
<p>
Optimized grep like those relying on the Boyer-Moore algorithm are extremely effective to look for patterns in large blocks (a complete file), because the initialization cost is very quickly amortized (often after just a few lines).<br>
<p>
HTTP headers are painful because they&#x27;re rarely large enough to amortize many optimizations, need to be processed at very high frequency and as such often suffer from even a function call or the construct of a likely()/unlikely().<br>
<p>
I wrote a log parser quite a long time ago, that I&#x27;m still using, that processes between 2 and 4 GB of logs per second, looking for some fields or producing statistics on output. It shared similar principles, and all the time was spent in fgets() looking for the LF! I reimplemented this in asm for i386 by then, then for x86_64, then added an option to choose whether or not to use memchr() instead when glibc improved and could sometimes be faster and compensate for the extra cost of the function call, and the differences can be significant. I then adopted similar mechanisms for HTTP headers and gained ~10% global performance probably indicating +50-100% on the parsing alone, so that does count quite a lot.<br>
<p>
For the HTTP header example above, among the possibilities to be faster are taking into account the abysmally low probability to meet the pattern. On average sized headers it could be faster to use the fast grep twice over the block if you know it&#x27;s fit in L1 cache, searching for &quot;\n &quot; then &quot;\n\t&quot; in the whole block at once. Since most headers will be at least ~100 bytes long, this could amortize the cost of initializing the lookup function.<br>
<p>
But I definitely agree with you that in any case this must be measured, confronted to various pathological patterns (and that&#x27;s what I&#x27;m doing all day long, trashing lots of apparently smart code changes that don&#x27;t pass the performance test on real data).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906515/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor906477"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 14:11 UTC (Tue)
                               by <b>andy_shev</b> (subscriber, #75870)
                              [<a href="/Articles/906477/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good explanation why Rust sucks... No, thanks, we do not need page faults and sleeping context in the critical sections in the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906477/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 15:26 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/906483/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t see the connection. The general purpose `std::string::String` might not work in all contexts, but there is a *lot* of code that doesn&#x27;t work in such contexts anyways. The kernel is certainly free to make its own String which can be used from interrupts and such (with appropriate error handling of course); there&#x27;s nothing magic about String in Rust and is &quot;just&quot; library code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906490"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 17:33 UTC (Tue)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/906490/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The kernel does have its own String:<br>
<p>
https://rust-for-linux.github.io/docs/alloc/string/struct.String.html<br>
<p>
Here&#x27;s the equivalent Rust standard String (well, alloc::string::String, userspace Rust programmers would use it from std but it&#x27;s equivalent)<br>
<p>
<a href="https://doc.rust-lang.org/alloc/string/struct.String.html">https://doc.rust-lang.org/alloc/string/struct.String.html</a><br>
<p>
You&#x27;ll notice that the standard String has a lot of stuff that the kernel doesn&#x27;t. And the kernel only has try_reserve() so you can&#x27;t just go around reserve()ing memory which might not exist as userspace programmers often do.<br>
<p>
The kernel has (or will eventually get) all of core, the Rust library where core language features that are not just inside the compiler live, so that&#x27;s stuff like an Option type, a Result type, most of the methods you think about for built-in types. But it doesn&#x27;t have std, the library where OS depending features like File I/O and Networking live, and it has its own rather different alloc, a library where the allocator and related features (such as a growable String) live.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906490/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor906484"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 15:43 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/906484/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Rust standard library isn&#x27;t fully suitable for use in a kernel (or many other embedded environments), but that&#x27;s okay, you can find or implement your own equivalent types that meet your requirements (just like you&#x27;d have to when using C). E.g. there&#x27;s heapless::String (<a href="https://docs.rs/heapless/latest/heapless/struct.String.html">https://docs.rs/heapless/latest/heapless/struct.String.html</a>) as a fixed-capacity string without dynamic allocation, where functions that might exceed the string&#x27;s capacity (like String::push) return a Result&lt;&gt; so it&#x27;s always safe and the caller has to explicitly decide how to handle that case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906484/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor906117"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 21:32 UTC (Thu)
                               by <b>unixbhaskar</b> (guest, #44758)
                              [<a href="/Articles/906117/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 ...also, I was bumped onto a mail, where Linus was explaining it to Steve Fench about the whole story...fascinating ....from time to time Linus wrote loooong response to someone about some particular topic ...that mail is one of them ...if anyone curious enough to find it out, please read that response and explanations too. <br>
<p>
I certainly did learn about that topic by going over his response a few times. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906117/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906126"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 1:13 UTC (Fri)
                               by <b>rcampos</b> (subscriber, #59737)
                              [<a href="/Articles/906126/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m just curious to ask for a link :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906126/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906157"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 10:08 UTC (Fri)
                               by <b>unixbhaskar</b> (guest, #44758)
                              [<a href="/Articles/906157/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you go to lore.kernel.org and look for &quot;strlcpy note&quot; as the subject line ..then you should get it. <br>
<p>
You might try this link for the subject ..then look for that specific mail in that listing :<br>
<p>
Search in all mail<br>
<p>
<a href="https://lore.kernel.org/all/?q=strlcpy">https://lore.kernel.org/all/?q=strlcpy</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906157/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor906158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 10:18 UTC (Fri)
                               by <b>unixbhaskar</b> (guest, #44758)
                              [<a href="/Articles/906158/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Precisely....<br>
<p>
FYI : <a href="https://lore.kernel.org/all/CAHk-=wi+xbVq++uqW9YgWpHjyBHNB8a-xad+Xp23-B+eodLCEA@mail.gmail.com/">https://lore.kernel.org/all/CAHk-=wi+xbVq++uqW9YgWpHjyBHN...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor906170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 13:35 UTC (Fri)
                               by <b>patrick_g</b> (subscriber, #44470)
                              [<a href="/Articles/906170/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I was bumped onto a mail, where Linus was explaining it to Steve Fench about the whole story...fascinating</font><br>
<p>
I think a link to this email is provided in this LWN article.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor906123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2022 22:12 UTC (Thu)
                               by <b>kees</b> (subscriber, #27264)
                              [<a href="/Articles/906123/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Replacing strlcpy is pretty straightforward. Here the issue tracker item for it: <a href="https://github.com/KSPP/linux/issues/89">https://github.com/KSPP/linux/issues/89</a><br>
<p>
Replacing strncpy has some special corner cases, but I really hope we can get it purged too. I wrote up the per-caller conversion flow chart in the issue for it:<br>
<a href="https://github.com/KSPP/linux/issues/90">https://github.com/KSPP/linux/issues/90</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 6:53 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/906141/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agreed, I too would like to see strncpy() disappear, as it tends to lie to the reader. I&#x27;ve seen it be entirely responsible for major slowdowns a few times in different projects by the way, where users did not realize that it was padding the whole target buffer. And the number of times you see it called in series to concatenate path elements, you can&#x27;t avoid thinking &quot;OK I have an overflow after the first one&quot;. The only valid case I know for it in userland is to write a UNIX socket path because sun_path is of fixed length and not necessarily 0-terminated :-/ But that clearly demonstrates that str_anything_pad() would be a more suitable name for this thing (though memset(end, 0, size-len)<br>
based on strscpy()&#x27;s return would work too).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 7:10 UTC (Tue)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/906423/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Agreed, I too would like to see strncpy() disappear, as it tends to lie to the reader. I&#x27;ve seen it be entirely responsible for major slowdowns a few times in different projects by the way, where users did not realize that it was padding the whole target buffer.</font><br>
<p>
These people should not be programming in C.<br>
<p>
&quot;If the length of src is less than n, strncpy() writes additional null bytes to dest to ensure that a total of n bytes are written.&quot;<br>
<p>
Right there in the man page. If you can&#x27;t read the most basic documentation, don&#x27;t use the language!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906479"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 14:58 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/906479/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IMHO it is not totally unreasonable to expect strncpy(src) to be equivalent to snprintf(&quot;%s&quot;, size, src), because strcpy(src) is actually equivalent to sprintf(&quot;%s&quot;, src).<br>
<p>
(Incidentally, snprintf is just about the only portable function that DTRT in this context.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906479/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906480"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2022 14:59 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/906480/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(Oops, I put the arguments in the wrong order, but you know what I mean.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906480/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor906277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2022 6:42 UTC (Sat)
                               by <b>ruscur</b> (guest, #104891)
                              [<a href="/Articles/906277/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Replacing stray strlcpy() cases is some great low-hanging fruit for anyone looking to get their first commits into the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906304"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2022 11:39 UTC (Sun)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/906304/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Did you follow kees&#x27;s link? It&#x27;s literally tagged &quot;Good first issue&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906304/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor906155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">memccpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 9:11 UTC (Fri)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/906155/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No love for memccpy() in the kernel (note, two &#x27;c&#x27;s, this is not memcpy())?<br>
<p>
This has apparently been in POSIX forever, and is also supposedly going to be part of C2X.<br>
<p>
<a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2349.htm">https://www.open-std.org/jtc1/sc22/wg14/www/docs/n2349.htm</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906160"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">memccpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2022 10:43 UTC (Fri)
                               by <b>bluss</b> (subscriber, #47454)
                              [<a href="/Articles/906160/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And the nice documentation here says &quot;To avoid the risk of buffer overflow&quot; and produces an example that uses the returned pointer p without checking if p was NULL, which is may reasonably be. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906160/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor906903"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2022 11:16 UTC (Fri)
                               by <b>mtodorov</b> (subscriber, #158788)
                              [<a href="/Articles/906903/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Just occurred to me, maybe it is a stupid idea ...

<p>What if strlcpy() was fixed instead of changing 1,000s of occurrences?</p>
<p>
Changing the strlen(src) to strnlen(src, size) should suffice. This would both prevent segfaults for long unterminated strings and preserve function semantics.</p>

<p>The fix is simple:
<pre>
    size_t strlcpy(char *dest, const char *src, size_t size)
    {
	size_t ret = <b>strnlen(src, size)</b>;

	if (size) {
	    size_t len = (ret &gt;= size) ? size - 1 : ret;
	    memcpy(dest, src, len);
	    dest[len] = '\0';
	}
	return ret;
    }
</pre>
</p>
<p>Am I making any sense to you? <b>strnlen (src, size)</b> is said to be POSIX-2008 compliant ...</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/906903/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906906"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2022 12:08 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/906906/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You&#x27;ve broken compatibility for callers which do something like:<br>
<p>
```<br>
size_t ret = bufsz;<br>
size_t sz = bufsz;<br>
while (sz &lt;= ret) {<br>
  ret = strlcpy(buf, in, bufsz);<br>
  if (sz &lt;= ret) {<br>
    buf = realloc(buf, ret);<br>
    sz = ret;<br>
  }<br>
}<br>
```<br>
<p>
to 1-stepping the buffer increment instead of just doing a single realloc-enough loop. The return value is &quot;the size that would have been attempted&quot;, not &quot;something bigger than&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906906/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2022 13:33 UTC (Fri)
                               by <b>mtodorov</b> (subscriber, #158788)
                              [<a href="/Articles/906989/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I see what you're trying to do. My presumption was obviously wrong: changing the return value amounts to a change of semantics, which makes the premise false. And requires another function not to break the existing sources.
<p>
Yes, I see indeed. Anyway, it seemed too simple and obvious so no one wouldn't have thought of it earlier.
<p>
Thanks, @mathstuf.
<p>
However, I believe that attempting and unbound strlen(src) on a fixed-size buffer is inherently and semantically wrong, as the size can never be greater than the size of the buffer unless you're performing a scan beyond buffer's end on a potentially unfinished string, which as Mr. Torvalds said can bring disaster (SEGFAULT in kernel mode).
<p>
<code><b>strlen (buf)</b></code> should thereof always be done as <code><b>strnlen (buf, sizeof (buf))</b></code>.
Beyond the end of the buffer there can be beasts, nasty animals and hidden pits.
<p>IMHO.




      
          <div class="CommentReplyButton">
            <form action="/Articles/906989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2022 13:38 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/906991/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; strlen (buf) should thereof always be done as strnlen (buf, sizeof (buf)). Beyond the end of the buffer there can be beasts, nasty animals and hidden pits. </font><br>
<p>
The problem is that `sizeof (buf)` is not known in a lot of contexts (e.g., filenames passed in from userspace). At that point, you&#x27;re starting to carry around the allocated size around and you may as well amortize the length calculation as well…and oh, what do you know, you have a C++ std::string with no relevant established API.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor906992"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 2, 2022 13:50 UTC (Fri)
                               by <b>mtodorov</b> (subscriber, #158788)
                              [<a href="/Articles/906992/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The problem is that `sizeof (buf)` is not known in a lot of contexts (e.g., filenames passed in from userspace). At that point, you&#x27;re starting to carry around the allocated size around and you may as well amortize the length calculation as well…and oh, what do you know, you have a C++ std::string with no relevant established API.</font><br>
<p>
No argument on that.<br>
However, in most cases there seems to be an implementation-specific limit, like `strnlen (buf, MAXPATHLEN)`.<br>
Attempting to process more than that which makes sense usually only brings a risk of buffer overflow anyway. IMHO.<br>
Carefully crafted input could place the first NULL byte at the beginning of the next memory page that is not allocated and trigger SIGBUS. Probably difficult to exploit, but still possible?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/906992/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor962797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Ushering out strlcpy()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 19, 2024 21:06 UTC (Mon)
                               by <b>pepsiman</b> (guest, #22382)
                              [<a href="/Articles/962797/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; to this day, glibc lacks strlcpy()</span><br>
<p>
It was eventually added in glibc 2.38.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/962797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
