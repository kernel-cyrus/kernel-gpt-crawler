        <!DOCTYPE html>
        <html lang="en">
        <head><title>BSD-style securelevel comes to Linux — again [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/566169/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/566053/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/566169/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>BSD-style securelevel comes to Linux — again</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 11, 2013</br>
           </div>
Most of the hand-wringing over the UEFI secure boot mechanism has long
passed; those who want to run Linux on systems with secure boot enabled
are, for the most part, able to do so.  Things are quiet enough that one
might be tempted to believe that the problem is entirely solved.  As it
happens, though, the core patches that implement the lockdown that some
developers think is necessary for proper secure boot support still have not
made their way into the mainline.  The developer behind that work is still
trying to get it merged though; in the process, he has brought back an old
idea that was last rejected in 1998.
<p>
By Matthew Garrett's reading of the secure boot requirements, a system
running in secure boot mode must not allow any user to change the
running kernel; not even root is empowered to do so.  Just over one year
ago, Matthew posted <a href="/Articles/514985/">a set of patches</a> that
implemented the necessary restrictions.  In secure boot mode (as defined by
the absence of a new capability called, at that time,
<tt>CAP_SECURE_FIRMWARE</tt>), the kernel would not allow the loading of
unsigned kernel modules, direct access to I/O ports or I/O memory, or,
most controversially, use of the <tt>kexec_load()</tt> system call to
reboot directly into a new kernel.  As one might expect, not everybody
liked this type of restriction, which flies in the face of the longstanding
Unix tradition of giving root enough rope to shoot itself in the foot.
<p>
So there were discussions around various aspects of these patches, but one of
the biggest problems only came to light later.  It seems that there is a
fundamental flaw in the capability model: it is nearly impossible to add
new capability bits without risking problems with applications that do not
know about the new bits.  In particular:
<p>
<ul>
<li> Some capability-aware applications work by turning off every
     capability that they do not think they need.  If a new bit is added
     controlling functionality that such an application uses, it will
     unknowingly disable a necessary capability and cease to work properly.
     From the point of view of users of this application, this kind of
     change constitutes an incompatible ABI change.
<p>
<li> Other applications work in a blacklist-oriented mode, turning off
     capabilities that are known not to be needed.  In essence, such an
     application simply sets the capability mask to zero, then sets the
     bits corresponding to the capabilities it wants.  If some sort of
     security-related functionality is put behind a new bit that is unknown
     to this kind of application, that application will leave the
     capability enabled.  That, in turn, could make the application
     insecure. 
</ul>
<p>
In this case, the biggest risk is that whitelist-style applications would
inadvertently turn off <tt>CAP_SECURE_FIRMWARE</tt>, essentially putting
themselves into secure boot mode even if the system as a whole is not
running in that mode.  That could cause things to break in mysterious ways.
What it comes down to is that, if one is designing a capability-based
system, one really must come up with the full list of needed capabilities
at the outset.  Back in 1998, when capabilities for Linux were being hashed
out, nobody had UEFI secure boot in mind.  So there is no relevant
capability bit available, and adding one now is not really an option.
<p>
More recently, Matthew posted <a href="/Articles/566171/">a new patch
set</a> that eliminates the new capability.  Instead, all of the secure
boot restrictions were tied to the existing flag controlling whether
unsigned kernel 
modules can be loaded.  Matthew's reasoning was that the restriction on
module loading exists to prevent the loading of arbitrary code into the
running kernel, so it made sense to lock down any other functionality that
might make it possible to evade that restriction.  Other developers
disagreed, though, saying that they needed the ability to restrict module
loading while still allowing other functionality — <tt>kexec_load()</tt> in
particular — to be used normally.  After some discussion, Matthew backed
down and withdrew the patches.
<p>
Eventually he came back with what he called <a href="/Articles/566114/">his
final attempt</a> at providing a kernel lockdown facility that wasn't tied
to the secure boot mechanism itself.  This time around, we have a new
sysfs file at <tt>/sys/kernel/security/securelevel</tt> that accepts any of
three values.  If it is set to zero (the default), everything works as it
always has, with no new restrictions.  Setting it to one invokes "secure
mode," in which all of the restrictions related to secure boot go into
effect.  Secure mode is also irrevocable; once it has been enabled, it
cannot be disabled (short of compromising the kernel, at which point the
battle is already lost).  There is also an interesting "permanently
insecure" mode obtained by setting <tt>securelevel</tt> to <tt>-1</tt>; the
system's behavior is the same as with a setting of zero, but it is no
longer possible to change the security level.
<p>
In the UEFI secure boot setting, the bootstrap code would take pains to set
<tt>securelevel</tt> to one before allowing any processes to run.  That
helps to avoid race conditions where the system is subverted before
the lockdown can be applied.
<p>
Some readers will, by now, have recognized that "securelevel" looks an
awful lot like <a
href="http://www.freebsd.org/doc/en/books/faq/security.html#idp76718256">the
BSD functionality</a> that goes by the same name; it was clearly patterned
after BSD's version.  Amusingly, this is not the first time that
securelevel has been considered for Linux; there was <a
href="https://lkml.org/lkml/1998/4/6/12">an extensive discussion on the
subject</a> in early 1998, when Alan Cox was pushing strongly for a
securelevel feature.  At that time, Linus rejected the feature because he
had something much better in mind: capabilities.  As is usually the case,
Linus won out, and Linux got capabilities instead of securelevel.  
<p>
More than fifteen years later, it seems that we might just end up with both
mechanisms.  Thus far, Matthew's latest patch set has not resulted in many
screams of agony, so it might just pass review this time — though, at this
point, it is almost certainly too late for 3.12.  Meanwhile, Vivek Goyal
has posted the first version of a <a href="/Articles/566170/">signed kexec
patch set</a> that would limit <tt>kexec_load()</tt> to signed images.
That would allow some useful features (kdump, for example) to continue to
work properly in the secure boot environment without leaving
<tt>kexec_load()</tt> completely open.  That, too, will make the secure
boot restrictions a bit more palatable and increase their chances of being
merged.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Capabilities">Capabilities</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-UEFI_secure_boot">Security/UEFI secure boot</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Secure_boot">Secure boot</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/566169/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor566282"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 19:17 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/566282/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;What it comes down to is that, if one is designing a capability-based system, one really must come up with the full list of needed capabilities at the outset.</font><br>
<p>
That's what always bugs me with Linux capabilities - they are not. They are actually _roles_, not capabilities.<br>
<p>
In a true capability-based system there's no question about the full list of caps, an application MUST use caps to work with resources. I.e. process must use "start_process_cap" object to start new processes and it would fail if it can't get access to it. It also makes little sense for processes themselves to drop caps, because they won't have anything unnecessary in their environment already (in a properly set system).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566282/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566293"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 20:11 UTC (Wed)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/566293/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is complicated because securing ring 0 is something of a new hardware nuance / functionality that didn't hugely make sense on old hardware -- anyone with the ability to write to the boot disk as fsuid 0 used to be able to get their code in kernelspace trivially, so that security distinction didn't make sense, but now it does.<br>
<p>
If you wanted to be really conservative, then "load_modules_for_secure_boot" would be a totally different capability from "load_modules", and the latter wouldn't do anything if the machine and kernel was booted in secure-boot mode. Same with "access_io_ports_for_secure_boot", "kexec_load_for_secure_boot", etc. But then you've broken all userspace at once because there are new capabilities to match new hardware functionality. (Which is sensible -- if the capability system was designed before e.g. USB, then maybe "access_usb" is a new capability.)<br>
<p>
Even though technically you haven't broken userspace, and old userspace works in non-secure-boot mode, but not with secure boot enabled, in practice nobody is going to be pleased with that argument.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566293/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 21:09 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/566311/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The point of a true cap-based system is that the environment itself takes care of capabilities.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566312"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 21:11 UTC (Wed)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/566312/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure I follow -- can you expand on what you mean by "the environment itself"?<br>
<p>
Do you mean that the hardware/firmware platform is supposed to provide enumerated capabilities to the OS?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566312/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 21:17 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/566314/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No. A capability-based OS would simply not provide required caps to programs that don't need them.<br>
<p>
Also, the capability-based security literature means quite a different thing by 'capabilities'. The actual example of capabilities in Linux are not security cap. bits, but file handles. A program can securely transfer them, use them and can't forge them.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566315"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 21:26 UTC (Wed)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/566315/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, I'm using "capability" here in the research-literature sense, not in the Linux sense.<br>
<p>
I think "don't provide capabilities to programs that don't need them" is so underspecified as to not be useful. Let's take the USB example -- say a process is the USB driver on some awesome microkernel architecture. Then USB 3 shows up, and something in the USB 3 spec means that several users want to be more careful about what can speak to USB 3 host controllers (maybe it interacts with power consumption), but several other users also don't care. Should the USB capability -- the ability to drive any USB 1 or 2 host controller on the system -- also grant access to a USB 3 host controller? "Yes" means that you've lost some of the security promise of a  capability architecture; "no" means that the users who don't care complain about breaking userspace.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566315/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566330"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 22:51 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/566330/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nope. USB3 controller would have its own capability, so only processes that need it would be able to get access to it.<br>
<p>
If USB3 needs some special handling then this logic would be encapsulated in some kind of server process.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566330/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 23:01 UTC (Wed)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/566331/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, but now you took an OS where you could plug in a flashdrive and have it work, changed hardware, and now that no longer works without modifications to userspace. By making USB3 a separate capability, you've broken userspace.<br>
<p>
(Or so goes the argument against adding a new Linux-style capability for Secure Boot.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566332"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 23:13 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/566332/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, but these modifications will be confined to policies. End-user programs won't have to be modified in any way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566332/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor566515"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2013 20:22 UTC (Thu)
                               by <b>zooko</b> (guest, #2589)
                              [<a href="/Articles/566515/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sigh. I wonder how much damage has been done by Linux using the word "capabilities" for their non-capabilities access control scheme?<br>
<p>
"It seems that there is a fundamental flaw in the capability model: it is nearly impossible to add new capability bits without risking problems with applications that do not know about the new bits."<br>
<p>
If you mean Linux's non-capabilities "capabilities", then yes! Your article succinctly explains the fundamental problem with them. If you mean real capabilities, then no! Real capability systems do not have this problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566515/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566574"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Blame POSIX not Linux</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2013 22:26 UTC (Thu)
                               by <b>david.a.wheeler</b> (subscriber, #72896)
                              [<a href="/Articles/566574/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The terminology problem is from POSIX, not Linux.  There was a POSIX group ("POSIX Security Extensions") that defined a draft spec that used the term "capabilities" for something completely different than what many other people called capabilities.  Linux implemented that draft POSIX spec, and thus uses its terminology.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566574/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor566617"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 1:33 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/566617/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      I've always rejected the concept of a program dropping privileges, and I run systems in which untrusted programs never do that and instead receive an environment with only the capabilities they need.  It's based on regular Linux kernel capabilities, though: the program <b>capexec</b> sets the privileges (capabilities, uid, gid) of a new process and then execs the untrusted program.  Process 1 has all capabilities, but system configuration determines what lesser capabilities all the other processes have.
<p>
Whether a program chooses its own capabilities or some OS facility establishes them, it seems to me the issue of changing the capabilities in future kernel releases is the same.  If you make a certain capability bit give less privilege in Release 2 than it did in Release 1, you'll have trouble.  If you never do, you can't ever tighten security.
<p>
And sometimes, it's a matter of opinion whether a certain capability bit is more powerful in Release 2 because the set of things that are possible in the two releases is different.

      
          <div class="CommentReplyButton">
            <form action="/Articles/566617/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor567577"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2013 21:29 UTC (Thu)
                               by <b>mm7323</b> (subscriber, #87386)
                              [<a href="/Articles/567577/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
I've always rejected the concept of a program dropping privileges, and I run systems in which untrusted programs never do that and instead receive an environment with only the capabilities they need.
</blockquote>
<p>
Being able to drop caps can be useful to programs which may startup, perform some privileged actions, then drop the caps that aren't needed.</p>
<p>
The simplest example would be a server process that wished to bind to a low port (&lt;1024) using CAP_NET_BIND_SERVICE.  Once the bind() is done, the capability can be dropped, but the already obtained file descriptor for the socket stands and can still be used.</p>
<p>
There are other ways this could be done, but using libcap to drop capabilities at the right time is straight forward to implement.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/567577/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor567582"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2013 22:48 UTC (Thu)
                               by <b>hummassa</b> (guest, #307)
                              [<a href="/Articles/567582/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Why not <pre>
chown nginx.nginx /dev/port/80
</pre> and then starting nginx as user nginx, group nginx? no privileges used, only at install-time...
      
          <div class="CommentReplyButton">
            <form action="/Articles/567582/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor567591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2013 0:41 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/567591/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
because you would have to create the whole infrastructure for /dev/port/80 first. and if you can get agreement from everyone on how that would work, you will have done something very impressive.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/567591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor567647"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2013 11:55 UTC (Fri)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/567647/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Perhaps I'm naïve in hoping that systemd's tmpfiles.d mechanism can be adopted more widely.

<p><code>echo c /dev/port/80 0700 nginx nginx - maj:min &gt; /etc/tmpfiles.d/nginx.conf</code>
      
          <div class="CommentReplyButton">
            <form action="/Articles/567647/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor828244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 7, 2020 10:59 UTC (Fri)
                               by <b>metux</b> (guest, #60789)
                              [<a href="/Articles/828244/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually, I&#x27;m currently implementing exactly that. Here&#x27;s the first step: plan9-style srvfs - a file system where a process can post an open fd, so other processes can open it from there.<br>
<p>
<a rel="nofollow" href="https://github.com/metux/linux-srvfs-oot">https://github.com/metux/linux-srvfs-oot</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/828244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor567602"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2013 2:18 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/567602/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, the cases I can think of that this scheme misses as-is are: what interface for port 80? TCP or UDP? Which IP addresses? Then how to persist that information (udev I assume). That's a lot of bikesheds.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/567602/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor567597"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2013 1:46 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/567597/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
The simplest example would be a server process that wished to bind to a low port (&lt;1024) using CAP_NET_BIND_SERVICE. Once the bind() is done, the capability can be dropped, but the already obtained file descriptor for the socket stands and can still be used.
</blockquote>
<p>
That's exactly what I object to and what I don't do on my system.  Instead, a privileged program dedicated to binding sockets runs with CAP_NET_BIND_SERVICE and binds the socket, then execs the server program.  The server program inherits the file descriptor, but no capabilities.
<p>
That way, I don't have to trust the server program to use CAP_NET_BIND_SERVICE properly, and drop it properly.  I only have to trust the one binder program, which does the job for everyone and is very stable.
<p>
(And besides, I don't like having all that duplicate socket setup code in every server program - another good reason to have a separate program dedicated to that).

      
          <div class="CommentReplyButton">
            <form action="/Articles/567597/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor566310"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 21:15 UTC (Wed)
                               by <b>dashesy</b> (guest, #74652)
                              [<a href="/Articles/566310/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Overall the secure boot seems to be useful to machine owners. I just wish the highest security mode was called "OWNER" so that later if one is locked in a Linux system, he knows he is not the real owner, but maybe just on a lease. It would be even cooler if one had to write the name of the owner to the sysfs file to enable this mode, so anyone could cat /sys/owner<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566310/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 21:57 UTC (Wed)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/566325/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On most machines I picture:<br>
<p>
   $ cat /sys/owner<br>
   wheel<br>
<p>
Seems highly unlikely that even 0.01% of users would bother changing it from the default...?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 11, 2013 22:11 UTC (Wed)
                               by <b>dashesy</b> (guest, #74652)
                              [<a href="/Articles/566326/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Since only owners (and not even root) can change hypothetical /sys/owner a user can change it if she is <b>the</b> owner. If you buy a phone, and <i>cat /sys/owner</i> shows <i>Random Vendor</i>, and cannot change that value, then you have just leased the phone, but at least you know this up front. It would be interesting to buy a car with IVI, and look at its owner.
      
          <div class="CommentReplyButton">
            <form action="/Articles/566326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566615"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 1:17 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/566615/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      You seem to be saying if one isn't running with full privileges, then one is not the owner of the system (someone else is), and that misses the point of secure boot.
<p>
Secure boot is about saying, "I own this system, but don't let me modify my kernel."  Reason: someone might trick me into trying to modify the kernel against my interests.  Or I could be walking in my sleep.
<p>
It's like a werewolf chaining himself up at sunset on a full moon night.

      
          <div class="CommentReplyButton">
            <form action="/Articles/566615/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566618"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 1:28 UTC (Fri)
                               by <b>dashesy</b> (guest, #74652)
                              [<a href="/Articles/566618/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As long as there is anyway to own the device, you are the owner. If it requires soldering (or connecting BIOS to flash programmer) though, that does not count.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566618/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566619"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 2:08 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/566619/">Link</a>] 
      </p>
      
      </div>
      </summary>
      You lost me in the circular definition: anyone who is capable of owning is the owner.  In normal English, anyone who actually <em>does</em> own is the owner.  This appears to parse as, "the owner is a person who is capable of being the owner."
<p>
So who is the person identifed in the sysfs file?  The person who owns or the person who is capable of owning (there could be many or none, I guess).  Likewise, does the OWNER security mode mean programs have the privileges of owning or just are capable of getting them?
<p>
What it seems to come around to is that the highest security mode has to be called something other than OWNER in order for it to make any sense for a person to choose to run in a lower mode -- and that choice <em>does</em> make sense.

      
          <div class="CommentReplyButton">
            <form action="/Articles/566619/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor566743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 17:19 UTC (Fri)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/566743/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you mean "pwn", not "own" :)  In normal English, owners are not the same as superusers or sysadmins or vendors.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566744"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 17:25 UTC (Fri)
                               by <b>dashesy</b> (guest, #74652)
                              [<a href="/Articles/566744/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Good point :)<p>
Well for me I own a machine if I can do whatever I want with it (of course as long as it does not hurt others). Maybe I should have phrased it this way: I do not own a system if I cannot change <i>/sys/owner</i> name.
      
          <div class="CommentReplyButton">
            <form action="/Articles/566744/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor566428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2013 12:56 UTC (Thu)
                               by <b>nsheed</b> (subscriber, #5151)
                              [<a href="/Articles/566428/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"...giving root enough rope to shoot itself in the foot" - what kind of Rube Goldberg api call is that then ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566444"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2013 13:55 UTC (Thu)
                               by <b>fuhchee</b> (guest, #40059)
                              [<a href="/Articles/566444/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(Hey, don't ruin the joke by belabouring it!)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566444/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor566625"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 3:41 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/566625/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually, what several of us (including HPA) in the thread were calling for was not for this to use the existing Linux capabilities (i.e. something tied to a running process, or filesystem point)<br>
<p>
but instead to be using capabilities in the general sense, a bitmask that enables/disables things feature by feature for the entire system.<br>
<p>
This doesn't suffer the major nightmare of the current per process capabilities system does.<br>
<p>
It would also allow for a system to be locked down MORE than what Matthew is looking for, allowing the lockdown to be used by more people.<br>
<p>
for example, you may want a lockdown capability that disabled ALL module loading after a specific point in the boot process<br>
<p>
or one that completely disabled the ability to mount a device.<br>
<p>
such lockdown capabilities would be very useful to have on a voting machine for example.<br>
<p>
Yes, Matthew does have a point in that there is the possibility of someone adding a "do_evil()" syscall and a corresponding "prevent_do_evil" lockdown capability. In such a case, someone trying to run a locked down machine with a new kernel, but an old userspace would inadvertently allow the do_evil() call.<br>
<p>
But if someone is really trying to run a locked down system, why would they be upgrading the kernel without upgrading the corresponding userspace? as long as triggering unknown lockdown capabilities doesn't cause an error, the new userspace will run just fine on the old kernel.<br>
<p>
<p>
The idea that there is a one-size-fits-all definition of what a securelevel locked down system should consist of is just faulty. Different people with different use cases will want different amounts of lockdown. what's very reasonable for one person is completely wrong for another.<br>
<p>
David Lang<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566625/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566636"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 8:13 UTC (Fri)
                               by <b>ernest</b> (guest, #2355)
                              [<a href="/Articles/566636/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt;But if someone is really trying to run a locked down system, why would they be upgrading the kernel without upgrading the corresponding userspace? as long as triggering unknown lockdown capabilities doesn't cause an error, the new userspace will run just fine on the old kernel.</font><br>
<p>
There can be many good reasons for this of course: Upgrade of some hardware in the old but otherwise perfectly fine system? maybe something broke down but can only be replaced by something too new for the current kernel. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566636/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566644"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 8:56 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/566644/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
there are good reasons to upgrade the kernel, but are there good reasons to upgrade the kernel without being willing to upgrade anything else?<br>
<p>
remember, this isn't the home user we are talking about here, this is someone who is trying to lock down the system in a way that even root can't change it.<br>
<p>
anyone going to that much effort isn't going to be randomly upgrading one component.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566644/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 19:36 UTC (Fri)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/566773/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">there are good reasons to upgrade the kernel, but are there good reasons to upgrade the kernel without being willing to upgrade anything else?</font></blockquote>

<p>Depends on your definition of “anything”. Kernel is often upgraded if you need/want to support new hardware capabilities. Sometimes you then need to upgrade some low-level components (things like modproble), but you don't expect to change the setup of the whole system just because you've installed new CPU and want to use AVX512 in your programs.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/566773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor566801"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2013 1:26 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/566801/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
remember that we are not talking about POSIX capabilities that your programs all need to know about.<br>
<p>
We are talking about features that you can turn off to lock your machine down (protecting it even from root)<br>
<p>
I would expect that there will be one program to do this, and it will probably be executed exactly once per boot cycle. (unless it's a developers machine)<br>
<p>
So saying that if you upgrade the kernel and are trying to lock down the machine, you need to check for new lockdown flags that may have been introduced and decide if you want them doesn't seem at all unreasonable to me. In fact, it sounds like what would happen anyway with anyone competent dong a kernel upgrade, you would check new kernel compile options to see if something new pops up that may be a problem.<br>
<p>
Look at the namespace features for a perfect example.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566801/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor566787"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">BSD-style securelevel comes to Linux — again</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2013 22:38 UTC (Fri)
                               by <b>hallyn</b> (subscriber, #22558)
                              [<a href="/Articles/566787/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"... an old idea that was last rejected in 1998"<br>
<p>
False.<br>
<p>
<a href="https://lkml.org/lkml/2006/8/2/180">https://lkml.org/lkml/2006/8/2/180</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/566787/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor567757"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Need Capabilities + Incapabilities</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 21, 2013 8:21 UTC (Sat)
                               by <b>ldo</b> (guest, #40946)
                              [<a href="/Articles/567757/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Seems to me the answer to the issue of forward/backward compatibility when changing capability bits is to have two parts to the capability mask:

<UL>
<LI> A set of bits like the present one, where each set bit gives the process some ability. Existing bits should never be overloaded to add new abilities, as that could compromise the security of existing applications; instead, new abilities require new capability bits to enable them. Correspondingly, no new restrictions should be imposed on existing capability bits, to avoid breaking the functionality of existing applications; a particular bit, once defined, will always refer to the same set of abilities.

<LI> A new set of <I>incapability</I> bits. These start out set to 1 for every process. As new security <I>restrictions</I> need to be added to the capability system, new bits can be assigned here that, when cleared, impose those restrictions. Leaving those bits set (the default) means the restrictions are not imposed on the process.
</UL>

<P>So the convention for applications is
<UL>
<LI>whitelist the capability bits, and
<LI>blacklist the <I>in</I>capability bits.
</UL>

<P>That is, start out with the capability mask all 0, and the incapability mask all 1; set all the bits in the former for things that you know you need, and clear all the bits in the latter for things that you know you <I>don’t</I> need. Leave everything you don’t know about in its default state; 0 for capabilities, 1 for incapabilities. This will ensure maximum compatibility in the face of changes to the security model in the future.

<P>Thoughts?
      
          <div class="CommentReplyButton">
            <form action="/Articles/567757/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
