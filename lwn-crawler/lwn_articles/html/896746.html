        <!DOCTYPE html>
        <html lang="en">
        <head><title>Adding an in-kernel TLS handshake [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/896746/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/896350/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/896746/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Adding an in-kernel TLS handshake</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jake Edge</b><br>June 1, 2022</br>
           <hr>
<a href="/Articles/lsfmm2022/">LSFMM</a>
</div>
<p>
Adding <a href="/Articles/892216/">support for an in-kernel TLS
handshake</a> was the topic of a combined storage and filesystem session at the
<a
href="https://events.linuxfoundation.org/lsfmm/">2022 Linux Storage,
Filesystem, Memory-management and BPF Summit</a> (LSFMM).  Chuck Lever and
Hannes Reinecke led the discussion on ways to add that support; they are
interested in order to provide TLS for network storage and filesystems.
But there are likely other features, such as <a
href="/Articles/558826/">QUIC</a> support, that could use an in-kernel 
TLS implementation.
</p>

<h4>Problem</h4>

<p>
Reinecke started things off by saying that, while Lever was interested in the
feature for NFS,  he wanted it for NVMe.  The problem is that those
applications cannot use the current in-kernel TLS support because they
need to initiate the handshake from the kernel, Reinecke said.  Current
kernels can communicate using TLS, but the connection handshake is done in
user space, then the connected socket is passed to the kernel for sending
and receiving the data.
</p>

<p>
The reason the existing mechanism cannot be used is because there is
already a socket connected to the remote host within the kernel that is,
effectively, being converted to use TLS.  So there is a need to pass a
connected socket from the kernel to user space if the handshake will be done
there, but there is no existing mechanism to do that.
</p>

<a href="/Articles/896837/">
<img src="https://static.lwn.net/images/2022/lsfmm-lever-reinecke-sm.png" border=0 hspace=5
align="right" alt="[Chuck Lever and Hannes Reinecke]"
title="Chuck Lever (l) and Hannes Reinecke (r)" width=400 height=201>
</a>

<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
An alternative would
be to do the whole job within the kernel, as a  company called <a
href="https://tempesta-tech.com/">Tempesta</a> has done, Reinecke said.
That works, but it brings "a lot of security-relevant code" into the
kernel, which would require an audit to help limit the potential security
danger.  Someone suggested writing that code in Rust; "we did think of
that", Lever said with a chuckle.  In any case, there are reasonable arguments
that this kind of code should not be in the kernel at all, regardless of
language, Reinecke said.
</p>

<p>
James Bottomley asked about using the kernel as a man in the middle and
passing the packets back and forth to user space as needed.  Reinecke said
that does not work with the existing libraries; if the kernel endpoint can
be passed to user space, there are  TLS libraries that can just
handle the handshake directly.
</p>

<p>
Steve French said that there is value in
finding a way to create a guinea-pig implementation for dealing with the 
handshake as a starting point, even if that code never goes upstream.  It
would allow the creation of a reference platform that shows that TLS for NFS, NVMe, or,
in his case, SMB over QUIC, is viable, then it can be reworked as needed.
But there is no good example that he could find of an upcall passing the
kernel socket to a user-space library.
</p>

<p>
Reinecke agreed; there is no mechanism of that sort, which is why they have
been pondering on how it should be done.  One possibility is to update the
netlink mechanism to allow passing file descriptors from the kernel to user
space.  Josef Bacik said that the Linux <a
href="https://nbd.sourceforge.io/">network block device</a> (NBD) already
uses netlink that way, but Lever pointed out that user space creates the
endpoint for NBD, not the kernel, so that is passing the socket in the
opposite direction of what is needed here.
</p>

<p>
David Howells said that for TLS&nbsp;1.3 all of the necessary code should
already be available in the kernel crypto subsystem.  It should just be a
matter of calling it properly.  But Reinecke said that the crypto layer
does have what is needed for encrypting and decrypting the data, but it
does not have necessary pieces for the initial handshake.
</p>

<p>
Bacik said that FreeBSD does the TLS handshake in user space and wondered
how it did so.  Lever said that it passed a file descriptor to a user agent
that uses an existing library, probably OpenSSL, to do the handshake.  That
is generally how the security community recommends that it be handled. 
</p>

<p>
On the server side, the kernel will be accepting connections from clients
that will then need to have a TLS connection initialized, Lever said, so
there is really no way of getting around the need to pass connected sockets
to user space.  His initial implementation used a separate address family
for a user agent's socket; the user agent would accept a connection from
the kernel on that socket, which "materializes the connected endpoint in
the user agent's file descriptor table". That socket gets passed by the agent to GnuTLS,
which does the handshake and closes the accepted socket; that tells the kernel that
the connected endpoint is ready to use.
</p>

<p>
That prototype worked for NFS and NVMe.  They are hoping to build
infrastructure that QUIC can use, as well, since it uses the TLS&nbsp;1.3 handshake
protocol to establish connections.
</p>

<h4>Direction</h4>

<p>
There was quite a bit of pushback from
the networking developers when they discussed doing the handshake
directly from within the kernel, Lever said.
Reinecke asked if it made sense to continue exploring that option or if the
user-space solution was the best route.  Bacik said that he is normally
"extremely allergic" to putting that kind of code in the kernel, but since
the crypto pieces are already there, it does not "seem like it's a big
deal" to do so.  Bottomley pointed out that it is just the primitives
that are present in the kernel, however; TLS has "a huge amount of handshaking code"
that is missing from the kernel.
</p>

<p>
Lever said that TLS&nbsp;1.3 reduces the amount of code needed for
handshaking by roughly half; both he and Reinecke only need support
for&nbsp;1.3.  But Bottomley said that he had looked at the bug reports for
OpenSSL, specifically regarding the&nbsp;1.3 handshaking; the code size may be
less, but there are still many bugs reported for it.
</p>

<p>
Chris Mason said that the TLS-for-storage developers were faced with "two different
slogs" to choose from; one is to add the TLS handshake code to the kernel and the other is
to figure out how to add the mechanism so that it can be done in user
space.  Both will be a lot of work, but the user-space solution will likely
be better long-term.  As security problems arise with TLS, for example, it
will be easier to address them in user space.  If it were him, Mason said,
he would choose the user-space route.
</p>

<p>
Lever said that one area where they do not feel comfortable with the
user-space solution is in handling a root filesystem or block device over
TLS.  The user agent process needs to be made special somehow so that the kernel
can always rely on it being there if it needs to re-establish the TLS
session—even when there is memory pressure, for example.
</p>

<p>
Another problem that Lever sees is how the kernel knows that it can trust
the process it is talking to.  The kernel is making an upcall, but how can
it be sure that it is talking to what it expects?  It is a more general
problem that he does not think has been solved for other user-space
helpers.  Ted Ts'o said that it is the same problem faced by firmware and
module loading within the kernel; the assertion is that
<tt>/sbin/request_module</tt> is sane and a similar assertion could be made
for the TLS user agent binary.
</p>

<p>
For a prototype and to work out any problems that may be encountered, it
clearly makes sense to 
do the handshake in user space, Lever said.  Every time he talks to a group
of kernel developers, he feels like the chances of eventually moving that handling
into the kernel dwindle.  French suggested that, once there are consumers of
the facility in the kernel, the  networking developers may see that it
makes sense to move that handling into the kernel.  Reinecke agreed; it really is not a
filesystem or storage topic, but something that the networking developers need
to consider.
</p>

<p>
There are two big advantages that TLS brings, which makes it a "great value
add for storage protocols", Lever said.  It allows both servers and clients
to authenticate the other end of the connection using X.509 certificates.
It also provides in-transit encryption in a way that can be offloaded to
specialized hardware.  TLS is well-established in the industry, which
makes it a good basis for an encryption feature.
</p>

<p>
The mechanism for passing the TLS information to the user agent is perhaps
one of the more contentious pieces, Lever said.  The prototype uses socket
options for the new address family to pass the connection information.
That allows the kernel to send certificate data, pre-shared keys, 
and other information specific to the TLS connection and handshake.  It
is seen as ugly by some of the reviewers of the prototype code, however.
</p>

<p>
The session wound down soon after that.  It would seem that, at least for
now, the same basic approach will be taken, though there are still multiple
issues
that need to be resolved.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking-Protocols">Networking/Protocols</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Transport_Layer_Security_TLS">Transport Layer Security (TLS)</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_Memory-Management_and_BPF_Summit-2022">Storage, Filesystem, Memory-Management and BPF Summit/2022</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/896746/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor896845"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 1, 2022 23:13 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/896845/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So.... <br>
<p>
<font class="QuotedText">&gt; socket(AF_INET, SOCK_STREAM, SOCK_TLS);</font><br>
<p>
?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/896845/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor896862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2022 10:29 UTC (Thu)
                               by <b>Lumag</b> (subscriber, #22579)
                              [<a href="/Articles/896862/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that the TLS handshake should staty out of the kernel. It has lots of ugly corner cases, strange checks, etc. I&#x27;d prefer to have OpenSSL/GNUTLS userspace helper doing the job.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/896862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor896866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2022 12:13 UTC (Thu)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/896866/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is simpler, but when memory pressure rears its ugly head this may turn out to be problematic. Suppose we&#x27;re in a situation where we have no free memory for allocations and a bunch of dirty NFS pages that need to be cleaned at the same time the socket connection goes down.<br>
<p>
Now we&#x27;re in a situation where we may not be able to allocate memory for the userland helper to do the handshake without performing writeback, but we can&#x27;t perform writeback until we can allocate the memory. Deadlock. There are several variations on this theme as well. You can try to do things like mlock all of the userland helper&#x27;s memory, but that&#x27;s probably impossible if we&#x27;re going to rely on 3rd party libraries for the TLS implementation.<br>
<p>
For the initial implementation, they&#x27;re sort of ignoring this for now, but it could turn out to be very problematic down the road.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/896866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor896913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2022 14:23 UTC (Thu)
                               by <b>james</b> (subscriber, #1325)
                              [<a href="/Articles/896913/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Surely if the connection goes down, either it's going to come right back up again, in which case TLS 1.3 session resumption is a thing which could reasonably be in the kernel, or the client is going to have to live with those dirty pages for a while?
<p>
And if the server gets into a position where it can't resume the session (so you need userspace to make a new connection), and the kernel simply can't free enough memory to do that, then you're pretty much out of memory anyway? At some point, if you want reliability, you need enough memory to make that possible.




      
          <div class="CommentReplyButton">
            <form action="/Articles/896913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor896929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2022 18:50 UTC (Thu)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/896929/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, that&#x27;s all true. Also, the kernel just overall better at avoiding these situations these days. It&#x27;s more proactive about flushing and blocking new pages from being dirtied when things aren&#x27;t being cleaned.<br>
<p>
I agree that a userland implementation is definitely the way to go. We may need the daemon to be extra careful to avoid allocations in critical codepaths, which may be difficult depending on what the TLS libraries do under the hood.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/896929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor896948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2022 0:54 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/896948/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Strictly speaking, can&#x27;t the kernel mark the writes as bad even after it has accepted them, and return EIO on close/fsync? That&#x27;s probably not very *nice*, but if the writes physically cannot be persisted anyway, you may as well let the application know that its data got lost.<br>
<p>
But OTOH neither the man pages nor POSIX are very clear about what EIO even means or how userspace should react to it, so I imagine there are some applications that will freak out and do weird things if you return that error. Amazingly, POSIX does not even tell you what the state of the file descriptor is after close(2) fails with EIO, which means you have no way of knowing (assuming a POSIX-only environment that lacks /proc/self/fd) whether the file descriptor still exists and still needs to be closed! I guess the only safe way is to loop and repeatedly call close until you get EBADF? But that&#x27;s obviously not thread-safe, and I could imagine a brain-dead implementation that just keeps returning EIO and never deallocates the fd.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/896948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2022 14:27 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/897028/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Strictly speaking, can&#x27;t the kernel mark the writes as bad even after it has accepted them, and return EIO on close/fsync? That&#x27;s probably not very *nice*, but if the writes physically cannot be persisted anyway, you may as well let the application know that its data got lost.</font><br>
<p>
Have you *looked* at what happens to data once the write() call returns? The reality is that the kernel doesn&#x27;t have a clue which application needs to be told, nor how to tell it.<br>
<p>
It gets even worse once network/raid/luks/integrity/blahblah gets involved. As a simple example, let&#x27;s say you&#x27;re writing a file of one block to a ten-disk raid array. You need to read 40k from disk, recompute checksums, and write the whole lot back. If THAT goes wrong, how do you tell the application it just trashed some data that was written six months ago ... ?<br>
<p>
Okay, that&#x27;s a bit extreme, but once the application has launched the data on its journey to disk, it&#x27;s very hard to work out some sane way to pass an error back up the unpredictable path the data has taken.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897038"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2022 15:50 UTC (Fri)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/897038/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Have you *looked* at what happens to data once the write() call returns? The reality is that the kernel doesn&#x27;t have a clue which application needs to be told, nor how to tell it.</font><br>
<p>
Not true, at least not on modern kernels. We track writeback errors in a better way now such that if we get one, it&#x27;s reported exactly once to fsync/msync on every fd that was open at the time that the error was recorded. Ditto for syncfs(2).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897038/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor897036"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2022 15:45 UTC (Fri)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/897036/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Writeback errors are an option, but not a good one. Most applications can&#x27;t handle them gracefully, so this usually means that the program dies or something equally awful...and in this case, the problem _should_ be temporary. We really don&#x27;t want to return a writeback errors on fsync unless there really is no other option. As far as close(2) goes, we really ought not return writeback errors to it at all. The only &quot;legitimate&quot; error for close(2) is EBADF.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897036/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor896869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS _1.3_ handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2022 12:48 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/896869/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; lots of ugly corner cases, strange checks, etc.</font><br>
<p>
This stance, which was apparently also raised at the talk, needs some fleshing out if it&#x27;s to persuade me. Lets see an actual concrete list of, say, a half dozen &quot;ugly corner cases&quot;.<br>
<p>
What&#x27;s proposed is specifically just TLS 1.3. In the PSK case, clients say &quot;Hi, I want to use this PSK&quot; and servers say &quot;Can do&quot; and we&#x27;re off to the races. Some other cases are also this easy. Fallback is lots more complexity, but this proposal only wants TLS 1.3.<br>
<p>
As I understand it, this is not intended to drop into your web browser or web server as a replacement for its implementation of TLS, it&#x27;s targeting situations where we&#x27;re currently using a plaintext wire protocol to underpin some kernel primitive and it would be better to speak TLS instead.<br>
<p>
If anything, getting OpenSSL or GnuTLS involved opens the door to additional complexity, because hey, we have this full blown implementation, if the remote device says it speaks TLS 1.0 we should just roll with it, shouldn&#x27;t we ? With an in-kernel TLS 1.3 solution the &quot;Let&#x27;s just do TLS 1.0 even though now all our security guarantees are destroyed&quot; change isn&#x27;t a LGTM patch to some userspace program, it&#x27;s going to the LKML where hopefully somebody will just say &quot;No&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/896869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897071"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS _1.3_ handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2022 12:55 UTC (Sat)
                               by <b>james</b> (subscriber, #1325)
                              [<a href="/Articles/897071/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>Fallback is lots more complexity, but this proposal only wants TLS 1.3.</blockquote>
So what about when TLS 1.4 comes out? You'll need to adopt it, and then you'll need fallback to 1.3.
<p>
Also, will TLS versions be retired at some point <strong>even if</strong> some sites are still using them and will experience this as a regression? Probably best to get this sorted before anyone adopts it.





      
          <div class="CommentReplyButton">
            <form action="/Articles/897071/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897203"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS _1.3_ handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2022 0:02 UTC (Tue)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/897203/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So what about when TLS 1.4 comes out? You&#x27;ll need to adopt it, and then you&#x27;ll need fallback to 1.3.</font><br>
<p>
The former would be a change to this work, and version negotiation would be part of that change.<br>
<p>
I&#x27;m guessing you&#x27;re not very familiar with how TLS works, fallback was a specific trick where things went wrong but instead of just giving up (which is the secure choice) you start over but with different assumptions about your peer. There are grave security problems with this trick, but it was necessary say ten years ago especially because people love badly designed middle boxes as &quot;security&quot;. We&#x27;ve hopefully made so much of the handshake encrypted that the worst of that won&#x27;t happen again, and also this kernel work isn&#x27;t general web security, if we&#x27;re talking to a device that&#x27;s wired to the same 10G switch or whatever then hopefully the middle boxes aren&#x27;t in the way.<br>
<p>
Libraries like OpenSSL often support fallback, but a modern web browser no longer does (they ripped this out when they shipped TLS 1.2 as minimum version if they hadn&#x27;t earlier) and there&#x27;s no reason the kernel would either.<br>
<p>
Normal version negotiation isn&#x27;t thorny. &quot;Hi, I can do X, Y, or Z&quot; &quot;Cool, let&#x27;s do Y then&quot;. I&#x27;m also doubtful that we&#x27;d see a TLS 1.4 in the foreseeable future anyway. So we&#x27;re asking about a  hypothetical event maybe decades in the future.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897203/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor896857"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 2, 2022 8:09 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/896857/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It really seems like a lot of the vague concern was about older TLS versions, but the proponents don&#x27;t actually want to talk anything other than TLS 1.3<br>
<p>
Even for the OpenSSL bugs, all the pathways where OpenSSL TLS 1.3 support intersects with backward compatibility are irrelevant for the kernel. OpenSSL needs to cope with the case where we fall back correctly, but the kernel can immediately punt in all such cases.<br>
<p>
However, I&#x27;ve been assuming they don&#x27;t want to do certificate checking in the kernel, and there&#x27;s a reference to certificates near the end so maybe I&#x27;m wrong. You definitely don&#x27;t want to get into that in the kernel, it&#x27;s a necessary complication for the Web but there&#x27;s no reason the kernel needs such a broad high level policy that I can see. I think just PSKs (which needn&#x27;t be associated with any certificates, we just &quot;know&quot; [from userspace] which PSKs to use) should be enough.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/896857/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor897034"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2022 15:55 UTC (Fri)
                               by <b>dkg</b> (subscriber, #55359)
                              [<a href="/Articles/897034/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
endpoint authentication seems like the real sticky part of this.  Who does your side of the TLS session think it is talking to?  who must it *not* talk to?  If we&#x27;re talking about a TLS connection used by an application, these are choices that only userspace is in a position to have answers for.<br>
<p>
If the handshake is only for a bidirectionally-authenticated TLS pipe on the basis of a pre-shared key (PSK) then putting everything in the kernel makes sense.  The semantics there are &quot;we&#x27;ve already established a shared secret with a peer, and we want to bootstrap that into a confidential, integrity-protected bidirectional network channel with that same peer&quot;.  That&#x27;s something you can either do successfully or not at all, with minimal configuration choices from the side of either the initiating or receiving endpoints, and a straightforward set of error conditions.<br>
<p>
Once you say &quot;i want to use TLS to connect to foo.example.net on port 993, and the remote peer&#x27;s certificate must be currently marked as valid for &quot;foo.example.net&quot;, certified against Mozilla&#x27;s X.509 root store, and my revocation-checking policy requires confirmation by either CRL or OCSP response within the last 72 hours; and ideally the connection would be made using the Encrypted Client Hello mechanism so that metadata about the name foo.example.net doesn&#x27;t leak in the Server Name Indication extension&quot; then there are way too many fiddly choices to expect the client to indicate to the kernel.  And there are many different ways that it could go wrong, so error reporting is significantly more complex.<br>
<p>
And that&#x27;s just the client side.  On the server side, where arbitrary clients might connect, and the authorization/privileges for any incoming client might differ based on the types of client authentication provided, or particular extensions used during the handshake.  Reporting the relevant details of that part of the handshake back out of the kernel seems like a significantly complex (and possibly unstable) API surface that i&#x27;d be reluctant to adopt if i were maintaining any of this stuff.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897034/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897049"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 3, 2022 20:16 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/897049/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can cover most of the cases by creating a keyring with trusted CA roots and supplying it as a socket option. Everything else (like custom certificate validation) can be done using the old mechanism of userspace handshake.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897049/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2022 10:49 UTC (Sat)
                               by <b>dkg</b> (subscriber, #55359)
                              [<a href="/Articles/897070/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree that it you could pass a certificate bundle of trusted CA roots to the kernel, but that wouldn&#x27;t be sufficient for a standard client connection.  You&#x27;d also have to pass the name that you want to validate for the peer, as another socket option.  Otherwise, any server certificate would be acceptable.  for modern protocols like HTTP/2, you probably also need to offer a mechanism to set/require certain ALPN choices. But with those three changes, the client could just accept whatever other connection parameters the kernel chooses.<br>
<p>
This depends of course on a plausible X.509 parser in the kernel, and X.509 path-finding code to map from the provided end-entity certificate through any provided intermediate CAs to one of the trusted roots.  So the kernel will be dealing with and reasoning about a notoriously bizarre data format, with information provided from user space *and* from the remote network.<br>
<p>
It would also mean if you wanted anything else, you&#x27;d need to revert to a userspace handshake.  in particular, any of the above would require a userspace handshake:<br>
<p>
- any sort of revocation check<br>
- denylists of known-invalid CAs<br>
- cached intermediate CAs (to be more likely to accept &#x27;transvalid&#x27; end entity certificates)<br>
- guidance on metadata leakage minimization (e.g. ECH)<br>
- any sort of policy details negotiated in the handshake<br>
- &quot;early data&quot; (data sent in the first flight based on assumptions about the TLS peer)<br>
<p>
And you probably couldn&#x27;t get significantly more information out of the kernel about the authenticated peer.  Perhaps you could offer a getsockopt mechanism after the socket was connected that yields the validated end-entity certificate for the peer for clients that want to reason about the negotiated peer.<br>
<p>
You could even have some sort of system-wide control that sets a default list of root CA certificates, which could be loaded from userspace by the superuser at runtime, which would permit someone using this mechanism to initialize the TLS layer without having to know its own preferred trust store.<br>
<p>
So i&#x27;m agreeing with you -- it does seem like this is a plausible approach, above and beyond a PSK system.  it would be inflexible, but that&#x27;s not always a bad thing.  Most applications really do just want a simple interface, and only the most sophisticated ones are willing to do the extra work to set up their own handshake.<br>
<p>
That said, if i were trying to implement this, i&#x27;d start with a PSK handshake for both client  and server.  Then i&#x27;d add an anonymous (accepts any client, any configuration) server-side option, which needs sockopt mechanisms to provide secret key material and an X.509 cert chain.  And only after that was all working would i consider how to do a minimal client-side, authenticated server mechanism.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897178"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2022 14:27 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/897178/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; - any sort of revocation check</font><br>
<font class="QuotedText">&gt; - denylists of known-invalid CAs</font><br>
<font class="QuotedText">&gt; - cached intermediate CAs (to be more likely to accept &#x27;transvalid&#x27; end entity certificates)</font><br>
<p>
These really seem to be something the keyctl subsystem could be used for, no? A service inserts the valid CAs on boot (with reasonable expiry times), known-bad CAs are either blocked there or more proactively in some other keyring. Intermediate CAs can be cached in either a system-wide, per-user, or per-process keyring as appropriate for the use case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897178/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor897084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2022 20:07 UTC (Sat)
                               by <b>aaronmdjones</b> (subscriber, #119973)
                              [<a href="/Articles/897084/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Forgive my ignorance, but what does TLS have to do with NVMe?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897085"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 4, 2022 20:28 UTC (Sat)
                               by <b>zev</b> (subscriber, #88455)
                              [<a href="/Articles/897085/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Probably for <a href="https://en.wikipedia.org/wiki/NVM_Express#NVMe-oF">NVMeoF</a>, I'd guess?


      
          <div class="CommentReplyButton">
            <form action="/Articles/897085/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor897373"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2022 13:26 UTC (Thu)
                               by <b>wagi</b> (subscriber, #57912)
                              [<a href="/Articles/897373/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
yes, this is for NVMe over TCP<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/897373/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor910691"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Adding an in-kernel TLS handshake</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2022 2:08 UTC (Mon)
                               by <b>lucien.xin</b> (guest, #160913)
                              [<a href="/Articles/910691/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've written an implementation for this topic, though there are some security problems. FWIW, just in case some one wants to know more about this, see <a rel="nofollow" href="https://github.com/lxin/tls_hs/">https://github.com/lxin/tls_hs/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/910691/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
