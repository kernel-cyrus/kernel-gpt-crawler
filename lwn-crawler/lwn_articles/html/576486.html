        <!DOCTYPE html>
        <html lang="en">
        <head><title>Memory barriers for TSO architectures [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/576486/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/575841/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/576486/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Memory barriers for TSO architectures</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>December 11, 2013</br>
           </div>
Developers — even kernel developers — like to think of access to memory as
a nice, predictable, deterministic thing.  If two memory locations are
written in a given order, one would hope that any other processors would see
those writes in the same order.  The truth of the matter is rather murkier;
compilers and processors are both happy to take liberties with the ordering
of memory
accesses in the name of performance.  Most of this playing around is
invisible to programmers, but it can interfere with the correct operation
of concurrent systems, so developers must occasionally force things to
happen in the right order through the use of memory barriers.  The set of
available barrier types looks like it will get a bit larger in the 3.14 kernel.
<p>
<h4>Introduction to memory barriers</h4>
<p>
A memory barrier is a directive that prohibits the hardware (and compiler) from
reordering operations in specific ways.  To see how they might be used,
consider the following simple example, taken from <a href="/Articles/572099/">a
2013 Kernel Summit session</a>.  The lockless insertion of a new element into a
linked list can be performed in two steps.  The first is to set the "next"
pointer of the new item to point to the item that will follow it in the
list: 
<p>
<blockquote>
    <img src="https://static.lwn.net/images/conf/2013/lce-ks/rcu-ll2.png" width=353 height=102
    alt="[Linked list]">
</blockquote>
<p>
Once that is done, the list itself can be modified to include the new item: 
<p>
<blockquote>
    <img src="https://static.lwn.net/images/conf/2013/lce-ks/rcu-ll3.png" width=353 height=102
    alt="[Linked list]">
</blockquote>
<p>
A thread walking the list will either see the new item or it won't,
depending on the timing, but it will see a well-formed list in either
case. 
If, however, the operations are reordered such that the second pointer
assignment becomes visible before the first, there will be a period of time
during which the structure of the list is corrupted.  Should a thread
follow that pointer at the wrong time, it will end up off in the weeds.  To
keep that from happening, this sort of list operation must use a memory
barrier between the two writes.  With a proper barrier in place, the
pointer assignments will never be seen in the wrong order.
<p>
The kernel offers a wide variety of memory barrier operations adapted to
specific situations, but the most commonly used barriers are:
<p>
<ul>
<li> <tt>smp_wmb()</tt> is a <i>write</i> memory barrier; it ensures that
     any write operation executed after the barrier will not become visible
     until all writes executed prior to the barrier are visible.  A
     write memory barrier would be the appropriate type to use in the
     linked list example above.
<p>
<li> <tt>smp_rmb()</tt> is a <i>read</i> memory barrier; any reads executed
     before the barrier are forced to complete before any reads after the
     barrier can happen.  Code traversing a linked list that is subject to
     lockless modification would want to use read barriers between access
     to subsequent link pointers.
<p>
<li> <tt>smp_mb()</tt> is a barrier for both read and write operations; it
     can be thought of as the combination of <tt>smb_wmb()</tt> and
     <tt>smp_rmb()</tt>.
</ul>
<p>
Memory barriers almost invariably come in pairs.  If one of two cooperating
threads cares about the order in which two values are written, the other
side must be equally concerned about the order in which those values are
read. 
<p>
Naturally enough, the full story is rather more complex than described
here.  Readers with sufficient interest and free time, along with quite a
bit of excess brain power, can read <a
href="/Articles/576489/">Documentation/memory-barriers.txt</a> for the full
story.
<p>
The primary reason for the proliferation of memory barrier types is
performance.  A full memory barrier can be an expensive operation; that is
something that kernel developers would prefer to avoid in fast paths.
Weaker barriers are often cheaper, especially if they can be omitted
altogether on some architectures.  The x86 architecture, in particular,
offers more ordering guarantees than some others do, making it possible to
do without barriers entirely in some situations.
<p>
<h4>TSO barriers</h4>
<p>
A situation that has come up relatively recently has to do with "total
store order" (TSO) architectures, where, as Paul McKenney <a
href="/Articles/576492/">put it</a>, "<q>reads are ordered
before reads, writes before writes, and reads before writes, but not
writes before reads</q>".  The x86 architecture has this property,
though some others do not.  TSO ordering guarantees are enough for a number
of situations, but, in current kernels, a full memory barrier must be used
to ensure those semantics on non-TSO architectures.  Thus, it would be nice
to have yet another memory barrier primitive to suit this situation.
<p>
Peter Zijlstra had originally called the new barrier <tt>smp_tmb()</tt>,
but Linus was <a href="/Articles/576493/">less than impressed</a> with the
descriptive power of that name.  So Peter came up with <a
href="/Articles/576494/">a new patch set</a> adding two new primitives:
<p>
<ul>
<li> <tt>smp_load_acquire()</tt> forces a read of a location in memory 
     (in much the same way as <a
     href="/Articles/508991/"><tt>ACCESS_ONCE()</tt></a>), but it ensures
     that the read happens before any subsequent reads or writes.
<p>
<li> <tt>smp_store_release()</tt> writes a value back to memory, ensuring
     that the write happens after any previously-executed reads or writes.
</ul>
<p>
These new primitives are immediately put to work in the code implementing
the ring buffer used for perf events.  That buffer has two pointers, called
<tt>head</tt> and <tt>tail</tt>; <tt>head</tt> is where the kernel will
next write event data, while <tt>tail</tt> is the next location user space
will read events from.  Only the kernel changes <tt>head</tt>, while only
user space can change <tt>tail</tt>.  In other words, it is a fairly
standard circular buffer.
<p>
The code on the kernel side works like this (in pseudocode form):
<p>
<pre>
    tail = smp_load_acquire(ring_buffer-&gt;tail);
    write_events(ring_buffer-&gt;head); /* If 'tail' indicates there is space */
    smp_store_release(ring_buffer-&gt;head, new_head);
</pre>
<p>
The <tt>smp_load_acquire()</tt> operation ensures that the proper tail
pointer is read <i>before</i> any data is written to the buffer.  And,
importantly, <tt>smp_store_release()</tt> ensures that any data written to
the buffer is actually visible there before the new <tt>head</tt> pointer
is made visible.  Without that guarantee, the reader side could possibly
see a <tt>head</tt> pointer indicating that more data is available before
that data is actually visible in the buffer.
<p>
The code on the read side is the mirror image:
<p>
<pre>
    head = smp_load_acquire(ring_buffer-&gt;head);
    read_events(tail);  /* If 'head' indicates available events */
    smp_store_release(ring_buffer-&gt;tail, new_tail);
</pre>
<p>
Here, the code ensures that the <tt>head</tt> pointer has been read before
trying to access any data in the buffer; in that way, <tt>head</tt>
corresponds to the data the kernel side wrote there.  This
<tt>smp_load_acquire()</tt> operation is thus paired with the
<tt>smp_store_release()</tt> in the kernel-side code; together they make
sure that data is seen in the correct order.  The
<tt>smp_store_release()</tt> call here pairs with the
<tt>smp_load_acquire()</tt> call in the kernel-side code; it makes sure
that the <tt>tail</tt> pointer does not visibly change until user space has
fully read the data from the buffer.  Without that guarantee, the kernel
could possibly overwrite that data before it was actually read.
<p>
The ring buffer code worked properly before the introduction of these new
operations, but it had to use full barriers,
making it slower than it needed to be.  The new operations allow this code
to be optimized while 
also better describing the exact operations that are being protected by
barriers.  As it happens, a lot of kernel code may be able to work with the
slightly weaker guarantees offered by the new barrier operations; the patch
changelog says "<q>It appears that roughly half of the explicit barriers
in core kernel code might be so replaced.</q>"
<p>
The cost, of course, is that the kernel's complicated set of memory barrier
operations has become even more complex.  Once upon a time that might not
have mattered much, since most use of memory barriers was deeply hidden
within other synchronization primitives (spinlocks and mutexes, for
example).  With scalability pressures pushing lockless techniques into more
places in the kernel, though, the need to be explicitly aware of memory
barriers is growing.  There may come a point where understanding
memory-barriers.txt will be mandatory for working in much of the kernel.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_barriers">Memory barriers</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/576486/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor576683"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2013 2:59 UTC (Thu)
                               by <b>jcm</b> (subscriber, #18262)
                              [<a href="/Articles/576683/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Obligatory link to the seminal work on the topic: <a href="http://infolab.stanford.edu/pub/cstr/reports/csl/tr/95/685/CSL-TR-95-685.pdf">http://infolab.stanford.edu/pub/cstr/reports/csl/tr/95/68...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576683/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor576815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2013 21:02 UTC (Thu)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/576815/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The work by Peter Sewell's group is also a very good resource for further information: <a href="http://www.cl.cam.ac.uk/~pes20/weakmemory/index.html">http://www.cl.cam.ac.uk/~pes20/weakmemory/index.html</a><br>
For example, the formalization of the C++ memory model by Batty et al. explains how acquire/release work in combination with other properties of a program.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor576685"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2013 4:06 UTC (Thu)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/576685/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      It's all well and good to say that the user code "just" needs to run 
<tt>head = smp_load_acquire()</tt> but have fun trying to find a definition for that function that you can include in your code (that works cross-platform).
<br><br>
For programs trying to access the perf_event mmap interface this often involves having to cut and paste big chunks of kernel code, and that's not really workable if your project isn't GPL2 licensed.  (For example the PAPI performance library is BSD licensed.  When I raised this issue on the lkml the answer I got was more or less "not our problem").

      
          <div class="CommentReplyButton">
            <form action="/Articles/576685/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor576793"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2013 18:27 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/576793/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Help is on the way.<br>
<p>
In C/C++11, smp_load_acquire(x) would be "atomic_load_explicit(x, memory_order_acquire)" and smp_store_release(x, v) would be "atomic_store_explicit(x, v, memory_order_release)".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576793/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor576809"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2013 20:44 UTC (Thu)
                               by <b>luto</b> (subscriber, #39314)
                              [<a href="/Articles/576809/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does that mean that smp_load_acquire will actually match the C/C++11 semantics?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576809/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor576820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 12, 2013 21:23 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/576820/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It will come close enough for almost all uses.<br>
<p>
The only significant difference that I am aware of is that smp_load_acquire() and smp_store_release() have volatile semantics, while their C/C++11 counterparts might or might not have volatile semantics, depending on usage.  There will of course also be type-system differences, but these should not matter for synchronization.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor576831"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2013 1:16 UTC (Fri)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/576831/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Help is on the way.</font><br>
<p>
Theoretically, sometime in the eventual future.  How long will it take for a compliant C/C++11 compiler to appear in say RHEL6?  Some of us develop software that has to be used on non-bleeding-edge systems.<br>
<p>
The perf_event interface is bad enough trying to understand as it is, let alone having part of the interface depending on obscure memory barriers that a normal user can't even access without coding up rare inline assembly instructions.  It once again shows what happens when a tool like perf is included with the kernel; it's next to impossible for outside users to keep on top of the interface.<br>
<p>
It would be much nicer if the kernel could handle this for the user.  Putting something as complicated as this at the hands of the user is just asking for multiple poorly written versions of the access code cut-and-pasted in scattered projects.<br>
<p>
I'd be more worried if the ordering issues had ever been seen in real life.  Has there been any bug reported where perf was failing due to this?  In theory the slightly wrong barriers have been in use since 2.6.32 without anyone really noticing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576831/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor576842"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2013 5:20 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/576842/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It sounds like you are arguing that the required memory barriers should be buried in header files supplied by the kernel.  On this, I must defer to the perf developers and maintainers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576842/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor576879"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2013 15:14 UTC (Fri)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/576879/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  It sounds like you are arguing that the required memory barriers should </font><br>
<font class="QuotedText">&gt; be buried in header files supplied by the kernel. On this, I must defer to </font><br>
<font class="QuotedText">&gt; the perf developers and maintainers.</font><br>
<p>
	<br>
No, I'm saying the interface is complicated to get right and implement.<br>
<p>
I challenge someone, based solely on this article, to write code that properly implements the userspace part of this interface using gcc-4.7 in a way that will work on x86, Power, and ARM machines, without requiring external libraries (and ideally working with kernel headers going back as far as say linux-3.2).<br>
<p>
I am not aware of other system call interfaces requiring a PhD in Computer Architecture plus some guesswork to actually implement, but maybe I've been just lucky with which system calls I usually have to deal with.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576879/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor576922"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2013 16:33 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/576922/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I could be wrong, but I don't believe that the purpose of this article was to serve as the sole reference for writing the user-space code required to interact with perf.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576922/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor576920"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2013 16:42 UTC (Fri)
                               by <b>andresfreund</b> (subscriber, #69562)
                              [<a href="/Articles/576920/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; It sounds like you are arguing that the required memory barriers should</font><br>
<font class="QuotedText">&gt; &gt; be buried in header files supplied by the kernel. On this, I must defer to</font><br>
<font class="QuotedText">&gt; &gt; the perf developers and maintainers.</font><br>
<p>
<font class="QuotedText">&gt; No, I'm saying the interface is complicated to get right and implement.</font><br>
<font class="QuotedText">&gt; [...]</font><br>
<font class="QuotedText">&gt; I am not aware of other system call interfaces requiring a PhD in Computer Architecture plus some guesswork to actually implement, but maybe I've been just lucky with which system calls I usually have to deal with.</font><br>
<p>
I don't think this is a meaningful comparison. Other syscalls have different requirements, and it's not like you need to use this syscall when developing a normal application. Pretty fundamentally it isn't interesting without a good idea of how the performance counters or tracepoints work.<br>
<p>
<font class="QuotedText">&gt; I challenge someone, based solely on this article, to write code that properly implements the userspace part of this interface using gcc-4.7 in a way that will work on x86, Power, and ARM machines, without requiring external libraries (and ideally working with kernel headers going back as far as say linux-3.2).</font><br>
<p>
Why on earth should a random article on the internet, even if from a reputable source, allow you to do that? Also, afaics you can just continue to use full barriers on the consuming side, just as before. It will be a bit slower, but that's it. Doing so should just be a __sync_synchronize() in gcc.<br>
<p>
That said, the interface really isn't trivial, so including a short LGPL/BSD licenced example consumer implementation wouldn't hurt.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576920/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor576936"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2013 18:12 UTC (Fri)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/576936/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I challenge someone, based solely on this article, to write code that properly implements the userspace part of this interface using gcc-4.7 in a way that will work on x86, Power, and ARM machines, without requiring external libraries (and ideally working with kernel headers going back as far as say linux-3.2)</font><br>
<p>
I suppose you're concerned about the atomics that have to be used.  If so, this should be helpful:<br>
<a href="http://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/_005f_005fatomic-Builtins.html">http://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/_005f_005fato...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576936/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor577032"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 14, 2013 20:41 UTC (Sat)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/577032/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
what I'm really trying to do is have a concise bit of code that I can plop into the "accessing the MMAP ring-buffer" part of the perf_event_open.2 manpage that users can cut-and-paste and have confidence that it works.<br>
<p>
Ideally this chunk of code would work for any architecture, across various compilers (gcc/llvm/intel), not require an outside library, and would be license agnostic.<br>
<p>
I suppose I could just put a notice saying "to ensure correctness you need a smp_wb() barrier here" but that's not necessarily very helpful to someone who just wants to read a ring buffer without having to learn low-level details about their architecture's memory ordering implementation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/577032/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor577084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 15, 2013 19:25 UTC (Sun)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/577084/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or, if you would like barriers whose semantic match those of the Linux kernel: <a href="http://urcu.so">http://urcu.so</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/577084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor576854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2013 9:47 UTC (Fri)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/576854/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; Help is on the way.</font><br>
<font class="QuotedText">&gt; </font><br>
<font class="QuotedText">&gt; Theoretically, sometime in the eventual future. How long will it take for a compliant C/C++11 compiler to appear in say RHEL6? Some of us develop software that has to be used on non-bleeding-edge systems.</font><br>
<p>
New atomics builtins that follow the C/C++11 model are offered since GCC 4.7, including the respective C++11 support.  C11 atomics should appear in GCC 4.9, I believe.<br>
<p>
On RHEL, you can get newer compilers for RHEL6, for example (look for the Developer Tools offering).  I don't know whether something similar is available for other distributions; if not, try libatomic-ops (<a href="http://www.hpl.hp.com/research/linux/atomic_ops/">http://www.hpl.hp.com/research/linux/atomic_ops/</a>), which has been part of Debian for a while already and also offers acquire/release atomics.<br>
<p>
Note that on some architectures, there might be several ways in which particular memory orders / barriers could be implemented by the compiler/kernel.  They should hopefully all have chosen the same implementation approach to make them compatible, but I don't know and haven't checked myself.  If you're on a rather strongly ordered architecture like x86, for example, you probably don't need to worry at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor576856"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2013 11:23 UTC (Fri)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/576856/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do you know whether the kernel's and GCC's way to implement barriers / memory orders is compatible (e.g., regarding the seq-cst choice on ARM outlined by the Cambridge group: <a href="http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html">http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html</a>)?  If the atomics "cross" the kernel interfaces, they should be part of the ABI.  I know that this has been discussed for the compilers and compatibility across them at least; I don't know of any "official" ABI document for this though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576856/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor576923"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 13, 2013 16:48 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/576923/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In Peter Zijlstra's latest patch, smp_load_acquire() and smp_store_release() use the "dmb" instruction, which is compatible with the Cambridge group's recipe.  Current smp_mb() also uses "dmb", so is compatible with this recipe's sequentially consistent fence.  The rcu_dereference() primitive is compatible with this recipe's memory_order_consume load.  The rcu_assign_pointer() primitive is currently a bit weaker than this recipe's store release, but I expect to be upgrading rcu_assign_pointer() in the next Linux-kernel release or two.<br>
<p>
The other Linux-kernel memory barriers are not directly comparable to C/C++11.<br>
<p>
So we should be good, at least until someone changes something.  :-)<br>
<p>
Specifying the memory-ordering properties of those user-kernel interfaces that are sensitive to memory ordering might not be a bad idea.  I have a funny feeling that continued pushes for performance in the absence of significant increases in single-threaded CPU performance will make this sort of thing more common...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/576923/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor577690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 19, 2013 10:20 UTC (Thu)
                               by <b>dakas</b> (guest, #88146)
                              [<a href="/Articles/577690/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I hope the implementation is better than the illustration.  If two threads try inserting an element of their own in the same place while being nearly in sync (meaning that one thread is never ahead more than one step of the other), the end result will have only one of the new elements being added to the linked list.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/577690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor577724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Memory barriers for TSO architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 19, 2013 15:03 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/577724/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Obviously, locking is needed between writers, yes.
      
          <div class="CommentReplyButton">
            <form action="/Articles/577724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
