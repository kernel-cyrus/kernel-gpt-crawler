        <!DOCTYPE html>
        <html lang="en">
        <head><title>P4TC hits a brick wall [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/977310/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/977366/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/977310/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>P4TC hits a brick wall</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>June 10, 2024</br>
           </div>
<a href="https://opennetworking.org/p4/">P4</a>, short for "Programming
Protocol-independent Packet Processors", is a programming language aimed at
networking devices; it is useful for the configuration of firewalls and
complicated routing architectures.  Since a lot of advanced networking is
done with Linux systems, it stands to reason that there would be value in
supporting P4 and, indeed, <a
href="/ml/netdev/20230124170346.316866-1-jhs@mojatatu.com/">an
implementation of P4</a> in the kernel's traffic-control subsystem was
first posted by Jamal Hadi Salim at the beginning of 2023.  After nearly
18&nbsp;months, though, this feature has not been merged, and the chances
of that happening would appear to be getting worse.
<p>
<h4>Introducing P4TC</h4>
<p>
The kernel supports a number of traffic-control mechanisms in its
networking subsystem; <a
href="https://man7.org/linux/man-pages/man8/tc-flower.8.html"><tt>tc-flower</tt></a>
is perhaps one of the most commonly used.  The P4TC subsystem proposed by
Salim fits into that subsystem, adding the ability to use the P4
language for the description of networking policies.  It is entirely
implemented in software, and runs within the kernel.
<p>
That software implementation was one of the first aspects of this work to
attract attention.  While one can do complicated network processing and
routing in the kernel, any implementation that is intended to keep up with
current network speeds needs quite a bit of hardware support.  There are
vendors selling networking hardware that is programmable with P4 now, and
P4TC intends to support that hardware, but that capability was not present
in the patch set (or any subsequent version).  Jiri Pirko <a
href="/ml/netdev/Y9QXWSaAxl7Is0yz@nanopsycho/">asked about that
omission</a> in response to the initial posting; Salim <a
href="/ml/netdev/CAAFAkD8kahd0Ao6BVjwx+F+a0nUK0BzTNFocnpaeQrN7E8VRdQ@mail.gmail.com/">answered</a>
that the traffic-control subsystem requires a software implementation for
any functionality that can be offloaded to hardware (thus ensuring that the
functionality is universally available), and that the hardware-offload
interfaces were still under consideration.  Daniel Borkmann <a
href="/ml/netdev/b47d1950-add0-6449-4160-d5e2f7a8d7f7@iogearbox.net/">complained</a>
that nobody would use the software implementation, an assertion that Salim
<a
href="/ml/netdev/CAM0EoMnxXi+LpbLGhW3L60ehw6PwD43U+DVAGbCahaQCbUQN4w@mail.gmail.com/">disagreed
with</a>.
<p>
The other significant comment from the first posting came from Stanislav
Fomichev, who <a
href="/ml/netdev/Y9RPsYbi2a9Q/H8h@google.com/">suggested</a> that, rather
than adding another packet parser to the kernel, P4TC should compile P4
programs to BPF, which could then run under the protection of the BPF
verifier.  That is a suggestion that Salim chose to accept; the <a
href="/ml/netdev/20230517110225.29327-1-jhs@mojatatu.com/">second version
of the P4TC patches</a>, posted in June 2023, included an early
implementation of that BPF support.
<p>
<h4>Increasing opposition</h4>
<p>
Several versions of the P4TC patch set followed, generally receiving little
in the way of reviewer attention.  <a
href="/ml/netdev/20231016093549.181952-1-jhs@mojatatu.com/">Version&nbsp;7</a>,
posted in October 2023, removed the "RFC" tag, indicating that Salim
thought it was ready for merging into the mainline.  <a
href="/ml/netdev/20231116145948.203001-1-jhs@mojatatu.com/">Version&nbsp;8</a>,
which came in November, attracted more comments.  John Fastabend was the
first to <a
href="/ml/netdev/65571196cff83_55d7320865@john.notmuch/">raise</a> what was
to become an ongoing objection: the new kfuncs added by the patch set
implement functionality that is seen as being similar to what BPF maps
already provide.  These kfuncs were received by a few members of the BPF
community as wasteful duplication of code at best, and possibly an abuse of
the kfunc mechanism as well.
<p>
Fastabend later <a
href="/ml/netdev/6557b2e5f3489_5ada920871@john.notmuch/">brought
forward</a> some other objections.  Integrating P4 into the
traffic-control subsystem, he said, was likely to hurt performance in a
number of ways.  Instead, he thought, P4 could be compiled directly to BPF
without the need for the traffic-control part.  The use of netlink to
control P4TC, he said, was slower and more complex than just storing policy
information in a BPF map.  He also complained that the real benefit from P4
comes with hardware offload, but the patch set still had no support for
interfacing with hardware.
Throughout these conversations, Salim tried to address the criticisms that
were directed toward this work, sometimes showing frustration and often
digging in his heels.  The use of netlink, for example, was <a
href="/ml/bpf/CAM0EoM=vbyKD9+t=UQ73AyLZtE2xP9i9RKCVMqeXwEh+j-nyjQ@mail.gmail.com/">described</a>
as "<q>not negotiable</q>".
<p>
<a
href="/ml/netdev/20240122194801.152658-1-jhs@mojatatu.com/">Version&nbsp;10</a>
of the series added more context to the cover letter in an attempt to
explain why certain decisions had been made, but Fastabend <a
href="/ml/netdev/65df6935db67e_2a12e2083b@john.notmuch/">reiterated and
extended</a> his objections in response to <a
href="/ml/netdev/20240225165447.156954-1-jhs@mojatatu.com/">version&nbsp;12</a>,
posted in February.

Also in response to that version, networking maintainer Paolo Abeni <a
href="/ml/netdev/b28f2f7900dc7bad129ad67621b2f7746c3b2e18.camel@redhat.com/">pointed
out</a> that, while a few developers had expressed opposition to the
patches, there were no voices (other than Salim) expressing support; he
wondered if the lack of hardware support might be part of the reason for
that.  Anjali Singhai, <a
href="/ml/netdev/CO1PR11MB49931E501B20F32681F917CD935F2@CO1PR11MB4993.namprd11.prod.outlook.com/">answered</a>
that both Intel and AMD need the hardware offload support, but that they
also need a standard kernel API to manage P4 programs and an in-kernel
pipeline to mix both hardware and software implementation.  "<q>This patch
series helps create a SW pipeline and standard API</q>".  Chris Sommers
also <a
href="/ml/all/IA0PR17MB7070B51A955FB8595FFBA5FB965E2@IA0PR17MB7070.namprd17.prod.outlook.com">expressed
support</a> for the work, giving a long list of reasons why it would be
useful for his company.
<p>
<a href="/ml/netdev/20240325142834.157411-1-jhs@mojatatu.com/">Version
13</a> (late March) got <a href="/ml/netdev/877chfmoe5.fsf@toke.dk/">an
ACK</a> from Toke Høiland-Jørgensen, but little other response.  <a
href="/ml/all/20240404122338.372945-1-jhs@mojatatu.com/">Version&nbsp;14</a>
(early April), instead, gained <a
href="/ml/all/CAADnVQLw1FRkvYJX0=6WMDoR7rQaWSVPnparErh4soDtKjc73w@mail.gmail.com/">an
explicit NACK</a> from BPF maintainer Alexei Starovoitov resulting from his
objections to the BPF integration (and the use of kfuncs in particular).
Borkmann <a
href="/ml/all/f27bfc4d-8985-6d3d-01f5-782ae1ccb9ee@iogearbox.net">added his
NACK</a> shortly thereafter, as <a
href="/ml/all/661444789fccf_49a6208ec@john.notmuch">did Fastabend</a>.
<p>
<h4>In search of a path forward</h4>
<p>
Salim persisted, posting <a
href="/ml/all/20240410140141.495384-1-jhs@mojatatu.com">version 16</a> in
mid-April.  Abeni <a
href="/ml/all/41736ea4e81666e911fee5b880d9430ffffa9a58.camel@redhat.com">suggested</a>
removing the BPF component (and significantly reworking the series) as a
possible way to move the work into the kernel, drawing <a
href="/ml/all/CAM0EoM=982OctjvSQpx0kR7e+JnQLhvZ=sM-tNB4xNiu7nhH5Q@mail.gmail.com">an
exasperated response</a> from Salim, who felt that he should not be asked
to remove the BPF support after having added in response to comments from
the same people who are objecting now.  He later <a
href="/ml/all/CAM0EoM=VhVn2sGV40SYttQyaiCn8gKaKHTUqFxB_WzKrayJJfQ@mail.gmail.com">said</a>:
"<q>My view is this series should still be applied with the nacks since it
sits entirely on its own silo within networking/TC (and has nothing to do
with ebpf)</q>".  Abeni, though, <a
href="/ml/all/87cf4830e2e46c1882998162526e108fb424a0f7.camel@redhat.com">declined
to do that</a>.
<p>
On May 21, Salim <a
href="/ml/all/CAM0EoMmsB5jHZ=4oJc_Yzm=RFDUHWh9yexdG6_bPFS4_CFuiog@mail.gmail.com">came
back</a> with a history of the work and a request that "<q>a third party
mediator</q>" be brought in to look at the situation and make
recommendations.  He put together <a
href="https://github.com/p4tc-dev/pushback-patches">a web page</a>
describing the work, the objections that have been raised, and his response
to them.  That mediator has not been named, though, and it does not seem
likely that this situation will change.  Instead, people like Tom Herbert
have <a
href="/ml/all/CAOuuhY9b6WZd6eunVGr6QQ=sd7KLvx7OVn4ozzon3+ABRQaYeQ@mail.gmail.com">questioned
the value of P4</a> in general, and networking maintainer Jakub Kicinski <a
href="/ml/all/20240522151933.6f422e63@kernel.org">said</a> that "<q>the
submission is neither technically strong enough, nor broadly useful enough
to consider making questionable precedents</q>" like overriding
maintainers.
<p>
As seems to be increasingly frequently the case with controversial kernel
patches, one fundamental question here has to do with just how far a
subsystem maintainer's reach can go.  The P4TC patches are contained within
the traffic-control subsystem, which is maintained by (among others) Jamal
Hadi Salim.  As he has pointed out numerous times, this work <i>uses</i>
BPF, but does not change the BPF subsystem; the BPF developers, he says,
should thus have no right to block it.
<p>
That view notwithstanding, this work appears to be effectively blocked, and
it is not clear where a mutually acceptable resolution might be found.
Potential users like Sommers have <a
href="/ml/all/SN6PR17MB21102057A1745DBCBB101DBB96F42@SN6PR17MB2110.namprd17.prod.outlook.com">expressed
their dismay</a> at this state of affairs, but that does not appear to have
swayed those who are opposed to P4TC.  At this point, the positions are
deeply entrenched and it is hard to see how they might be reconciled.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#BPF-Networking">BPF/Networking</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Networking">Networking</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/977310/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor977799"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 16:05 UTC (Mon)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/977799/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is it the kernel’s job to abstract over the hardware here, or should that be done by a userspace library like Mesa (for GPUs) or rdma-core (for RDMA)?  A P4 NIC is a programmable accelerator, and as such will need a compiler.  Unless that compiler is in the kernel, hardware-dependent userspace will be needed anyway.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977799/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977804"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 17:01 UTC (Mon)
                               by <b>jgg</b> (subscriber, #55211)
                              [<a href="/Articles/977804/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IMHO this is a part of the pushback. It is really unfortunate the details of how the HW offload will work was left largely unexplored on the list. As I understand things the current state of affairs have closed-source userspace compilers involved in the solution. I think several of the dug in positions about why it is designed a certain way are linked to how the OOT/closed solution is tacking on HW offload.<br>
<p>
It is not clear to me there is any path that fits the ideological picture of netdev here for HW offload.<br>
<p>
P4 that is software only with no HW offload is incredibly niche in my mind. The actual production use cases out there are already well served by something like Cillium and don't really have any pain points that P4 is going to fix. Sure researchers/etc may find some value, but I doubt it is worth the cost to the kernel community to carry this thing without HW support. The fundamental difference between P4 and Cillium/etc is that P4 has a path to HW offload and active existing HW offloaded implementations.<br>
<p>
Broadly I think this argument fits into the other recent threads LWN covered on mlx5ctl/fwctl/fbnic. On one side HW creators want to make their stuff work and on the other side kernel netdev folks want to see various ideological things.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977804/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977837"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 22:26 UTC (Mon)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/977837/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is HW offload capability but it is work in progress because vendors are still working on the drivers. There are biweekly (open) meetings discussing hardware offload including one this morning. The API abstraction for offload is well understood via standard tc ndo and is shared/common between the s/w+h/w. As mentioned in the article all prior cases for TC, when hardware offload is involved, the rule is to first produce the s/w piece, so there is/was no imperative to show offload in these patches.<br>
The other thing to note is that some users (MS is probably the most public in this case) like to define their datapath using P4, test it in s/w and then using some vendor hw solution deploy it at scale. The P4TC s/w datapath uses the same APIs as the h/w offload which the folks interested in P4TC see as advantage. There are other stated goals to the s/w datapath in that you dont really need to be an expert on ebpf to generate usable ebpf code. If you are interested in L2-4 datapath you will find P4 much more usable than hand coding ebpf code. <br>
<p>
But to your point, yes hw offload is important because of the NIC speeds (doing s/w datapaths at 100Gbps+ is not realistic). There are vendors out there who are producing NICs that are P4 capable (Intel and AMD are mentioned but other vendors who participate in the biweekly meetings are capable of providing P4 abstractions).<br>
The point here - which i think you are alluding to - is there is a whole industry producing and consuming P4 hardware. The obstructions are coming from folks who have no interest in any of this space.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977837/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977844"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 0:20 UTC (Tue)
                               by <b>jgg</b> (subscriber, #55211)
                              [<a href="/Articles/977844/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it is a false equivilance to compare TC and P4TC. TC is alot simpler and there is a clearer path to a HW mapping. Saying that P4 is the same because there will be some magic NDO op deeply undersells how complex P4 is, and how complex it will be to map to an efficient HW implementation.<br>
<p>
I agree there is alot of energy behind P4 right now, but P4TC's SW only dataplane is not what anyone I know is interested in. They want to see the offload path with clear support for HW. If this does not deliver that then it is not interesting. I think that uncertainy is the source of the tepid support on the list. I also don't know anyone that cares about the TC integration, FWIW.<br>
<p>
It has been over a year now of P4TC without any HW offload patches to show for it, to me this is a big red flag. Show this will actually work and solve the problem people want solved and the tepid support on the mailing list may improve. Prove P4 HW offload can be merged into netdev.<br>
<p>
As I said, I think netdev will never accept it because it is broadly infeasible to put the P4 HW compiler in a kernel driver and netdev will never accept a compiler in userspace.<br>
<p>
As a SW only construct the series effectively picks a fight with eBPF as who gets to be the "software defined API" for Linux networking - it is not surprising they have their own view of how the SW defined API should work - a view that is firmly tied to mapping things to eBPF not to TC.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977844/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977859"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 6:15 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/977859/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; netdev will never accept a compiler in userspace.</span><br>
<p>
Isn't that unnecessarily restrictive? The stance in graphics (after the Habanalabs debacle[1]) is that an open source stack is necessary, but the shader compiler _is_ in userspace.<br>
<p>
[1] <a href="https://lwn.net/Articles/821817/">https://lwn.net/Articles/821817/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977859/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977992"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 19:52 UTC (Tue)
                               by <b>sima</b> (subscriber, #160698)
                              [<a href="/Articles/977992/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Probably making a fool of myself and showing my lack of understanding of network stuff ...<br>
<p>
But why not redirect all this to something like DPDK running in userspace (with maybe tiny wrapper driver like drm has if vfio isn't enough). These things look like accelerators to me that happen to shuffle around network packets as a side effect. Shove it all into userspace except security isolation stuff, which for "you own the entire thing" use-cases is just an iommu driver in the kernel.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977992/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978056"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2024 9:37 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/978056/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Cause DPDK doesn't integrate with the rest of your Linux network stack. The network interface is dedicated to DPDK, bypasses all the Linux host stuff. If you do want to get packets back into the normal Linux stack DPKD has to reinject them - inefficient.<br>
<p>
Also, DPDK historically did not support interrupts. It could only run in polling mode. So DPDK apps generally sit spinning, pegging your CPU(s) at 100%. Horrifically bad for power usage. In principle DPDK now supports interrupt mode - but I'm not sure it's easy to setup or widely useable (I don't know, been a while since I used a DPDK app).<br>
<p>
Basically, DPDK is a PITA, and only worth the pain for special use-cases that really really need the performance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978056/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978063"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2024 10:10 UTC (Wed)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/978063/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Additional point: If you use DPDK it tends to be very specific to a vendor (example see Intel IPDK or Nvidia DOCA, etc), meaning you are locked in to their API. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978063/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978066"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2024 11:22 UTC (Wed)
                               by <b>sima</b> (subscriber, #160698)
                              [<a href="/Articles/978066/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All these points apply to gpu drivers in userspace too.<br>
<p>
Outside of very niche use-cases you need interrupts/blocking waits or you're toast burning power.<br>
<p>
With dma_buf, dma_fence and all the other interop stuff the userspace driver can efficiently interact with all the pure in-kernel graphics subsystems like display, media, cameras. It means a bit more code in your gpu kernel driver shim, but not that much.<br>
<p>
OpenGL as a standard was a fragmented vendor mess 10 years ago, and for performance you had to use the nvidia/amd extensions and rely on all the undefined implementation details. OpenGL4.x and now vulkan much improved the quality of the standard, have real conformance test suits, and on the implementation side mesa3d has massively improved too to give a consistent interface across all supported gpus.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978066/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor978065"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2024 10:36 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/978065/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In many cases, it's much better to use a packet-socket with PACKET_TX_RING and PACKET_RX_RING. This integrates with the normal Linux stack. And you can run BPF/eBPF filters. Performance isn't too far off DPDK either, but your application can actually sleep when there's no packets - no energy-burning spinning!<br>
<p>
PACKET_{RX,TX}_RING has grown-up into XDP. With even better performance, and more possibilities for offloading work down into the kernel with eBPF. For some applications, you could even end up with 0 user-space per-packet work. (Not sure how far XDP has matured for being able to actually forward packets onward and out of the system - without touching user-space - from within eBPF; was being planned, but not widely implemented last I knew, good few years ago).<br>
<p>
Basically, for new projects, look at XDP before DPDK.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978065/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor978057"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Reasons to not direct everything to userspace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2024 10:58 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/978057/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Ignoring the specifics of DPDK, which paulj's been clear on in a sibling comment, there's a big use case for this stuff where you have a border system that talks (say) TLS 1.1 through TLS 1.3, HTTP/1.1 through HTTP/3, and both TCP and QUIC, translating all of that to (say) a TLS 1.2 HTTP/2 TCP connection to a back end system using an internal CA.
<p>You need the stuff that's processed locally (protocol overhead) to come in through the kernel's network stack to your proxy application (probably via kTLS sockets so that you can offload the crypto operations); but you want the bulk data (cat video being sent/received, for example) to bypass the CPU completely, and be decrypted by the hardware, determined to be part of the user data, and re-encrypted for forwarding. You also need the hardware to report what it's done to the kernel TCP stack, so that TCP socket information can be updated, and the hardware prevented from forwarding data if (e.g.) the TCP window is full.
<p>Now, you can do all of this via a completely userspace proxy application; but wouldn't it be nice if the proxy application ran on a developer system without needing the DPDK (or whatever) supported hardware? Ideally, the proxy would be coded to use kTLS and splice to do all the data movement, and the kernel would exploit that to offload as much as is reasonable to hardware.
<p>On top of that, DPDK and similar take over the entire network interface; if you want to use the same network interface for accelerated packet processing, and for (e.g.) in-band SSH to the server, you can't do that without rewriting SSH to use DPDK instead of sockets API. This makes for a fun time if what you're building isn't a plain switch, because some applications want the network interface to expose acceleration to them, while others don't care - and that's what the kernel is there to mediate.


      
          <div class="CommentReplyButton">
            <form action="/Articles/978057/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor977868"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Compiler in userspace or kernelspace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 9:30 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/977868/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
it is broadly infeasible to put the P4 HW compiler in a kernel driver and netdev will never accept a compiler in userspace.
</blockquote>
<p>This seems odd for the kernel; GPU drivers already rely on a userspace compiler stack to provide GPU-specific machine code for each supported GPU, and have instead said that the requirement to be merged is that there exists at least one open source user of any given piece of functionality. This is in part because it's a lot clearer that GPUs need a compiler stack whose complexity is on the order of GCC, LLVM or similar projects, and thus not acceptable in the kernel, to run competitively; a compromise of "open source userspace is the only userspace we care about, it's not a regression if we break closed source userspace" is thus accepted in that space.
<p>Why would netdev not be willing to do the same?


      
          <div class="CommentReplyButton">
            <form action="/Articles/977868/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977879"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Compiler in userspace or kernelspace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 12:02 UTC (Tue)
                               by <b>jgg</b> (subscriber, #55211)
                              [<a href="/Articles/977879/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
netdev has enough history and ideology that makes me doubt the required design would be accepted, as the last few articles have shown netdev has ideas that are not entirely aligned with the broader kernel.<br>
<p>
This is my main point - until this is debated with actual code and people come out and have their say, it is a cloud of uncertainty that hangs over the design. Accepting the SW side uABI before having certainty the HW side can go is not a good idea.<br>
<p>
Yes, some P4 implementations have a LLVM scale compiler in userspace attached to them. The SW complexity depends on the HW architecture. If your HW for implementing P4 is some fixed function table walkers like in a simpler swtich then maybe you can do it in the kernel. If your HW is a crazy VLIW processor pipeline then probably not.<br>
<p>
It is really, really unclear how this all fits together and that netdev will ultimately accept all of it for all the P4 capable HW out there.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977879/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor977871"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 10:51 UTC (Tue)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/977871/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn't iptables/netfilter userspace just a compiler for rules to be put in the kernel?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977871/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor977885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 13:14 UTC (Tue)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/977885/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In regard to complexity:<br>
The fundamentals (or i should say our starting point) is the same - TC provides match-action abstraction which is the core of what P4 needs. The difference with offloads like TC flower or u32 for example is that they assume a "fixed datapath" whereas P4 doesnt. So in flower for example the table IDs and action IDs are hard-coded in the kernel, whereas in P4 they are generated using some agreed format by the compiler. Essentially the driver understands what the IDs are (just as it does for flower for example). There are other differences (eg a table belongs to the system instead of a netdev/port) but in general the tc driver ndo is so far sufficient to cover those abstractions with some minor flags.<br>
<p>
You mentioned the parser earlier being in the kernel or user space, did you mean the the packet parser? For P4TC for offload it resides in h/w and for s/w is generated in the ebpf code. Other TC classifiers like flower use the kernel's built in parser (flow dissector) which needs to be modified everytime a new header needs to be recognized.<br>
<p>
In regards to the compiler:<br>
I didnt grok the issue as to why netdev wouldnt accept the compiler being in user space. I have seen comments like  "vendor offload is evil" and  "binary blobs evil" but i thought we are past that. There are various purely offload schemes being worked on right now as we speak, see Paolo's work on the queue QOS or PSP etc.<br>
I also didnt grok why anybody would want to put the compiler in the kernel. The model we have is that the compiler is fed a static P4 program and generates the necessary artifacts; there is the control piece, some ebpf code if you wish to have s/w offload and a binary blob if you wish to have have offload. <br>
<p>
In regards to offload code:<br>
TBH, most of the eBPF disagreements are in the form of "here's how i would do it" and then tangential chaos ensues. It is why i collected the disagreements here: <a href="https://github.com/p4tc-dev/pushback-patches">https://github.com/p4tc-dev/pushback-patches</a><br>
For that reason, I have lost faith in whether doing everything being asked for would have helped move any disagreement leave alone providing either the glue offload code or a driver would help. Also i didnt feel it was necessary to produce any code because the TC rules are you produce the s/w piece first. Note, there are at least 3 vendors (Intel, AMD, Nvidia) that are involved in these discussions - and our starting point is essentially the TC model.<br>
<p>
Happy to see you mentioned P4 as a "thing" ;-&gt; There are several people whose basis of disagreement is that it is not.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor977848"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 1:21 UTC (Tue)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/977848/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the offload-capable userspace is closed source that is certainly a problem.  I would not be surprised if this would result in an automatic NACK.<br>
<p>
Is there any chance of open source offload support?  That would allow creating an API that isn’t dictated by closed source blobs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977848/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Should userspace be responsible for abstracting over backend?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 12:25 UTC (Tue)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/977881/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There may be some misunderstanding, the only thing not open/accessible is the hw internals.<br>
See this for how the compiler fits: <br>
<a href="https://github.com/p4tc-dev/docs/blob/main/why-p4tc.md#so-i-am-intrigued---how-do-i-get-myprog-installed-into-the-kernel">https://github.com/p4tc-dev/docs/blob/main/why-p4tc.md#so...</a><br>
<p>
The offload approach is no different than how TC flower or u32 etc work today.  IOW, when you add a table entry you can selectively say what goes in h/w vs s/w using the flags "skip_sw" or skip_hw" as described here: <br>
<a href="https://github.com/p4tc-dev/docs/blob/main/why-p4tc.md#so-i-am-intrigued---how-do-i-get-myprog-installed-into-the-kernel">https://github.com/p4tc-dev/docs/blob/main/why-p4tc.md#so...</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 compilers</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2024 19:04 UTC (Wed)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/978187/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For GPUs, Linux requires that the hardware-specific compiler is open source.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor977803"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank You, LWN</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 16:55 UTC (Mon)
                               by <b>linuxrocks123</b> (guest, #34648)
                              [<a href="/Articles/977803/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is at least the second time in less than a year that an article has been posted on LWN about good work that has been blocked by toxic nonsense from people with little to no skin in the game.  Thank you for reporting on this type of thing -- even if corbet does not seem to agree with, or is not willing to say publicly, that that is obviously what is happening.<br>
<p>
Thanks to LWN's reporting, I know not to bother trying to work with the kernel community and instead keep whatever I decide to do in that space out of tree.  That is valuable information and is by itself well worth the price of an LWN subscription.<br>
<p>
I fear for what this means for the long-term health of the Linux kernel, but from personal experience it appears that things have been like this for at least 14 years, so perhaps the kernel community can continue on a path of treating its contributors horribly and still end up with a good kernel.  But I won't be one of them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977803/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977812"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank You, LWN</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 17:36 UTC (Mon)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/977812/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I try to keep my opinion out of things when I can — though the selection of a specific topic to write about is an expression of opinions in its own right.  For the cases you are referring to, my own opinion might not be the same for all of them.
<p>
One opinion I do think I should express, though, is this: I think that the developers involved are taking the positions they are with the intent of having the best and most maintainable kernel possible years from now.  Feeling about how to get there obviously differ, but I do think that the people involved are mostly working in good faith.


      
          <div class="CommentReplyButton">
            <form action="/Articles/977812/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor977842"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank You, LWN</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 22:33 UTC (Mon)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/977842/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I concur with your comments.<br>
As someone who has been around the kernel for 20+ years and contributing to the kernel and other things, i believe it is actually getting worse. There is a bit of a strangle-hold by some of the big users who shall remain nameless - if it doesnt fit their use cases then nobody needs such a feature.<br>
I was talking to someone working on the Sonic project the other day and asked them why they are bypassing the kernel and their response was it wasnt so much they are bypassing the kernel for performance but rather they are "bypassing the kernel process". 18 months later we are still dealing with objections on how we are using kfuncs ;-&gt;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977842/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977847"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank You, LWN</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 0:13 UTC (Tue)
                               by <b>jgg</b> (subscriber, #55211)
                              [<a href="/Articles/977847/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree with you here, not doing work in the kernel is a significant upside to almost any project.<br>
<p>
Only people who have their own private kernel forks have the luxury of having a fast moving kernel that meets their needs. For the rest of us it feels like a constant struggle to get basic stuff in.<br>
<p>
Your 18 months for P4TC is bad, but not a unique story in the kernel. I'm also over a year into a project with no real dissent or objection, it is just so unbearably slow. The people with kernel forks are already running my code, but it will be another year or more before a Red Hat user will get it. Sigh.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977847/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor977860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank You, LWN</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 6:20 UTC (Tue)
                               by <b>nim-nim</b> (subscriber, #34454)
                              [<a href="/Articles/977860/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I’m not sure things are getting worse, people are people and there have been plenty of disagreements in the past.<br>
<p>
What is changing is how Linux and its kernel are becoming a central part in computing,raising the stakes and forcing a lot of people that have no wish to work together to work together.<br>
<p>
It would probably be useful for the Linux Foundation to employ some neutral high-level people dedicated to mediating those situations. Linus can not mediate everything by himself and people are quick to flame him when he steps in a bit too bluntly.<br>
<p>
Of course mediating and getting harassed by both sides is not exactly a dream job.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor977866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank You, LWN</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 9:00 UTC (Tue)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/977866/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
24 years ago, <a href="https://linux.slashdot.org/story/00/06/14/0212208/has-linux-development-become-too-political:">https://linux.slashdot.org/story/00/06/14/0212208/has-lin...</a><br>
<p>
"Has Linux development become too political, bottlenecked and ego-driven? Witness the recent exchange between Hans Reiser, of ReiserFS fame, and Alexander Viro (VFS maintainer) on Linux-Kernel; Hans, and others, were griping about Viro refusing patches and ideas on principle, and Viro keeps telling people to shut up and read the code. It's obvious that the kernel needs better documentation and fewer penis-size contests, but it also needs better 'roadmaps' and plans -- i.e., documentation in advance of changes. Does anyone have a current "org chart" for Linux kernel development? Is Linux Kernel Development sustaintable as a coalition of little feifdoms?"<br>
<p>
I don't think this is a new thing. :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank You, LWN</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 13:47 UTC (Tue)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/977940/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The ego challenges are not new but my point was it is getting to the point of vested interests driving agendas, some being economical some being "coalitions".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor977867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank You, LWN</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 9:12 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/977867/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; There is a bit of a strangle-hold by some of the big users who shall remain nameless - if it doesnt fit their use cases then nobody needs such a feature.</span><br>
<p>
That's one of the objections. The smaller is the number of regular users, the more uncertain is the maintenance.<br>
<p>
But it sounds like the more important objection is the usual one: how can this code be run and meaningfully[*] tested? As long as the answer is "practically impossible except for 5 people", well... Discussions around this point tend to get lost in technical details like userspace vs kernel, hardware vs software, compilers, licences, etc. and sometimes lose track of the only real and important goal: maintenance.<br>
<p>
Funny enough, maintainers care about only 3 things: maintenance, maintenance and maintenance.<br>
<p>
[*] meaningfully= with significant code coverage.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977870"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank You, LWN</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 10:33 UTC (Tue)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/977870/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; But it sounds like the more important objection is the usual one: how can this code be run and meaningfully[*] tested? </span><br>
<p>
But that's the good part about a software only implementation: it can be built and tested by anybody without any hardware. If anything, hardware offload is harder because it cannot be tested by most people.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977870/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977962"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Thank You, LWN</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 14:27 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/977962/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The ability to test drivers without hardware is pure gold, agreed 200%.<br>
<p>
BUT it is never enough because it's never 100% the same. So there also must be a significant number of hardware users who should be able to run the code on actual hardware without too many painful hurdles like expensive and closed source compilers etc. It's not even a political question of licences, freedom  and other FSF things, it's firstly about "How hard is it to run the darn thing and how many people can do it?"<br>
<p>
There are entire CPU architectures regularly removed from the kernel sources! Because they have too few users. FireWire is also hanging by a thread. So adding niche drivers very difficult to expert would make no maintenance sense. <br>
<p>
The only solution for niche drivers is: stable APIs + out of tree. Unfortunately not offered by Linux.<br>
<p>
Disclaimer: I have no idea how "niche" is P4 specifically.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977962/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor977809"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">History of TC actions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 17:30 UTC (Mon)
                               by <b>npws</b> (subscriber, #168248)
                              [<a href="/Articles/977809/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Given the history of Salim, who dumped TC actions into the kernel in a horrible state, with literally hundreds of sloppy bugs, imbalanced locking, use-after-free, incorrect and completely unchecked calls to other subsystems "programmed" by userspace, plenty of copy-and-paste, zero documentation,  you name it, and left the entire mess for others to fix, I can certainly understand the reluctance. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977809/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977826"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">History of TC actions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 19:01 UTC (Mon)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/977826/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Given the history of Salim, who dumped TC actions into the kernel in a horrible state, with literally hundreds of sloppy bugs, imbalanced locking, use-after-free, incorrect and completely unchecked calls to other subsystems "programmed" by userspace, plenty of copy-and-paste, zero documentation, you name it, and left the entire mess for others to fix</span><br>
<p>
Interesting. Why is he still a maintainer then, if his work is lacking technical quality?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977826/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977872"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">History of TC actions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 10:56 UTC (Tue)
                               by <b>andy_shev</b> (subscriber, #75870)
                              [<a href="/Articles/977872/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not talking about him or any other concrete personalia, there are maintainers who know better and worse the code base, the coding practices or even the C programming language. You may find plenty of examples when fellow Linux kernel contributors (and some of them are maintainers) became surprised by a corner case due to lack of deep understanding of the C language or Linux kernel multi-architecture support paradigm. You may even conduct a research yourself — ask people, who you think (or they think) *know* the C language, "what does attribute __packed__ mean?" You will be surprised, I promise.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977872/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978033"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">History of TC actions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2024 1:27 UTC (Wed)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/978033/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; ask people, who you think (or they think) *know* the C language, "what does attribute __packed__ mean?" </span><br>
<p>
Trick question? Of course there's no such thing in the C language (standard)!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978033/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor982237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">History of TC actions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2024 10:26 UTC (Wed)
                               by <b>andy_shev</b> (subscriber, #75870)
                              [<a href="/Articles/982237/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
“C language” used in here in a broder way. Using only standard is impractical and may not give useful results.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/982237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor982241"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">History of TC actions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2024 11:13 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/982241/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm guessing it's like PL1's bitwise declarations?<br>
<p>
I remember Fortran shenanigans trying to read/write logic bits to the OS, where the OS was written in PLP and assigned bits most-to-least significant, while Fortran assigned them least-to-most. If I could have made PLP read them the Fortran way it would have been easy, but sadly Fortran was the consumer not the producer.<br>
<p>
(Oh and if you messed up said bitwise declaration you could REALLY f*** the computer's performance :-) Mind you, mess up anything in PL1 and you could really ruin the computer's performance ... )<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/982241/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor977843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">History of TC actions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2024 22:44 UTC (Mon)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/977843/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wasnt sure i should respond and i dont know who you are - but you are making some rather outrageous commentary. Do you use tc or have in the past? When or how did i dump and abandon things for others to fix? I am very involved in either fixing, reviewing, suggesting or testing all of the tc code and majority of the time it is not code i wrote. I am a volunteer, probably one of the few still hanging around despite the corporatization and these kind of insults are not helpful. Regardless, is the tc code buggier in comparison to other parts of the net subsystem? Do you have some data you can use to backup your claims?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">History of TC actions</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2024 19:12 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/978471/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Do you have some data you can use to backup your claims?</span><br>
<p>
Agreed 100%: this sort of extremely broad and serious attack with absolutely ZERO example or any sort of evidence is only good enough for social media. Please share some data or keep pure diffamation out of here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor977878"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 12:14 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/977878/">Link</a>] (46 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting article. There is a tension here between various interests. The hardware vendors and DC-cloud operators (typically big tech - MS, FB/Meta, GOOG, etc.) who want to have stable kernel interfaces through which they can push changes at a fast rate from *proprietary* user-space to hardware; versus (factions of) kernel maintainers who aren't keen on taking on long-term maintenance of fairly opaque APIs to benefit (generally) proprietary software - the kernel as a dumb pass-through for blobs of proprietary code doesn't fit with their vision. It has to be some noted, other factions of kernel maintainers disagree, and they are typically working for said hardware vendors and DC-cloud operators.<br>
<p>
I don't know what the right answer is here from a kernel perspective. I do try to follow what is happening in software-defined networking pipelines though, and see what the trend is. I want to pick up on something, from the P4TC doc page (<a href="https://github.com/p4tc-dev/docs/blob/main/why-p4tc.md">https://github.com/p4tc-dev/docs/blob/main/why-p4tc.md</a>):<br>
<p>
'In fact two major NIC vendors Intel ref16 and AMD ref17 produce "P4-native" NICs today.'<br>
<p>
And it points at the Intel E2000 and AMD Pensano "NPU" (or "IPU" as Intel call them). These are I/O processing cards and contain a powerful ARM SoC. The Intel has an ARM Neoverse, the AMD one an ARM Cortex A72. These cards are proper computers and are running full Linux systems. As is the NVidia "BlueField" NPU.<br>
<p>
The question has to be asked (which I think shemminger hints at in one of his emails in the thread, in saying that P4 is not how most software people would choose to programme networking, even if it might be useful to hardware people to be able to re-use existing P4 logic and deploy them on a Linux host): <br>
<p>
Is P4 really the best interface for a general Linux host to offload networking to a specialised I/O-offload host?<br>
<p>
To say these NPU/IPUs are P4 based, therefore Linux on the host must support P4 is... incorrect. Even if P4 is a core part of the NPU design (e.g. the Pensando, for sure), the architecture - AFAICT - does not require the I/O-processor &lt;-&gt; host interface to be P4. The NPU&lt;-&gt;host interface could be something else, something more explicit or it could be eBPF. The translation from the NPU&lt;-host interface to the interface of the local tables on the NPU can be done on the NPU ARM. <br>
<p>
Indeed, the interface could quite easily simply be IP. The I/O processor can just be a fairly normal connection-terminating edge-proxy/load-balancer, and send requests on to appropriate services on the containers on the main host. Just using... normal IP.<br>
<p>
Something to bear in mind I think.<br>
<p>
If we look down the road, it seems servers will basically turn into mini-clusters of hosts. With a small (1 main?) number of powerful compute hosts to run containers and user/application processes; and a number of I/O processing hosts to distribute traffic inside the mini-cluster. And is the correct interface here really opaque, proprietary, blobs of a specialised network-HW DSL; or should it look more like a network with, at least, open, robust transport protocols? (Perhaps with RDMA).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977878/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977882"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 12:40 UTC (Tue)
                               by <b>nim-nim</b> (subscriber, #34454)
                              [<a href="/Articles/977882/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the situation is a lot more chaotic than that.<br>
<p>
The DC cloud operators are perfectly fine with open interfaces, they become what they are today *because* they were ready to deploy such open systems (the losers in the DC cloud operator race bet on closed systems providers such as VMWare Cisco &amp; friends).<br>
<p>
The hardware vendors techs are probably fine with open interfaces too, they would not be building embedded Linux NPU systems if they could not stomach those.<br>
<p>
The problem is the hardware vendor management. This management accepts that DC cloud operators could not care less for closed systems, it accepts that DC cloud operators will force them to give up the margins associated with closed systems but there is the problem of the “losers in the DC cloud operator race”. Those guys will buy whatever the DC cloud operators standardise on but lack the market weight to force hardware vendors to give up on closed hardware margins. Ergo, hardware vendors *must* get DC cloud operators to adopt closed systems even if DC cloud operators would not care less about them.<br>
<p>
Thus, the only people that would readily adopt closed interfaces (big business and losers in the DC cloud operator race) are totally absent in the discussion even though everyone else is positioning himself against the money they are likely to feed into the system later.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977882/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977966"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 15:05 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/977966/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The DC-cloud operators _want_ open systems, in so far as having to build on top of closed systems inevitably leads to pain points. (Security, fixing bugs, updating software, etc.).<br>
<p>
However, the same DC-cloud operators very much _want_ to build their own *closed* systems on top of /open/ systems.<br>
<p>
These DC-cloud operators are big enough that they have managed to get vendors to open up a good bit, on drivers and firmware. Either by using their purchasing clout ("Make that open or we don't buy from you") or their engineering clout ("If you won't open the firmware, we will simply write our own and open it"). Though, when it comes to the dominant maker of networking ASICs, that vendor is still firmly closed-source. However, the biggest DC-cloud operators are big enough they can at least get the source - but the public never will.<br>
<p>
Again, the DC-cloud operators would be perfectly happy if they can write their own proprietary blobs in eBPF, P4, whatever, and push them down through open SDKs, kernels, and hardware firmware. At least, open to them.<br>
<p>
You can argue an open high-level, programming interface to a Linux-on-a-smartNIC-with-a-closed-SDK is better than a closed SDK. But... you've got a closed-SDK interface either way, havn't you?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977966/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor977883"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 13:10 UTC (Tue)
                               by <b>jgg</b> (subscriber, #55211)
                              [<a href="/Articles/977883/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The interest in P4 is that every big network operator has their own custom proprietary network with their own ideas for how switching should work. Switching is being used to build all kinds of things now, including high level things NAT and load balancers. They all want to buy commodity HW and SW then customize it with their own custom closed software to make the network behave in their unique way. <br>
<p>
There are many competing options in this broad space, DPDK/rte_flow, Cillium, OVS-switchdev, OVS-DPDK and more. The cloud operator can choose alot of different approaches to build their proprietary logic on top of. P4 is being pushed by a few NIC vendors as a unique value add under the banner of "standards", but on the flip side right now P4 with OOT/closed compilers is competing against a fully open DPDK/rte_flow.<br>
<p>
To make a point really clear, it is not that the host must understand P4, but the OS running the NIC-switch must run P4, because P4 SDK is the only option some NIC vendors offer. This might be the OS inside a physical switch, the OS running in ARM cores on an xPU, or the OS running in a hypervisor providing switching for VMs. All of these places run Linux and all of these places have an interest in an upstream solution.<br>
<p>
IMHO netdev has consistently failed to offer a stack that people want to use in the HW switching space. Actual switches are dominated by SDKs and NIC switches are principally DPDK or some OOT P4 thing right now.<br>
<p>
Maybe P4 is a way to fix that, but defiantely not without in-tree and open HW offload support.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977883/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977958"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 14:25 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/977958/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've worked at one of the big network operators that is doing all kinds of stuff on Linux based switches and servers with offload NICs. Bit out of date, but I can imagine.<br>
<p>
And "You only get a P4 SDK" rings very familiar. Before it was "You only get a &lt;switch family specific&gt; binary SDK". Which really sucked if you wanted to support more than 1 family, never mind 1 more than 1 vendor. The operator I worked at was big enough that - grudgingly - they were able to get source for the SDK from a major (secretive) vendor. But that's something available only to gigantic customers.<br>
<p>
"P4 SDK" sounds like the latest way for switch ASIC vendors to avoid releasing actual programming information.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977958/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978202"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Reverse engineering?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2024 22:24 UTC (Wed)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/978202/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Could reverse engineering be an option?  That is a fairly common approach in the GPU world.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978202/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor977886"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 14:06 UTC (Tue)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/977886/">Link</a>] (39 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, and there are 2 major interfaces here:<br>
<p>
1. The way the general host programmes the NPU or I/O processor. <br>
2. The way the hardware is actually programmed <br>
<p>
For a lot of these new-style NPUs (i.e., a small switch chip with an ARM SoC), interface 1 could easily be a JSON-RPC / ReST daemon running on the NPU, that whatever mgmt software on the main host talks to over HTTPS over IP over PCIe; or ssh. In the long run, these kind of interfaces might be more generally useful and better.<br>
<p>
For the 2nd, it would be nice to have the direct hardware interface described. Sending P4 to a Linux SoC on a PCIe card, so some proprietary software can interpret the P4 to /actually/ programme the hardware kind of.... sucks... and is a bit of an end-run around the GPL really.<br>
<p>
There are also (at least) 2 different high-level use-cases here:<br>
<p>
a) Load balance incoming connections: Flow-steer, or perhaps even run some or all of a transport network protocol (TCP or perhaps QUIC; maybe even HTTPS - the cards surely can or will soon be able to do thisd), and deliver the data directly to the correct socket buffer; while applying firewalling, tc, etc., rules. Basically, avoid having to vswitch between host and containers on the main host.<br>
<p>
b) Do all kinds of weird network rerouting - encapping, decapping, etc. <br>
<p>
Does the former need P4? Or can it be done with more general purpose protocols?<br>
<p>
Meanwhile, much of the latter can be covered by a declarative specification. Because nearly all the hardware is composed of various kind of tables. If you want fast networking, you generally need a pipeline of fixed-function units that each apply an action based on lookup tables (config tables, state tables). The composition of the pipeline itself determined by a table. The manuals for fast forwarding chips run to hundreds of pages of definitions of tables basically. Fast networking pipelines are not made of general-computation programmable logic - defeats the purpose.<br>
<p>
The dominant manufacturer absolutely hates releasing documentation. And that attitude carries over to a lot of other vendors (whether cause they believe in keeping things secret; or just cause they suck at writing docs, and wouldn't want to have to commit to effort of public docs). P4, in a sense, allows them to encode the programming of these chips into an opaque binary, and avoid publishing the actual docs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977886/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 15:26 UTC (Tue)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/977969/">Link</a>] (33 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes on the two interfaces.<br>
Part of the challenge is that although #1 abstraction of what a datapath should accomplish can be prescribed in P4 different vendors will have different #2 approaches to instruct their ASICs. The goal here is to standardize things coming from the control plane all the way to hitting the driver tc ndo and then let the vendor take it from there. Certainly a vendor could define their own (proprietary) approach. Having a common interface does not mean the hardware has to be "P4 native", you can have an entirely different architecture as long as you conform to those interfaces. As a consumer i would only need the h/w document if i run into bugs.<br>
<p>
Both #a and #b are achievable via P4 - as long as you can describe them in match action tables. Some of the newer xPUs have ability to do stateful table updates in h/w so you can do some clever stateful load balancing.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2024 13:30 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/978067/">Link</a>] (32 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What do you mean by "P4 native" hardware? Wouldn't that be an FPGA?<br>
<p>
I'm a bit confused by P4, I have to admit. <br>
<p>
I understand the genesis, in that declarative interfaces to network equipment can seem to become unwieldy. P4 allows one to write a more concise /specification/ for an interface to a _particular_ set of networking equipment; and P4 is general enough that it can be used to such specs across a variety of such sets. I.e., P4 definitely works for the purpose of a better language to /go on/ to produce a _family_ of specifications to describe networking hardware (rather than trying to extend a declarative spec like OpenFlow, making it bigger and bigger).<br>
<p>
However, the reverse does not follow. It does _not_ follow that one can write arbitrary P4 and have it be implementable by whatever P4-enabled networking equipment, _unless_ the networking equipment is at least an FPGA, or a general purpose computer. But in neither case will you get really good networking performance - especially not the latter. To get good performance, you must use P4 to compose a pipeline of fixed-function blocks. But then, you must stick to a subset of P4 that is within the bounds of the actions those blocks can take - you can not implement arbitrary P4 on such equipment.<br>
<p>
So... the place of P4 is funny. As a network specific HDL, that might be nicer for hardware people to describe network hardware, I guess that makes sense if the hardware people think so. I guess it makes sense to build an open library of network function blocks, that can be synthesised and implemented in FPGAs and what not (but the P4 docs say their examples are more simplified examples - not production quality; so... that's not the open library of useful blocks?).<br>
<p>
As a language to target Smart NICs for offload, or software-defined pipelines on general-purpose computers: Does P4 really make sense? The Smart NICs will be a set of fixed-function blocks - not able to implement general P4. So do you need P4? The pure software computer pipeline - well an actual programming language (eBPF-targeting subset of C or C++ or Rust or whatever) makes more sense there, surely?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 13, 2024 19:25 UTC (Thu)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/978344/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You caught me at the right time paulj, so i will provide a more verbose response.<br>
<p>
"P4 native" means the presented abstraction on hardware is P4. Infact the hardware details as presented to the programmer by the vendor are  P4, see for example the blocks labelled P4 in: <a href="https://www.servethehome.com/pensando-distributed-services-architecture-smartnic/">https://www.servethehome.com/pensando-distributed-service...</a><br>
<p>
So IOW, for these vendors it is the ASIC that provides the abstraction. To provide the P4 abstractions you could use other h/w like FPGA to provide the MAT(+other objects), example FPGA vendors like Xilinx and that forked-out Intel FPGA vendor provide P4 abstractions (eg see <a href="https://www.xilinx.com/products/intellectual-property/ef-di-vitisnetp4.html">https://www.xilinx.com/products/intellectual-property/ef-...</a> or <a href="https://www.intel.com/content/www/us/en/software/programmable/p4-suite-fpga/overview.html">https://www.intel.com/content/www/us/en/software/programm...</a> ). Of course abstraction on FPGAs is not exactly free - you will consume resources/gates just to provide the abstraction, which means limited pipelines and on very speacilized cases for you are better off writting a one-off datapath that is proprietary to you and organizations with enough skills do that. For average skills or TTM reasons providing a well understood abstraction like P4 helps. <br>
Having said that: While designing the ASIC from day one to more P4 friendly gives you an advantage as long as you have MAT pipelines built in you can infact abstract out P4 (likely at some extra abstraction cost), example NVIDIA ASICs can abstract out P4 just fine. And it also doesnt mean that what is labelled as "P4 native" is entirely conformant (I have seen example support of a match followed by multiple actions whereas the spec says there can only be one action).<br>
<p>
Reading between the lines, you probably already know that some cloud vendors are spec-ing out to NIC vendors what they want the hardware to do using P4 (some public like MS, others in private). That doesnt harm in comoditizing this abstraction.<br>
<p>
To your second point on reverse being true - even for FPGA when the vendor provides you a "P4 suite" for their h/w it doesnt mean you can arbitrarly make changes to it. You would have to go through them to make changes, so from that perspective they are no different than ASICs unless you wrote you have the skills to write your own RTL/P4 pipeline.<br>
A general purpose computer can of course implement anything - but it would be silly to for example implement a pipeline which includes table with a few hundred thousand ternary matches because you are literally looking at looping a few hundred thousand times to find a match. An ASIC (or an FPGA) would do that in one cycle. So at low speeds, general purpose CPUs work just fine. When you start looking at 100Gbps+ it doesnt make sense anymore from compute/power given packet rates.<br>
<p>
I would not call it a "pipeline of fixed-function blocks", rather it is a pipeline of MATs or maybe even better description is the abstraction is a graph of MATs since you can conditionally select which path to take, etc. So what you would call "network function blocks" at the low levels are essentially either P4 programs or a collection of P4 programs. Most of these vendors can infact load multiple P4 programs. We are going to be putting out quiet a few examples of P4 programs samples once upstream succeeds. My all-time favorite is a totally useless program that acts as an in-network calculator.<br>
<p>
There are also limitations depending on the vendor and model, so knowledge on hw is in some cases required - table sizes for example(although most of these guys cheat a bit by using high latency DRAM to store excess entries), actions limitations, what the table lookups are available (eg some may be missing ability to do range lookups), what kind of tables follow each other in a pipeline (is it an exact match first then LPM or the other way round)etc,  etc. With P4TC we are suggesting a "constraint" file which describes what the hw capability/constraints are and if such a file is fed to the compiler we would even constrain what the s/w datapath can do as well. See: <a href="https://github.com/p4tc-dev/docs/blob/main/images/why-p4tc/p4tc-compile-workflow-install.png">https://github.com/p4tc-dev/docs/blob/main/images/why-p4t...</a> - but those are ongoing discussions...<br>
<p>
As to whether general language like Rust or eBPF makes more sense, my personal view is a specific DSL is a better choice . I am sure eBPF and Rust users would disagree with me, but frankly i dont want to keep wrestling with the internals of for example verieifer or whatever rust allocation rules are. I know how my datapath should look like and I can present my 10 tables and how a packet will flow across using P4 and then let the compiler generate the ebpf or Rust. And with the right constructs you shouldnt need a lot of expertise in eBPF or Rust if any. Not trying to blaspheme but I would rather not pay prime $ to have such expertise in house.<br>
<p>
P4 is also still evolving, for example if you look at the pensando block diagrams or details you'll notice that they are allowing to integrate classical features like TSO, or RSC(hardware offloaded GRO) on the host side TX/RX part described using P4.<br>
<p>
Typed too much in there and feel i may have digressed and missed something you were asking...<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978853"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 3:14 UTC (Wed)
                               by <b>Kamilion</b> (subscriber, #42576)
                              [<a href="/Articles/978853/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a great breakdown that kind of nails why most people seem to be talking past each other.<br>
<p>
I've been following the "SmartNIC" Arms race from the sidelines as an equipment recycler for quite a while.<br>
<p>
<p>
So then, my question to jhs2 is, now comprehending the hardware graph and silicon layout to a degree, where is the P4-extended Linux Kernel and it's corresponding compiler/SDK running? This is inside of the SmartNIC's context on it's AArch64 kernel? On the host's AMD64 kernel? Inside of a SME VM running on one of the AMD64 cores? On some random Raspberry Pi5 plugged into a Asmedia switch plugged into a PLX bridge? Across a CXL boundary? Across a OpenMP boundary?<br>
<p>
If we're talking about, say, the kernel on a pensando or bluefield card, It seems to me that the only P4 SDK that would make sense to run would be AMD or nvidia's, and not say, Silicom's or InterfaceMasters'.<br>
<p>
I dug a bit into the P4TC github links and didn't really seen anything about that scope.<br>
(Re: The Jeff Geerling Will-It-Pi angle)<br>
<p>
And then the general questions more applicable to others:<br>
<p>
Aren't we running into the linux-firmware bloat problem yet again? <br>
<p>
As a gamer, I really hate seeing a gigabyte plus of smartnic firmwares being pushed down to random consumer devices that may not even have expansion ports in the general sense.<br>
<p>
As a recycler, it really bothers me that the smartnic firmwares being distributed are practically useless without digging around forums trying to find people's progress dumps and random vendor ftp sites with questionably-old tooling, and readmes that seem stuck in the linux 3.x era, effectively making this very nice 10Gbit+ hardware worthless to resale compared to a plain X540. <br>
"It used to be, pick up a couple DAC cables from 10Gtek and you were good to go."<br>
<p>
As a system administrator, dealing with racked equipment, it really bothers me that I can't easily manage discrete systems anymore due to the sheer amount of indirection between whatever CLI I've been given and the actual hardware underneath. I have a BEAUTIFUL shiny-chromed out b****com 40gbit switch chassis with a PCIe management card slung to a supermicro X11 motherboard in the back, DPDK packages for the b****com chip, but I've only been able to get the original NetBSD image to operate on it. Got a Juniper QFX5200, has an embedded xeon running the show, but again, stuck with it's original NetBSD. The *only* "open" hardware I have in my lab is an arista running ONIE to get OpenVSwitch. "It's honestly pathetic." In that respect, I am more open to embracing P4 if it means a more useful abstraction that I can rely on, but I take what I can get.<br>
<p>
<p>
Something one can do about this is *accept* there are weird people who play video games for entertainment in the world, and make assumptions that some places linux can run is very not in the wheelhouse of where the latest 800Gbit DWDM physics magic happens.<br>
<p>
Honestly, I'm kind of thankful Keith Packard saw the light and opened his viewpoint past the narrow "windowing system" lens he had been viewing things with, after (in my understanding) visiting Valve, putting on a VR headset, and getting nauseously sick from the experience, culminating in the general feeling of "Ah, yes, this needs some fixing..."<br>
<p>
It's not that I wish others to get nauseously sick, but I do wish more maintainers and developers would allow themselves to peek outside of their subsystems a little further. It's hard to get a 10,000 foot view when you've got blinders on to whole segments of users... ("oh, android doesn't count towards linux marketshare!")<br>
<p>
Today's enterprise smartnic is tomorrow's integrated small form factor consumer 5gbit quad port router appliance.<br>
<p>
Right now, it seems like the waterfall effect has encountered some rocks parting the stream, with big corporate logos emblazoned upon them. But in the end, it all ends up in the ebay pool below, and if nobody plucks the fish out of the ebay pool, downstream to the grinders and e-waste graveyards it goes. At the very least, the bluefield cards can switch roles and act as standalone computers in backplane hosts, running plain linux tasks without much aid from acceleration, such as ServeTheHome's own zfs-iscsi-export video demonstration.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978853/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor978862"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 10:42 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/978862/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks for the long and detailed reply. Very informative and useful. Thanks.<br>
<p>
I think what you write on the P4 abstractions is consistent with my comment. You write P4 to basically compose the pipeline of fixed-function blocks, and you can also write more P4 to do custom processing on a CPU (e.g. ARM NeoVerse SoC on a SmartNIC in the case of "offload", or on the main CPU of the host). I'm not sure what a MAT is though.<br>
<p>
And it was implied to me that in this pipeline 1 fixed function block can conditionally output to more than 1 other block. E.g. an output could go to a tunnel decap block, or an MPLS encapping block. An output packet can also be recirculated back to an earlier part of the pipeline. It's also implied each block can have 1 or more table based memories (specialised like TCAMs in some cases, or not) to do associative lookups of some detail of a packet to retrieve some information to guide the action. Well known kinds of pipelines from L3 switch ASICs - which is what P4 is designed to be able to describe. These fixed function blocks can not run arbitrary P4 programmes. You need a CPU for that. Some L3 switch ASICs (and hence SmartNICs can or will have) do indeed have CPUs in them, but - the generation I know about anyway - could in no way handle packet processing in any significant way. Nor do I think an ARM SoCs in a SmartNIC could either. They can handle a good bit of packets, but not line-rate 20+ Gbps I think.  (But... performance keeps getting better).<br>
<p>
Anyway, it's interesting. Clearly, there are many very capable people in the networking hardware industry who believe P4 is the best way forward for them to provide a capable interface to ever more capable networking hardware. And no doubt they have a lot of expertise here.<br>
<p>
However, I do still share the concern of others - including another reply to you here - that these exist in some part to allow vendors to ship hidden and proprietary Linux systems, and so avoid /actual/ openness.<br>
<p>
Anyway, thanks for the long reply, appreciate it!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978862/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 11:22 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/978865/">Link</a>] (27 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
These fixed function blocks can not run arbitrary P4 programmes. You need a CPU for that.
</blockquote>
<p>Note that P4 is intended to be a pipeline; your program starts with a finite state machine that parses the packet to extract interesting data (possibly using an externally supplied data table as part of the parsing process) as metadata attached to the packet. You then pass the packet and the metadata through a series of match-action tables; each match-action table compares the parsed metadata to its match conditions, and if it has a match, it performs the corresponding action (edit the packet, change metadata etc). After you've performed all the actions, the modified set of packet and metadata is fed to a finite state machine that serializes it to the right place for output.
<p>And the matches in P4 can all be expressed as "turn all the metadata for this packet into a big binary number, AND with a mask, XOR with a toggle, compare for equality with a value". This, in theory, would permit you to express any P4 pipeline with a single match-action table; in practice, because of the size of the big binary number, you implement multiple match-action tables, and a way to choose which bits of metadata go into the match for each table.
<p>Because there's no looping involved here, all of this can be expressed without a CPU or similar; your parsing and output FSMs may benefit from being implemented on a tiny fast CPU, but the sequence of match-action blocks doesn't really gain from being part of a CPU.



      
          <div class="CommentReplyButton">
            <form action="/Articles/978865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978868"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 12:06 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/978868/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, sorry, you need an FPGA or a CPU (or a fab) to be able to "run" arbitrary P4. I had stated that in earlier comment in the thread. In practical terms, that means a CPU.<br>
<p>
Fixed function elements can not implement arbitrary P4.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978868/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor978869"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 12:11 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/978869/">Link</a>] (25 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Note that there can be looping. Packets can be recirculated back to an earlier stage of the pipeline. The state controlling this and further parsing (and looping/recirc) being the stack of packet headers - which the logic can pop/push/modify.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978869/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978926"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 14:05 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/978926/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      <p>None of this needs a CPU or FPGA inside the ASIC, though, unless you'd count something like the <a href="http://www.righto.com/2016/02/reverse-engineering-arm1-instruction.html">ARM1 sequencer</a> as a CPU; you can do all of the things P4 does using a sequencer and the ability to recirculate a packet. You don't need the ability to go backwards in a P4 program, and recirculation works by starting a new instance of the program, skipping forwards to the right stage, and passing in the data that was given during recirculation.
<p>While you can't have a completely fixed function dataflow any more, you can do what you need to do for P4 programs with a sequencer, rather than a full CPU.


      
          <div class="CommentReplyButton">
            <form action="/Articles/978926/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 14:58 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/978938/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think we disagree. Yes, of course you can implement P4 in hardware. The point of P4 is to describe hardware-implementable pipelines.<br>
<p>
My point is that I don't think that any given hardware pipe-line, even one with sequencers all along it (as I'm sure there are in at least some line-speed switching ASICs ) can not implement any arbitrary P4 specification - least not efficiently, not even with generous provision of sequencers in every place. Am I wrong in thinking that?<br>
<p>
Again, I'm not saying a CPU is required for P4. Not at all. I am saying that for any given network P4 device consisting of a pipeline of fixed-function blocks, with pipeline implying a level of selectability in the output of one to input of next - including selecting recirculating back to an earlier stage (with the modified state), there is a /subset/ of P4 that is directly implementable on that pipeline.  (You say "replace with another P4 programme" in a hardware pipeline that is "recirculate packet").<br>
<p>
To fully support all of the P4 the user might want, outside of that subset, vendors at the moment are providing CPUs. That is my understanding from things like Bluefield, Pensaro, and Intel E2000. And these happen to be full-blown embedded Linux systems. Pensaro looks like it has the most interesting of P4-support-hardware, based on what I can find. Be interesting to play with it.<br>
<p>
Am I wrong on or missing something, or do we actually agree? :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 14:59 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/978942/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry, I am sure there are some parts of line-speed switching ASICs with sequencers. But.. not all along the pipeline (AFAIK). Old knowledge. Not merchant silicon - internal product use only - and discontinued now I think.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor978943"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 15:21 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/978943/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <p>I disagree with you; the entire point of P4 is that it is possible to design hardware that can be configured to run an arbitrary P4 program efficiently. It won't be a pipeline of fixed function blocks - it will be a sequencer running over a P4 program, and choosing different fixed function blocks to access a packet in turn, according to the program that it's sequencing over.
<p>Now, there are going to be limits here - like you can only recirculate a fixed number of times before the hardware drops below line rate, and you can only have a certain complexity of program - but that's true of CPUs, too - I can't run a program that needs 4 GiB of code on a 32-bit CPU, for example.
<p>And AFAICT looking at SmartNICs, they're providing CPUs because they want to do things beyond what P4 offers. P4 is effectively a hardware-first reimagining of BPF, and you <em>can't</em> do all the exciting things people want to do with P4, just as you can't with BPF. Rather than telling customers that they can't have a SmartNIC that does that, they've shoved a CPU in there so that you can have a SmartNIC do anything software can do.


      
          <div class="CommentReplyButton">
            <form action="/Articles/978943/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 15:35 UTC (Wed)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/978945/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Still trying to navigate the LWN interface - i responded via email but didnt see it here, so repeating some of those points here..<br>
<p>
farnz, your comments are on topic in regards to P4 (and the analogy to ebpf restriction was apropos). <br>
<p>
To paulj's comment however I would like to point out in the case of P4TC, you may express things in P4 that your chosen NIC may not support in its hardware and we need to have exceptions in s/w. Meaning we can extend the pipeline to (slower) s/w<br>
The TC (flower for example) model has this concept of "continuation" - where some lookup construct you cant express otherwise or some action your hardware doesnt support is implemented in the branched-to-cpu part of the pipeline. Today, we leave this as an "operational" logic to the human operator to make the call when they populate the table entries to explicitly call out with "skip_sw", meaning "i want this in hw" vs "skip_hw" meaning "I want this in s/w part of the pipeline". So consider the processing pipeline as being in h/w and/or s/w. <br>
There are more complex models we are currently discussing, but the summary is that the logic at the moment is burdened on the human. Of course we support multiple independent P4 programs which can be executed in some sort of if-else approach but at the moment in order to "start simple" for offload we only allow one P4 program (you can have multiple in s/w). In the future the compiler or some AI system would be able to produce a better distribution of what goes in h/w or s/w via some constraints knowledge it has + consideration of your end goals.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979052"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2024 9:49 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/979052/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting stuff.<br>
<p>
Is the AMD MPU ISA documented somewhere? Are the LLVM changes for MPU support published?  Does the LLVM MPU support mean we can write MPU programmes in languages other than P4, in principle?<br>
<p>
Cool stuff. I need to try find a project that could use this and persuade someone to fund it. ;)<br>
<p>
I think if the hardware ISA was open, and the Linux system on the card open, that there's a _lot_ of scope for experimenting with interesting architectures for future Linux distributed computing and network offload.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979052/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor979049"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2024 9:45 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/979049/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I still don't think we disagree. Least, I don't disagree with you.<br>
<p>
On "can only recirculate a fixed number of times before the hardware drops below line rate", last I knew high-end L3 ASIC hardware could not keep up with line rate for peak PPS. Now, peak PPS requires small packets, and workloads rarely are dominated by line rate small packets. However, every time you recirculate your peak PPS halves.  Basically, recirculation has a very immediate effect on peak PPS. <br>
<p>
On largely fixed function classic pipelines, recirculating generally corresponds to encap/decap network technologies (VxLAN, etc.). You generally don't have more than 1 level of those. Maybe it's the same with for the hardware you're considering.<br>
<p>
One thing I hadn't been aware of is the architecture of AMD Pensando. It's very hard to find detailed information on its P4 acceleration things. I can't find a manual for the instruction set at all. The most detailed information I can find is a HotChips paper:<br>
<p>
  <a href="https://ieeexplore.ieee.org/document/9352483">https://ieeexplore.ieee.org/document/9352483</a><br>
<p>
Basically an 8-stage, 4-wide pipeline of "MPUs" - I/O processors of some kind, but unclear how programmable. If an ISA manual is available, I can not find it. Are they more like CPUs or more like sequencers - I'm not sure. I assume latter.<br>
<p>
It fits in exactly with what you're saying. But it also fits in with what I'm saying - all these things come with CPUs to handle the stuff that can not fit in dedicated IO pipeline processing logic (even if that logic has some restricted programmability). So I don't see how we disagree. The reality is the vendors are shipping CPUs to both run management (reconfig, etc.) and provide a slow-path for processing logic that does not map onto the I/O hardware. That was part of my point, I don't see how you can disagree with it.<br>
<p>
The point I *care about* is the vendors are *not* providing the hardware manuals on how to actually programme those I/O pipelines (whether the programme elements are based on high-speed micro-controllers, sequencers, not sure). Instead we have to rely on an embedded Linux system, which - I assume - has a proprietary LLVM blob in it to do the P4-&gt;I/O pipeline programme translation. That sucks for the long-run.<br>
<p>
(Are the AMD Pensando LLVM changes for MPU support public?).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979049/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Arbitrary programs on fixed function blocks</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2024 9:51 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/979053/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, and peak PPS - i.e. with minimum size packets - also directly affects average PPS on normal workloads. At some point even normal workloads will start to contend, if enough packets are recirculating back through the pipeline.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor979051"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why CPUs on SmartNICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2024 9:55 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/979051/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
 It fits in exactly with what you're saying. But it also fits in with what I'm saying - all these things come with CPUs to handle the stuff that can not fit in dedicated IO pipeline processing logic (even if that logic has some restricted programmability). So I don't see how we disagree. The reality is the vendors are shipping CPUs to both run management (reconfig, etc.) and provide a slow-path for processing logic that does not map onto the I/O hardware. That was part of my point, I don't see how you can disagree with it.
</blockquote>
<p>Vendors are shipping CPUs not because it's needed to run management or provide a slow-path for processing P4 logic that does not map onto the I/O hardware, but because people want SmartNICs that go above and beyond what P4 allows you to do. You seem to be under the impression that the CPU is needed to implement parts of P4; at least on the ones I've encountered under NDA, the P4-enabled SmartNICs do not implement any part of P4 in the CPU.
<p>Instead, the CPU exists so that the SmartNIC can do things that aren't possible with P4; I <a href="https://lwn.net/Articles/978057/">gave an example in a different comment</a> of a proxy using P4 to accelerate load balancing external TLS connections to internal servers. The SmartNIC vendors believe (rightly or wrongly) that rather than having an application on the host CPU doing the bits of TLS that hardware can't do (certificate verification, for example) and doing the HTTP protocol version translation, people want a SmartNIC that handles all of that for them so that the application on the host CPU is reduced from "handle TLS protocol, do HTTP protocol translation for the things that get forwarded to other hosts, handle some requests locally" to "handle requests locally".


      
          <div class="CommentReplyButton">
            <form action="/Articles/979051/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979060"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why CPUs on SmartNICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2024 11:00 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/979060/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can the SmartNIC you have in mind run /any/ synthesis of P4 to its P4 engine(s)?<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979060/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979061"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2024 11:06 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/979061/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <p>Within the same limitations as a CPU, yes. Obviously, as the P4 program gets more complicated, the rate at which it can handle packets falls, and it has limits on how much RAM it access (so you can't compile a P4 program that needs more than the available RAM to a hardware configuration).
<p>The SmartNIC in question also has a CPU, because the manufacturer boasts that it can do things like TLS termination (including certificate chain processing) on the NIC chip, which can't be done in a P4 program. But you can hold the CPU in reset (in theory) if you just want P4 programs to run on the SmartNIC.


      
          <div class="CommentReplyButton">
            <form action="/Articles/979061/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979066"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2024 12:27 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/979066/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The limitations are going to be quite a bit different to the CPU though. At some point of complexity, the P4 sequencers will be slower than the CPU; at a further point, the P4 sequencer pipeline simply won't handle it. The CPU will be slower, but able to still work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979066/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979072"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2024 13:00 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/979072/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <p>At least on the device I've seen under NDA, that's untrue. The CPU's limitations are a lot more significant than the P4 sequencer pipeline when running P4 programs; any P4 program that the P4 engine can handle will run on the network pipeline at a higher PPS with the same or lower RAM consumption as it would take on the CPU, and the P4 engine can address as much RAM as the CPU can.
<p>The reason for the CPU is that there are things you can't express in P4 (like "do X.509 certificate verification"), but can express in the CPU's machine code.



      
          <div class="CommentReplyButton">
            <form action="/Articles/979072/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979127"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2024 16:05 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/979127/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok, well, that sounds like a game-changing piece of kit. Very very interesting. Maybe one day not too far away you can come back here and tell me what it is.<br>
<p>
I still would have questions like the ones about Pensando to jhs2 here: <a href="https://lwn.net/Articles/979052/">https://lwn.net/Articles/979052/</a><br>
<p>
I'd rather programme such things in some C subset than in P4. And if I were to invest in that hardware in some way, I'd want the LLVM changes to be open.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979127/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 11:59 UTC (Fri)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/979230/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
paulj, the bottlenecks in these devices are IO (the ethernet wire and PCIE), not your packet processing pipelines. At 2x100G (~300Mpps in each direction) while i havent personally had need to verify i am told by the NIC vendors i have access to you can recirculated 2-3 times and still handle that throughput just fine. There's clearly an added latency and the more you recirculate implies your throughput will go down but not as bad as you going via s/w. So to farnz's comment on the significance in performance is very real.<br>
<p>
To your other question, i think you'll need to sign an NDA to get the low nutsnbolts details.<br>
Reading your comment on "I'd rather programme such things in some C subset than in P4. And if I were to invest in that hardware in some way, I'd want the LLVM changes to be open" brings up some questions for me:<br>
<p>
So the whole MPU abstraction is based on a common processing flow (which P4 is designed to prescribe) that does:<br>
{<br>
  1. parse the headers of interest into some vector<br>
  2. lookup some table with a key = {headers and/or metadata}<br>
  3. run some logic based on your #2 results (may keep doing #2 and #3 many times based on your pipeline logic)<br>
  4. put together headers of interest and send out to one or more destinations<br>
}<br>
<p>
If that is the common flow, what do you feel can be improved on that workflow or even it begs the question if there is a "better way"?<br>
To your other point:<br>
Even if you got your hands on the manual which allowed you to register-bang your way through some logic, why would you want to? One reason that comes to mind is you can probably write something optimal. IMO, that would come at a cost of needing a paulj a) we are lucky to have paulj in a project because he is a maestro at this b) paulj will get it done in two days at 100% performance. No offense intended, but I would rather have that new grad get this done in a week and at real cheeep. I will probably end up with 10% performance degradation with the new grad but i am certain those are things that can be improved over time. I guess the point i am trying to get to is tooling with a DSL like P4 in order to improve productivity is a win.<br>
 <br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979234"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 12:57 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/979234/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess for NPU/DPU/IPUs, there are only a couple of ports, so there is maybe more headroom on max PPS. The 2-3 time recirc headroom is interesting. Useful too. <br>
<p>
On your new grad, I don't ask you to hire me. I just want to be able to programme the thing in a language of my own choice, and I want the general eco-system to be able to extend and improve the language and library support around these devices without having to rely on you. The AMD Pensando MPUs have some kind of programmable ISA, which probably can support more than just P4. I don't want to bit-bang it, I want to write code in some familiarish language and have an *open* compiler produce the right bit sequence - why would I bit-twiddle it myself? :) <br>
<p>
Let's turn this around though. Why would you, as the vendor of this device (let's say - you're closer to the vendors than I am I think), think that you can gain enough of my trust to sell me a device that relies on a _proprietary compiler toolchain_ (whether embedded into the SmartNIC's Linux image, or available as an SDK I can run on my own Linux host)? It's 2024 and vendors are still trying to push proprietary compilers on users? Many of us have experience of this, and it's a huge PITA.<br>
<p>
In answering, bear in mind, that there is a long history of vendors of fancy, niche, new networking hardware either: a) Going bust; or b) Getting bought up by some massive vendor, and the hardware and its support being cancelled about 2 to 3 years later.<br>
<p>
I want sustainable tooling. Sustainable means the ISA must be documented in at least open code, if not proper hardware manuals. Sustainable tooling means /others/ can maintain the compiler changes, and port them forward, long after the vendor has gone bust / lost interest. Sustainable tooling means /others/ can add their own tools (other language front-ends, ports, extensions, improvements, etc.).<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979234/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979304"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 16:43 UTC (Fri)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/979304/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
2 ports seems to be the most common setup. 2x100G was circa last 1-3 years. 2x200G is common and i believe there are 2x400G you can order. Market is heading towards 2x800G. I believe you can always add octopus cables to split into lower link speeds although havent tried it (and it may depend on the SKU). And no I dont work for any of them - just a linux zealot who has been doing SDN for many years.<br>
<p>
There are other accelerators in most of these devices that already can be integrated into Linux proper (TLS, IPSec, de/compression, NVME offloads etc). IMO, I dont think you can get one ring of abstraction to rule them all so P4 is not an answer to all these offloads but it is a very nice shoe-in to the niche which is MAT; and give the MPU maps to a MAT engine I dont see why a subset of a general purpose programming language like C would be the best fit. You mentioned in one of your earlier comments that a lot of networking folks sat down and agreed that this abstraction is a good way forward. Those folks may be off base in their thinking in some cases but from a general perspective not that far off from  years of experience building these devices.<br>
<p>
re: the mythical new grad, I dont want to hire you because you are more than likely to be more expensive given your knowledge and there's probably only 10 pauljs in total in the world that already work for different cloud vendors ;-&gt;<br>
<p>
That said i totally empathize with your freedom point and the bad experience when hardware gets EOLed or vendors going kaput - and I too want sustainable tooling.<br>
<p>
The P4 compiler (at least P4C) is open source. AFAIK, there is no opposition by the vendors for their backends to be open source. I am certain they want to hide certain things they think are some big secret (which probably all their competitors already know!). My hope is there may be a middle ground to allow for that as opposed to absolute objection that everything binary blob is eeveel.  I am trying to be pragmatic and this may be the wrong question: Would you be ok if we let the vendors hide some things or you are totally against them hiding anything?<br>
<p>
"I want to write code in some familiarish language .." - is that because you love that language or feel you will be more productive? What should it be? There are religions out there centred around languages. Some people think ebpf is the hammer, they just need your problem to look like a nail.<br>
To re-emphasize my opinion: a DSL provides more preciseness than a general purpose language (regardless of how restricted it is) like ebpf or rust.<br>
I will only use general purpose languages because i can only find for example C programmers in the market, etc.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979304/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor979266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 15:07 UTC (Fri)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/979266/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;&gt; I'd rather programme such things in some C subset than in P4</span><br>
<span class="QuotedText">&gt; If that is the common flow, what do you feel can be improved on that workflow or even it begs the question if there is a "better way"?</span><br>
<p>
This is a thing that constantly happens in the FPGA and ASIC world. Every few years someone with extreme software brain comes along, who has spent so much time writing C-like languages that they think that's synonymous with computation. Or maybe at some level just scared of being a complete beginner again. And they look at all of the DSLs and the bad vendor tooling and conclude that the problem is that it's not LLVM and C. And so they try to make some tool to turn LLVM IR into RTL (doesn't work, you've lost too much information, you basically need to write a decompiler first) write their own C-like IR (ditto) write a new C compiler (can work, but the output will just look suspiciously like a worse CPU with a hardwired program) or C subset (might as well be a new language, you will spend more time learning it than just learning a HDL).<br>
<p>
And at the end of all that, you're forced to realize that effective programming requires tools that match the mental model of the system you are targeting and that no amount of SSA wrangling is going to bridge that gap for you. (Which is annecdotally why people with functional or logic programming experience do a lot better)<br>
<p>
Anyway, P4. It's a lot like that too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979302"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 15:15 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/979302/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Other HDLs are possible too. Much higher level pattern-&gt;action matching DSLs are possible too.<br>
<p>
There's no good reason to not release the LLVM changes.<br>
<p>
"Software people should learn P4" is certainly not a good reason.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979302/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor979265"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 13:44 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/979265/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>The difficulty with a C subset is that the device is too constrained to running P4 pipelines to run anything even marginally C-like (no backwards jumps allowed, for a start); P4 is an open language with a formal specification, so I don't see a huge issue programming it in P4.
<p>What I do think the vendors need to do is stop trying to hide the details of how the pipelines work behind proprietary obfuscation layers, and instead give us open source P4 → device bytecode compilers, documentation for their extensions to P4 (so that we can use the driver to work out how the extensions are implemented), and open source drivers that put the bytecode on the card in a way that's functional (along with documentation explaining why the driver does what it does).
<p>With all of that, it'd be a lot easier to address the whole set of issues around SmartNICs.


      
          <div class="CommentReplyButton">
            <form action="/Articles/979265/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979269"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 13:55 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/979269/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We have a C subset for eBPF, which started out with no loops - and only limited loops now. We also have packet filter specification languages that can be compiled to BPF. Why /must/ we be constrained to P4, for hardware the vendor has to provide a compiler for anyway?<br>
<p>
"give us open source P4 → device bytecode compilers, documentation for their extensions to P4 (so that we can use the driver to work out how the extensions are implemented), and open source drivers that put the bytecode on the card in a way that's functional (along with documentation explaining why the driver does what it does)."<br>
<p>
You're agreeing with me. :) That's exactly what I've been saying. I don't want a closed LLVM SDK. I want at least the LLVM source changes to be published. (I say LLVM, cause this issue only arises with LLVM, and not GCC). <br>
<p>
There's no secret sauce in that bytecode.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979269/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979270"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 14:14 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/979270/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>We don't need to be constrained to P4, but from the vendor point of view, you've got hardware which does straight-line packet processing according to the P4 pipeline rules - why support another language?
<p>That's why I care more about the compiler being open source than about the language the vendors use as input. If the vendors provide an equivalent of Mesa's shader compilers, but for P4 instead of GLSL and SPIR-V, then the community can write the languages we want. If we ask for a C subset, there's a good chance that what we'll get is one C subset per vendor, which can only be compiled using vendor-proprietary tools.


      
          <div class="CommentReplyButton">
            <form action="/Articles/979270/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 14:40 UTC (Fri)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/979271/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You're restarting my position. If you scroll up, I've been saying we need to at least have the compiler back-end changes open-source, so that the wider world has at least the option of adding wider support than just P4.<br>
<p>
Without going back into the debate around how capable these MAT/MPU ISAs are (cause... I can't say as the ISAs aren't public AFAICT, and you can't really either as you're under NDA), from our discussions here + the AMD/Pensando MPU HotChips IEEE Micro paper it is clear these devices have enough programmability to support at least restricted programming languages - with loops (you made that point yourself).<br>
<p>
I mentioned C (whatever subset), only for my own immediate preferences, nowhere did I argue /only/ C ;) (just scroll back), I could imagine lots of other possibilities, from simpler declarative filter languages, to having some kind of modern network version of AWK+tcpdump - i.e. that really nice "PATTERN { ACTION } PATTERN { ACTION } ...." form of AWK, with tcpdump/libpcap like filter language for the PATTERN - to lots of interesting DSLs. E.g., there is a Haskell based HDL as an academic project. Lots is possible.<br>
<p>
There is no reason why it has to be restricted to P4. Other than that a vendor has proprietary LLVM changes and only wants to support a P4 front-end.<br>
<p>
We - the potential users - shouldn't be happy with that and shouldn't accept that. Especially not users who are long-time LWN subscribers.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor979306"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 16:53 UTC (Fri)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/979306/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
re:<br>
<span class="QuotedText">&gt; We have a C subset for eBPF, which started out with no loops - and only limited loops now. We also have packet filter specification languages that can be compiled to BPF.</span><br>
and<br>
<span class="QuotedText">&gt; it is clear these devices have enough programmability to support at least restricted programming languages - with loops</span><br>
<p>
I think it's important to point out that these are vastly different things. I think calling them "loops" or even an "ISA" is a pretty unhelpful characterization. Which is partly to blame on the vendors overrepresenting what they can do of course.<br>
<p>
My general, non-NDA (or at least not mine ;) understanding of how these types of devices are built up, at least as of a few generations ago, is as a set of high level functional blocks attached to a set of fabrics. A "program" is then just a set of bits describing how to wire these blocks together. For example, one set of bits may configure a memory unit to read an address from the math unit, a math unit may be configured to read bits from the packet and another memory unit, etc. Then when a packet comes in, all of these things happen, not in a linear sequence, but mostly simultaneously.<br>
<p>
A "loop" then, is basically just putting the packet back where it came from for another round. You can't, say, loop over each byte in a packet or something like you could do in BPF. Excluding loop-like things implemented by a functional block (e.g. copying memory), you generally get one loop for your whole program. Also the reason for looping is not generally even that you actually want to loop over anything logically. Usually it's that you've run out of blocks. If your program has 5 memory lookups and your device has 4 units there's nothing you can do, another trip through the pipeline it is.<br>
<p>
So it's not really like an ISA in the sense we're used to from CPU land. There are no discrete instructions here that you could step through. In CPU terms, you might think of them as a CPU where the packet is the instruction to be executed and you get to upload the microcode that decides what it means.<br>
<p>
(if you're unfamiliar with what microcode looks like, it actually looks pretty much exactly like what I described above)<br>
<p>
I hope that explains a bit why vendors are in no particular hurry to release details on their "ISA"s either. It's all pretty closely tied to intricate hardware details and there wouldn't really be a lot of room for developers to do things differently in the way they have done for CPUs. It would still be really neat, for sure. But I also understand why it's not happening.<br>
<p>
At the end of the day, we already have something that can execute things that look like C code as fast as we know currently know how to do. They're called "CPUs". If this was just a slightly different CPU, there'd be no point to any of this :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979306/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor979316"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 SmartNIC limits</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2024 17:31 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/979316/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But how do you define the language that should be supported? Different vendors have different subsets of functionality. And you simply can't punt processing to the CPU at these speeds.<br>
<p>
P4 looks like a good middle-ground and vendors support it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/979316/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor978925"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2024 15:09 UTC (Wed)
                               by <b>jhs2</b> (subscriber, #107016)
                              [<a href="/Articles/978925/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So I got inspired from the discussions here (thank you! some things may seem obvious to me but may not make sense to an outsider) and did  a small update to the document to provide some clarity,<br>
see: <a href="https://github.com/p4tc-dev/docs/blob/main/why-p4tc.md#deployment-model">https://github.com/p4tc-dev/docs/blob/main/why-p4tc.md#de...</a><br>
<p>
To respond to Kamilion:<br>
That section may be able to answer most of your questions, otherwise let me know and i can fix it up.<br>
Our goal is to make the operational model and tooling "Linux-conscious" i.e a model a Linux admin (or as the kids say these days "operator") will understand into mainstream kernel to avoid what you described as needing "random vendor ftp sites with questionably-old tooling".<br>
There is a bias/desire to cater to folks who have deployed TC + offloads.<br>
The "SDK" is essentially the APIs to the kernel which allow for CRUD + publish/subscribe (nothing we are inventing, it is how netlink works). We are putting out changes to iproute2 for p4tc but that wont scale in a cluster environment, so we are offering a library you can link in to your app if you wish.<br>
<p>
There is the unavoidable vendor aspect of course in the sense you are going to need their P4 compiler backend to generate the offloading blob that gets loaded. See the box which says "vendor backend" in:<br>
<a href="https://github.com/p4tc-dev/docs/blob/main/images/why-p4tc/p4tc-compile-workflow-install.png">https://github.com/p4tc-dev/docs/blob/main/images/why-p4t...</a><br>
We are trying to standardize the driver interfaces for runtime control and loading mechanisms - and as expected, there's a lot of religious views (some around "Eeevil vendor binary blobs")<br>
So to your comment on whether Silicom's or InterfaceMasters' would work, if they support the tc ndo or variation of in their driver then it boils down that they still need a compiler backend that generates the blobs that talk to their hardware.<br>
<p>
The general consensus right now in the biweekly offload discussions (we'll have a session at netdevconf as well) is the vendors will ship you a "default" P4 program. The P4 program will be available from the vendor for you to look at and recompile if you wish. This shipped program is expected to be well tested and supported by the vendor just as they would a fixed pipeline today exposed in the form of TC flower for example. When the reset happens, this is whats gets loaded. You can recompile your own binary of course and add extensions or do a purpose built one (with constraints on what the h/w can do) and then load that instead (I suspect the support model will be very different, YMMV).<br>
Hopefully that gives some confidence that when you buy this NIC off ebay and it should benefit from the tooling we are pushing for. Of course the alternative is the existing user space etc tooling from the vendor that is guaranteed to bit-rot.<br>
<p>
paulj, a MAT is a "match action table". If you look at the AMD blocks shown earlier, they refer to that unit as  "MPU", you can look at it as unit of operation.<br>
To your and I believe marcH and others concerns: "that these exist in some part to allow vendors to ship hidden and proprietary Linux systems, and so avoid /actual/ openness."<br>
<p>
There is no doubt vendors want you locked in. But the hope here is that by providing standard interfacing we are neutering some of those desires. IOW, i should be able to move my P4 program to another NIC if i wish to, with the constraint that the NIC offers what i need in hardware. So I may move to a different vendor maybe because they offer some more capacity or higher speed or some feature that meets my requirements better etc.<br>
<p>
And yes, there is "mini-clusters" mentality even on some NICs (example the Nvidia CX7 already has some extra embedded RISCv CPU). This could get very complex and my hope is that P4 is a good starting point on which we can build on. I dont believe for even a nanosecond that the RISCv exists because they want to hide something rather it exists because they are solving a customer problem.<br>
To be pragmatic: IMO, I dont see it as evil and TBH, a lot of these vendors produce proprietary interfaces and blobs because a) they really dont want to deal with the Linux upstream process (i mean look at the excruciating effort with P4TC), b) they want to put out a working, supportable product.<br>
This is not something my idealistic self would have said a few years ago: there has to be some middle ground where as a community we dont default to labelling them as evil (again not ruling out that there's some evil intent). Maybe getting older doesnt always equate to getting more grumpy..<br>
<p>
To your comment "there are many very capable people in the networking hardware industry who believe P4 is the best way forward for them to provide a capable interface to ever more capable networking hardware":<br>
P4 is the only standardized datapath DSL accepted today by most vendors and consumers so it makes sense to support.  It is not by any means perfect, but it is what is available. Our view is the people running the standardisation are very receptive to feedback so we will work with them to make it more host friendly.<br>
<p>
In regards to your comment on whether we need a CPU or not (meaning a s/w datapath), we do in some cases. To follow the flower model, there maybe some table constructs that are missing in your hardware in which you let the pipeline continue to the CPU. But typically this is an exception to the rule for high performance.<br>
<p>
I may have missed some other comment....<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978925/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor977988"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 18:13 UTC (Tue)
                               by <b>intelfx</b> (subscriber, #130118)
                              [<a href="/Articles/977988/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Sending P4 to a Linux SoC on a PCIe card, so some proprietary software can interpret the P4 to /actually/ programme the hardware kind of.... sucks... and is a bit of an end-run around the GPL really.</span><br>
<p>
Well, this is exactly what's happening with the latest iteration of Nouveau (where the NVIDIA GPUs grew an additional "GSP" RISC-V chip which basically runs the entirety of the previous proprietary kernel-space driver, which in turn makes it possible to write a clean, neat, tidy free software kernel-space driver... which is unfortunately nothing more than a tiny wrapper that sends commands to the _actual_ proprietary driver to execute.<br>
<p>
And the kernel community seems to welcome this development with open arms, so what gives?<br>
<p>
<span class="QuotedText">&gt; and is a bit of an end-run around the GPL really.</span><br>
<p>
That said... regardless of how much this situation sucks from a common sense perspective, the GPL does not attach across hardware boundaries.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977988/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor977995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 11, 2024 20:11 UTC (Tue)
                               by <b>airlied</b> (subscriber, #9104)
                              [<a href="/Articles/977995/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wouldn't say open arms, it was impossible to proceed in practically any other way to support that particular hardware. All the fw is signed, so we can't write our own. The signed fw we had been receiving from the vendor prior to GSP, was functionally limited, bespoke for nouveau and hard to get support for. GSP firmware is the same fw as the vendor uses in their driver and isn't functionally limited.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/977995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2024 19:32 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/978474/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; All the fw is signed, so we can't write our own. </span><br>
<p>
Locking down production devices is now the norm. It's never going to go away.<br>
<p>
All customers should focus on requesting one thing from vendors: a good _Developer Mode_<br>
<p>
<a href="https://www.chromium.org/chromium-os/developer-library/guides/device/developer-mode/">https://www.chromium.org/chromium-os/developer-library/gu...</a><br>
<a href="https://thesofproject.github.io/latest/getting_started/intel_debug/introduction.html#chromebooks-and-sof">https://thesofproject.github.io/latest/getting_started/in...</a><br>
<p>
Some companies do this "spontaneously". Others only after legislative action.<br>
<p>
Related: <a href="https://en.wikipedia.org/wiki/Right_to_repair">https://en.wikipedia.org/wiki/Right_to_repair</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor978055"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2024 9:33 UTC (Wed)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/978055/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, an "end-run around the GPL" implies avoiding the reach of the GPL. So, that's what they're doing in some of these cases. <br>
<p>
That said, if what they're doing in some NPU is avoiding putting code into host Linux kernels by putting it into closed-source Linux kernels on an NPU linux image, they may be hiding the fact from the operator of the host - and avoiding some of the pain of closed-source kernel modules wrt system updates of general purpose Linux distros - but they're obviously not avoiding the requirements of the GPL.<br>
<p>
However, I imagine the P4-&gt;hardware programming on these Linux-based NPUs is in user-space on those cards.<br>
<p>
And it sucks we still have hardware companies thinking that it's a good idea to not document their hardware interfaces, but instead hide the programming of the hardware behind layers and layers of SDKs and (now with P4) Abstract-Hardware-DLs (AHDLs? Not a real-HDL anymore, in a sense).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978055/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor978473"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2024 19:25 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/978473/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; And it sucks we still have hardware companies thinking that it's a good idea to not document their hardware interfaces, but instead hide the programming of the hardware behind layers and layers of SDKs and (now with P4) Abstract-Hardware-DLs (AHDLs? Not a real-HDL anymore, in a sense).</span><br>
<p>
Customers want more control, vendors want customers to have less control.<br>
<p>
What's new?<br>
<p>
Nothing: business as usual. Literally.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978473/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor978476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">P4 Native NICs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 14, 2024 19:43 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/978476/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; If we look down the road, it seems servers will basically turn into mini-clusters of hosts. With a small (1 main?) number of powerful compute hosts to run containers and user/application processes; and a number of I/O processing hosts to distribute traffic inside the mini-cluster. </span><br>
<p>
SoC have been "mini-clusters" for a long time and not just servers. Just look at the size of <a href="https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git">https://git.kernel.org/pub/scm/linux/kernel/git/firmware/...</a><br>
<p>
<span class="QuotedText">&gt; And is the correct interface here really opaque, proprietary, blobs of a specialised network-HW DSL; or should it look more like a network with, at least, open, robust transport protocols? (Perhaps with RDMA).</span><br>
<p>
It's hard enough to standardize interfaces between discrete pieces of hardware (I mean TCP/IP, Ethernet, Wifi, Bluetooth, etc.). I think there's much less incentive for the same standardization to happen _inside_ the same chip. Don't get me wrong: there is "hardware code re-use" and standard buses but many hardware companies at best don't care about protocols and software run on top, and at worst try to use these for vendor lock-in and to make more revenue. It's just business.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/978476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
