        <!DOCTYPE html>
        <html lang="en">
        <head><title>Support for the TSO memory model on Arm CPUs [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/970907/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/971094/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/970907/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Support for the TSO memory model on Arm CPUs</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 26, 2024</br>
           </div>
At the CPU level, a memory model describes, among other things, the amount
of freedom the processor has to reorder memory operations.  If low-level
code does not take the memory model into account, unpleasant surprises are
likely to follow.  Naturally, different CPUs offer different memory models,
complicating the portability of certain types of concurrent software.  To
make life easier, some Arm CPUs offer the ability to emulate the x86 memory
model, but efforts to make that feature available in the kernel are running
into opposition.
<p>
CPU designers will do everything they can to improve performance.  With
regard to memory accesses, "everything" can include caching operations,
executing them out of order, combining multiple operations into one, and
more.  These optimizations do not affect a single CPU running in isolation,
but they can cause memory operations to be visible to other CPUs in a
surprising order.  Unwary software running elsewhere in the system may see
memory operations in an order different from what might be expected from
reading the code; <a href="/Articles/576486/">this article</a> describes
one simple scenario for how things can go wrong, and <a
href="/Articles/844224/">this series on lockless algorithms</a> shows in
detail some of the techniques that can be used to avoid problems related to
memory ordering.
<p>
The x86 architecture implements a model that is known as "total store
ordering" (TSO), which guarantees that writes (stores) will be seen by all
CPUs in the
order they were executed.  Reads, too, will not be reordered, but the
ordering of reads and writes relative to each other is not guaranteed.
Code written for a TSO architecture can, in many cases, omit the use of
expensive barrier instructions that would otherwise be needed to force a
specific ordering of operations.
<p>
The Arm memory model, instead, is weaker, giving the CPU more freedom to
move operations around.  The benefits from this design are a simpler
implementation and the possibility for better performance in situations
where ordering guarantees are not needed (which is most of the time).  The
downsides are that concurrent code can require a bit more care to write
correctly, and code written for a stricter memory model (such as TSO) will
have (possibly subtle) bugs when run on an Arm CPU.
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
The weaker Arm model is rarely a problem, but it seems there is one
situation where problems arise: emulating an x86 processor.  If an x86
emulator does not also emulate the TSO memory model, then concurrent code
will likely fail, but emulating TSO, which requires inserting memory
barriers, creates a significant performance
penalty.  It seems that there is one type of concurrent x86 code — games —
that some users of Arm CPUs would like to be able to run; those users,
strangely, dislike the prospect of facing the orc hordes in the absence of
either performance or correctness.
<p>
<h4>TSO on Arm</h4>
<p>
As it happens, some Arm CPU vendors understand this problem and have, as
Hector Martin described in <a
href="/ml/linux-kernel/20240411-tso-v1-0-754f11abfbff@marcan.st/">this
patch series</a>, implemented TSO memory models in their processors.  Some
NVIDIA and Fujitsu CPUs run with TSO at all times; Apple's CPUs provide it
as an optional feature that can be enabled at run time.  Martin's purpose
is to make this capability visible to, and controllable by, user space.
<p>
The series starts by adding a couple of new <a
href="https://man7.org/linux/man-pages/man2/prctl.2.html"><tt>prctl()</tt></a>
operations.  <tt>PR_GET_MEM_MODEL</tt> will return the current memory model
implemented by the CPU; that value can be either
<tt>PR_SET_MEM_MODEL_DEFAULT</tt> or <tt>PR_SET_MEM_MODEL_TSO</tt>.  The
<tt>PR_SET_MEM_MODEL</tt> operation will attempt to enable the requested
memory model, with the return code indicating whether it was successful;
it is allowed to select a stricter memory model than requested.  For the
always-TSO CPUs, requesting TSO will obviously succeed.  For Apple CPUs,
requesting TSO will result in the proper CPU bits being set.  Asking for
TSO on a CPU that does not support it will, as expected, fail.
<p>
Martin notes that the code is not new: "<q>This series has been brewing in
the downstream Asahi Linux tree for a while now, and ships to thousands of
users</q>".  Interestingly, Zayd Qumsieh had posted <a
href="/ml/linux-kernel/20240410211652.16640-1-zayd_qumsieh@apple.com/">a
similar patch set</a> one day earlier, but that version only implemented
the feature for Linux running in virtual machines on Apple CPUs.
<p>
Unfortunately for people looking forward to faster games on Apple CPUs,
neither patch set is popular with the maintainers of the Arm architecture
code in the kernel.  Will Deacon <a
href="/ml/linux-kernel/20240411132853.GA26481@willie-the-truck/">expressed</a>
his "<q>strong objection</q>", saying that this feature would result in a
fragmentation of user-space code.  Developers, he said, would just enable
the TSO bit if it appears to make problems go away, resulting in code that
will fail, possibly in subtle ways, on other Arm CPUs.  Catalin Marinas,
too, <a href="/ml/linux-kernel/ZiKyWGKTw6Aqntod@arm.com/">indicated</a>
that he would block patches making this sort of implementation-defined
feature available.
<p>
Martin <a
href="/ml/linux-kernel/28ab55b3-e699-4487-b332-f1f20a6b22a1@marcan.st/">responded</a>
that fragmentation is unlikely to be a problem, and pointed to the
different page sizes supported by some processors (including Apple's) as an
example of how these incompatibilities can be dealt with.  He said that, so
far, nobody has tried to use the TSO feature for anything that is not an
emulator, so abuse in other software seems unlikely.  Keeping it out, he
said, will not improve the situation:
<p>
<blockquote class="bq">
	There's a pragmatic argument here: since we need this, and it
	absolutely will continue to ship downstream if rejected, it doesn't
	make much difference for fragmentation risk does it? The vast
	majority of Linux-on-Mac users are likely to continue running
	downstream kernels for the foreseeable future anyway to get newer
	features and hardware support faster than they can be
	upstreamed. So not allowing this upstream doesn't really change the
	landscape vis-a-vis being able to abuse this or not, it just makes
	our life harder by forcing us to carry more patches forever.
</blockquote>
<p>
Deacon, though, <a
href="/ml/linux-kernel/20240419165826.GB4020@willie-the-truck/">insisted</a>
that, once a feature like this is merged, it will find uses in other
software "<q>and we'll be stuck supporting it</q>".
<p>
If this patch is not acceptable, it is time to think about alternatives.
One is to, as Martin described, just keep it out-of-tree and ship it on the
distributions that actually run on that hardware.  A long history of
addition by distributions can, at times, eventually ease a patch's way past
reluctant maintainers.  Another might be to just enable TSO unconditionally
on Apple CPUs, but that comes with an overall performance penalty — about
9%, <a
href="/ml/linux-kernel/f6484dcd-ebf6-4b6f-be17-69b05539e33b@marcan.st/">according
to Martin</a>.  Another possibility was <a
href="/ml/linux-kernel/87zftoqn7u.wl-maz@kernel.org/">mentioned</a> by Marc
Zyngier, who suggested that virtual machines could be started with TSO
enabled, making it available to applications running within while keeping the
kernel out of the picture entirely.
<p>
This seems like the kind of discussion that does not go away quickly.
One of the many ways in which Linux has stood out over the years is in its
ability to allow users to make full use of their hardware; refusing to
support a useful hardware feature runs counter to that history.  The
concerns about potential abuse of this feature are also based in long
experience, though.  This is a case where the development community needs
to repeat another part of its long history by finding a solution that
makes the needed functionality available in a supportable way.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Architectures-Arm">Architectures/Arm</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_model">Memory model</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/970907/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor971290"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2024 14:58 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/971290/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  Interestingly, Zayd Qumsieh had posted a similar patch set one day earlier, but that version only implemented the feature for Linux running in virtual machines on Apple CPUs.</span><br>
<p>
Does this mean it is on for the virtual machine but off for other processes running at the same time? On different cores? I'm confused about how "dynamic" this can be...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971290/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971291"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2024 15:13 UTC (Fri)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/971291/">Link</a>] 
      </p>
      
      </div>
      </summary>
      It's plenty dynamic; enabling it for a virtual machine (only) is entirely doable.  A similar approach (mentioned in the article) was discussed for the other patch set.


      
          <div class="CommentReplyButton">
            <form action="/Articles/971291/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor971325"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2024 23:51 UTC (Fri)
                               by <b>thoughtpolice</b> (subscriber, #87455)
                              [<a href="/Articles/971325/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, support for TSO on Apple Silicon is enabled on a per-process basis, and TSO-enabled threads must run on performance cores. Therefore virtual machine software (which runs just like any other normal process) can just enable it before relinquishing execution to the VMM.<br>
<p>
This is a pretty big requirement in general because the Rosetta 2 emulator in macOS needs to be able to run x86 binaries efficiently and TSO is required for that, but you don't want to introduce a large performance penalty on the rest of the system to enable it. It would be pretty bad if your machine just randomly hit a 10% performance cliff the instant you started a single emulated x86 app anywhere (command line or a script, for instance).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971325/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971394"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 13:57 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/971394/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
TSO-enabled threads must run on performance cores
</blockquote>
<p>Does this mean that you can't switch the efficiency cores into TSO mode? If that's the case, then it's not just a 10% performance cliff, but also an energy consumption hit for workloads that could otherwise run just fine on the efficiency cores alone.


      
          <div class="CommentReplyButton">
            <form action="/Articles/971394/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 15:44 UTC (Sun)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/971399/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On the hand, if workload is fine running on efficiency core, then it does not need 10% better performance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971400"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 15:46 UTC (Sun)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/971400/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>But if TSO memory model mode means that you can't run on the efficiency cores, even though you'd be fine running on an efficiency core (despite any performance penalty), then you waste energy if you demand TSO mode when weak memory models are fine.


      
          <div class="CommentReplyButton">
            <form action="/Articles/971400/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor971303"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2024 17:09 UTC (Fri)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/971303/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&lt;s&gt;<br>
I understand the objection! There's plenty of other examples of bad code that deserves to fail on systems that do things correctly: turning memory overcommit on, for instance, encourages a whole lot of sloppy programming practices that aren't portable to other OSes. Or trying to play sound in the Flash plugin on glibc circa 2008 and expecting it to not come out garbled - who does that? Also nobody on Linux should expect their CPU scheduler to keep their cores 100% loaded, or their disk scheduler to let them do literally anything else with the system while writing to a USB stick; I'm sure they'll revert those patches real soon now and we can go back to pretending we're a Real UNIX™.<br>
<p>
We must punish users of stinky software by making their lives miserable through sanctions - that will convince the upstream application developers, three steps removed on another architecture, OS and economic system, to fix it promptly so that we never have to leave our elitist comfort zone.<br>
&lt;/s&gt;<br>
<p>
God forbid anyone gets functioning drivers for mainstream hardware in Linux.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971303/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor971314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2024 20:41 UTC (Fri)
                               by <b>shironeko</b> (subscriber, #159952)
                              [<a href="/Articles/971314/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it's a little strange that changing the memory model need kernel involvement at all? Especially if it's a compatibility thing. seem like something user mode code should just be allowed to do by toggling some register or something. Is this a case of apple's backwards engineering?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971315"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2024 20:49 UTC (Fri)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/971315/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's per-process state that needs to be enabled/disabled as necessary when doing a task switch.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971315/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971329"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2024 4:37 UTC (Sat)
                               by <b>shironeko</b> (subscriber, #159952)
                              [<a href="/Articles/971329/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Right. Is the patch to make linux preserve this state when task switching? that seem entirely un-controversial <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971329/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971341"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2024 10:18 UTC (Sat)
                               by <b>WolfWings</b> (subscriber, #56790)
                              [<a href="/Articles/971341/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The patch wants to introduce an ioctl to allow processes to declare they need the alternative memory model.<br>
<p>
But since that alternative memory model DRASTICALLY changes how multi-threaded code needs to be written (broadly speaking the LTO model greatly simplifies multi-threaded code) the maintainers are basically saying "Everyone will take the lazy route and copy-paste enable that everywhere so their x86 code works right on Arm and just refuse to support systems that don't support the x86 memory model." and... yes, so what?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971341/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 4:27 UTC (Sun)
                               by <b>rgb</b> (subscriber, #57129)
                              [<a href="/Articles/971380/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, those developers will also take the well deserved ~10% performance hit, which sounds about the right amount of punishment for being lazy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971412"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 21:57 UTC (Sun)
                               by <b>WolfWings</b> (subscriber, #56790)
                              [<a href="/Articles/971412/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not about being lazy directly, but about simply not having time to re-architect a codebase that started on x86 for example of which there are legion.<br>
<p>
Being able to recompile an existing codebase by just throwing that flag on some boilerplate launch code and have it work without further fiddling?<br>
<p>
That's worth lightyears more than the 10% performance hit to get it out the door and running. Not even for corporate stuff but just FOSS stuff that's multi-threaded.<br>
<p>
Folks can fix the code over time to stop making the x86 LTO assumptions but getting it running fully elsewhere is worlds more important generally.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971412/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor971415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 23:37 UTC (Sun)
                               by <b>jeremyhetzler</b> (subscriber, #127663)
                              [<a href="/Articles/971415/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What do you mean by "LTO"?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2024 6:53 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/971428/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I assume they meant TSO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor971318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2024 22:17 UTC (Fri)
                               by <b>Heretic_Blacksheep</b> (guest, #169992)
                              [<a href="/Articles/971318/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Every time I see a Linux kernel maintainer dogmatically dictate they will actively block any patches that enables legitimate hardware functions for no good reason other than programmers might actually use it (GASP! - even if they use it in an iffy way programmers are MEANT to use it on that platform!) I want to grab the guy by the shirt and demand who made him god (they aren't even if they're accidentally in some position of minor authority) - and at the same time I realize that sometimes it's a  good thing distros regularly maintain their own kernel tree fork &amp; override some zealot upstream overly concerned about the orthodoxy of his True Way of doing things.  Don't like it?  Don't touch it, but likewise don't try to stop others that want to use it!  (Don't like it?  Don't watch it.)<br>
<p>
I could understand if there is an objectively demonstrable issue with patch quality or data integrity over some hardware functions: constant time guarantee violations, inherent race conditions, etc.  But none of those objections were raised from what I saw.  Only that someone might at some point write subtly broken code... which people do all the time, including all the kernel maintainers themselves.  Might as well disable concurrent code entirely and go back to single, strictly in-order processing because of branch misprediction, race conditions, and logical process mapping violations abound - because that's exactly what that argument amounts to - and all equally fixable by "disallowing" most modern CPUs and requiring all programmers complete 3 years of computer science to learn proper programming logic/formal methods (good luck!).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2024 22:52 UTC (Fri)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/971321/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
you seem nice<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2024 23:21 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/971322/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Dunno what I think about Heretic Blacksheep, but he has a point :-(<br>
<p>
There's too many stories about stuff being blocked because maintainers don't like it, with minimal or no technical justification, and sometimes a blunt "over my dead body".<br>
<p>
I can accept maintainers being sceptical and wanting to be convinced, but one only has to look at the people who don't want Rust anywhere near their subsystem, or that module that's supposed to configure hardware (can't remember the details) where it seems a single driver for a single board is unacceptable - the functionality supposedly needs to be spread across several drivers and castrated in the process ...<br>
<p>
There are a few maintainers who seem to think that users are major inconvenience to a well functioning system - well they are, aren't they? <br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971323"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 26, 2024 23:31 UTC (Fri)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/971323/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On the other hand, the maintainers usually have a far better view and understanding of the overall system (and are therefore in a better place to make educated judgements) than individual driver authors or (especially) users.<br>
<p>
Case in point:  "Android Linux" vs "Mainline Linux", and how everyone+dog cobbled stuff together and bashed at it until the former "worked" with no consideration of the cost (or even the necessity) of ongoing maintenance.  Repeat that for every SoC maker, or SoC family, or individual SoC, or even individual devices.<br>
<p>
The "Android" features that finally made it into the mainline bore little resemblance (and is vastly superior) to what was first shipped en masse, and that doesn't even touch on how much stuff never even saw a release in source code form.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971323/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2024 0:12 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/971326/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  On the other hand, the maintainers usually have a far better view and understanding of the overall system (and are therefore in a better place to make educated judgements) than individual driver authors or (especially) users.</span><br>
<p>
And if a maintainer says "convince me", then that's fine. It's when the maintainer says "I'm not interested in any arguments, the answer's no", that we have a problem.<br>
<p>
The problem as far as I'm concerned, is that too many experts have been brainwashed into thinking they know best, and need bashing over the head with a clue-by-four. If they're not prepared even to ask the question "does the proposer have a point", then they ought to go.<br>
<p>
Your Android stuff, I'm not saying it was the best way to do it, but cobbling together a system that works, and then fixing it so it's acceptable to mainline, is the way Linux works. But sometimes mainline has the attitude "to hell with users, I want an easy life". You're left with the feeling on occasion that the kernel is actively hostile to user-space, forgetting that without user-space there's no point in having a kernel.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2024 2:05 UTC (Sat)
                               by <b>nksingh</b> (subscriber, #94354)
                              [<a href="/Articles/971327/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think part of the issue here is that ARM Ltd. has a strong opinion that the architecture should have a weak memory model and all software written for ARM should be ready to handle it. <br>
<p>
They are using their maintainership over the upstream ARM kernel port to enforce their viewpoint as the owner of the architecture. But they're kind of doing it in a way that might hamper adoption for people who want to efficiently emulate x86 binaries.  Maybe there are no ARM inhouse cores that support tlany TSO extensions so they don't care yet.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2024 6:26 UTC (Sat)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/971334/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As far as I understand, Apple is a funding member of Arm. As such, they are allowed to implement non standard extensions whereas most other vendors can't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2024 17:59 UTC (Sat)
                               by <b>thoughtpolice</b> (subscriber, #87455)
                              [<a href="/Articles/971367/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, in practice all the cores that implemented it are custom designs, and Fujitsu, Nvidia and Apple are all architecture licensees, so they're allowed to do that. Not all of Nvidia's custom designs, at least, use TSO; Carmel (Xavier) is TSO only, while Denver2 (TX2) is weakly ordered.<br>
<p>
TSO is a bit weird though because I was under the impression ARM's rules were something like "Non-standard extensions can't be externally 'visible' or documented for consumption and the core must fully comply with the spec." That's why Apple doesn't (and probably can't!) document extensions like this one, that allows TSO to be toggled. But the memory model is pretty visible? Maybe it's all a bit weaselly; after all, if the default memory model is stronger than the spec requires, then every correctly written weakly ordered program should behave the same anyway, so it's not "visible". On the other hand, incorrect programs may behave differently than they would under a weak model, but you could argue that TSO behaviors are "just" a subset of weakly ordered behaviors, and thus it's in spec.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971379"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 4:46 UTC (Sun)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/971379/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, weak ordering is not an architectural feature, it's a lack of a defined feature.  An implementation that provides stronger ordering still satisfies the architectural requirements.  And unlike, say, an additional instruction, where the architecture actually requires a specific behaviour (typically an illegal instruction exception) when the encoding for the new instruction is encountered, but the implementation with the additional instruction behaves differently, a stronger ordered implementation satisfies the (lack of) architectural requirements of the weakly ordered architecture.  Another way of looking at it is that a program written for a weakly ordered architecture will behave as intended on an implementation with stronger ordering, so there is no test to say that the strongly ordered implementation does not satisfy the requirements of the architecture.

<p>My guess is that this clause in the architectural license is indeed there to prevent licensees from squatting on currently unused instruction encoding space or currently illegal behaviour that ARM intends to reserve for future extensions.

<p>The only thing that might be an issue here is the switch that Apple implemented.  I guess they implemented it in something like a model-specific register (i.e. an area that the architecture leaves for implementations to define), and then that should satisfy the architectural license.  I wonder, though, why Apple bothered with the switch; why not just do what Fujitsu did according to the article, and implement TSO throughout?


      
          <div class="CommentReplyButton">
            <form action="/Articles/971379/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor971569"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2024 20:28 UTC (Mon)
                               by <b>justincormack</b> (subscriber, #70439)
                              [<a href="/Articles/971569/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Apple does not actually anywhere refer to their cores as Arm (its Apple Silicon please), and Arm does not usually refer to them at all. Of course everyone else does.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971569/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor971409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 20:22 UTC (Sun)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/971409/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Android has facilities vastly superior to anything available in the GNU/Linux ecosystem. Consider linker namespaces, which comprehensively solve the ELF single namespace dynamic linker mistake. Consider the extremely efficient no-IPC system properties interface. Consider Binder, which beats the pants off dbus (on both performance and functionality) any day of the week. The broader "Linux" community would do well to learn, humbly, from Android.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971425"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2024 5:59 UTC (Mon)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/971425/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But the original argument was not about the facilities provided by the implementations, it was about the quality of the implementation.<br>
<p>
I can't speak to the quality of the Android implementation, but I've definitely seen the following pattern in languages (C++ some, but, particularly Java). Heck, I've seen analogs in applications and entire systems..<br>
<p>
It goes like this..<br>
<p>
Everyone agrees some aspect of the language/standard library is bad and horrible.<br>
<p>
But, instead of getting a clean implementation upstreamed, they hack together some framework of horror (if one looks at the implementation), that putatively improves the situation (if one only looks at the features provided).<br>
<p>
Eventually, the language incorporates a clean solution (since doing it right takes time), but all the consultants and folks who carved out a niche understanding the (often poorly documented) framework of horror, now have a sunk cost, and it takes ages to convince them to transition to just using the nicely implemented, performant, well-documented language/standard library features.<br>
<p>
Maybe this isn't the situation with Android - but nothing in your argument rules it out.<br>
<p>
Android could very well provide some nice features to the users *and* be a pile of unholy hacks. This is not an uncommon situation in many areas of programming and computer systems in general.<br>
<p>
Worse is not necessarily better, despite what the gods have said to us.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971425/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor971410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 20:45 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/971410/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Repeat that for every SoC maker, or SoC family, or individual SoC, or even individual devices.</span><br>
<p>
Android now has a single image that works across all the devices: <a href="https://source.android.com/docs/core/architecture/kernel/generic-kernel-image">https://source.android.com/docs/core/architecture/kernel/...</a><br>
<p>
<span class="QuotedText">&gt; The "Android" features that finally made it into the mainline bore little resemblance (and is vastly superior) to what was first shipped en masse</span><br>
<p>
Which ones?<br>
<p>
<span class="QuotedText">&gt; and that doesn't even touch on how much stuff never even saw a release in source code form.</span><br>
<p>
Android core has always been Open Source. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971426"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2024 6:02 UTC (Mon)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/971426/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, but Android *core* hasn't always been a terribly useful set of software. The situation has gotten better, but, that's not really what people mean when they talk about the Android ecosystem in general.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971426/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor971395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 14:47 UTC (Sun)
                               by <b>Heretic_Blacksheep</b> (guest, #169992)
                              [<a href="/Articles/971395/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Arbitrariness and capricious argument are what I expect out of religious fanatics.  The reasons given by two of the Arm code contributors stinks of religious zealotry not well reasoned and thought out objections, hence my reaction.  "Who died and made you god?" is a common question when dealing with this kind of problem.  It's a colloquialism just like every culture on earth has.  It signifies strong negative reaction, nothing else.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971396"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 15:28 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/971396/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; "Who died and made you god?"</span><br>
<p>
The Arm maintainers, like all other maintainers in the F/OSS world, are maintainers because they've consistently shown up and done this hard, usually thankless work for many, many years.   The Arm architecture is in far, far better shape now thanks to their work.<br>
<p>
In other words, they have earned (and continue to earn!) their godhood.<br>
<p>
Can you say the same about yourself?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971396/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971444"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2024 14:03 UTC (Mon)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/971444/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, you have what effectively is a new, incompatible-with-others architecture variant (ARM64TSO ?) that is capable of running programs for the other architecture (ARM64), but the opposite isn't true.  Just like i686 userspace running on AMD64/X86-64 kernels...  But without the benefit of being actually considered a separate  architecture or variant, and thus creating a massive amount of headaches later on, *including* to users, distros, etc.<br>
<p>
But is it any different from other optional extensions to the ARM64 ISA, which not everybody provides (is there such a thing)?  I don't know enough about it to even give an "IMHO" about it, but to someone without enough information, it comes to mind that maybe it is just in need of being implemented to look like, e.g., AMD64+AVX2 support is to generic AMD64 (but with the IOCTL toggle or whatever form it should take: maybe something in ELF)?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971444/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971639"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2024 7:54 UTC (Tue)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/971639/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a moral dimension to it that other architecture extensions don't have.  If a new CPU supports a new instruction, and you decide to use it to speed up your program, you are simply taking advantage of new hardware.  No doubt you continue to provide an alternative, slower implementation for older CPUs.  You're not being a bad person by using the new instruction -- except, perhaps, if it's patented and only available on processors from one litigious, grasping manufacturer.  (Although in olden days there was sometimes a mild "naughtiness" associated with using undefined opcodes of an 8-bit processor, arising from "don't care" states in the design, which had strange but occasionally useful semantics.)<br>
<p>
But here there is a true path revealed to us.  The designers of ARM, in their wisdom, have provided a plain and humble concurrency model.  The righteous programmer will take care to follow its strictures.  Not for us the worldly luxury of TSO as practised by the followers of Intel and the AMD-ites.  If one group of ARM developers is allowed to get lazy and become addicted to the easier memory model, that's unfair to those who have remained virtuous.  Indeed, others might be led astray and start to demand support for TSO everywhere.  And then where would we be?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971639/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor971369"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 27, 2024 20:44 UTC (Sat)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/971369/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It seems to me like managing it on a per-VM basis would be wise, if only to avoid questions about what happens if two CPUs with different memory models share memory. Does TSO mean that other CPUs see your writes in order, or that you will see other CPUs' writes in order? If all CPUs have the same memory model (they're all x86, or all Arm cores that always use TSO), these alternatives are equivalent, so it wasn't previously important to specify. Will other vendors agree with Apple's implementation if they make CPUs that can change memory models?<br>
<p>
It's already possible for all CPUs in an Arm system to be TSO, and having that potentially true of only some VMs on a single host isn't particularly complicated, while having a mixture of memory models seems like something that's only reliable if you're the CPU vendor.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971369/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor971381"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 5:42 UTC (Sun)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/971381/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      You are too lenient on the CPU designers here.  They are prone to throw problems over the wall to the software people.  E.g., Alpha gave use imprecise exceptions "because of performance".  But IA-32 implementations with OoO execution gave us better performance <strong>and</strong> precise exceptions (and OoO implementations would not become faster if the requirement for precise exceptions was dropped).

<p>I call this attitude of throwing problems over to the software people the "supercomputer attitude", because it's especially rampant in supercomputing where hardware costs still exceed software costs.

<p>Weak memory ordering is just another example of throwing a problem over to software.  The hardware people would have loved to have no cache coherency between different CPUs at all.  But that was so unusable that they did the next-best thing: weak ordering, where software has to insert synchronizing instructions (that are slow if the hardware is designed to be essentially incoherent) at various places.  And then people from the same company that gave us Alpha with not just imprecise exceptions but also an especially weak memory model wrote <a href="https://ieeexplore.ieee.org/document/546611">an advocacy piece</a> that justifies the lack of architectural quality with performance (the magic word that makes lots of people overlook any misfeature).

<p>Now we have CPUs from Intel and AMD which mostly use TSO that are in machines with hundreds of cores.  Do they suffer from bad performance?  Fujitsu actually designed its A64FX for a supercomputer and implemented TSO, so they obviously know how to implement TSO efficiently (they did not even bother with a weakly ordered mode; they have decades of experience implementing SPARC CPUs which offered both TSO and weak ordering, switchable).  Apparently Apple is not quite there yet, as according to the numbers they have an implementation where weak ordering still provides a performance advantage, but at least they offer a TSO mode.  I hope that they will improve their implementation such that the performance penalty of TSO mode vanishes.  And if ARM really wants to be competition to Intel and AMD in laptops and servers, they need to implement TSO, too, and implement it efficiently.

<p>To come back to the Alpha: On the 21264 they actually implemented precise exceptions AFAICT (it's natural for an OoO implementation and the trapb instruction was as cheap as a noop, because it then was a noop).  But Alpha was canceled before they saw the light and made precise exceptions an official feature of a new version of the architecture.





      
          <div class="CommentReplyButton">
            <form action="/Articles/971381/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971406"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 20:18 UTC (Sun)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/971406/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not like a simple "yes" or "no" situation though. AMD64 and x86 are also not fully ordered models either, they're just a bit LESS weakly ordered.<br>
<p>
It's like database isolation. READ UNCOMMITTED is weaker than READ COMMITTED which is weaker than REPEATABLE READ and so on. Some implementations support some isolation levels and not others. Almost none support totally strict ordering because that makes necessary concurrency almost impossible; instead stronger isolation levels use speculative execution where the transaction can fail and roll back if an isolation requirement cannot be satisfied.<br>
<p>
There's more of a spectrum (or really an n-dimensional matrix) of possible ordering decisions in memory ordering and logical order of operations. There is no one right choice - "100% ordered all the time" just isn't feasible with concurrent execution with shared-anything, so *all* design decisions are compromises.<br>
<p>
In a database I pick the isolation level most appropriate to my application's requirements. Or even that specific operations; sometimes I want to have stronger guarantees on specific things where I'm more willing to have them slow and/or require retries. So having something similar for the CPU memory model makes perfect sense to me. You use what's appropriate for the app's correctness, latency and throughput requirements.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971406/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971431"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2024 10:04 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/971431/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>There's also the fact that, at least in theory, compilers are permitted to reorder atomic accesses based on the rules of the language memory model (not the CPU memory model), adding a whole extra layer of complexity.
<p>I don't believe any compiler currently does so for accesses other than "relaxed" type accesses (although I've seen discussions that suggest that LLVM is thinking about this), but it's not forbidden by any language spec I've seen. I have a suspicion, though, that there's plenty of source code out there that's buggy if a compiler does start doing reorderings permitted by the language spec that aren't permitted by TSO.


      
          <div class="CommentReplyButton">
            <form action="/Articles/971431/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor971824"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2024 17:04 UTC (Tue)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/971824/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      My understanding of AMD64 is that the regular memory accesses (those in the ordinary mov instructions and that are part of load-and-operate and RMW instructions) behave according to TSO.  There are some special instructions with worse semantics, but you have to choose them to be bitten by them.  So it's not bad.  If you don't want to be bitten, don't use these instructions.  And, concerning farnz' comment, the same goes for compilers: avoid those that provide worse memory ordering than can be had on the hardware the code is running on.

<p>If by "not fully ordered" you refer to TSO being weaker than sequential consistency, that's true, and I would prefer sequential consistency.  But that's just whataboutism.  The issue at hand is about TSO vs. ARM's variant of weak memory ordering.

<blockquote>There is no one right choice - "100% ordered all the time" just isn't feasible with concurrent execution with shared-anything</blockquote>

What evidence do you have for that?  Is it the same evidence that the Alpha people gave for rejecting byte and word accesses (which they added to the architecture later) and for rejecting precise exceptions?

<p>Anyway, whatever you mean by "100% ordered all the time" (sequential consistency?), the issue at hand is TSO, and TSO is obviously feasible, as evidenced by all the hardware that implement TSO; and given that this includes even hardware designed for supercomputers (the Fujitsu A64FX), and it's not optional there, the tradeoff is obviously not one of horses for courses, but one of better (TSO) vs. worse (weaker memory models).


      
          <div class="CommentReplyButton">
            <form action="/Articles/971824/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971839"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2024 17:55 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/971839/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>That A64FX is TSO is not evidence that TSO is feasible for all heavy compute scenarios; HPC code tends to be designed to minimize data sharing between threads, since that's historically been a really slow option. As a result, Fujitsu might well decide to throw away the last 5% to 10% peak performance in favour of fewer bugs that only exhibit on A64FX and not Intel/AMD supercomputers.



      
          <div class="CommentReplyButton">
            <form action="/Articles/971839/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor972305"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 3, 2024 14:22 UTC (Fri)
                               by <b>anton</b> (subscriber, #25547)
                              [<a href="/Articles/972305/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      There are many unstated (and unsupported) and some stated (but also unsupported) assumptions in your postings, among them:

<ul>

<li> That the speed advantage of weak ordering on some hardware shows itself only on shared data.

<li> That other "heavy compute scenarios" (which ones?) do not avoid data sharing, but HPC does.

<li> That data sharing has historically (where, when?) been a really slow option, but that's no longer the case.

<li> That the performance difference between TSO and a hypothetical weak ordering variant of the A64FX would be 5%-10%.

<li> That supercomputer users are willing to throw away 5%-10% in performance for easier porting of code, while for the rest of the computing world performance is much more important, so it's entirely reasonable to let them suffer the problems that come from weak ordering.

<li> That porting from Intel/AMD is of particular relevance for the users of A64FX-based supercomputers.

</ul>

I think that most of these assumptions are not plausible or outright wrong.


      
          <div class="CommentReplyButton">
            <form action="/Articles/972305/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor972309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 3, 2024 15:31 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/972309/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>In order:
<ul>
<li>If there's no data sharing, then there's no ordering between CPUs to begin with. In this situation, a high-performance implementation of TSO or even sequentially consistent memory models can delay the stores needed to meet the memory model rules until a read happens from another CPU. This, in turn, means that the speed advantage of weak ordering is only guaranteed to show up on shared data, or on low performance implementations.
<li>All compute scenarios attempt to avoid data sharing; however, we were talking in the context of A64FX, which is a HPC processor, and the history of HPC matters here.
<li>Data sharing in HPC has historically been things like MPI over a network, instead of shared memory. That biases HPC towards a "no shared data" model, meaning that the performance penalty of TSO is less significant than in something like a database server which uses shared state to manage the consistency part of ACID.
<li>On the CPU cores we have that allow you to switch between TSO and weaker models, the weaker model has at least a 10% advantage over TSO on a basket of tasks, and considerably more than that in many cases. 5% is thus a reasonable estimate for the cost of TSO mode, assuming that cores are close to optimal today.
<li>It's not <em>just</em>about easier porting of code; weaker memory models result in silent errors, where you thought you had sufficient synchronization, but you did not. In HPC, that leads to unexpected wrong results, where the computation was incorrect.
<li>HPC development is not normally done on the supercomputer itself; that's where you run your completed code. Development is done on "normal" laptops and desktops, just like everywhere else; a bug that only shows on the supercomputer but not on the developer workstations is challenging to debug, since the supercomputer is occupied by people running completed code. That makes porting from Intel/AMD relevant to the users of A64FX-based supercomputers, since the initial testing is going to be done on Intel/AMD for CPU-based code; the exception is GPU-based supercomputers, where the testing is done on a GPU from the same manufacturer.
</ul>
<p>On the other hand, your assertion, which is completely unbacked, is that if A64FX has chosen TSO, it must have done so because TSO and weak memory ordering has the same performance; and yet on every CPU out there that offers both options, including the latest Apple Silicon devices and previous Fujitsu SPARC64 CPUs, TSO has a performance penalty compared to the processor's relaxed memory ordering. However, given that A64FX is swimming against the stream in HPC (most HPC systems now use GPUs for the compute elements, with CPUs there to manage the GPUs, where Fujitsu are using CPUs without GPUs), it is entirely plausible that they chose to minimise risk of bad outputs in preference to extracting the last few percent of performance.
<p>After all, being 4th instead of 1st in the Top500 list is preferable to being 4th but having to withdraw papers based on A64FX computations because they're demonstrably wrong; it's also possible that Fujitsu had actual data from their SPARC64 XII machines that showed that people ran in TSO mode rather than doing the work to get the last few % of performance in RMO mode.


      
          <div class="CommentReplyButton">
            <form action="/Articles/972309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor971402"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">personality(2) already exists</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2024 18:07 UTC (Sun)
                               by <b>Hello71</b> (subscriber, #103412)
                              [<a href="/Articles/971402/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Linux already has a system call to enable special compatibility logic in the kernel for old binaries. personality(2) was added 30 years ago in Linux 1.1.20 and has gained various "weird memory" modes over the years, including "ADDR_LIMIT_32BIT (since Linux 2.2): Limit the address space to 32 bits." and "ADDR_NO_RANDOMIZE (since Linux 2.6.12): With this flag set, disable address-space-layout randomization.". There has not been a surge of poorly-written programs relying on these modes.<br>
<p>
Fundamentally, CPU emulation is a heavy compatibility mode. A reasonable argument could, and has endlessly been made that Wine and other emulators are detrimental to the long-term success of portable applications, but I see no principle why Wine, QEMU, ADDR_LIMIT_32BIT, and ADDR_NO_RANDOMIZE should be acceptable but PR_SET_MEM_MODEL_TSO shouldn't.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971402/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971429"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">personality(2) already exists</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2024 7:27 UTC (Mon)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/971429/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As it happens QEMU has generally either not needed or not succeeded in getting into the kernel compat tweaks for its emulation. (The one I'm thinking of is that if you're emulating a 32 bit guest readdir syscall you need to fill a 32 bit d_off in struct dirent, but a 64 bit host kernel with some filesystems will put a 64 bit hash in the d_off, which can't fit into the guest's 32 bit field, and there's no way to say "give me something I can put in 32 bits". We tried to get patches for an fcntl to toggle this into the kernel a few years back but they went nowhere.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971429/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971626"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">personality(2) already exists</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2024 6:34 UTC (Tue)
                               by <b>linusw</b> (subscriber, #40300)
                              [<a href="/Articles/971626/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I tried to fix this for QEMU but ended up getting ignored I think.<br>
Personally I can live with this, but it's probably not good for QEMU.<br>
<a href="https://lore.kernel.org/linux-fsdevel/20201117233928.255671-1-linus.walleij@linaro.org/">https://lore.kernel.org/linux-fsdevel/20201117233928.2556...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971626/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971809"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">personality(2) already exists</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2024 15:53 UTC (Tue)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/971809/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What does qemu currently do, when it encounters this situation?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971809/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor972193"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">personality(2) already exists</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2024 14:53 UTC (Thu)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/972193/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The typical failure mode is that QEMU returns the 64-bit value in the struct from the getdents64(2) syscall, and the guest libc then fails the readdir(3) library call with EOVERFLOW when it can't fit the quart into the pint pot. The guest program is usually terminally unhappy with that.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/972193/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor971570"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">personality(2) already exists</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2024 20:33 UTC (Mon)
                               by <b>justincormack</b> (subscriber, #70439)
                              [<a href="/Articles/971570/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
emacs used to disable ASLR with that, not aware of any other usage, and eventually they gave up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971570/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor971656"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2024 12:27 UTC (Tue)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/971656/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I undertand Will and he's right. A few years ago when I started to test haproxy on the Neoverse-N1 platform, I discovered that it would randomly crash and misbehave. It had weaker atomics than its predecessors and my code was just too unrigorous to accommodate to that. This notion of memory models was totally unclear to me by then; nobody except a few tens of people on earth really know how each memory model works (and Will definitely is one of them BTW). After a few weeks of work (and help from the CPU designer) we addressed the problems and started to be stricter in our way to use atomics. Now it's one of the most scalable platforms, if not the most scalable one. Now I wish there was a way to disable TSO on x86!<br>
<p>
If I had had this prctl available, what would have happened ? Very easy, looking at the random crashes, Google would have directed me to other people solving this problem by placing this prctl() in the startup chain and voilà! Not only the code would never have been fixed, but it would have remained suboptimal and I would not have learned anything about my bad practice. Thus I'm really glad this prctl didn't exist!<br>
<p>
Also there are other problems: it's not just a matter of process, it's a matter of code. Programs are dynamically linked with external libraries nowadays. What if a library was designed with TSO in mind and not the rest of the code ? How will one detect that the whole code needs to be protected ? IMHO that's more of an ABI problem than anything else, and if something had to be done, it should be by claiming to be a different architecture variant so that it is the kernel that recognizes a binary as working in this or that mode, and that programs can only link with compatible libraries. This way it still allows to port existing code using that explicit architecture variant, but it also imposes it on the whole ecosystem (the set of dependencies), just like some use compat32 for example. This would void the risk that users start to randomly stuff that into their programs to solve bugs, and make sure that it's only used when there is a compelling reason to do so.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971656/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor971940"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 1, 2024 3:02 UTC (Wed)
                               by <b>gmatht</b> (subscriber, #58961)
                              [<a href="/Articles/971940/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Presumably, every library that needs TSO should enable it in its startup logic (immediately prior to where it subverts SSH).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/971940/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor972413"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2024 7:38 UTC (Sat)
                               by <b>DemiMarie</b> (subscriber, #164188)
                              [<a href="/Articles/972413/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That reasoning holds so long as one can change the code.<br>
<p>
For emulation, one can’t.  And without TSO, x86 can’t be emulated efficiently on Arm.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/972413/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor972454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 5, 2024 1:55 UTC (Sun)
                               by <b>jubal</b> (subscriber, #67202)
                              [<a href="/Articles/972454/">Link</a>] 
      </p>
      
      </div>
      </summary>
      this is going to be used on apple's processors anyways, because it's required to run x86 emulation efficiently; the question is whether it's going to be managed where it should (in the kernel), or – if the architecture maintainers manage to convince linus that he shouldn't be able to run steam and windows games efficiently on his apple laptop when running mainline kernel – outside of the kernel tree.


      
          <div class="CommentReplyButton">
            <form action="/Articles/972454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor971657"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2024 13:15 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/971657/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Would it be workable to say that this state is per-thread, and that a thread in TSO mode cannot make syscalls other than to disable TSO mode?
<p>For an emulator like FEX, this is perfectly reasonable; emit "switch to TSO mode", emit your JITted code, and at the end of a JIT block (when you're about to go back to Arm native code such as a FEX ThunkLib, or making a syscall), emit "switch out of TSO mode". It has a small performance hit (since you need to re-request TSO mode at each syscall boundary), but hopefully the advantage of running the core in TSO mode outweighs the hit from having to switch back and forth.
<p>However, this isn't usable as a "quick hack" for applications that didn't take the memory model into account - you'd have to patch up every place that makes a syscall to switch out of TSO mode, make the syscall, and switch back, else it'll crash. If you do this, it's obvious looking at your code that you've got an evil hack in place, and thus clear that you didn't think about the impact.
<p>Am I missing something critical here?


      
          <div class="CommentReplyButton">
            <form action="/Articles/971657/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor972298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Support for the TSO memory model on Arm CPUs</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 3, 2024 12:47 UTC (Fri)
                               by <b>smitty_one_each</b> (subscriber, #28989)
                              [<a href="/Articles/972298/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So, in general TSO chickening-out is bad?<br>
<p>
(I'll show myself out.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/972298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
