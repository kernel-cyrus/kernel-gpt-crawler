        <!DOCTYPE html>
        <html lang="en">
        <head><title>IR decoding with BPF [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/759188/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/759139/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/759188/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>IR decoding with BPF</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="GAByline">
           <p>July 9, 2018</p>
           <p>This article was contributed by Sean Young</p>
           </div>
In the 4.18 kernel, a new feature was merged to allow infrared (IR)
decoding to be done using <a href="/Articles/740157/">BPF</a>. Infrared remotes use many different
encodings; if a decoder were to be written for each, we would end up with
hundreds of decoders in the kernel. So, currently, the kernel only supports
the most widely used protocols. Alternatively, the <tt>lirc</tt> daemon can
be run to decode IR. Decoding IR can usually be expressed in a few lines of
code, so a more lightweight solution without many kernel-to-userspace
context switches would be preferable. This article will explain how IR
messages are encoded, the structure of a BPF program, and how a BPF program
can maintain state between invocations. It concludes with a look at the
steps that are taken to end up with a button event, such as a volume-up key
event.

<p>

Infrared remote controls emit IR light using a simple LED. The LED is
turned on and off for shorter or longer periods, which is interpreted somewhat
akin to morse code. When infrared light has been detected for a period,
the result is
called a "pulse". The time between pulses when no infrared light is detected is
called a "space". 
<p>

Whenever a pulse or space is detected by an IR receiver, a BPF program
will be executed (if one is attached). This program consists of
a single function entry point that takes a pointer to a context. 
For IR decoders, this context is an <tt>unsigned int</tt> value. For 
a packet filter, the context would instead be a packet. In our case, the
lower 24&nbsp;bits of the <tt>int</tt> value contain the duration of the
pulse or space, 
in microseconds. The top eight bits define the type of the event, which can
either be <tt>LIRC_MODE2_PULSE</tt>, <tt>LIRC_MODE2_SPACE</tt>, or
<tt>LIRC_MODE2_TIMEOUT</tt>. The return value 
of the BPF program is ignored.
<p>

If a space between two pulses gets excessively long, it could delay the
decoding of a button press. For example, we might want to know that the IR
message has 
really ended by measuring the space after the last pulse has occurred.
Since a space is a time between two pulses, we would have to wait for the
next pulse from the next IR message to occur before we would get this value.
So, for this reason, there is a timeout. If a space lasts longer than the
timeout, it is reported as <tt>LIRC_MODE2_TIMEOUT</tt>. This is typically
set at 125ms.

<p>
A BPF program can be written in a number of different ways, but the
easiest way is to use <tt>clang</tt> with the target BPF. This allows the
BPF program to be written in a sort of restricted C that does not allow the
use of C-library functions or loops, for example.

<p>
To create an IR decoder in BPF, we start with:
<p>
<pre>
    static int eq_margin(int duration, int expected, int margin)
    {
	return (duration &gt;= (expected - margin)) 
     	    &amp;&amp; (duration &lt;= (expected + margin));
    }

    int bpf_decoder(unsigned int *sample)
    {
	int duration = *sample &amp; LIRC_VALUE_MASK;
	bool pulse = (*sample &amp; LIRC_MODE2_MASK) == LIRC_MODE2_PULSE;

	if (pulse &amp;&amp; eq_margin(duration, 300, 100) {
		// seen short pulse of about 300 microseconds
	}
    }
</pre>
<p>

Typically, IR receivers have a precision of 50µs at most.  I would
recommend checking for durations of at least 100µs around
the value you expect.

<p>
Now we can parse a single pulse or space, but every IR message consists
of several pulses and spaces in quick succession. In a regular C program, we
would use a static variable, a global variable,  or some heap memory to maintain
our state while waiting for the next event. Unfortunately none of those
options are available in BPF. Instead, we use BPF maps, which
are a generic key-value store where the key is always an <tt>unsigned
int</tt> and the value is a generic blob; we can store whatever we
want. This is how we declare a BPF map to hold the IR-decoding state:

<p>
<pre>
    struct decoder_state {
	unsigned int bits;
	unsigned int count;	
    };

    struct bpf_map_def SEC("maps") decoder_state_map = {
	.type = BPF_MAP_TYPE_ARRAY,
	.key_size = sizeof(unsigned int),
	.value_size = sizeof(struct decoder_state),
	.max_entries = 1,
    };
</pre>

<p>
There are a few different types of BPF maps, the main ones being
"array" and "hash". Since we are only looking to store one structure, an
array is 
more than sufficient; we thus specify <tt>max_entries</tt> as one.
The <tt>key_size</tt> has to be the size
of an <tt>unsigned int</tt>, no other key size is supported. The
<tt>value_size</tt> is the 
size of our blob of data. We've declared a struct for this purpose, and we
use <tt>sizeof()</tt> to ensure we have the right storage for it.

<p>
There are a number functions available to use BPF maps from our BPF code. For
example, to get an our entry in <tt>decoder_state_map</tt> BPF map, we can call:

<p>
<pre>
    int key = 0;
    struct decoder_state *s = bpf_map_lookup_elem(&amp;decoder_state_map, &amp;key);
</pre>

<p>

Unfortunately,
if we try to use the pointer to the map, we will get an error when we load
our BPF 
program: "R6 invalid mem access 'map_value_or_null'". This is the kernel's BPF
verifier 
complaining; it checks to ensure that a BPF program does
not do anything it should not, like try to access out-of-bounds memory. It
also checks for other conditions, like relying on undefined behavior or
loops.

<p>
The problem here is that <tt>bpf_map_lookup_elem()</tt>, the function used
to obtain a value from a BPF map, might return NULL
if the key is beyond the last element. The elements of an array are
pre-allocated, and we are looking for element zero out of a total of one,
so this lookup should 
never fail. However, the BPF verifier is not aware of this so, in order to
keep the verifier happy, we have to add:

<p>
<pre>
    if (!s)
	return 0;
</pre>

<p>

The pointer we get from <tt>bpf_map_lookup_elem()</tt> is a direct pointer
to the array, so we do not have to call <tt>bpf_map_update_elem()</tt>
after making changes. The BPF verifier will check that we only use our pointer
with the right offsets within our array entry; otherwise our program will not
load.

<p>
Now that we have memory to store state, we can implement decoding. When
we have decoded the IR to a button event, we can submit that event to the
input subsystem using the BPF function
<tt>bpf_rc_keydown()</tt>. It takes four arguments, being the BPF context, the
protocol, the scancode, and the toggle bit:
<p>
<ul class="spacylist">

<li> The context for BPF is the pointer that was passed to the main BPF
     function; so we simply pass <tt>sample</tt> here.

<li> The IR protocol can be used by user space to determine which protocol
     produced any given scancode; at the moment, nothing uses it.

<li> The scancode is the value that was decoded. IR protocols generally
     encode some sort of value, and that value does not necessarily
     represent a key or a button. A particular remote might assign
     particular values with buttons; so, we need a mapping from scancode to
     key code. This is done using remote-control keymaps, which usually
     live in <tt>/lib/udev/rc_keymaps/</tt> if the <tt>v4l-utils</tt>
     package is installed (or the <tt>ir-keytable</tt> package on
     Ubuntu or Debian).

<li> Some IR protocols include a toggle bit. Since the IR message is
     repeated every 90ms or so, it is impossible to distinguish
     a key being held from a key released and pressed again (toggled). In
     the latter case, the toggle bit will change value, so
     <tt>rc-core</tt> knows to generate both key-up and key-down events.
</ul>

<p>
So those are the four arguments to <tt>bpf_rc_keydown()</tt>. Now, we can
show a complete example of a fictional IR decoder.

<p>
<pre>
    #include &lt;linux/lirc.h&gt;
    #include &lt;linux/bpf.h&gt;

    #include "bpf_helpers.h"

    enum state {
	STATE_INACTIVE,
	STATE_FIRST_PULSE,
	STATE_SECOND_PULSE
    };

    struct decoder_state {
       enum state state;
       unsigned int space;
    };

    struct bpf_map_def SEC("maps") decoder_state_map = {
	.type = BPF_MAP_TYPE_ARRAY,
	.key_size = sizeof(unsigned int),
	.value_size = sizeof(struct decoder_state),
	.max_entries = 1,
    };

    SEC("fictional_ir")
    int decode(unsigned int *sample)
    {
	int key = 0;
	struct decoder_state *s = bpf_map_lookup_elem(&amp;decoder_state_map, &amp;key);

	if (!s)
	    return 0;

	int duration = LIRC_VALUE(*sample);

	switch (s-&gt;state) {
	case STATE_INACTIVE:
	    if (LIRC_IS_PULSE(*sample) &amp;&amp; duration == 500) {
		s-&gt;state = STATE_FIRST_PULSE;
	    }
	    break;
	case STATE_FIRST_PULSE:
	    if (LIRC_IS_SPACE(*sample)) {
		s-&gt;space = duration;
		s-&gt;state = STATE_SECOND_PULSE;
	    } else {
		s-&gt;state = STATE_INACTIVE;
	    }
	    break;
	case STATE_SECOND_PULSE:
	    if (LIRC_IS_PULSE(*sample) &amp;&amp; duration == 500) {
	 	bpf_rc_keydown(sample, 64, s-&gt;space / 100, 0);
	    }
	    s-&gt;state = STATE_INACTIVE;
	    break;
	}

	return 0;
    }

    char _license[] SEC("license") = "GPL";
</pre>

<p>
Several operations are multiplexed through the <a
href="http://man7.org/linux/man-pages/man2/bpf.2.html"><tt>bpf()</tt>
system call</a> for
managing BPF programs and BPF maps, and for attaching them to devices. To
create a BPF program, the  <tt>BPF_PROG_LOAD</tt> is used.
We have to provide a pointer to the BPF instructions, the instruction count, and
a program name. If the system call is successful, we will get a file
descriptor.

<p>

We can create BPF maps with the <tt>BPF_MAP_CREATE</tt> command, which also
returns a file descriptor on success. Once we have the program and maps
created, we can attach the program to a LIRC device
(e.g. <tt>/dev/lirc0</tt>) using the <tt>BPF_PROG_ATTACH</tt> command. We have
to provide a file descriptor for the LIRC device and the BPF program file
descriptor. Once the file descriptor is attached, we can safely exit
our process and the BPF program won't be freed when its file descriptor is
closed.

<p>
Currently there is a hard-coded limit of 64 BPF programs that may be
attached to one LIRC device. Any more, and <tt>BPF_PROG_ATTACH</tt> will
return <tt>E2BIG</tt>. 
Every time a new pulse or space occurs, all the BPF programs will be executed.
This makes it possible to load multiple BPF decoders, so that different
remotes can be used at the same time.

<p>
As you might expect there are also commands for querying and detaching
BPF programs. 

<p>
The BPF example above can be compiled it with:
<p>
<pre>
    clang --target=bpf -O2 -c foobar.c
</pre>

<p>
You'll need to compile it with kernel headers from 4.18 (or later), and the
<tt>bpf_helpers.h</tt> from the same tree. This produces <tt>foobar.o</tt>,
an ELF object file.

<p>
Using <tt>ir-keytable</tt>, you can load this BPF program. You'll need the
<a href="https://git.linuxtv.org/syoung/v4l-utils.git/log/?h=bpf">BPF
patches</a>, which have not been merged yet at the time of writing. In
order to simulate this, the <tt>rc-loopback</tt> pseudo-receiver can be
used, so no IR hardware 
is needed. Here are the steps to make this work:

<p>

<pre>
    modprobe rc-loopback
    ir-keytable -p ./foobar.o
</pre>
<p>
In order to test this setup, create a file <tt>test</tt> with the following
contents: 
<p>
<pre>
    pulse 500
    space 1500
    pulse 500
</pre>
<p>

Now, run:
<p>
<pre>
    ir-keytable -k 15:KEY_VOLUMEUP -t
</pre>
<p>
in one terminal, and:
<p>
<pre>
    ir-ctl -s test
</pre>
<p>
in another.  You should get this output:
<p>
<pre>
    855.168999: lirc protocol(64): scancode = 0xf
    855.169009: event type EV_MSC(0x04): scancode = 0x0f
    855.169009: event type EV_KEY(0x01): key_down: KEY_VOLUMEUP
    855.169009: event type EV_SYN(0x00).
</pre>
<p>

The <tt>ir-keytable</tt> patches above also include a Python script that
converts <tt>lircd</tt> remote configuration so that it can be used with
<tt>ir-keytable</tt>. This should make it possible to do without the
<tt>lirc</tt> daemon. However, some protocol decoders require very basic
loops, which currently the BPF verifier does not allow at all.
<p>

Even with all <tt>lircd</tt> remote configurations supported, that would
still not cover all possible remote controls. A possible solution can be
found in  <a
href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation">IRP
notation</a>, a general form of description for IR protocols; it would be
nice to generate BPF from 
that, and have support for a very broad array of remotes, without having to
open-code each one.
Lastly, other things than button presses are encoded in IR, for example
target temperatures in air conditioning remote controls, or some remote
controls include a directional pad.  Supporting such devices with BPF
decoders will require some further work.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#BPF-Device_drivers">BPF/Device drivers</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Device_drivers-Support_APIs">Device drivers/Support APIs</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Young_Sean">Young, Sean</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/759188/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor759364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2018 16:09 UTC (Mon)
                               by <b>linuxjacques</b> (subscriber, #45768)
                              [<a href="/Articles/759364/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well now I know what BPF is, but not from reading this article.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759371"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2018 18:01 UTC (Mon)
                               by <b>jake</b> (editor, #205)
                              [<a href="/Articles/759371/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Well now I know what BPF is, but not from reading this article.</font><br>
<p>
I just added a link to hopefully help others who are not up on BPF.<br>
<p>
thanks!<br>
<p>
jake<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759371/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759388"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2018 23:34 UTC (Mon)
                               by <b>atai</b> (subscriber, #10977)
                              [<a href="/Articles/759388/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BPF: the new Javascript?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759388/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759408"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 9:06 UTC (Tue)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/759408/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;BPF: the new Javascript?</font><br>
I'll get onto it once I've finished the Common Lisp interpreter -- unless we can fold in an incomplete and buggy implementation thereof within the eBPF-js engine?<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759408/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759442"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 16:51 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/759442/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Get on with the time. Nobody cares about LISP anymore, it's JavaScript this century.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759442/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor760365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2018 19:02 UTC (Thu)
                               by <b>miquels</b> (guest, #59247)
                              [<a href="/Articles/760365/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You have it backwards. We should replace BFP in the kernel with WASM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor760415"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2018 8:06 UTC (Fri)
                               by <b>rurban</b> (guest, #96594)
                              [<a href="/Articles/760415/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Probably, but with the added functionality to remove all things security in your kernel. So they desperately find new ways to keep your favorite toy, and persuade everyone else to ditch dtrace and only write BPF probes. Next time: BPF in userspace, i.e. almost dtrace.<br>
<p>
With arrays in BPF and spectre/meltdown it is not possible to be on the safe side anymore.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760415/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor759375"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2018 20:45 UTC (Mon)
                               by <b>meyert</b> (subscriber, #32097)
                              [<a href="/Articles/759375/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Alternatively, the lirc daemon can be run to decode IR"<br>
<p>
So why is any of this actually done in kernel code?<br>
<p>
Why not rip out all in kernel IR decoding and why adding more like this bpf support?<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759375/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759384"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2018 22:45 UTC (Mon)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/759384/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes. The article complains about user/kernel context switches but it does not explain why that is actually a problem. Frequent user/kernel transitions are common in Linux, they're called "system calls".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759384/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor759387"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2018 23:08 UTC (Mon)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/759387/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There isn't any in kernel IR decoding other than device support. The point of the article is to point out that though BPF was developed for networking it's being found to be a very flexible tool to do lots of things.  Will lirc move to using BPF? who knows but the article does show it's possible to use BPF rather creatively for things it was never really intended for. <br>
<p>
I don't know about you but that's pretty cool that it was designed and implemented generically enough that it's got uses beyond the direct use for which it was developed.  I think that's actually a pretty good example of the Linux way in designing these kernel interfaces so they are flexible. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759387/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2018 23:35 UTC (Mon)
                               by <b>atai</b> (subscriber, #10977)
                              [<a href="/Articles/759389/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
security hole, anyone?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759391"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 0:11 UTC (Tue)
                               by <b>daney</b> (guest, #24551)
                              [<a href="/Articles/759391/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No more of a security hole than the N other uses of eBPF in the kernel.<br>
<p>
It seems the main type of device that would use this is probably embedded consumer platforms.  Are we going to start seeing evil IR blasters designed to hack into these things via the (now) in-kernel IR decoders?  I don't know. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759391/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor759393"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 0:57 UTC (Tue)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/759393/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
  &gt; I don't know about you but that's pretty cool that it was designed and implemented generically enough that it's got uses beyond the direct use for which it was developed.<br>
<p>
This would be noteworthy if this were using original BPF, which was explicitly written for stateless filtering of network packets using a very minimal virtual stack machine. The BPF engine in Linux was extended to support more generic constructs as well as loading and storing of state, and has more in common with Google's NaCL project than original BPF. The only remaining limitation in Linux's BPF is, IIUC, the inability to loop--in classic BPF only forward jumps are allowed, whereas in Linux BPF backwards jumps are allowed if the verifier is convinced the program doesn't actually loop.<br>
<p>
It's not surprising at all that it can do this.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759393/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor759990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2018 16:53 UTC (Mon)
                               by <b>mchehab</b> (subscriber, #41156)
                              [<a href="/Articles/759990/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So why is any of this actually done in kernel code?</font><br>
<p>
The answer is the same to this question: "why an USB HID scancode is translated to key inside the Kernel?" <br>
<p>
Because on an embedded device, the IR may be the only input device. Think for example on a Set Top Box or a TV set: usually, all the user has is the remote controller. It needs to be able to handle key presses since when the Kernel starts.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor759392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 0:16 UTC (Tue)
                               by <b>quotemstr</b> (subscriber, #45331)
                              [<a href="/Articles/759392/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
IR decoding should be done in userspace. It's really hard to imagine a scenario in which the transition latency would matter. This kind of thing is _exactly_ the moral hazard that adding a general-purpose scripting system to the kernel introduces.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759403"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 7:45 UTC (Tue)
                               by <b>shiftee</b> (subscriber, #110711)
                              [<a href="/Articles/759403/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My employer makes an embedded device which supports modbus over serial.<br>
For the embedded C version we customised the driver to watch for a gap like above in order to separate the packets.<br>
We then put the data in a struct with an int telling us the number of bytes.<br>
For the Linux version we have not found a way to do this. We can read the bytes sequentially but the timing information is lost.<br>
This means that if we receive a malformed or unsupported packet the only recovery is to flush the buffers and try reading again.<br>
<p>
While not a disaster it is preferable to throw out only that packet and try reading the next one.<br>
To do so under Linux it seems we need to modify the driver, but BPF looks like a nice solution if it were possible<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759403/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 8:40 UTC (Tue)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/759405/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem with the modbus over serial protocol is that it relies on detecting silence lengths to mark frame boundaries. <br>
<p>
But I thought that libmodbus (<a href="http://libmodbus.org/">http://libmodbus.org/</a>) had this already implemented. Is it not the case?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759406"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 8:58 UTC (Tue)
                               by <b>chris.sykes</b> (subscriber, #54374)
                              [<a href="/Articles/759406/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  But I thought that libmodbus (<a href="http://libmodbus.org/">http://libmodbus.org/</a>) had this already implemented. Is it not the case?</font><br>
<p>
Nope, libmodbus tries to parse the RTU frames as bytes are received in order to figure out how many are still outstanding; the trouble is, it has to do this before it can check the CRC...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759406/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759418"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 14:00 UTC (Tue)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/759418/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Any idea of why it does this instead of reading byte for byte and timing out?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759418/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 10, 2018 15:39 UTC (Tue)
                               by <b>chris.sykes</b> (subscriber, #54374)
                              [<a href="/Articles/759440/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect support for Modbus TCP, which uses length prefixed framing, was added first, with RTU coming later, and they kept the "how many bytes am I still waiting for" code in the common layer.<br>
<p>
It's difficult to do RTU frame timing properly from user-space, without RT scheduling; and you really want control over the RX FIFO interrupt thresholds in the UART as well.<br>
<p>
I've often thought making Modbus RTU serial line discipline, that exposed a socket API (like socketCAN), would make an interesting project, but so far, haven't found the time...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759475"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2018 7:22 UTC (Wed)
                               by <b>shiftee</b> (subscriber, #110711)
                              [<a href="/Articles/759475/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So do you think BPF could be modified (in theory at least) to read Modbus RTU packets and somehow provide them to user space as length prefixed frames?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759475/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759479"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2018 9:44 UTC (Wed)
                               by <b>Darkmere</b> (subscriber, #53695)
                              [<a href="/Articles/759479/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Probably. One of the interesting use cases for that is a system where you have multiple speeds on the same physical network. <br>
<p>
With rs485 you then want to decode traffic in multiple speeds at once to find out which traffic is modbus RTU and which is some other traffic. <br>
(It’s common enough to have Mbus at 2400 bps and modbus at 9600 and 19200. And no. It ain’t pretty)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759479/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor759573"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 9:35 UTC (Thu)
                               by <b>seanyoung</b> (subscriber, #28711)
                              [<a href="/Articles/759573/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For the modbus case there is a BPF function bpf_ktime_get_ns() available which can be used for processing timeouts correctly.<br>
<p>
This is an interesting idea. I have a device which produces packets on usb-serial; the process wakes up for nearly every byte that arrives, which causes load on the underpowered arm device it is attached to. It would be nice if the process could be woken up only when a complete packet arrives, and invalid packets get dropped.<br>
<p>
This seems similar to the original purpose of BPF. The BPF program would need access to the serial buffer and control read readiness reporting. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759573/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor759991"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2018 17:10 UTC (Mon)
                               by <b>mchehab</b> (subscriber, #41156)
                              [<a href="/Articles/759991/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; IR decoding should be done in userspace. It's really hard to imagine a scenario in which the transition latency would matter</font><br>
<p>
Handling input events in Kernel has noting to do with latency. It is all about allowing to control the system when it boots. It doesn't  really matter if the keyboard is an old PS/2 keyboard, an USB keyboard or a Infrared remote: once keys are pressed, user expects actions to be taken.<br>
<p>
The remote controller subsystem was designed to allow:<br>
   - disabling it completely;<br>
   - enable hardware decoders but require userspace to prepare it;<br>
   - do decoding in software (via LIRC);<br>
   - support devices with a micro-controller that reports scan codes to the Kernel (instead of PULSE/SPACE timings);<br>
   - and now, via BPF decoding (for newer Kernels).<br>
<p>
On systems that have keyboard/mice, all the above options could be used, but there are embedded devices where the only input device is an infrared (like a TV set of a Set Top Box). For those, doing Kernel decoding provide ways to allow passing keycodes  very early at boot time, with would help, for example, to start userspace with a different run level, just like if the device had any other type of keyboard.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759991/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor760035"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2018 9:20 UTC (Tue)
                               by <b>seanyoung</b> (subscriber, #28711)
                              [<a href="/Articles/760035/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Exactly. Another point to consider (if that was not already clear) is that there are two types of IR devices:<br>
<p>
1. IR receivers that report pulse/space information "raw IR" or "mode 2"<br>
2. IR receivers that report decoded scancodes<br>
<p>
By having pulse/space decoding in kernel space, both types of devices can be used in LIRC_MODE_SCANCODE, which means that decoded scancodes are reported. Userspace does not need to care if the IR decoding happens in the IR receiver or in the kernel; the same interface is exposed to userspace.<br>
Also both types of devices report input events to the input layer in exactly the same way, so again it looks the same from userspace.<br>
<p>
Some IR devices (like the winbond-cir SuperI/O) can do both decoding in hardware circuit or report pulse-space to the kernel. We choose to set up the device in the later mode since we can then support many more protocols than the few the hardware supports.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760035/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor902946"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2022 0:47 UTC (Sat)
                               by <b>comex</b> (subscriber, #71521)
                              [<a href="/Articles/902946/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m pretty sure it&#x27;s not even possible to load a BPF program without a userspace program, though...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/902946/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor902981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2022 21:20 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/902981/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There&#x27;s technically nothing stopping someone doing that at kernel build time and then including the BPF bytecode in the kernel/initrd like a firmware blob. It&#x27;d be slightly silly as you could just as easily use plain C; on the other hand one could also make the argument *more* of the kernel should be runtime-replaceable like this...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/902981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor759529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 11, 2018 15:37 UTC (Wed)
                               by <b>gebi</b> (guest, #59940)
                              [<a href="/Articles/759529/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That should work for the usbtouchscreen driver too...<br>
<p>
<a href="https://github.com/torvalds/linux/blob/master/drivers/input/touchscreen/usbtouchscreen.c">https://github.com/torvalds/linux/blob/master/drivers/inp...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759566"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 5:19 UTC (Thu)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/759566/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm wondering in what scenario user-kernel space transitions are a performance issue for low-speed IR-remote comms?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759566/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759571"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 12, 2018 9:25 UTC (Thu)
                               by <b>seanyoung</b> (subscriber, #28711)
                              [<a href="/Articles/759571/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
After JIT, an IR decoder is about ~400 instructions on x86-64 (without loops). That's less work than a single context switch, and with user space decoding there will be many more transitions and much more memory used.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759571/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759694"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 13, 2018 0:52 UTC (Fri)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/759694/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This implies that it's more efficient to have it in-kernel, but does't really explain that doing it in userspace is a performance concern for low-bandwidth links such as the one this is designed for.<br>
<p>
In other words if doing it in user space costs 0.00000000001% of a core and doing it in kernel costs 0.000000000001%, then it's not really a performance concern.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759694/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759907"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2018 6:43 UTC (Mon)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/759907/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Say people who do not use hundreds of billions of IR devices on their computer ...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759907/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759911"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2018 8:47 UTC (Mon)
                               by <b>paulj</b> (subscriber, #341)
                              [<a href="/Articles/759911/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting setup. How do you get billions of IR devices attached on a computer?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759911/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759912"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2018 8:59 UTC (Mon)
                               by <b>cpitrat</b> (subscriber, #116459)
                              [<a href="/Articles/759912/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Billions is easy, I'm talking hundreds of billions.<br>
First you have to buy them. That's where you discover that few sellers support int64 through their whole toolchain.<br>
Then you have to get them deliver. Even with small packages (20 cm^3) we're talking about 20,000 trucks coming to your home.<br>
Then you need longer cables because even if the receptor is only 1cm^3 you need a 32m radius sphere to fit them all (ignoring the cable).<br>
<p>
So a bunch of challenges, but I as you see, no major obstacle.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759912/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor759989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2018 16:50 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/759989/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why would you want a solid sphere of IR devices? You'd only be able to communicate with the ones on the outside surface, the others would all be in shadow. Surely you'd want to arrange them in a single layer as a spherical shell about 900m in radius, with your IR receiver in the middle. Then you might start to worry about decoding taking a noticeable percentage of your CPU cycles.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor760277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 19, 2018 8:56 UTC (Thu)
                               by <b>johnny</b> (guest, #10110)
                              [<a href="/Articles/760277/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is that really a productive use of your time, though? Wiring up the first hundred billion devices is probably a fun time, but I suspect the novelty would start wearing off soon thereafter.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/760277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor759885"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2018 14:51 UTC (Sun)
                               by <b>rossmohax</b> (guest, #71829)
                              [<a href="/Articles/759885/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I read it more more like  a "look ma, no hands!" case :)   Curious engineer had an itch to scratch and published result. It might have some battery-saving benefits though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/759885/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor761171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2018 14:27 UTC (Sat)
                               by <b>HybridAU</b> (guest, #85157)
                              [<a href="/Articles/761171/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>I know this is slightly off-topic for this article, but does anyone know of a good USB IR Blaster / Receiver? I bought an <a href="https://www.irdroid.com/irdroid-usb-ir-transceiver/">Irdroid USB IR Transceiver</a> a few years ago and I don't know if it was damaged during postage or something but I could never get it to work. I tried Lirc / irrecord and never got anything.</p>
<p>Essentially what I want to do is set up a Raspberry Pi, record the signals from my air conditioner's remote and then use a cron job to playback and switch on / off my air conditioner at certain times.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/761171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor768117"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">IR decoding with BPF</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2018 11:54 UTC (Thu)
                               by <b>seanyoung</b> (subscriber, #28711)
                              [<a href="/Articles/768117/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For USB, I would recommend any mceusb device. Not all have transmitters attached. <br>
<p>
The raspberrypi this device is very well supported: <a href="https://energenie4u.co.uk/catalogue/product/ENER314-IR">https://energenie4u.co.uk/catalogue/product/ENER314-IR</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/768117/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2018, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
