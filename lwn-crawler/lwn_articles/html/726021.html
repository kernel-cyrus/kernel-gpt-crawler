        <!DOCTYPE html>
        <html lang="en">
        <head><title>Specifying the kernel ABI [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/726021/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/725472/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/726021/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Specifying the kernel ABI</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>This article brought to you by LWN subscribers</b>
<p>
Subscribers to LWN.net made this article &mdash; and everything that
       surrounds it &mdash; possible.  If you appreciate our content, please
       <a href="/Promo/nst-nag3/subscribe">buy a subscription</a> and make the next
       set of articles possible.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>June 21, 2017</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2017-Open_Source_Summit_Japan">OSS Japan</a>
</div>
<p>
At <a
href="http://events.linuxfoundation.org/events/open-source-summit-japan">Open
Source Summit Japan</a> (OSSJ)—OSS is the new name for LinuxCon,
ContainerCon, and CloudOpen—Sasha Levin gave a talk on the kernel's
application binary interface (ABI).  There is an effort to create a kernel
ABI specification that has its genesis <a href="/Articles/705937/#abi">in a 
discussion about fuzzers</a> at the 2016 Linux Plumbers Conference.  Since
that time, 
some progress on it has been made, so Levin described what the ABI is and the
benefits that would come from having a specification.  He also covered
what has been done so far—and the
the extensive work remaining to be done.
</p>

<a href="/Articles/726121/">
<img src="https://static.lwn.net/images/2017/ossj-levin-sm.jpg" border=0 hspace=5 align="left"
alt="[Sasha Levin]" title="Sasha Levin" width=225 height=260>
</a>

<p>
An ABI is how one piece of compiled code talks to another, he said.  For
the kernel, the ABI is how user space communicates with the kernel.  That
takes the form of system calls, <tt>ioctl()</tt> commands, and, to some
extent, the calls in the <a
href="/Articles/615809/">virtual dynamic shared object</a> (vDSO).
</p>

<p>
The current process for Linux development says that kernel patches cannot
break programs that rely on the ABI.  That means a program that runs on the
4.0 kernel should be 
able to run on the 5.0 kernel, Levin said.  While breakage is not intended,
there is nothing that would automatically prevent it from happening.  There
are no tools that 
would detect an ABI break, so the responsibility to find these kinds of
problems falls to user space.  If a user-space program breaks because of an
ABI change, users and developers of that program can complain to the kernel
developers and, hopefully, get the problem fixed upstream.
</p>

<p>
The kernel ABI gets extended by some developer coming up with a new feature
that has a user-space interface and, with luck, some documentation that
describes it.
Usually the maintainer will require documentation before merging the
feature, he said.  Normally, though, someone else will write the
corresponding user-space code to use the new feature; that might be
developers for the GNU C library (glibc) or QEMU, for example.  Then the
kernel and user-space developers test to find things that are broken on
both sides of the interface; the code is "massaged until stuff works"
between the two.
</p>

<p>
But that process has a number of flaws.  Basic validity checks are
forgotten and can often reappear as security vulnerabilities later on.
Effectively, these missing checks allow user space to cause the kernel to
do things that were never planned for, which is always dangerous.  There
are also 
undefined behaviors on both sides of the interface because there is no
complete specification.  Even if all of the checks are made, there is still
room for the kernel to end up performing operations that were not planned.
The lack of a specification can also lead to problems down the road;
failing to verify flags and other parameters mean that changes in the
kernel can cause
existing programs to break.
</p>

<p>
Backward compatibility is supposed to be verified by the <a
href="https://linux-test-project.github.io/">Linux Test Project</a> (LTP) and
other tools, which help, but the real verification is done by all of the
user-space 
applications.  LTP will catch big things, Levin said, but not the majority
of backward compatibility breaks.
</p>

<p>
The user-space ABI is broken "every other release or so"; usually they are
small things that no one cares about, he said.  But, one of the problems is
that it can take some time before the new release gets widespread testing.
In the meantime, some user-space program could start relying on the new
ABI, while another 
program still relies on the unbroken, old behavior; that would be a
recipe for a difficult-to-solve problem. 
</p>

<p>
Much of the validation that is done in the kernel is done on an ad hoc
basis.  There is no clear definition of what should be checked or how the
checks should be done.  Each system call typically has its own way of
checking, which opens up room for bugs, he said.  If there are 20 different
versions of ways to check some kind of parameter and one of them gets
fixed, it is common for the other 19 to be missed.  He suggested that using
"<tt>git&nbsp;blame</tt>" on any major system call will show missed checks;
"look and you will be unpleasantly surprised".  
</p>

<p>
Even in user space there are lots of different implementations for
system call parameter handling.  For example, <tt>strace</tt> has its own
library describing all of the system calls, C libraries do their own
parameter checking, and different fuzzers all have their own way of
generating system call parameters.  That is just more duplication, which
leaves more room for mistakes, Levin said.  Most of those implementations
are written by developers who aren't necessarily familiar with the kernel
side of the interface as well.  "It's a mess."
</p>

<p>
The existing documentation, in the form of <tt>man</tt> pages, is "pretty
good".  But <tt>man</tt> pages only cover about 80% of the use cases; they
are not supposed to completely document the ABI of the kernel.  The
documentation is meant to help programmers get their programs working with
the kernel, thus it is a "summary briefing" rather than any kind of
"contract".

<h4>Contract</h4>

<p>
Today, the contract is embodied in the kernel code for a specific kernel
version.
The documentation is based on someone's understanding of the kernel code,
which may be 
wrong, and the kernel code itself is subject to change.  There generally is
no proactive effort to see if an ABI change affects a particular user-space
program; its users find out later when things break.
</p>

<p>
Having a contract would kill multiple birds with one stone, he said.  It
would force 
the kernel and user space to behave in a specific way.  The backward
compatibility problems would disappear, since changes that affect it could
be detected.  It would prevent a whole class of errors between user space
and the kernel.  It would fully document the ABI and it would also allow
code reuse for the ABI, with the usual benefits that brings.
</p>

<p>
What would this contract look like?   It should be human readable so that
people can review it, but also should be machine readable so that it can be
turned into code for tests or to use in the kernel and user space.
Hopefully, it would only need to be written once but could be used by all
of the potential consumers.  As a starting point, the system call
descriptions used by the <a href="/Articles/677764/">syzkaller fuzzer</a>
look reasonable.  They are used to create calls to system calls that are correct
enough that they tickle new parts of the kernel code.
</p>

<p>
On the kernel side, the contract would be used to generate code to verify
parameters and return values as part of the ABI.  The code would validate
the input and output parameters based on the specification.  It would try
to prevent calls with invalid arguments from even getting to the real
system call code. That would reduce the amount of validation checks needed
in the individual system calls; for example, file descriptors could be
verified in only one place and system calls could rely upon getting a valid
one. 
</p>

<p>
For user space, it would make things easier for programs and libraries that
access the kernel ABI.  Instead of hoping the ABI is understood, user-space
programs would have a guarantee of behavior instead.  The contract would be
made usable for projects like <tt>strace</tt> that already have to work
with the ABI.  Validation code based on the specification could be added to
glibc and other C libraries as well.
</p>

<p>
By generating the validation code and centralizing it, lots of code in
both the kernel and user space will be removed.  Fixes to the validation
code will be shared on both sides of the ABI.  In addition, backward
compatibility problems will be detected more easily and quickly.  It will
be difficult to implicitly break the ABI.
</p>

<p>
There are also benefits for users of the stable and long-term support (LTS)
kernels.  Right now, some are afraid to upgrade their kernels because they
are worried about a new kernel breaking their user-space application.  The
contract would provide more assurance that those applications will still
run correctly.  Even though he is a maintainer of LTS kernels, he thinks
they are a 
"pretty bad
idea" overall; if you keep older kernels alive for many years, "things are
bound to go wrong".   He is hoping that an ABI contract would help to kill
off LTS kernels to some extent by increasing the frequency that users are
willing to do kernel upgrades.
</p>

<p>
There are security benefits as well.  Centralizing the code that is used by
multiple user-space projects as well as the kernel will likely lead to more
people scrutinizing that code.  A fix that is found by one project will fix
the others as well.  Many of these kinds of bugs lead to CVE entries, so
ultimately this could help reduce the number of vulnerabilities for Linux.
</p>

<p>
There are also academic and other researchers interested in a specification
of the kernel ABI.  For example, safety researchers are particularly
interested as some government agencies will not allow certain industries
(nuclear power, for example) to run Linux because there is no specification
to describe the limits of what the ABI provides.
</p>

<h4>Plans</h4>

<p>
The "hard part" is what is being worked on now, Levin said, which is to
determine the format for the specification.  The <tt>open()</tt> and
<tt>close()</tt> system calls are "pretty easy to describe", but other
system calls are more complicated and have a lot of interactions with other
system calls.
There is a need to start documenting all of the system
calls and <tt>ioctl()</tt> commands and to go beyond what is listed in the
<tt>man</tt> pages.  The <tt>man</tt> page may say that <tt>EINVAL</tt> is
returned for a bad flag value, but the specification needs to say exactly
what flag values will cause that return.  That needs to be written by
someone who is 
familiar with the system call, he said.
</p>

<p>
Then those specifications need to be tested.  That needs to be done without
breaking existing user-space programs, but still providing user space a way
to test the code.  If the feature is governed by a kernel configuration
option, most users won't 
change their distribution's setting, which may limit testing.  There needs
to be a way to do user-space testing that still allows existing applications
to work while the specification is incomplete and changing.
</p>

<p>
Levin was asked if he knew of other, similar efforts.  He said that the
Linux Foundation started a project and paid a company to create a
specification of some kind back in 2008.  That effort crashed when the
economy tanked around the same time and he has never seen any of the results
of that work.
</p>

<p>
Another audience member asked about the performance of putting these checks
into the system call path, which is considered to be a hot path in the
kernel.  Levin acknowledged that, but said the idea was to effectively move
the checking out of the system call itself, so that would essentially shift
the time spent.  But there would be more checks and there would be some impact
from jumping through another layer; he was hopeful that it would not be
a blocker. 
</p>

<p>
In answer to another question, Levin said he has been doing some <a href="/Articles/706606/">preliminary work</a> with the syzkaller
developers, but that
there is a need for more developers.  It is just now starting to get to a
point where it is worth getting something into the kernel, he said, but there is
much more work still to be done.
</p>

<p>
[I would like to thank the Linux Foundation for travel assistance to Tokyo
for Open Source Summit.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_model-User-space_ABI">Development model/User-space ABI</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Open_Source_Summit_Japan-2017">Open Source Summit Japan/2017</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/726021/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor726163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2017 23:12 UTC (Wed)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/726163/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This could be really useful for rr and valgrind, which want to observe all writes to user-space performed by the kernel and already have their own system-call models to find them --- but those models are incomplete and need constant updates; using shared models would be better.<br>
<p>
The syzkaller system-call descriptions look like a pretty good start for that. From a quick look I see a few issues:<br>
* License. If something like this is going to be used by a variety of projects the most lenient license possible would be good. rr is MIT-licensed, but currently the syzkaller descriptions are using the Apache 2 license.<br>
* In some places the syzkaller models are focused on generating system calls and aren't quite enough for interpreting arbitrary system calls made from user-space. E.g. the description of "key_desc" provides some hardcoded constants for some fields and doesn't tell us what happens if the incoming values are different.<br>
* In some places system calls have effects on memory that aren't captured by the syzkaller description, e.g. DRI "map" ioctls. Those need special handling by tools like rr and valgrind and it's not worth trying to put that handling in syzkaller descriptions, but it would be helpful to have a flag in the description to indicate "has other userspace effects" so tools can check that required special handling is present.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor726189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 9:31 UTC (Thu)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/726189/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, we wouldn't be able to use an Apache-2 licensed set of syscall descriptions for QEMU's linux-user mode, since we're GPL-2-only. That would be a shame.<br>
<p>
One interesting corner case for ABI specification is "if userspace makes a syscall and there are two different things wrong with the arguments, which errno is reported?". For instance if you pass read(2) a bad file descriptor and a pointer to invalid memory, do you get EBADF or EFAULT? The answer effectively is "whichever the kernel implementation happens to check first", and there's unlikely to be much consistency between different syscalls (and it wouldn't surprise me if the answer varied across kernel versions if somebody did code cleanup). QEMU's linux-user syscall emulation takes the view that userspace shouldn't care which errno it gets, because for us it's sometimes excessively difficult to arrange that the checks happen in the order the kernel does (in particular we usually have to report EFAULT early because we needed to look at buffers passed in order to convert data structures in them before making the host syscall).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor726194"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 10:55 UTC (Thu)
                               by <b>jlayton</b> (subscriber, #31672)
                              [<a href="/Articles/726194/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, the order of error returns changes all the time with kernel versions. It's good to keep things consistent between releases as much as we can, but POSIX allows us to weasel out of that with this statement:<br>
<p>
"If more than one error occurs in processing a function call, any one of the possible errors may be returned, as the order of detection is undefined."<br>
<p>
I don't hear a lot of grousing about this from userland developers, but maybe we need to do more here for a proper ABI specification?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726194/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor726254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 18:06 UTC (Thu)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/726254/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think anybody really should care about order-of-error checks (as you say, POSIX says it's not specified) and from a QEMU PoV I'd prefer it if we said it definitely wasn't ABI. On the other hand from a strict definition of ABI maybe it is?<br>
<p>
The only things I've come across which actually cared have been LTP test cases which were trying to test for "correct error code for error condition A" but had bugs which meant they supplied arguments that also provoked error condition B, but happened to pass against a real kernel because the kernel checked A first. (The LTP developers accepted bugfix patches to the tests to make them not do this.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor726199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 12:11 UTC (Thu)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/726199/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Aside: does QEMU linux-user support DRI? Because that's one thing I'd really like to support under rr that I haven't gotten to because figuring out, say, the i915 DRI ioctls seemed like too much work. (And I worry that perhaps there are shared memory effects rr just can't handle.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor726253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 18:03 UTC (Thu)
                               by <b>pm215</b> (subscriber, #98099)
                              [<a href="/Articles/726253/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nope, we've not got support for the DRI ioctls.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor726164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Signal/exit/ptrace</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2017 23:47 UTC (Wed)
                               by <b>ebiederm</b> (subscriber, #35028)
                              [<a href="/Articles/726164/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<p>
The intersection signal handling, task exiting, and ptrace is b0rken today.<br>
<p>
I will be interested if this approach is able to shed light on that area of the code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor726168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 1:50 UTC (Thu)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/726168/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; He is hoping that an ABI contract would help to kill off LTS kernels to some extent by increasing the frequency that users are willing to do kernel upgrades.</font><br>
<p>
I expect many wonderful things to come out of this work, but a change in demand for LTS kernels is not one of them.<br>
<p>
The demand for LTS kernels (and kernels maintained elsewhere using a similar process) arises because of threat of regressions *behind* the ABI, a dozen stack frames away from userspace.<br>
<p>
ABI stability is one of the things Linux tends to get right often enough.  I have not been directly affected by an ABI change in mainline release kernels in the git era, and I know of only a handful of ABI changes that affected anyone else (and most of those happened in the 90's).  ABI failures are difficult to test in general, but trivially easy to detect with a specific end-user workload, so they're nothing to worry about as long as you have at least one spare machine capable of running that workload to verify every new kernel that comes along.<br>
<p>
Enhanced parameter validation through the ABI would help discover and fix security issues, but security issues already provide motivation for all kernel upgrades, LTS or otherwise.  The resulting fixes would just end up in the LTS patch queues the same way they do now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor726171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 1:55 UTC (Thu)
                               by <b>pj</b> (subscriber, #4506)
                              [<a href="/Articles/726171/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the way of documentation, it seems like it might be useful to instrument the kernel to report all params passed to system calls so that those combinations of params (eg. flags, etc) can be listed as 'valid' or 'invalid' (depending on their result/return value) as well as more-or-less likely to be at least somewhat tested due to being in use - so bugs are more likely to lurk in other combinations of said params.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor726203"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Weakly done in Solaris</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2017 12:54 UTC (Thu)
                               by <b>davecb</b> (subscriber, #1574)
                              [<a href="/Articles/726203/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <P>In a previous life, David J. Brown and his band of madmen stabilized the ABI just outside the kernel, in the shared libraries. They were somewhat larger than the kernel, various as heck, and contained both internal (kernel-like <I>SUNWprivate</I>) and external, public interfaces.

<P>We used the spec files / elf .sections for all sorts of things, starting with testing, fuzzing-data creation, tracing (apptrace, somewhat like strace) and change tracking.

<P>I was personally interested in the latter: we had to handle normal evolution at the same time as supporting binary stability and avoiding NP-complete problems while doing so. As it happens, we used the same mechanisms as did Linux standard library and as did Multics. I have a short discussion at https://leaflessca.wordpress.com/2017/02/12/dll-hell-and-avoiding-an-np-complete-problem/

<P>Our experience, IMHO, is that having a mostly-stable, evolving ABI was <I>A Really Good Idea</I>. It's one the library folks should do more of, and the kernel folks try out somewhere it has a high likely payoff.
      
          <div class="CommentReplyButton">
            <form action="/Articles/726203/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor726358"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2017 16:09 UTC (Fri)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/726358/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; file descriptors could be verified in only one place and system calls could rely upon getting a valid one.</font><br>
<p>
What if another thread closes that file descriptor after the automatic verification but before the system call uses it? (where "uses" means "calls fget() to convert to a refcounted struct file* that is guaranteed to remain alive until the system call explicitly releases it" or similar)<br>
<p>
I assume the system call would still have to manually check if fget() etc returns NULL (indicating an invalid fd) and return an appropriate error code, but developers might become more complacent if they expect all the parameters have been verified already, so they're more likely to write buggy error handling code and review it less carefully, and it would become far harder for a unit test or fuzzer to test that error path (since it needs to set up a very tight race condition with closing the fd).<br>
<p>
It may be better for the generated verification code to intentionally *not* check any mutable state that's referenced by parameters, like files or memory, so that the checks only occur once (manually in the system call, which has to check anyway to avoid this TOCTTOU problem) and are therefore easier to test. It could still automatically verify that fd parameters are &gt;= 0 and that memory pointers are != NULL, since the parameters themselves are immutable; it just shouldn't dereference them to check they refer to open files or mapped memory, as they might not remain open or mapped.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726358/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor726365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2017 16:49 UTC (Fri)
                               by <b>k3ninho</b> (subscriber, #50375)
                              [<a href="/Articles/726365/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's really great to hear that something like this is happening from people who are going to get code committed. A 'magic number for ABI contracts' is one of the things I keep imagining would be a nice thing to hack together -- it's on a wishlist of things I'd like to do (but likely never will).<br>
<p>
<font class="QuotedText">&gt; Another audience member asked about the performance of putting these checks into the system call path, which is considered to be a hot path in the kernel. Levin acknowledged that, but said the idea was to effectively move the checking out of the system call itself, so that would essentially shift the time spent.</font><br>
<p>
The notion of having a contract allows you to specify a magic number for the calls available on a given kernel and to have the caller list the magic numbers for system calls used (which can be assembled when linking objects into a binary executable). Then a given kernel can examine that list of magic numbers when starting the program and spit out if incompatible -- done once at startup, not in the hot path of each system call.<br>
<p>
If your ABI changes, you can have new magic numbers in the contracts. If your ABI changes and you need backwards-compatibility, you can have a mapper in userspace for the interfaces you used to implement.<br>
<p>
K3n.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor726382"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 24, 2017 6:53 UTC (Sat)
                               by <b>knuto</b> (subscriber, #96401)
                              [<a href="/Articles/726382/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In my humble opinion the very best way to achieve this contract is by means of executable assertions about the syntax and semantics of each interface. A good unit test framework provides the features necessary to enable writing a test that captures a particular aspect of an interface down to details not really specified in the man pages or other associated documentation. Well written such tests can <br>
be used as guards to protect the ABI, and can also serve as a way for user level application developers to test their assumptions about an interface. <br>
<p>
Lets say I want to use a particular system call in a certain way in my application. I try it on my particular architecture and it seems to work, but the man page or documentation does not really specify that the <br>
semantics I see is guaranteed. I then go ahead and write a unit test that captures that particular semantics, post it for inclusion in a (yet to be created) kernel ABI unit test suite. The test is then initially subect to a continuous integration system that checks it against a representative set of kernels to maintain the ABI against. If passing, it is reviewed by the community and then if accepted (which also involves checking whether this is a test that in a good way documents a new aspect of the interface), also made part of a pre-check of any future kernel commit.  <br>
<p>
The benefit to the community of this test is that now the particular interface under test is better documented than before, and it is machine checkable, so no future commit would ever be able to break the contract enforced by the test. If the community establishes a practice of adding such tests for all new interfaces, and also to all cases where an ABI breakage occurs, or unclear semantics emerge, over time this set of executable specification will gradually improve into a security net against ABI breakage.<br>
<p>
The benefit to the application developer is that he/she cannot expect his/her program to be run on every platform out there to verify that the assumptions made in the application code is guaranteed. It might not even be easy to use that application for verification purposes because the semantics relied upon does not get exercised except under very special circumstances. By taking the extra work of documenting the assumption about how the interface works, the developer either identifies a bug/deficiency/ambiguity, and can then avoid relying on fuzzy semantics, or a guaranteed is placed that this semantics will never change, at least not without proper notice.<br>
<p>
Interestingly enough we recently ran into a case where the kernel ABI exhibits somewhat unexpected semantics, and where a stack of well established and heavy used applications makes assumptions that are not valid. I wouldn't be surprised if there's a lot of other applications out there that makes the same mistake.<br>
<p>
See <a href="https://lists.gnu.org/archive/html/qemu-devel/2017-06/msg05215.html">https://lists.gnu.org/archive/html/qemu-devel/2017-06/msg...</a><br>
<p>
Here QEMU makes the intuitive but invalid assumption that a successful bind() call to a certain address/port actually guarantees that a subsequent listen() call will succeed. I am certain that a number of people involved over time must have asked themselves the question if this assumption is true, and concluded that it is, although documentation does not explicitly state it. Nevertheless this problem has survived for many years without detection.<br>
For all I know without having tried on an ancient kernel, back when that assumption was made, maybe it was even true. <br>
<p>
If a test had been made that captured that semantics back then, this regression or bug would not have appeared, and likely saved a lot of frustration and time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726382/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor726491"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Definition of &quot;specification&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 26, 2017 20:58 UTC (Mon)
                               by <b>gavinsmith</b> (guest, #117044)
                              [<a href="/Articles/726491/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder what the difference between a "specification" and documentation is. I think that a specification is meant to be really precise documentation that specifies how the ABI is meant to behave.<br>
<p>
This on its own wouldn't prevent ABI breakage, as Linux developers would have to read and obey what was written in the specification, not making changes that contradict it. A specification might not be complete, and programs might rely on properties of the kernel's behaviour that were not in the written specification. If that was the case, then changing those properties would also be ABI breakage, even if these weren't in the specification.<br>
<p>
However, automatic tests to test that the ABI hasn't changed would be effective in preventing breakage. I can't think of any disadvantages of such tests. A test failure is much harder to ignore than a written specification, especially if the specification is hard to read or complicated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726491/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor726520"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Definition of &quot;specification&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 27, 2017 9:47 UTC (Tue)
                               by <b>laarmen</b> (subscriber, #63948)
                              [<a href="/Articles/726520/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To me, if there's a difference between the code and its doc, you fix the doc. If there's a difference between the code and its spec, you fix the code.<br>
<p>
Of course, YMMV.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/726520/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor727046"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Definition of &quot;specification&quot;</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 3, 2017 18:50 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/727046/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The specification describes what is SUPPOSED to happen.<br>
<p>
The documentation describes what DOES happen. (Hence the bugs - or fleas - in man pages).<br>
<p>
Of course, if "the code is the specification", then bugs are impossible :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727046/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor728203"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Specifying the kernel ABI</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 18, 2017 21:21 UTC (Tue)
                               by <b>themadsens</b> (guest, #117686)
                              [<a href="/Articles/728203/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I don't know how this compares to other projects mentioned,  but as I understand it, the <a rel="nofollow" href="https://github.com/justincormack/ljsyscall">LJsyscall</a> project is well underway with what could well be regarded as a formal specification of the the Linux ABI (and also for that of NetBSD, OSX etc). The significance of this has also been recognized <a rel="nofollow" href="https://williamaadams.wordpress.com/2012/06/19/a-new-way-of-programming-systems/">elsewhere</a>
      
          <div class="CommentReplyButton">
            <form action="/Articles/728203/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
