        <!DOCTYPE html>
        <html lang="en">
        <head><title>Toward a swap abstraction layer [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/932077/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/932267/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/932077/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Toward a swap abstraction layer</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>May 22, 2023</br>
           <hr>
<a href="/Articles/lsfmmbpf2023">LSFMM+BPF</a>
</div>
The kernel's swapping code tends to not get much love.  Users try to avoid
it, and developers often find better things to do with their time than
trying to improve it.  At the <a href="/Articles/lsfmmbpf2023">2023 Linux
Storage, Filesystem, Memory-Management and BPF Summit</a>, though, Yosry
Ahmed dedicated a memory-management-track session to the problem of the
swap layer and what might be done to make it better.
<p>
Ahmed started with the subject of <a
href="https://www.kernel.org/doc/html/latest/admin-guide/mm/zswap.html">zswap</a>,
which "swaps" pages by compressing them and storing them more efficiently
in RAM.  This action happens just before actual swapping would occur, and
the rest of the memory-management system doesn't know anything about it.
One of the results of that is that a system using zswap must provide a
swap file, even if no pages are ever stored there.  Every page kept in zswap
must also have a slot reserved in the swap file, which wastes space in that
file and takes extra CPU time to manage.  The reclaim code is unaware of
zswap and has no idea where the pages it evicts will go.
<p>
So zswap is not perfectly integrated with the rest of the system, but it is
still heavily used, including on Google's production systems.  He suspects
that Chrome OS may be using it, and that a number of other companies
running large fleets also have a place for it.  So it would be good if
zswap were to work more efficiently.

Google has hacked together a short-term fix in the form of a simple
indirection layer that indexes both the swap file and the zswap area.  The
rest of the memory-management subsystem just sees a single swap index and
doesn't know whether it corresponds to an actual swap entry or a zswap
entry.  He is "not fond of it", but it works.
<p>
A better solution for the medium-term, he said, could be a proper indirection
layer.  There would be an operations vector (a structure full of function
pointers) for each swap implementation, and an <a
href="https://www.kernel.org/doc/html/latest/core-api/xarray.html">XArray</a>
to index the whole thing.  As well as addressing the duplication problem,
this implementation would make it possible to optimize the <a
href="https://man7.org/linux/man-pages/man2/swapon.2.html"><tt>swapoff()</tt></a>
operation. 
<p>
An even better, long-term idea, is something he described as "swap
descriptors" that would track swapping information independently from the
backend used to store any given swapped page.  This would be a much cleaner
abstraction, he said, though it would add a bit of memory overhead for the
additional tracking.  There would also have to be another index added to
support cluster readahead (which reads pages in larger chunks for
performance) properly.  This would be a bigger job overall.
<p>
Matthew Wilcox said that cluster readahead is an optimization that was
necessary for spinning media, but that it has no value for solid-state
storage.  Rather than worrying about cluster readahead, the
memory-management subsystem should just be swapping entire folios and
keeping the data together that way.  Michal Hocko agreed, saying that users
with slow disks have learned to avoid swap at all costs; cluster readahead
is an optimization for a non-existent set of users.
<p>
Ahmed said that he was worried that he would be told that keeping cluster
readahead would be a requirement, but nobody in the room seemed to feel
that way.  His next question was whether a memory overhead of 0.6-0.8% for
swap descriptors would be too much; Wilcox responded that it was
affordable, but said that care had to be taken to avoid allocating memory
in the reclaim path.
<p>
Chris Li briefly presented an alternative, which he called a "virtual
filesystem interface for swap files", that would abstract out all of the
operations for each swap type.  Each swap file would have its own swap
count and slot management.  Swapping, when implemented this way, could be
organized in layers without the need for an additional indirection layer;
that would avoid the need to increase its memory usage.  The Android
system, he said, aims to keep about 20% of its pages in swap; its
developers might not be pleased with the extra overhead.
<p>
David Hildenbrand, at the end of the session, said that people have been
complaining about the swap layer for years.  He would like to see that code
rewritten to work more like the virtual filesystem layer does, so he has a
strong preference for Li's alternative if it takes the kernel in that
direction.  Dan Williams advised Li that "if you come to LSFMM and show
people a pony, they will want the pony".  Hildenbrand agreed and, with a
laugh, said that Li's proposal was accepted.
<p>
Swapping in Linux may thus finally be on a path toward improvement.  It's
worth keeping in mind, though, that the code implementing this idea does
not exist yet.  So the kernel will probably not be swapping out its swap
interface in the near future.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Swapping">Memory management/Swapping</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Storage_Filesystem_Memory-Management_and_BPF_Summit-2023">Storage, Filesystem, Memory-Management and BPF Summit/2023</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/932077/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor932642"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2023 18:37 UTC (Mon)
                               by <b>vasvir</b> (subscriber, #92389)
                              [<a href="/Articles/932642/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; will probably not be swapping out its swap interface</span><br>
<p>
Priceless...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932642/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor932653"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2023 22:00 UTC (Mon)
                               by <b>intgr</b> (subscriber, #39733)
                              [<a href="/Articles/932653/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If zswap has already went through the trouble of compressing a page and it ends up being evicted to disk, it would be nice to save the compressed version to reduce I/O and improve utilization.<br>
<p>
But AFAIK what happens now is that the page will get decompressed by zswap to be written to disk in plain.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932653/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor932656"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2023 23:07 UTC (Mon)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/932656/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; David Hildenbrand, at the end of the session, said that people have been complaining about the swap layer for years.</span><br>
<p>
Count me in them! I've been perpetually confused by the whole existence of zswap and zram (and FrontSwap and CleanCache, and why this sliver of the kernel needs CamelCase Branding), appearing at more or less the same time with kconfig flags scattered all over the place (and shuffling around every few months) pertaining to one or the other or both with no obvious indication which is which. And I'm an outlier that has the time to go spelunking in docs all day, I don't see how a regular sysadmin can ever hope to understand this maze or configure it correctly.<br>
<p>
(Configuring it correctly, from what I eventually figured out, means to entirely ignore zswap and just have a zram-as-swapspace block device; the latter now *also* has an option to spill to a physical backing device if you want that, which seems to render zswap redundant anyway.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932656/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932660"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2023 0:20 UTC (Tue)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/932660/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm a Linux file system developer - never been an admin - and I literally didn't know these things existed.  To be fair, the file system I work on is a network one and never used for swap, but this stuff is *wild* to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932660/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor932672"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2023 9:08 UTC (Tue)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/932672/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The kernel's swapping code tends to not get much love. Users try to avoid it[...]</span><br>
<p>
I feel like a lot of this is due to the unfortunate general mis(understanding|information) that swap is only of use in emergencies when a device "runs out" of memory. For anyone unfamiliar, the role of swap is actually much more important during normal operation, because it puts anonymus and file-backed memory on equal footing. Without swap, if some program say allocates some memory for startup that it never actually ends up using again, that will have to stay there forever, even if it would be more beneficial for performance to use that memory for the page cache or some other purpose instead.<br>
<p>
I think part of this may be due to latency, as especially with old hard drives the stutter as pages get swapped back in was immediately noticable, while the the disk accesses saved by that stutter weren't. But with modern SSDs and especially ram compression, those are no longer a thing and it's basically just upsides.<br>
<p>
Large server operators have understood this for a while, but fortunately more distros like Fedora are shipping swap-on-zram and other solutions these days too. So this perception does seem to be slowly changing and I'm very happy to see more love in this area!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932672/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932678"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2023 11:07 UTC (Tue)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/932678/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; I feel like a lot of this is due to the unfortunate general mis(understanding|information) that swap is only of use in emergencies when a device "runs out" of memory. </span><br>
<p>
The problem is that the worst case was so terrible. When you have an HDD that can do 80MB/s then a 1GB swap file is 12 seconds of 100% I/O utilisation *in the best case*, which generally isn't what happens. For some reason, swapping is pretty terrible at I/O utilisation. So some process goes haywire, the kernel spends time swapping your working set to disk, then finally invokes the OOM killer to kill the offending process, and then more time swapping your working set back in again. In the meantime your system is totally unresponsive.<br>
<p>
Add in the recommendation to make your swapfile at least as large are your main memory and you could be waiting a very long time. On the other hand, having no swap avoids the problem entirely, but you pay the penalty a different way. But once bitten, twice shy.<br>
<p>
IMO when the process went haywire then either the OOM killer should have been invoked prior to swapping out your working set, or the swapping should be limited to the new process that was causing the memory pressure.<br>
<p>
Of course, SSDs changed the equation considerably. In my experience, 1GB swap is of a size that haywire processes (usually firefox, occasionally other things) only lead to about ~30s unresponsiveness. It would be great if an exploding firefox tab led to only firefox being unresponsive rather than the whole system.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932678/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932680"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2023 13:07 UTC (Tue)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/932680/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; In my experience, 1GB swap is of a size that haywire processes (usually firefox, occasionally other things) only lead to about ~30s unresponsiveness. It would be great if an exploding firefox tab led to only firefox being unresponsive rather than the whole system.</span><br>
<p>
This is why you generally want a userspace OOM killer, like oomd or the one provided by the systemd project. The kernel OOM is only invoked when an allocation request actually fails, at which point it is both too late and too deep within the kernel to really make good decisions. For example, you mention Firefox, however there is a good chance that firefox isn't the cause at all. A modern browser just happens to have a lot of processes that map a lot of memory, which makes it a juicy first target for the OOM killer regardless of whether it is actually the issue or not.<br>
<p>
A userspace OOM killer can take advantage of cgroups and statistics like PSI to act much earlier and smarter instead. It can, for example, look at memory pressure to determine that some cgroup is causing a lot of system time to be spent on memory reclaim (shrinking caches, swapping, etc.) and interfering with system performance long before it has exhausted all memory. In my experience when I fat-finger an array size that usually means a brief hitch of a second at most.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932680/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor932710"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2023 13:11 UTC (Tue)
                               by <b>gmgod</b> (guest, #143864)
                              [<a href="/Articles/932710/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Of course, SSDs changed the equation considerably.</span><br>
<p>
In case of true OOM, you get the exact same "system grinding to a halt" problem you had on HDDs though. And usually not just 30s of it (in my experience)...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932710/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor932681"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2023 11:41 UTC (Tue)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/932681/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; it puts anonymus and file-backed memory on equal footing</span><br>
<p>
Yes, we have all read that "in-defense of swap", and we agree that swap has its value in memory management.  But IMHO declaring anon pages and file-backed ones as "equal" is way too optimistic:<br>
- file-backed pages that are not dirty do not need a swap-out step;<br>
- applications usually anticipate disk file access may take some time, and they implement many strategies to avoid file access hanging UI, but no app can anticipate an arbitrary anon page may take more time to access; swapping out such pages may have a higher chance to give the user a stutter.<br>
<p>
But, well, don't get me wrong, I'm not against enabling swap.  My opinion is that, saying "we should enable swap" and advertising "enable swap and your system will be more responsive" cannot be accurate.  A lot of configuration are needed to get an always-responsive system; swap is one part of the config, but all parts must come together to make it work.  MGLRU, DAMON, cgroups and its managers (e.g. system76 scheduler) are going to help us on the way.  However, there is always another choice: if your RAM is enough most of the time, just don't enable swap and shutdown everyday; if you are shot someday just reboot.  I'm curios whether those strategies can play equally well as this.<br>
<p>
Again, don't get me wrong, I don't like rebooting everyday, and I do have swap enabled on some of my systems; although when it goes too far I still have to resort to rebooting.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932681/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932709"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2023 12:38 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/932709/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <p>I don't get your second point:
<blockquote>
 - applications usually anticipate disk file access may take some time, and they implement many strategies to avoid file access hanging UI, but no app can anticipate an arbitrary anon page may take more time to access; swapping out such pages may have a higher chance to give the user a stutter.
</blockquote>
<p>If the kernel has no access to swap, then it's, by definition, going to evict file-backed pages to make room for the application's data use. On my system, the vast majority of file-backed pages are executable code; what applications implement strategies to avoid hanging the UI if their code is paged out and has to be reloaded from mass storage?


      
          <div class="CommentReplyButton">
            <form action="/Articles/932709/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932717"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2023 14:30 UTC (Tue)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/932717/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think page caches are counted as a kind of file-backed memory, did I get it wrong?  After all I'm told by some swap supporters that they choose to swap out anon pages to make room for page cache.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932717/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932762"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 0:01 UTC (Wed)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/932762/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there any *other* kind of file backed data?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932762/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932764"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 0:55 UTC (Wed)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/932764/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ugh, you are right, my wording is bad.  I mean, at least on my machine, most of the page cache is not mapped in any userspace mapping; and that's what swap proponents keep telling me, that these cache are also good for performance and I should swap out other unused parts, those mapped by userspace, to make room for that part of the page cache.  They never told me a good strategy to decide which ones are "unused", however.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932764/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932778"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 10:38 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/932778/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Assuming you have a sensibly sized swap (not so large that you can enter swap thrash, and not too small), the kernel will get it right. It tracks access frequency for pages, and it can track whether it's doing repeated I/O to reread pages, and will (with help from the <a href="https://www.kernel.org/doc/html/next/admin-guide/sysctl/vm.html#swappiness"><tt>vm.swappiness</tt> sysctl</a> decide whether to swap out an unused page of anonymous memory or drop some page cache.
<p>And bear in mind that pages mapped by executables <em>are</em> part of the page cache. The page cache is all data that the kernel can recover from the filesystem trivially, and thus can drop at any time - most of the code segments of the running executables are just page cache pages.


      
          <div class="CommentReplyButton">
            <form action="/Articles/932778/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor933290"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2023 19:15 UTC (Tue)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/933290/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ok, thanks for the clarification!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933290/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor932765"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 1:26 UTC (Wed)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/932765/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry it seems I may have made some upset, so allow me to rephrase:<br>
<p>
I think that in-defense of swap article says "having a swap is good for memory management in general", and I agree.<br>
<p>
However I'm upset that part of our community seems to take that as "enable swap, and your desktop will be more responsive at all times".  This kind of flame war happens very often when someone says "I disable swap and it's faster".  I don't know if this is implied in that article (I think not), but I have to say I disagree with it.  There are too many factors in the responsiveness problem, and swap on/off can be either better or worse.  I have heard a user (in a telegram group chat) that goes to implement a daemon that memlocks all X/gtk libraries on boot, so he gets a hard guarantee that critical UI library code never gets evicted.  Having heard this case I think the whole picture may be like, swap gives eviction more choice, but users need protection in addition to a swap, to actually get good performance; but these protection mechanisms are way more complex, and solutions are still evolving.  As such I think there's no point shouting at a user who disables swap; he may have done scientific testing on his own and decided no-swap is actually better for him.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932765/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932779"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 10:44 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/932779/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <p>As a rule of thumb, turning off swap completely is a route to trouble, and if turning swap off improves your system, you've probably got the wrong value for <a href="https://www.kernel.org/doc/html/next/admin-guide/sysctl/vm.html#swappiness"><tt>vm.swappiness</tt></a>, such that the kernel is too keen to swap pages instead of dropping page cache, or vice-versa.
<p>In the case of memlocking critical UI code, that's something that will only help if your system is set up to avoid swapping - most of the code is in the page cache, and mapped into userspace, and if you have too little swap (or a kernel tuned to prefer evicting page cache to swapping anonymous pages), the kernel is forced to drop those page cache pages in order to avoid OOM.
<p>This <em>is</em> a complicated topic, and there's a lot of misunderstanding out there about what works and what does not work - e.g. people not realising that the "page cache" includes all the code pages from your executables, and thus by removing swap as an option, you force the kernel to evict code you're actively using in order to avoid OOM.


      
          <div class="CommentReplyButton">
            <form action="/Articles/932779/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932784"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 12:30 UTC (Wed)
                               by <b>xecycle</b> (subscriber, #140261)
                              [<a href="/Articles/932784/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; by removing swap as an option, you force the kernel to evict code</span><br>
<p>
This can be right or wrong, depending on other factors.  E.g. on single-purpose systems I can go extreme: memlock all code sections; I can do this together with cgroup-limiting all userspace to use some less memory than total physical memory.  Removing swap basically means to lock all anon pages; I can still manually lock file-backed pages.<br>
<p>
This, IMO, can be a valid protection scheme, and it can work without swap.<br>
<p>
Btw "in order to avoid OOM" is what the kernel is programmed to do; which makes sense, as a general-purpose kernel it must try to allow programs to proceed, in the absence of configured limits.  But this may be not the top-priority of an end user.  In the desktop use case (where the word "responsiveness" makes sense), I would prefer something that can quickly identify a misbehaving program and kill it, ideally without other programs' code dropped or anon swapped out.  Let's imagine this protection scheme:<br>
- I pick some apps, declare them as important, run them in a cgroup with memory.min protections, all code sections locked;<br>
- for all other apps run those in another cgroup that is limited to use total RAM - some margin for the kernel - dedicated amount given to above.<br>
This way, with or without swap, with or without an early OOM daemon, those important apps should get equal protection after all.  "Unimportant" apps can benefit from swap, yes, but I can simply declare them "unimportant".<br>
<p>
Of course I don't think there are many people doing this on their desktops, but I think similar practice is already used elsewhere, e.g. pod QoS in k8s.<br>
<p>
Again, I'm arguing that users actually want a good protection scheme, and a good scheme for some use case may work well without swap at all.  After all, what to do with diskless systems?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932784/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932787"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 13:56 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/932787/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Sure, in special-purpose systems you can memlock all important code so that it can't be evicted from the page cache, and you can limit userspace so that it can't overcommit. This works fine with or without swap.
<p>But the underlying problem we have is that <tt>fork</tt> either requires a huge amount of wasted swap/memory, or overcommit. If you allow overcommit, then you have to have some way of handling what happens when you get it wrong, and run out of memory.
<p>Your scheme isn't something that's commonly used, precisely because of the overcommit issue - you've just declared that important apps can't overcommit, and thus can't reliably use <tt>fork</tt>. What <em>is</em> common is setting up OOM controls so that if there's a shortage of memory, unimportant apps get killed first, and unimportant apps get paged out in preference to important apps.
<p>But on a desktop, pretty much everything you're running is an important application - you don't bother running something if you don't want it to work. So you need a system that works well for a case where nothing is unimportant - and that's the case where you have a small amount of swap, and an early OOM daemon that kills programs if they start entering swap thrash.
<p>And it's not useful to keep all code sections in memory - my desktop is currently perfectly responsive, and yet significant chunks of running applications are not paged in - start up code, error handling code for errors I'm never going to hit, POP3 code in my e-mail client, X11 support in my GUI libraries for Wayland-native programs, Wayland support in GUI libraries for programs that still use X11 and more. None of that needs to be loaded into memory, since it's never going to run; and by locking it into memory, you stop my applications from using that memory for something more useful to me.
<p>The goal the kernel has is to page out only the parts of file-backed data that won't be accessed again soon, and to page out anonymous data that won't be accessed again soon. It needs a bit of guidance (the swappiness parameter) to help it out in deciding between the two, but it won't page something out unless it's rarely accessed - and by definition, that's the stuff that you don't need for responsiveness, since if you did, it'd be frequently accessed.


      
          <div class="CommentReplyButton">
            <form action="/Articles/932787/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor932864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 16:30 UTC (Wed)
                               by <b>SLi</b> (subscriber, #53131)
                              [<a href="/Articles/932864/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would love to know what that magic value for swappiness is. It is my experience too that with basically any amount of swap and swappiness&gt;0, there's a major risk of a system becoming completely unresponsive for half an hour, even with the swap space being on a fast SSD.<br>
<p>
If this is easy to get right, is there any (say, desktop-oriented) distribution that gets it right, or even modifies the kernel defaults, out of the box?<br>
<p>
My workstation has 512 GiB of RAM. If I add a comparatively very meager amount of 10 GiB of swap, a runaway process makes it completely unusable for a long time.<br>
<p>
I think in this game, it's cheaper to just buy 10% more RAM and waste it. Still, it's sad. Why is this so hard?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932865"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 16:44 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/932865/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>10 GiB of swap is a huge amount, unless you're spreading it across multiple Optane SSDs; to avoid the unresponsiveness issue, you want the OS to be able to random write the swap area in page-sized chunks in under half a second. On my laptop, with a fast SSD (1.4M IOPS), that limits swap to 6 GiB at most, and I actually use 128 MiB (with 64 GiB RAM), which makes for a good balance - when things go wrong, it doesn't thrash, but I see anonymous pages swapped out when my free memory gets low (noting that it's often unused, since it's not unknown for me to not fill RAM with page cache and anonymous pages in a single session, and I shut down the laptop overnight).
<p>The rules about swap being sized proportionally to RAM come from systems without overcommit. In that situation, you do need a lot of swap, but most of it is never used; Linux has overcommit, and thus you only need a very small amount of swap to ensure that unused anonymous pages can be swapped in preference to paging out in-use code.


      
          <div class="CommentReplyButton">
            <form action="/Articles/932865/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 16:49 UTC (Wed)
                               by <b>SLi</b> (subscriber, #53131)
                              [<a href="/Articles/932866/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But then that also sounds like a very much diminishing benefit. In the best case, your computer performs as if it had 0.2% more RAM. In the worst case, you'll run into OOM sluggishness. Is it worth it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/932866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor932867"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2023 16:52 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/932867/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Yes, it really is. It's the difference between the machine going sluggish when I run close to OOM, because it's paging code in and out all the time, and it's having to page the code I'm actually using, and the machine using swap to page out anonymous data, giving systemd-oomd time to react and kill off the thing that's eating all my RAM.
<p>Without it, I find my system enters thrash a lot more easily than it does with a tiny amount of swap.


      
          <div class="CommentReplyButton">
            <form action="/Articles/932867/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor933125"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 28, 2023 23:43 UTC (Sun)
                               by <b>pturmel</b> (guest, #95781)
                              [<a href="/Articles/933125/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a very useful tip.  Thanks, @farnz.  I will now give my laptop 128MB of swap and see how it goes (also 64GB of RAM, nVME storage).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933125/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor933250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2023 12:42 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/933250/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I should note that I suspect that a significant fraction of my gains from this are because I have systemd-oomd running, and it takes action when swap is significantly used. My working theory is that if I'm hitting 90% full swap, I'm at a point where I've exceeded my system's capabilities, and systemd-oomd should kick in and kill things before I start paging out the executable code I'm actively using.


      
          <div class="CommentReplyButton">
            <form action="/Articles/933250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor933131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2023 9:10 UTC (Mon)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/933131/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; The rules about swap being sized proportionally to RAM come from systems without overcommit. </span><br>
<p>
And the fact that if you want to support hibernation, your memory has to fit in swap. IIRC that was the argument some distributions had to default sizing the swap so large. I think most distributions don't do that anymore, and hibernation has basically disappeared as an option in most setups.<br>
<p>
I think it would be nice to be able to reserve some disk space for "hibernation-but-not-swap", but that's not possible AFAIK.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor933132"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2023 12:20 UTC (Mon)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/933132/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  I think it would be nice to be able to reserve some disk space for "hibernation-but-not-swap", but that's not possible AFAIK.</span><br>
<p>
You can do that by only enabling an additional swap partition just before hibernation and disabling it right after resume.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933132/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor933265"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Toward a swap abstraction layer</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 30, 2023 13:38 UTC (Tue)
                               by <b>gioele</b> (subscriber, #61675)
                              [<a href="/Articles/933265/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  &gt; I think it would be nice to be able to reserve some disk space for "hibernation-but-not-swap", but that's not possible AFAIK.</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; You can do that by only enabling an additional swap partition just before hibernation and disabling it right after resume.</span><br>
<p>
That's more or less the behavior of the `resume=` kernel argument, isn't it?<br>
<p>
From <a href="https://man7.org/linux/man-pages/man7/kernel-command-line.7.html">https://man7.org/linux/man-pages/man7/kernel-command-line...</a><br>
<p>
<span class="QuotedText">&gt; resume=, resumeflags=</span><br>
<span class="QuotedText">&gt;</span><br>
<span class="QuotedText">&gt; Enables resume from hibernation using the specified device and mount options. All fstab(5)-like paths are supported. For details, see systemd-hibernate-resume-generator(8).</span><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/933265/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
