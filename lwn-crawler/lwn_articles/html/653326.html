        <!DOCTYPE html>
        <html lang="en">
        <head><title>RCU requirements part 3 [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/653326/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/653714/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/653326/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>RCU requirements part 3</h1>
</div>
<div class="ArticleText">
<div class="GAByline">
           <p>August 12, 2015</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
This is the third and final segment in a series on the requirements for the
kernel's read-copy-update (RCU) subsystem and how they came to be. <a
href="/Articles/652156/">Part&nbsp;1</a> covered the fundamental
requirements that make RCU what it is, while <a
href="/Articles/652677/">part&nbsp;2</a> got into the requirements driven
by software-engineering and parallelism concerns.  In this concluding
segment, the discussion will become more Linux-specific.  In particular,
the following topics are covered:
<p>
<ul>
<li>	<a href="#Linux-Kernel Complications">
	Linux kernel complications</a>
<li>	<a href="#Other RCU Flavors">
	Other RCU flavors</a>
<li>	<a href="#Possible Future Changes">
	Possible future changes</a>
</ul>
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
Needless to say, it wouldn't be an RCU article without the answers to the
quick quizzes at the end — but this article only has a single quiz in it.
<p>

<h4><a name="Linux-Kernel Complications">Linux kernel complications</a></h4>

<p>
The Linux kernel provides an interesting environment for all kinds of
software, including RCU.
Some of the relevant points of interest are as follows:

<ol class="spacylist">
<li>	<a href="#Configuration">Configuration</a>.
<li>	<a href="#Firmware Interface">Firmware interface</a>.
<li>	<a href="#Early Boot">Early boot</a>.
<li>	<a href="#Interrupts and NMIs">
	Interrupts and non-maskable interrupts (NMIs)</a>.
<li>	<a href="#Loadable Modules">Loadable modules</a>.
<li>	<a href="#Hotplug CPU">Hotplug CPU</a>.
<li>	<a href="#Scheduler and RCU">Scheduler and RCU</a>.
<li>	<a href="#Tracing and RCU">Tracing and RCU</a>.
<li>	<a href="#Energy Efficiency">Energy efficiency</a>.
<li>	<a href="#Performance, Scalability, Response Time, and Reliability">
	Performance, scalability, response time, and reliability</a>.
</ol>

<p>
This list is probably incomplete, but it does give a feel for the
most notable Linux kernel complications.
Each of the following sections covers one of the above topics.

<h4><a name="Configuration">Configuration</a></h4>

<p>
RCU's goal is automatic configuration, so that almost nobody
needs to worry about RCU's <tt>Kconfig</tt> options.
And, for almost all users, RCU does in fact work well
&ldquo;out of the box.&rdquo;

<p>
However, there are specialized use cases that are handled by
kernel boot parameters and <tt>Kconfig</tt> options.
Unfortunately, the <tt>Kconfig</tt> system will explicitly ask users
about new <tt>Kconfig</tt> options, which requires almost all of them
be hidden behind a <tt>CONFIG_RCU_EXPERT</tt> <tt>Kconfig</tt> option.
Commits doing this hiding are making their way to mainline.

<p>
This all should be quite obvious, but the fact remains that
Linus Torvalds recently had to
<a href="http://marc.info/?l=linux-kernel&amp;m=142905739823385">remind</a>
me of this requirement.

<h4><a name="Firmware Interface">Firmware interface</a></h4>

<p>
In many cases, the kernel obtains information about the system from the
firmware, and sometimes things are lost in translation.
Or the translation is accurate, but the original message is bogus.

<p>
For example, some systems' firmware over-reports the number of CPUs,
sometimes by a large factor.
If RCU naively believed the firmware, as it used to do,
it would create too many per-CPU kernel threads.
Although the resulting system will still run correctly, the extra
threads needlessly consume memory and can cause confusion
when they show up in <tt>ps</tt> listings.

<p>
RCU must therefore wait for a given CPU to actually come online before
it can allow itself to believe that the CPU actually exists.
The resulting &ldquo;ghost CPUs&rdquo; (which are never going to
come online) cause a number of
<a href="http://paulmck.livejournal.com/37494.html">interesting complications</a>.

<h4><a name="Early Boot">Early boot</a></h4>

<p>
The Linux kernel's boot sequence is an interesting process,
and RCU is used early, even before <tt>rcu_init()</tt>
is invoked.
In fact, a number of RCU's primitives can be used as soon as the
initial task's <tt>task_struct</tt> is available and the
boot CPU's per-CPU variables are set up.
The read-side primitives (<tt>rcu_read_lock()</tt>,
<tt>rcu_read_unlock()</tt>, <tt>rcu_dereference()</tt>,
and <tt>rcu_access_pointer()</tt>) will operate normally early on,
as will <tt>rcu_assign_pointer()</tt>.

<p>
Although <tt>call_rcu()</tt> may be invoked at any
time during boot, callbacks are not guaranteed to be invoked until after
the scheduler is fully up and running.
This delay in callback invocation is due to the fact that RCU does not
invoke callbacks until it is fully initialized, and this full initialization
cannot occur until after the scheduler has initialized itself to the
point where RCU can spawn and run its kernel threads.
In theory, it would be possible to invoke callbacks earlier;
however, this is not a panacea because there would be severe restrictions
on what operations those callbacks could invoke.

<p>
Perhaps surprisingly, <tt>synchronize_rcu()</tt>,
<tt>synchronize_rcu_bh()</tt> (<a href="#Bottom-Half Flavor">discussed
below</a>), and
<tt>synchronize_sched()</tt>
will all operate normally
during very early boot, the reason being that there is only one CPU
and preemption is disabled.
This means that the call <tt>synchronize_rcu()</tt> (or friends)
itself is a quiescent
state and thus a grace period, so the early-boot implementation can
be a no-op.

<p>
<div class="tlr">
<a name="Quick Quiz 14"><b>Quick Quiz 14</b>:</a>
So what happens with <tt>synchronize_rcu()</tt> during
scheduler initialization for <tt>CONFIG_PREEMPT=n</tt>
kernels?
<br><a href="#qq14answer">Answer</a>
</div>
Both <tt>synchronize_rcu_bh()</tt> and <tt>synchronize_sched()</tt>
continue to operate normally through the remainder of boot, courtesy
of the fact that preemption is disabled across their RCU read-side
critical sections and also courtesy of the fact that there is still
only one CPU.
However, once the scheduler starts initializing, preemption is enabled.
There is still only a single CPU, but the fact that preemption is enabled
means that the no-op implementation of <tt>synchronize_rcu()</tt> no
longer works in <tt>CONFIG_PREEMPT=y</tt> kernels.
Therefore, as soon as the scheduler starts initializing, the early-boot
fastpath is disabled.
This means that <tt>synchronize_rcu()</tt> switches to its runtime
mode of operation where it posts callbacks, which in turn means that
any call to <tt>synchronize_rcu()</tt> will block until the corresponding
callback is invoked.
Unfortunately, the callback cannot be invoked until RCU's runtime
grace-period machinery is up and running, which cannot happen until
the scheduler has initialized itself sufficiently to allow RCU's
kernel threads to be spawned.
Therefore, invoking <tt>synchronize_rcu()</tt> during scheduler
initialization can result in deadlock.

<p>
I learned of these boot-time requirements as a result of a series of
system hangs.

<h4><a name="Interrupts and NMIs">Interrupts and NMIs</a></h4>

<p>
The Linux kernel has interrupts, and RCU read-side critical sections are
legal within interrupt handlers and within interrupt-disabled regions
of code, as are invocations of <tt>call_rcu()</tt>.

<p>
Some Linux kernel architectures can enter an interrupt handler from
non-idle process context, and then just never leave it, instead stealthily
transitioning back to process context.
This trick is sometimes used to invoke system calls from inside the kernel.
These &ldquo;half-interrupts&rdquo; mean that RCU has to be very careful
about how it counts interrupt nesting levels.
I learned of this requirement the hard way during a rewrite
of RCU's dyntick-idle code.

<p>
The Linux kernel has non-maskable interrupts (NMIs), and
RCU read-side critical sections are legal within NMI handlers.
Thankfully, RCU update-side primitives, including
<tt>call_rcu()</tt>, are prohibited within NMI handlers.

<p>
The name notwithstanding, some Linux kernel architectures
can have nested NMIs, which RCU must handle correctly.
Andy Lutomirski recently
<a href="https://lkml.org/lkml/2014/11/21/642">surprised me</a>
with this requirement; he also kindly surprised me with <a
href="https://lkml.org/lkml/2014/11/22/1">an algorithm</a> that meets
that requirement.

<h4><a name="Loadable Modules">Loadable modules</a></h4>

<p>
The Linux kernel has loadable modules, and these modules can
also be unloaded.
After a given module has been unloaded, any attempt to call
one of its functions results in a segmentation fault.
The module-unload functions must therefore cancel any
delayed calls to loadable-module functions; for example,
any outstanding <tt>mod_timer()</tt> must be dealt with
via <tt>del_timer_sync()</tt> or similar.

<p>
Unfortunately, there is no way to cancel an RCU callback;
once you invoke <tt>call_rcu()</tt>, the callback function is
going to eventually be invoked, unless the system goes down first.
Because it is normally considered socially irresponsible to crash the system
in response to a module unload request, we need some other way
to deal with in-flight RCU callbacks.

<p>
RCU therefore provides
<tt><a href="http://lwn.net/Articles/217484/">rcu_barrier()</a></tt>,
which waits until all in-flight RCU callbacks have been invoked.
If a module uses <tt>call_rcu()</tt>, its exit function should therefore
prevent any future invocation of <tt>call_rcu()</tt>, then invoke
<tt>rcu_barrier()</tt>.
In theory, the underlying module-unload code could invoke
<tt>rcu_barrier()</tt> unconditionally, but in practice this would
incur unacceptable latencies.

<p>
Nikita Danilov noted this requirement for an analogous filesystem-unmount
situation, and Dipankar Sarma incorporated <tt>rcu_barrier()</tt> into RCU.
The need for <tt>rcu_barrier()</tt> for module unloading became
apparent later.

<h4><a name="Hotplug CPU">Hotplug CPU</a></h4>

<p>
The Linux kernel supports CPU hotplug, which means that CPUs
can come and go.
It is of course illegal to use any RCU API member from an offline CPU.
This requirement was present from day one in DYNIX/ptx, but
on the other hand, the Linux kernel's CPU-hotplug implementation
is &ldquo;interesting.&rdquo;

<p>
The Linux kernel CPU-hotplug implementation has notifiers that
are used to allow the various kernel subsystems (including RCU)
to respond appropriately to a given CPU-hotplug operation.
Most RCU operations may be invoked from CPU-hotplug notifiers,
including even normal synchronous grace-period operations
such as <tt>synchronize_rcu()</tt>.
However, expedited grace-period operations such as
<tt>synchronize_rcu_expedited()</tt> are not supported,
due to the fact that current implementations block CPU-hotplug
operations, which could result in deadlock.

<p>
In addition, all-callback-wait operations such as
<tt>rcu_barrier()</tt> are also not supported, due to the
fact that there are phases of CPU-hotplug operations where
the outgoing CPU's callbacks will not be invoked until after
the CPU-hotplug operation ends, which could also result in deadlock.

<h4><a name="Scheduler and RCU">Scheduler and RCU</a></h4>

<p>
RCU depends on the scheduler, and the scheduler uses RCU to
protect some of its data structures.
This means the scheduler is forbidden from acquiring
the run-queue locks and the priority-inheritance locks
in the middle of an outermost RCU read-side critical section unless
it also releases them before exiting that same
RCU read-side critical section.
This same prohibition also applies to any lock that is acquired
while holding any lock to which this prohibition applies.
Violating this rule results in deadlock.

<p>
For RCU's part, the preemptible-RCU <tt>rcu_read_unlock()</tt>
implementation must be written carefully to avoid similar deadlocks.
In particular, <tt>rcu_read_unlock()</tt> must tolerate an
interrupt where the interrupt handler invokes both
<tt>rcu_read_lock()</tt> and <tt>rcu_read_unlock()</tt>.
This possibility requires <tt>rcu_read_unlock()</tt> to use
negative nesting levels to avoid destructive recursion via
interrupt handler's use of RCU.

<p>
This pair of mutual scheduler-RCU requirements came as a
<a href="http://lwn.net/Articles/453002/">complete surprise</a>.

<p>
As noted above, RCU makes use of kernel threads, and it is necessary to
avoid excessive CPU-time accumulation by these threads.
This requirement was no surprise, but RCU's violation of it
when running context-switch-heavy workloads when built with
<tt>CONFIG_NO_HZ_FULL=y</tt>
<a
href="http://www.rdrop.com/users/paulmck/scalability/paper/BareMetal.2015.01.15b.pdf">did
come as a surprise [PDF]</a>.
RCU has made good progress toward meeting this requirement, even
for context-switch-heavy <tt>CONFIG_NO_HZ_FULL=y</tt> workloads,
but there is room for further improvement.

<h4><a name="Tracing and RCU">Tracing and RCU</a></h4>

<p>
It is possible to use tracing on RCU code, but tracing itself
uses RCU.
For this reason, <tt>rcu_dereference_raw_notrace()</tt>
is provided for use by tracing, which avoids the destructive
recursion that could otherwise ensue.
This API is also used by virtualization in some architectures,
where RCU readers execute in environments in which tracing
cannot be used.
The tracing folks both located the requirement and provided the
needed fix, so this surprise requirement was relatively painless.

<h4><a name="Energy Efficiency">Energy efficiency</a></h4>

<p>
Interrupting idle CPUs is considered socially unacceptable,
especially by people with battery-powered embedded systems.
RCU therefore conserves energy by detecting which CPUs are
idle, including tracking CPUs that have been interrupted from idle.
This is a large part of the energy-efficiency requirement,
so I learned of this via an irate phone call.

<p>
Because RCU avoids interrupting idle CPUs, it is illegal to
execute an RCU read-side critical section on an idle CPU.
(Kernels built with <tt>CONFIG_PROVE_RCU=y</tt> will splat
if you try it.)
The <tt>RCU_NONIDLE()</tt> macro and <tt>_rcuidle</tt>
event tracing is provided to work around this restriction.
In addition, <tt>rcu_is_watching()</tt> may be used to
test whether or not it is currently legal to run RCU read-side
critical sections on this CPU.
I learned of the need for diagnostics on the one hand
and <tt>RCU_NONIDLE()</tt> on the other while inspecting
idle-loop code.
Steven Rostedt supplied <tt>_rcuidle</tt> event tracing,
which is used quite heavily in the idle loop.

<p>
It is similarly socially unacceptable to interrupt an
<tt>nohz_full</tt> CPU running in user space.
RCU must therefore track <tt>nohz_full</tt> user-space
execution.
And in
<a href="https://lwn.net/Articles/558284/"><tt>CONFIG_NO_HZ_FULL_SYSIDLE=y</tt></a>
kernels, RCU must separately track idle CPUs on the one hand and
CPUs that are either idle or executing in user space on the other.
In both cases, RCU must be able to sample state at two points in
time, and be able to determine whether or not some other CPU spent
any time idle and/or executing in user space.

<p>
These energy-efficiency requirements have proven quite difficult to
understand and to meet; for example, there have been more than five
clean-sheet rewrites of RCU's energy-efficiency code, the last of
which was finally able to demonstrate
<a
href="http://www.rdrop.com/users/paulmck/realtime/paper/AMPenergy.2013.04.19a.pdf">real
energy savings running on real hardware [PDF]</a>.
As noted earlier,
I learned of many of these requirements via angry phone calls;
flaming me on the Linux-kernel mailing list was apparently not
sufficient to fully vent their ire at RCU's energy-efficiency bugs.

<h4><a name="Performance, Scalability, Response Time, and Reliability">
Performance, scalability, response time, and reliability</a></h4>

<p>
Expanding on the
<a href="/Articles/652677/#Performance and Scalability">earlier
discussion</a> (in part&nbsp;2),
RCU is used heavily by hot code paths in performance-critical
portions of the Linux kernel's networking, security, virtualization,
and scheduling subsystems.
RCU must therefore use efficient implementations, especially in its
read-side primitives.
To that end, it would be good if preemptible RCU's implementation
of <tt>rcu_read_lock()</tt> could be inlined, however, doing
this requires resolving <tt>#include</tt> issues with the
<tt>task_struct</tt> structure.

<p>
The Linux kernel supports hardware configurations with up to
4096 CPUs, which means that RCU must be extremely scalable.
Algorithms that involve frequent acquisitions of global locks or
frequent atomic operations on global variables simply cannot be
tolerated within the RCU implementation.
RCU therefore makes heavy use of a combining tree based on the
<tt>rcu_node</tt> structure.
RCU is required to tolerate all CPUs continuously invoking any
combination of RCU's runtime primitives with minimal per-operation
overhead.
In fact, in many cases, increasing load must <i>decrease</i> the
per-operation overhead; witness the batching optimizations for
<tt>synchronize_rcu()</tt>, <tt>call_rcu()</tt>,
<tt>synchronize_rcu_expedited()</tt>, and <tt>rcu_barrier()</tt>.
As a general rule, RCU must cheerfully accept whatever the
rest of the Linux kernel decides to throw at it.

<p>
The Linux kernel is used for realtime workloads, especially
in conjunction with the
<a href="https://rt.wiki.kernel.org/index.php/Main_Page">-rt patchset</a>.
The realtime-latency response requirements are such that the
traditional approach of disabling preemption across RCU
read-side critical sections is inappropriate.
Kernels built with <tt>CONFIG_PREEMPT=y</tt> therefore
use an RCU implementation that allows RCU read-side critical
sections to be preempted.
This requirement made its presence known after users made it
clear that an earlier
<a href="http://lwn.net/Articles/107930/">realtime patch</a>
did not meet their needs, in conjunction with some
<a href="https://lkml.org/lkml/2005/3/17/199">RCU issues</a>
encountered by a very early version of the -rt patchset.

<p>
In addition, RCU must make do with a sub-100-microsecond realtime latency
budget.
In fact, on smaller systems with the -rt patchset, the Linux kernel
provides sub-20-microsecond realtime latencies for the whole kernel,
including RCU.
RCU's scalability and latency must therefore be sufficient for
these sorts of configurations.
To my surprise, the sub-100-microsecond realtime latency budget
<a href="http://www.rdrop.com/users/paulmck/realtime/paper/bigrt.2013.01.31a.LCA.pdf">
applies to even the largest systems [PDF]</a>,
up to and including systems with 4096 CPUs.
This realtime requirement motivated the grace-period kernel thread, which
also simplified handling of a number of race conditions.

<p>
Finally, RCU's status as a synchronization primitive means that
any RCU failure can result in arbitrary memory corruption that can be
extremely difficult to debug.
This means that RCU must be extremely reliable, which in
practice also means that RCU must have an aggressive stress-test
suite.
This stress-test suite is called <tt>rcutorture</tt>.

<p>
Although the need for <tt>rcutorture</tt> was no surprise,
the current immense popularity of the Linux kernel is posing
interesting&mdash;and perhaps unprecedented&mdash;validation
challenges.
To see this, keep in mind that there are well over one billion
instances of the Linux kernel running today, given Android
smartphones, Linux-powered televisions, and servers.
This number can be expected to increase sharply with the advent of
the celebrated Internet of Things.

<p>
Suppose that RCU contains a race condition that manifests on average
once per million years of runtime.
This bug will be occurring about three times per <i>day</i> across
the installed base.
RCU could simply hide behind hardware error rates, given that no one
should really expect their smartphone to last for a million years.
However, anyone taking too much comfort from this thought should
consider the fact that in most jurisdictions, a successful multi-year
test of a given mechanism, which might include a Linux kernel,
suffices for a number of types of safety-critical certifications.
In fact, rumor has it that the Linux kernel is already being used
in production for safety-critical applications.
I don't know about you, but I would feel quite bad if a bug in RCU
killed someone.
Which might explain my recent focus on validation and verification.

<h4><a name="Other RCU Flavors">Other RCU flavors</a></h4>

<p>
One of the more surprising things about RCU is that there are now
no fewer than five <i>flavors</i>, or API families.
In addition, the primary flavor that has been the sole focus up to
this point has two different implementations, non-preemptible and
preemptible.
The other four flavors are listed below, with requirements for each
described in a separate section.

<ol class="spacylist">
<li>	<a href="#Bottom-Half Flavor">Bottom-half flavor</a>
<li>	<a href="#Sched Flavor">Sched flavor</a>
<li>	<a href="#Sleepable RCU">Sleepable RCU</a>
<li>	<a href="#Tasks RCU">Tasks RCU</a>
</ol>

<h4><a name="Bottom-Half Flavor">Bottom-half flavor</a></h4>

<p>
The softirq-disable (AKA "bottom-half", hence the "_bh" abbreviations)
flavor of RCU, or <i>RCU-bh</i>, was developed by
Dipankar Sarma to provide a flavor of RCU that could withstand the
network-based denial-of-service attacks researched by Robert
Olsson.
These attacks placed so much networking load on the system
that some of the CPUs never exited softirq execution,
which in turn prevented those CPUs from ever executing a context switch,
which, in the RCU implementation of that time, prevented grace periods
from ever ending.
The result was an out-of-memory condition and a system hang.

<p>
The solution was the creation of RCU-bh, which does
<tt>local_bh_disable()</tt>
across its read-side critical sections, and which uses the transition
from one type of softirq processing to another as a quiescent state
in addition to context switch, idle, user mode, and offline.
This means that RCU-bh grace periods can complete even when some of
the CPUs execute in softirq indefinitely, thus allowing algorithms
based on RCU-bh to withstand network-based denial-of-service attacks.

<p>
Because
<tt>rcu_read_lock_bh()</tt> and <tt>rcu_read_unlock_bh()</tt>
disable and re-enable softirq handlers, any attempt to start a softirq
handler during the
RCU-bh read-side critical section will be deferred.
In this case, <tt>rcu_read_unlock_bh()</tt>
will invoke softirq processing, which can take considerable time.
One can, of course, argue that this softirq overhead should be associated
with the code following the RCU-bh read-side critical section rather
than <tt>rcu_read_unlock_bh()</tt>, but the fact
is that most profiling tools cannot be expected to make this sort
of fine distinction.
For example, suppose that a three-millisecond-long RCU-bh read-side
critical section executes during a time of heavy networking load.
There will very likely be an attempt to invoke at least one softirq
handler during that three milliseconds, but any such invocation will
be delayed until the time of the <tt>rcu_read_unlock_bh()</tt>.
This can of course make it appear at first glance as if
<tt>rcu_read_unlock_bh()</tt> was executing very slowly.

<p>
The
<a href="http://lwn.net/Articles/609973/#RCU Per-Flavor API Table">RCU-bh API</a>
includes
<tt>rcu_read_lock_bh()</tt>,
<tt>rcu_read_unlock_bh()</tt>,
<tt>rcu_dereference_bh()</tt>,
<tt>rcu_dereference_bh_check()</tt>,
<tt>synchronize_rcu_bh()</tt>,
<tt>synchronize_rcu_bh_expedited()</tt>,
<tt>call_rcu_bh()</tt>,
<tt>rcu_barrier_bh()</tt>, and
<tt>rcu_read_lock_bh_held()</tt>.

<h4><a name="Sched Flavor">Sched flavor</a></h4>

<p>
Before preemptible RCU, waiting for an RCU grace period had the
side effect of also waiting for all pre-existing interrupt
and NMI handlers.
However, there are legitimate preemptible-RCU implementations that
do not have this property, given that any point in the code outside
of an RCU read-side critical section can be a quiescent state.
Therefore, RCU-sched was created, which follows &ldquo;classic&rdquo;
RCU in that an RCU-sched grace period waits for for pre-existing
interrupt and NMI handlers.
In kernels built with <tt>CONFIG_PREEMPT=n</tt>, the RCU and RCU-sched
APIs have identical implementations, while kernels built with
<tt>CONFIG_PREEMPT=y</tt> provide a separate implementation for each.

<p>
Note well that in <tt>CONFIG_PREEMPT=y</tt> kernels,
<tt>rcu_read_lock_sched()</tt> and <tt>rcu_read_unlock_sched()</tt>
disable and re-enable preemption, respectively.
This means that if there was a preemption attempt during the
RCU-sched read-side critical section, <tt>rcu_read_unlock_sched()</tt>
will enter the scheduler, with all the latency and overhead entailed.
Just as with <tt>rcu_read_unlock_bh()</tt>, this can make it look
as if <tt>rcu_read_unlock_sched()</tt> was executing very slowly.
However, the highest-priority task won't be preempted, so that task
will enjoy low-overhead <tt>rcu_read_unlock_sched()</tt> invocations.

<p>
The
<a href="http://lwn.net/Articles/609973/#RCU Per-Flavor API Table">RCU-sched API</a>
includes
<tt>rcu_read_lock_sched()</tt>,
<tt>rcu_read_unlock_sched()</tt>,
<tt>rcu_read_lock_sched_notrace()</tt>,
<tt>rcu_read_unlock_sched_notrace()</tt>,
<tt>rcu_dereference_sched()</tt>,
<tt>rcu_dereference_sched_check()</tt>,
<tt>synchronize_sched()</tt>,
<tt>synchronize_rcu_sched_expedited()</tt>,
<tt>call_rcu_sched()</tt>,
<tt>rcu_barrier_sched()</tt>, and
<tt>rcu_read_lock_sched_held()</tt>.
However, anything that disables preemption also marks an RCU-sched
read-side critical section, including
<tt>preempt_disable()</tt> and <tt>preempt_enable()</tt>,
<tt>local_irq_save()</tt> and <tt>local_irq_restore()</tt>,
and so on.

<h4><a name="Sleepable RCU">Sleepable RCU</a></h4>

<p>
For well over a decade, someone saying &ldquo;I need to block within
an RCU read-side critical section&rdquo; was a reliable indication
that this someone did not understand RCU.
After all, if you are always blocking in an RCU read-side critical
section, you can probably afford to use a higher-overhead synchronization
mechanism.
However, that changed with the advent of the Linux kernel's notifiers,
whose RCU read-side critical
sections almost never sleep, but sometimes need to.
This resulted in the introduction of
<a href="https://lwn.net/Articles/202847/">sleepable RCU</a>,
or SRCU.

<p>
SRCU allows different domains to be defined, with each such domain
defined by an instance of an <tt>srcu_struct</tt> structure.
A pointer to this structure must be passed into each SRCU function,
for example, <tt>synchronize_srcu(&amp;ss)</tt>, where
<tt>ss</tt> is the <tt>srcu_struct</tt> structure.
The key benefit of these domains is that a slow SRCU reader in one
domain does not delay an SRCU grace period in some other domain.
That said, one consequence of these domains is that read-side code
must pass a &ldquo;cookie&rdquo; from <tt>srcu_read_lock()</tt>
to <tt>srcu_read_unlock()</tt>, for example, as follows:

<blockquote>
<pre>
 1 int idx;
 2 
 3 idx = srcu_read_lock(&amp;ss);
 4 do_something();
 5 srcu_read_unlock(&amp;ss, idx);
</pre>
</blockquote>

<p>
As noted above, it is legal to block within SRCU read-side critical sections,
however, with great power comes great responsibility.
If you block forever in one of a given domain's SRCU read-side critical
sections, then that domain's grace periods will also be blocked forever.
Of course, one good way to block forever is to deadlock, which can
happen if any operation in a given domain's SRCU read-side critical
section can block waiting, either directly or indirectly, for that domain's
grace period to elapse.
For example, this results in a self-deadlock:

<blockquote>
<pre>
 1 int idx;
 2 
 3 idx = srcu_read_lock(&amp;ss);
 4 do_something();
 5 synchronize_srcu(&amp;ss);
 6 srcu_read_unlock(&amp;ss, idx);
</pre>
</blockquote>

<p>
However, if line&nbsp;5 acquired a mutex that was held across
a <tt>synchronize_srcu()</tt> for domain <tt>ss</tt>,
deadlock would still be possible.
Furthermore, if line&nbsp;5 acquired a mutex that was held across
a <tt>synchronize_srcu()</tt> for some other domain <tt>ss1</tt>,
and if an <tt>ss1</tt>-domain SRCU read-side critical section
acquired another mutex that was held across an <tt>ss</tt>-domain
<tt>synchronize_srcu()</tt>,
deadlock would again be possible.
Such a deadlock cycle could extend across an arbitrarily large number
of different SRCU domains.
Again, with great power comes great responsibility.

<p>
Unlike the other RCU flavors, SRCU read-side critical sections can
run on idle and even offline CPUs.
This ability requires that <tt>srcu_read_lock()</tt> and
<tt>srcu_read_unlock()</tt> contain memory barriers, which means
that SRCU readers will run a bit slower than would RCU readers.
It also motivates the <tt>smp_mb__after_srcu_read_unlock()</tt>
API, which, in combination with <tt>srcu_read_unlock()</tt>,
guarantees a full memory barrier.

<p>
The
<a href="http://lwn.net/Articles/609973/#RCU Per-Flavor API Table">SRCU API</a>
includes
<tt>srcu_read_lock()</tt>,
<tt>srcu_read_unlock()</tt>,
<tt>srcu_dereference()</tt>,
<tt>srcu_dereference_check()</tt>,
<tt>synchronize_srcu()</tt>,
<tt>synchronize_srcu_expedited()</tt>,
<tt>call_srcu()</tt>,
<tt>srcu_barrier()</tt>, and
<tt>srcu_read_lock_held()</tt>.
It also includes
<tt>DEFINE_SRCU()</tt>,
<tt>DEFINE_STATIC_SRCU()</tt>, and
<tt>init_srcu_struct()</tt>
APIs for defining and initializing <tt>srcu_struct</tt> structures.

<h4><a name="Tasks RCU">Tasks RCU</a></h4>

<p>
Some forms of tracing use &ldquo;trampolines&rdquo; to handle the
binary rewriting required to install different types of probes.
It would be good to be able to free old trampolines, which sounds
like a job for some form of RCU.
However, because it is necessary to be able to install a trace
anywhere in the code, it is not possible to have read-side markers
such as <tt>rcu_read_lock()</tt> and <tt>rcu_read_unlock()</tt>.
In addition, it does not work to have these markers in the trampoline
itself, because there would need to be instructions following
<tt>rcu_read_unlock()</tt>.
Although <tt>synchronize_rcu()</tt> would guarantee that execution
reached the <tt>rcu_read_unlock()</tt>, it would not be able to
guarantee that execution had completely left the trampoline.

<p>
The solution, in the form of
<a href="http://lwn.net/Articles/607117/">Tasks RCU</a>,
is to have implicit
read-side critical sections that are delimited by voluntary context
switches, that is, calls to <tt>schedule()</tt>,
<tt>cond_resched_rcu_qs()</tt>, and
<tt>synchronize_rcu_tasks()</tt>.
In addition, transitions to and from user-space execution also delimit
tasks-RCU read-side critical sections.

<p>
The tasks-RCU API is quite compact, consisting only of
<tt>call_rcu_tasks()</tt>,
<tt>synchronize_rcu_tasks()</tt>, and
<tt>rcu_barrier_tasks()</tt>.

<h4><a name="Possible Future Changes">Possible future changes</a></h4>

<p>
One of the tricks that RCU uses to attain update-side scalability is
to increase grace-period latency with increasing numbers of CPUs.
If this becomes a serious problem, it will be necessary to rework the
grace-period state machine so as to avoid the need for the additional
latency.

<p>
Expedited grace periods scan the CPUs, so their latency and overhead
increases with increasing numbers of CPUs.
If this becomes a serious problem on large systems, it will be necessary
to do some redesign to avoid this scalability problem.

<p>
RCU disables CPU hotplug in a few places, perhaps most notably in the
expedited grace-period and <tt>rcu_barrier()</tt> operations.
If there is a strong reason to use expedited grace periods in CPU-hotplug
notifiers, it will be necessary to avoid disabling CPU hotplug.
This would introduce some complexity, so there had better be a <i>very</i>
good reason.

<p>
The tradeoff between grace-period latency on the one hand and interruptions
of other CPUs on the other hand may need to be re-examined.
The desire is of course for zero grace-period latency as well as zero
inter-processor interrupts undertaken during an expedited grace period
operation.
While this ideal is unlikely to be achievable, it is quite possible that
further improvements can be made.

<p>
The multiprocessor implementations of RCU use a combining tree that
groups CPUs so as to reduce lock contention and increase cache locality.
However, this combining tree does not spread its memory across NUMA
nodes nor does it align the CPU groups with hardware features such
as sockets or cores.
Such spreading and alignment is currently believed to be unnecessary
because the hot-path read-side primitives do not access the combining
tree, nor does <tt>call_rcu()</tt> in the common case.
If you believe that your architecture needs such spreading and alignment,
then your architecture should also benefit from the
<tt>rcutree.rcu_fanout_leaf</tt> boot parameter, which can be set
to the number of CPUs in a socket, NUMA node, or whatever.
If the number of CPUs is too large, use a fraction of the number of
CPUs.
If the number of CPUs is a large prime number, well, that certainly
is an &ldquo;interesting&rdquo; architectural choice.
More flexible arrangements might be considered, but only if
<tt>rcutree.rcu_fanout_leaf</tt> has proven inadequate, and only
if the inadequacy has been demonstrated by a carefully run and
realistic system-level workload.

<p>
Please note that arrangements that require RCU to remap CPU numbers will
require extremely good demonstration of need and full exploration of
alternatives.
<p>
There is an embarrassingly large number of flavors of RCU, and this
number has been increasing over time.
Perhaps it will be possible to combine some at some future date.

<p>
RCU's various kernel threads are reasonably recent additions.
It is quite likely that adjustments will be required to more gracefully
handle extreme loads.
It might also be necessary to be able to relate CPU utilization by
RCU's kernel threads and softirq handlers to the code that instigated this
CPU utilization.
For example, RCU callback overhead might be charged back to the
originating <tt>call_rcu()</tt> instance, though probably not
in production kernels.

<h4><a name="Summary">Summary</a></h4>

<p>
This document has presented more than two decade's worth of RCU
requirements.
Given that the requirements keep changing, this will not be the last
word on this subject, but at least it serves to get an important
subset of the requirements set forth.

<h4><a name="Acknowledgments">Acknowledgments</a></h4>

I am grateful to Steven Rostedt, Lai Jiangshan, Ingo Molnar,
Oleg Nesterov, Borislav Petkov, Peter Zijlstra, and
Andy Lutomirski for their help in rendering
this article human readable, and to Michelle Rankin for her support
of this effort.

<p>
<h4>Answer to the quick quiz</h4>
<p>

<a name="qq14answer"></a>
<p><b>Quick Quiz 14</b>:
So what happens with <tt>synchronize_rcu()</tt> during
scheduler initialization for <tt>CONFIG_PREEMPT=n</tt>
kernels?


</p><p><b>Answer</b>:
In <tt>CONFIG_PREEMPT=n</tt> kernels, <tt>synchronize_rcu()</tt>
maps directly to <tt>synchronize_sched()</tt>.
Therefore, <tt>synchronize_rcu()</tt> works normally throughout
boot in <tt>CONFIG_PREEMPT=n</tt> kernels.
However, the code must work in <tt>CONFIG_PREEMPT=y</tt> kernels,
so it is still necessary to avoid invoking <tt>synchronize_rcu()</tt>
during scheduler initialization.


</p><p><a href="#Quick%20Quiz%2014"><b>Back to Quick Quiz 14</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Read-copy-update">Read-copy-update</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/653326/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
