        <!DOCTYPE html>
        <html lang="en">
        <head><title>NULL v. zero [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/93574/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/92806/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/93574/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>NULL v. zero</h1>
<div class="Byline">[Posted July 14, 2004 by corbet]
               <p>
               </div>
</div>
<div class="ArticleText">
Back in June, this page <a href="http://lwn.net/Articles/87538/">looked at
the <tt>sparse</tt> utility</a>, which is being used to search out various
kinds of errors in the kernel code base.  Recently, large numbers of
patches have gone in to address one particular <tt>sparse</tt> complaint:
using an integer <tt>0</tt> to represent a null pointer value.  These
patches (<a href="/Articles/93575/">example</a>) have struck some
developers as useless code churn, leading to <a
href="/Articles/93576/">complaints</a> like:
<p>
<div class="BigQuote">
	If you want people to conform people to a certain CodingStyle
	please document officially in the kernel, sparse isn't distributed
	with the kernel and the sparse police is silently changing the
	kernel all over the place with sometimes questionable benefit. Only
	the __user warnings had really found the bugs, but the rest I've
	seen changes perfectly legal code.
</div>
<p>
Linus <a href="/Articles/93577/">responds</a> that programmers who
interchange <tt>NULL</tt> and zero are confused about the types they are
using and are putting that confusion into the kernel.  In his desire to
enable the compiler (and other compile-time checkers) to find errors, he
wants to separate the integer and pointer types as completely as possible.
<tt>NULL</tt> is a pointer, while <tt>0</tt> can never be.  
<p>
<div class="BigQuote">
In other words:
<p><pre>
	char * p = 0;	/* IS WRONG! DAMMIT! */
	int i = NULL;	/* THIS IS WRONG TOO! */
</pre><p>
and anybody who writes code like the above either needs to get out of the 
kernel, or needs to get transported to the 21st century. 
</div>
<p>
One might conclude from this statement that Linus is pretty well convinced
that the current course of action is correct.  He also <a
href="/Articles/93579/">states</a> that, without exception, changing zero
to <tt>NULL</tt> has resulted in better, more readable code.  So use of
<tt>NULL</tt> seems to have become part of the official kernel coding
style, even if the <a href="/Articles/93580/">CodingStyle document</a> is
still silent on the matter.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Coding_style">Coding style</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#NULL_and_zero">NULL and zero</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/93574/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor93680"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 11:38 UTC (Thu)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/93680/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      The ISO/IEC 9899:1999 standard states that<p>1) as of the language: an integer constant expression with the value 0, or such an expression cast to type void *, is called a null pointer constant. If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function. [6.3.2.3.3]<p>2) as of the libraries: NULL is a macro that expands to the implementation-defined null pointer constant. [7.17.3] <p>These two statements clash a bit -- the null pointer constant is not an implementation defined, but rather a standards-defined.<br>It is obvious therefore that NULL is always #defined as 0 or ((void *)0).<p>It is totally correct to use 0 to initialize pointers to zero. That's what the standard states. With all due respect, Linus should have read the C standard before stating the contrary.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93680/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93706"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 11:46 UTC (Thu)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/93706/">Link</a>] 
      </p>
      
      </div>
      </summary>
      [In the last paragraph: to null, not to zero, of course.]
      
          <div class="CommentReplyButton">
            <form action="/Articles/93706/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor93708"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 12:15 UTC (Thu)
                               by <b>dougm</b> (guest, #4615)
                              [<a href="/Articles/93708/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      Linus isn't arguing that it violates the standard; he's arguing that it's a style violation that leads to decreased code readbility and mistakes.  This is clear if you read the whole thread. 
      
          <div class="CommentReplyButton">
            <form action="/Articles/93708/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93735"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 15:52 UTC (Thu)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/93735/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Thanks for the correction. Style coding standards may be more strict than the language itself, of course.<p>By the way, are there some real examples when the use of 0 instead of NULL would lead to some real error? I'm just curious.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93735/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93750"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 17:03 UTC (Thu)
                               by <b>kamil</b> (guest, #3802)
                              [<a href="/Articles/93750/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      0 is not good enough if the compiler can't guess from the context that you want a pointer.  This typically happens in cases such as this one:<p>int execl(const char *path, const char *arg, ...);<p>Here, one should pass null pointer as the last argument.  Passing 0 is usually OK on 32-bit machines, but not on 64-bit ones.  You must explicitly cast 0 to a pointer type to conform to the standard.  But NULL will be just as erroneous here, given that the standard allows it to be defined as a plain int 0.  So you would in fact have to write (void*)NULL to conform both to the C standard and to Linus :-).<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/93750/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 19:25 UTC (Thu)
                               by <b>knobunc</b> (subscriber, #4678)
                              [<a href="/Articles/93785/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Sorry, I don't see why you would need to cast NULL to conform to the spec as summarized above since it is says &quot;implementation-defined null pointer constant&quot; so it must provide something that is a 64-bit pointer.<p>-ben
      
          <div class="CommentReplyButton">
            <form action="/Articles/93785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 19:34 UTC (Thu)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/93788/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I think the other person mean (const char *)NULL, but maybe not.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor93786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 19:32 UTC (Thu)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/93786/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yeah, but unfortunately you can't pass plain NULL either (though it works<br>on almost any system).  You have to cast it to the correct pointer type.<br>(Of course using 0 is even worse.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/93786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor93821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 22:45 UTC (Thu)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/93821/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I guess you can always safely pass NULL, as it would be declared as a plain 0 only in case it really physically is a plain 0. In any other case it would be ((void *)0). Any sane library would always declare NULL as ((void *)0), because it is the compiler that always knows the actual physical value for sure :)<p>Of course, all other values for NULL would be incorrect, as it was explained in my initial posting. One can not define NULL as 0xFFFFFFFF, for example, as it would not qualify as a null pointer constant.<p>Thanks for providing the example, that clarified things a bit!
      
          <div class="CommentReplyButton">
            <form action="/Articles/93821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor93717"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 13:34 UTC (Thu)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/93717/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      The C compiler and standards will accept a lot of things that are garbage, in all honesty.  Just because a NULL pointer is just 0 is really nothing more than an implementation detail.  It's also an artifact of C's weak type checking, which is one argument people often use in favor of C++, Java, C#, etc.<p>A code checker like Sparse will often enforce a stricter dialect than standard C, which is a good thing, because then it will find errors that the normal C compiler wouldn't pick up.  Correct type checking is one such error.<p>It also does improve readability.  If you are skimming through some code, and see:<p>if (var == 0) { ... }<p>You are likely to assume var is an integer, no?  However, if you see:<p>if (var == NULL) { ... }<p>You are likely to assume var is a pointer, yes?  Using the appropriate type makes the code easier to read and understand.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93717/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93730"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 15:41 UTC (Thu)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/93730/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      The fact that a NULL pointer is just 0 is not an implementation detail. It is not really a value -- it is a standard *syntax* to say that you want a pointer to be null. Please read my comment a bit more thourough, it is all there. It has nothing to do with weak type checking either. As a matter of fact, this works the very same way in C++, that is, null pointer constant is 0. In C/C++, the compiler always knows what you mean, judging from the context (is it a pointer being assigned or an integer? the compiler knows).<p>In case it was really about coding styles and not about the language, this is all moot anyway. People could use 0 as NULL, and it would be perfectly legal and correct, as long as they don't participate in kernel development that way. Sorry guys, I overlooked that.<p>Btw, the quoted &quot;int i = NULL&quot; is always incorrect, and that's the language issue, not a style issue.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93730/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 18:23 UTC (Thu)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/93772/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Yes, it is weak type checking. The only way C++ is a strong type checking language is if you compare it to C or Assembly. If you used Ada or Java, or any of a hundred different languages, you couldn't convert a constant of type integer to a pointer. 0, standing alone in a strong typing system is not ambigious, and it doesn't change type depending on what things you stick around it.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93824"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 23:03 UTC (Thu)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/93824/">Link</a>] 
      </p>
      
      </div>
      </summary>
      It is not a weak type checking, it is the absence of any type checking at all is some cases. It is not the language itself which imposes this absence, it is libraries that do. All that ellipsis functions for instance, as an execl example above. These prototypes doesn't give the compiler any clue about the types at all, so it can't apply any type checking in these cases. In case the compiler knows about types, it will act accordingly, converting zeroes to null pointers when applicable.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93824/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor93789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 19:37 UTC (Thu)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/93789/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Actually, no.  C++ is a little more strict.  C++ doesn't have a generic<br>pointer type like C.<p>Valid C:<p>int *ptr=malloc(10*sizeof(int));<p>That's not valid C++.  Instead you have to do this:<p>int *ptr=(int *)malloc(10*sizeof(int));<p>Which is really annoying because it is obvious from the context what the<br>type should be, and it masks the bug of not including stdlib.h before<br>calling malloc.<p>So in C++ the nil pointer is 0 (they are very adamant about this).<br>In C it is NULL, which can be either (void *)0 or 0.  The first is<br>obviously better since the compiler will complain if it is used in<br>invalid contexts but it's a quality of implementation issue not a<br>conformance issue.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93802"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 20:20 UTC (Thu)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/93802/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Actually, C++ won't compile if you don't have a function prototype for malloc in scope. If you don't include &lt;stdlib.h&gt; or something else that includes a malloc function, it simply won't work.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93802/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93826"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 23:52 UTC (Thu)
                               by <b>dododge</b> (guest, #2870)
                              [<a href="/Articles/93826/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
The header inclusion issue is in C, not C++.  The differences in the languages mean that there is no single way to call malloc that works well for both of them.
</p>

<p>
If you're writing C++ you have to cast malloc because the compiler won't like the implicit conversion. If you're writing C you shouldn't cast it, in order to force the compiler to warn you if there's no prototype in scope. 
</p>

<p>
Where you can run into trouble is when you've got code or a programmer moving betwen the two languages.
</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/93826/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor93790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 19:40 UTC (Thu)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/93790/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      Is it not strange for the language to use the lhs to determine how to<br>evaluate the rhs?  This always bothered me about C++.  For example:<p>int bob;<br>void *nancy;<p>bob = NULL*NULL;  // NULL is an integer here but a warning would be nicer<p>nancy = NULL*5; // So you say NULL is a pointer here but I don't actually believe it<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/93790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 22:02 UTC (Thu)
                               by <b>sir99</b> (guest, #3286)
                              [<a href="/Articles/93815/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      If NULL is defined as (void*)0, then neither of those is legal C++. It seems that gcc special-cases NULL so that it can be treated as both an integer and a pointer. Further, only an expression that evaluates to 0 at compile-time can be implicitly cast to a pointer; no other integer can be.<p>AIUI, the lhs doesn't determine how the rhs is evaluated. The rhs is evaluated independently and then promoted to the type of the lhs.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2004 19:35 UTC (Fri)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/93941/">Link</a>] 
      </p>
      
      </div>
      </summary>
      &quot;AIUI, the lhs doesn't determine how the rhs is evaluated. The rhs is evaluated independently and then promoted to the type of the lhs.&quot;<p>That was my point, really.  That's why NULL as (void *)0 is better than just<br>zero, and why C++'s insistance that 0 is better confuses me.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor93793"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 19:43 UTC (Thu)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/93793/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      I don't see Linus saying that 0 can't be used as a NULL pointer.  In fact<br>it clearly works since it is spread all over the kernel.  It is just way<br>better to use NULL for pointers, 0 for ints, 0U for unsigned ints, '\0'<br>for chars, etc. so that it is clear what the constant is supposed to be.<br>This is a style issue and not a standards compliance issue.<p>(C++ people would disagree and say that 0 is the correct value for the<br>null pointer but I just have to say that C++ is broken in that respect.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/93793/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93818"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2004 22:33 UTC (Thu)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/93818/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      Hey, C is broken the very same way ;) As you said, it is a style issue after all. It is the C++ people who are broken if you would like, not the language itself :)<p>Well, as a C++ person I would say that I personally prefer to use 0 everywhere, since it is faster to type, it eats less screen estate, and with all that there was not a single case in my practice where it led to any problem. I guess it's just because C++ libraries and everything I write myself is strictly typed, so the compiler always knows what I want to mean by using 0, and all the problems with the incorrect types are catched when I actually try to use the variables I initialized, not when I initialize them.<p>While I'm quite firm in it for C++, pushing that principle to a lower-level C would be a bit rough, as there are places when the type checking is bypassed, like the execl case demonstrated above (thanks for the demonstration, kamil!)<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/93818/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2004 19:40 UTC (Fri)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/93942/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      I disagree that the use of 0 for everything means that C++ is stongly typed.<br>It seems backwards to me.  A srongly typed language should be able to tell<br>the type of a constant without looking at the lhs of an assignment or the<br>parameter type in a function call.  I don't believe you that C++ magically<br>knows which one... I think it evaluates it as an int, and then converts to<br>a pointer on assignment.  Where this gets really ugly is with overloaded<br>functions and operators... if there is an int version and say, an int *<br>version, which one do you mean to call with a naked 0?
      
          <div class="CommentReplyButton">
            <form action="/Articles/93942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93946"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2004 20:15 UTC (Fri)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/93946/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      First of all, it is the fact that the language is strongly typed that allows it using 0 for anything, but not the opposite.<p>There is no magic. A zero constant may be implicitly casted either to a null pointer, or to a zero integer. The compiler deduces which cast is required judging by the target type. An integer can not be implicitly casted to a null pointer, as well as any non-zero integer constant. Only a zero integer constant may be casted to a pointer. It is quite simple really.<p>When the target type is ambiguous (e.g. with overloaded functions), the compiler will stop with an error. In this case you will have to cast your zero either to an integer type or to a pointer type explicitly. This behaviour is common with overloaded functions, and is nothing special for pointers.
      
          <div class="CommentReplyButton">
            <form action="/Articles/93946/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor94007"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2004 4:32 UTC (Sat)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/94007/">Link</a>] 
      </p>
      
      </div>
      </summary>
      But what do you mean by target type?  LHS?  If so, this goes against<br>fundamental aspects of the language.  The evaluation of the RHS should<br>not be affected by the type of the LHS.  The conversion should only<br>happen just before the assignment.  And if such conversion happens, that<br>is an implicit conversion -- an implicit cast.  That's not strong type<br>checking.  And my point is that the RHS may be more than a simple<br>unadorned zero.  When that is the case it would be nice to know ahead of<br>time if the type is an integer or a pointer so that it could warn about<br>improper manipulation of pointers (multiplying pointers for example).<br>Maybe that's a contrived corner case but I still see it as an ugly aspect<br>of the language.
      
          <div class="CommentReplyButton">
            <form action="/Articles/94007/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor94009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2004 4:41 UTC (Sat)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/94009/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Wait.  I think I just understood what you mean:<p> char *bob=0*0;<p>would not compile as 0*0 is an integer expression.  The implicit conversion<br>is only applied for a naked constant.<p>Then I retract my statement about the compiler not being able to warn in<br>some cases.  But I continue to think this is rather strange for a language<br>that claims to be strongly typed.  (For example the removal of implicit<br>conversions of char constants was a good thing... I wish C could shed that<br>&quot;feature&quot; as well.)
      
          <div class="CommentReplyButton">
            <form action="/Articles/94009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor94015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2004 11:08 UTC (Sat)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/94015/">Link</a>] 
      </p>
      
      </div>
      </summary>
      No,<p>char * bob = 0*0;<p>will compile. Everything that evaluates to a zero at compile time will work. That's what I actually meant by saying &quot;zero constant&quot;. The fact that it is possible to assign various constant expressions with the zero result to pointers looks like a misfeature, but it is minor at best.<p>On the other hand,<p>int i = 0;<p>char * bob = i;<p>will not compile, as 'i' does not qualify as something that evaluates to a zero at compile time.
      
          <div class="CommentReplyButton">
            <form action="/Articles/94015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor94866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2004 15:44 UTC (Fri)
                               by <b>Nelson</b> (subscriber, #21712)
                              [<a href="/Articles/94866/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Prior C standards haven't defined the value of NULL.  The AS/400 maybe one of the more popular examples of a platform that didn't always use it.<p>More importantly, regardless of whether or not the languages allows it,  this is a discussion about style.  Linus made the call,  don't use zero in place of NULL <br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/94866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor93987"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2004 22:59 UTC (Fri)
                               by <b>jabcslwn</b> (guest, #11815)
                              [<a href="/Articles/93987/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      I agree that NULL is not used enough for assignments, but throw another hat into the ring with the syntax<br>if(!someptr) instead of if(someptr == NULL) or <br>if(!someboolean) instead of if(someboolean==0).<br>After all, the C language values were designed to allow for this, thus<br>simplifying the language expression. Anybody want to shoot me down?
      
          <div class="CommentReplyButton">
            <form action="/Articles/93987/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor93994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">!x vs x == 0</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 16, 2004 23:50 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/93994/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I believe C was designed to allow "if (!a)" for the case that a is a logical (boolean) quantity.  That it can be used with pointers is a byproduct.  I believe the concept of the null pointer came later.
<p>
However, I accept "if (!a)" where a is a pointer, because a pointer which may have the null pointer value is in fact two pieces of information in one, and one of them is logical.  a having a non-null-pointer value is the logical proposition that a exists.  Looked at that way, "if (a == NULL)" is actually harder to read, and not because it uses a few more characters.  Because it presents the absence-of-value NULL as if it were an actual pointer value.
<p>
Of course, one thing that will always raise my hackles is "if (!a)" where a is a number.

      
          <div class="CommentReplyButton">
            <form action="/Articles/93994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor94008"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 17, 2004 4:33 UTC (Sat)
                               by <b>Ross</b> (guest, #4065)
                              [<a href="/Articles/94008/">Link</a>] 
      </p>
      
      </div>
      </summary>
      It's certainly allowed.  If it is good style is another debate :)
      
          <div class="CommentReplyButton">
            <form action="/Articles/94008/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor94754"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 22, 2004 18:59 UTC (Thu)
                               by <b>h.j.thomassen</b> (guest, #15232)
                              [<a href="/Articles/94754/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      I would like to bring this discussion back to a plain vanilla C one.<br>It may help if you read K&amp;R, 2nd Ed. page 102:<p>&quot;Pointers and integers are not interchangeable. Zero is the sole exception: the constant zero may be assigned to a pointer, and a pointer may be compared with the constant zero. The symbolic constant NULL is often used in place of zero, as a mnemonic to indicate that this is a special value for a pointer&quot;<p>The first edition has a similar text on page 97/98. So: NULL is a mnemonic to support readability: nothing more..<p>Hence the usual    #define NULL 0        [And not: (void *)0 or (char *)0].<p>Statements like &quot;ptr = 0&quot; or &quot;if (ptr != 0)&quot; are perfectly legal C, but K&amp;R have introduced NULL for better readability. Linus is right to follows K&amp;R in this.<br>The use of NULL instead of 0 shows your collegues that you are aware that you used an exceptional language feature. But automated compiler checks are out of the question.<p>If a subroutine wants a ptr-argument, it is wrong to write &quot;subr(0)&quot;, because it is not within the limits of the above K&amp;R wordings. But &quot;subr(NULL)&quot; is equally wrong. In ANSI C the function-prototyping mechanism will &quot;fix&quot; this error for you on the fly. In pre-ANSI C, or in ANSI-C without a known prototype for your subr, you are lucky (but buggy nevertheless) if &quot;sizeof(0)==sizeof(your_ptr)&quot;. Your program blows if this is not the case. I have seen a lot of this in the days when the first Motorola68000 C-compilers had the habit of giving two bytes to an int, and four bytes to a pointer.<p>But the comment by Kamil (above) with the &quot;execl&quot; example hits an exceptionally sore spot, since even the ANSI-prototype mechanism can not save you if the prototype is declared with a variable number of arguments. If you pass a 0 or a NULL as the argument to an execl, you get &quot;sizeof(int)&quot; zero-bytes on the argument stack. The subroutine expects &quot;sizeof(const char *)&quot; zero-bytes as a terminator. On modern 32-bit compilers those two sizes happen to be equal. But there is nothing in the C-language that requires them to be equal. The execl example really *must* have &quot;(const char *)NULL&quot; (or (const char *)0) to be theoretically correct in size.<p>Beware: history may repeat. The Motorola68000 example is from the days that we converted from 16-bit thinking to 32-bit thinking. The conversion from 32-bit to 64-bit thinking may uncover lots of similar problems.<p>And, by the way, there is nothing in the C standard that says that all pointers should be of equal size. I have seen one CPU-with-C-compiler where sizeof(int *) was 2, and sizeof(char *) was 3. Admittedly, this was 25 years ago.<br>But it is the reason why void-pointers were introduced in the first place.<p>The guarantee that the language gives you is that sizeof(void *) &gt;= sizeof(any_other_data_ptr_type). The void-pointer was introduced because the language needed a &quot;pointer-transport-crate&quot;, suitable to store (cast) any other type/size of data pointer into, without the risk of loosing precision.<p>From a theoretical point of view the above &quot;execl&quot; example might receive too many zero-bytes if you write (void *)0 instead of (char *)0. The (char *)0 is what the execl-prototype requires, and therefore the only correct pointer-type (and size!).<p>I think that the world would collapse if a compiler would come up now where not all pointers, including the void pointer, would have equal size; but that's a different topic.<p>Hendrik-Jan Thomassen<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/94754/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor94857"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 23, 2004 14:36 UTC (Fri)
                               by <b>vivi48</b> (guest, #6412)
                              [<a href="/Articles/94857/">Link</a>] 
      </p>
      
      </div>
      </summary>
      &gt; The execl example really *must* have &quot;(const char *)NULL&quot; (or <br>&gt; (const char *)0) to be theoretically correct in size.<p>or (void *)NULL or (void *)0 because the spec explicitely says that with va_arg you can read back a void * as a char *.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/94857/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor95135"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">NULL v. zero</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2004 16:41 UTC (Mon)
                               by <b>h.j.thomassen</b> (guest, #15232)
                              [<a href="/Articles/95135/">Link</a>] 
      </p>
      
      </div>
      </summary>
      vivi48: You are correct. I looked in my copy of the ISO/IEC FDIS 9899<br>(i.e. the C-99 standard at ISO-level) and it says in para. 6.2.5 [26]:<p>&lt;quote:&gt; A pointer to void shall have the same representation and alignment<br>requirements as a pointer to a character type. &lt;footnote:&gt; Meant to<br>imply interchangeability as arguments to functions, return values<br>from functions, and members of unions. &lt;end quote&gt;<p>(ANSI X3.159-1989 has this same text in para. 3.1.2.5 [25])<p>Also: the va_arg description (para 7.15.1.1) has a discussion about<br>type-mismatches between caller and callee, and it says that this<br>will have undefined behaviour, except if &lt;quote:&gt; one type is pointer<br>to void and the other is a pointer to a character type &lt;end quote&gt;.<p>Thanks for pointing :-) this out.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/95135/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2004, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
