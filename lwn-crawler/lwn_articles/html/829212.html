        <!DOCTYPE html>
        <html lang="en">
        <head><title>Rethinking fsinfo() [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/829212/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/829193/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/829212/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Rethinking fsinfo()</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 21, 2020</br>
           </div>
The proposed <tt>fsinfo()</tt> system call, which returns extended
information about mounted filesystems, was first <a
href="/Articles/792628">covered here</a> just over one year ago.  The form
of <tt>fsinfo()</tt> has not changed much in that year, but the debate over
merging it continues.  To some, <tt>fsinfo()</tt> is needed to efficiently
obtain information about filesystems; to others, it is an unnecessary and
over-engineered mechanism.  Changes will probably be necessary  if this
feature is ever to make it into the mainline kernel. 
<p>
Linux has long supported the <tt><a
href="https://man7.org/linux/man-pages/man2/statfs.2.html">statfs()</a></tt>
system call (usually seen from user space as <tt><a
href="https://man7.org/linux/man-pages/man3/statvfs.3.html">statvfs()</a></tt>)
as a way of obtaining information about mounted filesystems.  As has
happened so often, though, the designers of <tt>statfs()</tt> made a list
of all the filesystem attributes they thought might be interesting and
limited the call to those attributes; there is no way to extend it with new
attributes.  Filesystem designers, though, have stubbornly refused to stop
designing new features in the decades since <tt>statfs()</tt> was set in
stone, so there is now a lot of relevant information that cannot be
obtained from <tt>statfs()</tt>.  Such details include mount options, timestamp
granularity, associated labels and UUIDs, 
and whether the filesystem supports features like extended attributes,
access-control lists,
and case-insensitive lookups.
<p>
As it happens, the kernel does make much of that information available now
by way of the <tt>/proc/mounts</tt> virtual file.  The problem with
<tt>/proc/mounts</tt>, beyond the fact that some information is still
missing, is that it is inefficient to access.  Reading the contents of that
file requires the kernel to query every mounted filesystem for the relevant
information; on systems with a lot of mounted filesystems, that can get
expensive.  Systems running containerized workloads, in particular, can
have vast numbers of mounts — thousands in some cases — so reading
<tt>/proc/mounts</tt> can be painful indeed.  For extra fun, the only way
to know about newly mounted filesystems with current kernels is to poll
<tt>/proc/mounts</tt> and look for new entries.
<p>
David Howells proposes to solve the polling problem with a new notification
mechanism, but that mechanism, in turn, relies on <tt>fsinfo()</tt>, the
21st revision of which was <a
href="/ml/linux-kernel/159646178122.1784947.11705396571718464082.stgit@warthog.procyon.org.uk/">posted</a>
on August&nbsp;3.  Howells requested that both <a
href="/ml/linux-kernel/1842689.1596468469@warthog.procyon.org.uk/">notifications</a>
and <a
href="/ml/linux-kernel/1845353.1596469795@warthog.procyon.org.uk/"><tt>fsinfo()</tt></a>
be pulled during the 5.9 merge window, but that did not happen.  Instead,
the request resulted in yet another discussion about whether
<tt>fsinfo()</tt> makes sense in its current form.
<p>
<h4>fsinfo()</h4>
<p>
The API for <tt>fsinfo()</tt> is comprehensive and
extensible; there should never be a need for an <tt>fsinfo2()</tt> to add
new attributes in the future.  But it is also complex.  On the surface, the
interface looks like this:
<p>
<pre>
    int fsinfo(int dfd, const char *pathname, const struct fsinfo_params *params,
	       size_t params_size, void *result_buffer, size_t result_buf_size);
</pre>
<p>
Where the <tt>params</tt> structure is defined as:
<p>
<pre>
    struct fsinfo_params {
	__u64	resolve_flags;	/* RESOLVE_* flags */
	__u32	at_flags;	/* AT_* flags */
	__u32	flags;		/* Flags controlling fsinfo() specifically */
	__u32	request;	/* ID of requested attribute */
	__u32	Nth;		/* Instance of it (some may have multiple) */
	__u32	Mth;		/* Subinstance of Nth instance */
    };
</pre>
<p>
There are four different ways to use <tt>dfd</tt>, <tt>pathname</tt>, and
<tt>params-&gt;at_flags</tt> to specify which filesystem should be queried;
see <a
href="/ml/linux-kernel/159646180259.1784947.223853053048725752.stgit@warthog.procyon.org.uk/">this
patch changelog</a> for details.  The rest of the <tt>params</tt> structure
describes the actual information request; the results end up in
<tt>result_buffer</tt>.
<p>
There are numerous possibilities for <tt>params-&gt;request</tt>,
including:
<p>
<ul class="spacylist">
<li> <tt>FSINFO_ATTR_STATFS</tt> returns more-or-less the same information
     that would be obtained from <tt>statfs()</tt>.
<li> <tt>FSINFO_ATTR_LIMITS</tt> returns various limits of the filesystem,
     including maximum file size, inode number, user ID number, hard links
     to a file, file-name length, etc.  These are returned in an
     <tt>fsinfo_limits</tt> structure.
<li> <tt>FSINFO_ATTR_TIMESTAMP_INFO</tt> yields information about
     timestamps on files as a set of binary structures;
     this information includes the maximum values and granularity of timestamps
     expressed in a unique (to the kernel) mantissa-and-exponent format.
<li> <tt>FSINFO_ATTR_MOUNT_POINT</tt> generates a string showing where the
     filesystem is mounted.
<li> <tt>FSINFO_ATTR_MOUNT_CHILDREN</tt> gives an array of structures
     identifying the filesystems mounted below the filesystem being
     queried.
</ul>
<p>
The full list of possible requests is rather longer than the above.  Each
returns data in a different format, usually a specific binary structure for
the information requested.  For some attributes, a query might return an
arbitrary number of elements; in this case, the <tt>Nth</tt> and
<tt>Mth</tt> fields in the <tt>fsinfo_params</tt> structure can be used to
identify which should be returned.  <a
href="/ml/linux-kernel/159646187933.1784947.10955424144341330111.stgit@warthog.procyon.org.uk/">This
patch</a> contains a sample program that exercises a number of
<tt>fsinfo()</tt> features to produce a listing showing the mount
topography of the current system.
<p>
<h4>Complaints and alternatives</h4>
<p>
There are a couple of points of resistance to the <tt>fsinfo()</tt>
proposal, starting with whether it is needed at all.  Linus Torvalds <a
href="/ml/linux-kernel/CAHk-=wgz5H-xYG4bOrHaEtY7rvFA1_6+mTSpjrgK8OsNbfF+Pw@mail.gmail.com/">called
it</a> "<q>engineering for its own sake, rather than responding to
actual user concerns</q>" and wondered why it was needed now after Linux
has done without it for so many years.  Torvalds tends to worry about
adding system calls that end up being used by nobody, so it is not unusual
for him to push for justification for the addition of new interfaces. It didn't take
long for potential users to make their needs clear;  Steven Whitehouse <a
href="/ml/linux-kernel/066f9aaf-ee97-46db-022f-5d007f9e6edb@redhat.com/">described
it</a> this way:
<p>
<div class="BigQuote">
	The overall aim is to solve some issues relating to scaling to
	large numbers of mount in systemd and autofs, and also to provide a
	generically useful interface that other tools may use to monitor
	mounts in due course too. Currently parsing /proc/mounts is the
	only option, and that tends to be slow and is certainly not atomic.
</div>
<p>
Karel Zak, maintainer of the util-linux package, <a
href="/ml/linux-kernel/20200813103634.ey2xxwgbn3e4lhdr@ws.net.home/">described</a>
the needs of systems with thousands of mount points.  Lennart Poettering
provided <a href="/ml/linux-kernel/20200814075836.GA230635@gardel-login/">a
long list</a> of attributes he would like to learn about filesystems and
why they would be useful.  The end result of all this discussion is that
the need for some sort of filesystem-information system call is not really
in doubt.
<p>
The complexity of <tt>fsinfo()</tt> still gives some developers something
to worry about, though; to them, it looks like yet another multiplexer system call
that tries to do a large number of things.  But it's not entirely clear
what an alternative would look like.  There was a brief digression in which
Torvalds <a
href="/ml/linux-kernel/CAHk-=wjzLmMRf=QG-n+1HnxWCx4KTQn9+OhVvUSJ=ZCQd6Y1WA@mail.gmail.com/">suggested</a>
an API where attributes of a file could be opened as if that file were
actually a directory; so, for example, opening (with a special flag)
<tt>foo/max_file_size</tt> would allow the reading of the maximum file size
supported by the filesystem hosting the plain file <tt>foo</tt>.  This idea
strongly resembles the controversial <a href="/Articles/100148/">approach to metadata
implemented by the reiser4 filesystem</a> back in 2004, though nobody
seemed to think it was politic to point that out in the discussion.
<p>
What <i>was</i> pointed out was that there are numerous practical
difficulties associated with implementing this sort of mechanism.  Even
precisely defining its semantics turns out to be hard.  So this idea was
put aside; it will languish until somebody else surely suggests it again
several years from now.
<p>
That leaves open the question of what a new API for obtaining filesystem
information should look like.  Torvalds <a
href="/ml/linux-kernel/CAHk-=wig0ZqWxgWtD9F1xZzE7jEmgLmXRWABhss0+er3ZRtb9g@mail.gmail.com/">called</a>
<tt>fsinfo()</tt> "<q>confusing and over-engineered</q>" and <a
href="/ml/linux-kernel/CAHk-=wh4qaj6iFTrbHy8TPfmM3fj+msYC5X_KE0rCdStJKH2NA@mail.gmail.com/">asked</a>: "<q>Can we just make a simple extended statfs() and be done
with it, instead of this hugely complex thing that does five different
things with the same interface and makes it really odd as a result?</q>"
He further <a
href="/ml/linux-kernel/CAHk-=wh5YifP7hzKSbwJj94+DZ2czjrZsczy6GBimiogZws=rg@mail.gmail.com/">suggested</a>
that a number of the binary structures used by <tt>fsinfo()</tt> could be
replaced by  ASCII data.  He <a
href="/ml/linux-kernel/CAHk-=wiUcfgC1PdbS_4mfAj2+VTacOwD_uUu6krSxjpvh42T7A@mail.gmail.com/">pointed
out</a> that a number of filesystem interfaces use ASCII for the more
complex attributes already and expressed hope that a kernel interface
exporting information in ASCII would make life easier for code that is
parsing that information out of <tt>/proc/mounts</tt> now.
<p>
So the end result of this discussion is likely to be an attempt to redesign
<tt>fsinfo()</tt> along those lines.  There is a problem here, though: the
information needed is, like the systems it is representing, inherently
complex.  By the time a <tt>statfs()</tt>-like API that can represent all
of this information and which can be extended in the future is designed,
chances are that this design will start to look a lot like what
<tt>fsinfo()</tt> is now.  Replacing a few binary structures with ASCII
seems unlikely to change the picture significantly.  The end result of this
whole exercise may be something that strongly resembles the current design.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#System_calls">System calls</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/829212/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor829318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2020 17:55 UTC (Fri)
                               by <b>zyga</b> (subscriber, #81533)
                              [<a href="/Articles/829318/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unrelated to fsinfo directly, but related to parsing ascii. The problem is not the parsing of one-off specific file. It&#x27;s that there&#x27;s no consistency anywhere in the kernel, to represent structured data. Having written and maintained a parser for /proc/PID/mountinfo for several years I found:<br>
<p>
- A few bugs, over time, in a rather small and well tested code.<br>
- Edge case that affects extremely common and battle-tested implementations (mount/systemd)<br>
- Had to venture into the belly of the kernel to understand the precise implementation, and escaping rules<br>
<p>
Perhaps it would be worth recognizing that the format is neither simple nor common. Space escaping rules differ from file to file. There is no libkernel, with reference parsers, everyone rolls their own.<br>
<p>
Could the kernel, just maybe, adopt something (whatever) standard and simple. So that parsing the next &quot;simple&quot; text file, is done from a library function available in all the modern programming languages? Could we just use JSON or something of the kind?<br>
<p>
If the counter argument is that parsing JSON is hard, I will only say that there are a few high-quality implementations, including the one that everyone reading this comment is using at the time. I don&#x27;t think we need to invent a new format for fsinfo.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2020 18:09 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/829319/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I often wish the kernel would use something like protobufs for syscalls. It would save a lot of issues with marshalling/unmarshalling.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2020 12:57 UTC (Sat)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/829399/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This still adds friction as suddenly one needs to account for generated headers in the build system and add extra dependency.  I just wish  the Linux kernel has used more that old trick of using a struct for sys call arguments and passing the struct size as a version information. Then new fields can be added as necessary and the code will be both forward and backward compatible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829417"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2020 15:31 UTC (Sat)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/829417/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Reusing the tracepoint infrastructure where every event can be either read as a binary struct (with the struct layout described by some sysfs file) or as a formatted string would be a nice solution, I think.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829417/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829488"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2020 15:45 UTC (Mon)
                               by <b>SEJeff</b> (guest, #51588)
                              [<a href="/Articles/829488/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The double copy required to read protobufs would probably be terrible for user/kernel interaction. Flatbuffers, and its zero copy deserialization would be a better fit, even if it isn&#x27;t quite as well known.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829488/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829493"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2020 18:29 UTC (Mon)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/829493/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;double copy&quot;? I understand why it might require one copy (to deserialize to an in-memory format), but why two?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829493/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2020 19:07 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/829501/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would guess to avoid racing with the userspace while unmarshalling the data? Though it might be possible to create a race-safe parser for protobufs, they are not complicated.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829502"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2020 20:15 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/829502/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think Nanopb (a protobuf implementation for embedded systems) is already race-safe, since the decoder just reads linearly from an input stream, so that does seem possible.<br>
<p>
When decoding strings or byte arrays, it can read directly from the stream into the decoded message struct (if the field is configured with a fixed max size) or into a malloced buffer (if configured with variable size) or can pass a substream object representing the value into a callback function. Using the callback interface would let the kernel copy directly from the userspace input buffer into the appropriate internal kernel struct.<br>
<p>
It looks like FlatBuffers can&#x27;t do that, because verification (to avoid out-of-bounds reads etc) is a separate operation from reading fields. You&#x27;d have to memcpy the whole buffer from userspace to kernel memory before verifying and then copying strings again into kernel structs.<br>
<p>
For kernel-to-userspace messages, you don&#x27;t need to worry about race conditions and you probably don&#x27;t need the verification step (since you have to trust the kernel anyway), so FlatBuffers could work better there.<br>
<p>
For userspace-to-kernel in both protocols, if you really don&#x27;t want to force the user to pack all their data into a single buffer, you could always encode userspace pointers as integers (like a &quot;fixed64&quot; in protobuf) to point to raw data or encoded messages at other addresses, and the kernel can traverse those pointers manually like it does today. You&#x27;d still get the benefit of automatic marshalling for the majority of structs and fields.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829502/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829707"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2020 16:50 UTC (Thu)
                               by <b>esemwy</b> (guest, #83963)
                              [<a href="/Articles/829707/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Anybody remember VMS?  DEC solved this by passing arguments by *descriptor*, which was a self describing array of parameters. Given how often the syscall vs kernel feature mismatch comes up, it seems it wasn’t such a weird idea after all. <br>
<p>
<a href="http://h30266.www3.hpe.com/odl/axpos/opsys/vmsos84/5841/5841pro_053.html#arg_bydescriptor_sec">http://h30266.www3.hpe.com/odl/axpos/opsys/vmsos84/5841/5...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829707/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor829336"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 21, 2020 22:59 UTC (Fri)
                               by <b>chris_se</b> (subscriber, #99706)
                              [<a href="/Articles/829336/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A couple of years or so ago I had to write some portable code (Windows, macOS, Linux) to figure out the number of physical CPU cores in the system (in order to provide the user with a sane default for the number of processing threads for a workload that doesn&#x27;t jive well with hyperthreading/SMT). This was near-trivial on macOS/Windows, but a plain awful experience on Linux.<br>
<p>
macOS: 1 direct system call, 5 LOC with error handling<br>
Windows: 2 low-level API calls (that probably translate directly into system calls? not sure) + some struct processing in a loop, 12 LOC with error handling<br>
<p>
Linux: have to parse /sys/devices/system/cpu/cpuX/topology/thread_siblings_list, X starting at 0, as well as checking /sys/devices/system/cpu/cpuX/online to see whether the core was actually active. I wrote my first implementation on an Intel system, where the siblings list of a 2-core system with hyperthreading would be {&quot;0,2&quot;, &quot;1,3&quot;, &quot;0,2&quot;, &quot;1,3&quot;}, because Intel puts all of their hyperthreaded cores _after_ all of the physical cores. Tried that a year later on an AMD system with SMT, and because AMD groups their cores differently, the contents are {&quot;0-1&quot;, &quot;0-1&quot;, &quot;2-3&quot;, &quot;2-3&quot;}. My code couldn&#x27;t interpret that because it didn&#x27;t consider the fact that the cores could be specified as ranges. So I had to go back and change it. Sure, if you read the documentation _really_ carefully there is an indication how to parse the format, so yeah, that was my fault. But in the end, my (now correct) implementation is &gt; 20 LOC just for parsing the thread_siblings_list file, not including the logic to actually obtain the result that I actually want. A simple system call to obtain information about the CPUs in the current system as some kind of struct would have made my life a _lot_ easier in that case.<br>
<p>
I have to do a lot of low-level OS programming on various OS on a daily basis -- and in general I like the Linux APIs a lot better than the APIs of most other operating systems -- but as soon as I have to parse or generate ASCII, I start to hate it with a vengeance. (Thankfully this is not the case for most things I have to do.) I consider the proposed fsinfo() system call interface to be VASTLY superior to any ASCII-based interface. The underlying user-space code would be a LOT less error-prone for me. For me as a user-space developer, I could see myself using the proposed fsinfo() call (with the structs) in the future to obtain some information about the filesystem, but unless I desperately needed a piece of information for some reason I would completely avoid this system call if it required me to parse an ASCII string. (Though, to be fair, I&#x27;m definitely not one of the people who is the main target of this functionality at all; for my software this currently falls more into the &quot;nice to have&quot; category.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829336/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829411"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2020 15:03 UTC (Sat)
                               by <b>vadim</b> (subscriber, #35271)
                              [<a href="/Articles/829411/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I concur with the desire for JSON or something similar.<br>
<p>
The worst thing about the text formats is that they are brittle. They&#x27;re prone to failure when some unexpected character sneaks in, to ad-hoc implementations that are based on a programmer looking at &#x27;cat /proc/whatever&#x27; and writing whatever comes to mind (&quot;oh, so this is a list with one entry per line, with elements separated by spaces&quot;) and to being inflexible for expansion (can you add anything to /proc/partitions and not break a lot of stuff?)<br>
<p>
The second worst is that different philosophies are being followed. <br>
<p>
/proc/swaps might as well be the output of a command like &#x27;df&#x27;<br>
<p>
/proc/meminfo is half-written for human consumption, with amounts in kB and aligned columns, and half written for machine consumption with obscure labels like &quot;Committed_AS&quot;.<br>
<p>
/proc/mounts is very machine oriented.<br>
<p>
Some files explicitly tell you the units (and it can be unclear whether another unit could ever be used). Some files have column names. Some like /proc/ioports have meaningful identation.<br>
<p>
Many are uncomfortable for machine parsing. Eg, in /proc/cpuinfo you get &quot;address sizes	: 39 bits physical, 48 bits virtual&quot;. -- you have to parse that comma, and it&#x27;s unclear whether a third thing could ever be there. Many files are lacking in unique identifiers, eg, my /proc/ioports has 3 levels of &quot;0000-0000 : pnp 00:00&quot;, one under another.<br>
<p>
I&#x27;m amazed that the computing industry is pretty old by now, we have plentiful RAM, storage and CPU power, and the issues of escaping data, representing arrays and trees, and allowing for adding extra info without breaking existing software are still with us, despite there being things like JSON that solve the vast majority of them.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829411/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829416"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2020 15:26 UTC (Sat)
                               by <b>dezgeg</b> (subscriber, #92243)
                              [<a href="/Articles/829416/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sadly JSON (and many other text formats these days) assume Unicode strings though, while for example mountinfo may contain non-Unicode data like pathnames. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829416/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2020 16:36 UTC (Sat)
                               by <b>zyga</b> (subscriber, #81533)
                              [<a href="/Articles/829421/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, is that a reason for all the ad-hoc formats? We could pass paths as byte arrays. In reality, most software will have issues with non-UTF8-friendly things anyway, because they may want to display it. It&#x27;s nice that open(2) does not complain but it&#x27;s pretty rubbish if no application can ever display that thing without &quot;here are some bytes&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 22, 2020 18:50 UTC (Sat)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/829423/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Realistically, if you want to pass raw bytes through a text-formatted thing, you should be using Base64 or something similar. This of course means that paths become unreadable to humans without decoding, but you could have a flag indicating whether a path has been escaped, and then only escape things that aren&#x27;t valid UTF-8. Alternatively, you could encode the &quot;bad bytes&quot; with \\x00 through \\xFF, which is valid in a JSON string (the backslash is escaped, so it&#x27;s &quot;just&quot; a backslash followed by three letters), but could be confused with a real filename (so you would need to invent further escaping for that case, as described in <a href="https://xkcd.com/1638/">https://xkcd.com/1638/</a>).<br>
<p>
Or, if you think letting people create files with ridiculous names was a bad idea to begin with, you could simply declare non-UTF-8 paths unsupported and spit out invalid JSON if the user tries to create one. Much userspace software already does something like that anyway (see for example Python 3&#x27;s surrogateescape hack). But then a lot of parsers will work just fine the vast majority of the time, and break on an obscure condition that the average engineer may not even realize is possible. So that&#x27;s probably not ideal...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829431"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2020 15:22 UTC (Sun)
                               by <b>abo</b> (subscriber, #77288)
                              [<a href="/Articles/829431/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <p>Surrogate escapes can be used to encode arbitrary bytes in JSON:</p>

(python)
<pre>
&gt;&gt;&gt; b = bytes(range(256))
&gt;&gt;&gt; u = b.decode("UTF-8", errors="surrogateescape")
&gt;&gt;&gt; import json
&gt;&gt;&gt; j = json.dumps(u)
&gt;&gt;&gt; uin = json.loads(j)
&gt;&gt;&gt; bin = uin.encode("UTF-8", errors="surrogateescape")
&gt;&gt;&gt; [n for n in bin]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]
&gt;&gt;&gt; bin == b
True
</pre>

<p>The JSON looks like this:</p>

<pre>
"\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f\udc80\udc81\udc82\udc83\udc84\udc85\udc86\udc87\udc88\udc89\udc8a\udc8b\udc8c\udc8d\udc8e\udc8f\udc90\udc91\udc92\udc93\udc94\udc95\udc96\udc97\udc98\udc99\udc9a\udc9b\udc9c\udc9d\udc9e\udc9f\udca0\udca1\udca2\udca3\udca4\udca5\udca6\udca7\udca8\udca9\udcaa\udcab\udcac\udcad\udcae\udcaf\udcb0\udcb1\udcb2\udcb3\udcb4\udcb5\udcb6\udcb7\udcb8\udcb9\udcba\udcbb\udcbc\udcbd\udcbe\udcbf\udcc0\udcc1\udcc2\udcc3\udcc4\udcc5\udcc6\udcc7\udcc8\udcc9\udcca\udccb\udccc\udccd\udcce\udccf\udcd0\udcd1\udcd2\udcd3\udcd4\udcd5\udcd6\udcd7\udcd8\udcd9\udcda\udcdb\udcdc\udcdd\udcde\udcdf\udce0\udce1\udce2\udce3\udce4\udce5\udce6\udce7\udce8\udce9\udcea\udceb\udcec\udced\udcee\udcef\udcf0\udcf1\udcf2\udcf3\udcf4\udcf5\udcf6\udcf7\udcf8\udcf9\udcfa\udcfb\udcfc\udcfd\udcfe\udcff"
</pre>
      
          <div class="CommentReplyButton">
            <form action="/Articles/829431/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829432"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2020 18:05 UTC (Sun)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/829432/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That goes against the interoperability recommendations of the JSON RFC, which says (<a href="https://tools.ietf.org/html/rfc8259#section-8.2">https://tools.ietf.org/html/rfc8259#section-8.2</a>):<br>
<p>
<font class="QuotedText">&gt; the ABNF in this specification allows member names and string values to contain bit sequences that cannot encode Unicode characters; for example, &quot;\uDEAD&quot; (a single unpaired UTF-16 surrogate).  Instances of this have been observed, for example, when a library truncates a UTF-16 string without checking whether the truncation split a surrogate pair.  The behavior of software that receives JSON texts containing such values is unpredictable; for example, implementations might return different values for the length of a string value or even suffer fatal runtime exceptions.</font><br>
<p>
so it seems a bad idea to rely on unpaired surrogates (like surrogateescape) if you&#x27;re choosing JSON specifically for its interoperability.<br>
<p>
Surely the simplest way to encode Linux&#x27;s 8-bit paths in JSON is to map the bytes 0x00..0xFF onto U+0000..U+00FF and then proceed as normal. When decoding, treat any element &gt;=U+0100 as a syntax error. That should be interoperable between all JSON implementations, and very easy to handle in both Unicode-aware and -unaware applications.<br>
<p>
If the application wants to display the path to a user, do a potentially-lossy UTF-8 decode in the UI layer, which is about the best you can ever do with Linux paths regardless of how they&#x27;re encoded for transport. For all non-display-related processing of paths (which I think is more common and more important than displaying paths), keep them in the simple lossless U+0000..U+00FF representation.<br>
<p>
(Windows&#x27; 16-bit paths are more complicated, if you want to handle them pedantically correctly: they can contain unpaired surrogates so you can&#x27;t simply interpret them as JSON-compatible Unicode strings. In that case it&#x27;s probably safer to treat them as binary data and encode with base64.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829432/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829435"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2020 19:08 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/829435/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Surely the simplest way to encode Linux&#x27;s 8-bit paths in JSON is to map the bytes 0x00..0xFF onto U+0000..U+00FF and then proceed as normal. When decoding, treat any element &gt;=U+0100 as a syntax error. That should be interoperable between all JSON implementations, and very easy to handle in both Unicode-aware and -unaware applications.</font><br>
<p>
So, basically, pretend we have LC_ALL=&quot;[whatever].ISO-8859-1&quot; at both ends, and then require userspace to clean up the mess if LC_ALL is actually set to a different value (which, on modern systems, is typically the case). The problem, of course, is that if you ever try to decode that JSON with a naive implementation, you will get mojibake since they will skip the &quot;clean up the mess&quot; step. So you still need non-naive implementations, which makes me wonder, why bother with JSON in the first place?<br>
<p>
<font class="QuotedText">&gt; If the application wants to display the path to a user, do a potentially-lossy UTF-8 decode in the UI layer, which is about the best you can ever do with Linux paths regardless of how they&#x27;re encoded for transport.</font><br>
<p>
Strictly, you should be consulting the locale information rather than just assuming UTF-8. UTF-8 is the most common encoding, but its use in pathnames is not required by any standard that I&#x27;m aware of. Now, you can&#x27;t use something too weird such as UTF-16 (null bytes not allowed), but legacy 8-bit encodings are very much legal and valid on some older systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829435/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829453"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2020 22:44 UTC (Sun)
                               by <b>shemminger</b> (subscriber, #5739)
                              [<a href="/Articles/829453/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Text interfaces to userspace are brittle (easily broken) and suck. If you look at some of the interface in /proc/net there are columns filled with zeros because some field existed in 2.2 and can never change.<br>
<p>
Message based interfaces like netlink are more slightly more difficult to program but offer opportunity for expansion.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829453/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor829456"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2020 4:51 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/829456/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In that case it&#x27;s probably safer to treat them as binary data and encode with base64</font><br>
<p>
In what endianness do you treat the incoming 16bit data? Big? Little? Native? Native is easy, but it means you need to know what the host system is before archiving the raw data. Little is easy, but then can be confusing in the raw data viewers (which could render backwards). BOM is ok? But you could also start a filename with a BOM and…blah.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829456/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829461"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2020 12:30 UTC (Mon)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/829461/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since this is about Windows, and Windows is always little-endian (except on Xbox 360, as far as I can tell), it seems obvious to use little-endian here. Since it&#x27;s not Unicode (it&#x27;s just an array of 16-bit values) there&#x27;s no reason to even think about BOMs. You&#x27;d simply take the LPCWSTR path (i.e. const wchar_t*, where sizeof(wchar_t)==2) which is used by the Win32 APIs, then cast to uint8_t* and base64-encode as normal. That seems easy.<br>
<p>
Most code that processes the path should treat it as an opaque blob or decode it to wchar_t*, and wouldn&#x27;t need to care about Unicode or surrogates etc.<br>
<p>
When you want to display the path to a user, you&#x27;d need to do a lossy UTF-16LE decode to get a real Unicode string to pass into your UI system. (Lossy because the path might contain unpaired surrogates which you can&#x27;t decode safely). (If you&#x27;re using the Win32 UI APIs, that decoding will probably happen implicitly inside the API implementation; otherwise you might need to do it in the application). The important thing is to avoid trying to decode into a real Unicode string in any context where the lossiness will cause worse than a cosmetic glitch. (So you shouldn&#x27;t try to store Windows paths directly in JSON, because interoperable JSON requires real Unicode strings, hence the base64 encoding.)<br>
<p>
(Linux is the same except 8-bit instead of 16-bit, and probably UTF-8 (or the user&#x27;s current locale, as NYKevin mentioned, though of course they might have files created under a different locale and there&#x27;s no way to be sure what they were meant to be) instead of almost always UTF-16LE, and you can encode arbitrary 8-bit strings as JSON strings much more easily than encoding arbitrary 16-bit strings (where you need base64 etc). On both platforms it&#x27;s a mistake to think that a path is simply an encoded Unicode string, and that you can decode/encode at the edge and do all your internal processing with Unicode.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829461/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829564"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2020 19:02 UTC (Tue)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/829564/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Most code that processes the path should treat it as an opaque blob or decode it to wchar_t*, and wouldn&#x27;t need to care about Unicode or surrogates etc.</font><br>
<p>
I agree that just stuffing paths into binary storage is the best solution. However, usually paths need displayed or the storage you&#x27;re using has a human caring about it at some point in its lifetime. Especially if you&#x27;re using a container format like JSON. It&#x27;s nice and all, but a way to store arbitrary binary data without having to figure out how to encode it so that it is Unicode safe would have been much appreciated. (No, BSON don&#x27;t fix this; they just change the window dressing from `{:&quot;&quot;,}` into type-and-length-prefixed fields or type-and-NUL-terminated sequences). CBOR has binary data, but then library support is more widely lacking.<br>
<p>
FWIW, I&#x27;ve spent a lot of time thinking about how to stuff paths into JSON: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1689r2.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829564/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829637"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2020 19:43 UTC (Wed)
                               by <b>unilynx</b> (guest, #114305)
                              [<a href="/Articles/829637/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I hope for a future where someone introduces a &#x27;sane-names&#x27; filesystem mount option, which will forbid the use of invalid UTF8, filenames starting with a dash or space, containing dollar signs, and all the other funny things that make processing filenames hard or dangerous. Spaces in filenames we probably have to live with.<br>
<p>
Distributions might slowly make that option the default for new systems, sysadmins can opt-in faster themselves, unless they really have to deal with those few applications (which will hopefully disappear or become obsolete fast) that really, really want to create weird filenames.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829637/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829655"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2020 4:48 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/829655/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Requiring valid UTF-8 is probably sensible for a new filesystem.<br>
Excluding end-of-line characters is probably justifiable too. (or any control char ... I don&#x27;t think we need TAB or DEL).<br>
Anything else is parochial.<br>
When I&#x27;m choosing a name to save my document from my GUI, why should I care about your inability to write safe shell scripts, or even have any understanding that &quot;the shell&quot; exists.<br>
It is bad enough that I cannot put a &#x27;/&#x27; in my file names, why would you prevent me using &#x27;$&#x27;??<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829655/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829895"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2020 11:29 UTC (Sat)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/829895/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We&#x27;re slowly getting there, the kernel has Unicode normalisation for filesystems at long last. I think we could live without ASCII control chars next, though I don&#x27;t agree that we should forbid filenames from containing strings that an average person at a regular keyboard could type. Computers are meant to serve people, not the other way around.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829895/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor829580"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2020 14:09 UTC (Wed)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/829580/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
JSON looks simple until you want to add a human-readable comment (syntax error), or escape some non-ASCII chars in text (utf-16 only), or even just shoot it out without counting and cleaning up trailing commas (syntax error).<br>
<p>
Anything that requires more than about half a kb of bash-builtins parsing code to deal with is too complicated, IMHO.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829580/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829635"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2020 19:36 UTC (Wed)
                               by <b>unilynx</b> (guest, #114305)
                              [<a href="/Articles/829635/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is what `jq` is for. It turns bash into a very capable automation environment around eg. AWS or digital ocean, as they ship with cli tools that give json output.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829635/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor829663"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2020 12:08 UTC (Thu)
                               by <b>zyga</b> (subscriber, #81533)
                              [<a href="/Articles/829663/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We are not talking about configuration files but about kernel-userspace interfaces. If you need comments, just describe it like any other data. It&#x27;s not something you will edit by hand. In addition, current syntax does not support comments so I don&#x27;t quite know if you are confusing this with something else or if I&#x27;m missing your point.<br>
<p>
As for parsing, please show me a correct /proc/self/mountinfo parser in shell. I&#x27;ll wait. As another poster commented, jq handles that for shell scripts in a single-line correct and simple manner. The moment we step out of custom formats the kernel forces on us, the moment we start to have really rich set of tools for processing data.<br>
<p>
And it doesn&#x27;t have to be JSON. It should just not be ad-hoc, per-file convention with custom, brittle parser.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829663/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829691"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2020 13:10 UTC (Thu)
                               by <b>kpfleming</b> (subscriber, #23250)
                              [<a href="/Articles/829691/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
YAML is a superset of JSON, using whitespace instead of  (most) punctuation to indicate structure, and it supports comments.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829691/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor829782"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2020 13:13 UTC (Fri)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/829782/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And if we could strip away things like type annotations, the umpteen ways of quoting text blocks (and other incidental possibilities without a complicated escape generator. Sure, you could call it YAML, but the only safe way to actually generate it with arbitrary data is to treat it like JSON because no one wants to write escape detectors for all of YAML&#x27;s arcane syntax features.<br>
<p>
Don&#x27;t forget that some parsers have baked in the extension proposals(!) in, so you have to pay attention to things like accidentally generating merge keys (&quot;&lt;&lt;&quot;).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/829782/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor829777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rethinking fsinfo()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 28, 2020 12:13 UTC (Fri)
                               by <b>mvdwege</b> (guest, #113583)
                              [<a href="/Articles/829777/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Best solution: discard the dogmatic adherence to 'it must be text'. If the primary consumer of the information is <em>not</em> a sysadmin at the console, use binary data and cut out the redundant parsing step.</p>
<p>Yes, 'everything is an ASCII stream' makes things easily readable for humans, and it is great if you have text tools to write ad-hoc parsers for it. The problem is that you <em>keep</em> writing ad-hoc parsers. A little more pragmatism on this old UNIX dogma would be appreciated.</p>
<p>I'm speaking as a sysadmin/developer who ran into this when I wanted to verify if my local MTA had successfully sent (aka received a 250 reply) an email. The only way to do that was to parse fscking syslog. In 2018. When tools like D-Bus notification already had existed for over a decade.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/829777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2020, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
