        <!DOCTYPE html>
        <html lang="en">
        <head><title>Smart pointers for the kernel [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/992055/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/992719/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/992055/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Smart pointers for the kernel</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Daroc Alden</b><br>October 4, 2024</br>
           <hr>
<a href="https://lwn.net/Articles/990496/">Kangrejos 2024</a>
</div>
<p>
Rust has a plethora of smart-pointer types, including reference-counted
pointers, which have special support in the compiler to make them
easier to use. The Rust-for-Linux project would like to reap those same benefits
for its smart pointers, which need to be written by hand to conform to
the
<a href="/Articles/718628/">
Linux kernel
memory model</a>. Xiangfei Ding
presented at Kangrejos about the work to enable custom
smart pointers to function the same as built-in smart pointers.
</p>

<p>
Ding showed the specific "superpowers" that built-in smart pointers have in his
<a href="https://kangrejos.com/2024/SmartPointer%20and%20PinCoerceUnsized.pdf">
slides</a>:
unsizing and dynamic dispatch. Unsizing allows the programmer
to remove the length of an array behind a pointer from its type,
turning
a <tt>Ptr&lt;[T; N]&gt;</tt> (bounds-checked at compile time) into a
<tt>Ptr&lt;[T]&gt;</tt> (bounds-checked at run time). This needs special support because slices
(values of type <tt>[T]</tt>) do not have a known size at compile time; therefore the compiler
needs to store the size somewhere at run time. The compiler could store the size
in the pointed-to allocation, but that would require reallocating the array's
memory, which would be expensive. Instead, the compiler stores the size
alongside the pointer itself, as a fat pointer. On nightly Rust compilers, users
can enable an experimental feature and then have their
pointer type implement
<a href="https://doc.rust-lang.org/std/ops/trait.CoerceUnsized.html"><tt>CoerceUnsized</tt></a>
to indicate that it supports that.
</p>

<a href="/Articles/992336">
<img src="https://static.lwn.net/images/2024/xiangfei-ding-small.png" class="lthumb"
alt="[Xiangfei Ding]" title="Xiangfei Ding" />
</a>

<p>
The second superpower is called
<a href="https://doc.rust-lang.org/std/ops/trait.DispatchFromDyn.html"><tt>DispatchFromDyn</tt></a>
and allows converting a <tt>Ptr&lt;T&gt;</tt> into a <tt>Ptr&lt;dyn
Trait&gt;</tt> when <tt>T</tt> implements <tt>Trait</tt>. This has to do with
the way that Rust implements dynamic dispatch — a value of type <tt>Ptr&lt;dyn
Trait&gt;</tt> uses a dispatch table to find the implementation of the method
being invoked at run time.
That method expects to receive a <tt>self</tt> pointer. So converting a smart
pointer to use dynamic dispatch only works when the smart pointer can be used as
a <tt>self</tt> pointer.
</p>

<p>
These features are both experimental, because the Rust project is still working
on their design. Ding explained that there is an
<a href="https://rust-lang.github.io/rfcs/3621-derive-smart-pointer.html">
RFC</a> aimed at stabilizing just enough for the Linux kernel to use, without
impeding the development of the features. The RFC would add a new macro
that makes it trivial for
a smart pointer satisfying certain requirements to implement the
necessary traits, no matter what the final forms of the traits end up looking
like. That would let the kernel start using its custom smart pointers on stable
Rust sooner rather than later.
</p>

<p>
There is one catch — implementing these features for a smart-pointer type with a
malicious or broken
<a href="https://doc.rust-lang.org/std/ops/trait.Deref.html">
<tt>Deref</tt></a> (the trait that lets a programmer dereference a value)
implementation could break the guarantees
Rust relies on to determine when objects can be moved in memory.
This is of particular importance to
<a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><tt>Pin</tt></a>,
which is a wrapper type used to mark an allocation that cannot be moved.
It's not hard to write smart-pointer types that don't cause problems,
but in keeping with Rust's
commitment to ensuring safe code cannot cause memory-safety problems, the RFC
also requires programmers to use unsafe (specifically, implementing an
<tt>unsafe</tt>
<a href="https://users.rust-lang.org/t/understanding-the-marker-traits/75625/3">
marker trait</a>) as a promise that
they've read the relevant documentation and are not going to break <tt>Pin</tt>.
With that addition, the code for a smart-pointer type would look like this:
</p>

<pre>
    // Use Ding's macro ...
    #[derive(SmartPointer)]
    // On a struct that is just a wrapper around a pointer
    #[repr(transparent)]
    struct MySmartPointer&lt;T: ?Sized&gt;(Box&lt;T&gt;);

    // Implement Deref, with whatever custom logic is needed
    impl&lt;T: ?Sized&gt; Deref for MySmartPointer&lt;T&gt; {
        type Target = T;
        fn deref(&amp;self) -&gt; &amp;T {
            ...
        }
    }

    // And then promise the compiler that the Deref implementation is okay to
    // use in conjunction with Pin:
    unsafe impl&lt;T: ?Sized&gt; PinCoerceUnsized for MySmartPointer&lt;T&gt; {}
</pre>

<p>
Andreas Hindborg asked for some clarification about why the marker trait is
needed. <tt>Deref</tt>
is supposed to be simple, Ding explained. Usually, someone writing a
smart-pointer type would have a normal pointer stored in their type; when implementing
<tt>Deref</tt>, they can just use the normal pointer. But it's technically
possible to implement something more complicated than that. In this case, you
could have a <tt>Deref</tt> implementation that actually moves data out of the
object pointed to and stores something else there. This would not normally be a problem,
except when the smart pointer is contained in a <tt>Pin</tt>, which is supposed
to prevent the value from being moved. If the <tt>Deref</tt> implementation
moves the value anyway, then that would be undefined behavior. The unsafe marker
trait is a promise to the compiler that the programmer has not done that.
</p>

<!-- middle-ad -->

<p>
The new macro is available on nightly Rust, although Ding says that it needs a
bit more testing in order to stabilize, as well as some additional documentation
which he is working on. Miguel Ojeda asked how soon the macro might be
stabilized; Ding answered that it should be quite soon. He will make a
stabilization report shortly, and then it is just a matter of checking off the
requirements.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Kangrejos-2024">Kangrejos/2024</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/992055/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor993042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unsafe</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 5, 2024 16:11 UTC (Sat)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/993042/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm glad to see this requires the unsafe marker upholding Rust's principles here.<br>
<p>
I implement Deref and DerefMut for misfortunate::Double which (the whole point of the misfortunate crate) does something that's legal in safe Rust but is probably not what you wanted. in this case although dereferencing a Double&lt;T&gt; gets you access to a T, *mutably* dereferencing it gets you a different T! There are two inside it (hence the name) but they appear to be singular from outside.<br>
<p>
I don't know whether it would be safe for this to have the marker or not, but because it's unsafe I know I can just not implement it and never need to know.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unsafe</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2024 15:13 UTC (Sun)
                               by <b>daroc</b> (editor, #160859)
                              [<a href="/Articles/993069/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Although I'm not familiar with misfortunate::Double, that sounds like a central example of a type that is not safe to do these conversions on.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Unsafe</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2024 0:25 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/993211/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's not possible (at compile-time) to do these coercions on Double, because the unsizing coercion is only legal for types that are layout-identical to a single raw pointer. More prosaically, Double does not allow T: ?Sized, so it wouldn't be possible even if it were possible.<br>
<p>
But if neither of those issues were present, this would be entirely fine since Double::swap() takes a &amp;mut self parameter, and you only violate this invariant if you re-seat the pointer without calling such a method. Pin does not allow borrowing either the pointer or the pointee mutably (unless the pointee is Unpin), so it would prevent you from calling swap(), and everything would be entirely sound.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor993054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2024 7:54 UTC (Sun)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/993054/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
… and that's the difference between Rust and C, right here.<br>
<p>
With Rust you add funky semi-comprehensible macros to your classes to tell the compiler which invariants your class and/or pointers to its members requires (and obeys). You don't do that? people will have problems using your class.<br>
<p>
With C you write simple and legible code (or what looks like such) and document the invariants in comments or documentation (or not). Your users can walk right over them and nobody cares — until the kernel BUGs on you, that is. Or worse.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2024 13:38 UTC (Sun)
                               by <b>tux3</b> (subscriber, #101245)
                              [<a href="/Articles/993062/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would nitpick that the culture of annotating invariants in comment or documentation is certainly something I'd like to see more on the C side. Methinks we'd need a lot less tooling enforcement if people always diligently thought about (and documented!) all the important invariants their API expects.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993081"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2024 21:11 UTC (Sun)
                               by <b>kleptog</b> (subscriber, #1183)
                              [<a href="/Articles/993081/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The main problem with documenting API invariants via comments is that they'll be wrong after the first refactor. Unless there's a process to actually validate them, they're almost certainly going to be wrong fairly quickly.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993081/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2024 16:42 UTC (Mon)
                               by <b>carlosrodfern</b> (subscriber, #166486)
                              [<a href="/Articles/993189/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is so true in the company environment with the time pressure. The company puts deadlines over excellency in many cases and it is satisfied with a "good enough" code quality. However, in the Open Source projects, if there is no time pressure (and usually there isn't), you can take your time to get it as perfect as you want, and demand that from your contributors. It depends a lot on the main maintainer's perspective on code quality discipline. In the case of Linux, they have Linus, and he has done a great job communicating the culture of excellency over deadlines. However, once the key individual of a project leaves or changes code quality perspective, there is a high risk of things "relaxing" and falling apart.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993193"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Documented invariants versus invariants in code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2024 17:59 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/993193/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>The bigger problem, IME, is not time, but actually recognising that you've changed something relevant. In that regard, documentation and comments (including Rust safety comments) are the worst possible way to deal with an API invariant, since there's not even a guarantee that the wording of the comment will be consistent enough to be usefully greppable.
<p>The ideal is always type-level checking of your invariants, because that check stops you making mistakes. The next best thing is what this proposal does with <tt>unsafe impl</tt>, where users get the invariant type-checked (so I can remove the <tt>unsafe impl</tt> if it's wrong, and find all the places that need fixing), and where it's not hard to write a tool that will definitely find all the places that need manual checks.
<p>The worst case is a situation where code at the point of use says something like "relies on the fact that foo does not move its contents, ever" in a comment, so that when someone refactors FooPtr, they've got to review all users of FooPtr to discover that the "foo" in the comment refers to something of type FooPtr.


      
          <div class="CommentReplyButton">
            <form action="/Articles/993193/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Documented invariants versus invariants in code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2024 23:51 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/993205/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The "good" news is that, in this particular case, it would be quite perverse to define an object that violates this invariant. The vast majority of reasonable smart pointers are fully compliant and can just opt into it without further thought. It is only a problem if you (in the smart pointer implementation) change what object you're pointing to, the objects have different fat pointer metadata (vtable or slice size), and you make this change without any &amp;mut self method being called. Nobody does that combination of things, because it's obviously crazy to re-seat a pointer (smart or dumb) without counting that as a mutation of the pointer.<br>
<p>
Even misfortunate does not do it (at time of writing): Double does not specify T: ?Sized so you can't put a fat pointer into it (although I suspect that's merely an oversight rather than an intentional decision), and Double::swap() is a &amp;mut self method, so even if T could be unsized, swap() counts as a modification of the pointer anyway.<br>
<p>
In order to violate this invariant, you'd need to be doing something really ridiculous, like modifying the raw pointer value through a Cell&lt;T&gt; (not a Mutex&lt;T&gt;, since the whole smart pointer has to have the same layout as a raw pointer for this unsizing coercion to be possible in the first place), or using mem::transmute() to replace the raw pointer's vtable with a different one (not UB if the concrete types are layout-compatible).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993501"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Documented invariants versus invariants in code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2024 20:22 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/993501/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; and you make this change without any &amp;mut self method being called.</span><br>
<p>
Self-nitpicking: This should read "any &amp;mut self method other than DerefMut::deref_mut()." But that's still a ridiculous thing to do, because deref_mut() is the method that overrides the * (dereference) operator for write operations, so if you have it re-seat the pointer, you'd be causing code like *foo = bar to change what address ("place" in Rust's formal terminology) foo points at. Nobody who writes *foo = bar expects something like that to happen.<br>
<p>
At this point, I imagine that C++ programmers will object that, even though this operation should not change the address of the pointee, it could change the object's dynamic type. This is sort of true in C++ (objects may change dynamic type during construction, so when the object is copy-constructed, it could temporarily have a different dynamic type from bar, and you can interact with it through foo during this time), but not true at all in Rust (vtables are not even part of the object representation in the first place, they are statically allocated and tracked by fat pointers, so there is no plausible mechanism for modifying an object's dynamic type, nor is it possible to interact with partially-constructed objects through safe Rust).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993501/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor993928"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Documented invariants versus invariants in code</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2024 20:06 UTC (Sun)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/993928/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In the days since reading this comment I've been trying to figure out a suitably nefarious new misfortunate type which meets this requirement but I didn't succeed so far, maybe I'm missing a trick (although I did make one new "smart pointer" type that is fairly silly but it's still Sized because it requires Default)<br>
<p>
In the event you find yourself writing such a type please let me know, I'm named tialaramex most places - including Google's "Gmail" of course.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993928/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor993327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2024 18:04 UTC (Tue)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/993327/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's true even in teams that take things seriously and require at least two approvals before things get merged so that issues like this are exposed to more eyeballs  - and with no time pressure to boot. In my experience, a programmer's brain gets trained to "unsee" comments as irrelevant filler. They are just invisible. How can you keep them in sync if your brain thinks they don't exist?<br>
<p>
That said, the claim was that comments documenting invariants have value. They do, but only because you cannot do it in the programming language itself. How can you put faith in proofs in an unspecified language that the compiler doesn't even look at?<br>
<p>
Use a language in which you don't have to do it most of the time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993368"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2024 8:37 UTC (Wed)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/993368/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; In my experience, a programmer's brain gets trained to "unsee" comments as irrelevant filler. They are just invisible. How can you keep them in sync if your brain thinks they don't exist?</span><br>
<p>
That is a good point, essentially you can never rely on them when trying to understand the code because they might be outdated but you would always have to read them when modifying the code to see if they need to be updated. That is a very unlikely combination of behaviors to develop naturally.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993368/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor993911"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2024 13:41 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/993911/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; In my experience, a programmer's brain gets trained to "unsee" comments as irrelevant filler.</span><br>
<p>
Sounds like a bad habit to me. I find comments to be very helpful in both development and review. A recent example: <a href="https://gitlab.kitware.com/utils/ghostflow-director/-/merge_requests/398/diffs">https://gitlab.kitware.com/utils/ghostflow-director/-/mer...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993911/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2024 13:57 UTC (Sun)
                               by <b>pizza</b> (subscriber, #46)
                              [<a href="/Articles/993914/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Sounds like a bad habit to me. I find comments to be very helpful in both development and review. </span><br>
<p>
So I take it you've never had to review (or otherwise work with/consume) external/third party code?<br>
<p>
In my experience, comments are rarely helpful, and more often than not, actively harmful to your understanding of what the code _actually_ does.  (As opposed to what was intended at the time the comments were written).<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2024 20:08 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/993929/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sure, I've dug through third party code. The comments may be *bad*, but I still have to read them to know that. *Ignoring* them means also being unaware of the (or at least "an") *intent* of the code (regardless of its implementation quality).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor994860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 21, 2024 9:09 UTC (Mon)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/994860/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Sounds like a bad habit to me. I find comments to be very helpful in both development and review.</span><br>
<p>
I'm not saying this is a *good* thing :) It just happens, at least in my brain, when tracing the code itself. I remember to look at the comments only when I'm confused, baffled, or otherwise can't figure out why it does what it does.<br>
<p>
On the other hand, I only *add* comments when I know the code may be confusing for the reader. (This includes me, a month from now.) For example, there was a bug and the fix required some unexpected or counter-intuitive condition(s). Other than that the code should be "obvious" and in code like that comments are unnecessary at best, harmful at worst.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/994860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor994864"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 21, 2024 12:29 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/994864/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The code I linked is "obvious" from an algorithm viewpoint (grab some info from the code submission, traverse a graph from the configuration while collecting visited nodes, and finally do a set intersection). The *why* is probably completely lost without the comments. I find this is more useful in high-level code where the data has far more meaning baked into them (i.e., there is far more meaning attached to the strings than just the names themselves here) than at the "implement a set intersection" level where the data elements' relevant properties end at "have a mechanism to compare equality".<br>
<p>
FWIW, I add comments as I code if I'm building up the algorithm from scratch or (as in this case) when I'm self-reviewing the code before merging (I think I added these even before I opened the initial MR).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/994864/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor994870"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 21, 2024 13:59 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/994870/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Okay, this dates from my Fortran days, but I try to code in blocks of at most one screen. These *may* warrant a short description of what the block is meant to achieve. Preferably a couple of lines, so it's a block description of a block of code.<br>
<p>
The individual lines of code should be self explanatory, but especially when they are "elegant" (my word for "obvious once you know what it's doing") or convoluted, they may warrant a short one-liner.<br>
<p>
Two different types of comment, for two different scenarios, shame many languages don't allow you to differentiate. This is where C(++)s' "/* */" and "//" are actually very good, as you can differentiate between the two.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/994870/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor993078"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2024 21:17 UTC (Sun)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/993078/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are a lot of invarants that are almost always true and that people don't realize they're assuming, especially ones which require that two variables of the same type don't have the same value. For example, git's strbuf_addstr() assumes that the string you're adding isn't the buf of the strbuf you're adding it to. Any other string works, and there's a function that adds a strbuf to another strbuf that works for this case (and is more efficient in all cases), but there's nothing pointing out that this one operation that practically nobody would want to do is actually unsafe, and it's probably not better to consume programmers' attention making sure they know about it, since they're much less likely to make this mistake than all sorts of other mistakes, but it would be good if the compiler could point out the issue if they actually violate it. For that matter, the author of the strbuf_addstr() function probably didn't consider the possibility that the string to add might be the same memory as the one being reallocated to make space. To be certain to avoid unlikely issues, the compiler would have to tell the library author to include an annotation of an obscure invariant that the compiler should tell users of, if they ever violate it.<br>
<p>
C assumes that nobody will ever make that mistake (and it's probably right), whereas Rust wants to be sure that they can't make it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993078/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor994669"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2024 6:00 UTC (Fri)
                               by <b>blackfire</b> (guest, #92738)
                              [<a href="/Articles/994669/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; C assumes that nobody will ever make that mistake (and it's probably right), whereas Rust wants to be sure that they can't make it.</span><br>
<p>
And it's actually trivial enough in this case. See a sample StrBuf in the Rust playground: <a rel="nofollow" href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a9cfbe706385bb3e83df9ca7b9d504e8">https://play.rust-lang.org/?version=stable&amp;mode=debug...</a><br>
<p>
Uncommenting the one commented line (which would lead to the bug you mention) will cause a compile error. The `append` method takes a mutable reference to `self` (the object it's modifying) and an immutable reference to the bytes it's about to append.<br>
<p>
The catch is you cannot have both a mutable and immutable reference to the same object, so there's no way trying to append a buf to itself would work (except `unsafe`, but if you use it to violate the "aliased xor mutable" rule, it's insta-UB anyway).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/994669/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor994670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2024 6:13 UTC (Fri)
                               by <b>mb</b> (subscriber, #50428)
                              [<a href="/Articles/994670/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;except `unsafe`, but if you use it to violate the "aliased xor mutable" rule, it's insta-UB anyway)</span><br>
<p>
Hm, are you sure that just having two aliasing nonconst raw pointers is insta-UB?<br>
That doesn't look right to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/994670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor994673"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2024 7:56 UTC (Fri)
                               by <b>blackfire</b> (guest, #92738)
                              [<a href="/Articles/994673/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Hm, are you sure that just having two aliasing nonconst raw pointers is insta-UB?</span><br>
<span class="QuotedText">&gt; That doesn't look right to me.</span><br>
<p>
Having multiple raw pointers (const or not) is fine, having multiple mut references (or one mut and 1+ const) is UB, even without dereferencing any of them.<br>
<p>
(this is made mildly more complex by stacked borrows but that's the gist and honestly I don't claim to fully understand the intricacies of the model, but you do have to watch out for UB any time you make a reference from a raw pointer)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/994673/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor993210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust vs. C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2024 0:26 UTC (Tue)
                               by <b>gerdesj</b> (subscriber, #5446)
                              [<a href="/Articles/993210/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"… and that's the difference between Rust and C, right here."<br>
<p>
My takeaway from this article is that both camps are (begrudgingly) listening to each other.<br>
<p>
As a civilian, I don't really give a shit about the rights and wrongs of a programming paradigm or whatever wankery is in the ascendant today.  I am persuaded that C and Rust are both serious ways of generating machine code to run on my CPUs 'n that. <br>
<p>
What I do like to see is gangs of serious engineers getting to grips with novel ideas and gradually thrashing out the best (for a given value of best) way forwards.<br>
<p>
In the end its all about the engineering.  Unless you are writing raw machine code, you need Assembly, C or Rust or whatevs to get stuff done ... err make stuff happen.  Do remember that in the end you are generating machine code that does something - that's the goal.  How you get there is a "journey" and that is up to you.<br>
<p>
My laptop does not "run" C or Rust.  It runs machine code and that's all.  Please ensure it runs the best machine code available, however you get it there!  I will be forever grateful for that. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor993829"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Smart pointers and memory models</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2024 18:41 UTC (Fri)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/993829/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      I'm trying to understand the reference to the Linux kernel memory model here. Here's my very limited understanding so far and I'd appreciate corrections:
<p>
<ul>
<li>The Rust standard library type <code>Arc&lt;T&gt;</code> (atomically reference-counted pointer to <code>T</code> uses the atomic support in the Rust standard library for the refcount, and there's some particular implementation of those.</li>
<li>The Linux kernel might want to use a different implementation of atomics (concretely, maybe different assembly instructions, maybe adding barriers) than the Rust standard library uses. In particular, if Rust code and C code are modifying the same atomic, they need to use compatible instructions.</li>
<li><code>Arc</code> (and <code>Rc</code> and a few other standard library pointer-wrapping types) have the ability that, if they hold a two-word "fat pointer", you can use them in contexts where you need a normal pointer and you know you don't need the metadata (e.g., because you're calling a method from the vtable, and that method was compiled knowing what type it's being called on) by just casting (transmuting) the type of the smart pointer and ignoring the second word.</li>
<li>This functionality is implemented by these types implementing some unstable marker traits, which they can do because they're in the standard library. Apart from the correctness things described in the article, the other important thing these traits do is promise that this cast is valid and that e.g. <code>Rc&lt;[u8; 10]&gt;</code> is the first few bytes of <code>Rc&lt;[u8]&gt;</code>.</li>
<li>The kernel wants a refcounted type with this same ability.</li>
<li>So the Rust team is adding a derive annotation that implements these traits (instead of exposing the traits themselves, whose API they're not ready to commit to) that requires that anything you derive the trait on is a <code>#[repr(transparent)]</code> wrapper around something in the standard library that is marked as implementing those traits (a raw pointer is one of these), which guarantees the layout trick.</li>
</ul>
<p>
I think the part I don't understand is the relevance of interop between Rust and C. Is there any case where Rust and C are modifying the same atomic variable? Is the kernel's implementation of <code>Arc</code> (or <code>ListArc</code>) intended to be layout-compatible with any existing C code in the kernel? It seems like "We want to leak on overflow instead of panicking" and "We need the intrusive linked list support because that is a useful design in kernelspace" by itself justify this, and the different memory model doesn't come into play. What goes wrong if Rust types use Rust atomics and C types use kernel atomics?
<p>
Maybe put another way, if the standard library gained <code>SaturatingArc&lt;T&gt;</code> and an appropriate intrusive linked list type, which seem like not unreasonable things for everyone to have, would those suffice? (To be clear, I'm not actually suggesting this instead of the current approach, just asking it as a hypothetical for my understanding.)
<p>
For that matter, why are Rust atomics and LKMM atomics different? I'm vaguely familiar with the fact that (e.g.) Alpha does things with memory ordering that people don't expect and so you need more barriers than your same code would need on other architectures, and so the kernel does emit those barriers on Alpha. But wouldn't this apply to <i>all</i> code on Alpha, and thus wouldn't Rust want to handle atomics in the same way? Why is there not one obvious correct way for anyone to implement an atomic reference count on a given architecture?






      
          <div class="CommentReplyButton">
            <form action="/Articles/993829/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993835"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Smart pointers and memory models</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2024 19:01 UTC (Fri)
                               by <b>daroc</b> (editor, #160859)
                              [<a href="/Articles/993835/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>
That is an excellent summary of the talk. As to why the LKMM is relevant — the LKMM doesn't just say things about how to write to atomic variables, it also has guarantees about how those writes interact with other constructs like threads. Boqun Feng actually had a neat talk that gave more detail about this later in the day that I'm still in the process of writing up. But one example is that if one thread writes to an atomic variable and then wakes another thread, the LKMM says that second thread is guaranteed to see the write. Rust atomics don't make that guarantee. Does that discrepancy cause problems? Maybe. At the very least, it's an extra complication to think about. Writing correct multithreaded code is hard enough; there's no reason to make it harder by having two conflicting models.
</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/993835/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor993842"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Smart pointers and memory models</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2024 20:44 UTC (Fri)
                               by <b>geofft</b> (subscriber, #59789)
                              [<a href="/Articles/993842/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, thanks, that specific discrepancy is the sort of thing I was curious about, thanks! I will look forward to the writeup.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/993842/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor993837"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Smart pointers and memory models</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 11, 2024 19:12 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/993837/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Rust atomics exactly match the memory model defined for C11, but with <tt>memory_order_consume</tt> (which no compiler benefited from, last I checked - all implementations I've seen treat it as a weird spelling of <tt>memory_order_acquire</tt>) removed completely.
<p>The LKMM predates C11 by quite some time, and has different rules about what <i>happens-before</i> and <i>synchronizes-with</i> relationships are established by the various atomic operations you can do. As a result, something needs to make sure that when Rust code accesses atomics that are shared with C, the LKMM rules are followed, and not the C11 rules; if everything just followed the C11 rules, then the kernel code that assumes LKMM would be broken (although I believe that if everything follows the LKMM rules, code that assumes C11 rules will still work).
<p>And Rust code will eventually need to modify atomics shared with C, because some of the existing kernel data structures depend on atomic modifications.


      
          <div class="CommentReplyButton">
            <form action="/Articles/993837/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor994672"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Smart pointers and memory models</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 18, 2024 6:28 UTC (Fri)
                               by <b>westurner</b> (guest, #145208)
                              [<a href="/Articles/994672/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FWIW e.g. Apache Arrow is zero copy with C, CFFI, C++, Java, Python, and Rust APIs:<br>
<p>
[Memory and IO Interfaces — Apache Arrow v17.0.0](<a rel="nofollow" href="https://arrow.apache.org/docs/python/memory.html#memory-pools">https://arrow.apache.org/docs/python/memory.html#memory-p...</a>)<br>
<p>
<span class="QuotedText">&gt; External memory, under the form of a raw pointer and size, can also be referenced using the foreign_buffer() function.</span><br>
<p>
pyarrow.foreign_buffer(address, size, base=None)  <br>
<a rel="nofollow" href="https://arrow.apache.org/docs/python/generated/pyarrow.foreign_buffer.html#pyarrow.foreign_buffer">https://arrow.apache.org/docs/python/generated/pyarrow.fo...</a> :<br>
<p>
<span class="QuotedText">&gt; base: Object that owns the referenced memory.</span><br>
<p>
<span class="QuotedText">&gt; The buffer will be optionally backed by the Python base object, if given. The base object will be kept alive as long as this buffer is alive, including across language boundaries (for example if the buffer is referenced by C++ code)</span><br>
<p>
The Arrow Parquet docs mention that parquet must be reshaped when reading and writing from disk.<br>
<p>
Feather (Arrow IPC) format is the same shape on disk as in RAM, with ZSTD or LZ4 compression by default.<br>
<p>
<p>
serde.rs supports very many serialization formats for rust, including Python pickles and CSV and JSON and so on.<br>
<p>
lancedb also does zero-copy with Rust and Arrow: <a rel="nofollow" href="https://lancedb.github.io/lancedb/#why-use-lancedb">https://lancedb.github.io/lancedb/#why-use-lancedb</a> :<br>
<p>
<span class="QuotedText">&gt; Tight integration with the Arrow ecosystem, allowing true zero-copy access in shared memory with SIMD and GPU acceleration</span><br>
<p>
arrow-ipc-bench compares Flight, Plasma (*), sharedmemory with MacOS, IIRC: <br>
<a rel="nofollow" href="https://github.com/wjones127/arrow-ipc-bench/tree/main">https://github.com/wjones127/arrow-ipc-bench/tree/main</a><br>
<p>
Rust arrow_ipc::reader &gt; Struct StreamReader:<br>
<a rel="nofollow" href="https://docs.rs/arrow-ipc/53.1.0/arrow_ipc/reader/struct.StreamReader.html">https://docs.rs/arrow-ipc/53.1.0/arrow_ipc/reader/struct....</a><br>
<p>
Apache Arrow &gt; Serde.rs compatibility: <br>
<a rel="nofollow" href="https://docs.rs/arrow/latest/arrow/#serde-compatibility">https://docs.rs/arrow/latest/arrow/#serde-compatibility</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/994672/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor994776"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">reftrack-plugin</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 19, 2024 0:29 UTC (Sat)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/994776/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From the HN comments, a GCC plugin for C language that tracks references to allocated objects:<br>
<p>
<a href="https://github.com/acbits/reftrack-plugin">https://github.com/acbits/reftrack-plugin</a><br>
<a href="https://news.ycombinator.com/item?id=41875792">https://news.ycombinator.com/item?id=41875792</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/994776/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2024, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
