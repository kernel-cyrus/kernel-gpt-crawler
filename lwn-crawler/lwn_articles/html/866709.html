        <!DOCTYPE html>
        <html lang="en">
        <head><title>The Btrfs inode-number epic (part 2: solutions) [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/866709/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/866757/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/866709/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The Btrfs inode-number epic (part 2: solutions)</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we donâ€™t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>August 23, 2021</br>
           </div>
<a href="/Articles/866582/">The first installment</a> in this two-part
series looked at the difficulties that arise when Btrfs filesystems
containing subvolumes are exported via NFS.  Btrfs has a couple of quirks
that complicate life in this situation: the use of separate device numbers
for subvolumes and the lack of unique inode numbers across the filesystem
as a whole.  Recently, Neil Brown set off on an effort to try
to solve these problems, only to discover that the situation was even
more difficult than expected and that many attempts would be required.

<p>
<h4>Take 1: internal mounts</h4>
<p>
Brown's <a
href="/ml/linux-fsdevel/162742539595.32498.13687924366155737575.stgit@noble.brown/">first 
patch set</a> attempted to resolve these problems by creating the
concept of "internal mounts"; these would be automatically created by Btrfs
for each visible subvolume.  The automount mechanism is used to make those
mounts appear.  With a bit of tweaking, the kernel's NFS server daemon
(<tt>nfsd</tt>) can 
recognize these special mounts and allow them to be crossed without an
explicit mount on the remote side.  With this setup, the device numbers
shown by the system are as expected, and inode numbers are once again
unique within a given mount.
<p>
At a first glance, this patch set seemed like a good solution to the
problem.  When presented with a description of this approach back in July,
filesystem developer Christoph Hellwig <a
href="https://lore.kernel.org/linux-nfs/YPaCuGm+3RX6vzjp@infradead.org/">responded</a>:
"<q>This is what I've been asking for for years</q>".  With these
changes, Btrfs appears to be a bit less weird and some longstanding
problems are finally resolved.
<p>

This patch set quickly ran into trouble, though.  Al Viro <a
href="/ml/linux-fsdevel/YQNG+ivSssWNmY9O@zeniv-ca.linux.org.uk/">pointed
out</a> that the mechanism for querying device numbers could generate I/O
while holding a lock that does not allow for such actions, thus deadlocking
the system; without that query, though, the scheme for getting the device
number from the filesystem will not work.  One potential alternative,
providing a separate superblock for each internal mount that would contain
the needed information, is even worse.  Many operations in the kernel's
virtual filesystem layer involve iterating through the full list of mounted
superblocks; adding thousands of them for Btrfs subvolumes would create a
number of new performance problems that would take massive changes to fix.
<p>
Additionally,   Amir Goldstein <a
href="/ml/linux-fsdevel/CAOQ4uxj9DW2SHqWCMXy4oRdazbODMhtWeyvNsKJm__0fuuspyQ@mail.gmail.com/">noted</a>
that the new mount structure could create trouble for overlayfs; it would
also break some of his user-space tools.  There is also the little issue of
how all those internal mounts would show up in <tt>/proc/mounts</tt>; on
systems with large numbers of subvolumes, that would turn
<tt>/proc/mounts</tt> into a huge, unwieldy mess that could also expose the
names of otherwise private subvolumes.

<p>
<h4>Take 2: file handles</h4>
<p>
Brown <a
href="/ml/linux-fsdevel/162787790940.32159.14588617595952736785@noble.neil.brown.name/">concluded</a>
that "<q>with its current framing the problem is unsolvable</q>".
Specifically, the problem is the 64&nbsp;bits set aside for the inode
number, which are not enough for Btrfs even now.  The problem gets worse
with overlayfs, which must combine inode numbers from multiple filesystems,
yielding something that is necessarily larger than any one filesystem's
numbers.  Brown described the current solution in overlayfs as "<q>it
over-loads the high bits and hopes the filesystem doesn't use them</q>",
which seems less than fully ideal.  But, as long as inode numbers are
limited to any fixed size, there is no way around the problem, he said.
<p>
It would be better, he continued, to use the file handle provided by many
filesystems, primarily for use with NFS; a file's handle can be obtained
with <a
href="https://man7.org/linux/man-pages/man2/open_by_handle_at.2.html"><tt>name_to_handle_at()</tt></a>.
The handle is of arbitrary length, and it includes a generation number,
which handily gets around the problems of inode-number reuse when a file is
deleted.  If user space were to use handles rather than inode numbers to
check whether two files are the same, a lot of problems would go away.
<p>
Of course, some new problems would also materialize, mostly in the form of
the need to make a lot of changes to user-space interfaces and programs.
No files exported by the kernel (<tt>/proc</tt> files, for example) use
handles now, so a set of new files that included the handles would have to be created.
Any program that looks at inode numbers would have to be updated.  The
result would be a lot of broken user-space tools.  Brown has repeatedly <a
href="/ml/linux-fsdevel/162794157037.32159.9608382458264702109@noble.neil.brown.name/">insisted</a>
that breaking things may be possible (and necessary):
<p>
<blockquote class="bq">
	If you refuse to risk breaking anything, then you cannot make
	progress.  Providing people can choose when things break, and have
	advanced warning, they often cope remarkable well.
</blockquote>
<p>
Incompatible changes remain a hard sell, though.  Beyond that, to get
the full benefit from the change, Btrfs would have to be changed to stop
using artificial device numbers for subvolumes, which is not a small change
either.  And, as Viro <a
href="/ml/linux-fsdevel/YQeB3ASDyO0wSgL4@zeniv-ca.linux.org.uk/">pointed
out</a>, it is possible for two different file handles to refer to the same
file. 
<p>
In summary, this approach did not win the day either.
<p>
<h4>Take 3: mount options</h4>
<p>
Brown's <a
href="/ml/linux-fsdevel/162848123483.25823.15844774651164477866.stgit@noble.brown/">third
attempt</a> approached the problem from a different direction, making all
of the changes explicitly opt-in.  Specifically, he added two new mount
options for Btrfs filesystems that would change their behavior with regard
to inode and device numbers.
<p>
The first option, <tt>inumbits=</tt>, changes how inode numbers are
presented; the default value of zero causes the internal object ID to be
used (as is currently the case for Btrfs).  A non-zero value tells Btrfs to
generate inode numbers that are "<q>mostly unique</q>" and that fit
into the given number of bits.  Specifically, to generate the inode number
for a given object within a subvolume, Btrfs will:
<p>
<ul class="spacylist">
<li> Generate an "overlay" value from the subvolume number; this is done by
     byte-swapping the number so that the low-order bits (which vary the
     most between subvolumes) are in the most-significant bit positions.
<li> The overlay is right-shifted to fit within the number of bits
     specified by <tt>inumbits=</tt>.  If that number is&nbsp;64, no shift
     need be done.
<li> That overlay value is then XORed with the object number to
     produce the inode number presented to user space.
</ul>
<p>
The resulting inode numbers will still be unique within any given
subvolume; collisions within a large Btrfs filesystem can still happen, but
they are less likely than before.  Setting <tt>inumbits=64</tt> minimizes
the chances of duplicate inode numbers, but a lower number (such
as&nbsp;56) may make sense in situations (such as when overlayfs is in use)
where the top bits are used by other subsystems.
<p>
The second mount option is <tt>numdevs=</tt>; it controls how many device
numbers are used to represent subvolumes within the filesystem.  The
default value, <tt>numdevs=many</tt>, preserves the existing behavior of
allocating a separate device number for every subvolume.  Setting
<tt>numdevs=1</tt>, instead, causes a single device number to be used for
all subvolumes.  When a filesystem is mounted with this option, tools like
<tt>find</tt> and <tt>du</tt> will not be able to detect the crossing of a
subvolume boundary, so their options to stay within a single filesystem
may not work as expected.  It is also possible to specify
<tt>numdevs=2</tt>, which causes two device numbers to be used in an
alternating manner when moving from one subvolume to the next; this makes
tools like <tt>find</tt> work as expected.
<p>
Finally, this patch set also added the concept of a "tree ID" that can be
fetched with the <a
href="https://man7.org/linux/man-pages/man2/statx.2.html"><tt>statx()</tt>
system call</a>.  Btrfs would respond to that query with the subvolume ID,
which applications could then use to reliably determine whether two files
are contained within the same subvolume or not.
<p>
Btrfs developer Josef Bacik <a
href="/ml/linux-fsdevel/e6496956-0df3-6232-eecb-5209b28ca790@toxicpanda.com/">described</a>
this work as "<q>a step in the right direction</q>", but said that he
wants to see a solution that does not require special mount options.
"<q>Mount options are messy, and are just going to lead to distros
turning them on without understanding what's going on and then we have to
support them forever</q>".  A proper solution, he said, does not present
the possibility for users to make bad decisions.  He suggested just using
the new tree ID within <tt>nfsd</tt> to solve the NFS-specific problems,
generating new inode numbers itself if need be.
<p>
Brown <a
href="/ml/linux-fsdevel/162872000356.22261.854151210687377005@noble.neil.brown.name/">countered</a>
with a suggestion that, rather than adding mount options, he could just
create a new filesystem type ("<q>btrfs2 or maybe betrfs</q>") that
would use the new semantics.  Bacik <a
href="/ml/linux-fsdevel/6571d3fb-34ea-0f22-4fbe-995e5568e044@toxicpanda.com/">didn't
like that idea</a> either, though.  Brown  <a
href="/ml/linux-fsdevel/162880775121.15074.3288255136681201159@noble.neil.brown.name/">added</a>
that he would prefer not to do "<q>magic transformations</q>" of
Btrfs inode numbers in <tt>nfsd</tt>; if a filesystem requires such
operations, they should be done in the filesystem itself, he said.  He then asked
that the Btrfs developers make a decision on their preferred way to solve
this problem, but did not get an answer.
<p>
<h4>Take 4: the uniquifier</h4>
<p>
On August 13, Brown returned with <a
href="/ml/linux-fsdevel/162881913686.1695.12479588032010502384@noble.neil.brown.name/">a
minimal patch</a> aimed at solving the NFS problems that started this whole
discussion.  It enables a
filesystem to provide a "uniquifier" value associated with a file; this
value, the name of which is arguably better suited to a professional wrestler, is
only available within the kernel.  The NFS server can then 
XOR that value with the file's inode number to obtain a number
that is more likely to be unique.  Btrfs provides the overlay value
described above as this value; <tt>nfsd</tt> uses it, and the problem
(mostly) goes away.
<p>
Bacik <a
href="/ml/linux-fsdevel/ebffa324-0d42-4227-b162-0dad19144943@toxicpanda.com/">said</a>
that this approach was "<q>reasonable</q>" and acked it for the Btrfs
filesystem.  It thus looks like it could finally be a solution for the
problem at hand.  Or, at least, it's closer; Brown later <a
href="/ml/linux-fsdevel/162906585094.1695.15815972140753474778@noble.neil.brown.name/">realized</a>
that the changed inode numbers would create the dreaded "stale file handle"
errors on existing clients when the transition happens.  An <a
href="/ml/linux-fsdevel/162969155423.9892.18322100025025288277@noble.neil.brown.name/">updated
version of the patch set</a> adds a new flag in an unused byte of the NFS
file handle to mark "new-style" inode numbers and prevent this error from
occurring. 

<p>

The second revision of the fourth attempt may indeed be the charm that
makes some NFS-specific 
problems go away for Btrfs users.  It is hard not to see this change â€” an
internal process involving magic numbers that still is not guaranteed to
create unique inode numbers â€” as a bit of a hack, though.  Indeed, even
Brown <a
href="/ml/linux-fsdevel/162942971499.9892.4386273250573040668@noble.neil.brown.name/">referred
to</a> "<q>hacks to work around misfeatures in filesystems</q>" when
talking about this work.  Hacks, though, can be part of life when dealing
with production systems and large user bases; a cleaner and more correct
solution may not be possible without breaking user systems.  So the
uniquifier may be as good as things can get until some other problem is
severe enough to force the acceptance of a more disruptive solution.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems-Btrfs">Filesystems/Btrfs</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/866709/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor867159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2021 16:48 UTC (Mon)
                               by <b>jkingweb</b> (subscriber, #113039)
                              [<a href="/Articles/867159/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A fascinating series, indeed. Thank you for this, intrepid editor!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor867166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2021 18:15 UTC (Mon)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/867166/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why not to switch inode numbers to 128 bits? It is significantly less drastic than using handles while in practice is enough to use various random generators and hashes that can produce unique numbers on demand.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867167"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2021 18:23 UTC (Mon)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/867167/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn&#x27;t that need *another* `_LARGE_FILE_SUPPORT` macro detection round during software configuration to move? Or would it be a `statx`-only change? If so, how would `stat` be expected to expose this information via `ino_t`?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867167/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor867174"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2021 19:43 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/867174/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
64-bit inodes already give you room for ~18 quintillion inodes per filesystem. You do not actually need that many, or if you do, something has gone terribly wrong.<br>
<p>
Sure, you can throw more bits at the problem, but you&#x27;re just treating the symptoms. The real issue here is not &quot;we don&#x27;t have enough bits.&quot; It&#x27;s &quot;we can&#x27;t agree on exactly how those bits should be allocated.&quot; One possibility: btrfs might decide to have unique inodes over the whole filesystem, and that would likely be challenging but technically possible (for example, when you create a subvolume, you allocate a new 32-bit inode prefix to that subvolume, and whenever any subvolume runs out of inode numbers, you give it another 32-bit prefix - since each prefix contains ~4 billion inode numbers, this allocation should happen rather infrequently, and since there are ~4 billion possible prefix values, the large size of these allocations will not easily cause a shortage).<br>
<p>
But I doubt you can actually do that and still maintain on-disk compatibility with existing btrfs filesystems. Oh well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867174/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2021 22:43 UTC (Mon)
                               by <b>willy</b> (subscriber, #9762)
                              [<a href="/Articles/867187/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would go further. Allocate in groups of 2^16. That way we run out of space in a group frequently and test the &quot;allocate new prefix&quot; path every day instead of once every dozen years.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor867179"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2021 22:50 UTC (Mon)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/867179/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a variation on the swab64() strategy.  Unless I&#x27;ve missed something, it doesn&#x27;t require any on-disk format changes in most cases.  The NFS server can already do it now, so there&#x27;s no reason why btrfs couldn&#x27;t do it itself.  You&#x27;d use a mount option that says &quot;crush all my inodes into one 64-bit namespace&quot; and there would be a corresponding loss of maximum filesystem size/age.  Internally the filesystem would still use separate subvol and inode, so you could remove the mount option and get the old behavior again.<br>
<p>
If we know the highest-numbered subvol on the filesystem (which is a trivial tree lookup at mount time) and we use bit-swap instead of byte-swap, then we know which bits are subvol ID and which are inode (all bits that are not subvol ID are inode ID), so we have a nice pair of O(1) bidirectional conversion functions.  We can also know when subvol and inode might potentially collide (it&#x27;s not possible as long as the number of bits needed for the highest subvol ID and the highest inode do not total more than 64, but you probably want warnings around 56 or so).<br>
<p>
If you ran out of inode bits in a subvol then you&#x27;d need a lookup table to map a discontiguous range of inodes to subvols.  That table would require a disk format change, but most users will never occupy enough bits to need it (it will take decades, creating thousands of inodes every second and thousands of snapshots per day, to make the numbers bump).  It could be created lazily when the free bits run out, but if that takes 20 years to happen then that code isn&#x27;t going to be very well tested.<br>
<p>
Alternatively btrfs could in the future do garbage collection to free up old object ID numbers, i.e. start at the highest inodes and pack them into the lowest-numbered available inode slots, and stop when it had freed up enough top bits.  That wouldn&#x27;t require an on-disk format change, it would just be a maintenance task to run at regular intervals, say, once every 15 years.  This is roughly equivalent to creating an empty subvol and using &#x27;cp -a --reflink&#x27; to move the data into files with smaller inode numbers, so if you are in really dire straits you don&#x27;t need to wait for a special tool.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867179/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor868998"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2021 19:41 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/868998/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The real issue here is not &quot;we don&#x27;t have enough bits.&quot; It&#x27;s &quot;we can&#x27;t agree on exactly how those bits should be allocated.&quot;</font><br>
<p>
Another way of putting it: if you insist on stacking new bits on the front of an inode number for every new sort of thing that must be unique within a mount point (new btrfs subvolumes, new mount points within an NFS export, new this, new that), we can *never* have enough bits, because you can always add another layer of overlayfs or nfs exporting or whatever, and require more: and since most filesystems are using 64-bit inode numbers already, 64 bits is *never* enough to maintain guaranteed uniqueness in that space while adding more spaces as well on top.<br>
<p>
(What saves us and lets us use kludges like the one in this article without disaster is that 64-bit spaces are, indeed, so large that we can just assume it is almost entirely empty and we can just pick more numbers at random, as long as they&#x27;re not mostly-bits-zero or mostly-bits-1, and probably work nearly all the time, despite the birthday paradox. This is gross but probably good enough. I for one do not want a 128-bit ino_t flag day any time soon thankyouverymuch!)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868998/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor867256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 16:51 UTC (Tue)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/867256/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Everything seems to over time adopt UUIDs...<br>
<p>
It&#x27;d work in theory, but it&#x27;d be an amount of churn comparable to replacing 32-bit time_t, or IPv4 (even on a closed internal network that&#x27;s a Sisyphean task).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor867169"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2021 18:38 UTC (Mon)
                               by <b>martin.langhoff</b> (subscriber, #61417)
                              [<a href="/Articles/867169/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; an internal process involving magic numbers that still is not guaranteed to create unique inode numbers</font><br>
<p>
A tough tradeoff it seems. Questions...<br>
<p>
What&#x27;s the fallout if the inodes are not unique? Given that large modern systems can be really large, inode collisions might be just a fact of life.<br>
<p>
and...  the solution is an intermediate &quot;let&#x27;s limit the repercussions on other software&quot; solution. Sure. So then... _is there a clear correct way to check for unique inode that is sane, clear of collisions and portable (across filesystems)? <br>
<p>
In other words, if I was a maintainer of a deduplicator utility, or developing the next version of NFS, and I&#x27;m alert enough to be reading this article, is there a clear way to DTRT? <br>
<p>
While today we want to not break the world, we&#x27;re also building tomorrow...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867169/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867181"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2021 22:04 UTC (Mon)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/867181/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; What&#x27;s the fallout if the inodes are not unique?</font><br>
<p>
This is unknowable in general - it depends on exactly what assumptions various applications make.<br>
<p>
We know some specific problems.<br>
- if a directory has the same inode number as an ancestor, find/du etc will refuse to enter that directory.<br>
- if a &#x27;tar&#x27; archive is being created of a tree, and two *different* files both have multiple links and both have the same inode number, then the second one found will not be included in the archive (I *think* tar doesn&#x27;t track inode numbers for dirs or for objects with only one link).<br>
- Other tools that collect files, like rsync and cpio, will have similar problems.<br>
- various tools probably cache a dev/ino against a name, and if a subsequent stat shows that same dev/ino, they assume it is the same object.  So if a given name referred to two different inodes over time, which happen to have the same inode number, such tools would behave incorrectly. (all these are unlikely with my overlay scheme - this one more so than most).<br>
<p>
There are probably others.  However most code would never notice.<br>
<p>
<font class="QuotedText">&gt; So then... _is there a clear correct way to check for unique inode that is sane, clear of collisions and portable</font><br>
<p>
Probably not.  Even the current best-case behaviour of file-systems like ext4 does not provide the guarantees that I have described tar as requiring (it is possible I&#x27;ve misrepresented &#x27;tar&#x27; - I haven&#x27;t checked the code).<br>
The &quot;compare st_dev and st_ino&quot; approach is only completely reliable when you have both files open.  If you don&#x27;t, it is possible for the first file to be deleted after you &#x27;stat&#x27; it, and then for the second file to be created with the same inode number.<br>
Use of &quot;ctime&quot; or even &quot;btime&quot; where supported, would help here.<br>
So comparting dev, ino, and btime should be sufficient providing btime is supported.  Almost.<br>
Another possible (though unlikely) problem is that these objects might be on auto-mounted filesystems.<br>
If you stat a file, get busy with something else and the filesystem gets unmounted, then some other filesystem gets mounted, the second filesystem *might* get the same st_dev as the first filesystem.  So if you then stat a file on the new filesystem, it could be a completely different file on a different filesystem, but might have the same st_dev_ st_ino, and st_btime.<br>
<p>
Tracking the identity of filesystems (to detect these mounts) is not well supported.  st_dev is, as I say, transient for some filesystems.  The statfs() systemcall reports an &quot;fsid&quot;, but this is poorly specified.  The man page for statfs() says &quot;Nobody knows what f_fsid is supposed to contain&quot;.  Some filesystems (btrfs, xfs, ext4 and others) provide good values.  Other filesystems do less useful things.  Some just provide st_dev in a different encoding.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867181/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 5:40 UTC (Tue)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/867199/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
With 128-bit inode and device numbers one can guarantee that for any practical purposes they are unique and never reused.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 16:33 UTC (Tue)
                               by <b>jonesmz</b> (subscriber, #130234)
                              [<a href="/Articles/867254/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Would you propose using UUIDs specifically? Or just an arbitrary / implementation defined 128bit value?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor867186"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 23, 2021 22:25 UTC (Mon)
                               by <b>poc</b> (subscriber, #47038)
                              [<a href="/Articles/867186/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just as a matter of interest, does ZFS suffer from this problem, and if not, why not?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867186/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 4:17 UTC (Tue)
                               by <b>Conan_Kudo</b> (subscriber, #103240)
                              [<a href="/Articles/867195/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      I'm not <em>exactly</em> certain if ZFS has this issue, but the ZFS software suite has <a href="https://openzfs.github.io/openzfs-docs/man/8/zfs-share.8.html">its own SMB and NFS server implementations</a>, which means that the issues that the Linux NFS server has do not matter for ZFS users, who typically use the ZFS NFS implementation instead.





      
          <div class="CommentReplyButton">
            <form action="/Articles/867195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867205"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 9:28 UTC (Tue)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/867205/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I just checked <a href="https://github.com/openzfs/zfs.git">https://github.com/openzfs/zfs.git</a><br>
ZFS doesn&#x27;t have an NFS server.   It has a bunch of user-space tools which provide a standard &#x27;zfs&#x27; interface to the NFS support in the host kernel.  On Linux it uses the Linux kerrnel NFS server.<br>
<p>
ZFS is a substantially different filesystem to btrfs and is not directly comparable.  It doesn&#x27;t have anything with comparable flexibilty to btrfs subvols (which I want to call &quot;subtrees&quot;).<br>
There is a &quot;main&quot; filesystem, which uses 48bit inode numbers. and uses a fairly traditional NFS filehandle with the inode number and generation number.<br>
Then there are &quot;snapshots&quot; under &quot;.zfs/snapshot&quot;. The filehandle for objects in a snapshot have another 48bit number, presumably to identify which snapshot.<br>
I don&#x27;t *know&quot; what inode number is presented to stat(), but I wouldn&#x27;t be at all surprised to find that  objects in .zfs/snapshot have the SAME inode number as the corresponding object in the main filesystem.<br>
If you ask some tool like tar to look at the main filesystem as well as a snapshot, it might get confused.  But them, I suspect it is really quite easy to avoid doing that.<br>
With btrfs, subtree *can* be used as snapshots, but they can be used for other purposes too, and they can appear anywhere in the filesystem. With that extra flexibility comes extra responsibility....<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867205/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867207"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 10:29 UTC (Tue)
                               by <b>mtu</b> (guest, #144375)
                              [<a href="/Articles/867207/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting you should say that btrfs is more flexible than ZFSâ€”I feel the other way around. Coming from ZFS on FreeBSD, I think btrfs&#x27; concept of subvolumes is annoyingly primitive.<br>
<p>
Where btrfs has a flat list of &quot;subvolumes&quot;, ZFS has a hierarchical tree of &quot;datasets&quot; (filesystems), each of which can have any number of read-only &quot;snapshots&quot;*, which can in turn be the basis of sparse copy-on-write &quot;clones&quot; that behave like datasets. Dataset properties (like mountpoints, compression and more advanced fs stuff like recordsize) are hereditary throughout the tree. Most dataset operations (like snapshotting, &#x27;sending&#x27; into a flat bytestream or modifying properties) work recursively for any subtree.<br>
<p>
In contrast, I feel that all that btrfs has to offer is: &quot;Here&#x27;s a flat list of a few hundred &#x27;subvolumes&#x27;, good luck keeping track and managing their properties and mounpoints, and try to not write to the ones you meant to keep as read-only snapshots.&quot;<br>
<p>
* Concerning the matter at hand: Yes, snapshots are accessible through a dataset&#x27;s &quot;.zfs/&quot; subdirectory (unless the feature is disabled for a given dataset). But they are usually only every exposed by explicit &quot;cd&quot; or path addressing from a shell, and never pop up to confuse find, NFS, samba, du or any other userspace application working recursivelyâ€”at least that&#x27;s my experience on FreeBSD, that&#x27;s always had intimate and seamless integration of ZFS. On Linux, that seems to be a different story: <a href="https://github.com/openzfs/zfs/issues/6154">https://github.com/openzfs/zfs/issues/6154</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867207/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867211"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 11:56 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/867211/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>btrfs subvolumes are not a flat list; they can be created at any point in a normal directory hierarchy, including as children of other subvolumes. And all the other features you describe of ZFS snapshosts work in btrfs, too, just with different tooling.
<p>It sounds like you've encountered one set of tooling to manage btrfs subvolumes, and assumed that the limits of that tooling are the limits of btrfs.


      
          <div class="CommentReplyButton">
            <form action="/Articles/867211/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867229"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 14:42 UTC (Tue)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/867229/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; btrfs subvolumes are not a flat list</font><br>
<p>
They were in 2008.  Things have changed a little since then.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867229/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor867233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 16:17 UTC (Tue)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/867233/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This description of ZFS snapshots sounds so much less flexible than the btrfs version that I wonder if it&#x27;s even an accurate description of ZFS.<br>
<p>
btrfs snapshots are a lazy version of &#x27;cp -a --reflink&#x27;.  Users can drop a subvol anywhere in the filesystem and snapshot it anywhere else.  This is part of the current problem--there isn&#x27;t a single administrator-managed tree of subvols or snapshots, because ordinary applications can create and use subvols the same way they make directories (*).  An existing NFS export can wake up one morning after an application software upgrade and suddenly find itself hosting a lot of subvols it didn&#x27;t plan for.  This proliferation of subvols is why the obvious solution (create distinct mount points for each and every subvol) isn&#x27;t very popular (nor is the other obvious solution, lock down subvols so they aren&#x27;t as trivial to use).<br>
<p>
Unlike other popular snapshot systems, btrfs has no distinction between &quot;base&quot; and &quot;clone&quot; subvols.  There is a notion of an &quot;original&quot; subvol and a &quot;snapshot&quot; subvol, but it&#x27;s not part of the implementation, it&#x27;s only a hint for administrators to label before-and-after snapshots for incremental send/receive.  After a snapshot, both subvols are fully writable equal peers sharing ownership of their POSIX tree and data blocks, the same as if you had done cp -a --reflink atomically.  Snapshots have a read-only bit that can be turned on or off (but turning it off means the subvol is no longer synchronized with copies on other filesystems, so it can&#x27;t be used as a basis for incremental send/receive any more).  You can chain snapshots (snap A to B, snap B to C, snap C to D...), with equal cost to write any subvol in the chain, and you can delete any of the snapshots in the chain with equal cost and without disrupting any other snapshot (other snapshot systems will have up to O(n) extra cost if there are n snapshots, or may not be able to delete the original subvol before deleting all snapshots).  These properties greatly improve the usability of snapshots for applications since they can freely switch between treating them as subvol units or as individual files.<br>
<p>
(*) If that seems weird, observe that a long time ago &#x27;mkdir&#x27; required root privileges (**).<br>
<p>
(**) OK there were different reasons for that.  Still, ideas about what is &quot;normal&quot; for a filesystem and what is &quot;privileged&quot; do change over time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor867268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 19:26 UTC (Tue)
                               by <b>zev</b> (subscriber, #88455)
                              [<a href="/Articles/867268/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>I don't *know" what inode number is presented to stat(), but I wouldn't be at all surprised to find that objects in .zfs/snapshot have the SAME inode number as the corresponding object in the main filesystem.
If you ask some tool like tar to look at the main filesystem as well as a snapshot, it might get confused. But them, I suspect it is really quite easy to avoid doing that.</blockquote>

From a quick check, it appears that zfs does indeed present the same inode numbers in snapshots as it does in the main filesystem (on FreeBSD, anyway, though presumably on other kernels as well).  Though yes, as hinted at elsewhere, it omits the magic .zfs directories from directory listings (getdents, etc.), so you'll only ever end up referencing a path in a snapshot if you really ask for it; basic directory recursion by find, tar, etc. will skip right over it without ever knowing it's there.






      
          <div class="CommentReplyButton">
            <form action="/Articles/867268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor867200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 6:21 UTC (Tue)
                               by <b>eru</b> (subscriber, #2753)
                              [<a href="/Articles/867200/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A warning example of the trouble you get when you break a very old assumption. Or should it be even be called an invariant: Every mounted file system shall have inode numbers that are unique within it. In hindsight, at least, the correct solution would have been to not merge btrfs until it obeys this rule.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2021 4:55 UTC (Sun)
                               by <b>patrakov</b> (subscriber, #97174)
                              [<a href="/Articles/867714/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This requirement is not really useful, as it applies to the whole filesystem and assumes that there is no concurrent mutation of the whole filesystem. It would be necessary to make a stronger requirement, that can at least apply to subtrees and tolerate mutations outside of the subtrees. And ideally, specify what happens with inode numbers now and in the past, if the subtree being walked through is also being mutated concurrently.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867849"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2021 13:44 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/867849/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup. I&#x27;ve been puzzled by this and I think I&#x27;ve hit on part of the problem ...<br>
<p>
The *obvious* fix is to make i-nodes unique at the root file-system level. It&#x27;s not a problem to think of a snapshots sharing i-nodes if they&#x27;re sharing the same file ...<br>
<p>
BUT. As soon as you break the link by modifying the file in one snapshot, that means you need to change the i-node number. No problem? Until the user has been using hardlinks to avoid having multiple identical copies of large files. You&#x27;re now forcing &quot;create temp files, copy over original&quot; behaviour onto user space and that breaks hard links ...<br>
<p>
I&#x27;m guessing there&#x27;s plenty more problems where that came from, so where do we go from here? It ain&#x27;t simple ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867849/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867850"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2021 14:02 UTC (Tue)
                               by <b>patrakov</b> (subscriber, #97174)
                              [<a href="/Articles/867850/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Correct. And this is even mentioned in other comments: &quot;btrfs snapshots are a lazy version of &#x27;cp -a --reflink&#x27;&quot;. Same inode numberss indicate hardlinks, and reflinks are a different beast. So it looks like a solution would involve generating inode numbers lazily when someone stats a file in the snapshot.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867850/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor867201"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 7:01 UTC (Tue)
                               by <b>mezcalero</b> (subscriber, #45103)
                              [<a href="/Articles/867201/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I very much like the idea to expose a second 64 bit identifier via statx(). This value together with the inode would be 128 bit then, which has the same size as a UUID, i.e. should be large enough to be effectively collision-free IRL by all established standards â€“ at least if allocated ramdomly or via a hash. I mean, how cool would be that: having a truly universal identifier for an inode, that is not only valid on some specific file system but *world-wide*. (They could generate the exposed pair of inode ID and this new 2nd inode ID via a single block AES encryption, if they want something reversible, with a randomized â€” but public â€” key stored in the fs header somewhere). If files had these 128bit ids that are effectively uuids then the overlayfs problem, the nfs problem would all be so much simpler. After all all these issues just stem from the fact that 64bit is just too little to properly generate them randomized/hashed, and thus you need to manually avoid conflicts instead of just relying on the fact that the number space is sufficiently large that if you generate things randomized/hashed collisions are sufficiently unlikely.<br>
<p>
Note that Windows is way ahead there, and exposes such pretty-much-UUIDs-but-not-really for NTFS already: <a href="https://devblogs.microsoft.com/oldnewthing/20110228-00/?p=11363">https://devblogs.microsoft.com/oldnewthing/20110228-00/?p...</a> â€” Maybe it&#x27;s time for Linux just acknowledge that having such a universal 128bit ID is actually a really useful thing.<br>
<p>
Note that btrfs documented that dirs that are subvolumes are recognizable by their inode nr 256. If they change that they&#x27;ll break a good part of userspace (including systemd). But if they give my truly universally valid 128 bit IDs as replacement I&#x27;d be more than happy to fix the fallout â€“ at least in my codebases â€“ quickly.<br>
<p>
(I think it would really make sense to add a flag returned by statx() that marks the subvolume dirs explicitly as subvolumes. Right now userspace is supposed to make the check &quot;has this file BTRFS_SUPER_MAGIC and inode nr 256&quot; which is just messy and requires two syscalls. i.e. STATX_ATTR_SUBVOLUME or FS_SUBVOLUME_FL would be great to have)<br>
<p>
Lennart<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867201/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867313"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2021 11:26 UTC (Wed)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/867313/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To me having globally unique inode numbers just sounds like another way to uniquely fingerprint a system that we need to protect from anyone who might want to do that.<br>
<p>
I also don&#x27;t really see the use case outside of filesystems like btrfs which do everything differently mainly to be different. It is not as if they couldn&#x27;t have split up the 64bit available to them into two numbers that would be more than enough for the numbers of files you find on a filesystem times the number of subvolumes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867313/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2021 21:02 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/867398/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you have access to read arbitrary inode numbers, then you can in practice uniquely identify the system by sampling a bunch of files in home directory. And even a single-file 64-bit inode is already likely to be reasonably unique.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor867385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2021 1:21 UTC (Thu)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/867385/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It is not as if they couldn&#x27;t have split up the 64bit available to them into two numbers</font><br>
<p>
It might be harder than it looks?  So far btrfs, xfs, bcachefs, zfs, and overlayfs have all not done this.<br>
<p>
bcachefs seems to have painted itself into the same corner as btrfs:  32-bit subvol ID, 64-bit inode, making a snapshot duplicates all existing inode numbers in the subvol.  XFS experimented with subvols, gave up, and now recommends bcachefs instead.  ZFS duplicates inode numbers--despite using only 48 bits of ino_t--and apologizes to no one.<br>
<p>
Overlayfs takes up at least one bit of its own, which can interfere with any other filesystem&#x27;s attempt to use all 64 bits of ino_t (indeed the btrfs NFS support patch reserves some bits for that).  Overlayfs only does that sometimes--the rest of the time, it lets inode numbers from different lowerdirs collide freely.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867420"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2021 1:52 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/867420/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It might be harder than it looks? </font><br>
<p>
One reason that it is harder for btrfs is that btrfs never reuses inode numbers (well ... almost never).<br>
Nor does it reuse subvolume numbers.<br>
<p>
So if you create a snapshot every minute you&#x27;ll use 24bits of subvolume numbers in 31 years - even if you only keep a few around.<br>
If you create 100 new files per second, you&#x27;ll use 40 bits of inode numbers in 348 years - no matter how many you keep.<br>
<p>
How long do we expect a filesystem to last for?  348 years is probably unrealistic - is 31?<br>
These creation rates are high.  Are they unrealistically high? Maybe.<br>
If you were a filesystem developer, would you feel comfortable limiting subvolumes to 24bits and inodes to 40 bits?<br>
<p>
64bits allows you to create one every microsecond and still survive for half a million years.  That is much easier for a filesystem developer to live with.<br>
<p>
I would like btrfs to re-use the numbers and impose these limits.  This is far from straight forward.  It is almost certainly technically possible without excessive cost (though with a non-zero cost).  But it can be hard to motivate efforts to protect against uncertain future problems (.... I&#x27;m sure there is a well known example I could point to...).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867420/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor868537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 7, 2021 14:11 UTC (Tue)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/868537/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; These creation rates are high. Are they unrealistically high? Maybe</font><br>
<p>
It&#x27;s hard to make a direct comparison given the fundamental differences in the model of subvolumes vs ZFS&#x27; various dataset types, but FWIW, I have a running system - at home, so not exactly enterprise scale - where the total number of ZFS snapshots that have been made across filesystems/volumes in the pool over the last decade is probably around 15 million. Getting pretty close to 24 bits.<br>
<p>
I don&#x27;t know enough about btrfs to know if the equivalent setup to those filesystems and volumes would be based on some shared root there and competing for inodes, or entirely separate. I guess what that boils down to is that I don&#x27;t know if the rough equivalent to a btrfs filesystem is a ZFS filesystem or a ZFS *pool*. Either way, once you&#x27;re used to nearly-free snapshots, you can find yourself using a *lot* of them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor867589"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 27, 2021 6:10 UTC (Fri)
                               by <b>mezcalero</b> (subscriber, #45103)
                              [<a href="/Articles/867589/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You do realize all major Linux file system implementatios export a UUID identifying the file system universally? See blkid. If you are concerned about globally unique identifiers for the system: those existing ones are a lot better suited for that. Per-inode UUIDs are much less interesting for that.<br>
<p>
Lennart<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867589/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor867250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 16:16 UTC (Tue)
                               by <b>wazoox</b> (subscriber, #69624)
                              [<a href="/Articles/867250/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Dave Chinner in a discussion about snapshots just wrote that on the xfs ML:<br>
<p>
   &quot;As such, if you want a performant, scalable, robust snapshotting<br>
   subvolume capable filesystem, bcachefs is the direction you should<br>
   be looking. All of the benefits of integrated subvolume snapshots,<br>
   yet none of the fundamental architectural deficiencies and design<br>
   flaws that limit the practical usability of btrfs for many important<br>
   workloads.&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867258"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 18:00 UTC (Tue)
                               by <b>sub2LWN</b> (subscriber, #134200)
                              [<a href="/Articles/867258/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here&#x27;s a link to the quoted linux-xfs mail: <a href="https://lwn.net/ml/linux-xfs/20210823231235.GK3657114%40dread.disaster.area/">https://lwn.net/ml/linux-xfs/20210823231235.GK3657114%40d...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867258/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor867259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 18:22 UTC (Tue)
                               by <b>mbunkus</b> (subscriber, #87248)
                              [<a href="/Articles/867259/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;ve looked into bcachefs a couple of times over the years now, and I&#x27;d really like to give it a serious go â€” but not at the cost of having to build my own kernel (as none of the distros relevant to me seem to carry it) and rescue ISO.<br>
<p>
Do you have any insight into their plans, timeframes, goals for getting it into mainline? I see that an unsuccessful attempt was made in December 2020, but after thatâ€¦ not easy to find more information for an outsider like me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867334"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 25, 2021 14:52 UTC (Wed)
                               by <b>wazoox</b> (subscriber, #69624)
                              [<a href="/Articles/867334/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here is the latest request from Kent for mainlining:<br>
<a href="https://lkml.org/lkml/2020/10/27/3684">https://lkml.org/lkml/2020/10/27/3684</a><br>
<p>
There was some problem, then no news... OTOH at the time snapshots weren&#x27;t even functional.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867334/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor867266"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 24, 2021 23:07 UTC (Tue)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/867266/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Quote from <a href="https://bcachefs.org/Snapshots/">bcachefs.org</a>:

<blockquote>The functionality and userspace interface for snapshots and subvolumes are roughly modelled after btrfs...</blockquote>

I wouldn't expect anything different.  For over a decade, btrfs has had the only viable implementation of this interface to build on in Linux.  Even if other filesystems implement subvols and snapshots, they'll be strongly compelled to follow whatever trail btrfs blazes for them now.<p>

I find all the worst-case O(N) searching for N snapshots in the design doc concerning.<p>

This is what the bcachefs 'snapshot' branch does today:

<pre>
# bcachefs subvolume create foo
# date &gt; foo/bar
# bcachefs subvolume snapshot foo quux
# find -ls
     4096      0 drwxr-xr-x   3 root     root            0 Aug 24 18:40 .
     4098      0 drwxr-xr-x   2 root     root            0 Aug 24 18:40 ./foo
     4099      1 -rw-r--r--   1 root     root           29 Aug 24 18:40 ./foo/bar
     4098      0 drwxr-xr-x   2 root     root            0 Aug 24 18:40 ./quux
     4099      1 -rw-r--r--   1 root     root           29 Aug 24 18:40 ./quux/bar
     4097      0 drwx------   2 root     root            0 Aug 24 18:40 ./lost+found
# stat foo/bar quux/bar
  File: foo/bar
  Size: 29              Blocks: 1          IO Block: 512    regular file
Device: fd04h/64772d    Inode: 4099        Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2021-08-24 18:40:37.278101823 -0400
Modify: 2021-08-24 18:40:37.290101816 -0400
Change: 2021-08-24 18:40:37.290101816 -0400
 Birth: -
  File: quux/bar
  Size: 29              Blocks: 1          IO Block: 512    regular file
Device: fd04h/64772d    Inode: 4099        Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2021-08-24 18:40:37.278101823 -0400
Modify: 2021-08-24 18:40:37.290101816 -0400
Change: 2021-08-24 18:40:37.290101816 -0400
 Birth: -
</pre>

Duplicate st_dev <em>and</em> st_ino, it's <em>worse</em> than btrfs.  On the other hand:

<pre>
# date &gt; foo/second1
# date &gt; quux/second2
# ls -li */second*
4100 -rw-r--r-- 1 root root 29 Aug 24 18:44 foo/second1
4101 -rw-r--r-- 1 root root 29 Aug 24 18:44 quux/second2
</pre>

bcachefs will always give new files unique inode numbers, even in different subvols, because the code for creating a new file obtains a globally unique inode number.  Possible point for bcachefs here--in this situation, btrfs uses a per-subvol inode number allocator, which would have given both new files inode 4100.











      
          <div class="CommentReplyButton">
            <form action="/Articles/867266/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor867427"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2021 5:47 UTC (Thu)
                               by <b>dgc</b> (subscriber, #6611)
                              [<a href="/Articles/867427/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup. I stand by that statement. I&#x27;ve run tests, measured numbers and observed behaviours. I also have a fair understanding of differences in architetures and implementations. This thread is probably enlightening about the architectural deficiencies within btrfs, which would appear to be unfixable:<br>
<p>
<a href="https://lore.kernel.org/linux-btrfs/20210121222051.GB4626@dread.disaster.area/">https://lore.kernel.org/linux-btrfs/20210121222051.GB4626...</a><br>
<p>
From a filesystem design perspective, COW metadata creates really nasty write amplification and memory footprint problems for pure metadata updates such as updating object reference counts during a snapshot. First the tree has to be stabilised (run all pending metadata COW and write it back), then a reference count update has to be run which then COWs every metadata block in the currently referenced metadata root tree. The metadata amplification is such that with enough previous snapshots, a new snapshot with just a few tens of MB of changed user data can amplify into 10s of GB of internal metadata COW.....<br>
<p>
That explained why user data write COW performance on btrfs degraded quickly as snapshot count increases on this specific stress workload (1000 snapshots w/ 10,000 random 4kB overwrites per snapshot, so 40GB of total user data written)<br>
<p>
In comparison, dm-snapshot performance on this workload is deterministic and constant as snapshot count increases, same as bcachefs. Bcachefs performed small COW 5x faster than dm-snapshot (largely due to dm-snapshot write amplification due to 64kB minimum COW block size). At 1 snapshot, btrfs COW is about 80% the speed of bcachefs. At 10 snapshots, bcachefs and dm-snapshot performance is unchanged and btrfs has degraded to about the same speed as dm-snapshot. At 100 snapshots, btrfs is bouncing between 1-5% the sustained user data write speed of bcachefs, and less than a quarter of the speed of dm-snapshot, and it doesn&#x27;t regain any of the original performance as the snapshot count increases further.<br>
<p>
That can be seen in workload runtimes - it ran in 20 minutes on bcachefs with each snapshot taking less than 30ms. It ran in about 40 minutes on dm-snapshot, with each snapshot taking less than 20ms. It took 5 hours for XFS+loopback+reflink to run (basically the XFS subvol architecture as a 10 line shell hack) because reflink on an image file with 2 million extents takes ~15s. It took about 9 hours for btrfs to run - a combination of slow user IO (sometimes only getting only *200* 4kB write IOPS from fio for minutes at a time) and the time to run the btrfs snapshot command increasing linearly with snapshot count, taking ~70s to run by the 1000th snapshot.<br>
<p>
Sustained IO rates under that workload: bcachefs ~200 write IOPS, 100MB/s. XFS+reflink: ~15k write IOPS, 60MB/s. dm-snapshot: ~10k/10k read/write IOPS, 650/650 read/write MB/s. btrfs: 10-150k write IOPS, 5-10k read IOPS, 0.5-3.2GB/s write, 50MB/s read (9 hours averaging over 1GB/s write will make a serious dent in the production lifetime of most SSDs)<br>
<p>
Write amplification as a factor of storage capacity used by that workload: bcachefs: 1.02 xfs+loop+reflink: 1.1 btrfs: ~4.5 dm-snapshot: 17 (because 64kB/4KB = minimum 16x write amplification for every random 4kB IO)<br>
<p>
memory footprint: bcachefs: ~2GB. XFS+reflink: ~2.5GB. dm-snapshot: ~2.5GB. btrfs: Used all of the 16GB of RAM and was swapping, writeback throttling on both the root device (swap) and the target device (btrfs IO), userspace was getting blocked for tens of seconds at a time waiting on memory reclaim, swap, IO throttling, etc.<br>
<p>
Sure, it&#x27;s a worst case workload, but the point of running &quot;worst case&quot; workloads is finding out how the implementation handles those situations. It&#x27;s the &quot;worst case&quot; workloads that generate all the customer support and escalation pain for engineering teams that have to make those subsystems work for their customers. Given that btrfs falls completely apart and makes the machine barely usable in scenarios that bcachefs does not even blink at, it&#x27;s a fair indication of which filesystem architecture handles stress and adverse conditions/workloads better.<br>
<p>
bcachefs also scales better than btrfs. btrfs *still* has major problems with btree lock contention. Even when you separate the namespace btrees by directing threads to different subvolumes, it just moves the lock contention to next btree in teh stack - which IIRC is the global chunk allocation btree. I first reported these scalability problems with btrfs over a decade ago, and it&#x27;s never been addressed. IOWs, btrfs still generally shows the same negative scaling at concurrency levels as low as 4 threads (i.e. 4 threads is slower than 1 thread, despite burning 4 CPUs trying to do work) as it did a decade ago. In comparison, bcachefs concurrency under the same workloads and without using any subvolume tricks ends up scaling similarly to ext4 (i.e. limited by VFS inode cache hash locking at ~8 threads and 4-6x the performance of a single thread). <br>
<p>
I can go on, but I&#x27;ve got lots of numbers from many different workloads that basically say the same thing - if you have a sustained IO and/or concurrency in your workload, btrfs ends up at the bottom of the pack for many important metrics - IO behaviour, filesystem memory footprint, CPU efficiency, scalability, average latency, long tail latency, etc. In some cases, btrfs is a *long* way behind the pack. And the comparison only gets worse for btrfs if you start to throw fsync() operations into the workload mix....<br>
<p>
I&#x27;m definitely not saying that bcachefs is perfect - far from it - but I am using bcachefs as a baseline to demonstrate that it the poor performance and scalability of btrfs isn&#x27;t &quot;just what you get from COW filesystems&quot;. Competition is good - bcachefs shows that a properly designed and architected COW filesystem can perform extremely well under what are typically called &quot;adverse workload conditions&quot; for COW filesystems. As such, my testing really only serves to highlight the deficiencies in existing upstream snapshot solutions, and so...<br>
<p>
&quot;As such, if you want a performant, scalable, robust snapshotting<br>
subvolume capable filesystem, bcachefs is the direction you should<br>
be looking. All of the benefits of integrated subvolume snapshots,<br>
yet none of the fundamental architectural deficiencies and design<br>
flaws that limit the practical usability of btrfs for many important<br>
workloads.&quot;<br>
<p>
-Dave.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867427/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867751"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2021 9:25 UTC (Mon)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/867751/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think I&#x27;ve seen a couple of mentions of bcachefs and it seemed interesting at that time, but I completely missed the point at which it transitioned from &quot;a cool prototype&quot; to &quot;production-ready, stable and mature&quot;. Is it already? Perhaps it needs a PR department of sorts, because it sounds really amazing ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867751/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867793"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 31, 2021 1:27 UTC (Tue)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/867793/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You haven&#x27;t missed it--that point is still in the future.  Subvols on bcachefs are only a few months old, and much closer to the &quot;cool prototype&quot; end of the spectrum than the other end.  My last test run of bcachefs ended after 29 minutes with a readonly splat from the &#x27;cp&#x27; command.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867793/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor868239"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 3, 2021 2:06 UTC (Fri)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/868239/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Speaking of cool-but-unreleased filesystems, has anyone heard from Tux3 lately? It was showing some mythical benchmark numbers where an in-memory loopback was outperforming tmpfs, then it fell off the face of the earth.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868239/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor868540"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 7, 2021 14:31 UTC (Tue)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/868540/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The mailing list has had nothing but &quot;is this project alive?&quot; type messages for the last couple of years. The latest one of those to get an answer was last year:<br>
<p>
<font class="QuotedText">&gt; I can&#x27;t say very active though, we are working on spare time. Recently,</font><br>
<font class="QuotedText">&gt; we are working for snapshot prototype, and inode container improvement</font><br>
<p>
I&#x27;d say the last time it looked even vaguely healthy was 2014, and even that was after a couple of very light years, so I think it is probably never going to see the light of day, sadly.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868540/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor867509"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2021 15:10 UTC (Thu)
                               by <b>josefbacik</b> (subscriber, #90083)
                              [<a href="/Articles/867509/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is a problem of interfaces.  Btrfs has subvolumes, which are just their own b-tree, and the inode numbers are just a value inside of that tree.  Since they are different trees you can share inode numbers across multiple trees.  However each tree has their own unique ID.<br>
<p>
The st_dev thing is unfortunate, but again is the result of a lack of interfaces.  Very early on we had problems with rsync wandering into snapshots and copying loads of stuff.  Find as well would get tripped up.  The way these tools figure out if they&#x27;ve wandered into another file system is if the st_dev is different.  So we made st_dev different for every subvolume.  Is this a great solution?  Absolutely not.  Is there another option?  Not really, this is how userspace interacts with the kernel, so we compromised in order to make userspace work well.<br>
<p>
The next problem is that every subvolume has the same start inode number.  The subvolume id is clearly different, but that &#x27;.&#x27; stat is going to be the same value for any subvolume.  Again we need a way to tell an application that this is the subvolume root.  Is this the best way forward?  Absolutely not.  Is there another option?  Not really.<br>
<p>
What we need is an interface to give userspace more information.  I&#x27;ve suggested exporting UUID&#x27;s via statx.  We have a file system wide UUID and then we have per-subvolume UUID&#x27;s.  This is relatively straightforward and gives userspace a whole lot of information.  They can tell if two subvolumes are on the same file system, and they can tell that they are in two different subvolumes.<br>
<p>
Another solution would be to simply export the subvolume ID via statx, as that&#x27;s just another u64.  That is how we deal with NFS file handles, we build them with the subvolume id + the inode number.  That combination is completely unique and is everything you need to find the inode.  Now this doesn&#x27;t solve the problem of figuring out if two different subvolumes are the same file system.  This is why I think the UUID is more valuable.  We could add yet another st_sbdev or something to export the device for the file system itself if we wanted to stick with the device number scheme, and then we would have everything we need to get all the information we would want out of the file system.<br>
<p>
Btrfs was the first file system to do this, and we did it in a system that didn&#x27;t envision this type of architecture.  Because of that we had to make certain interface decisions to get the best outcome possible for userspace, as that is the _ONLY_ thing that matters.  It doesn&#x27;t matter how we organize ourselves in the kernel, because the kernel doesn&#x27;t operate in a vacuum.  It provides userspace the ability to do actual work, and as such we are confined to the interfaces that exist.  Extending those interfaces is the only sane way forward, because we cannot un-ring the bell of the choices we&#x27;ve already made.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867509/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867572"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 26, 2021 23:22 UTC (Thu)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/867572/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; we cannot un-ring the bell of the choices we&#x27;ve already made.</font><br>
<p>
Indeed, we cannot.  I wonder if we can learn anything about future choices.  And whether we can repair the current situation.<br>
<p>
Modifying the st_dev was, in retrospect, an unfortunately choice.  But it was also an easy choice - quickly providing a solution.<br>
ZFS (and others I think) address a similar problem by hiding things from readdir().  This might work adequately with a fixed name like &quot;.zfs&quot;. It wouldn&#x27;t work for btrfs which allows any name to be used for a subvolume.<br>
<p>
Another approach - which would have been more work and taken longer - would have been to work with rsync, find, etc to find a solution.  One might have been to change them to check statfs().f_fsid instead of st_dev.  This has the advantage that f_fsid is already available, but poorly specified and not widely used.  That means it is less brittle and using it is less likely to break things.<br>
<p>
This is, I think, an instance of the much broader &quot;platform problem&quot;.  It always seems easier to work-around weaknesses in the platform, rather than push for changes in the platform.  But the long-term benefits come from doing the early work (painful though it may be) and improve the platform.<br>
<p>
But  note that there are two distinct problems here:<br>
1 - the platform provides no way to identify a subtree within a filesystem (project-id is close, but not quite the same)<br>
2 - the platform limits inode numbers to 64 bits (in any given filesystem)<br>
<p>
Adding subtree information in statx addresses &#x27;1&#x27; and could be used by find and rsync as needed.  But that doesn&#x27;t address &#x27;2&#x27;.<br>
Addressing &#x27;2&#x27; requires a realistic assessment of how many bits are really needed to identify all possible objects.  I think 64 is actually enough for the forseeable future, providing they are use wisely.   Setting i_ino to a strong hash of whatever value the filesytem uses internally to find a file is a tempting idea. My last proposed solution for the NFS problem is to use a week hash (xor with bit shift).  Maybe we should use a strong hash instead.<br>
<p>
While I like the use of uuids for filesystems (and wish f_fsid was 128bits instead of 64), I don&#x27;t think they are such a good idea for files within a filesystem.  tree-id + file-id + generation should always be enough and while 128bit might be a good size for that, forcing them into UUID format doesn&#x27;t seem to add value.<br>
<p>
<p>
I seem to recall that when &#x27;statx&#x27; was being proposed, lots of people had lots of ideas about extra things to add.  The decision was to not add anything new at first.  So if we want to add things now we need to make a strong case, and demonstrate at least one application that will immediately use the information.  That would be a lot easier if we had a concrete problem to fix.  The NFS issue is a concrete problem, but it doesn&#x27;t actually require a user-space API change, so it is hard to use it as a lever to extend statx()....<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867572/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867722"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2021 9:22 UTC (Sun)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/867722/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Setting i_ino to a strong hash of whatever value the filesytem uses internally to find a file is a tempting idea. My last proposed solution for the NFS problem is to use a week hash (xor with bit shift). Maybe we should use a strong hash instead.</font><br>
<p>
Why is it necessary to use something that has the potential for collisions at all? Why not just hand out arbitrary or sequential numbers in a centralized fashion (like every other filesystem that isn&#x27;t FAT)? Is there some rule that says you&#x27;re not allowed to look at subvolume X when you make a new file in subvolume Y? Why would such a rule be necessary?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867722/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor867724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 29, 2021 12:31 UTC (Sun)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/867724/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Subvolume Y can be a writeable snapshot clone of subvolume X. And you want creating snapshots to be fast, and not use excess disk space. Needing to iterate over every file in X to assign each one a new centrally-assigned-unique inode in Y would be unfortunate both in terms of time and space it would take.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor867756"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 30, 2021 15:05 UTC (Mon)
                               by <b>zblaxell</b> (subscriber, #26385)
                              [<a href="/Articles/867756/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Creating a subvol snapshot instantly duplicates every inode number that already exists in the snapshot source subvol to the target subvol.  &quot;Instantly&quot; is a core requirement of the feature set--if a filesystem cannot create a subvol snapshot instantly, there is no performance or consistency advantage over userspace emulation with &#x27;cp -a --reflink=always&#x27;, and it is better not to implement the subvol feature set at all (which is roughly why XFS doesn&#x27;t do it).<br>
<p>
To get globally unique and stable inode numbers without a separate subvol ID, the filesystem would have to dynamically remap duplicate inode numbers from subvol-local values to globally-unique values every time a readdir() or stat() happened.  This adds some overhead to all read operations that filesystem maintainers are reluctant to implement.  They would prefer some more efficient way to tell an application &quot;this is a distinct inode number namespace but not a distinct filesystem&quot; so that applications that rely on the uniqueness feature can bear some of the costs (including opportunity costs) of implementing it, while not imposing new costs (such as new O(log(N)) search costs on every stat(), or exploding /proc/mounts and `df` output size) on applications that don&#x27;t care about inode uniqueness.<br>
<p>
The NFS server could maintain its own persistent unique inode numbers in a mapping table outside of the filesystem, and not send the filesystem&#x27;s inode numbers to clients at all, but that has obvious and onerous runtime costs (the NFS server would have to maintain persistent state proportional to filesystem size).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/867756/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor868978"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2021 9:23 UTC (Sun)
                               by <b>walex</b> (subscriber, #69836)
                              [<a href="/Articles/868978/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Â«<i>This is a problem of interfaces. Btrfs has subvolumes, which are just their own b-tree, and the inode numbers are just a value inside of that tree. Since they are different trees you can share inode numbers across multiple trees. However each tree has their own unique ID.</i>Â»</p>

<p>This seems a weak defense of the current Btrfs situation, and it is based on a mispresentation of <a rel="nofollow" href="http://www.sabi.co.uk/blog/21-two.html?210804#210804">UNIX filesystem semantics</a>, regardless of the details of the API:</p>
<ul>
<li>In UNIX each filesystem instance has at least one root directory, and each root directory and its descendant i-nodes have a unique "device-id", which was once upon a time the device-id of the containing block device, but need not be (e.g. filesystem instances not contained in any block device).</li>
<li>In UNIX there is no restriction against having multiple filesystem instances in a block device, or having multiple root directories in a filesystem instance (even if both are not traditionally possible).</li>
<li>The only restriction is that (optionally) a filesystem type can deny hard links between a directory and an i-node with different device-ids.</li>
</ul>

<p>In particular there is no obligation for mounted root directories of filesystem instances to be registered in '/etc/fstab' or anywhere else.</p>

<p>Each Btrfs pr ZFS subvolume or snapshot is just a different root directory in a filesystem instance, so Btrfs (and ZFS, and soon 'bcachefs') respect all these properties, well written NFS servers have no problems with them, and therefore there is simply no issue with them and NFS, and this whole discussion is pointless.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/868978/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor868997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Btrfs inode-number epic (part 2: solutions)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2021 19:36 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/868997/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It enables a filesystem to provide a &quot;uniquifier&quot; value associated with a file; this value, the name of which is arguably better suited to a professional wrestler, is only available within the kernel.</font><br>
<p>
That&#x27;s not the only place that term is used! This is probably the only time in history that any component of Emacs has ever been compared to a professional wrestler (except for its weight and sumo wrestlers in particular): <a href="https://www.emacswiki.org/emacs/uniquify">https://www.emacswiki.org/emacs/uniquify</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/868997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
