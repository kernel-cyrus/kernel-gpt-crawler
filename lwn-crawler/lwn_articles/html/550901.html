        <!DOCTYPE html>
        <html lang="en">
        <head><title>An unexpected perf feature [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/550901/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/550895/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/550901/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>An unexpected perf feature</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>LWN.net needs you!</b>
<p>
Without subscribers, LWN would simply not exist.  Please consider
       <a href="/Promo/nst-nag2/subscribe">signing up for a subscription</a> and helping
       to keep LWN publishing.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>May 21, 2013</br>
           </div>
<p>
Local privilege escalations seem to be regularly found in the Linux kernel
these days,
but they usually aren't quite so old&mdash;more than two years since the release
of 2.6.37&mdash;or backported into
even earlier kernels.  But <a
href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2013-2094">CVE-2013-2094</a>
is just that kind of bug, with a now-public exploit that apparently dates
back to 2010. 
It (ab)uses the <tt>perf_event_open()</tt> system call, and the bug was
backported 
to the 2.6.32 kernel used by Red Hat Enterprise Linux (and its clones:
CentOS, Oracle, and Scientific Linux).  While local privilege escalations
are generally considered less worrisome on systems without untrusted users,
it is easy to forget that UIDs used by network-exposed services should also
qualify as untrusted&mdash;compromising a service, then using a local
privilege escalation, leads directly to root. 
</p>

<p>
The bug was found by Tommi Rantala when running the <a
href="/Articles/536173/">Trinity fuzz tester</a> and was <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=8176cced706b5e5d15887584150764894e94e02f">fixed</a>
in mid-April.  At that time, it was <a href="/Articles/550679/">not
recognized as a security problem</a>; the release of an <a
href="http://fucksheep.org/~sd/warez/semtex.c">exploit</a> in mid-May
certainly changed that.  The exploit is dated 2010 and contains some
possibly "not 
safe for 
work" strings. Its author <a href="/Articles/551220/">expressed
surprise</a> 
that it wasn't seen as a security problem when it was fixed.  That alone is
an indication (if 
one was needed) that people in various colored hats are scrutinizing kernel
commits&mdash;often in ways that the kernel developers are not. 
</p>

<p>
The bug itself was <a
href="http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=b0a873ebbf87bf38bf70b5e39a7cadc96099fa13">introduced</a>
in 2010, and made its first appearance in the 2.6.37 kernel in January
2011.  It treated the 64-bit perf event ID differently in an
initialization routine (<tt>perf_swevent_init()</tt> where the ID  was
sanity checked) and in the cleanup routine
(<tt>sw_perf_event_destroy()</tt>).  In the former, it was treated as a
signed 32-bit integer, while in the latter as an unsigned 64-bit integer.
The difference may not seem hugely significant, but, as it turns out, it
can be used to effect a full compromise of the system by privilege
escalation to root.
</p>

<p>
The key piece of the puzzle is that the event ID is used as an array
index in the kernel.  It is a value that is controlled by user space, as it is
passed in via the <tt>struct&nbsp;perf_event_attr</tt> argument to <a
href="http://man7.org/linux/man-pages/man2/perf_event_open.2.html"><tt>perf_event_open()</tt></a>.
Because it is sanity checked as an <tt>int</tt>, the upper 32 bits of
<tt>event_id</tt> can be anything the attacker wants, so long as the lower
32 bits are considered valid.  Because
<tt>event_id</tt> is used as a signed value, the test:
<pre>
    if (event_id &gt;= PERF_COUNT_SW_MAX)
            return -ENOENT;
</pre>
doesn't exclude negative IDs, so anything with bit 31 set (i.e. 0x80000000) will be
considered valid.
</p>

<p>
The exploit code itself is rather terse, obfuscated, and hard to follow,
but Brad 
Spengler has provided a detailed <a
href="http://www.reddit.com/r/netsec/comments/1eb9iw/sdfucksheeporgs_semtexc_local_linux_root_exploit/c9ykrck">description
of the exploit</a> on Reddit.  Essentially, it uses a negative value for
the event ID to cause the kernel to change user-space memory.  The exploit
uses <tt>mmap()</tt> to map an area of user-space memory that will be
targeted when the negative event ID is passed.  It sets the mapped area to
zeroes, then calls
<tt>perf_event_open()</tt>, immediately followed by a <tt>close()</tt> on
the returned file descriptor.  That triggers:
<pre>
    static_key_slow_dec(&amp;perf_swevent_enabled[event_id]);
</pre>
in the <tt>sw_perf_event_destroy()</tt> function.
The code then looks for non-zero values in the mapped area, which can be
used (along with the event ID value and the size of the array elements) to
calculate the base address of the <tt>perf_swevent_enabled</tt> array.

<p>
But that value is just a steppingstone toward the real goal.  The exploit
gets the base address of the interrupt descriptor table (IDT) by using the
<tt>sidt</tt> assembly language instruction.  From that, it targets the
overflow interrupt vector (0x4), using the increment in
<tt>perf_swevent_init()</tt>: 
<pre>
    static_key_slow_inc(&amp;perf_swevent_enabled[event_id]);
</pre>
By setting <tt>event_id</tt> appropriately, it can turn the address of the
overflow interrupt handler into a user-space address.

<p>
The exploit arranges to <tt>mmap()</tt> the range of memory where the
clobbered interrupt
handler will point and fills it with a <a
href="http://en.wikipedia.org/wiki/NOP_slide">NOP sled</a> followed by <a
href="http://en.wikipedia.org/wiki/Shellcode">shellcode</a> that
accomplishes its <i>real</i> task: finding the UID/GIDs and capabilities in
the credentials of the current process so that it can modify them to be UID
and GID 0 with full 
capabilities. At that point, in what almost feels like an afterthought, it
spawns a shell&mdash;a root shell.
</p>

<p>
Depending on a number of architecture- or kernel-build-specific features
(not least x86 assembly) makes the exploit itself rather fragile. It also
contains bugs, according to Spengler.  It doesn't work on 32-bit x86 systems
because it uses a hard-coded system call number (298) passed to
<tt>syscall()</tt>, which is different (336) for 32-bit x86 kernels.  It
also won't work on Ubuntu systems because the size 
of the <tt>perf_swevent_enabled</tt> array elements is different. The
following will thwart the existing exploit:
<pre>
    echo 2 &gt; /proc/sys/kernel/perf_event_paranoid
</pre>
But a minor change to the flags passed to <tt>perf_event_open()</tt>
will still allow the privilege escalation. None of these is a real defense
of any sort 
against the <i>vulnerability</i>, though they do defend against this
specific exploit.  Spengler's analysis has more details, both of the
existing exploit as well as ways to change it to work around its fragility.
</p>

<p>
The code uses <tt>syscall()</tt>, presumably because
<tt>perf_event_open()</tt> is 
not (yet?) 
available in the GNU C library, but it could also be done to
evade any argument checks done in the library.  Any sanity checking done by
the library must also be done in the kernel, because using
<tt>syscall()</tt>  can avoid the usual system call path.  Kernels
configured without support for perf events
(i.e. <tt>CONFIG_PERF_EVENTS</tt> not set) are unaffected by the bug as
they lack the 
system call entirely.
</p>

<p>
There are several kernel hardening techniques that would help to avoid this
kind of bug leading to system compromise.  The grsecurity <a
href="http://grsecurity.net/~spender/uderef.txt">UDEREF</a> mechanism would
prevent 
the kernel from dereferencing the user-space addresses so that the
<tt>perf_swevent_enabled</tt> base address could not be calculated.  
The PaX/grsecurity <a
href="http://forums.grsecurity.net/viewtopic.php?f=7&t=3292">KERNEXEC</a>
technique would prevent the user-space shellcode from executing.  While these techniques can inhibit this kind of
bug from allowing privilege escalation, they impose costs
(e.g. performance) that have made them 
unattractive to the mainline developers. Suitably configured kernels on
hardware that supports it would be protected by <a
href="/Articles/517475/">supervisor mode access prevention</a> (SMAP) and
<a
href="http://forums.grsecurity.net/viewtopic.php?f=7&t=3046">supervisor
mode execution protection</a> (SMEP), the former would prevent access to
the user-space addresses much like UDEREF, while the latter would prevent
execution of user-space code as does KERNEXEC.
</p>

<p>
This is a fairly nasty hole in the kernel, in part because it has existed
for so long (and apparently been known by some, at least, for most of that
time).  Local privilege escalations tend to be somewhat downplayed because
they require an untrusted local user, but web applications (in particular)
can often provide just such a user.  Dave Jones's Trinity has clearly
shown its worth over the last few years, though he was <a
href="http://codemonkey.org.uk/2013/05/16/cve-2013-2094/">not terribly
pleased</a> 
how long it took for fuzzing to find this bug.
</p>

<p>
Jones suspects there may be "<q>more fruit on that branch
somewhere</q>", so more and better fuzzing of the perf system calls (and
kernel as a whole) is
indicated.  In addition, the exploit author at least suggests that he has
more exploits waiting in the wings (not necessarily in the perf
subsystem), it is quite likely that others do as well.  Finding and fixing
these security holes is an important task; auditing the commit stream to
help ensure that these 
kinds of problems aren't introduced in the first place would be quite useful.
One hopes that companies using Linux find a way to fund more work in this
area. 
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Vulnerabilities">Security/Vulnerabilities</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/550901/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor551316"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 21, 2013 23:01 UTC (Tue)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/551316/">Link</a>] (24 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; While these techniques can inhibit this kind of bug from allowing privilege escalation,</font><br>
<p>
sadly, this bug is the textbook example of the 'almost arbitrary write' kind and it *is* exploitable under PaX/grsecurity (well, after the attacker achieved arbitrary code execution in userland), albeit harder (needs a powerful enough kernel infoleak bug).<br>
<p>
<font class="QuotedText">&gt; they impose costs (e.g. performance) that have made them unattractive to the mainline developers.</font><br>
<p>
i have my doubts that mainline devs have ever cared let alone known about these techniques ;), besides these features are pretty much free on i386, only amd64 sucks for performance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551316/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551361"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 10:35 UTC (Wed)
                               by <b>vivo</b> (subscriber, #48315)
                              [<a href="/Articles/551361/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; these features are pretty much free on i386, only amd64 sucks for performance.</font><br>
The other way around right? amd64 is ok i386 suck<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551361/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551362"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 10:54 UTC (Wed)
                               by <b>patrick_g</b> (subscriber, #44470)
                              [<a href="/Articles/551362/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <i>> The other way around right? amd64 is ok i386 suck</i><br><br>
I don't think so. According to <a href="https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final143.pdf">this paper</a> :<br><br>
<i>The PaX-protected kernel exhibits a latency ranging between 5.6% and 257% (average 84.5%) on the x86, whereas on x86-64, the latency overhead ranges between 19% and 531% (average 172.2%). Additionally, (..) overhead for process creation (in both architectures) lies between 8.1% to 56.3%.</i><br><br>
And :<br><br>
<i>On x86, PaX offers protection against ret2usr attacks by utilizing the segmentation unit for isolating the kernel from user space. In x86-64 CPUs, where segmentation is not supported by the hardware, it temporarily remaps user space into a different location with non-execute permissions. (...) the
lack of segmentation in x86-64 results in higher performance penalty</i>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/551362/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 11:02 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/551365/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
now is that because the AMD64 is so bad, or because the stock kernel is tuned to be so much faster on AMD64 and these patches ruin that tuning.<br>
<p>
but either way, the attitude that the performance problem doesn't matter because it's not bad on the i386 port, only on the amd64 port is ignoring the fact that amd64 is becoming the common case, and people aren't going to use features that make their highest performing hardware suffer that much.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551366"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 11:29 UTC (Wed)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/551366/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
first, note that the kguard paper has very questionable numbers (they contradict my own measurements i've been doing for over a decade now), and when i tried to reproduce them, their gcc plugin didn't even compile so i don't know what exactly they'd done. i've been trying to fix it up ever since but it's a low priority project, so i'll blog about this topic some time later i guess ;).<br>
<p>
second, when i said 'these features' i specifically referred to Jake's sentence where he cites two PaX features that would protect against specific exploit techniques utilized by the public exploit (and there're more features that would protect against other exploit techniques but i digress).<br>
<p>
third, what attitude are you talking about? i never said anything about ignoring performance, just corrected Jake's statement that sounded like as if these features (remember, still talking about PaX) were universally bad for performance whereas both i386 and arm (recent addition by spender from earlier this year, see <a href="http://forums.grsecurity.net/viewtopic.php?f=7&amp;t=3292">http://forums.grsecurity.net/viewtopic.php?f=7&amp;t=3292</a>) have a very efficient implementation. in fact, if there's anyone who most appreciates the slow but steady income of hardware support for long existing PaX features (SMEP/SMAP for KERNEXEC/UDEREF, respectively) then it's me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551366/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor551367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 11:42 UTC (Wed)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/551367/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is because it depends for performance on an obsolete feature of the 32-bit x86 ISA (segmentation), which was almost completely removed in the cleanup during the design of the x86-64 ISA.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551372"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 12:09 UTC (Wed)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/551372/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
i would not call the effective removal of segmentation from amd64 a cleanup, more like the proverbial case of the baby going with the bathwater. sure, conforming code segments and call gates could be called obsolete, but the ability to define windows on the virtual address space is very useful (AMD had to add some of it back temporarily for VMware before hw virtualization caught on) and is a real shame that it got almost completely removed. it's a design mistake, not something to be proud of.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551372/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551414"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 16:43 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/551414/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite. It didn't even make the silicon appreciably simpler, because the CPU still has to drag it all around for 32-bit code, even while the CPU is in long mode (unlike vm86 which it can skip entirely and doesn't need to make particularly efficient in any case). The most they could do was drop optimizations for non-maximally-sized segments, and they did *that* before x86-64 was even thought of. It frees up some opcodes that they could reuse, is all.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551414/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor551448"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 19:37 UTC (Wed)
                               by <b>helge.bahmann</b> (subscriber, #56804)
                              [<a href="/Articles/551448/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
i386-style segmentation requires an add of the segment base for every address generation (or using a virtual cache which is a can of worms on its own), and while this is already not funny to do it on 32 bit without wrecking access latency (it is just barely manageable because it is possible to restrict the fast path to upper 20 bit adds), it becomes just very expensive going to 48 bit addresses (not even thinking of what would happen going to full 64 bit addresses). And yes, scrapping this add even on 32 bit is a saving significant enough to the point that current-gen CPUs short-circuit base=0 and pay a penalty otherwise.<br>
<p>
Segmentation anyways is a poor sustitute for what you *really* want: a full "world separation" between kernel and user, and this has since ages been possible e.g. on Sparc without any segmentation and much more efficiently using address space identifiers. And while amd64 took away segmentation, it also brought with virtualisation the ASIDs (admittedly, both are unfortunately annoyingly closely tied together).<br>
<p>
It might make more sense to look forward and maybe figure out if the new facilities can be used to do the isolation properly (and that may perhaps include talking to chip makers), rather than looking backward and mourning the loss of an oddball capability that enabled an incomplete hack.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551448/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551471"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 20:02 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/551471/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, x96 is not the entire world, it never was on the high-end, and with ARM and MIPS appliances, it's increasingly less so on the low-end. Right now x86 is the middle ground, but it's getting squeezed from the bottom the same way that amd64 is squeezing out the former high-end<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551471/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor551463"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 20:09 UTC (Wed)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/551463/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
first, the cost of non-0 bases is independent of width, the CPU already has full 64 bit adders just for this purpose (think support for 'lea' and fs/gs overrides). however for my purposes what is important is the ability to define segment limits and flip the meaning of that limit (lower or upper, for expand-down segments), so non-0 bases are pretty much irrelevant. <br>
<p>
second, segment limits are pretty much the best way to implement world separation, they require the least amount of hw resources: one parallelizable compare on the virtual address (i.e., it can be done before or in parallel to the virtual-&gt;physical translation) vs. tons of paging related caching while resolving the physical address. so no, i maintain that ditching all of segmentation was a design mistake and sparc or VT-x style ASIDs are not equivalent replacements (just ask Bromium for their performance numbers ;).<br>
<p>
third, while SMEP/SMAP are useful performance enchancements for amd64, they require quite a bit more kernel infrastructure to make them robust. in particular, since they rely on paging, *all* of the paging related structures must be properly protected against memory corruption bugs which is quite a bit larger attack surface than the GDTs (and no kernel i know does this work except for PaX). so while i 'mourn the loss of segmentation' (which is not as oddball as you think, and it's never been an incomplete hack) i've been doing the extra work for a decade now to make paging based replacements actually secure as well ;).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551463/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 21:06 UTC (Wed)
                               by <b>helge.bahmann</b> (subscriber, #56804)
                              [<a href="/Articles/551474/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
First, AFAICT fs/gs overrides (as well as lea) go through ALU and pay the access penalty exactly because there is no dedicated adder anymore, it would be a total waste of resources otherwise as segment overrides are in practice used just for TLS which is not that much of a fast path. (It is actually even more disturbing what happens with a base!=0 cs as it totally messes up the btb).<br>
<p>
Second, TLBs tagged with address space identifiers are actually cheaper and more generic than segment limits: You can save the comparators (even though they don't add latency because they can operate in parallel), and address space layout can be done at will. Since for separation the ranges are inteded to be disjoint, both approaches will actually have the same TLB foot print, so no advantages here for segment limits either.<br>
<p>
VT-x style ASIDs are only poor due to their tie-in with, err, VT-x, their equivalents work just fine on every architecture that has been designed with address space identifiers (under their various names, as context/thread/process/... identifiers) to begin with (and BTW have more general applications for fast thread switching etc.). As for the paging-related caching: You don't get rid of that using segment limits, you just pile another layer on top.<br>
<p>
As for the attack surface regarding page tables: Why do you think it is easier to protect page tables mapping virtual address space [kern_start;kern_end) in the segment limit case, than it is to protect page tables mapping asid=kern in the asid case? (Rhetorical question, as there is no difference, so the whole argument regarding paging is a red herring).<br>
<p>
And yes x86 segmentation is oddball in that it has never been designed for what it is now being used for, is difficult to make efficient in hardware, while address-space-based methods are both easy to make efficient and can more explicitly support the intended separation semantic. Considering segmentation to be the best solution to the problem is suffering quite a bit from Stockholm syndrome ;)<br>
<p>
Really I don't question your accomplishments, but segmentation is a shallow local minimum, and while infinite effort can be spent trying to micro-optimize beside this minimum, there are far deeper local minima (and many of them outside x86).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551505"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2013 23:33 UTC (Thu)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/551505/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
1. the ALU concept is so 80's ;). seriously, 'modern' CPUs are a tad bit more complex, Intel and AMD CPUs have all dedicated adders for address calculations (not just for the already mentioned purposes but also for rip-relative addressing). TLS not being a fast path is probably news to everyone spending their time on multithreaded applications, and Intel, in the grand conspiracy of schemes, must have added dedicated fs/gs base manipulating insns to their latest CPUs in order to slow these workloads down even more. as for the BTB, isn't it indexed by virtual and not logical addresses?<br>
<p>
2. ASIDs cannot by definition be cheaper, paging related caches and checks will always require more circuits and cycles than a simple comparator. not sure what address space layout decisions have to do with this though, when you have ASIDs by definition you have full address spaces for each ASID. if you meant mixing different ASIDs in the same virtual address space (how?), then nobody does that.<br>
<p>
conceptually ASIDs are indeed more generic except this fact is utterly irrelevant, there isn't a mainstream OS out there that would make use of this ability (i.e., mix user and kernel pages in arbitrary ways in the same address space). in practice everyone simply divides the virtual address space into two parts between userland and the kernel, so simple limit checking would do just fine (vs. checking access rights at every level of the paging hierarchy).<br>
<p>
3. ASIDs do have their uses indeed, in fact i would love to have a better mechanism on Intel/AMD CPUs to implement some of my ideas but for simple user/kernel separation a segment limit check has no match.<br>
<p>
4. to understand the difference in the security level provided by a segmentation and paging based non-exec/no-access kernel protection scheme we have to consider the attacker's assumed ability. against an arbitrary read and write capability they're equivalent. however this is the ideal attacker model only we use to evaluate theoretical boundaries of protection schemes, in practice we rarely get such bugs and that's exactly where the difference becomes important. in particular, the segmentation based approach can achieve a certain level of self-protection by simply ensuring that the top-level page tables enforce the read-only property on the GDTs whereas doing the same for page tables themselves is much harder - this is the attack surface difference. that said, KERNEXEC (on i386/amd64 so far) does attempt to minimize the exposure of top-level page tables but it's far from being a closed system yet (breaking up kernel large page mappings, tracking virtual aliases, etc have non-negligible performance impact).<br>
<p>
5. what has segmentation been designed for then? surely there's only so much you can do with a data or code segment ;). why is it difficult to make it efficient in hardware? and which particular bit (there're many descriptor types)? why would paging related data structures be easier to handle in hw than segmentation ones? and how do you imagine beating a simple comparator? so far you haven't offered any facts to make me think otherwise.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551505/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551744"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2013 8:53 UTC (Fri)
                               by <b>helge.bahmann</b> (subscriber, #56804)
                              [<a href="/Articles/551744/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
1. Sure it's not a single 80s style alu anymore, rather it is a set of independently operating arithmetic units; typically two are adders, and whatever is needed is scheduled to them (addr gen or general arithmetic alike). Doing anything else is wasteful (which is to say that it is done nevertheless occasionally *if* it can speed up a fast-path, which for address calculations it cannot).<br>
<p>
2. TLS is not a fast path, profiling shows around 1 in 1000 to 10000 instructions is TLS, so no one bothers paying a 1 cycle penalty for that.<br>
<p>
3. ASIDs are cheaper because they just become part of the tag in the TLB. You do the TLB lookup (which you do anyways) and compare the tag for equality which is cheaper than a "greater than" comparison against an address space limit (which, incidentally, is just another adder), end of story.<br>
<p>
4. Enforcing read-only is easily done at the page level, so what's the point?<br>
<p>
5. What segmentation has been designed for? To map the concept of program object segments (the name may be a hint, right?) directly to hardware, facilitate sharing and relocatability this way. This is also where the security model for them originates from. It was conceived when people were somehow not yet certain paging was scalable, but I am too young to have been involved back then, you would have to ask the 'bearded guys'.<br>
<p>
And to answer your last question: Paging is cheaper because hashed lookup (TLB) and equality comparison are cheaper than "less than" comparisons in hardware. Segmentation is a conceptual dead-end, live with it :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551744/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551755"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2013 12:00 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/551755/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a "bearded guy" (I have no beard) who has written designed and written bios's and protected mode operating systems x86, and who had to look at the x86 architecture in detail again in mind numbing detail (as in reading the 4 Intel x86 "data sheets" several times in order to port linux-abi system to AMD64), I recall my thoughts at the time as being "my - AMD has cleaned this mess up".<br>
<p>
For those of you defending Intel's decisions at this time - I lived through it.  At the time Intel regarded all programmers as idiots, and decided to solve the problem with hardware.  Thus we have the absurdly complex designs we see today, with x86 interrupts taking 2000 cycles (?!?!? - that was back when Intel was game enough to publish cycles) and it wasn't the slowest instruction.  Can anyone remember a Task Gate Descriptor?<br>
<p>
Yet that wasn't the worst of it. The worst of the worst died.  It was a new Intel architecture called iAPX432.  It caused more excitement than Haswell in it's day.  I am sure it's forebears would prefer we forgot it entirely.  It remains in my mind the ultimate testimony to the arrogance caused by ignorance, in this case the Electrical Engineers thinking they could tell Software Engineers how we should do our jobs.  But I exaggerate.  Back then we weren't allowed to call ourselves Engineers.<br>
<p>
Still they got their revenge with x86.  In it they made it plain we could not be trusted to swap between two tasks quickly.  Only 30 years later with the advent of ARM has their folly been made plain to everyone.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551755/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551760"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2013 13:40 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/551760/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
you aren't going nearly far enough back<br>
<p>
segmentation on the x86 came about with the 80286 (or possibly even the 80186, I'm not sure) CPU.<br>
<p>
It was intended as a way to allow programs to continue to use 16 bit 8086 addressing but be able to use more than 64K of ram in a system (by setting a segment offset and then running the 16 bit code inside that segment)<br>
<p>
It never was an effective security measure, because to avoid wasting tons of memory on programs that didn't need it, the segments overlap, allowing one program to access memory of another program.<br>
<p>
When the 80386 came out and supported paging and real memory protection, everyone stopped using segments real fast<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551760/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2013 23:31 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/551820/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; segmentation on the x86 came about with the 80286 (or possibly even the 80186, I'm not sure) CPU.</font><br>
<p>
8086 actually.  It was their way of extending the address space of the 8080 to 20 bits.<br>
<p>
It was just a slightly more sophisticated take on the way CPU designers have gone about extending the range of addressable memory beyond the natural size of internal registers for eons.  It had the advantage you could use separate address spaces for both code and data, giving you 64K for each.  So by using a small amount of extra silicon they effectively doubled the amount of address space you had over simple "page extension" hack everybody else was doing.  Kudos to them.<br>
<p>
So you are saying it was the 80286 is where the rot set it.  In the 80286 they had enough silicon to give the programmer true isolation between processes.  They could of gone the 32 bits + page table route everybody else did, but no we got segmentation (without page tables instead) and retained 16 bit registers.  Why?  Well this was also the time the hardware designers had enough silicon to implement microcode - so they could become programmers to!  And they decided they could do task switching, ACL's and god know what else better than programmers, so they did.  In other words somehow they managed to forget their job was to provide hardware that ran programs quickly, and instead thought their job was to do operating system design.<br>
<p>
It was a right royal mess.  Fortunately for them the transition from DOS to Windows / OS2 (which is where the extra protections and address space matters) took a while, and by then the i386 was released.  It added 32 bits and paging, so we could ignore all that 16 bit segmentation rubbish and get on with life.  It turned out the transition to multitasking operating systems wasn't waiting on programmers figuring out had to do it (who would have thunk it?), but rather the price of the RAM needed to hold several tasks at once had to come down.<br>
<p>
People here defending the segmentation model should try writing for the 80286, which could only address 64K of code and 64K of data at any one time.  There was no reason for it.  The 68000 family had a much better memory model at the time, so it wasn't silicon constrains.  Well there would have been enough silicon if they hadn't devoted so much of it to creating their own operating system on a chip.<br>
<p>
Intel finally came to their senses with Itanium. With it they used all that extra silicon to do what hardware designers should be doing - make programs run fast.  Sadly it came along too late.<br>
<p>
Back to your point - the time line.  The 80286 was released in 1982.  The iAPX432 was meant to be released in 1981.  The 80286 was the fall back position.  As Wikipedia points out, this is a part of its history Intel strives to forget.  You will find no mention of the iAPX432 on their web site, for instance.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2013 23:50 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/551828/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; 8086 actually. It was their way of extending the address space of the 8080 to 20 bits.</font><br>
<p>
That's right, I forgot about that. And IIRC, with the 286 they only expanded it to 24 bits<br>
<p>
but in any case, my point was that the dawn of the AMD64 chip is eons past the point where segmentation was introduced, failed, and was rejected<br>
<p>
P.S. I disagree with you about the Itanium. It wasn't a good design. They took far more silicon than other processors and ended up being less productive with it.<br>
<p>
In part, the speed increases were the cause of this failure. As the speed differences between memory and the CPU core get larger, having a compact instruction set where each instruction can do more, becomes more important, and for all it's warts, the x86 instructions do rate pretty well on the size/capability graph.<br>
<p>
but in part the programmers really should NOT have to change their programs to work well on a new CPU where the hardware designers have implemented things differently. By hiding such changes in the microcode, instructions that get used more can be further optimized, and ones that aren't can be emulated so they take less silicon. It's a useful layer of abstraction.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551830"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 25, 2013 0:21 UTC (Sat)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/551830/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; P.S. I disagree with you about the Itanium. It wasn't a good design. They took far more silicon than other processors and ended up being less productive with it.</font><br>
<p>
I wasn't commenting whether it was a good design.  I don't know, as I haven't used it.  I was just saying Itanium marked the point when Intel went back to sticking to the knitting - in other words trying to design a new architecture whose sole goal was to run programs fast.  If you say they failed despite having that explicit goal then that's a shame.<br>
<p>
As I recall the Itanium tried to improve it's speed in a RISC like way - ie by keeping things simple on the hardware side and offloading decisions to the compiler.  In the Itanium's case those decisions were about parallelism.<br>
<p>
I think it's pretty clear now tuning the machine language to whatever hardware is available at the time is a mistake when you are going for speed.  It might work when the hardware is first designed, but then the transistor budget doubles and all those neat optimisations don't much so much sense anymore, but you are welded to them because there are hardwired into the instruction set.  Instead the route we have gone down is to implement a virtual CPU, rather like the JVM.  The real CPU then compiles the instruction set on the fly into something that can be run fast with todays transistor budget.  With tomorrows transistor budget it might be complied into something different.<br>
<p>
The x86 instruction set is actually good pretty in this scenario - better than ARM.  It's compact, and each instruction gives lots of opportunities to execute bits of it in parallel.  If this is true, then Intel ending up with an architecture that can run fast is just dumb luck, as they weren't planning for it 30 years ago.  Now that I think about it, the VAX instruction set would probably be even better again.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551830/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor551849"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 25, 2013 10:36 UTC (Sat)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/551849/">Link</a>] 
      </p>
      
      </div>
      </summary>
      192k of data (point DS, ES, SS to different segments).
      
          <div class="CommentReplyButton">
            <form action="/Articles/551849/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor551951"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 27, 2013 22:06 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/551951/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a guy who used to do stuff with Arcs, '30 years later with the advent of ARM' is bizarre. ARMs of a sort were around in the early 90s :) but, sure, they hadn't set the world on fire yet.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551951/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor551748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2013 9:16 UTC (Fri)
                               by <b>helge.bahmann</b> (subscriber, #56804)
                              [<a href="/Articles/551748/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just as an addendum... Don't get me wrong, you are right to complain that a mechanism that was usable for security purposes was removed while nobody bothered to add a suitable substitute, and that all of the pretty architectural ideas that had already been present and demonstrated to be workable for 25+ years now had been ignored, but the "proper" way going forward is not to revive segmentation but implement comparable semantics with mechanisms that are performance-neutral. SMEP and SMAP are actually quite "easy" from a hardware conceputal point of view, so it is kind of annoying that it took so long.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor551736"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2013 7:35 UTC (Fri)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/551736/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
From a security point of view amd64 _is_ bad, especially compared to older architecture like sparc which provide fully separated kernel and user address space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551736/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551739"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2013 7:48 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/551739/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
if they were so fully separated, how could you pass data between them?<br>
<p>
Even if true, it just shows that price and performance trump low probability security benefits once again, so what's new?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551739/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551757"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 24, 2013 12:43 UTC (Fri)
                               by <b>helge.bahmann</b> (subscriber, #56804)
                              [<a href="/Articles/551757/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sparc has instructions "load from foreign address space" and "store to foreign address space" (and even "compare and swap in foreign address space").<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551757/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor551320"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 21, 2013 23:39 UTC (Tue)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/551320/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Kernels configured without support for perf events (i.e. </font><br>
<font class="QuotedText">&gt; CONFIG_PERF_EVENTS not set) are unaffected by the bug as they lack</font><br>
<font class="QuotedText">&gt; the system call entirely. </font><br>
<p>
As far as I know it's not possible to disable perf_event on x86 since about 2.6.37 or so, because it is automatically enabled to get debugger support.  I'd be glad to be proven wrong though.<br>
<p>
As far as trinity support, better perf_event_open() coverage that I contributed was merged today, so everyone can fuzz away.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551320/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 21, 2013 23:43 UTC (Tue)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/551321/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As far as trinity support, better perf_event_open() coverage that I</font><br>
<font class="QuotedText">&gt; contributed was merged today, so everyone can fuzz away.</font><br>
<p>
Also, the new trinity support isn't as complete as it could be.  Check out my perf_event_open() manpage linked above.  The perf_event system call is fantastically complex with over 40 inter-dependent arguments that interact in complex ways.<br>
<p>
I still sometimes wish that a thinner perf counter interface was merged.  perfctr and perfmon2 both were much thinner wrappers over the perf counter MSRs.  The "put everything in the kernel" strategy for perf_event makes it that hard to validate correctness.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor551318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 21, 2013 23:45 UTC (Tue)
                               by <b>gerdesj</b> (subscriber, #5446)
                              [<a href="/Articles/551318/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; This is a fairly nasty hole in the kernel</font><br>
<p>
Or perhaps a fairly nasty hole in a subsystem within the kernel which you may or may not be using.<br>
<p>
For a laugh (I'm back in a hotel having fixed a knackered RHEL box quicker than anticipated) I ran that sheep.c code on my laptop.  I'm no C expert but after a read through it looked innocuous enough apart from the job it has to do.  <br>
<p>
It died badly and a quick play with strace showed why.<br>
<p>
Yes: It was bloody Gentoo not forcing me to enable every possible feature that I may never use.  Bloody non Enterprise ready OS distros.<br>
<p>
Cheers<br>
Jon<br>
<p>
PS Actually a temporary KVM on my laptop with a basic copy of the host FS to play with.<br>
<p>
PPS Must get around to looking into perf - perhaps I'll start installing it and the kernel bits when I need it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551323"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 0:05 UTC (Wed)
                               by <b>gerdesj</b> (subscriber, #5446)
                              [<a href="/Articles/551323/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On reflection and now I've bothered to check I DO have perf enabled, what about treating kernel modules in a similar way to say PHP extras like cURL in Ubuntu? (I only say Ubuntu because I have some experience there - I'm sure others have similar policies)<br>
<p>
There must be a "disto required subset" that needs to be installed at initial installation time and then only add the extra modules when a package is installed?<br>
<p>
I admit this would probably add rather a lot of extra work if too granular but might assist mitigating unforeseen future snags.<br>
<p>
For example have a distro basic kernel and then exclude all V4Lx drivers on a server.  Even on a server version, install V4L mods if say Myth was installed.<br>
<p>
Cheers<br>
Jon<br>
<p>
PS Wonder why the sheep thing didn't work then although it was described as fragile.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551323/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551326"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 1:29 UTC (Wed)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/551326/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; On reflection and now I've bothered to check I DO have perf enabled, </font><br>
<font class="QuotedText">&gt; what about treating kernel modules in a similar way to say PHP extras</font><br>
<font class="QuotedText">&gt; like cURL in Ubuntu? (I only say Ubuntu because I have some experience </font><br>
<font class="QuotedText">&gt; there - I'm sure others have similar policies)</font><br>
<p>
People keep going on about disabling perf_event or using it as a module.<br>
<p>
perf_event *cannot* be configured as a module, and it *cannot* be disabled on X86.  It's always there.  And you can't disable it after boot either.<br>
It looks like this was introduced explicitly by cc2067a51424dd25 in Nov 2010 but the dependency existed before because HAVE_HW_BREAKPOINT (default on x86) depends on PERF_EVENTS.<br>
<p>
Maybe it's time for a /proc/sys/perf_event_paranoid value of "3" meaning no perf_events at all.<br>
<p>
I must admit I'm of two minds of this.  As a HPC researcher the main positive feature of perf_event was the fact that it was available everywhere by default, negating the previous hassle of having to get sysadmin intervention to do performance analysis.  It would be sad to return to those days, but I guess security trumps convenience.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551326/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551347"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 7:39 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/551347/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite. This API is too damn complicated (and people complained that dtrace was too complicated, bah!). I don't plan to do performance analysis on my little memory-constrained network-facing firewall: why am I obliged to carry the perf machinery there?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551347/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551350"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 9:11 UTC (Wed)
                               by <b>Frej</b> (guest, #4165)
                              [<a href="/Articles/551350/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd blame the language rather than the API. The best innovation in any kernel would be to stop using unsafe languages or at least limiting usage. Ofcourse this won't help every security issue, but every crash seems to be these days.<br>
<p>
The research is out there and has been for a long time (see cyclone), hopefully rust (somewhat similar in ideas) will show a viable way forward.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551350/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 10:34 UTC (Wed)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/551360/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A "safe language" would be in fact equivalent to a "bug-free language", which is absurd, of course.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551368"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 11:46 UTC (Wed)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/551368/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is a whole lot of ground between a hypothetical "bug-free language", a language that makes it harder to write problematic constructs, a language that warns about use of dubious constructs and a language in the land where all people carry BFGs (without a safety) and walking around with size 150 shoes.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551368/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor551484"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 20:50 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/551484/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Safe language" is actually well-defined. It means a language where it's impossible to cause memory corruption, which is certainly possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551484/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551574"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2013 9:17 UTC (Thu)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/551574/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's no way to prevent memory corruption, as long as I can write to the wrong variable (ooops!). Memory protection is a feature of the underlaying machine, not the language.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551574/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551602"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2013 12:32 UTC (Thu)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/551602/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Uh? Your definition of memory protection is different from the normal definition which makes your post quite useless..<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551602/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor551608"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2013 12:46 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/551608/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Write a wrong value _where_?<br>
<p>
And yes, it's totally possible to create a language (hint: Java, C#) that do NOT require hardware memory protection at all to isolate misbehaving applications.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551608/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 27, 2013 17:13 UTC (Mon)
                               by <b>dgm</b> (subscriber, #49227)
                              [<a href="/Articles/551931/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Write a wrong value _where_?</font><br>
<p>
Anywhere it was not intended to be, but mostly strings, specially strings that are interpreted by the program.<br>
<p>
<font class="QuotedText">&gt; And yes, it's totally possible to create a language (hint: Java, C#) that do NOT require hardware memory protection at all to isolate misbehaving applications.</font><br>
<p>
It's not the language but the virtual _machine_ they run on what isolates misbehaving applications. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551962"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 27, 2013 23:51 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/551962/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Anywhere it was not intended to be, but mostly strings, specially strings that are interpreted by the program.</font><br>
That won't cause memory damage.<br>
<p>
<font class="QuotedText">&gt; It's not the language but the virtual _machine_ they run on what isolates misbehaving applications. </font><br>
Nope. If your language allows unrestricted pointer arithmetic then it doesn't matter at all if you are running it inside the most secure VM.<br>
<p>
And if your language simply doesn't have a way to express pointer arithmetic then you can't use it to do memory damage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551962/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551981"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 28, 2013 8:59 UTC (Tue)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/551981/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And if your language simply doesn't have a way to express pointer arithmetic then you can't use it to do memory damage.</font><br>
<p>
IHMO you can't use that language to manage the memory neither, i.e. you can't write malloc()/free() nor what the kernel needs, for instance "allocate a contiguous DMA able buffer accessible with DMA32 PCI card and fail if a wait is needed and give back it's physical address" or "free memory blocks after DMA hardware has finished sending them", or any variation of it.<br>
Obviously if you had perfect hardware and a processor with an "allocate_memory" and a "free_memory_after_both_software_and_DMA_have_finished_with_it" assembly instruction, then maybe...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551981/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551982"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 28, 2013 9:06 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/551982/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You can certainly do it. You won't be able to do free() unless you can statically prove its correctness, but doing malloc() and using GC to collect unused objects is possible.<br>
<p>
You also certainly can allocate buffers with special properties, and you can even do stuff like reading from within buffers by using fat pointers (i.e. a pointer with a length).<br>
<p>
In fact, it's all been done in the past even for OS kernels. It's the question of practicality, not possibility.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551982/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor551412"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 16:40 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/551412/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'd blame the language *as well* as the API. C makes it very easy to write insecure and buggy code, but the API being ridiculously complex gives you a lot of corners to make undetected-until-too-late mistakes in. I don't see how anyone could be confident that anything of that complexity was secure :/<br>
<p>
(This is really the same complaint I have about SELinux policies. I *like* complexity, but Schneier is right: it is the enemy of security -- and the entire programmer profession is helping out. Including me. Ah well.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551412/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor551433"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 18:07 UTC (Wed)
                               by <b>ebiederm</b> (subscriber, #35028)
                              [<a href="/Articles/551433/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Show me a type system that I can accurately type functions written in assembly, and I will believe there are safe languages that could be used.<br>
<p>
Until we can stop escaping the type-system in a kernel there is no such thing as a safe language.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551433/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551485"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 20:51 UTC (Wed)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/551485/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Show me a type system that I can accurately type functions written in assembly</font><br>
Your wish is my command: <a rel="nofollow" href="http://www.cs.cornell.edu/talc/">http://www.cs.cornell.edu/talc/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551485/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551536"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2013 4:34 UTC (Thu)
                               by <b>ebiederm</b> (subscriber, #35028)
                              [<a href="/Articles/551536/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Talx86 can not accurately type programs encoded in assembly.<br>
<p>
There are no dependent types for allowing the removal of bounds checks in array updates.  Instead magic array macros must be used.  (Not supporting general memory accesses is a signification failure in adding types to assembly language).<br>
<p>
There is no support for multiprocessing.<br>
<p>
There is no support for support for manual memory management.  Talx86 requires a garbage collector.<br>
<p>
Which means a large number of common kernel constructs can not be encoded in this assembler.  We are unfortunately quite a ways from safe languages that can be used for kernel programming.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551536/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551537"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2013 4:39 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/551537/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Dependent types can be feasibly added and fat pointers are already supported in hardware (on a couple of exotic architectures, but still).<br>
<p>
I don't see much problems with multithreading, though memory model formalization should be quite interesting.<br>
<p>
Garbage collector of some sort seems inevitable in any case. Perhaps with some kind of region inference to help with short-lived allocations. In some limited cases it may be possible to use static proofs of correctness.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551537/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor552092"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 29, 2013 5:41 UTC (Wed)
                               by <b>schabi</b> (guest, #14079)
                              [<a href="/Articles/552092/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I agree.<br>
<p>
Interpreting unsigned 64 bit IDs as signed 32 bit is exactly what I'd expect to generate at least a compiler warning. Even in C, this should have been caught by good compilers or static analysis tools.<br>
<p>
So, what went wrong?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/552092/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor551890"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 26, 2013 13:03 UTC (Sun)
                               by <b>spender</b> (guest, #23067)
                              [<a href="/Articles/551890/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've uploaded the definitive exploit for the vulnerability here:<br>
<a href="http://grsecurity.net/~spender/exploits/enlightenment.tgz">http://grsecurity.net/~spender/exploits/enlightenment.tgz</a><br>
<p>
It should work on any distro, x86 or x64, with any combination (or lack of) CONFIG_MODULES and CONFIG_JUMP_LABEL.  I've personally tested it on RHEL, Ubuntu, Debian, and Gentoo, custom kernels and distro kernels: 2.6.32 (RHEL), 2.6.38, 3.0, 3.2, 3.5, 3.8.  It requires no System.map or /proc/kallsyms on x64 (even though a System.map could be trivially obtained, or the symbols extracted from the visible kernel image in /boot instead).  Once it gains control in the kernel it resolves symbols internally.  Its generic ring0 payload (reusable with any other kernel exploit where the attacker controls eip/rip) disables SELinux, AppArmor, IMA -- all LSMs.  It breaks out of any chroot or mnt namespace.  It breaks out of vserver and OpenVZ.  It creates no logs and leaves the system in a consistent state.<br>
<p>
The initial port was completed last week:<br>
<a href="http://www.youtube.com/watch?v=WI0FXZUsLuI">http://www.youtube.com/watch?v=WI0FXZUsLuI</a><br>
<a href="http://www.youtube.com/watch?v=llqxbMgIztk">http://www.youtube.com/watch?v=llqxbMgIztk</a><br>
<p>
I delayed publication a week to give people more time to update, but this exploit should be considered a demonstration of the true risk of depending on patching individual bugs as a means to security or in using shared-kernel virtualization without any kind of kernel self-protection.  The techniques in the exploit, some of which have never been published before, are the kinds of techniques that are used and sold in private.<br>
<p>
-Brad<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551890/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor551328"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bug class</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 2:18 UTC (Wed)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/551328/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Would it be possible to add a check to something like sparse to detect this class of bug (value being truncated by being assigned from a larger type to a smaller type)? And the related sign confusion class of bug (assigning from unsigned to signed or vice versa without checking the range first)?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551328/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bug class</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 5:25 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/551344/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect that there are a whole heap of places in the kernel where this happens; most are probably perfectly sane and don't need to be checked, because the resulting value is not used as an offset to index anything.<br>
<p>
Long-term, of course, that's not an excuse not to do the work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor551353"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bug class</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 9:28 UTC (Wed)
                               by <b>mcfrisk</b> (guest, #40131)
                              [<a href="/Articles/551353/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn't Coverity find this already?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551353/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor551373"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bug class</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 12:28 UTC (Wed)
                               by <b>PaXTeam</b> (guest, #24616)
                              [<a href="/Articles/551373/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; [...]to detect this class of bug (value being truncated by being assigned from a larger type to a smaller type)</font><br>
<p>
it's not true that casting a value from a wider type to a narrower one is a bug in general (think how often long-&gt;int happens when error codes are returned in the kernel) so detecting that construct would produce immense amounts of false positives (based on our own experiments last year we're talking about many thousands of instances for allyesconfig/amd64). and even if the value is not preserved during the narrowing cast it may not be a bug but intended behaviour and it's very hard to tell for a compiler.<br>
<p>
with that said, Emese Revfy wrote a gcc plugin for us that tries to detect this specific instance of unchecked signed array index usage. the results are somewhat more managable, there're about 200 instances on allmod/amd64, most of which are false positives (interprocedural analysis, etc would help eliminate most of them, but that's not a half an hour project as this one was), however some of them look genuine bugs, albeit nothing security related so far (of those that i checked that is).<br>
<p>
<font class="QuotedText">&gt; And the related sign confusion class of bug (assigning from unsigned to</font><br>
<font class="QuotedText">&gt; signed or vice versa without checking the range first)?</font><br>
<p>
the size overflow plugin from Emese (<a href="http://forums.grsecurity.net/viewtopic.php?f=7&amp;t=3043">http://forums.grsecurity.net/viewtopic.php?f=7&amp;t=3043</a>) does this but we had to scale it back due to the amount of false positives (even gcc creates these itself during canonicalization), as it's just not feasible to eliminate such constructs for now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551373/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor551378"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bug class</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 13:35 UTC (Wed)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/551378/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; and even if the value is not preserved during the narrowing cast it may not be a bug but intended behaviour and it's very hard to tell for a compiler.</font><br>
<p>
If the narrowing losing the higher bits is intended behavior, the programmer should either use an explicit cast instead of an implicit one (x = (int)y instead of int x = y), or explicitly mask out the upper bits (x = y &amp; 0xffffffffu). This would be similar to having to add an extra pair of parenthesis when using bitwise operators within an if/while/for, and would also make it more visible to readers of the code that the narrowing is taking place. So this class of false positives (intentionally masking by narrowing) is not a problem.<br>
<p>
However, I do agree that the rest of the false positives would be a problem. What would be needed would be a way to somehow track the range of the variables, so the checker would know that for instance the variable being narrowed is in the range -1..-4095 (the error code case).<br>
<p>
<font class="QuotedText">&gt; however some of them look genuine bugs, albeit nothing security related so far (of those that i checked that is).</font><br>
<p>
Will they be reported upstream? A bug is a bug, so even if they are not security related, they should be fixed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551378/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor551585"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Bug class</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 23, 2013 10:41 UTC (Thu)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/551585/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Smatch theoretically can find buffer underflows.<br>
<p>
In this case it missed for several reasons.  1) This wasn't getting marked as untrusted user data.  2)  The cross function tracking wasn't working.  3) The underflow check was ignoring if we capped the upper value.  *eyeroll*<br>
<p>
I haven't pushed all the Smatch changes yet, but it's sort of working now to the point where it would have found this bug.  It did find a couple problems in ATM network drivers as well.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551585/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor551380"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">An unexpected perf feature</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 22, 2013 13:45 UTC (Wed)
                               by <b>fuhchee</b> (guest, #40059)
                              [<a href="/Articles/551380/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"At that time, it was not recognized as a security problem ..."<br>
<p>
The passive voice underlines the uncertainty.  One can certainly take Greg at his word that he didn't realize it.  However, the absence of formal treatment at the security@ mailing list by others is just as consistent with unawareness as with sweeping-under-the-rug.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/551380/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
