        <!DOCTYPE html>
        <html lang="en">
        <head><title>3.0 and RCU: what went wrong [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/453002/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/452580/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/453002/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>3.0 and RCU: what went wrong</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="GAByline">
           <p>July 27, 2011</p>
           <p>This article was contributed by Paul McKenney</p>
           </div>
<p>My goal has always been for my code to go in without so much as a
ripple.  Although I don't always meet that goal, I can't recall any
recent failure quite as spectacular as <a
href="http://lwn.net/Articles/452269/">RCU in v3.0</a>.  My v3.0 code
didn't just cause a few ripples, it bellyflopped.  It is therefore
worthwhile to review what happened and why it happened in order to avoid
future bellyflops and trainwrecks.  
</p>
<p>This post-mortem will cover the following topics:
</p>

<ol>
<li>	<a href="#Overview of Preemptible RCU Read-Side Code">
	Overview of preemptible RCU read-side code</a>
<li>	<a href="#Steaming Towards the Train Wreck">
	Steaming towards the trainwreck</a>
<li>	<a href="#Fixes">Fixes</a>
<li>	<a href="#Current Status">Current status</a>
<li>	<a href="#Preventing Future Bellyflops and Trainwrecks">
	Preventing future bellyflops and trainwrecks</a>
</ol>

It will end with the obligatory
<a href="#Answers to Quick Quizzes">answers to the quick quizzes</a>.

<h4><a name="Overview of Preemptible RCU Read-Side Code">
Overview of preemptible RCU read-side code</a></h4>

<p>Understanding the trainwreck requires reviewing a small amount of
<code>TREE_PREEMPT_RCU</code>'s read-side code.
First, let's look at <code>__rcu_read_lock()</code>, which, in preemptible
RCU, does the real work for <code>rcu_read_lock()</code>:
</p>

<pre>
  1 void __rcu_read_lock(void)
  2 {
  3   current-&gt;rcu_read_lock_nesting++;
  4   barrier();
  5 }
</pre>

<p>This is quite straightforward: line&nbsp;3 increments the per-task
<code>-&gt;rcu_read_lock_nesting</code> counter and line&nbsp;4 ensures
that the compiler does not bleed code from the following RCU read-side
critical section out before the <code>__rcu_read_lock()</code>.
In short, <code>__rcu_read_lock()</code> does nothing more than
to increment a nesting-level counter.
</p>

<p>The <code>__rcu_read_unlock()</code> function, which, in preemptible RCU,
does the real work for <code>rcu_read_unlock()</code>, is only slightly more
complex:
</p>

<pre>
  1 void __rcu_read_unlock(void)
  2 {
  3   struct task_struct *t = current;
  4 
  5   barrier();
  6   --t-&gt;rcu_read_lock_nesting;
  7   barrier();
  8   if (t-&gt;rcu_read_lock_nesting == 0 &amp;&amp;
  9       unlikely(ACCESS_ONCE(t-&gt;rcu_read_unlock_special)))
 10     rcu_read_unlock_special(t);
 11 }
</pre>

<p>Line&nbsp;5 prevents the compiler from bleeding code from the
RCU read-side critical section out past the <code>__rcu_read_unlock()</code>,
line&nbsp;6 decrements the per-task nesting-level counter, so that thus
far <code>__rcu_read_unlock()</code> is the inverse of
<code>__rcu_read_lock()</code>.
</p>

<p>However, if the value of the nesting counter is now zero,
we now need to check to see if anything unusual happened
during the just-ended RCU read-side critical section,
which is the job of lines&nbsp;8 and&nbsp;9.
Line&nbsp;7 prevents the compiler from moving this check to precede
the decrement on line&nbsp;6 because otherwise something unusual might
happen just after the check but before the decrement, which would
in turn mean that <code>__rcu_read_unlock()</code> would fail to
clean up after that unusual something.
The "unusual somethings" are:
</p>

<ol>
<li>	The RCU read-side critical section might have blocked or
	been preempted.
	In this case, the per-task <code>-&gt;rcu_read_unlock_special</code>
	variable will have the
	<code>RCU_READ_UNLOCK_BLOCKED</code> bit set.
<p>
<li>	The RCU read-side critical section might have executed for
	more than a jiffy or two.
	In this case, the per-task <code>-&gt;rcu_read_unlock_special</code>
	variable will have the
	<code>RCU_READ_UNLOCK_NEED_QS</code> bit set.
</ol>

<p>In either case, the per-task <code>-&gt;rcu_read_unlock_special</code>
will be non-zero, so that <code>__rcu_read_unlock()</code> will invoke
<code>rcu_read_unlock_special()</code>, which we look at next:
</p>

<pre>
  1 static void rcu_read_unlock_special(struct task_struct *t)
  2 {
  3   int empty;
  4   int empty_exp;
  5   unsigned long flags;
  6   struct rcu_node *rnp;
  7   int special;
  8 
  9   if (in_nmi())
 10     return;
 11   local_irq_save(flags);
 12   special = t-&gt;rcu_read_unlock_special;
 13   if (special &amp; RCU_READ_UNLOCK_NEED_QS) {
 14     rcu_preempt_qs(smp_processor_id());
 15   }
 16   if (in_irq()) {
 17     local_irq_restore(flags);
 18     return;
 19   }
 20   if (special &amp; RCU_READ_UNLOCK_BLOCKED) {
 21     t-&gt;rcu_read_unlock_special &amp;= ~RCU_READ_UNLOCK_BLOCKED;
 22 
 23     /* Clean up after blocking. */
 24 
 25   }
 26 }
</pre>

<p>Lines&nbsp;9 and 10 take an early exit if we are executing in
non-maskable interrupt (NMI) context.
The reason for this early exit is that NMIs cannot be interrupted
or preempted, so there should be no <code>rcu_read_unlock_special()</code>
processing required.
Otherwise, line&nbsp;11 disables interrupts and line&nbsp;12 takes a
snapshot of the per-task <code>-&gt;rcu_read_unlock_special</code>
variable.
Line&nbsp;13 then checks to see if the just-ended RCU read-side
critical section ran for too long, and, if so, invokes
<code>rcu_preempt_qs()</code> to immediately record a quiescent state.
Recall that any point in the code that is not in an RCU
read-side critical section is potentially a quiescent state.
Therefore, since someone is waiting, report the quiescent state
immediately.
</p>

<p>Lines&nbsp;16 through 18 take an early exit if we are executing
in a hardware interrupt handler.
This is appropriate given that hardware interrupt handlers cannot
block, so it is not possible to preempt or to block within an RCU read-side 
critical section running within a hardware interrupt handler.
(Of course, threaded interrupt handlers are another story altogether.)
</p>

<p>Finally, line&nbsp;20 checks to see if we blocked or were
preempted within the
just-ended RCU read-side critical section, clearing the corresponding
bit and cleaning up after blockage or preemption if so.
The exact details of the cleanup are not important (and are therefore
omitted from the code fragment above), although curious
readers are referred to <code>kernel.org</code>.
The important thing is what happens if this RCU read-side critical section
was the last one blocking an expedited RCU grace period or if the
just-ended RCU read-side critical section was priority-boosted.
Either situation requires that RCU interact with the scheduler, which
may require the scheduler to acquire its runqueue and priority-inheritance
locks.
</p>

<p>Because the scheduler disables interrupts when acquiring the
runqueue and the priority-inheritance locks, an RCU read-side
critical section that lies entirely within one of these locks'
critical sections cannot be interrupted, preempted, or blocked.
Therefore, such an RCU read-side critical section should not
enter <code>rcu_read_unlock_special()</code>, and should thus
avoid what would otherwise be an obvious self-deadlock scenario.
</p>

<div class="tlrw"><a name="Quick Quiz 1"><b>Quick Quiz 1</b>:</a>
But what about RCU read-side critical sections that begin
before a runqueue lock is acquired and end within that lock's
critical section?
<a href="#aqq1">Answer</a>
</div>

<p>As we will see later, a number of self-deadlock scenarios can be
avoided via the
<code>in_irq()</code> early exit from <code>rcu_read_unlock_special()</code>.
Keep the critical importance of this early exit
firmly in mind as we steam down the tracks towards the
RCU/scheduler/threaded-irq trainwreck.
</p>

<h4><a name="Steaming Towards the Train Wreck">
Steaming towards the trainwreck</a></h4>

Before we leave the station, please keep in mind that
<code>in_irq()</code> can return inaccurate results because
it consults the <code>preempt_count()</code> bitmask, which is updated
in software.
At the start of the interrupt, there is therefore a period of
time before <code>preempt_count()</code> is updated to record the
start of the interrupt, during which time the interrupt handler
has started executing, but <code>in_irq()</code> returns false.
Similarly, at the end of the interrupt, there is a period of
time after <code>preempt_count()</code> is updated to record
the end of the interrupt, during which time the interrupt
handler has not completed executing, but again
<code>in_irq()</code> returns false.
This last is most emphatically the case when the end-of-interrupt
processing kicks off softirq handling.

<p>With that background, the sequence of commits leading to the trainwreck
is as follows:
</p>

<ol>
<li>	In March of 2009, <a
	href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=a18b83b7ef">commit
	<code>a18b83b7ef</code></a> added the first known 
	<code>rcu_read_unlock()</code> to be called while holding
	a runqueue lock.
<p>

<div class="tlrw">
<a name="Quick Quiz 2"><b>Quick Quiz 2</b>:</a>
Suppose that an RCU read-side critical section is enclosed within
a runqueue-lock critical section.
Why couldn't that RCU read-side critical section
be the last RCU read-side critical section blocking a
<code>TREE_PREEMPT_RCU</code> expedited grace period?
<a href="#aqq2">Answer</a>
</p>

<p><a name="Quick Quiz 3"><b>Quick Quiz 3</b>:</a>
Why can't we avoid this whole mess by treating interrupt-disabled
segments of code as if they were RCU read-side critical sections?
<a href="#aqq3">Answer</a>
</div>



<li>	In December of 2010, <a
	href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=d9a3da069">commit
	<code>d9a3da069</code></a>  added
	<code>synchronize_rcu_expedited()</code> to
	<code>TREE_PREEMPT_RCU</code>, which causes the last
	reader blocking an expedited grace period to call
	<code>wake_up()</code> from within <code>rcu_read_unlock()</code>.
	Of course, the <code>wake_up()</code> acquires the runqueue
	locks.
</ol>
<p>
	Although this appears to open the door to an obvious deadlock
	scenario where the RCU read-side critical section under the
	runqueue lock is the last one blocking a preemptible-RCU
	expedited grace period, this cannot happen <i>as long as</i>
	the runqueue lock is held across the entire duration of
	the RCU read-side critical section.

<p>Continuing down the tracks toward the trainwreck:
</p>
<ol>
<li>	In June of 2010, <a
	href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=f3b577dec1">commit
	<code>f3b577dec1</code></a> added an RCU 
	read-side critical section in <code>wake_affine()</code>.
	Given that I was blissfully unaware of the true nature of
	<code>in_irq()</code>,
	I raised no objection to this patch.
	Quite the opposite, in fact, as can be seen by a quick
	glance at this commit.
<p>

<div class="tlrw">
<a name="Quick Quiz 4"><b>Quick Quiz 4</b>:</a>
Exactly what vulnerability did commit <code>f3b577dec1</code> expose?
<a href="#aqq4">Answer</a>
</div>

<li>	The addition of threaded interrupt handlers meant that almost
	all hardware interrupts started invoking the scheduler
	in order to awaken the corresponding interrupt kthread,
	which in turn increased the likelihood that
	<code>rcu_read_unlock_special()</code> would become confused
	by the return value from <code>in_irq()</code>.
<p>
<li>	Many more RCU read-side critical sections were added
	within runqueue and priority-inheritance critical sections,
	further increasing the interaction cross-section between RCU and the
	scheduler.
<p>
<li>	<code>RCU_BOOST</code> introduced an incorrect cross-task write to the
	per-task <code>-&gt;rcu_read_unlock_special</code> variable.
	This could result in this variable being corrupted, resulting
	in all manner of deadlocks.
	This was fixed by commit <code>7765be2fe</code>.
<p>
<li>	In addition, <code>RCU_BOOST</code> introduced another
	call from RCU into the scheduler in the form of a
	<code>rt_mutex_unlock()</code>.
</ol>

All of these changes set the stage for a number of potential failures; one
possible sequence of events is as follows:

<ol>
<li>	An RCU read-side critical section is preempted, then resumes.
	This causes the the per-task <code>-&gt;rcu_read_unlock_special</code>
	variable to have the <code>RCU_READ_UNLOCK_BLOCKED</code> bit set.
<p>
<li>	This task remains preempted for so long that RCU priority boosting
	is invoked.
<p>
<li>	The RCU read-side critical section ends by invoking
	<code>rcu_read_unlock()</code>, which in in turn invokes the
	<code>__rcu_read_unlock()</code> function shown above.
<p>
<li>	An interrupt arrives just after <code>__rcu_read_unlock()</code>
	reaches line&nbsp;7.
<p>
<li>	The interrupt handler runs to completion, so that
	<code>irq_exit()</code> is invoked, and <code>irq_exit()</code>
	decrements the irq nesting-level count to zero.
<p>
<li>	Then <code>irq_exit()</code> then invokes <code>invoke_softirq()</code>,
	which determines that ksoftirqd must be awakened.
<p>
<li>	The scheduler is invoked to awaken ksoftirqd, which acquires
	a runqueue lock and then enters an RCU read-side critical
	section.
<p>
<li>	When the interrupt handler leaves the RCU read-side critical
	section, line&nbsp;9 of <code>__rcu_read_unlock()</code>
	will find that the per-task <code>-&gt;rcu_read_unlock_special</code>
	variable is non-zero, and will therefore invoke
	<code>rcu_read_unlock_special()</code>.
<p>
<li>	Because <code>in_irq()</code> returns false,
	line&nbsp;16 of <code>rcu_read_unlock_special()</code>
	does not take an early exit.
	Therefore, <code>rcu_read_unlock_special()</code> sees the
	<code>RCU_READ_UNLOCK_BLOCKED</code> bit set in
	<code>-&gt;rcu_read_unlock_special</code>, and also notes
	that the task has been priority boosted.
	It therefore invokes the scheduler to unboost itself.
<p>
<li>	The scheduler will therefore attempt to acquire a runqueue lock.
	Because this task already holds a runqueue lock, deadlock
	can (and sometimes did) result.
</ol>

There were a number of other failure scenarios, but this one is
a representative specimen.  Needless to say, figuring all this out was a
bit of a challenge for everyone involved, as was the question of how to fix the problem.

<h4><a name="Fixes">
Fixes</a></h4>

<p>The fixes applied to the RCU trainwreck are as follows:
</p>

<ol>
<li>	<code><a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=b0d30417">b0d30417</a></code> (rcu: Prevent RCU callbacks from executing
	before scheduler initialized), which does what its name says.
	This addressed a few boot-time hangs.
<p>
<li>	<code><a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=131906b0">131906b0</a></code> (rcu: decrease rcu_report_exp_rnp coupling
	with scheduler), which causes RCU to drop one of its internal
	locks before invoking the scheduler, thereby eliminating
	one set of deadlock scenarios involving expedited
	grace periods.
<p>
<li>	<code><a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=7765be2f">7765be2f</a></code> (rcu: Fix RCU_BOOST race handling
	<code>current-&gt;rcu_read_unlock_special</code>), which
	allocates a separate <code>task_struct</code> field to
	indicate that a task has been priority boosted.
	This change meant that the <code>-&gt;rcu_read_unlock_special</code>
	field returned to its earlier (and correct) status of being
	manipulated only by the corresponding task.
	This prevented a number of scenarios where an instance of
	<code>__rcu_read_unlock()</code> invoked from interrupt
	context would incorrectly
	invoke <code>rcu_read_unlock_special()</code>, which would
	again result in deadlocks.
<p>
<li>	<code><a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=be0e1e21">be0e1e21</a></code> (rcu: Streamline code produced by
	__rcu_read_unlock()), which was an innocent bystander brought
	along due to dependencies among patches.
<p>
<li>	<code><a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=10f39bb1">10f39bb1</a></code> (rcu: protect __rcu_read_unlock() against
	scheduler-using irq handlers), which rearranges
	<code>__rcu_read_unlock()</code>'s manipulation of
	<code>-&gt;rcu_read_lock_nesting</code> so as to prevent
	interrupt-induced recursion in <code>__rcu_read_unlock()</code>'s
	invocation of <code>rcu_read_unlock_special()</code>,
	which in turn prevents another class of deadlock scenarios.
This commit was inspired by an <a href="https://lkml.org/lkml/2011/7/15/326">earlier patch by Steven Rostedt</a>.
<p>
<li>	<code><a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=c5d753a5">c5d753a5</a></code> (sched: Add irq_{enter,exit}() to
	<code>scheduler_ipi()</code> by Peter Zijlstra), which informs RCU that the scheduler is
	running.
	This is especially important when the IPI interrupts
	dyntick-idle mode: Without this patch, RCU would simply ignore
	any RCU read-side critical sections in <code>scheduler_ipi()</code>.
<p>
<li>	<code><a
href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=ec433f0c">ec433f0c</a></code>
(softirq,rcu: Inform RCU of irq_exit() activity by Peter Zijlstra),
	which informs RCU of scheduler activity that occurs from
	hardware interrupt level, but after <code>irq_exit()</code>
	has cleared the <code>preempt_count()</code> indication
	that <code>in_irq()</code> relies on.
	It is quite possible that <code>10f39bb1</code> makes this change
	unnecessary, but proving that would have delayed 3.0 even more.
<p>
<li>	<code><a href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=a841796f">a841796f</a></code> (signal: align __lock_task_sighand() irq
	disabling and RCU) fixes one case where an RCU read-side critical
	section is preemptible, but its <code>rcu_read_unlock()</code>
	is invoked with interrupts disabled.
	As noted earlier, there might be a broad-spectrum solution
	that renders this patch unnecessary, but that solution was
	not appropriate for 3.0.
</ol>

So, where are we now?

<h4><a name="Current Status">
Current status</a></h4>

<p>The Linux 3.0 version of RCU finally seems stable, but
the following potential vulnerabilities remain:
</p>

<ol>
<li>	In <code>RCU_BOOST</code> kernels, if an RCU read-side critical
	section has at any time been preemptible, then it is illegal
	to invoke its <code>rcu_read_unlock()</code> with interrupts
	disabled.
	There is an experimental
	<a href="https://lkml.org/lkml/2011/7/19/227">patch</a>
	that removes this restriction, but at the cost of lengthening
	the real-time mutex acquisition code path.
	Work continues to find a solution with better performance
	characteristics.
<p>
<li>	In all preemptible-RCU kernels, if an RCU read-side critical
	section has at any time been preemptible, then it is illegal
	to invoke its <code>rcu_read_unlock()</code> while holding
	a runqueue or a priority-inheritance lock.
	Although there are some possible cures for this condition,
	all currently known cures are worse than the disease.
<p>
<div class="tlrw">
<a name="Quick Quiz 5"><b>Quick Quiz 5</b>:</a>
How could you remove the restriction on possibly-preempted RCU read-side
critical sections ending with runqueue or priority-inheritance locks held?
<a href="#aqq5">Answer</a>
</div>
<li>	<code>TINY_PREEMPT_RCU</code> might well contain similar
	vulnerabilities.
</ol>


So, what should be done to prevent this particular bit of history
from repeating itself?

<h4><a name="Preventing Future Bellyflops and Trainwrecks">
Preventing future bellyflops and trainwrecks</a></h4>

<p>Prevention is better than cure, so what preventative measures should
be taken?
</p>

<p>The most important preventative measure is to do a full review of the
RCU code, documenting it as I go.
In the past, I documented new RCU functionality as a matter of course,
before that functionality was accepted into the kernel.
However, over the past few years, I have gotten out of that habit.
Although some of the bugs would probably have escaped me, I would
likely have spotted a significant fraction.
In addition, the documentation might have helped others better understand RCU,
which in turn might have helped some of them to spot the bugs.
</p>

<p>Although no one has yet reported similar bugs in
<code>TINY_PREEMPT_RCU</code>, that does not mean that similar bugs
do not exist.
Therefore, when inspecting the code, I need to pay special attention
to the corresponding portions of <code>TINY_PREEMPT_RCU</code>.
</p>

<p>Another important preventative measure is to
<a href="http://lwn.net/Articles/452231/">question long-held assumptions</a>.
My unquestioning faith in <code>in_irq()</code> was clearly misplaced.
Although <code>in_irq()</code> was
&ldquo;good enough&rdquo; for RCU for quite some time,
it suddenly was not.
In short, when you are working on something as low-level as RCU, you
shouldn't be taking things like this for granted.
</p>

<p>Dealing with the trainwreck also exposed some shortcomings in my
test setup, which emphasizes thoroughness over fast turnaround.
Although there is no substitute for a heavy round of testing on a
number of different configurations, it would be good to be able to validate
debug patches and experimental fixes much more quickly.
I have therefore started setting up an RCU testing environment
using KVM.
This testing environment also has the great advantage of working
even when I don't have Internet access.
Additionally, use of KVM looks like it will shorten the edit-compile-debug
cycle, which is quite important when chasing bugs that I actually can
reproduce.
</p>

<p>Finally, I need to update my test configurations.
Some of the bugs reproduce more quickly when threaded interrupt handlers are enabled,
so I need to add these to my test regime.
Another bug was specific to 32-bit kernels, which I currently
don't test, but which KVM makes it easy to test.
In fact, on my current laptop, 32-bit kernels are all that KVM is
capable of testing.
</p>

<p>Hopefully these changes will avoid future
late-in-cycle RCU
trainwrecks.
</p>

<h4><a name="Acknowledgments">
Acknowledgments</a></h4>

<p>I am grateful to
Steven Rostedt, Peter Zijlstra, Thomas Gleixner, Ingo Molnar,
Ben Greear, Julie Sullivan, and Ed Tomlinson for finding bugs, creating
patches, and lots of testing.
I owe thanks to Jim Wasko for his support of this effort.

</p><h4><a name="Answers to Quick Quizzes">
Answers to Quick Quizzes</a></h4>

<a name="aqq1"></a>
<p><b>Quick Quiz 1</b>:
But what about RCU read-side critical sections that begin
before a runqueue lock is acquired and end within that lock's
critical section?

</p><p><b>Answer</b>:
That would be very bad.
The scheduler is therefore forbidden from doing this.

</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>

<a name="aqq2"></a>
<p><b>Quick Quiz 2</b>:
Suppose that an RCU read-side critical section is enclosed within
a runqueue-lock critical section.
Why couldn't that RCU read-side critical section
be the last RCU read-side critical section blocking a
<code>TREE_PREEMPT_RCU</code> expedited grace period?

</p><p><b>Answer</b>:
No, it cannot.
To see why, note that
the <code>TREE_PREEMPT_RCU</code> variant of
<code>synchronize_rcu_expedited</code>
is implemented in two phases.
The first phase invokes <code>synchronize_sched_expedited()</code>,
which forces a context switch on each CPU.
The second phase waits for any RCU read-side critical sections that
were preempted in phase 1.
Because acquiring runqueue locks disables interrupts, it is not possible
to preempt an RCU read-side critical section that is totally enclosed
in a runqueue-lock critical section, and therefore
<code>synchronize_rcu_expedited</code> will never wait on such
an RCU read-side critical section,
which in turn means that the corresponding <code>rcu_read_unlock()</code>
cannot have a need to invoke the scheduler, thus avoiding the deadlock.
</p>

<p>Of course, the last link in the above chain of logic was broken
by a later bug, but read on...

</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>

<a name="aqq3"></a>
<p><b>Quick Quiz 3</b>:
Why can't we avoid this whole mess by treating interrupt-disabled
segments of code as if they were RCU read-side critical sections?

</p><p><b>Answer</b>:
For two reasons:
</p>

<ol>
<li>	The fact that interrupt-disable sections of code act as
	RCU read-side critical sections is a property of the
	current implementation.
	Later implementations are likely to need to do quiescent-state
	processing off-CPU in order to reduce OS jitter, and such
	implementations will not be able to treat interrupt-disable
	sections of code as RCU read-side critical sections.
	This property is important to a number of users, so much so
	that there is an
	<a href="https://lkml.org/lkml/2010/11/5/240">out-of-tree RCU implementation</a>
	that provides it (see
	<a href="https://lkml.org/lkml/2011/3/9/377">here</a> and
	<a href="https://lkml.org/lkml/2011/6/16/827">here</a>
	for more recent versions).
	Therefore, we should be prepared for mainline Linux kernel's
	RCU implementation to treat interrupt-disable sections of
	code as the quiescent states that they really are.
<p>
<li>	Having multiple very different things that provide read-side
	protection makes the code more difficult to maintain,
	with RCU-sched being a case in point.
</ol>

</p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>

<a name="aqq4"></a>
<p><b>Quick Quiz 4</b>:
Exactly what vulnerability did commit <code>f3b577dec1</code> expose?

</p><p><b>Answer</b>:

<p>Suppose that an RCU read-side critical section is the last one blocking
an expedited grace period, and that its <code>__rcu_read_unlock()</code>
is interrupted just after it decrements the nesting count to zero.
The <code>current-&gt;rcu_read_unlock_special</code> bitmask will
therefore be non-zero, indicating that special processing is required
(in this case, waking up the task that kicked of the expedited grace
period).
Suppose further that softirq processing is kicked off at the end of the
interrupt, and that there are so many softirqs pending that they
need to be handed off to ksoftirqd.
Therefore <code>wake_up()</code> is invoked, which acquires the
needed runqueue locks.
But because <code>wake_affine()</code> is invoked, there is
an RCU read-side critical section whose <code>__rcu_read_unlock()</code>
will see that <code>current-&gt;rcu_read_unlock_special</code> is nonzero.
At this point, <code>in_irq()</code> will be returning false,
so the resulting call to <code>rcu_read_unlock_special()</code>
won't know to take the early exit.
It will therefore invoke <code>wake_up()</code>, which will again
attempt to acquire the runqueue lock, resulting in deadlock.

</p><p><a href="#Quick%20Quiz%204"><b>Back to Quick Quiz 4</b>.</a>

<a name="aqq5"></a>
<p><b>Quick Quiz 5</b>:
How could you remove the restriction on possibly-preempted RCU read-side
critical sections ending with runqueue or priority-inheritance locks held?

</p><p><b>Answer</b>:
Here are some possibilities:
</p>

<ol>
<li>	<a href="https://lkml.org/lkml/2011/7/21/308">Enclose all
	runqueue or priority-inheritance critical section
	in an RCU read-side critical section</a>.
	This would mean that any <code>rcu_read_unlock()</code> that
	executed with one of these locks held would be inside the
	enclosing RCU read-side critical section, and thus would be
	guaranteed not to invoke <code>rcu_read_unlock_special()</code>.
	However, this approach would add overhead to the scheduler's
	fastpaths and requires yet another odd hand-crafted
	handoff at context-switch time.
<p>
<li>	Keep some per-task state indicating that at least one
	scheduler lock is held.
	Then <code>rcu_read_unlock_special()</code> could set another
	per-task variable indicating that cleanup is required.
	The scheduler could check this flag when releasing its
	locks.
	I hope that the maintainability challenges of this approach
	are self-evident.
<p>
<li>	Your idea here.
</ol>

<p><a href="#Quick%20Quiz%205"><b>Back to Quick Quiz 5</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Read-copy-update">Read-copy-update</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/453002/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor453218"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">3.0 and RCU: what went wrong</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2011 13:32 UTC (Thu)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/453218/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great piece, to see this kind of honest analysis and re-evaulation!<br>
Such a contrast from commercial gloss &amp; dissembly &amp; political spin.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/453218/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor453226"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">3.0 and RCU: what went wrong</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2011 14:36 UTC (Thu)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/453226/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Glad you liked it!  That said, I must confess that I was completely unaware that my earlier articles were felt to be commercial gloss, dissembly, and political spin.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/453226/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor453233"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">3.0 and RCU: what went wrong</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2011 16:16 UTC (Thu)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/453233/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Uhmm, I don't think he meant your articles... just the general proprietary software trend.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/453233/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor453287"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">3.0 and RCU: what went wrong</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2011 20:43 UTC (Thu)
                               by <b>roblucid</b> (guest, #48964)
                              [<a href="/Articles/453287/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Paul, I definitely was not referring to any other articles you wrote. I really enjoyed you self critique and it was meant as wholesome praise only, no other motives.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/453287/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor453398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">3.0 and RCU: what went wrong</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 29, 2011 14:40 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/453398/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah!  Please accept my apologies for my misinterpretation, then!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/453398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor453479"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">3.0 and RCU: what went wrong</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2011 3:45 UTC (Sat)
                               by <b>pr1268</b> (subscriber, #24648)
                              [<a href="/Articles/453479/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>I'm curious, in <tt>static void rcu_read_unlock_special(struct task_struct *t)</tt>, on line 5 <tt>unsigned long flags</tt> is declared but uninitialized.  Later, on line 11, it is passed-by-value to another function.  Is there some missing code not shown that initializes <tt>flags</tt>?</p>

<p>Thank you for the neat article&mdash;I openly admit that a lot of it is hard for me to follow, but then I'm not as fluent in low-level kernel internals as Paul is.  (And, I'm incredibly happy to know that people as knowledgeable as Paul are running the Linux Kernel Show&trade;. ;-)</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/453479/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor453483"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">3.0 and RCU: what went wrong</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 30, 2011 5:19 UTC (Sat)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/453483/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
local_irq_save() is a macro which disables interrupts on the local CPU and saves the old value of the interrupt flag into its parameter.<br>
<p>
Not using a pointer is a little bit more efficient when accessing it from inline assembler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/453483/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor453636"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">3.0 and RCU: what went wrong</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2011 19:40 UTC (Sun)
                               by <b>Julie</b> (guest, #66693)
                              [<a href="/Articles/453636/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What a terrific analysis! <br>
<p>
We are very lucky to have Paul to unravel this ball of string and pick out all the burrs. We are also very lucky that he's great at explaining complex things in a clear, accessible way and that he's prepared to take time out to write another superb article.<br>
<p>
Thanks for all your tireless and selfless efforts, Paul.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/453636/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor454177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">3.0 and RCU: what went wrong</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2011 22:38 UTC (Thu)
                               by <b>dfsmith</b> (guest, #20302)
                              [<a href="/Articles/454177/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How about a patch to rename in_irq() to in_irq_likely()?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor454910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Renaming in_irq()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 13, 2011 23:02 UTC (Sat)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/454910/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I understand it, the problem with renaming it is that it is perfectly reliable for its intended driver-writing users.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/454910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
