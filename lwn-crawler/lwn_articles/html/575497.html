        <!DOCTYPE html>
        <html lang="en">
        <head><title>Deadline scheduling: coming soon? [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/575497/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/575356/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/575497/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Deadline scheduling: coming soon?</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>December 4, 2013</br>
           </div>
Deadline scheduling was first <a href="/Articles/356576/">covered here</a>
in 2009.  Like much of the code in the realtime tree, though, deadline
scheduling appears not to be subject to deadlines when it comes to being
merged into the mainline.  That said, it seems entirely possible that this
longstanding project will land in a stable kernel release fairly soon, so a
look at 
the status of this patch set, and the proposed ABI in particular, seems in
order. 
<p>
To recap briefly: deadline scheduling does away with the concept of process
priorities that has been at the core of most CPU scheduler algorithms.
Instead, each process provides three parameters to the scheduler: a
"worst-case execution time" describing a maximum amount of CPU time needed
to accomplish its task, a period describing how often the task must be
performed, and a deadline specifying when the task must first be completed.  The
actual scheduling algorithm is then relatively simple: the task whose
deadline is closest runs first.  If the scheduler takes care to not allow
the creation of deadline tasks when the sum of the worst-case execution
times would exceed the amount of available CPU time, it can guarantee that
every task will be able to finish by its deadline.
<p>
Deadline scheduling is thus useful for realtime tasks, where completion by
a deadline is a key requirement.  It is also applicable to periodic tasks
like streaming media processing.
<p>
In recent times, work on deadline scheduling has been done by Juri Lelli.
He has posted several versions, improving things along the way.  His <a
href="/Articles/570293/">v8 posting</a> in October generated a fair amount
of discussion, including suggestions from scheduler maintainers <a
href="/Articles/575502/">Peter Zijlstra</a> and <a
href="/Articles/575503/">Ingo Molnar</a> that the time had come to merge
this code.  That merging did not happen for 3.13, but chances are that it
will for a near-future kernel release, barring some sort of unexpected
roadblock.  The main thing that remains to be done is to get the user-space
ABI nailed down, since that aspect is hard to change after it has been
released in a mainline kernel.
<p>
<h4>Controlling the scheduler</h4>
<p>
To be able to guarantee that deadlines will be met, a deadline scheduler
must have an incontestable claim to the CPU, so deadline tasks will run
ahead of all other tasks â€” even those in the realtime scheduler classes.
Deadline-scheduled processes cannot take <i>all</i> of the available CPU
time, though; the amount of time actually available is controlled by a set
of sysctl knobs found under <tt>/proc/sys/kernel/</tt>.  The first two
already exist in current kernels: <tt>sched_rt_runtime_us</tt> and
<tt>sched_rt_period_us</tt>.  The first specifies the amount of CPU time
(in microseconds) available to realtime tasks, while the second gives the
period over which that CPU time is available.  By default, 95% of the
total CPU time is made available to realtime processes, leaving 5% to give
a desperate system administrator a chance to recover a system from a
runaway realtime process.
<p>
The new <tt>sched_dl_runtime_us</tt> knob is used to say how much of the
realtime allocation is available for use by the deadline scheduler.  The
default setting allocates 40% for deadline scheduling, but a system
administrator may well want to tweak that value.  Note that, while realtime
scheduling is supported by control groups, deadline scheduling has not yet
been implemented at that level.  How deadline scheduling should interact with
group scheduling raises some interesting questions that have not yet been
fully answered.
<p>
The other piece of the ABI  allows processes to enter and control the
deadline scheduling regime.  The current system call for changing a process's
scheduling class is:
<p>
<pre>
    int sched_setscheduler(pid_t pid, int policy, const struct sched_param *param);
</pre>
<p>
The <tt>sched_param</tt> structure used in this system call is quite
simple:
<p>
<pre>
    struct sched_param {
	int sched_priority;
    };
</pre>
<p>
So <tt>sched_setscheduler()</tt> works fine for the currently available
scheduling classes; the desired class is specified with the <tt>policy</tt>
parameter, while the associated process priority goes into <tt>param</tt>.
But <tt>struct&nbsp;sched_param</tt> clearly does not have the space needed
to hold the three parameters needed with deadline scheduling, and its
definition cannot be changed without breaking the existing ABI.  So a new
system call will be needed.  As of this writing the details are still
under discussion, but the new ABI can be expected to look something like
this:
<p>
<pre>
    struct sched_attr {
 	int sched_priority;
 	unsigned int sched_flags;
 	u64 sched_runtime;
 	u64 sched_deadline;
 	u64 sched_period;
	u32 size;
    };

    int sched_setscheduler2(pid_t pid, int policy, const struct sched_attr *param);
    int sched_setattr(pid_t pid, const struct sched_attr *param);
    int sched_getattr(pid_t pid, struct sched_attr *param, unsigned int size);
</pre>
<p>

Where <tt>size</tt> (as both a parameter and a structure field) is the size
of the <tt>sched_attr</tt> structure.  If, in the future, the need arises
to add more fields to that structure, the kernel will be able to use the
<tt>size</tt> value to determine which version of the structure an
application is using and respond accordingly.  For the curious:
<tt>size</tt> is meant to be specified within
<tt>struct&nbsp;sched_attr</tt> when that structure is, itself, an input
parameter to the kernel; otherwise <tt>size</tt> is given separately.
The <tt>sched_flags</tt> field of
<tt>struct&nbsp;sched_attr</tt> is not used in the current version of the
patch. 
<p>
One other noteworthy detail is that processes running in the new
<tt>SCHED_DEADLINE</tt> class are not allowed to fork children in the same
class.  As with the realtime scheduling classes, this restriction can be worked
around by setting the scheduling class to
<tt>SCHED_DEADLINE|SCHED_RESET_ON_FORK</tt>, which causes the child to be
placed back into the default scheduling class.  Without that flag, a call
to <tt>fork()</tt> will fail.
<p>
<h4>Time to merge?</h4>
<p>
The deadline scheduling patch set has a number of loose ends left to be
dealt with, many of which are indicated in the patches themselves.  But
there comes a point where it is best to go ahead and get the code into the
mainline so that said loose ends can be tied down more quickly; the
deadline scheduling patches may well have reached that point.  Since
deadline scheduling can be added without much risk of regressions on
systems where it is not in use, there should not be a whole lot more that
needs to be dealt with before it can be merged.
<p>
...except, maybe, for one little thing.  When deadline scheduling was <a
href="/Articles/412745/">discussed at the 2010 Kernel Summit</a>, Linus and
others clearly worried that there may not be actual users for this
functionality.  There has not been a whole lot of effort put into
demonstrating users for deadline scheduling since then, though it is worth
noting that the Yocto project has included the patch in some of its
kernels.  The <a
href="http://www.juniper-project.org/page/overview">JUNIPER project</a> is
also planning to use deadline scheduling, and has been supporting its
development.  Users like these will definitely help the deadline
scheduler's case; Linus has become wary
of adding features that may not actually be used.  If that little point
can be adequately addressed, we may have deadline scheduling in the
mainline in the near future.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Scheduler-Deadline_scheduling">Scheduler/Deadline scheduling</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/575497/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor575657"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2013 19:35 UTC (Wed)
                               by <b>bokr</b> (subscriber, #58369)
                              [<a href="/Articles/575657/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
1. When does hard real-time not require deadlines?<br>
<p>
2. I am wondering if complex policy and critical path stuff wouldn't best be done in userland at high realtime priority  I.e., let such a process do the figuring and policy implementation planning to meet deadlines, and give it an ABI to tell the OS what to run in absolute priority starting when. Then it can yield its own CPU by sleeping a planned amount, as an inverted scheduling of other work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575657/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575706"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2013 23:27 UTC (Wed)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/575706/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; 1. When does hard real-time not require deadlines?</font><br>
<p>
If you have infrequent events which you must react to _right_now_, you definitely need "hard" real time, yet a deadline scheduler is useless.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575706/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575747"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2013 4:55 UTC (Thu)
                               by <b>tseaver</b> (guest, #1544)
                              [<a href="/Articles/575747/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Hard" realtime implies deadlines by definition[1];  if deadlines aren't<br>
applicable to your problem, you are doing something else.<br>
<p>
]1] <a href="http://en.wikipedia.org/wiki/Hard_realtime#Hard">http://en.wikipedia.org/wiki/Hard_realtime#Hard</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575747/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2013 10:38 UTC (Thu)
                               by <b>kugel</b> (subscriber, #70540)
                              [<a href="/Articles/575772/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Right, row-latency response is not the same as hard realtime, though one often wants both.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor575777"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2013 11:16 UTC (Thu)
                               by <b>yaap</b> (subscriber, #71398)
                              [<a href="/Articles/575777/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, hard real-time implies deadlines. But there is a difference between deadlines known in advance, and reactive deadlines where an unexpected asynchronous event must be processed within a given response time. Both are cases of hard real-time, where there is a clear deadline on some processing. EDF scheduling is a natural match for the first case, but a preemptive scheduler is fine for the second case. <br>
<p>
Also, even for the first case EDF is not a requirement. One can use a preemptive scheduler with rate monotonic analysis (see <a href="https://en.wikipedia.org/wiki/Rate-monotonic_scheduling">https://en.wikipedia.org/wiki/Rate-monotonic_scheduling</a>) to make sure deadlines are met. And from memory it seems this has been done: provide an EDF like library API that will check that RMA conditions are met, but just allocate a priority and run on a preemptive scheduler.<br>
<p>
So although hard RT is about deadlines and EDF has the proper keyword in its name, it is never a necessity. That may explain why there is little traction.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575777/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2013 13:03 UTC (Thu)
                               by <b>hasta2003</b> (subscriber, #76829)
                              [<a href="/Articles/575797/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Two things on why EDF (actually EDF + Constant Bandwidth Server = SCHED_DEADLINE) is better than RM for Hard and Soft RT:<br>
<p>
- it can better utilize CPU power (optimal on UP, 100% of CPU power while still meeting deadlines, RM ~ 69%)<br>
- it can provide temporal guarantees, which plain EDF or RM cannot do<br>
- it provides temporal isolation, misbehaving tasks cannot affect your high priority activities<br>
<p>
The RT literature is quite vast in this regard, something more can be found in Documentation (<a href="https://lkml.org/lkml/2013/11/7/271">https://lkml.org/lkml/2013/11/7/271</a>). Just let me know if you want more details :).<br>
<p>
Thanks,<br>
<p>
- Juri<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575918"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2013 1:51 UTC (Fri)
                               by <b>bokr</b> (subscriber, #58369)
                              [<a href="/Articles/575918/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
1. What if execution time ranges are not uncorrelated? I.e., what if scheduling a before b guarantees best time for b (e.g. warming cache), but there is little or no effect on a if b is scheduled first but b first gives random or worst time for b itself? Then there is an optimum sequence.<br>
<p>
2. Deadlines to me fall into categories that show up more easily in the concrete real time scheduling problem of cooking and serving a dinner. One deadline is when everyone is seated and baked potato and grilled steaks and steamed veggies (with a cold pat of butter on top) all have to be served near simultaneously. This entails other deadlines and responses to events. Deadline for turning on oven. Hot enough to put in potatoes. Etc.<br>
<p>
The general pattern is resource available, lax schedule for some prepping, cooking for a fixed interval with strict deadline at the end, not for starting, so the start has to be computed back, but it is important to start accurately so it will end accurately. The potatoes take the longest, the steaks probably parallel to the broccoli. You get the picture.<br>
<p>
Also note that the oven will be hot, so dessert souffle cook should take that into account. Worst case cooking time is not uncorrelated unless you have uncorrelated start conditions.<br>
<p>
3. I can imagine a situation where you are supplying services with different prices according to quality. The cheapest might schedule single processors and simple low bitrate algorithms, and not meeting deadlines is just breakups in the phone conversation or frozen frames instead of keeping up with jump-cut keyframes, or whatever.<br>
<p>
The question is if the scheduling ABI will support building a server that does both high and low QOS processing at the same time, using more CPUs and power for the high paying customer.<br>
<p>
In terms of GUI experience, one frame is a dinner, broccoli might be a video overlay of stock ticker updated one marquee shift, etc. But everything has to be cooked and ready/consistent at buffer flip time.<br>
<p>
4. Can the EDF be tiered into separate priorities, so that high priority tasks run first, with maybe leftover time trickling to lower levels?<br>
<p>
5. Priority is not to be used to control logical sequence order, but sometimes a ready queue that is guaranteed to run in logical fifo/roundrobin sequence is cheaper than to guarantee access coordination by locks. Maybe just use locks and not worry about it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575918/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575955"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2013 10:03 UTC (Fri)
                               by <b>hasta2003</b> (subscriber, #76829)
                              [<a href="/Articles/575955/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting questions, some have already got answers, some others are being studied in these days (in the RT literature). What you are talking about sounds to me like pipelines of tasks, group/hierarchical scheduling and gang scheduling. I'm not saying that this is already doable using the new mechanisms, but they are the base for everything.<br>
<p>
Let's say that in your restaurant you want to cook several dinners at the same time, and you want to assign them a different priority (friends and restaurant reviewers have to eat first and at least 10 minutes after they ordered), that's group scheduling: all activities for a single dinner receive higher priority, same could apply to Virtual Machines on a shared host. A feature we are working on and will extend soon SCHED_DEADLINE capabilities.<br>
<p>
SCHED_DEADLINE can already allow sporadic activations: you can decide your task is activated by the completion of some other task, or when a timer fires (put broccoli in the pot after potatoes have been in the oven for 10 minutes). You just assign a deadline for them, and they will be scheduled among other tasks, no worries about relative priorities (like you probably have to do with FIFO/RR, e.g., are my broccoli more important than the steak?).<br>
<p>
Then you may also want to assemble a cake layer after layer. Base in 1 minute, put cream on top (after base) in 30 seconds, and pass it to the next stop where it will be covered by a chocolate frosting in not more than 15 sec. That sounds to me like a pipeline of tasks, and have already been studied. Different approaches are possible (holistic view, intermediate deadlines, etc.), all of them can make use of SCHED_DEADLINE.<br>
<p>
Lastly, let's say you want to just say "prepare a vegetarian couscous in not more than 30 minutes" and you don't want to care about parallel steps. Someone has to cook the couscous, some other has to cut onions, carrots, zucchini, etc. and then someone has to cook them. At the end all have to be put together again in a single dish a be served to the customer. There is lot of interest in this right now (OpenMP, etc.) and how to efficiently assign deadlines to parallel tasks is not yet decided, but the building blocks are already available using the new scheduling policy.<br>
<p>
After all, you can also still use different policies for different activities, and we are actually working on how to correctly and safely make priority trickle (proxy exec being a promising candidate).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575955/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor575663"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling and virtualization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2013 19:53 UTC (Wed)
                               by <b>jhhaller</b> (guest, #56103)
                              [<a href="/Articles/575663/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An interesting point (to me, at least) would be how one could use this API to support deadline scheduling in a virtualized guest. While the simple approach would be to lock the guest to particular cores, and keep other work away from those cores, that prevents using those cores for low-priority work.<br>
<p>
A more complicated guest would need to use a para-virtualized scheduler, so that multiple deadlines can be passed to the hypervisor, and somehow pass that data to the kernel. Ideally, the guest would pass the priority of it's currently running thread to the hypervisor, so it could properly schedule the process with the native OS, but probably needs to register multiple priorities and deadlines, so that the native OS will escalate the priority of the hypervisor so it will schedule the hypervisor when it's time for it's guest OS to run a high priority task. Keeping the hypervisor and guest OS priorities synchronized will be a challenge, as the guest OS could finish it's high priority tasks early.<br>
<p>
This seems to be a case where cgroups will work better than strict virtualization, once deadline scheduling is implemented there, but cgroups have some of the same type of implementation issues as hypervisors, but give the OS more information about thread-level scheduling information.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575663/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575690"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling and virtualization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 4, 2013 21:09 UTC (Wed)
                               by <b>nevets</b> (subscriber, #11875)
                              [<a href="/Articles/575690/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps using OSv would be useful here. As OSv does not allow fork as well, but you get a virtualized OS that run a single process with all the access to the virtual hardware (think a virtualized DOS). Having several of these instances under a deadline scheduler will allow them to get a guaranteed amount of CPU.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575690/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor575769"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling and virtualization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2013 10:16 UTC (Thu)
                               by <b>Lennie</b> (subscriber, #49641)
                              [<a href="/Articles/575769/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Virtualization has always been messy. There is no proper way to do it, it's pretty messy.<br>
<p>
It's one kernel trying to communicate with an other kernel. So the best way is to create a some kind of para-virtualized API.<br>
<p>
Best way to get any guarantees might actually be to use containers instead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575769/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor575773"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2013 11:02 UTC (Thu)
                               by <b>hasta2003</b> (subscriber, #76829)
                              [<a href="/Articles/575773/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks Jonathan for this report!<br>
<p>
I'd just like to add that, for anyone that wants to experiment with the new ABI, branch "new-ABI" on <a href="https://github.com/jlelli/sched-deadline">https://github.com/jlelli/sched-deadline</a> is the most updated source.<br>
<p>
As usual, any kind of feedback is highly appreciated (especially if it comes with a nice use-case :)).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575773/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor575812"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2013 13:56 UTC (Thu)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/575812/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why is the old syscall not sufficient?<br>
<p>
The structure is passed as a pointer. If you consider the the type of the structure that is pointed to to be dependant on the policy, than there should not be a problem. You only need assistance of the policy logic to sensibly access the value.<br>
<p>
And why is the size not the first parameter in the structure? A structure like this would be more sensible:<br>
<p>
struct sched_attr {<br>
   u32 size;<br>
   u32 sched_flags;<br>
   union {<br>
     struct sched_params,<br>
     struct deadline_params,<br>
     struct foobar_params,<br>
   }<br>
}<br>
<p>
If you need some big values in the structure for some future policy (change) than you don't have to workaround some static field in the middle of the structure. And given a size you're expected to always check it (and any possible flags) before interpreting the other fields.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575812/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Old syscall</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2013 14:19 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/575820/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I can imagine a few reasons for not wanting to use a variable-sized structure with the old syscall.  First of those is simple type safety; you'd lose the ability to check the type of the "params" argument in the compiler.
<p>
Beyond that, though, how do you make something like <tt>sched_getparam()</tt> safe?  You might <i>assume</i> that an  application will never get put into an unexpected scheduler class that would cause the overflow of the smaller structure size, but such assumptions have proved dangerous in the past.
      
          <div class="CommentReplyButton">
            <form action="/Articles/575820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor575928"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2013 3:21 UTC (Fri)
                               by <b>dashesy</b> (guest, #74652)
                              [<a href="/Articles/575928/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      Yes size should be the first to be of any value.<br>
Providing the size is something very often seen in Win32 API. One problem with providing the size, in general, is that sizes can only grow so perhaps a version number would be more helpful. The other problem is people start using <code>sizeof()</code> all over places, and memory layout and packed attribute also take effect. Win32 code is usually not pretty.<br>
But isn't it better not to predict future too much, it will not hurt to add a new syscal in the future if needed, which comes to politics I guess. Also the norm is to add a number to the end of the old variant (e.g. dup and dup2, sched_setscheduler and sched_setscheduler2 and sched_setscheduler3), so that will fit better with overall picture too.<br>
      
          <div class="CommentReplyButton">
            <form action="/Articles/575928/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575947"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2013 8:40 UTC (Fri)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/575947/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's almost treating the syscall interface as symbol versioning. Sure it helps if the old interface was too restrictive, but in this case they just want a system for allowing different parameters for different scheduling policies. And a new syscall for each scheduling policy is not really sensible. In that case just add a syscall per scheduling policy and don't try to be generic about it.<br>
<p>
I agree that version would probably be better than size (say something else changes but the structure remains the same size). And in that case you could possibly even drop the flags part (if you need it, change the version).<br>
<p>
A size could still be usefull, but that would be to make the generic syscall wrapper copy all the supplied data from userspace to prevent concurrent updates on the userspace structure from confusing the kernel checks. But in that case I'd add it as a parameter in the syscall. It still wouldn't exclude a version in the structure though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575947/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor575952"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2013 9:13 UTC (Fri)
                               by <b>hasta2003</b> (subscriber, #76829)
                              [<a href="/Articles/575952/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We have both:<br>
<p>
- version number is same as size: #define SCHED_ATTR_SIZE_VER0	40	/* sizeof first published struct */<br>
- a new syscall, called sched_setscheduler2, that uses the new ABI, and that is extensible (just one, not a new sched_setschedulerX for every new scheduling class/policy we'll have in the future).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575952/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575968"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2013 11:58 UTC (Fri)
                               by <b>iq-0</b> (subscriber, #36655)
                              [<a href="/Articles/575968/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Version number is not the same as size. Because it can not capture that the meaning changes without the size changing. But one could easily achieve that through using flags.<br>
<p>
But moving the size to the front would still be more logical or supplying it as an additional parameter outside the structure would be even better. Now you first have to check if it's safe to read the size from userspace and then you have to check if it's safe to access the structure.<br>
This is effectively the same reason why you must always pass a socklen_t along with a sockaddr pointer.<br>
<p>
But I really wonders: Do you actually always want to receive all possible fields for each policy? At least specify that is an error to supply a non-zero value for a field that is not supported by the given policy.<br>
<p>
But it still feels like you're implementing something resembling what fcntl is for filedescriptors only for scheduling policies. Only try imagining fcntl taking a humongous structure describing all possible parameters for all different uses (I'm not saying you should mimick fcntl but it is just a syscall that caters to multiple distinct uses concerning a generic resource).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575968/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575974"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2013 13:16 UTC (Fri)
                               by <b>hasta2003</b> (subscriber, #76829)
                              [<a href="/Articles/575974/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since this struct is only allowed to grow (and any change is meaningless since it already contains necessary and sufficient parameters to describe real-time tasks), I think size can be considered as a version number as well.<br>
Checks about kernel to/from userspace reads/writes are done and we ensure fwd/bwd compatibility.<br>
Currently you are allowed to not specify a period, and it is considered equal to the deadline in this case. The other restriction is a non-null runtime. It is already specified as comments, but I should add it to documentation too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575974/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor575894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 5, 2013 21:07 UTC (Thu)
                               by <b>lmb</b> (subscriber, #39048)
                              [<a href="/Articles/575894/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is actually quite interesting for HA clustering, or other code that uses network liveness checks. It is timing sensitive (meaning it needs to be run periodically with hard guarantees, otherwise other nodes will declare this one dead), but only needs a brief tick to process everything.<br>
<p>
The currently used SCHED_RR is prone to priority inversion or even being pushed off by less crucial processes that just happen to have picked the same or higher scheduling priority. Not to mention that a bug in the code leads to CPU starvation. Deadline scheduling would allow us to put a constraint on this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor575954"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Deadline scheduling: coming soon?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 6, 2013 9:23 UTC (Fri)
                               by <b>hasta2003</b> (subscriber, #76829)
                              [<a href="/Articles/575954/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sounds interesting!<br>
Can you give more details? Like some application in particular that suffers from the problems you depicted. If I'd have the opportunity to look at the source code I could probably figure out how we can use deadline scheduling for it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/575954/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2013, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
