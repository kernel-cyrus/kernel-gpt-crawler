        <!DOCTYPE html>
        <html lang="en">
        <head><title>Patching until the COWs come home (part 1) [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/849638/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/849739/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/849638/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Patching until the COWs come home (part 1)</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="GAByline">
           <p>March 22, 2021</p>
           <p>This article was contributed by Vlastimil Babka</p>
           </div>
The kernel's memory-management subsystem is built upon many concepts, one
of which is called "copy on write", or "COW".
The idea behind COW is conceptually simple, but its
details are tricky and its past is troublesome. Any change to its
implementation can have unexpected consequences and cause subtle breakage
for existing workloads. So it is somewhat surprising that last year we saw
two major changes the kernel's COW code; less surprising is the fact that,
both times, these changes had unexpected consequences and broke things. 
Some of the resulting problems are still not fixed
today, almost ten months after the first change, while the original reason
for the changes — a security vulnerability — is also not fully fixed.  Read
on for a description of COW, the vulnerability, and the initial fix; the
concluding article in the series will describe the complications that arose
thereafter. 

<p>

Copy on write is a standard mechanism for sharing a single instance of an
object between processes in a situation where each process has the illusion
of an independent, private copy of that object.  Examples include memory
pages shared between processes or data extents shared between files.  To
see how COW is used in the memory-management subsystem, consider what
happens when a process calls <tt>fork()</tt>: the pages in that process's
private memory areas should no longer be shared between the parent and
child. But, instead of creating new copies of those pages for the child
process during the <tt>fork()</tt> call, the kernel will simply map the
parent's pages in the child's page tables.  Importantly, the page-table
entries in both parent and child are set as read-only (write-protected).
<p>

If either process attempts to write to one of these
pages, a page fault will occur, and the kernel's page-fault handler will
create a new copy of the page, replacing the page-table entry (PTE) in the
faulting process with a PTE that references the new page, but which allows
the write to proceed. This action is often referred to as "breaking
COW". If the other process then tries to write to that same page, another
page fault 
will occur, as that process's PTE is still marked read-only. But now the
page-fault handler will recognize that the page is no longer shared, so
the PTE can just be made writable and the process can resume.

<p>

The benefits of this scheme are lower memory consumption and a reduction of
CPU time spent copying pages during <tt>fork()</tt> calls. Often the price
of copying is never paid for many of the pages because the child
might call <tt>exit()</tt> or <tt>exec()</tt> before either the parent or
the child writes to those pages.

<p>

While the COW mechanism looks simple, the devil is in the details, as has
been <a href="/Articles/704231/">shown already</a> in the past. The recent
trouble in this area started in 2020; it resulted in two major changes while
attempting to fix a vulnerability — which is actually still not fixed in all
scenarios — and resulted in many corner cases, some of which are still not
fully ironed out.

<p>
<h4>The trouble begins</h4>
<p>
The first public sign of issues with the COW mechanism appeared in the form of
<a href="https://git.kernel.org/linus/17839856fd58">commit 17839856fd58</a>
("gup: document and work around 'COW can break either way'
issue") at the end of May 2020. The changelog doesn't fully describe the
problem scenario, but what is there  is ominous enough:
<p>
<blockquote class="bq">
    End result: the get_user_pages() call might result in a page pointer
    that is no longer associated with the original VM, and is associated
    with - and controlled by - another VM having taken it over instead.
</blockquote>
<p>

Any doubts about whether the commit fixed a security vulnerability vanish
when one notices the Reported-by tag mentioning Jann Horn; presumably
Horn's report went through the appropriate non-public security
channels. The practice of making fixes to some vulnerabilities immediately
public without explicitly marking them as such is not new, especially in
the COW area.  Nevertheless, the related <a
href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2045">Project
Zero issue</a> was made public in August, and CVE-2020-29374 was assigned
in December; both point to the above-mentioned commit as the fix.

<p>
As the Project Zero issue includes proof-of-concept (PoC) code, we can look at
the fix with that code in mind and not rely on the incomplete commit log. The
most important parts of the PoC are the following:
<p>
<pre>
    static void *data;

    posix_memalign(&amp;data, 0x1000, 0x1000);
    strcpy(data, "BORING DATA");

    if (fork() == 0) {
	// child
	int pipe_fds[2];
	struct iovec iov = {.iov_base = data, .iov_len = 0x1000 };
	char buf[0x1000];

	pipe(pipe_fds);
	vmsplice(pipe_fds[1], &amp;iov, 1, 0);
	munmap(data, 0x1000);

	sleep(2);
	read(pipe_fds[0], buf, 0x1000);
	printf("read string from child: %s\n", buf);
   } else {
	// parent
	sleep(1);
	strcpy(data, "THIS IS SECRET");
   }
</pre>
<p>

The code starts by allocating an anonymous, private page and writing some
data there; it then calls <tt>fork()</tt>. At that point, the page becomes
a COW page — it is write-protected for the parent process by making the
corresponding page-table entry read-only, and for the child process an
identical PTE is created.  Then, while the parent is blocked inside
<tt>sleep()</tt>, the child creates a pipe and passes the page to that pipe
with <tt>vmsplice()</tt>, a system call that is similar to <tt>write()</tt>
but which allows a zero-copy data transfer of the page's contents. In order
to achieve 
that, the kernel takes a reference on the source page (by increasing its
reference count) through <tt>get_user_page()</tt> or one of its variants;
the set of these functions is often referred to as "GUP". The child then
unmaps the page from its own page tables (but retains the reference in the
pipe) and goes to sleep.

<p>

The parent wakes up from its sleep and writes new data to the page. The
page table entry is write-protected, so the write causes a page fault.  The
page-fault handler can tell that this is fault on a COW page because the
the mapping allows write access while the PTE is write protected. If there
were more processes mapping the page then the content would have to be
copied (breaking COW), but if there is a single mapping, the page can
be just made writeable. The kernel relies on the value returned by
<a
href="https://elixir.bootlin.com/linux/latest/source/include/linux/mm.h#L839"><tt>page_mapcount()</tt></a>
to determine how many mappings exist.

<p>

Here is the problem: <tt>page_mapcount()</tt> at this point in the PoC's
execution includes only the parent's mapping, because the child has already
called <tt>munmap()</tt> on that page. This function does not take into
account the fact that the child can still access the parent's page through
the pipe; it ignores the elevated page reference count. Thus, the kernel allows
the parent process to write new data into the page, which is no longer
considered to be a COW page. Finally, the child wakes up and reads that new
data from the pipe, which might include sensitive information that the
parent did not expect the child to see.

<p>
<h4>Corralling the problem</h4>
<p>
One might rightfully ask why this potential of leaking data from parent to
child can matter in practice, as both processes are normally executing the
code from the same binary and the <tt>fork()</tt> only acts as a branch in
the code. So we can assume that, either the binary is trusted and thus the
child process is too, or it is not and then we probably should not let the
parent access any sensitive data in the first place. And, in the scenario
where <tt>fork()</tt> from a trusted binary is followed by an
<tt>exec()</tt> of a potentially malicious binary, <tt>exec()</tt> removes
all shared pages from the address space of the child process before loading
the new binary.
<p>
But, as the Project Zero issue mentions, there are
environments, such as Android, where each process is forked from a zygote
process without a subsequent <tt>exec()</tt>, for performance reasons.
That could lead to a situation that looks a lot like the PoC exploit for
this bug.

<p>

Moreover, the <tt>vmsplice()</tt> syscall might just be a symptom of a
broader issue, since there are many other callers of the GUP functions in
the kernel.  So it is a good idea in general not to let a child process
hold on to a page shared through the COW mechanism with the parent while
letting the parent write new contents to the page.
<p>
To prevent exploits of this behavior,
commit 17839856fd58  made it impossible to get a
reference (even a read-only reference) via GUP to a COW-shared page. All
such attempts now result in 
breaking COW and returning a reference to the new copy instead. Thus,
in the PoC code above, calling <tt>vmsplice()</tt> now causes the child
process to replace the shared COW page in the corresponding page table
entry with a new page, which is then passed to the pipe. Afterward, the
child no longer has any way to access the parent's page and the new
contents written there.
<p>

The commit notes the possibility of worse performance for some GUP users,
especially those that rely on a lockless variant of the interface like
<tt>get_user_pages_fast()</tt>. The changelog continues that finer-grained
rules could be added later for situations where it is clear that it is safe to
keep sharing the COW page because it can never be overwritten with new,
potentially sensitive contents.  The system-wide zero-page would be one
example of this sort of situation.  But otherwise, Linus Torvalds (the
author of the change) expected
no fundamental issues with this aggressively COW-breaking approach for
GUP. Linux 5.8 was duly released with this commit.
<p>

And this, one might think, was the end of the problem.  But, as was
mentioned at the outset, COW is a complicated and subtle beast.  In truth,
the problems were just beginning.  The <a href="/Articles/849876/">second
half of this article</a> will 
delve into how the COW fix led to a stampede of new problems that still
have yet to be completely solved.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-get_user_pages">Memory management/get_user_pages()</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Vulnerabilities">Security/Vulnerabilities</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#Babka_Vlastimil">Babka, Vlastimil</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/849638/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor850097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 22, 2021 18:55 UTC (Mon)
                               by <b>tux3</b> (subscriber, #101245)
                              [<a href="/Articles/850097/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What a cliffhanger!  <br>
I certainly am glad that project zero is there to root out these bugs (pun intended).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 12:37 UTC (Tue)
                               by <b>gerdesj</b> (subscriber, #5446)
                              [<a href="/Articles/850163/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;But, as the Project Zero issue mentions, there are environments, such as Android, where each process is forked from a zygote process without a subsequent exec(), for performance reasons. That could lead to a situation that looks a lot like the PoC exploit for this bug.&quot;<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor850107"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 22, 2021 19:22 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/850107/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s definitely a problem because it doesn&#x27;t match the user&#x27;s mental model of how fork() is supposed to work. It&#x27;s clear that either COW must be broken in this case or a mapping must be retained (or the refcounts split into per-mm versions, which seems likely to be far more expensive). The conceptually ideal approach would have everything act just like normal data, i.e. recognise things like vmsplice references *as* references so you don&#x27;t need to specially break COW early for them -- but this seems likely to be viciously complex and of only minor benefit. Of course, hunting down every single way a reference can be taken by a child and arranging to COW-break on all of them seems likely to be a nightmarish game of whack-a-mole too...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850107/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor850113"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 22, 2021 20:52 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/850113/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Over the years I found that COWs are just bad and it&#x27;s best to avoid them altogether.<br>
<p>
Can we already use io_uring to spawn new processes?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850113/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 22, 2021 23:09 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/850123/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If you&#x27;re going to break API compatibility anyway,* then you might as well just tell people to use vfork() or posix_spawn(), as those are already mature and well-understood interfaces, and the latter is even portable.<br>
<p>
Incidentally, while researching this comment, I stumbled across this tidbit from clone(2):<br>
<p>
<font class="QuotedText">&gt; In contrast to the glibc wrapper, the raw clone() system call</font><br>
<font class="QuotedText">&gt; accepts NULL as a stack argument (and clone3() likewise allows</font><br>
<font class="QuotedText">&gt; cl_args.stack to be NULL).  In this case, the child uses a</font><br>
<font class="QuotedText">&gt; duplicate of the parent&#x27;s stack.  (Copy-on-write semantics ensure</font><br>
<font class="QuotedText">&gt; that the child gets separate copies of stack pages when either</font><br>
<font class="QuotedText">&gt; process modifies the stack.)  In this case, for correct</font><br>
<font class="QuotedText">&gt; operation, the CLONE_VM option should not be specified.  (If the</font><br>
<font class="QuotedText">&gt; child shares the parent&#x27;s memory because of the use of the</font><br>
<font class="QuotedText">&gt; CLONE_VM flag, then no copy-on-write duplication occurs and chaos</font><br>
<font class="QuotedText">&gt; is likely to result.)</font><br>
<p>
That sounds like it would be fun to debug. Now I&#x27;m wondering if any developers have decided that they &quot;need to&quot; bypass glibc and pull this sort of chicanery on any of my systems... (I&#x27;m an SRE, so if it broke in production, it would be my problem to fix it). &quot;Fortunately,&quot; most of the bugs I&#x27;ve seen have tended to be higher-level than this, but it&#x27;s still a bit frightening that the kernel will just let you do something like that.<br>
<p>
* Which is obviously not going to happen given the kernel&#x27;s fanatical devotion to not breaking userspace, but let&#x27;s pretend for a moment.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850153"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 10:08 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/850153/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
posix_spawn() is not a single system call (technically both fork() and vfork() are wrappers around clone(2), but at least the latter is a single system call).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850153/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850191"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 16:12 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/850191/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well sure, but in the (absurd) hypothetical where we&#x27;re eliminating COW, the kernel would presumably need to grow an interface with capabilities similar to fork+exec, and the POSIX standard name for that interface is posix_spawn.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850191/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850223"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 23:00 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/850223/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Apparently, people dislike posix_spawn. Perhaps we would grow a full replacement that would allow to create a suspended process, tweak its attributes (using file handle-based API) and then resume it.<br>
<p>
But I feel what we might actually get is a io_uring-based API that does this using BPF. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850223/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 24, 2021 1:45 UTC (Wed)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/850248/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We _almost_ have that api already: ptrace.<br>
<p>
<p>
Minor problem being that ptrace is really awful. It&#x27;s too bad the proposals to add a saner handle based version have all died off.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor850158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 11:01 UTC (Tue)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/850158/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A couple of years ago we discussed this paper, which argues that fork() is fundamentally the wrong primitive to build OS process management around: <a href="https://lwn.net/Articles/785430/">https://lwn.net/Articles/785430/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor850170"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 14:17 UTC (Tue)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/850170/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I considered using vfork() recently, but ultimately decided against it after encountering too many warnings about it.  For example, see the history of glibc using vfork() for posix_spawn():<br>
<p>
glibc &lt;= 2.23:<br>
posix_spawn() uses vfork() if POSIX_SPAWN_USEVFORK is set or if there is no cleanup expected in the child before it exec(3)s the requested file. However, this implementation of vfork() was the source of a number of bugs.<br>
<p>
Linux glibc &gt;= 2.24:<br>
glibc commit 9ff72da471a509a8c19791efe469f47fa6977410<br>
posix_spawn() switches from vfork() to clone(CLONE_VM | CLONE_VFORK) which uses a separate stack for the child.  This fixes a number of vfork()-related bugs (&quot;possible parent clobber due stack spilling&quot;), making it possible to enable by default and ignore POSIX_SPAWN_USEVFORK.<br>
<p>
recent non-Linux glibc<br>
glibc commit ccfb2964726512f6669fea99a43afa714e2e6a80<br>
POSIX_SPAWN_USEVFORK is ignored and regular fork() is always used, due to difficulties getting vfork() to work without the Linux-specific clone() semantics.<br>
<p>
Note that using clone(CLONE_VM | CLONE_VFORK) safely requires blocking all signals, including NPTL-internal signals.  But the glibc wrappers don&#x27;t let you block NPTL-internal signals, making it much more difficult to do outside of glibc.  See the glibc implementation for all the gory details.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850170/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor850131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 22, 2021 23:42 UTC (Mon)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/850131/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Naïve non-kernel-developer perspective: this seems _intuitively_ like the wrong solution to the problem.  The child still has access to the page, so surely it should still be marked as having access to that page as long as it does indeed have a reference to it, rather than pretending it doesn&#x27;t have access to the page just because it&#x27;s been munmap&#x27;d.  Just because the page has been munmap&#x27;d doesn&#x27;t mean that the process can&#x27;t read from it, so why is the page table entry removed?  I assume there&#x27;s a very good reason why it&#x27;s done this way, though.  Could someone clear up my misunderstanding?<br>
<p>
For what it&#x27;s worth, this all reminds me of the SCM_RIGHTS/io_uring issue (<a href="https://lwn.net/Articles/779472/">https://lwn.net/Articles/779472/</a>). <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850135"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 0:20 UTC (Tue)
                               by <b>vbabka</b> (subscriber, #91706)
                              [<a href="/Articles/850135/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The child still has access to the page, so surely it should still be marked as having access to that page as long as it does indeed have a reference to it, rather than pretending it doesn&#x27;t have access to the page just because it&#x27;s been munmap&#x27;d.</font><br>
<p>
I&#x27;m not sure I understand your point, but that problem is prevented by the commit. When the child wants to take that extra reference (for vmsplice()) it gets a copy instead of the page shared with the parent. Afterwards both the page tables of the child and the reference held by the pipe point to this new copy, and the access to parent&#x27;s page is lost.<br>
<p>
<font class="QuotedText">&gt;  Just because the page has been munmap&#x27;d doesn&#x27;t mean that the process can&#x27;t read from it, so why is the page table entry removed?</font><br>
<p>
That&#x27;s simply the semantic of munmap() - it has to adjust the VMA tree and zap page table entries so that the munmapped range is no longer represented there. Then if the process tries to read/write to an address within the area, it segfaults. We can&#x27;t leave the page table entry there just because another reference exists. The read from the pipe doesn&#x27;t go through these page tables.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850135/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 3:37 UTC (Tue)
                               by <b>PengZheng</b> (subscriber, #108006)
                              [<a href="/Articles/850143/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a non-kernel developer, I&#x27;m curious:<br>
<p>
In retrospect, is this COW breaking fundamentally wrong?<br>
Why not treat vmsplice reference &quot;as references&quot;?  Is is possible to make the page inaccessible to the userspace process after munmap while still keep the kernel&#x27;s reference?<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850147"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 8:42 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/850147/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In principle yes, but then you have other problems.<br>
<p>
For example, mmap can be used to allocate memory at a fixed address. It can be difficult to tell whether any given address is suitable (because other pages etc. might be in the way), but if you had just munmapped it, it would be really weird for a subsequent mmap of the same address and size to fail. Userspace might assume that it doesn&#x27;t need to check the error code for mmap in that case (or it might not have suitable recovery code, and just call abort(3)).<br>
<p>
So now your solution needs to accommodate stacking a new page on top of the hidden page, or relocating the hidden page, either of which is nontrivial. That&#x27;s not even mentioning the fact that you need to teach vmsplice to track per-process references in the same way as pages do, without that page actually existing in the userspace page map. These are all rather difficult problems to solve, and this is a security issue, so solving hard problems is not the ideal form of a fix. Throwing in a simple COW break is a much more straightforward solution (but, as the story alludes, there was presumably some complication which they failed to account for).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850147/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850154"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 10:28 UTC (Tue)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/850154/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; if you had just munmapped it, it would be really weird for a subsequent mmap of the same address and size to fail. Userspace might assume that it doesn&#x27;t need to check the error code for mmap in that case (or it might not have suitable recovery code, and just call abort(3)).</font><br>
<p>
That reminds me of an old bug: About a decade ago, Firefox (using code from jemalloc) would try to do a large aligned allocation like &quot;p = mmap(NULL, size*2); munmap(p); p = mmap(round_up(p, alignment), size);&quot; i.e. using the first mmap+munmap to discover a large-enough hole in the address space, then allocating at a correctly-aligned address within that hole. If the second mmap didn&#x27;t return the address that was requested, there must have been a race condition with another thread that allocated in the same hole, so it would loop around and try again and hope for better luck next time.<br>
<p>
That worked okay until it ran on kernels with a security feature that randomised mmap and entirely ignored the address parameter (which is technically okay since it&#x27;s defined as just a hint, not a requirement), so the code got stuck in an infinite loop.<br>
<p>
That was fixed ages ago, but it does seem plausible that some userspace code may still make similarly unwise assumptions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850154/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor850189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 16:00 UTC (Tue)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/850189/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The PTE has to go away because that&#x27;s what munmap() is specified to do. Furthermore, the fact that it&#x27;s the same process at both ends of the pipe is irrelevant to the issue, I think. It seems to me like the simple solution would be to elevate the page map count while it&#x27;s in the pipe (but where else might a page be kept that a process other than parent could get it?) or use the refcount to decide if the parent is the exclusive owner (but maybe the parent has extra references?).<br>
<p>
I think the semantics that would be clear is that, if a reference can be used to read the contents of the page, or can be converted into a reference that can be used to read the contents of the page, it counts as a map. But then you&#x27;d have to identify what needs the addition.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor850148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 8:40 UTC (Tue)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/850148/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do any applications actually use vmsplice() at all? I remember making a prototype for a minimal HTTP server (it only ever existed to serve two static responses), and it helped a few percent, but was never put in production. It seems to have caused a fair bit of security headache over the years…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 10:06 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/850152/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Based on a quick Debian Code Search query:<br>
<p>
* The fio benchmarking tool supports it<br>
<p>
* openssl uses it with AF_ALG (which is also a bit on the obscure side), and so does libkcapi (a library for the kernel crypto API)<br>
<p>
* VLC is an interesting one, it uses vmsplice to dump the decompressed output of gzip/bzip2/xz into memory (probably because the rest of the program prefers to work with memory-mapped buffers?)<br>
<p>
* FUSE also uses it<br>
<p>
Also, Samba doesn&#x27;t use vmsplice but it uses splice to implement the opposite of sendfile (read from a socket into a file).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 21:49 UTC (Tue)
                               by <b>dgc</b> (subscriber, #6611)
                              [<a href="/Articles/850210/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup, vmsplice is the classic &quot;solution looking for a problem to solve&quot; interface. <br>
<p>
FWIW, given the well known documented caveats around combining Direct IO, mmap buffers and fork to avoid data corruption and &quot;undefined results&quot; (see open(2) man page) because of interactions COW, I&#x27;m also not at all surprised that there are very similar issues resulting from vmsplice() taking temporary unaccounted references to user mapped pages...<br>
<p>
-Dave.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850222"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 23, 2021 22:45 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/850222/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On the other hand vmsplice is just a handy shortcut. AIO or any use of g_u_p() can cause the same issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850222/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor850432"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2021 4:17 UTC (Thu)
                               by <b>alison</b> (subscriber, #63752)
                              [<a href="/Articles/850432/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Here is a naive question: why do we have both COW and RCU?   Is there any reason fork() couldn&#x27;t use RCU?   Is RCU safer?    RCU has extensive formal documentation but COW less so.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/850432/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor850442"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Patching until the COWs come home (part 1)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 25, 2021 7:29 UTC (Thu)
                               by <b>cladisch</b> (<b>&#x272D; supporter &#x272D;</b>, #50193)
                              [<a href="/Articles/850442/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>RCU requires that all software that accesses these data structures uses certain patterns and helper functions. (This is why we have <a href="https://lwn.net/Kernel/Index/#Read-copy-update">many articles</a> about it.)</p>
<p>COW uses the CPU's built-in virtual memory features to make it look to userspace software as if the pages were never shared to begin with.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/850442/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
