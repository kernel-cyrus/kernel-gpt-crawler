        <!DOCTYPE html>
        <html lang="en">
        <head><title>Moving the kernel to modern C [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/885941/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/885967/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/885941/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Moving the kernel to modern C</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Please consider subscribing to LWN</b>
<p>
Subscriptions are the lifeblood of LWN.net.  If you appreciate this
content and would like to see more of it, your subscription will
help to ensure that LWN continues to thrive.  Please visit
<a href="/Promo/nst-nag1/subscribe">this page</a> to join up and keep LWN on
the net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 24, 2022</br>
           </div>
Despite its generally fast-moving nature, the kernel project relies on a
number of old tools.  While critics like to focus on the community's
extensive use of email, a possibly more significant anachronism is the use
of the 1989 version of the C language standard for kernel code — a standard
that was codified before the kernel project even began over 30 years ago.
It is looking like that longstanding practice could be coming to an end as
soon as the 5.18 kernel, which can be expected in May of this year.
<p>
<h4>Linked-list concerns</h4>
<p>
The discussion started with <a
href="/ml/linux-kernel/20220217184829.1991035-1-jakobkoschel@gmail.com/">this
patch series</a> from Jakob Koschel, who is trying to prevent
speculative-execution vulnerabilities tied to the kernel's linked-list
primitives.  The kernel makes extensive use of doubly-linked lists defined
by <a
href="https://elixir.bootlin.com/linux/v5.17-rc5/source/include/linux/types.h#L177"><tt>struct
list_head</tt></a>:
<p>
<pre>
    struct list_head {
	struct list_head *next, *prev;
    };
</pre>
<p>
This structure is normally embedded into some other structure; in this way,
linked lists can be made with any structure type of interest.  Along with the
type, the kernel provides <a
href="https://elixir.bootlin.com/linux/v5.17-rc5/source/include/linux/list.h">a
vast array of functions and macros</a> that can be used to traverse and
manipulate linked lists.  One of those is <a
href="https://elixir.bootlin.com/linux/v5.17-rc5/source/scripts/kconfig/list.h#L43"><tt>list_for_each_entry()</tt></a>,
which is a macro masquerading as a sort of control structure.  To see how
this macro is used, imagine that the
kernel included a structure like this:
<p>
<pre>
    struct foo {
    	int fooness;
	struct list_head list;
    };
</pre>
<p>
The <tt>list</tt> member can be used to create a doubly-linked list of
<tt>foo</tt> structures; a separate <tt>list_head</tt> structure is usually
declared as the beginning of such a list; assume we have one called
<tt>foo_list</tt>.  Traversing this list is possible with code like:
<p>
<pre>
    struct foo *iterator;

    list_for_each_entry(iterator, &amp;foo_list, list) {
    	do_something_with(iterator);
    }
    /* Should not use iterator here */
</pre>
<p>

The
<tt>list</tt> parameter tells the macro what the name of the
<tt>list_head</tt> structure is within the <tt>foo</tt> structure.
This loop will be executed once for each element in the list, with
<tt>iterator</tt> pointing to that element.
<p>
Koschel included <a
href="/ml/linux-kernel/20220217184829.1991035-4-jakobkoschel@gmail.com/">a
patch</a> fixing a bug in the USB subsystem where the iterator passed to
this macro was used 
after the exit from the macro, which is a dangerous thing to do.  Depending
on what happens within the list, the contents of that iterator could be
something surprising, even in the absence of speculative execution.
Koschel fixed the problem by reworking the code in question to stop using
the iterator after the loop.
<p>
<h4>The plot twists</h4>
<p>
Linus Torvalds <a
href="/ml/linux-kernel/CAHk-=wg1RdFQ6OGb_H4ZJoUwEr-gk11QXeQx63n91m0tvVUdZw@mail.gmail.com/">didn't
much like the patch</a> and didn't see how it related to
speculative-execution vulnerabilities.  After Koschel <a
href="/ml/linux-kernel/86C4CE7D-6D93-456B-AA82-F8ADEACA40B7@gmail.com/">explained
the situation further</a>, though, Torvalds <a
href="/ml/linux-kernel/CAHk-=wiyCH7xeHcmiFJ-YgXUy2Jaj7pnkdKpcovt8fYbVFW3TA@mail.gmail.com/">agreed</a>
that "<q>this is just a regular bug, plain and simple</q>" and said
it should be fixed independently of the larger series.  But then he
wandered into the real source of the problem: that the iterator passed to
the list-traversal macros must be
declared in a scope outside of the loop itself:
<p>
<blockquote class="bq">
	The whole reason this kind of non-speculative bug can happen is
	that we historically didn't have C99-style "declare variables in
	loops". So list_for_each_entry() - and all the other ones -
	fundamentally always leaks the last HEAD entry out of the loop,
	simply because we couldn't declare the iterator variable in the
	loop itself.
</blockquote>
<p>
If it were possible to write a list-traversal macro that could declare its
own iterator, then that iterator would not be visible outside of the loop
and this kind of problem would not arise.  But, since the kernel is stuck
on the C89 standard, declaring variables within the loop is not possible.
<p>
Torvalds said that perhaps the time had come to look to moving to the <a
href="https://en.wikipedia.org/wiki/C99">C99 
standard</a> — it is still over 20&nbsp;years old, but is at least recent
enough to allow block-level variable declarations.  As he noted, this move
hasn't been done in the past "<q>because we had some odd problem with
some ancient gcc versions that broke documented initializers</q>".  But,
in the meantime,
the kernel has moved its minimum GCC requirement to version&nbsp;5.1, so
perhaps those bugs are no longer relevant.
<p>
Arnd Bergmann, who tends to keep a close eye on cross-architecture
compiler issues, <a
href="/ml/linux-kernel/CAK8P3a0DOC3s7x380XR_kN8UYQvkRqvE5LkHQfK2-KzwhcYqQQ@mail.gmail.com/">agreed</a>
that it should be possible for the kernel to move forward.  Indeed, he
suggested that it would be possible to go as far as the <a
href="https://en.wikipedia.org/wiki/C11_(C_standard_revision)">C11
standard</a> (from 2011) while the change was being made, though he wasn't
sure that 
C11 would bring anything new that would be useful to the kernel.  It might
even be possible to move to <a
href="https://en.wikipedia.org/wiki/C17_(C_standard_revision)">C17</a> or
even the yet-unfinished <a href="https://en.wikipedia.org/wiki/C2x">C2x</a>
version of the language.  That, however, has a downside in that it
"<q>would break gcc-5/6/7 support</q>", and the kernel still supports
those versions currently.  Raising the minimum GCC version to 8.x would
likely be more of a jump than the user community would be willing to accept
at this point.
<p>
Moving to C11 would not require changing the minimum GCC version, though,
and thus might be more readily doable.  Torvalds <a
href="/ml/linux-kernel/CAHk-=wicJ0VxEmnpb8=TJfkSDytFuf+dvQJj8kFWj0OF2FBZ9w@mail.gmail.com/">was
in favor</a> of that idea:
"<q>I really would love to finally move forward on this, considering that
it's been brewing for many many years</q>".  After Bergmann <a
href="/ml/linux-kernel/CAK8P3a2b_RtXkhQ2pwqbZ1zz6QtjaWwD4em_MCF_wGXRwZirKA@mail.gmail.com/">confirmed</a>
that it should be possible to do so, Torvalds <a
href="/ml/linux-kernel/CAHk-=wh97QY9fEQUK6zMVQwaQ_JWDvR=R+TxQ_0OYrMHQ+egvQ@mail.gmail.com/">declared</a>:
"<q>Ok, somebody please remind me, and let's just try this early in the
5.18 merge window</q>".
The 5.18 merge window is less than one month away, so this is a change that
could happen in the near future.
<p>
It is worth keeping in mind, though, that
a lot of things can happen between the merge window and the 5.18 release.
Moving to a new version of the language standard could reveal any number of
surprises in obscure places in the kernel; it would not take many of those
to cause the change to be reverted for now.  But, if all goes well, the
shift to C11 will happen in the next kernel release.  Converting all of the
users of <tt>list_for_each_entry()</tt> and variants (of which there are
well over 15,000 in the kernel) to a new version that doesn't expose the
internal iterator seems likely to take a little longer, though.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Build_system">Build system</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#GCC">GCC</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/885941/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor886000"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 15:12 UTC (Thu)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/886000/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Note that, if for some reason you need to stay with c89, you can always add a block around the for() statement to hold the loop variable.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886000/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886001"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 15:51 UTC (Thu)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/886001/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You&#x27;d need to do that to each caller, which is a *lot* of code churn.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886001/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886076"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 3:08 UTC (Fri)
                               by <b>kmeyer</b> (subscriber, #50720)
                              [<a href="/Articles/886076/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You would just do it once, in the macro definition.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886076/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886078"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 6:24 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/886078/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Based on the code shown in this article, I&#x27;m not clear on how you would actually do that. It *looks* like the macro expands to while(something) or for(something), and doesn&#x27;t even have the &quot;regular&quot; set of braces, so you can&#x27;t edit it to include an outer set of braces without modifying the call sites.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886078/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886081"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 7:08 UTC (Fri)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/886081/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t think you could with Linux&#x27;s list macros. You could with Sparse&#x27;s, which have pairs of macros invoked at the start and end of each loop (and which use two levels of braces).<br>
<p>
But C99 makes this easy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886081/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886079"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 11:33 UTC (Fri)
                               by <b>4m1rk</b> (guest, #157085)
                              [<a href="/Articles/886079/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The macro just creates the `for` expression. If you need to put the for expression inside a block then the macro needs to accept the body of the for too. Do C macros allow passing a code block?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886079/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886280"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 16:24 UTC (Sun)
                               by <b>mina86</b> (guest, #68442)
                              [<a href="/Articles/886280/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Do C macros allow passing a code block?</font><br>
<p>
Yes. You can pass pretty much whatever you want so long as parenthesise match and there is no comma outside of parenthesise.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886280/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor887393"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 9, 2022 23:56 UTC (Wed)
                               by <b>bartoc</b> (guest, #124262)
                              [<a href="/Articles/887393/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The comma is a bit of a huge pita if you&#x27;re passing a whole loop body.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887393/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor886308"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 23:59 UTC (Sun)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/886308/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
#define for if (false); else for<br>
<p>
:-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886308/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor886003"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 16:22 UTC (Thu)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/886003/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is &quot;documented initializers&quot; Linus&#x27;s typo for &quot;designated initializers&quot;?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886003/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 17:36 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/886040/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Instead of leaking a not-necessarily-valid pointer, couldn&#x27;t the macro set it to NULL at the end? Actually, I&#x27;m surprised there isn&#x27;t a standard trick for doing an assignment that will be an error unless the compiler eliminates it as dead code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886044"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 17:59 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/886044/">Link</a>] (28 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Cost.  Pretty significant cost in some cases for something that shouldn’t even be necessary.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886044/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 20:09 UTC (Thu)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/886053/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It should be cost-free in any case where the iteration variable isn&#x27;t accessed after the loop, since the compiler would eliminate the dead store. The code change is also fairly trivial: just edit the condition from &quot;&amp;pos-&gt;member != (head)&quot; to &quot;(&amp;pos-&gt;member != (head)) || ((pos = NULL))&quot;.<br>
<p>
Unfortunately this alone doesn&#x27;t handle loops which exit early due to &quot;break&quot; or &quot;goto&quot;. The &quot;goto&quot; case is unavoidable, but the &quot;break&quot; case can be dealt with by wrapping the macro in a second, trivial loop as shown in this example[0]. Note that the generated code (for gcc 5.1 with -O2) is *identical* between the version with the extra loop (traverse1) and the original version which does not set the iterator to NULL after the loop (traverse2). The initialization of the iterator to the flag state (-1), the condition for the outer loop, and the store of NULL to the iterator after the loop are all successfully eliminated.<br>
<p>
[0] <a href="https://godbolt.org/z/4obYManzc">https://godbolt.org/z/4obYManzc</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886061"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 20:48 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/886061/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It might work to have:<br>
<p>
extern unsigned long list_iterator_live_after_loop;<br>
<p>
and &quot;|| ((pos = (void *) list_iterator_live_after_loop), 0)&quot;<br>
<p>
I didn&#x27;t try changing the kernel macro that way, but my little test code doesn&#x27;t link if the iterator is used after the loop, but does link and work if it&#x27;s not used. As I recall, the kernel is already using that sort of trick to use compiler optimization to remove an error message only if the compiler can disprove it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886061/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886184"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 22:20 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/886184/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unfortunately, this is probably UB: <a href="https://en.cppreference.com/w/c/language/extern">https://en.cppreference.com/w/c/language/extern</a><br>
<p>
<font class="QuotedText">&gt; The entire program may have zero or one external definition of every identifier with external linkage.</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; If an identifier with external linkage is used in any expression other than a non-VLA, (since C99) sizeof, or _Alignof (since C11), there must be one and only one external definition for that identifier somewhere in the entire program.</font><br>
<p>
There&#x27;s no exception for short-circuit operators. If you use it at compile time, for anything other than sizeof, then it has to exist (have storage allocated somewhere).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886184/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 0:56 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/886200/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>It's an UB according to the standard.  But Linus very rarely is concerned with that: he tends to accept such stupidity only when there are no way convince compiler to stop breaking sane (from Linux developer's POV!) code.</p>

<p>It's one of the reasons about why GCC is the only supported compiler, BTW.</p>

<p>And GCC not just supports that feature, it even provides <code>__attribute__((__error(msg)))</code> extensions to make error messages more explicit. And GLibC uses it to define <code>__errordecl</code> macro.</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/886200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886206"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 2:34 UTC (Sat)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/886206/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And this sort of bad idea is why the kernel is only possible to compile with optimizations enabled.<br>
<p>
It would be a lot better if Linux used c++ constexpr functions and templates for compile time evaluation semantics, instead of abusing the optimizer to very poorly emulate them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886206/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor886075"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 1:19 UTC (Fri)
                               by <b>ianloic</b> (subscriber, #54050)
                              [<a href="/Articles/886075/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s kind of fascinating how small the cost is, even when using the pointer afterwards: <a href="https://godbolt.org/z/cbv4fqan3">https://godbolt.org/z/cbv4fqan3</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886075/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886057"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 20:26 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/886057/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, I meant to imply that the compiler would eliminate all of those writes except for ones that expose bugs, but then I got side-tracked by wondering if you could make the kernel not even link unless the compiler eliminated the write. Anyway, it wouldn&#x27;t affect the generated code unless the compiler can&#x27;t tell the code is correct.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886057/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886070"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 22:12 UTC (Thu)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/886070/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Very good point.<br>
<p>
God I’d sure love to get to a newer C standard though…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886070/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886083"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 8:54 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/886083/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The smarter move would be to start compiling the kernel with a C++ compiler. A weenier step would be to accept source files with a &quot;.cc&quot; suffix and build those with a C++ compiler.<br>
<p>
There would, in any case, be no need to step outside Gcc, where in fact that was done long ago, with no disruption, but with massive benefits. Anybody spooked about C++ should understand that Gcc and Clang are both coded in C++, whatever the language you compile on them.<br>
<p>
Similarly, anybody spooked by C++ &quot;hidden code&quot; should understand that Rust does literally all of the things they are spooked by; and all of its power comes from that.<br>
<p>
Staying on ancient EOL&#x27;d language Standards does nobody any good.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886083/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886084"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 9:02 UTC (Fri)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/886084/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suspect the people most likely to be spooked (for whatever value of &quot;spooked&quot;) by any &quot;hidden code&quot; aspect of C++ are equally likely to be similarly spooked by the similar aspects of Rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886084/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886087"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 9:33 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/886087/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If they understood programming better, they would be more spooked by their C compiler failing to emit such code where, without, the code they wrote is buggy.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886087/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886085"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 9:30 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886085/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A weenier step accepting .cc files? The problem with that is &quot;all of C++&quot; is a security / close-to-the-metal nightmare, and the definition of what is the acceptable subset varies with who you talk to.<br>
<p>
A further problem is the size / speed of the code. Yes C++ is *mostly* pretty good, but I suspect the compiler devs will barf on that word &quot;mostly&quot;.<br>
<p>
To what extent does kernel C currently drop out of C into assembler, and to what extent will C++ make that worse?<br>
<p>
No I don&#x27;t actually know the answers, I&#x27;m just predicting the devs&#x27; reactions.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886085/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886176"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 21:24 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/886176/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You demonstrate you know neither the answers, nor the questions, and are simply making things up as you go along. Just stop.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886176/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886224"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 13:46 UTC (Sat)
                               by <b>Paf</b> (subscriber, #91811)
                              [<a href="/Articles/886224/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, it’s nice to know you’ve solved the problems and all of the kernel devs opposed are just fools who cannot see the light.  I’m no expert in this particular area but I suspect there’s a *small* chance they’re not just all idiots.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886224/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886250"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 22:30 UTC (Sat)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886250/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I would not say they are fools. But they are somewhat hidebound - viz the use of email as their primary collaboration system. They are also as capable as the rest of us to have prejudices. C++ in the 1990s was not a good choice for a Kernel - the programming paradigms popular then, the quality of compilers then and the language features then were not there. We were also a lot less aware of the potential for security holes that C code was subject to without a careful eye. Things have changed. Knowledge has been acquired about the best approaches to things. It’s been over 20 years. But as evidenced by some comments on this article - attitudes change slowly. Linux is unusual in major software projects as being very much a product of one person’s idiosyncrasies. There is a certain groupthink that it is particularly susceptible too. Different ways of thinking have historically led to an unpleasant email. <br>
I suppose what I am saying is that experience outside the Kernel community suggests that using a language which enables the us of low or zero cost abstractions and automates resource management is a good idea. Trying to emulate these features in C89 (using macros!) because C89 is all you have is not a good solution. Preserving with C because it’s what you know is also not the best for a project that is used as a bedrock of modern computing.<br>
Kernel mode C++ standards exist. They’re quite reasonable and not hard to implement or learn. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886250/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886255"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 0:09 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886255/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I would not say they are fools. But they are somewhat hidebound - viz the use of email as their primary collaboration system. </font><br>
<p>
So you&#x27;re another idiot who thinks newer = better.<br>
<p>
I&#x27;m not saying these new-fangled things don&#x27;t work for you. And plenty of kernel devs use newer tools. But all these idiots going &quot;ooh! new! shiny!&quot; make life hell for people doing the work.<br>
<p>
I&#x27;m on a kernel mailing list. And reading the emails, I feel like tearing my hair out sometimes. But moving to Rust seems a far better solution than C++.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886255/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 8:13 UTC (Sun)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886272/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Newer does not always equal better, but using technology to solve problems is literally the business we are in. Submission of patches and PRs by email has real implications - security for one, less open and effective collaboration for another. Again, I’m not saying that it wasn’t the right solution for its time but there are alternatives that work better. <br>
And as for Rust, I’m a big fan of it but there is no way that the Kernel is going to be rewritten in Rust. It’s much more viable to replace some data structures and paradigms with C++ alternatives. This is possible without rewriting everything or completely retraining all existing contributors.<br>
And I don’t think calling people idiots is particularly helpful to what is a technical discussion. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886273"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 10:37 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886273/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You just admitted yourself in another comment that &quot;using C++ is not a technical problem&quot;. The problem is the social problem of making sure the C++ code really is smaller and more efficient than the C macros it replaces.<br>
<p>
AND THERE ARE TOO MANY &quot;OOH NEW SHINY&quot; LEMMINGS...<br>
<p>
Likewise moving away from email - the problem is a social problem - there AREN&#x27;T ENOUGH DEVELOPERS. I think a fair few subsystems ARE developed using solutions like github, gitlab, whatever. If it really worked, surely that model would spread rapidly. But it&#x27;s not working, and it&#x27;s not &quot;not working&quot; because the solution is better or worse, it&#x27;s not working because there aren&#x27;t enough people to make either solution work.<br>
<p>
And actually, probably one of the biggest problems with C++, is that IT&#x27;S NOT TRANSPARENT. Developers don&#x27;t have a clear model in their mind of HOW it works. I come from the days when tomorrow&#x27;s weather forecast took a day to run on the most powerful computers if you were lucky! If you can&#x27;t model performance down to the bare metal, you have no clue how long the program is going to take to run. That&#x27;s one of the reasons the kernel has held back on compilers so long, the disconnect between engineering reality and theoretical correctness. <br>
<p>
That&#x27;s one of the reasons I rant about relational. With Pick the database is transparent - as an application developer I can REASON about performance right through to the OS. That&#x27;s what&#x27;s so hard with C++ - the devs can NOT reason through to the hardware. (Okay, it&#x27;s getting harder even with C, but it&#x27;s not obfuscated ...)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886273/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886283"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Stop this please</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 16:51 UTC (Sun)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/886283/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Surely we can find a way to discuss things without calling each other idiots or lemmings, right? Please don't do this anymore.


      
          <div class="CommentReplyButton">
            <form action="/Articles/886283/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor886897"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2022 12:28 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/886897/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
[Caveat: haven&#x27;t written lots of C++ in years, and that was back in the early &#x27;10s. The language has changed and I haven&#x27;t kept up, I know...]<br>
<p>
The thing ncm likely meant was that Wol&#x27;s imagined kernel-developers&#x27; worries are not actually what they are documented as having worried about. C++ is not a security nightmare, not any more than C, anyway; it hasn&#x27;t been worse than C optimization-wise for about twenty years; and there is no sudden extra need to drop into asm just because this is C++ (C++ is still nearly a superset of C, and this is just as true of the GNU variant).<br>
<p>
Their stated worries are more that C++ has abstractions that enable things to magically happen behind your back with no immediate indication at the call site, and since the kernel developers are really looking for a portable assembler a lot of the time, where everything the machine does is obvious, this is *far* from what they want: they have their hands full coping with parallelism-induced complexities, memory model complexities, looking out for speculative execution gadgets etc etc, without worrying about the apparently same code doing wildly different things depending on what type they&#x27;re operating on.<br>
<p>
Many of C++&#x27;s transparently-do-things features are routinely used and almost essential to use anything resembling modern C++: references are the classic case (now function parameters&#x27; values can change in the caller without an &amp; at the call site), but also C++ before std::move used to not make it terribly clear whether things were being copied or not (and it was at the very least wordy to enforce one alternative), and even now we have things like stringviews which seem to come with built-in footguns. (Of course, the kernel would never use such pieces, but code review would need to make sure they never crept in... and you only need to forget *once*). Many of the pieces that *don&#x27;t* amount to &#x27;do this invisibly albeit usually helpfully&#x27; are related to templates, and, uh... the kernel is nonswappable code in which size is at a premium, and having the compiler promiscuously generate code to monomorphize templates on the fly was anathema for a long time (though Rust does the same thing, and people seem to be complaining less: maybe RAM is just that much cheaper now and kernel code size is less important? but icache bloat still matters, and Linus has worried about it in public, and that was years ago and it&#x27;s worse now).<br>
<p>
And that&#x27;s without even mentioning the really big painful problem, so big and painful that there are still compiler switches to disable the feature entirely, so big and painful that it took decades to figure out how to write code safely in the presence of these things and the last time I looked at it the safe code was extremely unobvious and if it was wrong you were unlikely to know for many years until things blew up, because there was no way to automatically check for safety: exceptions. Lovely idea, makes code&#x27;s non-exceptional path much clearer, but the implementation explodes exceptional flow paths and *all of them are invisible* and many might be in what looks like the middle of an atomic, indivisible entity to someone not thinking &quot;what if this were overloaded and threw?&quot;. If you use RTTI for absolutely everything religiously you don&#x27;t need to worry, but you only have to forget and do manual cleanup once and you&#x27;re in trouble when you next get an exception passing through that region. The kernel would obviously never use exceptions in the first place, mind you. Of course that now makes it impossible for destructors to fail, which probably rules out *use* of destructors for anything nontrivial, which means you can&#x27;t use RTTI, which means you can&#x27;t write anything resembling modern C++. You don&#x27;t pay for what you don&#x27;t use, but many of the bits require many of the other bits to use them non-clumsily, and then many of those bits are papering over design faults in the earlier bits -- std::move, again -- and the result of adding all those bits together is *ferociously* complex.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886897/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2022 13:37 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886899/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The thing ncm likely meant was that Wol&#x27;s imagined kernel-developers&#x27; worries are not actually what they are documented as having worried about. C++ is not a security nightmare, not any more than C, anyway; it hasn&#x27;t been worse than C optimization-wise for about twenty years; and there is no sudden extra need to drop into asm just because this is C++ (C++ is still nearly a superset of C, and this is just as true of the GNU variant).</font><br>
<p>
<font class="QuotedText">&gt; Their stated worries are more that C++ has abstractions that enable things to magically happen behind your back with no immediate indication at the call site, and since the kernel developers are really looking for a portable assembler a lot of the time, where everything the machine does is obvious, this is *far* from what they want: they have their hands full coping with parallelism-induced complexities, memory model complexities, looking out for speculative execution gadgets etc etc, without worrying about the apparently same code doing wildly different things depending on what type they&#x27;re operating on.</font><br>
<p>
Actually, this is pretty much exactly what I was trying to say ... that C++ does things behind your back, and when you&#x27;re trying to make sure that your code fits in L1 cache or whatever, code bloat is SERIOUS STUFF.<br>
<p>
How often do you see kernel developers talking about &quot;fast path&quot;? Quite a lot. And it only takes C++ to do something you don&#x27;t expect and the fast path will become orders of magnitude slower. WHOOPS!<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor887670"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 11, 2022 16:51 UTC (Fri)
                               by <b>timon</b> (subscriber, #152974)
                              [<a href="/Articles/887670/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think you mean RAII (Resource acquisition is initialization) instead of RTTI (Run-time type information).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/887670/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor888292"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 17, 2022 16:27 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/888292/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Um, yes, of course. I&#x27;ve had a mental hash collision between those two acronyms for literally decades, to such an extent that if you asked me what RTTI stood for I&#x27;d often say &quot;resource acquisition is oh wait&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/888292/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor886249"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 22:16 UTC (Sat)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886249/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The two aspects of C++ that are usually disabled are RTTI and exceptions. GCC and Clang both disable at least one if not both of the features (I believe GCC both and LLVM at least RTTI). C++ code which just uses RAII and non-virtual methods (an awful lot of modern C++ code) optimises to the same as equivalent C but does not really on people remembering to do all the manual steps and help abstract. Apple and Microsoft both have standards for Kernel mode C++ that could be used as a starting point if need be.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886249/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886102"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 14:52 UTC (Fri)
                               by <b>jd</b> (guest, #26381)
                              [<a href="/Articles/886102/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If we aren&#x27;t going to go with ancient, then move to D. It&#x27;s much, much newer and doesn&#x27;t carry anything like the risks or overheads of C++. (Not that I&#x27;d recommend it, for other reasons, but it helps illustrate the age of the standard shouldn&#x27;t matter as much as the quality of the result.)<br>
<p>
Is there markup for any of the static checkers beloved by kernel developers that could be used to improve the quality of the results? (And when was the last time Coverity checked the kernel?)<br>
<p>
There must be plenty that could be done to improve the kernel code without a drastic change of language.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886102/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886158"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 18:04 UTC (Fri)
                               by <b>davej</b> (subscriber, #354)
                              [<a href="/Articles/886158/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And when was the last time Coverity checked the kernel</font><br>
<p>
99% of the time, the answer to this question is the same as &quot;when did Linus last cut an -rc/final&quot;.<br>
I usually kick off a run the same day, failing that the following morning.<br>
<p>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886158/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886395"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 18:38 UTC (Mon)
                               by <b>jd</b> (guest, #26381)
                              [<a href="/Articles/886395/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s very comforting to know. I don&#x27;t know how much it is picking up these days, but I&#x27;ve been haunting the fringes long enough to know that it has always provided a very important service to kernel developers. (Through the mead haze, I can dimly recall when it was first used.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886395/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 21:33 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/886177/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I doubt Coverity works on D code. It does work on C++. &quot;Risks and overheads&quot; is wholesale speculation, unwelcome here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor886066"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 21:11 UTC (Thu)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/886066/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      It would break code that does this:

<pre>
list_for_each_entry(iterator, &amp;foo_list, list) {
    	if (do_something_with(iterator)) {
    		break;
    	}
}
if (list_entry_is_head(iterator, &amp;foo_list, list)) {
	// iteration finished
} else {
	do_something_else_with(iterator);
}
</pre>

All this "compare to head" nonsense is why I prefer regular NULL-terminated linked lists to the kernel's circular linked lists.  Insert/delete may take more instructions but iteration is much easier.


      
          <div class="CommentReplyButton">
            <form action="/Articles/886066/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 21:55 UTC (Thu)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/886068/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Yes, and you also have macros like for_each_list_entry_continue() which depend on the value being left in the iterator. All of these would also break if the macro was changed to declare the iterator inside the `for` statement, C99-style.</p>

<p>One way to work around the problem in your example would be to move the condition inside the loop, like this:</p>

<pre>
list_for_each_entry(iterator, &amp;foo_list, list) {
    // ...
    if (do_something_with(iterator)) {
        do_something_else_with(iterator);
        break;
    }
    // ...
    if (&amp;iterator-&gt;list == &amp;foo_list) {
        // this is the last entry; iteration finished
    }
}
</pre>

<p>The compiler should be smart enough to avoid checking the end condition twice in each iteration. Of course this becomes much less convenient if there is more than one break statement.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/886068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor886041"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 17:46 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/886041/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My thought is that it&#x27;s silly to require compatibility with standards old enough that even software implementing their newer versions are falling out of long-term support. There are other cases where arguably there&#x27;s a risk of causing a flag day, but moving off of C89 isn&#x27;t one of them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886041/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886051"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 18:47 UTC (Thu)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/886051/">Link</a>] (47 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yay!<br>
<p>
Don&#x27;t forget this one too:<br>
<p>
# warn about C99 declaration after statement<br>
KBUILD_CFLAGS += -Wdeclaration-after-statement<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886051/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886054"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 19:37 UTC (Thu)
                               by <b>zuzzurro</b> (subscriber, #61118)
                              [<a href="/Articles/886054/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If the plan is to make this move at the beginning of the next cycle, shouldn&#x27;t the -next kernel adopt it right now?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886054/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886058"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 24, 2022 20:30 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886058/">Link</a>] (45 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes please, finally! Combined declarations and initializations like every other programming language. More &#x27;const&#x27; and fewer &quot;this variable &#x27;may&#x27; be used uninitialized&quot; guessing/silliness. No more reverse Christmas trees.<br>
<p>
In even more advanced languages &#x27;const&#x27; is the default but let&#x27;s not get carried away; too much maths that could scare hardware engineers emotionally attached to their registers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886058/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886086"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 9:29 UTC (Fri)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/886086/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In even more advanced languages &#x27;const&#x27; is the default </font><br>
<p>
&quot;const&quot; is the default for /var/iables?!?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886086/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886088"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 9:37 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/886088/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Let us not confuse the name with the thing named.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886088/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 0:14 UTC (Sat)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886195/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Const is the default for named values. Mutability is opt in in Rust. C and C++ have const as the opt in.<br>
Scala has different words for mutable and non-mutable values (var and val respectively.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Constant v Immutable</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 19:10 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/886398/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Rust distinguishes constants from variables which simply can&#x27;t be mutated. By default you get a variable but it can&#x27;t be mutated. You can declare constants instead with &quot;const&quot; or, if you annotate your variable with &quot;mut&quot; you allow the variable to be mutated subsequently.<br>
<p>
let cannot_change = some::expression(with_variables_if_you, want);<br>
<p>
const COMPILE_TIME: u32 = my::WayToGet::a_constant_value(PERHAPS_FROM_OTHER_CONSTANTS);<br>
<p>
let mut count = 0; /* We will change this, presumably when counting stuff */<br>
<p>
At compile time the constants must be well, constant, (over time the amount of labour the compiler is willing to undertake to determine what that constant *is* has increased, as it has in C++ to a much greater extent) but the ordinary immutable value is not known at compile time, yet, it is immutable (of course if it&#x27;s inside the scope of a loop, it will be conjured into existence, perhaps with a new value, each time the loop runs)<br>
<p>
This means Rust programs naturally do Kate Gregory&#x27;s first step from maintaining a C++ codebase, marking everything immutable and then only marking as mutable the stuff that actually changes, so now the maintenance programmer has some idea what&#x27;s actually going on.<br>
<p>
If you&#x27;re familiar with C, Rust&#x27;s const is like a type-safe improvement on #define and Rust&#x27;s default immutable variables are more like C&#x27;s const. You may notice that the types were elided from my variable examples but not the constant, Rust insists on being explicitly told the type of constants but it will infer types for many variables from how they&#x27;re defined or used.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886311"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 3:36 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886311/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; In even more advanced languages &#x27;const&#x27; is the default</font><br>
<font class="QuotedText">&gt;</font><br>
<font class="QuotedText">&gt; &quot;const&quot; is the default for /var/iables?!?</font><br>
<p>
Sorry, I should used the standard name &quot;non-modifiable lvalue&quot;  /s<br>
<p>
More seriously, you&#x27;re highlighting a serious &quot;const&quot; problem in the programming languages and culture and especially in C. It&#x27;s very confusing to call &quot;constant&quot; something in a local scope that does not change after initialization but that is _different_ everytime the including function is called. So yes, an &quot;immutable variable&quot; is the unfortunate and confusing name used to make that difference.<br>
<p>
Rust does make a formal difference between 1) constant, 2) immutable and 3) mutable variables:<a href="https://doc.rust-lang.org/book/ch03-01-variables-and-mutability.html">https://doc.rust-lang.org/book/ch03-01-variables-and-muta...</a><br>
<p>
Consider this example:<br>
<p>
some_function()<br>
{<br>
   ... <br>
   z = f(g(x1) + h(x2)) / (j(x3) - k(x4)) - l(x5) + ... ; <br>
    ...<br>
}<br>
<p>
There is a simple reason why most people don&#x27;t write code like this and why they break it down into multiple steps: readability. Not just to avoid very long lines but to simply give a good NAME to carefully chosen checkpoints in the middle:<br>
<p>
some_function()<br>
{ <br>
  ... some code, including of course some statements and not just declarations ...<br>
<p>
   const meaningful_name1 = f(g(x1) + h(x2) ; <br>
   const meaningful_name2 =  j(x3) - k(x4);<br>
   etc. <br>
   ...<br>
}<br>
<p>
Funny enough, I&#x27;ve sometimes seen this lack of intermediate &quot;variables&quot; being abused by people new to functional languages (&quot;look Ma, no variables!). It&#x27;s especially tempting when you have a ternary operator more readable than &quot; cond ? A : B&quot;. I digress.<br>
<p>
It&#x27;s sad that many programming languages seem to care so little about the difference between read-only and read/write when mutability is in fact the most critical programming concept for both correctness (unintended side effects) and concurrency:<br>
<a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">https://doc.rust-lang.org/book/ch16-00-concurrency.html</a><br>
<p>
Every documentation about concurrency, locking, RCU and what not uses the words READ and WRITE every other line. Yet C does not care and calls everything &quot;a variable&quot;. Can you see a problem / gap here?  C, the low level language  supposedly in charge of managing  memory accessed concurrently by devices and multicores got a formal memory model in... 2011! After Java and I believe by basically borrowing the C++ one. RCU and locking experts aside, the vast majority of kernel developers  underestimates or even ignores the ridicule of that C-tuation.<br>
<p>
And of course the more read-only variables you have, the less likely you are to modify them by mistake. Can&#x27;t hurt when coding in _the_ language of memory corruptions.<br>
<p>
C has been influenced too much by the hardware engineering perspective where a variable is a memory location / register and not enough by the more &quot;mathematical&quot; view where a variable is just a name given to the result of some computation. Allowing declarations after statements is a baby step but into the right direction. All grown-up languages have already taken this step.<br>
<p>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886311/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886314"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 8:17 UTC (Mon)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/886314/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thanks, I do like the mathematical view!<br>
And allowing declarations after statements is a requirement for making intermediate results of non-trivial processing const.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886314/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886428"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 0:09 UTC (Tue)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886428/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Forgot the classic reference: <a href="https://queue.acm.org/detail.cfm?id=3212479">https://queue.acm.org/detail.cfm?id=3212479</a><br>
<p>
C Is Not a Low-level Language<br>
Your computer is not a fast PDP-11.<br>
David Chisnall<br>
<p>
<font class="QuotedText">&gt; Caches are large, but their size isn&#x27;t the only reason for their complexity. The cache coherency protocol is one of the hardest parts of a modern CPU to make both fast and correct. Most of the complexity involved comes from supporting a language in which data is expected to be both shared and mutable as a matter of course. Consider in contrast an Erlang-style abstract machine, where every object is either thread-local or immutable</font><br>
<p>
Etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886428/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor886089"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 9:39 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/886089/">Link</a>] (37 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Combined declarations and initializations like every other programming language.</font><br>
<p>
Please no!  That&#x27;s the most horrible thing I hate in modern C.<br>
<p>
Normally when reviewing code and looking for a variable, you just need to glance at<br>
the top of each upper level opening brace and nothing more. With those insane<br>
declarations after statement, you work like in bash: you have to read *ALL* lines<br>
above where you are, hoping you didn&#x27;t miss the right one. This serves absolutely<br>
no purpose, and only has for effect to complicate code reviews and ease introduction<br>
of new bugs.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886089/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886099"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 11:14 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886099/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You&#x27;re confusing &quot;use&quot; and &quot;initialise&quot;.<br>
<p>
Don&#x27;t allow mixing USE and declaration. But DO allow the *compiler* to set the initial value.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886099/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886126"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 15:13 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/886126/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m not sure we&#x27;re speaking about the same thing. I&#x27;m speaking about not making this monstrosity possible, where I&#x27;d say &quot;good luck&quot; for figuring the type of &quot;i&quot; depending on the line you&#x27;re reading, and its bounds:<br>
<p>
#include &lt;stdio.h&gt;<br>
#include &lt;unistd.h&gt;<br>
<p>
int blah(long x, int j)<br>
{<br>
        long i = x ? x : -1;<br>
        int k = i;<br>
<p>
        for (int i = 1; i &lt; j; i++) {<br>
                k += i * 2;<br>
                char i = (k &amp; 1) ? &#x27;O&#x27; : &#x27;E&#x27;;<br>
                int pid = getpid();<br>
                printf(&quot;i=%d j=%d pid=%d\n&quot;, i, j, pid);<br>
        }<br>
        return k;<br>
}<br>
<p>
PS: sorry for the formatting, I didn&#x27;t find how to make a code block.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886126/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 16:16 UTC (Fri)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/886144/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Making a code block on LWN needs two tags in HTML formatting: &lt;pre&gt; to indicate that formatting matters, and &lt;tt&gt; to indicate that you want monospaced fonts. Below is &lt;pre&gt;&lt;tt&gt; followed by your code (with indentation added by my brain), followed by &lt;/tt&gt;&lt;/pre&gt; - I've also had to escape special characters with HTML escapes (but it's a simple matter to write code to do this for you).
<pre>
<tt>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int blah(long x, int j)
{
    long i = x ? x : -1;
    int k = i;

    for (int i = 1; i &lt; j; i++) {
        k += i * 2;
        char i = (k &amp; 1) ? 'O' : 'E';
        int pid = getpid();
        printf("i=%d j=%d pid=%d\n", i, j, pid);
    }
    return k;
}
</tt>
</pre>


      
          <div class="CommentReplyButton">
            <form action="/Articles/886144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886318"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 10:15 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/886318/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I&#x27;ve also had to escape special characters with HTML escapes</font><br>
<p>
Thanks. That was the thing that made me think I was heading the wrong direction and that possibly there was something simpler in order to just paste a piece of code.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886318/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 16:51 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886151/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought that was allowed in ancient C ...<br>
<p>
Unless you mean actually declaring inside the &quot;if&quot; statement ... but I thought declaring after a { was permitted anywhere. I dunno, it&#x27;s ages since I&#x27;ve programmed C in anger.<br>
<p>
But it would be nice to say you can ONLY declare after a {, but that includes things like &quot;int i = 1&quot;. You shouldn&#x27;t be able to do things like &quot;int i; i=1; int j; j=2;&quot;, though.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 18:44 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/886159/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>In C89 and GNU89 declarations must occur before statements within each block. C89 additional requires initializers to be compiler-time constants. However, it's not as if this equivalent GNU89 code is any easier to follow:</p>

<pre><tt>#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int blah(long x, int j)
{
    long i = x ? x : -1;
    int k = i;
    {
        int i;
        for (i = 1; i &lt; j; i++) {
            k += i * 2;
            {
                char i = (k &amp; 1) ? 'O' : 'E';
                {
                    int pid = getpid();
                    printf("i=%d j=%d pid=%d\n", i, j, pid);
                }
            }
        }
    }
    return k;
}</tt></pre>

<p>The real lessons here are "use meaningful names" and "avoid shadowing".</p>





      
          <div class="CommentReplyButton">
            <form action="/Articles/886159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886197"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 0:21 UTC (Sat)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886197/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is called variable shadowing and is possible in C89 as well. It can be very ugly which is why it is discouraged although a good compiler should warn on shadowing.<br>
A good practice in modern languages is to combine declaration and initialisation so that you reduce the chance of accessing an uninitialised value. It also encourages locality in the code which makes it easier to comprehend. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886197/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886323"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 11:48 UTC (Mon)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/886323/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <pre>
main.cpp:11:6: error: redeclaration of ‘char i’
   11 | char i = (k &amp; 1) ? 'O' : 'E';
      |      ^
main.cpp:9:10: note: ‘int i’ previously declared here
    9 | for (int i = 1; i &lt; j; i++) {
      |          ^
</pre>


      
          <div class="CommentReplyButton">
            <form action="/Articles/886323/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886329"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 13:56 UTC (Mon)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/886329/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You seem to have a faulty C compiler, or you didn&#x27;t copy the code correctly. The curly bracket at the end of line 9 starts a new block, and it&#x27;s perfectly legal to declare a new &#x27;i&#x27; variable inside that block.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886329/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886385"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 17:06 UTC (Mon)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/886385/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That might be valid C (although I don&#x27;t know why, but it doesn&#x27;t give any errors in an online C compiler).  It isn&#x27;t valid C++.  The scope of the control variable declared in the for loop is the loop itself, so you can&#x27;t declare another variable with the same name in the same scope.<br>
<p>
for (int i = ..)<br>
{<br>
   int i = 2;  // not valid C++.  There is already a variable &#x27;i&#x27; declared in this scope<br>
}<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886385/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886406"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 20:10 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/886406/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The scope of the control variable declared in the for loop is the loop itself, so you can&#x27;t declare another variable with the same name in the same scope.</font><br>
<p>
What you say agrees with the C++ standard, but it makes me wonder why the standard authors appear to have been competing to come up with the most Byzantine special cases and exceptions they could think of to integrate into the standard rather than taking the simplest and least surprising route. Syntactically, the body of the for loop is a single statement which may be a compound statement. That part is the same as C. The braces are *not* part of the syntax for the loop. If the scope of the control variable were in fact the loop itself, and the body were treated the same as any other statement, then the compound statement would be an independent scope nested *within* that for-loop scope, and declarations within the compound statement would shadow any declarations scoped to the for loop (as they do in C). Instead the standard pierces the abstraction and treats compound statements in a for loop body differently than compound statements located elsewhere. There is no logic to this that I can see, just a bald statement that &quot;If a name introduced in an init-statement or for-range-declaration is redeclared in the outermost block of the substatement, the program is ill-formed.&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886406/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886492"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 16:27 UTC (Tue)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/886492/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In C++ the declaration and the body of the loop are the same scope.  In C, initializer in the for loop establishes its own scope, so there are actually two scopes created with a C for loop.  This was unintended behavior in C, and a defect report was raised about it, but it seems it wasn&#x27;t seen as important enough.  <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2257.htm#dr_466">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2257.htm...</a><br>
<p>
After all, who would write such code anyway?  Its a strange thing to take issue with.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886492/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886500"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 21:58 UTC (Tue)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/886500/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>&gt; In C++ the declaration and the body of the loop are the same scope.</p>

<pre><tt>for (init-statement condition[opt] ; expression) statement</tt></pre>

<p>The body of the for loop is just *statement*. If the declaration were in that scope it wouldn't survive from one iteration of the loop to the next or be visible in *condition* or *expression*. Declarations in *init-statement* are scoped over the entire for loop, not just the body.</p>

<p>Normally a compound statement within *statement* would introduce its own separate block scope *below* the level of *statement*, but in C++ the lines are blurred between the body of the for loop and the *inside* of the compound statement. In other words, I would expect this to be a redeclaration error, because `char i` and `int i` are declared in the same scope (note that all the examples in the standard are of this form):</p>

<pre><tt>for (int i = 0; i &lt; N; ++i)
    char i = 7;</tt></pre>

<p>but not this, because `char i` is declared in the new *nested* scope created by the compound statement and not directly in the body of the for loop:</p>

<pre><tt>for (int i = 0; i &lt; N; ++i) {
    char i = 7;
}</tt></pre>

<p>Contrast this with the following code which the standard (C++20 draft) claims is "equivalent" to the second example "except that names declared in the init-statement are in the same declarative region as those declared in the condition, and except that a continue in statement (not enclosed in another iteration statement) will execute expression before re-evaluating condition":</p>

<pre><tt>{
    int i = 0;  /* init-statement */
    while (i &lt; N  /* condition */) {
        { char i = 7; }  // statement
        ++i;
    }
}</tt></pre>

<p>In the "equivalent" while loop version there is clearly no redeclaration error—the `char i` declaration is within not just one but two levels of compound statements under the while loop and the scope where `int i` was declared.</p>

<p>&gt; After all, who would write such code anyway? Its a strange thing to take issue with.</p>

<p>Whether you would write that by hand or not, it's an unnecessary (and IMHO completely pointless) complication which moreover breaks compatibility with C. Redeclaration conflicts could appear as a result of macro expansion or other code generation, not just in hand-written code.</p>





      
          <div class="CommentReplyButton">
            <form action="/Articles/886500/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886529"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2022 8:56 UTC (Wed)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/886529/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You&#x27;ve got the history the wrong way around.  The behaviour of C++ here hasn&#x27;t changed since it was first standardized in 1998.  At that time, C didn&#x27;t allow a declaration in a for statement.  C99 borrowed the wording from the C++ Annotated Reference Manual, without realizing that the wording had been updated during the C++ standardization process.  So C introduced an incompatibility with C++, not the other way around.  The C standards committee documents are very clear that this was accidental, not intentional.<br>
<p>
The bottom line is that C++ will flag an error in some instances of very dubious code that is most likely a bug anyway (i.e. declaring a variable that shadows the loop control variable) where C99 would allow it.  None of the standards committee see it as something worth the bother of fixing.  If you really did intend to introduce a shadow declaration, the simple fix is to enclose it in another compound statement.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886529/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor886386"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 17:14 UTC (Mon)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/886386/">Link</a>] 
      </p>
      
      </div>
      </summary>
      See also <a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1865.htm">http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1865.htm</a>


      
          <div class="CommentReplyButton">
            <form action="/Articles/886386/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor886098"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 11:28 UTC (Fri)
                               by <b>jem</b> (subscriber, #24231)
                              [<a href="/Articles/886098/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>You can add this to the list of things you hate about Rust, too. In Rust you can even do this:</p>

<pre>
fn main() {
    let i = 0;
    println!("{}", i);    // Prints 0.
    
    let i = i+1;
    println!("{}", i);    // Prints 1.
}
</pre>

<p>Note that the i variables are immutable ("const") and there are two of them. The second let introduces a new variable which is initialized with the value i+1, where i refers to the first variable.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/886098/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886313"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 8:09 UTC (Mon)
                               by <b>geert</b> (subscriber, #98403)
                              [<a href="/Articles/886313/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So is this really any safer in the end?<br>
I still cannot rely on the constant i being constant over the full range of the block, as anyone can have inserted one or more redefinitions in the middle of the block.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886313/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886316"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 9:38 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886316/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I believe every compiler for pretty much every language can detect shadowing and warn about it. C included.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886316/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886317"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 10:09 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/886317/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Go is a notable exception.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886317/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886321"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 11:26 UTC (Mon)
                               by <b>taladar</b> (subscriber, #68407)
                              [<a href="/Articles/886321/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It is quite idiomatic in Rust to check a Result&lt;T, E&gt; value and reuse the same name for the content of type T after checking.<br>
<p>
The alternative isn&#x27;t really any better, coming up with extra names for what is logically the same value.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886321/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor886154"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 19:30 UTC (Fri)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/886154/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Please no! That&#x27;s the most horrible thing I hate in modern C.</font><br>
<p>
I am glad to see I am not alone.<br>
<p>
Usually, when it is used, it is a sign the function is too large and should be split, which would resolve the scoping issue.<br>
Of course since C17 still does not support gnu89 nested functions, sometime splitting the function require passing an inordinate amount of parameters.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886154/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886164"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 19:53 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886164/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; Please no! That&#x27;s the most horrible thing I hate in modern C.</font><br>
<p>
You meant: in _any_ vaguely modern language. What rock have you been living under?<br>
<p>
<font class="QuotedText">&gt; Usually, when it is used, it is a sign the function is too large and should be split, which would resolve the scoping issue.</font><br>
<p>
Exactly. If you can&#x27;t find a variable declaration then the function is simply too long.<br>
<p>
Of course with <a href="https://en.wikipedia.org/wiki/Type_inference">https://en.wikipedia.org/wiki/Type_inference</a> (1958) you don&#x27;t even need to declarations _at all_ but again, let&#x27;s not get carried away and scare ancient species...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886164/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 20:53 UTC (Fri)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/886171/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
If I can&#x27;t find the variable declaration, I&#x27;m using generic or weakly language-aware editing tools instead of strongly language-aware editing tools.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886228"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 14:07 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886228/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are you telling me strongly language-aware editing tools can find non-existing declarations?<br>
<p>
Okay, I find the lack of declarations ON OCCASION a complete pain, but don&#x27;t blame the tool if the language doesn&#x27;t require declarations. There&#x27;s plenty of languages like that out there ...<br>
<p>
(Which is why I tend to use Option Explicit in VB, or -DCLVAR in FORTRAN, etc etc.)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886228/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886230"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 14:55 UTC (Sat)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/886230/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; There&#x27;s plenty of languages like that out there ...</font><br>
<p>
There are, but in the small handful that I use (or have used in the past), I have never written a program where losing track of where I first initialized a variable would be a serious concern.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886230/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886237"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 15:19 UTC (Sat)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/886237/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Are you telling me strongly language-aware editing tools can find non-existing declarations?</font><br>
<p>
Well, no, but they can tell you what types the compiler has inferred for those variables (assuming the program is currently syntactically valid enough to do so, which in my experience is usually true if you&#x27;re doing maintenance rather than writing a new function: if you&#x27;re writing a new function, I hope you already know what types the variables you&#x27;re using in your new code are. :) )<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886237/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 22:10 UTC (Sat)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886248/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Type Inference is not the same as no declaration. Type Inference just means types don’t have to be explicitly stated where the compiler can infer it from the expression used to initialise the variable. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886279"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 16:04 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886279/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why would be the purpose of a declaration without an explicit type?<br>
<p>
How would a typeless declaration help the people in this thread who complain about not finding declarations? If not the type, what else are they looking for?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886279/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886287"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 18:55 UTC (Sun)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886287/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The declaration has a type - it’s inferred from the initialiser. It’s really only appropriate with local variables. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886287/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886300"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 20:49 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886300/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I see nothing factually wrong in your last two comments above but I really don&#x27;t understand why they&#x27;re posted as replies to mine. I&#x27;m afraid you&#x27;re misunderstanding my points and questions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886300/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886289"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 19:06 UTC (Sun)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/886289/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In Rust, it can move the lifetime of a variable around. So if I have some code that needs to live for the outer scope, but is only &quot;known&quot; in some nested place, I can use `let somename;` on a block in the right place, initialize it where the data is available, and continue on. I&#x27;ve used this before to keep a string alive long enough for a context where it may have been either allocated (and therefore need a place to hang its destructor) or came from some other string that lived longer than the function anyways.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886289/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor886166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 20:31 UTC (Fri)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/886166/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; gnu89 nested functions</font><br>
<br>
Which require your entire program to have an <a href="https://en.wikipedia.org/wiki/Nested_function#No-execute_stacks">executable stack</a>.





      
          <div class="CommentReplyButton">
            <form action="/Articles/886166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886175"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 20:55 UTC (Fri)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/886175/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They only do if they are used as function pointers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886175/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886180"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 22:12 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/886180/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Of course in C++ and Rust you have function literals. In C++,
<pre>
<tt>
  auto f = [](auto a, auto b) { return a + b; };
  assert(f(3, 4) == 7);
  assert(f(3.25, 3.75) == 7.0);
  assert(f("3"s, "4"s) == "34");
</tt>
</pre>
Rust lambdas might be less versatile.


      
          <div class="CommentReplyButton">
            <form action="/Articles/886180/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886196"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 0:18 UTC (Sat)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886196/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, Rust Lambdas generally work the same as C++ lambdas - subject to the usual Rust rules about lifetime.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886196/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor886190"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 23:25 UTC (Fri)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/886190/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a vim user, I just use the asterisk and hash keys to find the declaration. Not sure what your editor supports, but if it can&#x27;t do that, you might want to consider switching to a different editor (not necessarily vim, of course, whatever works for you).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886190/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886221"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 10:40 UTC (Sat)
                               by <b>niner</b> (subscriber, #26151)
                              [<a href="/Articles/886221/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I have fixed far too many bugs caused by people having to restructure perfectly readable code to appease the C89 gods. Some of those bugs I had introduced myself. On the other hand I have yet to come across a single bug in our code that was clearly caused by any confusion supposedly allowed by having variables declared where they are actually going to be used. Indeed the latter can make things even clearer, because it allows for more usage of const as in:
<pre>
{
    foo();
    void * const x = must_be_called_after_foo();
    ...
}
</pre>



      
          <div class="CommentReplyButton">
            <form action="/Articles/886221/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor886077"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 4:31 UTC (Fri)
                               by <b>pabs</b> (subscriber, #43278)
                              [<a href="/Articles/886077/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I wonder what the implications of this are for Bootstrappable Builds. I guess they will just need a longer GCC versions bridge before getting to the step of building Linux.<br>
<p>
<a href="https://bootstrappable.org/">https://bootstrappable.org/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886077/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886097"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 25, 2022 10:49 UTC (Fri)
                               by <b>georgm</b> (subscriber, #19574)
                              [<a href="/Articles/886097/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As written in the article, the minimum supported gcc version (5.1) already supports C11, so there shouldn&#x27;t be any change here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886097/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886198"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 0:26 UTC (Sat)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886198/">Link</a>] (53 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It always amuses me how C programmers / Linux Kernel types disavow C++ and then proceed to recreate C++ features using a mixture of macros and a hope that everyone is on their best behaviour. I seem to recall that this was why GCC moved to using C++ because it has features that help when working with data structures (RAII, methods etc.)<br>
No one is saying you have to use RTTI or exceptions although templates won’t be the worst idea in some of these cases if used properly. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886198/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886244"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 21:56 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886244/">Link</a>] (52 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; then proceed to recreate C++ features using a mixture of macros </font><br>
<p>
You have a very good point but you also have the exact reason why this keeps happening:<br>
<p>
<font class="QuotedText">&gt; No one is saying you have to use RTTI or exceptions ...</font><br>
<p>
The problem is: how do you tell developers _not_ to use RTTI, exceptions or any other of the gazillion features from the C++ kitchen sink that you don&#x27;t want them to use? Most people don&#x27;t read coding standards until they&#x27;re told to (too late) and maintainers don&#x27;t scale.<br>
<p>
The _only_ way to enforce something efficiently and consistently is to have a fully automated tool (compiler, linter, static analyzer,...) that catches it. Anyone who has ever used CI knows that.<br>
<p>
C++ fans who keep telling everyone &quot;modern C++ can do that too&quot; keep missing the point. The question is absolutely not about what C++ can do; we all know the answer is &quot;everything&quot; - which is exactly the problem. The C++ question is &quot;What are the compiler/linter checks to STOP people from doing X, Y and Z?&quot; Cause most projects can&#x27;t afford the maintainer bandwidth to enforce coding standards manually and even maintainers make mistakes, especially when overwhelmed.<br>
<p>
This is the difference between theoretical computer science and real world engineering with severe labor shortages, project management, deadlines etc. Maybe even some QA sometimes.<br>
<p>
These C++ checks will unfortunately never be good enough because:<br>
- Everyone has a slightly different definition of what is modern and/or safe C++ or about what they want to forbid.<br>
- C++ fans are fans of C++ because it lets you do whatever you want<br>
- The language wasn&#x27;t designed for most of these checks in the first place, so they can be at best heuristics with many false positives. Just look at existing static analyzers.<br>
<p>
So the only such check is to forbid C++ entirely and to wait for C to keep stealing very specific stuff from C++.<br>
<p>
Or Rust.<br>
<p>
PS: I had given up any hope of inexperienced people producing anything decent in shell scripting and then someone mentioned shellcheck in some obscure comment on LWN. Thank you!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886244/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886245"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 26, 2022 22:05 UTC (Sat)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886245/">Link</a>] (47 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many projects use the no RTTI / no exceptions dialect of C++ - every major compiler provides switches to enable that. I believe GCC itself is built in that way, many major games and financial applications are built that way. It’s simple to setup a build system to do that. <br>
Apple’s driver kit uses C++ for kernel code and Microsoft also has a subset of C++ they approve for writing Kernel Mode code. It’s not beyond the wit of the Linux Kernel developers to do that or to set simple standards for code they will accept in mainline. All we are talking about is using RAII and data encapsulation to enable safer more reliable coding. As a comment above says, the aspects of Rust that are being promoted to the Kernel can all be enabled in C++ as a start.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886245/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886254"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 0:02 UTC (Sun)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886254/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Both Apple and Microsoft have C++ compilers they control and pay the developers to do as they are told ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886254/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886270"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 7:57 UTC (Sun)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886270/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is not a technical argument. The fact is it’s perfectly possible to write C++ code that behaves well in Kernel mode and is safer and more reliable than emulating the same features in C using macros etc.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886270/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886320"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 11:00 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/886320/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>It is a technical argument; both Apple and Microsoft are able to enforce a subset of C++ that their kernel developers are happy with, and have CI setups that prohibit the use of features that do not behave well in kernel mode. On top of that, when new features appear (C++17, C++20, C++2x), Apple and Microsoft change the one acceptable kernel compiler to not support those features when compiling for the kernel.
<p>One of the "superpowers" technically of compiled languages is that the compiler does not accept programs that will misbehave at runtime. We accept that, as a side effect of this, there are some programs that will behave at runtime that the compiler also does not accept.
<p>If we have to rely on humans to spot use of "bad" features at runtime, we're putting mental effort onto reviewers, which is a scarce resource in kernel land. Thus, it's better for the kernel to use a compiler that puts the mental effort onto code authors (a C compiler) rather than one that simplifies coding, but puts much more mental strain on reviewers.
<p>A Linux kernel C++ dialect could be created, but it would need buy-in from GCC and Clang to enforce that dialect, so that reviewer time is not spent on something the machine can enforce.


      
          <div class="CommentReplyButton">
            <form action="/Articles/886320/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886327"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 13:04 UTC (Mon)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/886327/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It is a technical argument; both Apple and Microsoft are able to enforce a subset of C++ that their kernel developers are happy with, and have CI setups that prohibit the use of features that do not behave well in kernel mode. </font><br>
<p>
I wrote quite a bit of code in Windows kernel space, and most of Windows kernel is written in pure C. With few notable exceptions like the bad old GDI code.<br>
<p>
Apple&#x27;s kernel code is also mostly C, and you can download it and check yourself: <a href="https://github.com/apple/darwin-xnu">https://github.com/apple/darwin-xnu</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886327/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 15:09 UTC (Mon)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886365/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The situation has changed. The Windows Implementation Library includes C++ RAII helpers which are used in the operating system and drivers. They take care of closing handles etc. MSVC also has a kernel mode C++ switch which disables RTTI and Exceptions as well as floating point. <br>
Apple&#x27;s driver kit has always been C++.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886364"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 14:59 UTC (Mon)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/886364/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
checkpath.pl can take care of operator overloading if you&#x27;re too scared.<br>
<p>
Hey, even grep can do it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886364/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886405"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 19:13 UTC (Mon)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/886405/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>I'm not scared of C++ at all. But I understand why the kernel developers might be, and I respect their position.
<p>Looking at checkpatch.pl, it doesn't even know about operator overloading, or any other C++ feature - and the problem is not limited to operator overloading, but to any other C++ feature the kernel developers don't want to review.


      
          <div class="CommentReplyButton">
            <form action="/Articles/886405/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor886256"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 0:14 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/886256/">Link</a>] (39 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s not just RTTI. Also multiple inheritance, operator overloading, fallible constructors (Google-style &#x27;Init&#x27; methods), etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886256/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 7:50 UTC (Sun)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/886268/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; operator overloading</font><br>
<p>
std::span&lt;T&gt;::operator[] would be nice in fact.<br>
<p>
__le32 + __le32 would be nice too, maybe.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886271"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 8:04 UTC (Sun)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886271/">Link</a>] (37 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Fear of operating overloading is not based on anything more than FUD - there is a reason why Rust and other languages of recent origin permit the customisation of operations for user defined types. It can make them feel part of the language, makes programming more regular and encourages the use of abstractions. std::array’s overloaded operator [] makes it behave like a built in array, overriding operator &lt; for a user defined type makes it possible to build generic algorithms for sorting etc.<br>
As for multiple inheritance - depends on what you use it for. Mixins and interfaces are quite nice - but yes complex inheritance hierarchies esp. with virtual inheritance probably don’t have a space in kernel mode.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886271/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886278"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 14:50 UTC (Sun)
                               by <b>deater</b> (subscriber, #11746)
                              [<a href="/Articles/886278/">Link</a>] (35 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Fear of operating overloading is not based on anything more than FUD</font><br>
<p>
There are real reasons to avoid operator overloading.<br>
<p>
When doing system or embedded work it can be disastrous (for both performance but possibly also correctness) if what appears to be a standard operator that should map to a handful of assembly operations instead turns out to be a complex function with unknown side effects.<br>
<p>
This can also be a problem when reviewing a patch, and it can be unclear from the small amount of context whether an operation is overloaded or not.<br>
<p>
I suppose then the argument is that you should only view code in an IDE environment that requires 4GB of RAM and a full GUI interface and be sure to hover over each operation and offload all your thinking to a program written by someone else.  Sometimes newer/flashier ways of writing code aren&#x27;t necessarily better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886278/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886315"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 9:33 UTC (Mon)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/886315/">Link</a>] (34 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; This can also be a problem when reviewing a patch, and it can be unclear from the small amount of context whether an operation is overloaded or not.</font><br>
<p>
That&#x27;s exactly why I despise operator overloading. You cannot trust anymore what you&#x27;re reading.<br>
I would just be fine with defining *new* operators using other unused symbols, though. At least<br>
when you read them you figure you&#x27;re on something special that requires certain care.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886315/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886433"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 1, 2022 23:32 UTC (Tue)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886433/">Link</a>] (33 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That&#x27;s exactly why I despise operator overloading. You cannot trust anymore what you&#x27;re reading.</font><br>
<p>
It&#x27;s certainly an extreme reaction for a relatively minor thing. In an object orientated language, if your function gets passed a object x of type t, if t can be inherited from, x.method can do anything, no matter what the code for t says.<br>
<p>
Even in C, a + b can do quite a few different things. Off the top of my head, I can&#x27;t tell you what happens if a is a signed int with a negative value and b is an unsigned int. I do recall that integer overflow is undefined behavior, which is all sorts of fun. If you know the underlying types and the type programmer was sane, extending + to new types shouldn&#x27;t make things much more complex.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886433/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886595"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2022 18:19 UTC (Wed)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886595/">Link</a>] (31 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; That&#x27;s exactly why I despise operator overloading. You cannot trust anymore what you&#x27;re reading.</font><br>
<p>
<font class="QuotedText">&gt; It&#x27;s certainly an extreme reaction for a relatively minor thing. In an object orientated language, if your function gets passed a object x of type t, if t can be inherited from, x.method can do anything, no matter what the code for t says.</font><br>
<p>
Not knowing what code will run is considered a &quot;relatively minor thing&quot; only by fans of inheritance and object-oriented languages. Even in C where OO is super-explicit, tracking what .ops will run is one of the most time consuming thing.<br>
<p>
&quot;Object-oriented programming is an exceptionally bad idea which could only have originated in California.&quot; :-)<br>
<p>
And of course the classic http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html<br>
<p>
<font class="QuotedText">&gt; The King, consulting with the Sun God on the matter, has at times threatened to banish entirely all Verbs from the Kingdom of Java. If this should ever to come to pass, the inhabitants would surely need at least one Verb to do all the chores, and the King, who possesses a rather cruel sense of humor, has indicated that his choice would be most assuredly be &quot;execute&quot;.</font><br>
<font class="QuotedText">&gt; The Verb &quot;execute&quot;, and its synonymous cousins &quot;run&quot;, &quot;start&quot;, &quot;go&quot;, &quot;justDoIt&quot;, &quot;makeItSo&quot;, and the like, can perform the work of any other Verb by replacing it with an appropriate Executioner and a call to execute(). Need to wait? Waiter.execute(). Brush your teeth? ToothBrusher(myTeeth).go(). Take out the garbage? TrashDisposalPlanExecutor.doIt(). No Verb is safe; all can be replaced by a Noun on the run.</font><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886595/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886603"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 2, 2022 18:55 UTC (Wed)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886603/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Not knowing what code will run is considered a &quot;relatively minor thing&quot; only by fans of inheritance and object-oriented languages.  Even in C where OO is super-explicit, tracking what .ops will run is one of the most time consuming thing.</font><br>
<p>
Of course it&#x27;s not a problem at all for pure user space code that can run entirely in a graphical IDE with an excellent debugger. But good luck when troubleshooting some intermittent hardware bug or cache misconfiguration using &quot;printk&quot; over a slow serial link.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886603/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886622"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 2:11 UTC (Thu)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886622/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Not knowing what code will run is considered a &quot;relatively minor thing&quot; only by fans of inheritance and object-oriented languages. </font><br>
<p>
Every step in computer history has reduced the programmer&#x27;s ability to know what code will run. As Mel, the Real Programmer, said when refusing to use assembly “You never know where it&#x27;s going to put things, so you&#x27;d have to use separate constants”. A C program that runs on *nix? The number of different compilers, processors, kernels and C libraries is amazing, the number of different combinations in practice at least runs into the thousands. If you&#x27;re using a library that you&#x27;re not bundling, that&#x27;s another source of change, and even if you are, have you read that library? <br>
<p>
(And as the IOCCC has shown over the years, #define is an awesome tool for code doing what you think it should do, not what the naive C programmer thinks it&#x27;s doing.)<br>
<p>
a+b should add two items. If it&#x27;s not obvious what it&#x27;s doing, then that&#x27;s a bug in the library. You can go with function names like cos, cosf, cosl, ccos, ccosf, ccosl (standard C adds type information to both sides of the function name, for all the mockery *nix programmers gave Hungarian notation), but I&#x27;d really rather not.<br>
<p>
<font class="QuotedText">&gt; good luck when troubleshooting some intermittent hardware bug or cache misconfiguration using &quot;printk&quot; over a slow serial link.</font><br>
<p>
I started to appreciate OO more when I read the argument that it succeeded because of GUIs, and I started to have to write some of those. If you&#x27;ve got a screen box that takes a bunch of GUI elements, I don&#x27;t know of any better way than making them all inherit from Widget, especially if you want to be able to add arbitrary widgets from arbitrary libraries. Java&#x27;s &quot;everything is a class&quot; is an annoying box, but when OO is useful, it&#x27;s really useful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886622/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886631"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 3:22 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886631/">Link</a>] (26 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Every step in computer history has reduced the programmer&#x27;s ability to know what code will run</font><br>
<p>
You&#x27;re mixing up operator overloading with totally unrelated things. Yes of course we have no idea what machine code runs, what micro code underneath that and of course with code-reuse (at last...) we don&#x27;t know what code runs in libraries. But operator overloading and inheritance are very different: with them you don&#x27;t know _which source tab in your own editor you should look at_! In other words, you get lost in _your own code_.<br>
<p>
That&#x27;s a huge difference. There is a very simple solution for all the rest: only use compilers and libraries versions that everyone else uses too. Not only it reduces the number of bugs massively, but when you hit one you can just google it. Not knowing which _code source_ runs in your own project is a totally different problem.<br>
<p>
<font class="QuotedText">&gt; a+b should add two items. If it&#x27;s not obvious what it&#x27;s doing, then that&#x27;s a bug in the library.</font><br>
<p>
I agree there&#x27;s only so much damage that can be done by overloading &#x27;+&#x27;. But once again the problem is the same: where is the compiler / linter flag that limits operator overloading to only &quot;sensible&quot; use cases? Where do you even draw that line?<br>
<p>
<font class="QuotedText">&gt; Java&#x27;s &quot;everything is a class&quot; is an annoying box, but when OO is useful, it&#x27;s really useful.</font><br>
<p>
To a hammer, everything looks like a nail..<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886631/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 19:05 UTC (Thu)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886714/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But operator overloading and inheritance are very different: with them you don&#x27;t know _which source tab in your own editor you should look at_! In other words, you get lost in _your own code_.</font><br>
<p>
It&#x27;s easy to know where a + b comes from; if you know that a is of type Quaternion, then look in Quaternion.&quot;+&quot; or whatever the specific notation is. (If you were running Java, that would be in quaternion.java; in C, of course, even if you know the function name, it could be anywhere, so if you&#x27;re getting lost in your own code, you might want to look into Java or at least Java-like file naming conventions.) If you don&#x27;t know what type a is, you have bigger problems than operator overloading.<br>
<p>
Inheritance is more complex, yes. Ultimately, if it&#x27;s your own code, you should know what type is getting passed in and where to look for that code. Whether you&#x27;re using inheritance or switches, you&#x27;re going to need to know what the value is to see what code is being run, and if you know what that value is, you can find the code.<br>
<p>
<font class="QuotedText">&gt;  But once again the problem is the same: where is the compiler / linter flag that limits operator overloading to only &quot;sensible&quot; use cases? </font><br>
<p>
You write in a language that has all code go through a general-purpose macro processor before the compiler, one that has long been shown to do evil, evil stuff (the Bourne shell being a notorious example of horrors that can be done by the well-intentioned.) You trust the programmer to be sensible, or (arguably) you run a more locked down language like Java.<br>
<p>
<font class="QuotedText">&gt; To a hammer, everything looks like a nail..</font><br>
<p>
In response to the statement that sometimes a Phillips head screwdriver is useful? If you don&#x27;t believe that OO is useful for GUIs, point to alternatives and explain why OO languages are so popular for GUIs. KDE was done in C++ back before libstdc++ existed.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 22:19 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886720/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; In response to the statement that sometimes a Phillips head screwdriver is useful? If you don&#x27;t believe that OO is useful for GUIs, point to alternatives and explain why OO languages are so popular for GUIs. KDE was done in C++ back before libstdc++ existed.</font><br>
<p>
Except that this article is not about GUIs. Maybe it should be - why do we keep on having to buy newer, faster computers just to stop the guis slowing everything down? Do we really want to let that bloat into the kernel - pretty much bringing our super-fast new CPUS to a grinding halt ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 22:49 UTC (Thu)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886724/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This subthread started with a generalized bashing of OO languages, which is why a mention of where OO languages are useful came up.<br>
<p>
I&#x27;d be interested to see good measurements of why modern GUIs are so much slower; I&#x27;m curious if once you compensate for the increase in screen size and the increase in data sizes, if they really are all that much slower.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 23:54 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886726/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I thought it started with a suggestion that OO languages (C++) be used in the kernel.<br>
<p>
In which case, OO-bashing is justified. OO *IS* useful, but in the kernel when a few extra bytes of object code can cost you dearly in page faults etc, those faults are pretty fatal for the concept. THAT was the purpose of the bashing ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 9:42 UTC (Fri)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/886753/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The kernel embraced the size overheads of OO back in the 1990s, and C++&#x27;s OO model is just as much &quot;pay for what you use&quot; as the one the kernel uses.<br>
<p>
If a class has no virtual members, it doesn&#x27;t need a function table and doesn&#x27;t have function-pointer dispatch overheads.<br>
<p>
If it has some virtual members, only the members that are virtual have to be identified in the function table and called through function pointers.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor886743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 6:27 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886743/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; But operator overloading and inheritance are very different: with them you don&#x27;t know _which source tab in your own editor you should look at_! In other words, you get lost in _your own code_.</font><br>
<p>
<font class="QuotedText">&gt; Ultimately, if it&#x27;s your own code, you should know what type is getting passed in and where to look for that code.</font><br>
<p>
I should not have written _your own code_, I meant: you get lost _in the code base that you are working on_ as opposed to some external library, compiler or other abstraction you don&#x27;t care about.<br>
<p>
Most developers spend most of their time reading and debugging code they did not write themselves. Which is _exactly_ why kernel maintainers don&#x27;t want C++<br>
<p>
<font class="QuotedText">&gt; If you don&#x27;t believe that OO is useful for GUIs</font><br>
<p>
I was just rephrasing you.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886795"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 14:57 UTC (Fri)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886795/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I should not have written _your own code_, I meant: you get lost _in the code base that you are working on_ </font><br>
<p>
And it still stands; if it&#x27;s the code base that you are working on, you should know what type is getting passed in and where to look for that code. Assuming you&#x27;re not using Ruby, the type of the variable should be named nearby in the code.<br>
<p>
And again, &quot;I can&#x27;t find which source tab to look at&quot; is weird coming from someone bashing Java. In a.b(...), the code is found in file named after the type of a. In C, the definition of the function may be found in one of the files you #included in this code (or not; you can always declare external functions directly), but that header file name may have no relation to the file where the code is written. Of course, with the handy -D option to the C compiler, who knows what the function is actually named.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886795/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886829"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 17:28 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886829/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Assuming you&#x27;re not using Ruby, the type of the variable should be named nearby in the code. [...] In a.b(...), the code is found in file named after the type of a. </font><br>
<p>
??<br>
<p>
The type of the variable does not provide vtable resolution. That&#x27;s done only at run-time. Same problem for explicit .ops function pointers in C. You cannot just &quot;grep&quot; through vtables / .ops because they&#x27;re resolved at run-time. That&#x27;s the whole OO proposition.<br>
<p>
<font class="QuotedText">&gt; Assuming you&#x27;re not using Ruby, the type of the variable should be named nearby in the code.</font><br>
<p>
Afraid you lost me there.<br>
<p>
<font class="QuotedText">&gt;  In C, the definition of the function may be found in one of the files you #included in this code (or not; you can always declare external functions directly), but that header file name may have no relation to the file where the code is written.</font><br>
<p>
Code indexers can do a surprisingly good job most of the time. For the rest there is always git grep. It works as long as nothing is resolved at run-time.<br>
<p>
<font class="QuotedText">&gt; Of course, with the handy -D option to the C compiler, who knows what the function is actually named.</font><br>
<p>
I&#x27;ve seen many -D and I&#x27;ve never seen one redefining function names. As already wrote above, no one like the pre-processor and its abuse is very easily and routinely caught at code review. The entire problem with C++ is &quot;where do you draw the line?&quot;. That&#x27;s really not a problem with the pre-processor: it&#x27;s always very obvious whether you use it or not and I&#x27;ve seen &quot;no pre-processor here&quot; review comments countless times.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886829/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886849"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 20:22 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886849/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
BTW a great trick to unravel (evil) cpp macros is to deliberately insert a compilation error. gcc then shows the entire stack of macros involved. Much easier than cc -E or something.<br>
<p>
Same trick with build systems and many other situations with &quot;too many layers of indirections&quot;: deliberately injecting errors is often a great shortcut.<br>
<p>
(none of that available at run-time of course)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886849/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886881"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2022 2:42 UTC (Sat)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886881/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The entire problem with C++ is &quot;where do you draw the line?&quot;.</font><br>
<p>
That&#x27;s a problem with C++, not operator overloading or object orientation. <br>
<p>
<font class="QuotedText">&gt; That&#x27;s really not a problem with the pre-processor: it&#x27;s always very obvious whether you use it or not and I&#x27;ve seen &quot;no pre-processor here&quot; review comments countless times.</font><br>
<p>
It is quite similar to operator overloading; you can see where the macro or operator is defined, but not necessarily where it is used.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886881/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor886719"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 22:20 UTC (Thu)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/886719/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;Operator overloading&quot; is no different than any other overloading. Operators are just functions with symbols for names rather than alphanumeric strings. If you don&#x27;t have an issue with `add(a, b)` where `add` can be overloaded then there isn&#x27;t much rational basis for objecting to `a + b` where `+` can be overloaded.<br>
<p>
<font class="QuotedText">&gt; But once again the problem is the same: where is the compiler / linter flag that limits operator overloading to only &quot;sensible&quot; use cases? Where do you even draw that line?</font><br>
<p>
Sensible languages (such as Haskell) only allow overloading though the implementation of an interface (typeclass), which narrows the problem down: if you want to override `+` in Haskell then you need to provide an instance of `Num` for that data type, which implies that you need to implement the other numerical operations like `*`, `negate`, `fromInteger`, etc. which make up the minimal complete definition. If you try to define `+` at global scope outside of a `Num` instance without explicitly suppressing `Prelude.+` you&#x27;ll get an error due to the conflicting names.<br>
<p>
Typeclasses, in turn, generally come with &quot;laws&quot; which specify how their members should relate to each other, in addition to declaring types for each member which instances must share. (For historical reasons `Num` does not have any official typeclass laws itself, but there are certain basic expectations regarding associativity, commutivity, distributivity, and other properties[0] which amount to informal laws.) The laws, unlike the types, are not automatically enforced, but unlawful instances are strongly discouraged and it is usually simple to write property-based tests to verify that they are met. The key is that the instances of an interface are related by more than just a common name. Implementing a typeclass serves as a declaration of intent that the instance will follow the typeclass laws and generally behave as expected for an instance of that typeclass.<br>
<p>
It helps that Haskell allows almost any sequence of symbols as an operator name, so there is no pressure to abuse the left-shift operator for stream output. For example. You can also use any function name as an infix operator by putting it in backquotes—you can even define precedence and fixity for named functions used with infix syntax, just as you can for symbolic operators.<br>
<p>
Rust uses essentially the same model, with traits in place of typeclasses, though the set of numerical traits in Rust is a bit more nuanced than Haskell&#x27;s catch-all `Num` typeclass and the syntax unfortunately doesn&#x27;t allow for custom operators.<br>
<p>
[0] <a href="https://hackage.haskell.org/package/base-4.16.0.0/docs/GHC-Num.html">https://hackage.haskell.org/package/base-4.16.0.0/docs/GH...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886719/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886749"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 8:12 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/886749/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; If you don&#x27;t have an issue with `add(a, b)` where `add` can be overloaded then there isn&#x27;t much rational basis for objecting to `a + b` where `+` can be overloaded.</font><br>
<p>
No, that&#x27;s precisely the opposite. If you don&#x27;t have issue with &quot;add(a, b)&quot;, the please by all means use that and leave the operators to their original meaning so that the vast majority of the characters in the code you are reading do what you were always taught they do. Nobody imagines that when you&#x27;re doign your errands and see &quot;3 + 1 offered&quot;, this &quot;+&quot; means &quot;perform a database access and do some special operation to return a different value&quot; nor &quot;concatenate them and say 31&quot;. No, you imagine an addition, with all the simplicity that comes with it, but within some technical constraints imposed by computers (e.g. domain limitations causing wrapping, saturation or overflows). When I read &quot;a + b&quot;, I hear &quot;a plus b&quot; and nothing else. I&#x27;m not hearing &quot;a, the first argument of a function using a symbol looking like the plus I know, and a second argument b, now let&#x27;s check if such a function exists otherwise I&#x27;ll assume it&#x27;s in fact a regular plus&quot;.<br>
<p>
It is important to be able to read code the most naturally possible. It&#x27;s a matter of efficiency and reliability. And most exploited security flaws in software are found by careful code review and could be spotted by their developers if the code was not constantly cheating on them doing nasty tricks that do not ressemble what it seems to do. That&#x27;s the same reason why many developers perfer to use upper case for macros. It&#x27;s a signal that you should look it up and that it might evaluate your arguments more than once, for example.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886749/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886752"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 9:38 UTC (Fri)
                               by <b>mpr22</b> (subscriber, #60784)
                              [<a href="/Articles/886752/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I do have an issue with add(a, b) anywhere that isn&#x27;t the definition of a type&#x27;s implementation of the Arithmetic interface, though.<br>
<p>
When I&#x27;m trying to understand the calculations a piece of code is doing on data entities for which arithmetic is a &quot;natural&quot; concept, but which are not Sacred Primitive Types of the implementation language, wading through the resulting vast piles of &quot;x = add_foo(a, multiply_foo(b, c))&quot; etc is the kind of chore that degrades my attention span.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886752/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886758"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 13:04 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/886758/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s also more difficult to read for me, but way less than if I cannot trust any of the most elementary operators anymore.<br>
<p>
A good example are the mmx/sse/avx* API with all those complicated functions that map 1-to-1 to the underlying instructions. It&#x27;s particularly hard to read, but it would be even worse if operators were abused to perform some of them. And there are still much less operators than possible functions anyway, so being a bit more explicit doesn&#x27;t hurt.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886758/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 15:59 UTC (Fri)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886796/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Nobody imagines that when you&#x27;re doign your errands and see &quot;3 + 1 offered&quot;, this &quot;+&quot; means &quot;perform a database access</font><br>
<p>
In all the programming languages under discussion, 3 + 1 returns 4. In mathematics, a + b is an arbitrary function, almost always associative and commutative; 3 + 1 can equal 0, in Z mod 4. I&#x27;ve certainly seen + used as a concatenation operator in real life, like in rebuses. <br>
<p>
<font class="QuotedText">&gt; if the code was not constantly cheating on them doing nasty tricks that do not ressemble what it seems to do. That&#x27;s the same reason why many developers perfer to use upper case for macros. It&#x27;s a signal that you should look it up and that it might evaluate your arguments more than once, for example.</font><br>
<p>
Non-hygenic macros are insane. Had you said <br>
<p>
<font class="QuotedText">&gt; That&#x27;s exactly why I despise [C&#x27;s macro system]. You cannot trust anymore what you&#x27;re reading.</font><br>
<p>
I wouldn&#x27;t have disagreed. So why the difference? Why can developers be trusted with macros and not operator overloading?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886826"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 17:02 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886826/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; That&#x27;s the same reason why many developers perfer to use upper case for macros. It&#x27;s a signal that you should look it up and that it might evaluate your arguments more than once, for example.</font><br>
<p>
<p>
<font class="QuotedText">&gt; Why can developers be trusted with macros and not operator overloading?</font><br>
<p>
They can&#x27;t with either. No one likes the pre-processor. It&#x27;s always seen as a necessary evil to work around C&#x27;s limitations. Macros are subject to especially high review scrutiny and new ones can be introduced only if they solve a very generic problem and only when they are used all across the board (which ensures a lot of test coverage).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886826/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886828"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 17:06 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886828/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And most exploited security flaws in software are found by careful code review and could be spotted by their developers if the code was not constantly cheating on them doing nasty tricks that do not ressemble what it seems to do.</font><br>
<p>
I wonder where you got that from. Sure there&#x27;s Spectre and alike but most security flaws I ever looked at (admittedly not that many) were all &quot;mundane&quot; out of bounds accesses, uninitialized use, use after free, integer overflows, etc. All the usual and mundate memory corruption features of C which according to Microsoft and Google account for 70% of all security issues in C/C++ projects (I don&#x27;t know what the other 30% are)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886828/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor886761"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 14:37 UTC (Fri)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/886761/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Operator overloading&quot; is no different than any other overloading.</font><br>
<p>
It&#x27;s different in a really key way in most languages (not Haskell): operators have a more convenient infix syntax, but there&#x27;s a limited number of them which you can use, and that causes people to prefer to overload them for inappropriate operations.<br>
<p>
Let&#x27;s pretend c++ had no infix operators whatsoever (overloaded or not). So instead of `1 &lt;&lt; 2` you&#x27;d say `1.left_shift(2)`. When creating an output stream type nobody would _even consider_ having programmers spell &quot;write to output&quot; as `cout.left_shift(&quot;hello world&quot;)`. That&#x27;s just ridiculous on it&#x27;s face! Of course you&#x27;d use a more appropriate name.<br>
<p>
Yet, because of the limited operator vocabulary that is available to work with, there&#x27;s a great temptation to use operator overloads for these nonsensical operations. An absolutely irresistible temptation, I&#x27;d say. And that&#x27;s why operator overloading unfortunate in practice -- even though it shouldn&#x27;t be in theory.<br>
<p>
For example: C++20 just repeated this mistake, introducing an overload of bitwise_or `|` for (effectively) function composition in the new ranges library. With the weak rationale that `|` means pipe in Unix shell which is kinda the same thing so it &quot;makes sense&quot;. But it doesn&#x27;t. That&#x27;s not what the operator | is supposed to mean in c++.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886761/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886821"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 16:07 UTC (Fri)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886821/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; operators have a more convenient infix syntax, but there&#x27;s a limited number of them which you can use, and that causes people to prefer to overload them for inappropriate operations.</font><br>
<p>
Good point in general. Scala mitigates that by letting methods with one argument be used infix (in version 2, in Scala 3 you have to declare it infix), and allowing pretty much arbitrary operator/method names (for better and worse, :^$*+ is a valid method name that can be used infix in Scala.)<br>
<p>
I&#x27;d point out your C++ examples are self-inflicted; unlike programmers, the C++ designers could have added operators to the system.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886821/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886823"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 16:44 UTC (Fri)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/886823/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I&#x27;d point out your C++ examples are self-inflicted; unlike programmers, the C++ designers could have added operators to the system.</font><br>
<p>
This is a really long tradition in C++ land. For example, afaict the only reason C++ attempts to use operators for streams in the first place is because the language itself was not rich enough to be able to express generic, type-safe string formatting well. It just so happened that the existing function overloading and a convenient left-associative operator let you cobble together a hacky workaround which then became standard.<br>
<p>
Meanwhile nearly every other language decided to go and do what needed to be done to enable type safe string formatting instead. Including C++, which accidentally eventually enabled it to be written anyway, giving rise to {fmt} and then std::format.<br>
<p>
Then they went and did the same thing again with iterators, sfinae, variant/visit/optional, etc.<br>
<p>
I think the moral of iostreams is less that operator overloading is a bad idea, but that people will do absolutely horrible things if a language is not interested in finding ways to adequately address their needs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886823/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886853"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 21:29 UTC (Fri)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/886853/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I&#x27;d point out your C++ examples are self-inflicted</font><br>
<p>
Indeed, the C++ standard library designers often (but not always) act as if they have no ability to influence the core language design. And they may be correct, to some degree -- the language and library changes are done by different working groups within the standards committee, so there&#x27;s going to be a greater organizational friction to get your change in, if you need to modify both.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886853/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2022 17:13 UTC (Sat)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/886910/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I&#x27;d point out your C++ examples are self-inflicted; unlike programmers, the C++ designers could have added operators to the system.</font><br>
<p>
That was my point. Having a set of &quot;free to use&quot; operators that are never defined by default and are always type-specific would be perfect because they&#x27;re sufficient to ring a bell when you read that code. But as the previous commenter said, using explicit names instead of left-shifting string still remains quite better. After all in some languages (BASIC for example) we were not shocked by reading &quot;OR&quot;, &quot;AND&quot; or &quot;XOR&quot; as operators between two numbers. I&#x27;d be fine with a &quot;CAT&quot; operator to concatenate two strings, and remove the ambiguity that you have in certain languages like JS where a=b+1 is ambiguous when b=&quot;1&quot; where you don&#x27;t know if you&#x27;ll get string &quot;11&quot; or integer 2.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886912"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 5, 2022 17:45 UTC (Sat)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886912/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; After all in some languages (BASIC for example) we were not shocked by reading &quot;OR&quot;, &quot;AND&quot; or &quot;XOR&quot; as operators between two numbers. ... remove the ambiguity that you have in certain languages like JS where a=b+1 is ambiguous when b=&quot;1&quot; where you don&#x27;t know if you&#x27;ll get string &quot;11&quot; or integer 2.</font><br>
<p>
Does OR do a bitwise OR or a boolean OR? I don&#x27;t see any saving in ambiguity there. Likewise for the left shift; for all the fuss over it, in practice I&#x27;ve never seen it be the least bit ambiguous.<br>
<p>
As for JavaScript, as I said, I was thinking of statically typed languages, and if you&#x27;re programming JavaScript, you should know the answer to that. (It&#x27;s &quot;11&quot;.) But it is a little more confusing than it would be in other languages, since &quot;1&quot; / 1 implicitly converts &quot;1&quot; to a number, which is problematic, since lossy conversions should generally be avoided, especially when you&#x27;re shoving a round peg into a square hole. The problem is not with operator overloading, so much as it&#x27;s with lossy conversions. &quot;String&quot; / 1 should be caught at compile time, not run time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886912/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor886748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 7:42 UTC (Fri)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/886748/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  But operator overloading and inheritance are very different: with them you don&#x27;t know _which source tab in your own editor you should look at_! In other words, you get lost in _your own code_.</font><br>
<p>
Exactly. More than a decade ago, one of our project died after the ruby developer who was leaving admitted he was totally unable to tell us which assignments or operations were causing database accesses! Because doing a=b+c could *possibly* perform requests ina database to fetch some values or store the results. It became so deep that the code was a living being of itself that noone could tame anymore, and fixing bugs became totally impossible. Definitely a very bad idea. The only thing it provides is ease of *writing* code, but we must never forget that we write once and read it many times.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886793"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 14:30 UTC (Fri)
                               by <b>ianmcc</b> (subscriber, #88379)
                              [<a href="/Articles/886793/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How is that fixed by spelling it a=add(b,c) ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886793/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886762"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 4, 2022 14:36 UTC (Fri)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886762/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
= or + doing database requests is insane, but so is naming the function f() or add() or shelia(). I was not familiar that any dynamically typed language had operator overloading; in a statically typed language, the types of a, b and c would have made automatic renaming possible. Clarity of naming is important, and I&#x27;d argue that there&#x27;s a conservation of information; the more ambiguous the types, the more explicit the function naming needs to be to compensate.<br>
<p>
<font class="QuotedText">&gt; The only thing it provides is ease of *writing* code</font><br>
<p>
One of the recent Scheme additions was writing (add (times a c) b) as {a * c + b}, because it actually is easier to read code like that, and<br>
<p>
&quot;hi &quot; + name.toString + &quot; and good morning&quot; <br>
<p>
is also easier to read than <br>
<p>
&quot;hi&quot;.append(name.toString).append (&quot;and good morning&quot;)<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886762/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor886645"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 8:50 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/886645/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (And as the IOCCC has shown over the years, #define is an awesome tool for code doing what you think it should do, not what the naive C programmer thinks it&#x27;s doing.)</font><br>
<p>
What you are *completely* missing, is that most code like you describe does NOT do what it NEEDS to do.<br>
<p>
For the application programmer (real or not), throwing hardware at the problem is an acceptable solution.<br>
<p>
For the systems programmer, you can&#x27;t just go out and get a couple of extra MEG of L1 cache. You can&#x27;t go out and get a couple of extra cache lines.<br>
<p>
I date from the years when tomorrow&#x27;s weather forecast took 20hrs to run. &quot;Who cares if the program takes twice as long?&quot; - that guy would have been fired!<br>
<p>
I did a load of work (copying files around, etc) a while back on my computer. Okay, I run a protection-heavy disk stack, but I think my PC spent the next 20 minutes flushing cache. I don&#x27;t give a monkeys, it was other wise idle and responsive, but there are PLENTY of people out there who HAVE to care.<br>
<p>
If you can optimise your code FOR SPEED without having a clue what&#x27;s going on under the bonnet, you&#x27;re a better man than I am, gunga din ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886645/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 23:00 UTC (Thu)
                               by <b>dvdeug</b> (guest, #10998)
                              [<a href="/Articles/886725/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
What does any of this have to do with how slow a program is? Lots of fast programs are unreadable; I think it was Code Complete that talked about writing a DES decrypter in C that was easy to read, and speeding it up one hundred times by turning it into an unreadable pile of assembly. The Linux kernel uses a lot of those nightmare defines to get maximal inline speed at the cost of clarity and ease of finding the code running. Operator overloading has zero effect on speed. <br>
<p>
<font class="QuotedText">&gt; I date from the years when tomorrow&#x27;s weather forecast took 20hrs to run.</font><br>
<p>
Weather forecasting always wants faster computers to do more detailed and accurate forecasts. The National Hurricane Center mentioned for their hurricane forecasts that they post every four hours, they run various simulations, and one of them takes six hours to run, meaning it&#x27;s never as up to date as the other simulations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor886618"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Mar 3, 2022 0:07 UTC (Thu)
                               by <b>HenrikH</b> (subscriber, #31152)
                              [<a href="/Articles/886618/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Agreed that the implicit promotions and convert rules in C is a bit complex (and actually it would be nice if there where a tool one could use to highlight an expression and have the tool explain exactly what happens in this regard) but they are at least specified in the standard.<br>
<p>
For your example at hand with &quot;a + b&quot; where we have &quot;int a&quot; and &quot;unsigned int b&quot; and a have a negative value then since both are of the same rank (integers) but different types (signed vs unsigned) the signed integer is implicitly converted to an unsigned integer. Overflow is only undefined for the signed integer case while defined to wrap around for the unsigned integer which is why most of the &quot;a + b&quot; code works as intended.<br>
<p>
Aka if a is -1 and b is 2 then -1 is &quot;converted&quot; to 0xFFFFFFFF, add +2 and we wrap around to 1. In practice the compiler simply moves both a register and does the x86 ADD instruction since converting signed to unsigned of the same size is a no op and a binary add in particular is signedness agnostic.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886618/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor886309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Rust operator overloading</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 2:41 UTC (Mon)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/886309/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In fact Rust isn&#x27;t really overloading at all, what&#x27;s happening in Rust is that types get to implement some langitem Traits whose functions are invoked by operators. Without those trait implementations, you can&#x27;t use these &quot;overloadable&quot; operators on a user-defined type at all. For example if my type Apple doesn&#x27;t implement PartialEq you just can&#x27;t write thisApple == thatApple, it won&#x27;t compile. There was no &quot;overloading&quot; in the strict sense.<br>
<p>
And where C++ is very profligate with these overloads, Rust is conservative, for example recently there was work to let you do more natural things with Wrapping types, so e.g. today you write<br>
<p>
  let a = Wrapping&lt;i8&gt;(127);<br>
  let b = Wrapping&lt;i8&gt;(1);<br>
  let c = a + b;<br>
  /* now c is Wrapping&lt;i8&gt;(-128) */<br>
<p>
The authors originally thought it would be nice if this worked:<br>
<p>
  let a = Wrapping&lt;i8&gt;(127);<br>
  let b: i8 = 1;<br>
  let c = a + b;<br>
  /* authors thought it&#x27;s reasonable c is Wrapping&lt;i8&gt;(-128) but is that definitely what was expected?*/<br>
<p>
After feedback to their patches they agreed this could be surprising and instead only implemented *Assign Traits, thus:<br>
<p>
  let mut a = Wrapping&lt;i8&gt;(127);<br>
  let b: i8 = 1;<br>
  a += b;<br>
  /* The type of a hasn&#x27;t changed, so it is now Wrapping&lt;i8&gt;(-128) and that makes sense */<br>
<p>
In Rust for Linux they deliberately didn&#x27;t implement most of these &quot;operator&quot; traits for String and similar types which need implied allocation, because Linus doesn&#x27;t like implied allocation.<br>
<p>
Two asides, whilst C++ can&#x27;t do anything about it now, I&#x27;m convinced that subtyping is a bad idea and Rust&#x27;s choice to provide inheritance only for Traits (ie you can inherit behaviour but not state) was the Right Thing there too. Multiple inheritance the way C++ is unambiguously a bad idea.<br>
<p>
And, std::array is an example of C++ refusing to just fix the language. The built-in array in C 89 sucks. C++ inherits that, so the built-in array in C++ 98 sucks. And instead in modern C++ std::array is offered as a substitute, the built-in array syntax is just roped off as dangerous trash not to be used. Rust took the right stance here, in Rust 1.0 the arrays are not good, they&#x27;re better than in C 89 (and thus modern C++) but they&#x27;re far worse than Rust&#x27;s library container types, unrelated examples in documentation ended up using a Vec because it works. Unlike C++ the built-in array wasn&#x27;t left to die, and as of Rust 2021 the array type is pretty nice, it can do all the things you&#x27;d expect a container type to do, and only has a few small warts left to fix.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor886286"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 18:53 UTC (Sun)
                               by <b>rgmoore</b> (<b>&#x272D; supporter &#x272D;</b>, #75)
                              [<a href="/Articles/886286/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>C++ fans are fans of C++ because it lets you do whatever you want</blockquote>

<p>Which is more or less the explanation Linus used for why he doesn't want to move to C++.  It isn't about the technical side of the language; it's about excluding people who don't have the discipline to code the way he thinks the kernel should be coded.


      
          <div class="CommentReplyButton">
            <form action="/Articles/886286/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886288"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 19:05 UTC (Sun)
                               by <b>camhusmj38</b> (subscriber, #99234)
                              [<a href="/Articles/886288/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C let’s you do whatever you want. C++ is more restrictive than C. As I’ve said, the decisions made in the 1990s made sense then, but they don’t anymore. People who make the most performant, high security code code in C++ these days. There are no points in this game for being chads programming the way of the ancestors - on the contrary this can be harmful. This is particularly the case where people are reinventing language features using text substitution macros and a set of instructions to be carefully followed. Using the correct subset of C++ for Kernel mode is also a discipline - just as writing the correct type of C code is a discipline (using VLAs can overflow your stack for example, so don’t do it) - one that can be enforced with analysis tools and compiler switches. <br>
It’s OK to say that you don’t want to do it because you don’t know how or are scared to learn new things. But it’s also OK for people to say maybe sheer obstinacy is not a reason to not consider an idea. The cult of personality in this area is not helpful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886288/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor886303"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 27, 2022 21:03 UTC (Sun)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/886303/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Using the correct subset of C++ for Kernel mode is also a discipline - just as writing the correct type of C code is a discipline (using VLAs can overflow your stack for example, so don’t do it) - </font><br>
<p>
No, you&#x27;re missing the point exactly like all other C++ fans. -Wwla is not a &quot;discipline&quot;, it&#x27;s a compiler flag. A discipline requires some mental effort whereas adding -Wwla to a configuration file requires zero human effort. The computer does all the work.<br>
<p>
<font class="QuotedText">&gt; one that can be enforced with analysis tools and compiler switches.</font><br>
<p>
Great news: please share now the set of analysis tools and compiler switches that enforce the exact C++ subset kernel maintainers are willing to accept without increasing their code review workload that is already stretched past the limit. For at least all recent gcc and clang versions.<br>
<p>
<p>
Good luck getting all kernel maintainers to agree on that C++ subset in the first place! So that was a trick question, sorry.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886303/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor886301"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Moving the kernel to modern C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 28, 2022 8:55 UTC (Mon)
                               by <b>ballombe</b> (subscriber, #9523)
                              [<a href="/Articles/886301/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
VLA is a C99 extension. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/886301/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
