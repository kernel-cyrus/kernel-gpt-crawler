        <!DOCTYPE html>
        <html lang="en">
        <head><title>Avoiding the OOM killer with mem_notify [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/267013/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/266361/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/267013/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Avoiding the OOM killer with mem_notify</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jake Edge</b><br>January 30, 2008</br>
           </div>
<p>
Having applications that use up all the available memory can be a fairly
painful experience.  For Linux systems, it generally means a visit from
the out-of-memory (OOM) killer, which will try to find processes to kill.
As one would guess, coming up with rules governing which process to kill is
challenging&mdash;someone, somewhere, will always be unhappy with
a choice the OOM killer makes.  Avoiding it altogether is the goal
of the <a href="http://lwn.net/Articles/266586/">mem_notify</a> patch.
</p>

<p>
When memory gets tight, it is quite possible that applications have memory
allocated&mdash;often caches for better performance&mdash;that they
could free.  After all, it is generally better to lose some performance
than to face the consequences of being chosen by the OOM killer.  But,
currently, there is no way for a process to know that the kernel is feeling
memory pressure.  The patch provides a way for interested
programs to monitor the <tt>/dev/mem_notify</tt> file to be notified if
memory starts to run low.
</p>

<p> <tt>/dev/mem_notify</tt> is a character device that signals memory
pressure by becoming readable.  Interested programs can open the file and
then use <tt>poll()</tt> or <tt>select()</tt> to monitor the file
descriptor.  Alternatively, signal-driven I/O can be enabled via the
<tt>FASYNC</tt> flag and the system will deliver a SIGIO signal to the
process when the device becomes readable.  If it becomes readable, the
process should free any memory that it can afford to give up.  If enough
memory is freed this way, the kernel will have no need to call in the OOM
killer.  </p>

<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
The crux of the patch is how to decide that memory pressure is occurring.
mem_notify modifies <tt>shrink_active_list()</tt> to look for movement of
an anonymous page to the inactive list, which is an indication that some
will likely be swapped out soon.  When that occurs, 
<tt>memory_pressure_notify()</tt> (with the pressure flag set to 1) will be called for that zone.  When the
number of free pages for the zone increase above a threshold&mdash;based
on <tt>pages_high</tt> and <tt>lowmem_reserve</tt> for the
zone&mdash;<tt>memory_pressure_notify()</tt> is called again, but with the
pressure flag set to 0, effectively ending the memory pressure event for
that zone. 
</p>

<p>
If there are numerous processes waiting for a memory pressure notification,
it could be counterproductive to wake them all at once&mdash;the "thundering
herd" problem.  To combat this, the patch set adds the ability to wake
fewer processes than are waiting on the poll event, by adding the
<tt>poll_wait_exclusive()</tt> function.  <tt>poll_wait_exclusive()</tt>
will in turn call <tt>add_wait_queue_exclusive()</tt> so that a
member of the <tt>wake_up()</tt> family can be used that will limit the number of processes
woken up.  Previously, only <tt>poll_wait()</tt> was available, it uses
<tt>add_wait_queue()</tt>, which does not provide this ability.
Also, to reduce the frequency of processes waking up to reclaim memory,
<tt>memory_pressure_notify()</tt> will only do that once every five seconds.
</p>

<p>
The <tt>/proc/zoneinfo</tt> output has been changed to include the
mem_notify status.  This can be used by a human for diagnostic purposes or by a program to
 check the current status of zones for memory pressure.  
</p>

<p>
The embedded community has a lot of interest in seeing this feature get
added to the kernel.  Devices like phones and PDAs are often running close
to their memory limits and the OOM killer is currently unavoidable when the
user opens yet another application.  With this patch in place, programs
that use a lot of memory, but could get by with less, can be changed to
free up their caches and the like when memory gets tight.  As memory hungry
programs get changed, other users will
benefit as well.
</p>

<p>
The patch, submitted by Kosaki Motohiro, has been through several
iterations on linux-kernel.  The work was originally started by Marcelo
Tosatti, with the fifth version recently posted by Kosaki.  Previous
versions have been well received and with relatively few
comments on this iteration, it would seem to be getting close to being merged.
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_management-Out-of-memory_handling">Memory management/Out-of-memory handling</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#OOM_killer">OOM killer</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/267013/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor267248"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding the OOM killer with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 3:34 UTC (Thu)
                               by <b>salimma</b> (subscriber, #34460)
                              [<a href="/Articles/267248/">Link</a>] (29 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Presumably the OOM killer looks at applications' changes in memory footprint when picking a
victim? Otherwise there'd be no incentive for an app to play nice and voluntarily relinquish
memory.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267248/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267263"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding the OOM killer with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 9:09 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/267263/">Link</a>] (27 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
It's possible to take this metaphor of processes fighting over memory too far.  I don't think
in practice app writers consider themselves to have "won" if they've managed to partially
crash the user's system but keep their own process running while they did it.  The goal is to
not invoke the capricious god OOM at all.

Interesting possibility enabled by this patch: userspace OOM killer.  You don't *have* to
reduce memory by freeing caches -- killing other processes is quite effective too :-).  And if
you have a relatively integrated environment like a phone UI, you may know perfectly well from
userspace that killing that java game is better than killing the windowing system, which is
better than killing the gsm daemon.  (Even on desktops, one knows that killing X will also
automatically kill all its clients -- so one should always start by killing those clients
first, because if that works, then you've managed to escape the OOM situation with strictly
less damage.)
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267263/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267272"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 11:08 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/267272/">Link</a>] (25 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
The OOM killer is needed because the kernel has overallocated memory.  Surely for critical
processes there is a way to request 'hard' memory, where you can be sure that it really exists
either as RAM or swap space, and you can be certain you're not going to be arbitrarily killed
later for using the memory you requested.  The tradeoff is that a memory allocation request
can fail - but better to have malloc() return 0 where the app can handle it sensibly than to
have it pretend to work and then randomly kill your process later.

Can you turn off overallocation (and OOM killing) on a per-process basis?
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267272/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267281"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 11:43 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/267281/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
<font class="QuotedText">&gt;and you can be certain you're not going to be arbitrarily killed later for using the memory
you requested</font>

Well, here's what makes designing the OOM-killer hard -- attempting to use memory that the
system doesn't have actually *doesn't* kill you, it just wakes up the OOM-killer and then it's
perfectly possible that the OOM-killer will go after someone else.  Imagine a scenario where
one app allocates 99% of the system's memory (and not with some virtually allocated
overallocation bs, like they actually touch the pages or whatever), and then stops.  Then you
try to run "ls", and it overflows that last 1% of memory and wakes up the OOM-killer.  The
OOM-killer tries to identify and then attack the runaway giant process, not ls, even though ls
was the one who tried to get more memory.

So it doesn't actually help much for you, personally, to make sure your memory is not
overallocated -- if anything it will hurt, since it increases memory pressure overall and also
makes your process a bigger target.  You can turn off overallocation globally, but that
doesn't necessarily help either, since in the scenario above it just means that ls (and every
other program you try to run) fails, while the runaway monster just sits there.

Google say you can disable the OOM killer on a per-process basis, though, which I hadn't
known: <a href="http://linux-mm.org/OOM_Killer">http://linux-mm.org/OOM_Killer</a>
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267281/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267543"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 20:21 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/267543/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
So it doesn't actually help much for you, personally, to make sure your memory is not
overallocated
</blockquote>
<p>
Right, that's as dodgy as expecting to avoid the OOM Killer pseudo-crash by having the kernel notify users that memory is tight.
<p>
What you want is a combination of the two: a process turns off overallocation for itself, and in exchange, is made immune to the OOM Killer.
<p>
That way, processes that need determinism can have it while processes that don't want to waste swap space can have that.
<p>
Linux doesn't have this.  AIX does.


      
          <div class="CommentReplyButton">
            <form action="/Articles/267543/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267578"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 23:55 UTC (Fri)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/267578/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
<font class="QuotedText">&gt; What you want is a combination of the two: a process turns off overallocation for itself,
and in exchange, is made immune to the OOM Killer.</font>

I don't see the connection between these.  Turning off overallocation just means that you get
a different error handling API.  It certainly doesn't stop you from running the system out of
memory.

Making a process immune from the OOM killer is clearly a root-level operation; all you have to
do to force allocation is to touch pages after you allocate them, obviously not a root level
sort of ability.

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267578/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2008 2:00 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/267591/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Turning off overallocation just means that you get
a different error handling API
</blockquote>
<p>
How is getting killed by the OOM Killer an error handling API?  Turning off overallocation means you get an error handling API where you had none before.

<blockquote>
It certainly doesn't stop you from running the system out of memory.
</blockquote>
<p>
Turning off overallocation for one process doesn't stop you from running the system out of memory; that's why the OOM Killer is still there.  But he only kills <em>other</em> processes.  The connection is that if Process X is not overallocating memory (swap space), then the OOM Killer is guaranteed to be able to relieve memory pressure without having to kill Process X.  You can't say that about an overallocating process.

<p>
Think of it as two separate pools of swap space; one managed by simple allocation; the other with optimistic overallocation and an OOM Killer.  A process decides which one works best for it.

<blockquote>
all you have to
do to force allocation is to touch pages after you allocate them,
</blockquote>
<p>
No, that's not enough.  In overallocating mode, the swap space does not get allocated until the kernel decides to steal a page frame.  By then, the process is in no position to be able to deal with the fact that there's not enough swap space for him.

      
          <div class="CommentReplyButton">
            <form action="/Articles/267591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267634"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2008 1:39 UTC (Sun)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/267634/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Ah, I see, that's not what overallocation means.  It has nothing to do with swap.  As far as
the memory manager is concerned, the total amount of memory available in the system is RAM +
swap -- if you have 1G ram and 2G swap, then you have 3G total memory.

This 3G total is distributed among processes.  If overallocation is turned off, then each time
a process calls malloc() (well, really mmap()/sbrk()/fork()/etc., but never mind), either some
pages from that 3G are shaved off and reserved for that process's use, or if there are not
enough pages remaining then the syscall fails.

If overallocation is turned on, then malloc() never actually allocates memory.  What it does
instead is set up some virtual pages in the process's address space, and then the first time
the process tries to write anywhere on each of those not-really-there pages, the process takes
a fault, the memory manager allocates one of those 3G of pages, sticks it in place of the fake
page, and then finally allows the write to continue.  The upside of this is that if a process
malloc()'s a big chunk of memory and then only uses part of it, it's as if they only
malloc()'ed exactly what they ended up needing.  The downside is that since the actual
allocation is now happening somewhere in the middle of a single user-space cpu instruction,
there's no way to signal an error back to the process if the allocation fails, and so in that
case the only thing you can do is wake up an OOM-killer.

<font class="QuotedText">&gt; The connection is that if Process X is not overallocating memory (swap space), then the OOM
Killer is guaranteed to be able to relieve memory pressure without having to kill Process X.</font>

Which means that this just isn't true.  Memory pressure is caused by actually-allocated pages,
and the only difference between a process using overallocation and one that isn't is that the
overallocating process may have some virtual pages set up to trigger allocation sometime in
the future.  Whether such pages exist has no bearing whatsoever on memory pressure *now*.  The
only way the OOM-killer can relieve memory pressure is to kill off processes that are using
memory, and Process X qualifies.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267634/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267650"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2008 2:29 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/267650/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>
Though you start out saying overallocation has nothing to do with swap, your second sentence shows that it is strongly related to swap, saying that swap space is half the equation in determining how much memory is available to allocate.
<p>
But what overallocation are you talking about?  You describe it like some well-defined Linux function.  Are you talking about something that Linux implements?  AFAIK, Linux does not implement a per-process overallocation mode, and we were talking about what <em>should</em> be.
<p>
It's clear how the mode <em>should</em> work:  The same way it does in AIX, which is what I described.  "Turning off" overallocation has to mean that once you've allocated memory, you can <em>use</em> it and can't be killed for lack of memory.  Otherwise, why bother having the mode?
<p>
And the way to do that is to allocate swap space to the process at the moment you allocate the virtual addresses to it.  You could alternatively permanently allocate some real memory to the process, but that would be really wasteful (and we already have a means to do that: mlockall()).

<p>BTW, it's not helpful to talk about memory not being actually allocated by malloc (brk/mmap/etc).  malloc() does actually allocate virtual memory.  Allocating swap space and allocating real memory are separate things that exist in support of <em>using</em> virtual memory which has been allocated.  I also don't think "virtual" amounts to "fake."  It's a different form of memory.

<blockquote>
<p>Memory pressure is caused by actually-allocated pages
</blockquote>
<p>
I assume you mean pages of real memory.  Filling up of real memory is the primary cause of memory pressure, but it's easy to relieve that pressure:  just push data you aren't using out to swap space and free up the real memory.  When swap space is <em>full</em>, that's when the pressure backs up into the real memory and the OOM Killer is needed.  That's why I say swap space is the key to giving guaranteed-usable virtual memory to a process.

      
          <div class="CommentReplyButton">
            <form action="/Articles/267650/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267654"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2008 4:06 UTC (Sun)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/267654/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Obviously we're totally talking past each other, but I'll try one more time...

<font class="QuotedText">&gt;Though you start out saying overallocation has nothing to do with swap, your second sentence
shows that it is strongly related to swap, saying that swap space is half the equation in
determining how much memory is available to allocate.</font>

Well, sure, swap is, by any measure, an important part of a VM system, but that doesn't mean
it's "strongly related" to any other particular part of a VM system.  My point is that from
the point of view of overallocation, the difference between swap and physical RAM is just
irrelevant.

<font class="QuotedText">&gt; But what overallocation are you talking about? You describe it like some well-defined Linux
function. Are you talking about something that Linux implements?</font>

Yes.  I'm talking about "overallocation" or "overcommit", which in this context is a technical
term with a precise meaning.  When people are talking about it in this thread, they are
referring to a particular policy implemented by the Linux kernel and enabled by default.
Evidentally you haven't encountered this particular design before, which is why I described it
in my previous comment...

<font class="QuotedText">&gt;AFAIK, Linux does not implement a per-process overallocation mode, and we were talking about
what should be.</font>

No, AFAIK it doesn't, but it does support a global overallocation/no-overallocation switch,
and it's obvious what it would mean to take that switch and make it process-granular.  Maybe
there's yet another policy that Linux should implement, but if you want to talk about that
then trying to redefine an existing term to do so will just confuse people.

<font class="QuotedText">&gt;And the way to do that is to allocate swap space to the process at the moment you allocate
the virtual addresses to it.</font>

Huh, so is this how traditional Unix works?  Is this tight coupling between memory allocation
policy and swap management policy the original source of that old advice to make your swap
space = 2xRAM?  I've long wondered where that "rule" came from.

I guess I've heard before that in traditional Unix all RAM pages are backed on disk somewhere,
either via the filesystem or via swap, but I hadn't thought through the consequences before.

I'm guessing this is the original source of confusion.  Linux doesn't work like that at all;
I'm not sure there's any modern OS that does.  In a system where RAM is always swap-backed,
having 1G RAM and 2G of swap means that all processes together can use 2G total; in Linux,
they can use 3G total, because if something is in RAM it doesn't need to be in swap, and
vice-versa.  (What happens in your scheme if someone is running without swap?  I bet there are
people in this thread who both disable overallocation and run without swap (hi Zooko!).)

"Allocated memory" in my comment really just means "anonymous transient data that the kernel
has committed to storing on the behalf of processes".  It can arrange for it to be stored in
RAM, or in swap, or whatever.  There is no such thing as "allocated swap" or "allocated RAM"
in Linux.  (Except via mlockall(), I guess, if you want to call it that, but I don't think
calling it that is conceptually useful -- it's more of a way to pin some "allocated memory" 

Does that make my previous comment make more sense?
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267654/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2008 9:43 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/267714/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
but it does support a global overallocation/no-overallocation switch,
and it's obvious what it would mean to take that switch and make it process-granular. 
</blockquote>
<p>
That would be only slightly different from the scheme I described.  The only difference is that the global switch lets you add a specified amount of real memory to the size of swap space in calculating the quota.  If you could stop the kernel from locking up that amount of real memory for other things, you could have the OOM-proof process we're talking about, with less swap space.

<p>I think the only reason I haven't seen it done that way is that swap space is too cheap to make it worthwhile to bring in the complexity of allocating the real memory.  If I were to use the Linux global switch, I would just tell it to consider 0% of the real memory and throw some extra disk space at it, for that reason.

<p>
<blockquote>
What happens in your scheme if someone is running without swap?  I bet there are
people in this thread who both disable overallocation and run without swap
</blockquote>
<p>
They don't have that option.  The price they pay to have zero swap space is that nothing is ever guaranteed to be free from being OOM-killed.  Which is also the case for the Linux users today who disable overallocation and run without swap.

      
          <div class="CommentReplyButton">
            <form action="/Articles/267714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor267826"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2008 13:44 UTC (Tue)
                               by <b>filipjoelsson</b> (guest, #2622)
                              [<a href="/Articles/267826/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
<font class="QuotedText">&gt; But what overallocation are you talking about? You describe it like some</font>
<font class="QuotedText">&gt; well-defined Linux function. Are you talking about something that Linux</font>
<font class="QuotedText">&gt; implements? AFAIK, Linux does not implement a per-process overallocation</font>
<font class="QuotedText">&gt; mode, and we were talking about what should be.</font>

I think the overallocation he talks about is on the userspace level. When I'm programming an
application to read, store and analyze data on a laptop (a field application - the user wants
to have preliminary analysis right away), I can make a big fat allocation to use for cache. I
store the data in a database, which also uses a big fat cache. Until now, I have been had to
either make both caches no larger than a quarter the size of the RAM (roughly), since swapping
out really defeats the point of the cache.

If I had bigger caches, I could just hope that the sum of the actually used memory would not
be larger than RAM (or else it'd start swapping out, or if I run without swap - trigger the
OOM). With this patch, I can safely overcommit - and when I get the notification, I can cut
down on the caches and survive. The analysis step of the app will be slower, but my user will
not have been near a crash - and the analysis would have been slower anyway because of
swapping. One difference is that he can run without swap in a much more safe manner. Anyway,
this is not at all a case of a partial crash. You could argue that it is a case of sloppy
programming, but why should I reinvent memory managing? I'd much rather let the kernel do that
for me.

Oh, and lastly - on embedded platforms, you often have to do without swap. Swapping to flash
does not strike me as a good idea.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267826/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor268319"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2008 5:00 UTC (Fri)
                               by <b>goaty</b> (guest, #17783)
                              [<a href="/Articles/268319/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Don't forget about stack! For heavily multi-threaded processes on Linux, stack is usually the
biggest user of virtual memory.

As an aside, I know some operating systems use a "guard page" stack implementation, where
writes into the first page off the bottom (top?) of the stack trigger a page fault, which
allocates another page worth of real memory, and also moves the "guard page". The benefit
being that virtual memory use is much closer to actual memory use, and turning off overcommit
is much more viable. The downside is that the ABI requires the compiler to generate code to
probe every page when it needs to allocate a stack frame larger than the page size. Which
ironically can end up using more real memory than Linux's virtual-memory-hungry approach.

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268319/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268412"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2008 21:23 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/268412/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Linux has used a guard-page stack implementation since forever. It's 
transparent to userspace: the compiler doesn't need to do a thing.

(Obviously when threading things get more complex.)

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268412/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor267423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 0:01 UTC (Fri)
                               by <b>zooko</b> (guest, #2589)
                              [<a href="/Articles/267423/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
You can set sys.vm.overcommit_memory to policy #2.  Unfortunately, it isn't entirely clear
that this will banish the OOM killer entirely, or if it will just make it very rare.

<a href="http://www.linuxinsight.com/proc_sys_vm_overcommit_memory.html">http://www.linuxinsight.com/proc_sys_vm_overcommit_memory...</a>
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267430"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 1:21 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/267430/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
I ran my Linux laptop with strict overcommit enabled for a while.  Unfortunately, it does not
help.  Almost all desktop applications expect memory allocation to succeed.  From some of the
application errors I saw, developers seem to have become very lax about checking for NULL from
malloc.

C++ and Python applications did better, because they get an exception, and they have to do
*something* with it.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267430/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267441"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 3:28 UTC (Fri)
                               by <b>zooko</b> (guest, #2589)
                              [<a href="/Articles/267441/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Even if what you say is true, I would think that this would make the effects of memory
exhaustion more deterministic/reproducible/predictable.

C++ and Python apps, and also C apps that use malloc sparingly, would be less likely to crash
than others, I guess.

Perhaps this degree of predictability isn't enough to be useful.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267441/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267519"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 17:56 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/267519/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
I did not notice any extra predictability.  The effect was that the desktop programs crash
apparently randomly.  It was much like the OOM killer.  And just like the OOM killer, it was
generally the big stuff that blew up, like Evolution and Open Office.  I lost gnome-terminal a
few times.

The C++ and Python apps still crashed, they were simply more polite about it.

By the way, I don't read it that way, but your phrasing "Even if what you say is true" *could*
be offensive.  It seems to be saying that I wrote untruthfully.

Even if you don't see the same effect on your system, I did see it just the way I described it
on mine.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267519/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267541"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 19:34 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/267541/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Desktop applications aren't where I would expect to see deterministic memory allocation exploited.  Allocation failures and crashes aren't such a big deal with these applications because if things fall apart, there's a user there to pick up the pieces.  Overallocation and OOM Killer may well be the optimum memory management scheme for desktop systems.
<p>
Where it matters is business-critical automated servers.  For those, application writers do spend time considering running out of memory -- at least they do in cases where an OOM killer doesn't make it all pointless anyway.  They check the success of getting memory and do it at a time when there is some reasonable way to respond to not getting it.
<p>
And they <em>shouldn't</em> spend time worrying about freeing up swap space for other processes (i.e. mem_notify is no good).  That resource management task belongs to the kernel and system administrator.

      
          <div class="CommentReplyButton">
            <form action="/Articles/267541/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor267542"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 20:14 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/267542/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
You can set sys.vm.overcommit_memory to policy #2.  Unfortunately, it isn't entirely clear
that this will banish the OOM killer entirely, or if it will just make it very rare.
</blockquote>
<p>
It's entirely clear to me that it banishes the OOM killer entirely.  The only reason the OOM killer exists is that sometimes the processes use more virtual memory than there is swap space to put its contents.  With Policy 2, virtual memory isn't created in the first place unless there is a place to put the contents.

      
          <div class="CommentReplyButton">
            <form action="/Articles/267542/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267548"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 20:47 UTC (Fri)
                               by <b>zooko</b> (guest, #2589)
                              [<a href="/Articles/267548/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
But doesn't the kernel itself dynamically allocate memory?  And when it does so, can't it
thereby use up memory so that some user process will be unable to use memory that it has
already malloc()'ed?  Or do I misunderstand?
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267548/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 21:26 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/267552/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <p>The kernel reserves at least one page frame for anonymous virtual memory (actually, it's a whole lot more than that, but in theory one frame is enough for all the processes to access all their virtual memory as long as there is adequate swap space).
<p>
So any kernel real memory allocation can fail, and the code is painstakingly written to allow it to handle that failure gracefully (more gracefully than killing an arbitrary process).  It allocates memory ahead of time so as to avoid deadlocks and failures at a time that there is no graceful way to handle it.

      
          <div class="CommentReplyButton">
            <form action="/Articles/267552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267558"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 21:50 UTC (Fri)
                               by <b>zooko</b> (guest, #2589)
                              [<a href="/Articles/267558/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Right, but I wasn't asking about the kernel's memory allocation failing -- I was asking about
the kernel's virtual memory allocation succeeding by using memory that had already been
offered to a process as the result of malloc().

Oh -- perhaps I misunderstood and you were answering my question.  Are you saying that the
kernel will fail to dynamically allocate memory rather than allocate memory which has already
been promised to a process (when overcommit_memory == 2)?

Thanks,

Zooko

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267558/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267570"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 23:05 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/267570/">Link</a>] 
      </p>
      
      </div>
      </summary>
      The kernel doesn't use virtual memory at all (well, to be precise let's just say it doesn't use paged memory at all).   The kernel's memory is resident from the moment it is allocated, it can't ever be swapped out, and the kernel uses no swap space.

      
          <div class="CommentReplyButton">
            <form action="/Articles/267570/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor267889"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2008 23:05 UTC (Tue)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/267889/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
the problem that you will have when you disable overallocating memory is that when your 200M
firefox process tries to spawn a 2k program (to handle some mime type) it first forks, and
will need 400M of ram, even though it will immediatly exec the 2k program and never touch the
other 399.99M of ram.

with overallocation enabled this will work. with it disabled you have a strong probability of
running out of memory instead.

yes, it's more reproducable, but it's also a completely avoidable failure.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267889/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2008 3:25 UTC (Wed)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/267909/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>I wonder why we still have fork.  As innovative as it was, fork was immediately recognized, 30 years ago, as impractical.  vfork took most of the pain away, but there is still this memory resource allocation problem, and some others, and fork gives us hardly any value.  A fork-and-exec system call would fix all that.
<p>
Meanwhile, if you have the kind of system that can't tolerate even an improbable crash, and it has processes with 200M of anonymous virtual memory, putting up an extra 200M of swap space which will probably never be used is a pretty low price for the reliability of guaranteed allocation.

      
          <div class="CommentReplyButton">
            <form action="/Articles/267909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267913"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2008 5:26 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/267913/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
many people would disagree with your position that vfork is better then fork. (the issue came
up on the lkml within the last week and was dismissed with something along the lines of 'vfork
would avoid this, but the last thing we want to do is to push more people to use vfork')

I agree that a fexec (fork-exec) or similar call would be nice to have, but it wouldn't do
much good for many years (until a significant amount of software actually used it)

as for your comment of just add swap space to avoid problems with strict memory allocation.

overcommit will work in every case where strict allocation will work without giving
out-of-memory errors, and it will work in many cases where strict allocation would result in
errors. overcommit will also work in many (but not all) cases where strict allocation would
result in out of memory errors.

if it's trivial to add swap space to avoid the OOM errors in strict allocation, that same swap
space can be added along with overcommit and the system will continue to work in even more
cases.

the only time strict allocation will result in a more stable system is when your resources are
fixed and your applications are fairly well behaved (and properly handle OOM conditions), even
then the scenerio of one app allocating 99% of your ram, preventing you from running other
apps, is still a very possible situation. the only difference is that the timing of the OOM
error is more predictable (assuming that you can predict what software will be run when in the
first place)
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267913/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor268037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Requesting 'real' memory</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 0:35 UTC (Thu)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/268037/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Many people would disagree with your position that vfork is better then fork
</blockquote>
<p>
No, they wouldn't, because I was talking about the early history of fork and comparing the original fork with the original vfork.  The original fork physically copied memory.  The original vfork didn't, making it an unquestionable improvement for most forks.  A third kind of fork, with copy-on-write, came later and obsoleted both.  I didn't know until I looked it up just now that a distinct vfork still exists on modern systems.
<p>
<blockquote>
the only time strict allocation will result in a more stable system is when your resources are
fixed and your applications are fairly well behaved (and properly handle OOM conditions)
</blockquote>
<p>
The most important characteristic of a system that benefits from strict allocation is that there be some meaningful distinction between a small failure and a catastrophic one.  If all your memory allocations must succeed for your system to meet requirements, then it's not better to have a fork fail than to have some process randomly killed, and overallocation is better because it reduces the probability of failure.
<p>
But there are plenty of applications that do make that distinction.  When a fork fails, such an application can reject one piece of work with a "try again later" and a hundred of those is more acceptable than one SIGKILL.

      
          <div class="CommentReplyButton">
            <form action="/Articles/268037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor267309"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding the OOM killer with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 15:12 UTC (Thu)
                               by <b>salimma</b> (subscriber, #34460)
                              [<a href="/Articles/267309/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Nokia has something similar on their Linux-based Maemo platform -- run it without swap, start
a bunch of applications, and a lot of the built-in applications would enter a
reduced-memory-usage mode -- noticeable because it takes much longer to switch to them than it
normally would.

I wonder whether the apps currently just poll the system to find out how much memory is left,
or they have their own mechanism, though.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267309/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor267267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">You forget about higher god!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 9:47 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/267267/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Applications are always under threat from OOM-killer, but there are another, more powerfull god: the end user! If applications does not play nice and forces other applications to be killed by OOM-killer (one way or another) then eventually this information reaches the user and application is either silenced forever or fixed. So the applications (or rather the application writers) have every incentive to play well with others...</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/267267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor267268"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">memory congestion avoidance</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 10:01 UTC (Thu)
                               by <b>sasha</b> (guest, #16070)
                              [<a href="/Articles/267268/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
All the topic looks for me like TCP congestion avoidance protocol.  Currently, we are at the
early start of its development -- we are going to get a notification that the congestion
exists.  However, it is not enough to have a notification system, because different
applications are going to play by different rules.

So, I' looking forward for some clear rules for "memory congestion avoidance" written down as
a standard and implemented in the most of the high-level languages, especially languages with
garbage collectors.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267268/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor267322"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding the OOM killer with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 31, 2008 17:06 UTC (Thu)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/267322/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <P>How effective can this be, though, for many C programs?  If I <TT>malloc</TT> a bunch of memory, perhaps as caches, and then am asked to <TT>free</TT> it, that doesn't magically release pages back to the OS.  Now, if <TT>malloc</TT> uses <TT>mmap</TT> for some of the larger allocations, those can be released back to the OS by <TT>munmap</TT>.  But, for the general <TT>sbrk</TT> managed heap, I have to free stuff near the end of the heap before I can ask for my <TT>brk</TT> to be lowered.  There's no guarantee I can do that.</P>
<P>For this to be useful, whatever I <TT>malloc</TT> needs to have an additional level of indirection in user space, so I can move the objects I wish to keep and then compact the heap.  Otherwise, simply freeing stuff up won't be enough.</P>
<P>It may be useful to compare/contrast this to the HURD's approach, which is simply to force user space to do its own VM management.  There, the kernel and user-space dicker about physical pages only, and user space figures out how best to handle the burden when a given app wants more pages than the OS can give it. The answer could be garbage collection, discarding caches, swapping or whatever makes sense to a given application.</P>
<P>The main thing is that the app knows way ahead of time that real RAM is in short supply, and avoids getting into the overcommitted state entirely.  And since the kernel isn't doing the swapping, it seems like you wouldn't get into situations where you need to free memory so you have enough memory so that you can write out pages and the like.  Example:  Imagine that to wake an app so it can free some pages, you have to bring it in from swap, but swap is too full to write any dirty anonymous pages out.  If your policy is that each app self-swaps, this should never happen since the OS guarantees it'll have enough pages to do its work, and user space will just muddle along with what its given.  (In theory, it seems like a user space app could get by with just a few pages... a couple executable pages and a couple data pages.)</P>
<P>I'm guessing <TT>mem_notify</TT> will try to wake apps sufficiently far ahead that it can avoid those "need RAM to free RAM" situations in practice, but setting proper thresholds seems like it ought to be rather tricky.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/267322/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267438"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding the OOM killer with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 3:03 UTC (Fri)
                               by <b>vomlehn</b> (guest, #45588)
                              [<a href="/Articles/267438/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
<font class="QuotedText">&gt; I'm guessing mem_notify will try to wake apps sufficiently far ahead that it can avoid those
"need RAM to free RAM" situations in practice, but setting proper thresholds seems like it
ought to be rather tricky</font>

I don't see how the kernel can possibly know enough for it to notify applications far enough
ahead about the need to free memory; the memory allocation behavior of applications is just
too unpredictable.

An approach that seems like it would be better would be to notify the kernel that certain
pages in your application are being used to cache data. The kernel is then free to simply grab
them if it needs them. If your application decides it needs the data later, it uses as sytem
call to notify the kernel that the pages are no longer being used as a cache. If the kernel
didn't need the pages, they would still have their old data and the application could use them
directly.

On the other hand, if the kernel did have to grab the pages in the interim, the system call
used to grab the pages back would return an error. Your application would then know it needs
to remap the pages and regenerate the data. Of course, it's possible the pages can't be
remapped because memory is too low. The application would handle that as though the data
wasn't cached and it couldn't get the memory to read it. It already has to be able to do this,
so this doesn't add to the application's complexity.

The advantages of this approach are that the pages are immediately available to the kernel
without having to wake the process up. No need to figure out complex threshholds, no need to
allocate enough memory for the process to run, no delay in making the needed memory available.
You could even allow for priorities when telling the kernel the pages are being used for cache
so that the kernel would grab lower priority pages first.

I wish I had the time to code this and submit it because I think that mem_notify is an awful
botch that will cause unending pain as people add patch on patch to try to make it work. But
that's just my personal opinion...
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267438/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267522"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding the OOM killer with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 19:47 UTC (Fri)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/267522/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Applications can already see if they're missing memory pages by using mincore().

You may not have been carefully reading the mem_notify patch descriptions.

What it does is trigger on memory pages going into the inactive list.  This is what happens to
prepare memory pages that are good candidates for swapping.

Here is the Changelog from version 5 of the mem_notify patch, see the v3 changes:
Changelog
-------------------------------------------------
  v4 -&gt; v5 (by KOSAKI Motohiro)
    o rebase to 2.6.24-rc8-mm1
    o change display order of /proc/zoneinfo
    o ignore very small zone
    o support fcntl(F_SETFL, FASYNC)
    o fix some trivial bugs.

  v3 -&gt; v4 (by KOSAKI Motohiro)
    o rebase to 2.6.24-rc6-mm1
    o avoid wake up all.
    o add judgement point to __free_one_page().
    o add zone awareness.

  v2 -&gt; v3 (by Marcelo Tosatti)
    o changes the notification point to happen whenever
      the VM moves an anonymous page to the inactive list.
    o implement notification rate limit.

  v1(oom notify) -&gt; v2 (by Marcelo Tosatti)
    o name change
    o notify timing change from just swap thrashing to
      just before thrashing.
    o also works with swapless device.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267522/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor267451"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding the OOM killer with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 4:57 UTC (Fri)
                               by <b>ikm</b> (guest, #493)
                              [<a href="/Articles/267451/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
<font class="QuotedText">&gt; When memory gets tight, it is quite possible that applications have memory allocatedoften
caches for better performancethat they could free.</font>

Not many programs actually have any adjustable caches. More often it would be some useless
unreclaimed junk (and of course i'm talking java here). So this change should primarily
benefit them, I guess.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267451/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267492"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding the OOM killer with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 13:27 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/267492/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
I don't think I've ever written a substantial program that didn't have 
*some* sort of caching in it, to trade off space against time somewhere 
where `spend the time, every time' was undesirable. Often these caches are 
not expected to be terribly large, and have the exciting expiration policy 
`never', but it would be fairly trivial to respond to a mem_notify signal 
by just ditching the entire contents of all of those caches.

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267492/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor267554"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding the OOM killer with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 1, 2008 21:36 UTC (Fri)
                               by <b>droundy</b> (subscriber, #4559)
                              [<a href="/Articles/267554/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
There are certain obscure programs like firefox and gimp that have very large caches which
could be dumped under pressure.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267554/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267627"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding swap IO with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 2, 2008 17:49 UTC (Sat)
                               by <b>riel</b> (subscriber, #3142)
                              [<a href="/Articles/267627/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
The patch series is indeed designed primarily to increase system performance by avoiding the
IO penalty of swapping out (and back in) memory that contains data that is useless or can be
easily recalculated.

Decompressing (part of) a jpeg just has to be faster than swapping in something from disk,
simply because disk seek times are on the order of 10ms.

Avoiding the OOM killer is a secondary goal.  I am not sure why that is the headline of the
article...
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267627/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor267658"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding swap IO with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2008 4:14 UTC (Sun)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/267658/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
Oh!  This makes *much* more sense.  (Especially the otherwise unintelligible part of the
original article that talks about pages getting swapped out, which has nothing to do with
OOM.)

In fairness, though, the LKML patch announcement just talks about it being good to avoid the
OOM.
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267658/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor267698"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding swap IO with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 3, 2008 21:02 UTC (Sun)
                               by <b>oak</b> (guest, #2786)
                              [<a href="/Articles/267698/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
The article talks also about embedded systems. Those use use flash which 
doesn't suffer from the seek problem like hard disks do.  On embedded 
memory usage is much more of a problem though and kernel gets pretty slow 
too on devices without swap when memory gets really tight (all kernel does 
is page read-only pages from disk to memory and then discard them again 
until it finally does an OOM-kill).

I thought the point of the patch is for user-space to be able to do the  
memory management in *manageable places* in code.   As mentioned earlier, 
a lot of user-space code[1] doesn't handle memory allocation failures. And 
even if it's supposed to be, it can be hard to verify (test) that the 
failures are handled in *all* cases properly.  If user-space can get a 
pre-notification of a low-memory situation, it can in suitable place in 
code free memory so that further allocations will succeed (with higher 
propability). 

That also allows doing somehing like what maemo does.  If system gets 
notified about kernel low memory shortage, it kills processes which have 
notified it that they are in "background-killable" state (saved their UI 
state, able to restore it and not currently visible to user). I think it 
also notifies applications (currently) through D-BUS about low memory 
condition. Applications visible to user or otherwise non-background 
killable are then supposed to free their caches and/or disable features 
that could take a lot of additional memory.  If the caches are from heap 
instead of memory mapped, it's less likely to help because of heap 
fragmentation and it requiring more work/time though.

[1] Glib and anything built on top of it, like Gtk, assume that if process 
is still running, it got the memory, otherwise it's aborted.

</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/267698/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor268163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Avoiding the OOM killer with mem_notify</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 7, 2008 16:04 UTC (Thu)
                               by <b>ringerc</b> (subscriber, #3071)
                              [<a href="/Articles/268163/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment"><pre>
As a (fairly bad) application developer I'm not sure I understand how I can use this
effectively.

Say I'm notified that the kernel is running low on RAM. Furthermore, say I have a 265MB block
- a single allocation - and a bunch of small heap allocations before and after it in the heap.
Assuming I can afford to throw away the 256MB allocation I can delete() or free() it; however,
since I have more memory both higher and lower in the heap I don't see how the OS can reclaim
the RAM. I presume it relies on the huge allocation being a separate memory mapping (where
anonymous mmap() has been used by operator new or by malloc() ) that can be unmapped as per
/proc/self/maps?

So ... what about if my cache is a tree of heap-allocated objects of variable sizes (say, a
tree of polymorphic subtype instances)? Free()ing these objects is unlikely to help, since
many pages will have other things allocated on them too, and in any case the OS has no way to
know if a given page is free. This is especially likely when using the libstdc++ new(), which
(I understand) internally pre-allocates chunks of memory and parcels them out without invoking
lower level memory manegement. My understanding was that in this case all the kernel can do is
swap out the inactive page(s). I presume that to benefit from mem_notify I'd need to modify
the application to perform single large allocations dedicated only to use for this particular
cache, presumably either managing it with a C++ allocator interface (with the STL/Boost/etc)
or manually manage allocations within the block?

We all know it's often cleaner to use a container or an allocator in C++ when you want to
manage lots of small allocations of a particular type (especially when each is a fixed size
but they happen at unpredictable times) ... but many people don't, and in fact don't
understand them at all. It doesn't help that the STL and core language provide absolutely no
flexible pool allocators etc; you have to go to Boost for those, and many OSS / Free Software
projects are strangely reluctant to add a dependency on Boost.

What might help would be if there was a tiny portable C/C++ library (suitable to be compiled
directly into apps) that provided entirely standard and highly portable routines for non-Linux
platforms, and on Linux provided mem-pressure-aware C++ allocators and C memory allocation
calls + notifier callback hooks. All with identical interfaces, of course, though the
non-Linux ones would never actually detect and respond to memory pressure (unless other
platform support was added). A set of C++ "cache allocators" for various usage patterns that
could monitor memory pressure and automatically notify interested parties then invalidate and
release themselves would be particularly cool.

--
Craig Ringer
</pre></div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/268163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2008, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
