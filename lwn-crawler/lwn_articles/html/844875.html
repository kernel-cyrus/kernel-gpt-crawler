        <!DOCTYPE html>
        <html lang="en">
        <head><title>ioctl() for io_uring [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/844875/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/845092/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/844875/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>ioctl() for io_uring</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>February 4, 2021</br>
           </div>
Of all the system calls in the Unix tradition, few are as maligned as <a
href="https://man7.org/linux/man-pages/man2/ioctl.2.html"><tt>ioctl()</tt></a>.
But <tt>ioctl()</tt> exists for a reason — for many reasons, in truth — and
cannot be expected to go away anytime soon.  It is thus unsurprising that
there is interest in providing <tt>ioctl()</tt>-like functionality in the
<a href="/Articles/776703/">io_uring subsystem</a>.  A recent <a
href="/ml/io-uring/20210127212541.88944-1-axboe@kernel.dk/">RFC patch set
from Jens Axboe</a> shows the form that this feature might take in the
io_uring context.
<p>
The <tt>ioctl()</tt> name comes from "I/O control"; this system call was
added as a way of performing operations on peripheral devices that went
beyond reading and writing data. It could be used to rewind a tape drive,
set the baud rate of a serial port, or eject a removable disk, for example.  Over the
years, uses of <tt>ioctl()</tt> have grown far beyond such simple
applications, with some APIs (<a
href="https://www.kernel.org/doc/html/latest/userspace-api/media/index.html">media</a>,
for example) providing hundreds of operations.
<p>
The criticism of <tt>ioctl()</tt> comes from its multiplexed and
device-dependent nature; almost anything that can be represented by a file
descriptor supports <tt>ioctl()</tt>, but the actual operations supported
vary from one to the next.  While system calls are (in theory, at least)
closely scrutinized before being added to the kernel, <tt>ioctl()</tt>
commands often receive close to no review at all.  So nobody really knows
everything that can be done with <tt>ioctl()</tt>.  For added fun, there is
some overlap in the command space, meaning that an <tt>ioctl()</tt> call
made to the wrong file descriptor could have unexpected and highly
unpleasant results.  Attempts have been made to avoid this problem, but
they have not been completely successful.
<p>
After dealing with these problems for years, some developers would like to
see <tt>ioctl()</tt> disappear completely, 
but nobody has ever come up with a replacement that looks materially
better.  Adding a new system call for every function that might be
implemented with <tt>ioctl()</tt> is a non-starter; having device drivers
interpret command streams sent with <tt>write()</tt> is even worse.  There
probably is no better way to, for example, tell a camera sensor which color
space to use.
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
It is natural to want to support <tt>ioctl()</tt> in io_uring; it is not
uncommon to mix <tt>ioctl()</tt> calls with regular I/O, and it would be
useful to be able to do everything asynchronously.  But every
<tt>ioctl()</tt> call is different, and none of them were designed for
asynchronous execution, so an <tt>ioctl()</tt> implementation within
io_uring would have no choice but to execute every call in a separate
thread.  That might be better than nothing, but it is not anywhere near as
efficient as it could be, especially for calls that can be executed right
away.  Doing <tt>ioctl()</tt> right for io_uring essentially calls for
reinventing the <tt>ioctl()</tt> interface.
<p>
Operations in io_uring are communicated from user space to the kernel via a ring buffer;
each is represented as an instance of the somewhat complex <a
href="https://elixir.bootlin.com/linux/v5.10.12/source/include/uapi/linux/io_uring.h#L13"><tt>io_uring_sqe</tt>
structure</a>.  The new command mechanism is invoked by setting
<tt>opcode</tt> in that structure to <tt>IORING_OP_URING_CMD</tt>; the
<tt>fd</tt> field must, as usual, contain the file descriptor to operate
on.  The rest of the structure, though (starting with the <tt>off</tt>
field) is overlaid with something completely different:
<p>
<pre>
    struct io_uring_pdu {
	__u64 data[4];	/* available for free use */
	__u64 reserved;	/* can't be used by application! */
	__u64 data2;	/* available for free use */
    };
</pre>
<p>
The <tt>reserved</tt> field overlays <tt>user_data</tt> in the original
structure, which is needed 
for other purposes; thus, no data relevant to the command can be stored
there.  Applications are unlikely to see this structure, though; it will be
overlaid yet again with a structure specific to the command to be
executed.  For block-subsystem commands, for example, this structure
becomes:
<p>
<pre>
    struct block_uring_cmd {
	__u16 	op;
	__u16	pad;
	union {
	    __u32	size;
	    __u32	ioctl_cmd;
	};
	__u64	addr;
	__u64	unused[2];
	__u64	reserved;	/* can never be used */
	__u64	unused2;
    };
</pre>
<p>
Deep down within this structure is <tt>ioctl_cmd</tt>, which the
application should set to the <tt>ioctl()</tt> command code of interest;
the <tt>op</tt> field should be <tt>BLOCK_URING_OP_IOCTL</tt> (for now; in
the future there could be operations that are not tied to an
<tt>ioctl()</tt> call).  In the
patch set, the only supported command is <tt>BLKBSZGET</tt>, which returns
the block size of the underlying block device — something that can clearly
be done without performing actual I/O or sleeping.  The patch set also <a
href="/ml/io-uring/20210127212541.88944-6-axboe@kernel.dk/">implements a
couple of networking commands</a> using a different structure.
<p>
Within the kernel, any subsystem that wants to support io_uring operations
must add yet another field to the forever-growing <a
href="https://elixir.bootlin.com/linux/v5.10.12/source/include/linux/fs.h#L1822"><tt>file_operations</tt>
structure</a>:
<p>
<pre>
    struct io_uring_cmd {
	struct file *file;
	struct io_uring_pdu pdu;
	void (*done)(struct io_uring_cmd *, ssize_t);
    };

    int (*uring_cmd)(struct io_uring_cmd *, enum io_uring_cmd_flags);
</pre>
<p>
Needless to say, any handlers for io_uring <tt>IORING_OP_URING_CMD</tt>
operations should not block. 
Instead, they can complete the operation immediately, return an error
indicating that the operation would block, or run the operation
asynchronously and signal completion by calling the given <tt>done()</tt>
function.
<p>
This is an initial posting of a change that could have long-term
implications, so it would not be surprising to see significant changes
before it makes it into the mainline.  Indeed, in response to <a
href="/ml/io-uring/20210128003831.GE7695@magnolia/">a comment from Darrick
Wong</a>, Axboe <a
href="/ml/io-uring/f8576940-5441-1355-c09e-db60ad0ac889@kernel.dk/#t">tweaked
the interface</a> to provide eight more bytes of space
in <tt>struct io_uring_pdu</tt> — something that Wong said would be highly
useful to be able to submit the "<q>millions upon millions of ioctl
calls</q>" created by the <tt>xfs_scrub</tt> utility.
<p>
Whether the addition of an <tt>ioctl()</tt>-like interface to io_uring —
which is rapidly evolving into a sort of shadow, asynchronous system-call
interface for Linux — will generate controversy remains to be seen; there
has been none in response to the initial posting.  Axboe <a
href="/ml/io-uring/20210127212541.88944-2-axboe@kernel.dk/">expressed
hope</a> that the new commands will be "<q>a lot more sane and
useful</q>" than the existing <tt>ioctl()</tt> commands, but there
doesn't seem to be any way to enforce that.  As with <tt>ioctl()</tt>, the
addition of new io_uring commands will happen entirely within other
subsystems, and the level of scrutiny those additions receive will vary.
But io_uring needs this sort of "miscellaneous command" capability in the
same way that the system as a whole needs <tt>ioctl()</tt>, so it would be surprising
if this feature were not eventually merged in some form.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#ioctl">ioctl()</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#io_uring">io_uring</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/844875/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor845127"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2021 18:11 UTC (Thu)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/845127/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So when will io_uring grow support for running BPF programs in the middle? :-)<br>
<p>
I&#x27;m not even completely joking - think about doing a sort of &#x27;grep-like&#x27; thing completely in kernel and only pushing out stuff you cared about.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845127/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845144"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 0:35 UTC (Fri)
                               by <b>jpsamaroo</b> (guest, #129727)
                              [<a href="/Articles/845144/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Honestly, I thought the exact same thing just before seeing your comment. I think it&#x27;s probably only a short time before we see someone posting such a patch to the ML. Of course, that could become an easy way to DDoS one&#x27;s kernel, unless the kernel limits the number of io_uring-submitted BPF programs that can be running at once.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845144/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845152"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 8:32 UTC (Fri)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/845152/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, there are sleepable BPF programs (now, see commit 1e6c62a88215) so with some further work in that area it could simply be mandated that such programs be used in that kind of context.<br>
<p>
The bigger issue I expect is the root vs. non-root discussion, though in some use cases I suppose it might be sufficient to allow root to use BPF programs in io_uring.<br>
<p>
And, tbh, the fact that it&#x27;s not clear what a BPF program could even _do_. I mean, io_uring would&#x27;ve copied out data to userspace, and then BPF would have to copy it back in? That doesn&#x27;t make much sense. So you&#x27;d have to have kernel buffers here? Unless it gets restricted to *managing* the operations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845152/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor845171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 14:12 UTC (Fri)
                               by <b>rhdxmr</b> (guest, #44404)
                              [<a href="/Articles/845171/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That would be awesome. io_uring supplies data to BPF program and all process is done inside kernel using BPF.<br>
Without any syscall and copying buffer to userspace, all IO related tasks can be achieved.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845310"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2021 20:14 UTC (Sat)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/845310/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That is still not thought to the end. Clearly, BPF needs to be able to issue new io_uring calls. After all, the calls to be made might depend on the processing of the data. We should definitely get rid of all those unnecessary context switches and abandon userspace altogether ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845310/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845343"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2021 8:05 UTC (Mon)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/845343/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Isn&#x27;t Linux a kind of BPF-(micro-?)kernel with legacy userspace support? ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845343/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845347"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2021 9:31 UTC (Mon)
                               by <b>Sesse</b> (subscriber, #53779)
                              [<a href="/Articles/845347/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
People keep bringing up this meme, but I honestly don&#x27;t understand what all the fuzz is about. I keep looking for uses for eBPF, but I really can&#x27;t find them—there are some admin tools to show me slow I/Os that I&#x27;ve used maybe once, and that&#x27;s it. Is this really such a revolution?<br>
<p>
io_uring, on the other hand, I can perfectly well see lots of uses for (and I have used it myself).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845347/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor845141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 4, 2021 23:57 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/845141/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
They&#x27;re missing a chance to make ioctl() calls to be completely self-contained (i.e. no pointers to other structures).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845143"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 0:50 UTC (Fri)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/845143/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That would be ideal, but I suspect that for complex structures, and especially ones with dynamically sized components, there&#x27;ll be a parade of buffer exploits for the inevitable ad hoc serializing and deserializing hacks people will write. (How many years did it take for the pace of /proc exploits to slow down?) The whole point of ioctl is to avoid the need for [de]marshaling in the kernel, and while it obviously has its own pitfalls and history of exploits, there&#x27;s decades of pruning and security fixes there. If avoiding the churn and inevitable introduction of exploits means continuing to do some (though hopefully *less*) pointer chasing, so be it. There are worse possibilities than keeping around some copy_from_user calls, especially with page table isolation-like mitigations in place.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845143/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845145"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 1:37 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/845145/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
So every implementer of ioctls in the kernel continues to be vulnerable to TOCTOU vulnerabilities? awesome.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845145/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845277"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2021 1:21 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/845277/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My point was that *some* uses of pointers couldn&#x27;t be easily replaced with a simple, flat structure. (I was responding to a comment about making *all* ioctls &quot;completely self-contained&quot;.) In such cases ad hoc solutions could end up being much more complex, and bug prone, then pointer chasing. You can see how hairy things can get with sysctl structures on macOS, where someone tried too hard to pack things into a flat buffer and ended up introducing an exploit. And there&#x27;s a checkered history of people trying to solve the problem &quot;once and for all&quot; by making use of XDR and other interchange formats for simple kernel interfaces.<br>
<p>
But of course if there&#x27;s a TOCTTOU exploit then I would expect the code (including the *existing* kernel code) to copy locally first. It&#x27;s not like there can&#x27;t be TOCTTOU races with a flat structure. TOCTTOU races is why you can&#x27;t use BPF to filter raw path names before permitting an open--because the process could overwrite the pathname after the BPF filter but before its passed to the internal open routines. To do it correctly the pathname would need to be copied to a local, in-kernel buffer, but for various reasons that&#x27;s not a solution most people like.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845277/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845279"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2021 2:13 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/845279/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And there&#x27;s a checkered history of people trying to solve the problem &quot;once and for all&quot; by making use of XDR and other interchange formats for simple kernel interfaces.</font><br>
ioctls are far from a simple kernel interface. Mach is actually a good example that shows it can work.<br>
<p>
<font class="QuotedText">&gt;  It&#x27;s not like there can&#x27;t be TOCTTOU races with a flat structure.</font><br>
Any realistic implementation would copy the structure buffer into kernel-controlled memory immediately. So yep, structures would solve the TOCTTOU issues once and for all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845279/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor845148"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 4:08 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/845148/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The whole point of ioctl is to avoid the need for [de]marshaling in the kernel</font><br>
This is kind of a nonsense, though. The kernel ends up chasing pointers into the userspace and having to deal with TOCTOU races all the time. With a buffer you can copy it once as a solid block of memory and then the kernel code can be sure nothing changes underneath it. In most cases we probably would just be able to map the buffer onto a C struct and use it without any fear.<br>
<p>
Moreover, this will make it much easier for BPF hooks to inspect the content or for the audit subsystem to log it. A lot of stuff will become possible.<br>
<p>
Windows NT kernel has just such a design and it really make some stuff easier.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845148/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor845286"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2021 10:20 UTC (Sat)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/845286/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Part of the problem is that in C there is no good way to work with packet structs or arrays accessed not by a pointer but by an offset with an offset verification. If one designs the format carefully with everything properly aligned one can cast offsets into pointers, but then the verification part is still manual and error prone.<br>
<p>
In languages allowing more abstractions and overloading of short names that problem does not exist and one can have rather convenient way to access the data even when they are not aligned.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845286/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845295"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2021 13:28 UTC (Sat)
                               by <b>sbaugh</b> (guest, #103291)
                              [<a href="/Articles/845295/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s interesting to observe that programming with pointers which are actually offsets inside regions was widespread for a while, but then abandoned: segmented memory and near/far pointers. It would be neat if the legacy segmentation features of x86 could be reused to make deserialization safe...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845295/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845298"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 6, 2021 15:43 UTC (Sat)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/845298/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It was not abandoned entirely. Google used the segmented registers to implement NaCl on x86. <br>
<p>
But again, programming with far/near pointers in Borland C++ in 1992 was too painful. A company where I got my first programming job abandoned that and used 32 pointers for everything even if it harmed performance and lead to fatter binaries. But then again, C++ was a new thing then and the company was totally sold on the idea of objects leading to tight coupling of data and code, when segments require things like data-oriented programming.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845298/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor845146"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 1:37 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/845146/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; having device drivers interpret command streams sent with write() is even worse.</font><br>
<p>
Why?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845146/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845155"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 9:50 UTC (Fri)
                               by <b>sur5r</b> (subscriber, #61490)
                              [<a href="/Articles/845155/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Because in-band signalling is inherently error-prone as SS5 and 2600 have taught us.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845155/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845156"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 10:12 UTC (Fri)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/845156/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It doesn&#x27;t have to be in-band. <br>
<p>
And moreover, quite often devices already require some kind of structured data for their IO streams.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845156/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845355"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2021 11:16 UTC (Mon)
                               by <b>metan</b> (subscriber, #74107)
                              [<a href="/Articles/845355/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Btw we already have out-of-band signalling on file descriptors, for instance sockets have MSG_ERRQUEUE. Too bad the read() and write() syscalls have no flags we can use to pass something like this in order to read/write serialized configuration instead of data. Maybe it&#x27;s time add read2() and write2() with additional flag argument? :-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845355/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 8, 2021 15:19 UTC (Mon)
                               by <b>abatters</b> (<b>&#x272D; supporter &#x272D;</b>, #6932)
                              [<a href="/Articles/845365/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Maybe it&#x27;s time add read2() and write2() with additional flag argument?</font><br>
<p>
They already exist; see preadv2() and pwritev2().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor845163"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 10:59 UTC (Fri)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/845163/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don&#x27;t think that analogy works at all. It is completely routine for kernel APIs to accept structured data as input, and putting payload data inline with the control data does not make serialization any easier or harder. I say that write()ing formatted packets containing both the control and payload data is significantly *less* error-prone than juggling multiple buffers. If there&#x27;s an &quot;obvious&quot; argument against having drivers interpret command streams sent via write(), I don&#x27;t think this is it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845163/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor845647"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2021 3:16 UTC (Thu)
                               by <b>cozzyd</b> (guest, #110972)
                              [<a href="/Articles/845647/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You could have devices expose multiple files so a separate fd could be used for out of band control. But I&#x27;m not sure it solves more problems than it creates. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845647/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor845165"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 12:26 UTC (Fri)
                               by <b>itsmycpu</b> (guest, #139639)
                              [<a href="/Articles/845165/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Anyone know what roughly the overhead is, for making an asynchronous call with io_uring, in nanoseconds?<br>
a) if you submit many as batch<br>
b) if you submit them one by one.<br>
<p>
Any info based on actual measurements appreciated!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845165/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor845267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 5, 2021 22:47 UTC (Fri)
                               by <b>dougg</b> (guest, #1894)
                              [<a href="/Articles/845267/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Make some nullblk devices and use fio with the io_uring engine where the target device(s) is one or more nullblk devices. Then you can do the measurements yourself. You will be measuring the fio, io_uring, block layer and null_blk overhead with the latter being pretty small unless a lot of data is being moved.<br>
<p>
I do similar measurements with scsi_debug devices in place of nullblk devices.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/845267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor846552"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 18, 2021 7:46 UTC (Thu)
                               by <b>ksandstr</b> (guest, #60862)
                              [<a href="/Articles/846552/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Since io_uring consists of an early Direct3D-like &quot;command buffer&quot; interface, its time overhead is spent in de-/serialization, dispatch, reassembly, and cross-core cache latency as inputs and outputs move back and forth; with some I$ effect on top. Dispatch may be particularly expensive when kernel structures would be allocated and threads spawned to complete syscalls off-core.<br>
<p>
It would seem that for ordinary &quot;control&quot; syscalls io_uring gains mostly from reducing the number of trips through the syscall interface when asynchronous jobs are submitted and their results retrieved in bulk. The downside is that CPUs are rather good at syscalls, and even better at dealing with data already in the cache. So the bar to beating a good old syscall is rather high even post-Meltdown.<br>
<p>
Without even microbenchmarks it&#x27;s hard to say for sure, but it seems that io_uring would be strictly worse for either throughput or latency when not applied to a sufficiently concurrent bulk use case[0]. Furthermore, example cases where io_uring use would be a net gain aren&#x27;t readily apparent, in particular because it necessarily returns data generated in an off-core syscall to the originating core where (say) threads would go on with the rest of their operations first without their data leaving the core at all.<br>
<p>
I&#x27;m rather skeptical of the necessity and utility of io_uring in real-world use cases. So far it looks like something that got its foot in the door and is now expanding in scope to become something like what XCB was for Xorg.<br>
<p>
[0] bulk meaning many small calls, few large ones, or a happy medium of some kind.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/846552/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor865131"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">ioctl() for io_uring</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Aug 4, 2021 6:47 UTC (Wed)
                               by <b>optimistyzy</b> (guest, #152790)
                              [<a href="/Articles/865131/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
When this feature can be supported in which linux kernel version?<br>
And are there any example code in user space to use this nice feature? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/865131/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2021, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
