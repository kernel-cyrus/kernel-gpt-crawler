        <!DOCTYPE html>
        <html lang="en">
        <head><title>A return to restartable sequences [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/664645/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/664241/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/664645/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A return to restartable sequences</h1>
</div>
<div class="ArticleText">
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>November 18, 2015</br>
           </div>
Once upon a time, highly concurrent programming was something that only a
small subset of kernel developers needed to worry about.  As the number of
cores found in a CPU package grows, though, concurrency concerns are moving
out to user space.  The concerns of interest here are not just the
protection of critical sections; user space has had to be able to do that
for many years.  A different level of worry comes to the fore at levels of
concurrency where the overhead of locking becomes a significant performance
issue in its own right.  That's when developers start to think about
lockless algorithms, which bring unique challenges in user space.

<p>
In the kernel, lockless programming tends to be tricky, leading to code
that can be brittle if the data-access rules are not well understood or
observed.  But kernel code has a distinct advantage over user-space code in
this regard: it is able to ensure that critical-section code can run to
completion without being preempted.  As long as the code restricts itself
to per-CPU data structures, running with preemption disabled guarantees
that no other thread will try to access those structures concurrently.
User-space code has no such luxury; it always runs with preemption
enabled.  So any attempt to use per-CPU data structures in a lockless mode
must use a different approach.
<p>
One such approach has been termed "restartable sequences"; the first patch
enabling restartable sequences was <a href="/Articles/650333/">examined
here</a> last July.  A <a href="/Articles/662228/">new patch set</a> was
posted alongside the <a href="/Articles/662946/">kernel-summit session</a>
on restartable sequences in October.  This patch features a different
implementation and API that should address a number of the worries raised
by the first attempt.
<p>
A restartable sequence is a brief segment of code performing some sort of
lockless operation on a per-CPU data structure.  A key rule is that the
visible effects of a restartable sequence must be made by a single
instruction at the very end of the sequence.  Imagine, for example,
the following (simplistic) code removing the head item from a linked list:
<p>
<pre>
    struct list_thingie *item, *new_head;

    item = percpu_thingie_list_head;
    new_head = item-&gt;next;
    percpu_thingie_list_head = new_head;
</pre>
<p>

The final line is the only operation that would be visible to other threads
running on the same CPU.  The operation could be interrupted anytime before
that assignment without any ill effects — assuming the interrupted thread
did not actually try to use <tt>item</tt>, of course.  That final line
could also be implemented as a single instruction.  So this little fragment
of code could meet the rules for a restartable sequence; properly
implemented, it could allow multiple threads to remove items from a shared
list without the need for locking.
<p><blockquote class="ad">
<b><tt>$ sudo subscribe today</tt></b>
<p>
Subscribe today and elevate your LWN privileges. You’ll have
access to all of LWN’s high-quality articles as soon as they’re
published, and help support LWN in the process.  <a href="https://lwn.net/Promo/nst-sudo/claim">Act now</a> and you can start with a free trial subscription.
</blockquote>
<p>
There is one other thing that is needed, though, for a proper restartable
sequence: some code to execute if the sequence happens to be interrupted
partway through.  In most cases (this one included), that code simply needs
to restart the sequence from the beginning.  With that in place, a
restartable sequence can safely run in a lockless mode, but only if it can
either (1)&nbsp;run to completion, or (2)&nbsp;know that it has been
interrupted and jump to the failure code.  That is where the need for
kernel support comes in.
<p>
In the new patch, an application wanting to use restartable sequences needs
to register two addresses with the kernel, using a new system call:
<p>
<pre>
    int restartable_sequences(int flags, unsigned long *counter, void *post_commit);
</pre>
<p>
(<tt>restartable_sequences()</tt> is the name used in the implementation;
the associated <a href="/Articles/664654/">test code</a> calls it
<tt>rseq()</tt>, though).
<p>
The <tt>flags</tt> argument is currently unused.  The <tt>counter</tt>
address is a location where the kernel stores a combination of the current
CPU number and the current "event counter" — the number of times the thread
has been preempted.

The application should initially store NULL in the location
pointed to by <tt>post_commit</tt>; later, when a restartable sequence is
active, the application should store the address of the first instruction
following the commit instruction there.


Note that this call does not actually start a restartable sequence;
instead, it sets up the infrastructure so that such sequences can be run.
<p>
To actually run a restartable sequence, the application thread must
carefully do the following things, in order:
<p>
<ol>
<li> Read the current CPU/event counter value from the <tt>counter</tt>
     address provided 
     to the kernel above; this value must be stored for future use.
<p>
<li> Place the address to jump to should the sequence fail (i.e. if the
     thread is preempted while the sequence is running) where the kernel
     will find it.  The actual
     location for this address is architecture-dependent; the x86_64
     implementation wants it in the CX processor register.
<p>
<li> Load the address of the first post-commit instruction into the
     <tt>post_commit</tt> address provided above.
<p>
<li> Check the <tt>counter</tt> value again and ensure that it matches the
     value stored in the first step.  If the two do not match, preemption
     has already occurred and the code
     should jump directly to the failure address
<p>
<li> Execute the critical section through the final commit instruction.
<p>
<li> Clear the post-commit instruction address stored in step 3.
</ol>
<p>
The kernel's test for whether a restartable sequence is active is simple:
is the current instruction pointer less than the address of the post-commit
instruction stored in step&nbsp;3?  It is thus the storing of that address
that begins the sequence for real; once that happens, the kernel will cause
the thread to jump to its failure address if it is preempted.  The manual
check in step&nbsp;4 is needed, though, in case preemption happened just
before the execution of step&nbsp;3.  Performing the steps in this order
ensures that there are no race conditions around the preemption checking.
<p>
In the previous version of the patch, the entire restartable sequence
almost certainly needed to be written in assembly.
This new interface does not eliminate the need for assembly code, but it
does reduce the amount of that code considerably.  A few instructions
around and including the final commit must still be done in assembly,
though that can probably be hidden in library code for a number of common
use cases.
<p>
The previous version of the patch required the registration of one memory
area that would hold critical-section code.  With this version, instead,
the critical section(s) can appear anywhere.  Library code could
<i>almost</i> use this feature independently of other application code,
with one exception: the two addresses passed to the
<tt>restartable_sequences()</tt> call must be shared by all users.  The
alternative 
would be to make a new <tt>restartable_sequences()</tt> call prior to
beginning each sequence, but that is likely to run fairly strongly counter
to the performance objectives that motivated the use of restartable
sequences in the first place.
<p>
Discussion of this version of the patch set has been muted; perhaps it got
lost in all the other kernel summit activity.  Interest in this feature
clearly goes beyond Google (where the patch originates), though.  One would
thus expect this feature to eventually enter the kernel in some form.  Some
of the implementation concerns from last time around have been addressed;
the impact on the scheduler has been reduced, for example.  Whether it will
take another iteration or two to get the user-space interface right remains
to be seen, though.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Restartable_sequences">Restartable sequences</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/664645/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor664929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2015 4:34 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/664929/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Can we de-register the restartable sequences addresses once they are no longer needed?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/664929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor664978"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2015 14:49 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/664978/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Yes, just set them to zero.  Sorry, the article should have said that.
      
          <div class="CommentReplyButton">
            <form action="/Articles/664978/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor664931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2015 4:57 UTC (Thu)
                               by <b>joey</b> (guest, #328)
                              [<a href="/Articles/664931/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hrm, there seem to be quite a few parallels between this and Software Transactional Memory.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/664931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor664934"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2015 5:07 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/664934/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Indeed. However, transactional memory is designed for a different purpose - to protect against races and so it requires inter-CPU synchronization.<br>
<p>
Restartable sequences are designed to be used with data which is known NOT to be shared with other CPUs and is much faster.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/664934/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor665166"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2015 13:53 UTC (Fri)
                               by <b>tvld</b> (guest, #59052)
                              [<a href="/Articles/665166/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The preparatory work is still concurrent code, because the thread is not guaranteed to run in isolation.  Thus, there is concurrency, and you need to make the compiler aware of this; IOW, you need to use atomics even though you don't neccessarily need memory barriers.  The preparatory work needs to be robust to writes by other threads.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665166/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor664960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">flags</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2015 11:01 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/664960/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>The <code>flags</code> argument is currently unused.</blockquote>
In that case the code should be checking that <code>flags == 0</code> and failing if not.  Otherwise, it could be awkward to define a flag in future, since applications passing it have no idea if it is being honoured or ignored.  I think there have been LWN articles making this point in the past.
<p>
As far as I can see the <a href="https://lkml.org/lkml/2015/10/22/589">patch</a> does completely ignore <code>flags</code>.  It would be better not to have the argument at all rather than take it in a non-forward-compatible way.
      
          <div class="CommentReplyButton">
            <form action="/Articles/664960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor664961"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">flags</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2015 11:03 UTC (Thu)
                               by <b>epa</b> (subscriber, #39769)
                              [<a href="/Articles/664961/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
...moreover, you could end up with applications putting any random junk into the flags argument, which works fine currently, and it would be breaking user space to later give some of these values a meaning.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/664961/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor665037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2015 15:58 UTC (Thu)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/665037/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Great summary.  Clever and simple idea, awful name.  I suggest "preempt detection".  Nothing mandates "restart" of anything.  And "sequence" is way too generic. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor665040"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2015 16:10 UTC (Thu)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/665040/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also preempt_trap <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665040/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor665043"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2015 16:35 UTC (Thu)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/665043/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not clear on the need for steps 1 and 4.  Assuming the trap is armed (with an atomic write) at step 3, and the "real app work"  is done after that (reading and writing key dara structures), I don't think it mattered if I got preempted between step 2 and 3.  I assume the CX (RCX?) register is still valid / doesn't get cleared on a preempt.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665043/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor665062"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 19, 2015 18:27 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/665062/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This code is necessary to _avoid_ atomic instructions, so all the instructions there are just regular unprefixed instructions.<br>
<p>
It's necessary to make sure that another code had not been executed inside of a restartable sequence.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665062/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor665177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 20, 2015 15:53 UTC (Fri)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/665177/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Aligned 64 bit writes are already atomic (no tearing).  Otherwise step 6 would be wildly unsafe.    <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor665932"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2015 4:41 UTC (Fri)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/665932/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I too am somewhat mystified.  Since it's constrained to a single CPU atomic writes should not be a problem as interrupts can only happen between instructions.  The event read and later comparison, which is where most of the complexity comes from, seems to arise because they want to allow single stepping with a debugger.<br>
<p>
But it's not just complex - it's got odd limitations: only one per process, only supported on one CPU.  Registering a global area in TLS managed by a library would mean it's easy for the library to provide an arbitrary number of sequences per thread, with no additional kernel overhead.<br>
<p>
The one CPU restriction is understandable from one point of view - if you allow multiple CPU's atomic writes with their associated cache bouncing is unavoidable.  But since only one CPU is allowed why bother with multiple threads?   It must be a pretty specialised use case.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665932/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor665948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 27, 2015 14:29 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/665948/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think it's for high-speed lockless data structures in a process that's *otherwise* multithreaded (but all access to that data structure is serialized).<br>
<p>
This is a pretty common case, and worth optimizing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor666037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 29, 2015 8:26 UTC (Sun)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/666037/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I still don't get it.  If all access to the data structure is serialised by some other mechanism you don't need this.<br>
<p>
Perhaps someone has an example of where it's used?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/666037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667102"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 9:04 UTC (Tue)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/667102/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <p>Consider a lockless per-CPU stats counter. I've done some operation, and now I want to aggregate the existing stat with mine (e.g. add my dropped items count, or update an average processing time stat). For convenience, I'm going to assume that the aggregation operation is implemented as an inline function already.
<code>
<pre>
void do_something()
{
    int my_stat = 0;

    /* Do something, and update my_stat */

    int cpu = sched_getcpu();
    if (cpu &lt; 0) {
        HANDLE ERRORS;
    }
    int *percpu_stat = all_percpu_stats[cpu];
    int aggregate_stat = aggregate(*percpu_stat, my_stat);
    /* DANGER */
    *percpu_stat = aggregate_stat;
}
</pre>
</code>
<p>Here, I expect all_percpu_stats to be an array of pointers to per-CPU variables, set up so that in the cache coherency protocol, each CPU has exclusive write access to a single percpu_stat, and all other CPUs only read it.
<p>There's a problem with this code - if I'm pre-empted just before /* DANGER */, and the pre-emptor updates my percpu_stat, I'll overwrite their update. The functions provided enable me to rewrite the problem stretch as a moral equivalent of:
<code>
<pre>
bool preempted = true;
while(preempted)
{
    int cpu = sched_getcpu();
    if (cpu &lt; 0) {
        HANDLE ERRORS;
    }
    int *percpu_stat = all_percpu_stats[cpu];
    int aggregate_stat = aggregate(*percpu_stat, my_stat);
    /* DANGER */
    atomic_preemption_check(&amp;preempted,  *percpu_stat = aggregate_stat);
}
</pre>
</code>
<p>In this case, the sequence starts at the "while(preempted)", and is completed by atomically updating *percpu_stat, or retrying if I've been pre-empted. That way, if another thread is scheduled on my core, and could have updated percpu_stat, I get tot notice and redo the update with the new value. There's still a risk of failing to make progress if I'm pre-empted at DANGER every time I go round the loop, but we expect the loop to be small (code-wise), and thus this is a rare case.
      
          <div class="CommentReplyButton">
            <form action="/Articles/667102/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667106"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 11:46 UTC (Tue)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/667106/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Excellent reply, demonstrating "a thousand words" doesn't just apply to pictures.<br>
<p>
However amd64's "lock cmpxchg8b" isn't privileged is it?  And ditto arm's streq.  Why not just use them?  They are the two most common CPU's on the planet, but if you aren't using a CPU that provides an an unprivileged compare and swap, then substitute your kernel call to do the same thing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667106/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667110"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 12:14 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/667110/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Atomic instructions are expensive as they require inter-processor communication. In case of cache hit and everything, a simple cmpxchg8b takes around 300 cycles on a typical CPU and they can't really be pipelinized.<br>
<p>
Compare that to a simple mov instruction that requires no locking or cross-CPU communication.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667110/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667172"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 18:37 UTC (Tue)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/667172/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But doesn't this restart on preempt require system calls to control it? And a system call is not exactly cheap. I bet a single system call hits more than 300 cycles, easily.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667172/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667173"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 18:43 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/667173/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Restart happens if a thread is pre-empted by the system. But checking for that is basically free, the kernel takes care to notify the client thread.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667173/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667176"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 18:48 UTC (Tue)
                               by <b>zlynx</b> (guest, #2285)
                              [<a href="/Articles/667176/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Don't you have to keep calling the system call to reset the watched instruction pointer? I mean, unless you somehow manage to put all your restart code at the very beginning of your address space, some parts of your program are going to be at addresses less than the check address.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667176/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor667179"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 8, 2015 19:02 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/667179/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You don't have to do it for every restartable block. It can be done once per thread in the thread setup code (along with thread local storage setup) and torn down in the thread termination handler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/667179/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor667320"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Dec 9, 2015 17:36 UTC (Wed)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/667320/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>That's why steps 3 and 6 in the instruction list in the article matter. Step 3 is a straight <code>MOV [post_commit_location], end_address</code> that tells the kernel that you're entering a restartable sequence, and ensures that if the kernel pre-empts you, it'll update <code>counter</code> to tell you that you've been pre-empted. Step 6 is also a straight <code>MOV [post_commit_location], 0</code>, and ensures that the kernel knows you're done, and there's no longer any reason to watch your instruction pointer. Note that neither of these are syscalls - you do the syscall <em>once</em> to set up <code>post_commit</code> and <code>counter</code> addresses.
<p>Kernel-side, the syscall changes what happens on a context switch away from your thread. If you've called the syscall, the kernel does the moral equivalent (real code is more complex, as it only increments <code>counter</code> if another thread from the same process has run, and the real value of <code>counter</code> also includes the CPU number you're currently running on, so that you see pre-emption if you migrate from one CPU to another) of :
<p><pre><code>
if (suspended_thread_instruction_pointer &lt; <code>post_commit</code>)
{
    suspended_thread_instruction_pointer = restart_location; /* (CX on x86) */
}
++counter;
</code></pre>
<p>The idea is that these are all operations happening on one CPU, so there's no cache coherency overhead (as there would be with <code>LOCK CMPXCHG8B</code>, for example), nor is the kernel involved when there's no context switching happening. Thus, I restart every time there's a context switch (where I pay the kernel entry penalty anyway), but not when there's no context switch; this is the primitive I need to maintain something efficiently per-CPU where the final users of the thing I maintain simply aggregate the per-CPU values into a global value.
      
          <div class="CommentReplyButton">
            <form action="/Articles/667320/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor665718"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 24, 2015 18:57 UTC (Tue)
                               by <b>zev</b> (subscriber, #88455)
                              [<a href="/Articles/665718/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Why is <code>post_commit</code> a <code>void *</code> here?  Am I misunderstanding something or would it make more sense as a <code>void **</code>?
      
          <div class="CommentReplyButton">
            <form action="/Articles/665718/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor665887"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 26, 2015 18:05 UTC (Thu)
                               by <b>winden</b> (subscriber, #60389)
                              [<a href="/Articles/665887/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Something very similar, if not the same thing, was implemented for NetBSD in 2003:<br>
<p>
<a href="https://www.usenix.org/legacy/events/usenix2003/tech/freenix03/full_papers/mcgarry/mcgarry_html/">https://www.usenix.org/legacy/events/usenix2003/tech/free...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/665887/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor666047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 29, 2015 19:43 UTC (Sun)
                               by <b>kjp</b> (guest, #39639)
                              [<a href="/Articles/666047/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's a much simpler and accurately named API.  Kernel keeps a list of (addr,len) ranges and actually restarts them from the beginning after preempt.   Not sure how the Linux one is "progress".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/666047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor666094"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A return to restartable sequences</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 30, 2015 16:25 UTC (Mon)
                               by <b>bronson</b> (subscriber, #4806)
                              [<a href="/Articles/666094/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
gah, if that's true then this is starting to feel like a repeat of epoll/kqueue.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/666094/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2015, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
