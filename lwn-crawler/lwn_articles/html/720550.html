        <!DOCTYPE html>
        <html lang="en">
        <head><title>A formal kernel memory-ordering model (part 2) [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/720550/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/720527/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/720550/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A formal kernel memory-ordering model (part 2)</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="GAByline">
           <p>April 20, 2017</p>
           <p>By Jade Alglave, Luc Maranget, Paul E. McKenney, Andrea Parri, and Alan Stern</p>
           </div>
This article continues the description of the Linux-kernel memory
model that started
<a href="/Articles/718628/">here</a> as follows,
with the intended audience for each section in parentheses:

<ol class="spacylist">
<li>	<a href="#Memory Models and The Role of Cycles">
	Memory models and the role of cycles</a>
	(people interested in using memory-ordering tools).
<li>	<a href="#Specifying a Memory Model in Terms of Prohibited Cycles">
	Specifying a memory model in terms of prohibited cycles</a>
	(people interested in understanding the memory model).
<li>	<a href="#Conclusions">Conclusions</a>
	(all).
</ol>

<p>
This is followed by the inescapable
<a href="#Answers to Quick Quizzes">answers to the quick quizzes</a>.

<h3><a name="Memory Models and The Role of Cycles"></a>
Memory models and the role of cycles</h3>

<p>
One way of formalizing a memory model is to create an abstract description
of how a running system operates internally,
and then enumerate all the possible outcomes
this abstract operation can give rise to.
There are <a href="/Articles/470681/">tools that take this
operational approach</a>.
Another way is to define the constraints imposed by the memory model,
in the form of logical axioms,
and then enumerate all the possible outcomes that are
consistent with these constraints.
A tool using this axiomatic approach (called "herd") is described
<a href="/Articles/608550/">here</a>.
This tool can be <a href="http://diy.inria.fr/sources/index.html">downloaded</a>
and built as described in the <tt>INSTALL.md</tt> file.

<p>
Both approaches take as input a small fragment of code and an assertion
(together called a <i>litmus test</i>)
and produce an output value indicating whether
the memory model permits the
code fragment to execute in a way that would make the assertion true.
Here is a simple example of a litmus test (with line numbers added)
that illustrates the so-called &ldquo;message-passing&rdquo; pattern:

<blockquote>
<a id="litmus1" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-MP+o-mb-o+o-mb-o.litmus">Litmus&nbsp;Test&nbsp;#1</a>
<pre>
  1 C C-MP+o-mb-o+o-mb-o
  2
  3 {
  4 }
  5
  6 P0(int *x, int *y)
  7 {
  8   WRITE_ONCE(*y, 1);
  9   smp_mb();
 10   WRITE_ONCE(*x, 1);
 11 }
 12
 13 P1(int *x, int *y)
 14 {
 15   int r1;
 16   int r2;
 17
 18   r1 = READ_ONCE(*x);
 19   smp_mb();
 20   r2 = READ_ONCE(*y);
 21 }
 22
 23 exists
 24 (1:r1=1 /\ 1:r2=0)
</pre>
</blockquote>

<p>
Line&nbsp;1 identifies the source language of the code fragment
(&ldquo;C&rdquo;)
and gives the litmus test's name (&ldquo;C-MP+o-mb-o+o-mb-o&rdquo;).
<!-- and people say I'm bad at naming things...:) -->
Lines&nbsp;3 and&nbsp;4 are where initial values could be provided.
In this program no explicit initialization is needed,
because all variables' initial values default to zero.
Lines&nbsp;6-21 provide the code, in this case, one function for
each of two processors.
You can choose any name you like for these functions as long as it
consists of a &ldquo;P&rdquo; immediately followed by the processor's
number, numbered consecutively starting from zero.
By convention, local variable names begin with &ldquo;<tt>r</tt>&rdquo;
(these variables are treated as though they are stored in CPU registers),
and global variables must be passed in by reference as function
parameters.
The names of these function parameters are significant:
they must match the names of the corresponding global variables.

<p>
Finally, lines&nbsp;23 and&nbsp;24 provide an &ldquo;<tt>exists</tt>&rdquo;
assertion expression to evaluate the final state.
This final state is evaluated after the dust has settled:
both processes have completed and all of their memory references
and memory barriers have propagated to all parts of the system.
The references to the local
variables &ldquo;<tt>r1</tt>&rdquo; and &ldquo;<tt>r2</tt>&rdquo;
in line&nbsp;24 must be prefixed with &ldquo;<tt>1:</tt>&rdquo;
to specify which processor they are local to.
Note that a single &ldquo;<tt>=</tt>&rdquo; in this expression
is an equality operator rather than an assignment
(the assertion expression is written in the litmus-test language
rather than in C).
The &ldquo;<tt>/\</tt>&rdquo; character combination means &ldquo;and&rdquo;;
it is an ASCII representation of the mathematical &ldquo;&#8743;&rdquo; symbol.
Similarly, &ldquo;<tt>\/</tt>&rdquo; stands for &ldquo;or&rdquo;
(the mathematical &ldquo;&#8744;&rdquo; symbol);
this assertion could have been expressed just as well in negated form
by writing:

<blockquote>
<pre>
23 forall
24 (1:r1=0 \/ 1:r2=1)
</pre>
</blockquote>

<p>
The &ldquo;<tt>~</tt>&rdquo; character indicates negation, so
this assertion could also have been written in non-negated form as follows:

<blockquote>
<pre>
23 exists
24 ~(1:r1=0 \/ 1:r2=1)
</pre>
</blockquote>

<p>
The <tt>herd</tt> tool normally only prints variables that appear
in the <tt>exists</tt> (or <tt>forall</tt>) clause.
Additional variables can be printed using <tt>locations</tt>,
which is demonstrated
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/Examples.html#litmus22">here</a>.

<p>
The software tools mentioned above simply tell you whether
the logic expression evaluates to true in 
all, some, or none of the possible executions of the code.
Value judgments are left to the user.

<tt>herd</tt> may be run using the
<tt><a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/linux.def">linux.def</a></tt>
macro file included in the source package,
the <a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-MP+o-mb-o+o-mb-o.litmus">Litmus Test&nbsp;#1</a> source file,
and the
&ldquo;<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/strong-kernel.bell">bell</a>&rdquo; and
&ldquo;<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/strong-kernel.cat">cat</a>&rdquo; files
for the strong kernel memory model described
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html">here</a>.
The command is as follows:

<blockquote>
<pre>
herd7 -macros linux.def -bell strong-kernel.bell -cat strong-kernel.cat \
      C-MP+o-mb-o+o-mb-o.litmus
</pre>
</blockquote>

For people who prefer shorter command lines, the
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/strong.cfg"><tt>strong.cfg</tt></a> configuration file
specifies these settings already, along with several others
related to the style of the plot files <tt>herd</tt> is
capable of producing.
The command using this configuration file is:

<blockquote>
<pre>
herd7 -conf strong.cfg C-MP+o-mb-o+o-mb-o.litmus
</pre>
</blockquote>

The output from either command is:

<blockquote>
Outcome for
<a id="litmus1" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-MP+o-mb-o+o-mb-o.litmus">Litmus&nbsp;Test&nbsp;#1 (strong model)</a>
<pre>
 1 Test C-MP+o-mb-o+o-mb-o Allowed
 2 States 3
 3 1:r1=0; 1:r2=0;
 4 1:r1=0; 1:r2=1;
 5 1:r1=1; 1:r2=1;
 6 No
 7 Witnesses
 8 Positive: 0 Negative: 3
 9 Condition exists (1:r1=1 /\ 1:r2=0)
10 Observation C-MP+o-mb-o+o-mb-o Never 0 3
11 Hash=3240a31645e46554cb09739d726087ad
</pre>
</blockquote>

<p>
This output indicates the three possible outcomes from running this code in
the Linux kernel:

<ol class="spacylist">
<li>	<tt>r1 == 0 &amp;&amp; r2 == 0</tt>.
	This outcome occurs when P1 completes before P0 begins.
<li>	<tt>r1 == 0 &amp;&amp; r2 == 1</tt>.
	This outcome occurs when P1 executes concurrently with P0,
	so that P1's read from <tt>x</tt> executes before P0's
	write to <tt>x</tt>, but P1's read from <tt>y</tt> executes
	after P0's write to <tt>y</tt>.
<li>	<tt>r1 == 1 &amp;&amp; r2 == 1</tt>.
	This outcome occurs when P1 starts after P0 completes.
</ol>

<p>
The outcome <tt>r1 == 1 &amp;&amp; r2 == 0</tt> is not possible,
as indicated by the &ldquo;<tt>Never 0 3</tt>&rdquo;
near the end of the output.
Here, "Never" indicates that the test condition is true; "0&nbsp;3"
reinforces that by saying that the condition was found to be true in zero
possible outcomes and false in three outcomes.
This forbidden outcome would require a cycle of events, each happening
before the next and the last happening before the first:

<ol>
<li>	P0 writes to <tt>x</tt>,
<li>	P1 reads from <tt>x</tt>, 
<li>	P1 reads from <tt>y</tt>, and
<li>	P0 writes to <tt>y</tt>.
</ol>

This cycle is illustrated in the following figure:
<p>
<blockquote>
<img src="https://static.lwn.net/images/2017/mm-model/cycle-new.png" alt="cycle.png" class="photo">
</blockquote>
<p>
Please note that the concept of cycles can be thought of as a
mathematically precise generalization of the
<tt>memory-barriers.txt</tt> concept of memory-barrier pairing.


The labels in the diagram are defined as follows:

<ol class="spacylist">
<li>	<tt>fr</tt> = &ldquo;from-read&rdquo;, linking each read to
	any writes to the same variable that execute too late to affect
	the value returned by that read.
<li>	<tt>po</tt> = &ldquo;program order&rdquo;, linking statements
	within a given process in the order that they appear in the
	instruction stream.
<li>	<tt>rf</tt> = &ldquo;reads from&rdquo;, linking a given write
	to any reads that load the value stored by that write.
</ol>

<p>
The <tt>fr</tt> relation can be somewhat counter-intuitive,
so please look
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/fr.html">here</a>
for additional explanation.
The <tt>herd</tt> tool provides many additional relations,
which are tabulated
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/herd.html#built-in relations">here</a>.

<p>
It is important to note that not all cycles are prohibited.
To see this, consider the following:

<blockquote>
<a id="litmus2" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-MP+o-o+o-o.litmus">Litmus&nbsp;Test&nbsp;#2</a>
<pre>
  1 C C-MP+o-o+o-o
  2
  3 {
  4 }
  5
  6 P0(int *x, int *y)
  7 {
  8   WRITE_ONCE(*y, 1);
  9   WRITE_ONCE(*x, 1);
 10 }
 11
 12 P1(int *x, int *y)
 13 {
 14   int r1;
 15   int r2;
 16
 17   r1 = READ_ONCE(*x);
 18   r2 = READ_ONCE(*y);
 19 }
 20
 21 exists
 22 (1:r1=1 /\ 1:r2=0)
</pre>
</blockquote>

<p>
This is exactly the same as the previous litmus test except that the
<tt>smp_mb()</tt> calls have been removed.
Despite the fact that the outcome
<tt>r1 == 1 &amp;&amp; r2 == 0</tt> exhibits the same cycle as above,
it can in fact occur on weakly ordered systems where, for example,
P0's writes and P1's reads can be reordered by the hardware.
On such systems, the <tt>smp_mb()</tt> statements
are necessary to ensure that the order of execution of the writes and
reads is the same as their order in the source code.
This can be confirmed by running the tool in the same way as before, but
on the new litmus test:

<blockquote>
<pre>
herd7 -conf strong.cfg C-MP+o-o+o-o.litmus
</pre>
</blockquote>

<p>
The output will be as follows:

<blockquote>
Outcome for
<a id="litmus2" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-MP+o-o+o-o.litmus">Litmus&nbsp;Test&nbsp;#2 (strong model)</a>
<pre>
 1 Test C-MP+o-o+o-o Allowed
 2 States 4
 3 1:r1=0; 1:r2=0;
 4 1:r1=0; 1:r2=1;
 5 1:r1=1; 1:r2=0;
 6 1:r1=1; 1:r2=1;
 7 Ok
 8 Witnesses
 9 Positive: 1 Negative: 3
10 Condition exists (1:r1=1 /\ 1:r2=0)
11 Observation C-MP+o-o+o-o Sometimes 1 3
12 Hash=c3bdaae6256fa364ad31fb3c1e07c0f5
</pre>
</blockquote>

<p>
Note that all four possible states are present, and note also the
&ldquo;<tt>Sometimes 1 3</tt>&rdquo; near the end of the output.

<p>
<div class="tlr">
<a name="Quick Quiz 1"></a><b>Quick Quiz 1</b>:
Can't the compiler also reorder these accesses?
<br><a href="#qq1answer">Answer</a>
</div>

On sufficiently weakly ordered systems, the cyclic outcome in
Litmus&nbsp;Test&nbsp;#2
could occur even without instruction reordering,
because the writes might not propagate from P0 to P1 in the
order they were executed.
And even on more strongly ordered systems,
it would be sufficient to reorder either the reads or the writes;
it is not necessary to reorder both.
For example, if P1's accesses were reordered then we could have
the following sequence of events:

<ol class="spacylist">
<li>	P1 reads from <tt>y</tt>,
<li>	P0 writes to <tt>y</tt>,
<li>	P0 writes to <tt>x</tt>, and
<li>	P1 reads from <tt>x</tt>.
</ol>

This sequence says that P1 reads from <tt>y</tt> before reading
from <tt>x</tt>, i.e., the reads are reordered.
If this were to happen, there would no longer be a cycle,
as indicated in the following diagram (the dotted arrow to
the right indicates P1's reordering):

<p>
<blockquote>
<img src="https://static.lwn.net/images/2017/mm-model/cyclenot-new.png" alt="cyclenot.png"
class="photo"></p>
</blockquote>
<p>
This illustrates an important point: cycles in time of
instruction execution are impossible,
because time is linearly ordered (in our universe, even if
<a href="https://en.wikipedia.org/wiki/G%C3%B6del_metric">not
in all solutions to Einstein's field equations</a>).
Part of a memory model's job is to provide the conditions
under which one instruction must execute before another
and to check for any resulting cycles.
On the other hand, if there is no such cycle then it is possible
to find an order of execution for all the instructions which is
compatible with the memory model's ordering requirements
(for example, by doing a topological sort).
If this potential execution order did not violate any
of the memory model's other requirements,
it would demonstrate that the litmus test's assertion could hold.

<p>
Okay, we admit the preceding paragraph is an oversimplification.
Modern CPUs do not execute instructions at precise moments in time;
instead they run instructions through complicated multi-stage pipelines
and engage in multiple issue (running more than one instruction
through the same pipeline stages in parallel).
Furthermore, other ordering requirements come into play along with
time of execution, such as cache coherence (see
<a href="#cache coherence">below</a>).
Nevertheless, the basic idea is valid.

<p>
It is worth pointing out that computer hardware almost always has additional
restrictions beyond what the memory models describe;
CPU designers generally do not implement
all of the behaviors allowed by the instruction set architecture.
The fact that a memory model says a particular litmus test's assertion might
hold does not mean it can actually happen on any given computer.
As a simple example,
the finite write buffers found in real hardware prevent that
hardware from actually doing all the reorderings of writes that memory
models typically allow.
It also goes the other way&mdash;sometimes CPU designers mistakenly
implement a behavior that is prohibited by the instruction set architecture
(otherwise known as a &ldquo;silicon bug&rdquo; or &ldquo;CPU erratum&rdquo;).

<h3><a name="Specifying a Memory Model in Terms of Prohibited Cycles"></a>
Specifying a memory model in terms of prohibited cycles</h3>

<p>
As we have just seen, there is a close relationship between orderings
and the existence of cycles:
If some events are constrained to be ordered in a certain way then
that ordering cannot contain a cycle.
Conversely, if a given relation among various events does not contain any
cycles then it is possible to order those events consistently with the relation.
Thus, if we can precisely specify which instructions must execute before others
in a given piece of Linux kernel code,
we will be well on our way to constructing a formal model
that defines the kernel's execution-ordering guarantees
in terms of cycles among instructions.
Even better, this model can then be used to construct a tool that analyzes
litmus tests for execution-ordering problems.
(And of course, the same technique can be used for describing a memory model's
other ordering requirements.)

<p>
The <tt>herd</tt> tool implements a language, called <tt>cat</tt>,
designed to represent
memory models, which it does by specifying what cycles are prohibited.
This specification is defined in terms of sets and relations involving
memory-access events, barriers, and threads.
(For our purposes, each processor in a litmus test corresponds to
a distinct thread.)
<tt>herd</tt> is discussed in more detail
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/herd.html">here</a>;
in this section we will see how to write some simple memory models
in the
<tt>cat</tt> language.

<p>
But first, what cycles should the Linux kernel memory model prohibit?
Here is a partial list:

<ul class="spacylist">
<li>	Placing a full memory barrier (<tt>smp_mb()</tt>) between
	each pair of memory accesses in each process will prohibit
	all cycles.
	In other words, <tt>smp_mb()</tt> can be said to <i>restore
	sequential consistency</i>,
	that is, to ensure that all processors agree on a global order
	of all memory accesses by all processors.
	The <a href="#Relaxed Memory Order: Toy Specification">next section</a>
	shows example <tt>herd</tt> code that accomplishes this.
<li>	So-called
	<i><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4375.html">out-of-thin-air</a></i>
	computations must be ruled out.
	These are cycles where each CPU writes a value depending on the
	value written by the previous CPU in the cycle,
	and they are handled by the
	<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html#Cat File: Happens-Before">Happens-Before</a>
	section of the model's <a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html#Strong-Model Cat File">cat</a> file.
	The underlying reason why the model does not produce
	out-of-thin-air values is that any <tt>WRITE_ONCE()</tt>
	that depends on a <tt>READ_ONCE()</tt> is ordered after it,
	regardless of the type of dependency.
<li>	All CPUs should agree on the order of accesses to any single
	memory location.
	Making this happen is described
	<a href="#Relaxed Memory Order: Coherence Included">below</a>.
<li>	A chain of release-acquire pairs, where each load-acquire returns
	the value stored by the preceding store-release, should
	never form a cycle.
	The strong model's
	bell and
	cat files prohibit such cycles.
<li>	Cycles violating
	<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/RCUguarantees.html">RCU's guarantees</a>
	must be prohibited.
	This is handled by the RCU-specific portions of the
	<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html#Bell File: RCU Read-Side Critical Sections">bell</a>
	and
	<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/StrongModel.html#Cat File: RCU">cat</a> files.
</ul>

<p>
There are quite a few additional nuances of Linux-kernel use cases
and peculiarities of specific hardware, but this list provides a good
starting point.
The following sections present trivial &ldquo;toy&rdquo; memory
models that prohibit the first two types of cycles.

<h4><a name="Relaxed Memory Order: Toy Specification"></a>
Relaxed memory order: toy specification</h4>

<p>
The following shows a simple <tt>herd</tt> program that represents a
fragment of the Linux kernel memory model involving simple memory accesses
(<tt>READ_ONCE()</tt> and <tt>WRITE_ONCE()</tt>) and strong memory barriers
(<tt>smp_mb()</tt>):

<blockquote>
<a id="toy-RMO.cat" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/toy-RMO.cat">toy-RMO.cat</a>
<pre>
  1 "Toy RMO"
  2
  3 include "cos.cat"
  4
  5 let rfe = rf &amp; ext
  6 let fence = fencerel(F)
  7
  8 let rmo-order = fence | rfe | co | fr
  9 acyclic rmo-order
</pre>
</blockquote>

<p>
Line&nbsp;1 provides a name for the model, and line&nbsp;3 pulls in
some definitions that can be thought of as the <tt>herd</tt> equivalent
to the C-language:

<blockquote>
<pre>
#include &lt;stdio.h&gt;
</pre>
</blockquote>

<p>
However, instead of defining I/O primitives,
&ldquo;<tt>cos.cat</tt>&rdquo;
defines some basic relations, including the <tt>fr</tt>
relation mentioned earlier.

<p>
For
<a href="#litmus2">Litmus&nbsp;Test&nbsp;#2</a>
and
<a href="#litmus1">Litmus&nbsp;Test&nbsp;#1</a>
above (assuming the cyclic execution),
the built-in <tt>rf</tt> (&ldquo;reads-from&rdquo;) relation
contains the following links:

<ul>
<li>	<tt>WRITE_ONCE(*x, 1)</tt> &#10230; <tt>r1 = READ_ONCE(*x)</tt>,
<li>	<tt>INIT(*y, 0)</tt> &#10230; <tt>r2 = READ_ONCE(*y)</tt>.
</ul>

(where <tt>INIT(*y, 0)</tt> is the &ldquo;write&rdquo; that
initializes <tt>y</tt>),
and <tt>fr</tt> (&ldquo;from-read&rdquo;) contains:

<ul>
<li>	<tt>r1 = READ_ONCE(*y)</tt> &#10230; <tt>WRITE_ONCE(*y, 1)</tt>
</ul>

<tt>cos.cat</tt> also defines the <tt>co</tt>
(&ldquo;coherence order&rdquo;) relation,
which links each write to all later writes to the same variable
(just the writes, not the reads).
Initialization counts as a write; it is always the
first write in the coherence order for each variable.
Thus the <tt>co</tt> relation for these litmus tests looks like this:

<ul>
<li>	<tt>INIT(*x, 0)</tt> &#10230; <tt>WRITE_ONCE(*x, 1)</tt>
<li>	<tt>INIT(*y, 0)</tt> &#10230; <tt>WRITE_ONCE(*y, 1)</tt>
</ul>

<p>
Line&nbsp;5 computes <tt>rfe</tt> (&ldquo;reads-from external&rdquo;),
which is a restricted version of
the <tt>rf</tt> relation that covers only write-read
pairs where the write and the read are executed by different threads.
It does this by intersecting (the <tt>&amp;</tt> operator)
the <tt>rf</tt> relation
with the predefined <tt>ext</tt> relation,
which links all pairs of instructions belonging to different threads.
For the two litmus tests above, the <tt>rfe</tt> relation
turns out to be exactly the same as the <tt>rf</tt> relation.

<p>
Line&nbsp;6 uses the standard <tt>fencerel()</tt> function and
<tt>F</tt> event set to define a relation that links any two instructions
separated by a memory barrier.
For
Litmus&nbsp;Test&nbsp;#2,
which contains no instances of
<tt>smp_mb()</tt>, this relation is empty.
For
Litmus&nbsp;Test&nbsp;#1,
it contains the following links:

<ul>
<li>	<tt>WRITE_ONCE(*y, 1)</tt> &#10230; <tt>WRITE_ONCE(*x, 1)</tt>
<li>	<tt>r1 = READ_ONCE(*x)</tt> &#10230; <tt>r2 = READ_ONCE(*y)</tt>
</ul>

<p>
Line&nbsp;8 defines the <tt>rmo-order</tt> relation as the
union (the <tt>|</tt> operator) of the
<tt>fence</tt>, <tt>rfe</tt>, <tt>co</tt>, and <tt>fr</tt> relations.
<tt>rmo-order</tt> includes all pairs of instructions for which
this toy model of relaxed memory order (RMO) requires
the first to execute before the second.
Line&nbsp;9 expresses this requirement by stating that
the <tt>rmo-order</tt> relation is acyclic (contains no cycles).

<p>
For
Litmus&nbsp;Test&nbsp;#2,
<tt>rmo-order</tt>
does not contain a cycle, as shown below:

<p>
<blockquote>
<img src="https://static.lwn.net/images/2017/mm-model/rmo-acyclic.png" alt="rmo-acyclic.png"
class="photo">
</blockquote>

(The dotted &ldquo;po&rdquo; edges are for illustration only;
they are not present in the <tt>rmo-order</tt> relation and do
not contribute to any cycles.)

<p>
On the other hand, for
Litmus&nbsp;Test&nbsp;#1,
the additional links
added by the <tt>fence</tt> relation do create a cycle:

<p>
<blockquote>
<img src="https://static.lwn.net/images/2017/mm-model/rmo-cyclic.png" alt="rmo-cyclic.png"
class="photo"">
</blockquote>

<p>
Thus this model correctly distinguishes the &ldquo;message-passing&rdquo;
examples with and without memory barriers, as can be seen by downloading
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/toy-RMO.cat">toy-RMO.cat</a> and passing it via the
<tt>-cat</tt> command-line argument for
Litmus&nbsp;Test&nbsp;#2
as follows:

<blockquote>
<pre>
herd7 -conf strong.cfg -cat toy-RMO.cat C-MP+o-o+o-o.litmus
</pre>
</blockquote>

<p>
This produces the following output:

<blockquote>
Outcome for <a id="litmus2" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-MP+o-o+o-o.litmus">Litmus&nbsp;Test&nbsp;#2 (toy-RMO model)</a>
<pre>
 1 Test C-MP+o-o+o-o Allowed
 2 States 4
 3 1:r1=0; 1:r2=0;
 4 1:r1=0; 1:r2=1;
 5 1:r1=1; 1:r2=0;
 6 1:r1=1; 1:r2=1;
 7 Ok
 8 Witnesses
 9 Positive: 1 Negative: 3
10 Condition exists (1:r1=1 /\ 1:r2=0)
11 Observation C-MP+o-o+o-o Sometimes 1 3
12 Hash=c3bdaae6256fa364ad31fb3c1e07c0f5
</pre>
</blockquote>

Given the lack of a cycle in the <tt>rmo-order</tt> relationship,
the counter-intuitive cyclic execution is permitted,
as indicated by
&ldquo;<tt>Sometimes 1 3</tt>&rdquo; in the output.
In contrast, for
Litmus&nbsp;Test&nbsp;#1,
with memory barriers,
the command line:

<blockquote>
<pre>
herd7 -conf strong.cfg -cat toy-RMO.cat C-MP+o-mb-o+o-mb-o.litmus
</pre>
</blockquote>

produces the following output:

<blockquote>
Outcome for <a id="litmus1" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-MP+o-mb-o+o-mb-o.litmus">Litmus&nbsp;Test&nbsp;#1 (toy-RMO model)</a>
<pre>
 1 Test C-MP+o-mb-o+o-mb-o Allowed
 2 States 3
 3 1:r1=0; 1:r2=0;
 4 1:r1=0; 1:r2=1;
 5 1:r1=1; 1:r2=1;
 6 No
 7 Witnesses
 8 Positive: 0 Negative: 3
 9 Condition exists (1:r1=1 /\ 1:r2=0)
10 Observation C-MP+o-mb-o+o-mb-o Never 0 3
11 Hash=3240a31645e46554cb09739d726087ad
</pre>
</blockquote>

As expected, the memory barriers exclude the counter-intuitive outcome
where <tt>r1 == 1 &amp;&amp; r2 == 0</tt>.

<h4><a name="Relaxed Memory Order: Coherence Included"></a>
Relaxed memory order: coherence included</h4>

<p>
Consider this ridiculous single-thread litmus test:

<blockquote>
<a id="litmus3" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-CO+o-o.litmus">Litmus&nbsp;Test&nbsp;#3</a>
<pre>
  1 C C-CO+o-o.litmus
  2
  3 {
  4 }
  5
  6 P0(int *x)
  7 {
  8   *x = 3;
  9   *x = 4;
 10 }
 11
 12 exists
 13 (x=3)
</pre>
</blockquote>

<p>
On the face of it, this test can never succeed.
If we set <tt>x</tt> to 3 and then overwrite it with the value 4,
how can <tt>x</tt> possibly end up containing 3?
Nevertheless, running the
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/toy-RMO.cat">Toy RMO</a>
model shows that this outcome is permitted:

<blockquote>
Outcome for <a id="litmus3" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-CO+o-o.litmus">Litmus&nbsp;Test&nbsp;#3 (toy-RMO model)</a>
<pre>
 1 Test C-CO+o-o Allowed
 2 States 2
 3 x=3;
 4 x=4;
 5 Ok
 6 Witnesses
 7 Positive: 1 Negative: 1
 8 Condition exists (x=3)
 9 Observation C-CO+o-o Sometimes 1 1
10 Hash=b9e4f0d747854e10ad7310b4381f3652
</pre>
</blockquote>

<p>
This is because the model does not forbid it,
and everything that is not explicitly forbidden is permitted.
The model does not account for cache coherence,
a feature supported by most modern microprocessors&mdash;and demanded
by the vast majority of sane kernel hackers.
That's one reason why this model should be considered to be a toy.

<p>
<a name="cache coherence"></a><i>Cache coherence</i> (sometimes referred to as
&ldquo;per-location sequential consistency&rdquo;)
requires that the writes to any one
location in memory occur in a single total order (the coherence order),
which all the processors must agree on.
It also says that within each thread, the coherence order must be consistent
with the program order, as described by the following four
<a name="coherence rules"></a>coherence rules:

<ul class="spacylist">
<li>	<i>Write-write coherence:</i>
	If two writes in the same thread access the same location,
	the write that comes first in program order must come first
	in the coherence order for that location.
<li>	<i>Write-read coherence:</i>
	If a write W precedes (in program order) a read R of the same
	location, then R must read from W or from a write that occurs after
	W in the location's coherence order.
<li>	<i>Read-write coherence:</i>
	If a read R precedes (in program order) a write W of the same
	location, then R must read from a write that occurs before W
	in the location's coherence order.
<li>	<i>Read-read coherence:</i>
	If two reads R and R' in the same thread access the same location,
	where R comes before R' in program order,
	either they must read from the same write or else
	the write read by R must occur before
	the write read by R' in the location's coherence order.
</ul>

<p>
In
Litmus&nbsp;Test&nbsp;#3
above, there are three writes to the location where
<tt>x</tt> is stored: the initializing write of 0 (implicit in lines&nbsp;3-4),
and the writes of 3 and 4 (lines&nbsp;8-9).
The initializing write always comes first in the coherence order,
and the value tested in the &ldquo;exists&rdquo; clause is always
the value stored by the write that comes last in the coherence order
(called the <i>final write</i>).
Thus for the test to succeed, the coherence order for <tt>x</tt>
would have to be: <tt>x=0</tt>, <tt>x=4</tt>, <tt>x=3</tt>.
But this would violate the write-write coherence rule,
because the write that sets <tt>x</tt> to 3 comes before (in program order)
the write that sets it to 4.

<p>
(Note: The C11 standard recognizes the notion of <i>sequenced-before</i>
rather than that of program order.
For the most part the two are the same, referring to the order in which
loads and stores occur in the source code,
but there are a few differences.
For example, the compiler is not required to evaluate the
arguments to a function call in any particular order.
Thus, even though the statement:

<pre>
    printf("%d %d", WRITE_ONCE(x, 3), WRITE_ONCE(x, 4));
</pre>

will always print out &ldquo;3 4&rdquo;, after it executes <tt>x</tt>
may be equal either to 3 or 4.
We will not worry such subtleties for now.
But we will point out that in
Litmus&nbsp;Test&nbsp;#3,
the
&ldquo;<tt>*x = 3</tt>&rdquo; write
<i>is</i> sequenced before the &ldquo;<tt>*x = 4</tt>&rdquo; write,
and the compiler is not permitted to reorder them.
That is why we have omitted the <tt>WRITE_ONCE()</tt> calls and
reverted to plain ordinary assignment.
It's okay in this case, because <tt>x</tt> isn't shared between
processors and we're only trying to make a simple point.
But note that even with this two-line test program,
the compiler is permitted to eliminate the
&ldquo;<tt>*x = 3</tt>&rdquo; write entirely.)

<p>
Our Toy RMO memory model can be strengthened
to take cache coherence into account.
Here is the result:

<blockquote>
<a id="coherent-RMO.cat" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/coherent-RMO.cat">coherent-RMO.cat</a>
<pre>
  1 "Coherent RMO"
  2
  3 include "cos.cat"
  4
  5 let rfe = rf &amp; ext
  6 let fence = fencerel(F)
  7
  8 let rmo-order = fence | rfe | co | fr
  9 acyclic rmo-order
 10
 11 let com = rf | co | fr
 12 let coherence-order = po-loc | com
 13 acyclic coherence-order
</pre>
</blockquote>

<p>
<div class="tlrw">
<a name="Quick Quiz 2"></a><b>Quick Quiz 2</b>:
The <tt>rf</tt>, <tt>co</tt>, and <tt>fr</tt> terms
in the definition of <tt>com</tt> describe write-read,
write-write, and read-write links respectively,
corresponding to three of the four
<a href="#coherence rules">coherence rules</a>.
Why is there no term corresponding to the read-read rule?
<br><a href="#qq2answer">Answer</a>
</div>
Aside from the name change on line&nbsp;1, the only difference is the
addition of lines&nbsp;10-13.
Line&nbsp;11 defines the <tt>com</tt> relation as the union of the
<tt>rf</tt>, <tt>co</tt>, and <tt>fr</tt> relations.
If you imagine inserting reads into the coherence order for a variable,
by placing each read between the write that it reads from
and the following write,
you'll see that in each case <tt>com</tt> links a memory access
to one that comes later in the coherence order.
(<tt>com</tt>'s name arises from the fact that it describes the ways
different processors can <i>com</i>municate by writing to and reading
from shared variables in memory.)
<p>
<tt>po-loc</tt> in line&nbsp;12 is another standard relation;
it is the intersection of <tt>po</tt> and <tt>loc</tt>,
where the <tt>loc</tt> relation links all pairs of memory accesses that
refer to the same location in memory.
Thus, <tt>po-loc</tt> links each memory access to all those that
occur after it in program order and access the same variable.
Lines&nbsp;12-13 go on to define <tt>coherence-order</tt> as the
union of <tt>po-loc</tt> and <tt>com</tt> and to require that
<tt>coherence-order</tt> not have any cycles.

<p>
Since
Litmus&nbsp;Test&nbsp;#3
contains no reads, its <tt>rf</tt> and
<tt>fr</tt> relations are empty and
therefore <tt>com</tt> ends up being the same as <tt>co</tt>.
In the non-intuitive execution accepted by the Toy RMO model
(where <tt>x=3</tt> comes last in the coherence order),
<tt>com</tt> contains the following links:

<ul>
<li>	<tt>INIT(*x, 0)</tt> &#10230; <tt>*x = 3</tt>,
<li>	<tt>INIT(*x, 0)</tt> &#10230; <tt>*x = 4</tt>, and
<li>	<tt>*x = 4</tt> &#10230; <tt>*x = 3</tt>,
</ul>

while <tt>po-loc</tt> contains only:

<ul>
<li>	<tt>*x = 3</tt> &#10230; <tt>*x = 4</tt>.
</ul>

Putting these together yields an obvious cycle in <tt>coherence-order</tt>,
which causes the Coherent RMO model to
forbid the counter-intuitive outcome in
Litmus&nbsp;Test&nbsp;#3:

<blockquote>
Outcome for <a id="litmus3" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-CO+o-o.litmus"> Litmus&nbsp;Test&nbsp;#3 (coherent-RMO model)</a>
<pre>
 1 Test C-CO+o-o Allowed
 2 States 1
 3 x=4;
 4 No
 5 Witnesses
 6 Positive: 0 Negative: 1
 7 Condition exists (x=3)
 8 Observation C-CO+o-o Never 0 1
 9 Hash=b9e4f0d747854e10ad7310b4381f3652
</pre>
</blockquote>

<p>
Here's a slightly more sophisticated test that probes the read-read
coherence rule:

<blockquote>
<a id="litmus4" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-CO+o-o+o-o.litmus">Litmus&nbsp;Test&nbsp;#4</a>
<pre>
  1 C C-CO+o-o+o-o.litmus
  2
  3 {
  4 }
  5
  6 P0(int *x)
  7 {
  8   WRITE_ONCE(*x, 3);
  9   WRITE_ONCE(*x, 4);
 10 }
 11
 12 P1(int *x)
 13 {
 14   int r1;
 15   int r2;
 16
 17   r1 = READ_ONCE(*x);
 18   r2 = READ_ONCE(*x);
 19 }
 20
 21 exists
 22 (1:r1=4 /\ 1:r2=3)
</pre>
</blockquote>

<p>
Because of the write-write coherence rule, we know that the coherence order
for <tt>x</tt> must be: <tt>x=0</tt>, <tt>x=3</tt>, <tt>x=4</tt>.
If <tt>r1</tt> and <tt>r2</tt> were to end up equal to 4 and 3
respectively, it would mean the later read (in program order) had
read from the earlier write (in <tt>x</tt>'s coherence order),
thereby violating read-read coherence.

<p>
To see why the Coherent RMO model forbids this result, consider how the
various relations would turn out.
Because <tt>x=4</tt> must come last in the coherence order for <tt>x</tt>,
the <tt>co</tt> relation contains these links:

<ul>
<li>	<tt>INIT(*x, 0)</tt> &#10230; <tt>WRITE_ONCE(*x, 3)</tt>,
<li>	<tt>INIT(*x, 0)</tt> &#10230; <tt>WRITE_ONCE(*x, 4)</tt>, and
<li>	<tt>WRITE_ONCE(*x, 3)</tt> &#10230; <tt>WRITE_ONCE(*x, 4)</tt>.
</ul>

Since there are some read instructions in this test,
the <tt>rf</tt> and <tt>fr</tt> relations are non-empty.
The links in <tt>rf</tt> are:

<ul>
<li>	<tt>WRITE_ONCE(*x, 4)</tt> &#10230; <tt>r1 = READ_ONCE(*x)</tt> and
<li>	<tt>WRITE_ONCE(*x, 3)</tt> &#10230; <tt>r2 = READ_ONCE(*x)</tt>,
</ul>

while <tt>fr</tt> contains only:

<ul>
<li>	<tt>r2 = READ_ONCE(*x)</tt> &#10230; <tt>WRITE_ONCE(*x, 4)</tt>.
</ul>

Finally, <tt>po-loc</tt> contains:

<ul>
<li>	<tt>WRITE_ONCE(*x, 3)</tt> &#10230; <tt>WRITE_ONCE(*x, 4)</tt> and
<li>	<tt>r1 = READ_ONCE(*x)</tt> &#10230; <tt>r2 = READ_ONCE(*x)</tt>.
</ul>

<p>
Putting these together shows that <tt>coherence-order</tt> contains
the following length-3 cycle:

<ol>
<li>	<tt>r2 = READ_ONCE(*x)</tt>
<li>	<tt>WRITE_ONCE(*x, 4)</tt>
<li>	<tt>r1 = READ_ONCE(*x)</tt>
</ol>

The links in this cycle are <tt>fr</tt> followed by <tt>rf</tt>
followed by <tt>po-loc</tt>, as shown in this figure:

<p>
<blockquote>
<img src="https://static.lwn.net/images/2017/mm-model/read-read-coherence.png" class="photo">
</blockquote>

<p>
As can be seen in the following <tt>herd</tt> output, this cycle
is prohibited:

<blockquote>
Outcome for <a id="litmus4" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-CO+o-o+o-o.litmus">Litmus&nbsp;Test&nbsp;#4 (strong model)</a>
<pre>
 1 Test C-CO+o-o+o-o Allowed
 2 States 6
 3 1:r1=0; 1:r2=0;
 4 1:r1=0; 1:r2=3;
 5 1:r1=0; 1:r2=4;
 6 1:r1=3; 1:r2=3;
 7 1:r1=3; 1:r2=4;
 8 1:r1=4; 1:r2=4;
 9 No
10 Witnesses
11 Positive: 0 Negative: 6
12 Condition exists (1:r1=4 /\ 1:r2=3)
13 Observation C-CO+o-o+o-o Never 0 6
14 Hash=e28b27408fda33a59c7f2cd8a5ff7615
</pre>
</blockquote>

<div class="tlrw">
<a name="Quick Quiz 3"></a><b>Quick Quiz 3</b>:
But don't Itanium and SPARC RMO allow read-read reordering of
acccesses to a single variable by a single CPU?
How does the model handle these CPUs?
<br><a href="#qq3answer">Answer</a>

<p><a name="Quick Quiz 4"></a><b>Quick Quiz 4</b>:
Whatever happened to memory-barrier pairing???
<br><a href="#qq4answer">Answer</a>
</div>

<b>Exercise:</b> Assuming only that the <tt>co</tt> relation gives
a total ordering of all writes to a particular memory location,
prove that any cache-coherent execution of any program
(i.e., an execution that obeys the four coherence rules)
results in a <tt>coherence-order</tt> relation without cycles.
And conversely, prove that if an execution does violate any
of the coherence rules then its <tt>coherence-order</tt> relation
does contain a cycle.

<p>
This background will help you to understand the strong memory model
itself.

<h3><a name="Conclusions"></a>Conclusions</h3>

<p>
We have presented a Linux-kernel memory model that we hope will be useful
for education, concurrent design, and for inclusion in other tooling.
As far as we know, this is the first realistic formal memory model that
includes RCU ordering properties.
In addition, we believe this to be the first realistic formal memory
model of the Linux kernel.

<p>
This model is not set in stone, but subject to change with the evolution
of hardware and of Linux-kernel use cases.
We expect the change rate to be roughly similar to the historical change
rate of <tt>Documentation/memory-barriers.txt</tt>, however,
we believe that the
<a href="/Articles/718628/#Guiding Principles">guiding principles</a>
underlying this memory model will be more durable.

<p>
The
strong model
accepts significant complexity to attain greater strength.
In contrast, the
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/WeakModel.html">weak model</a>
accepts some weakenings in order to achieve some degree of simplicity.
Candidate weakenings include:

<ol class="spacylist">
<li>	Omitting C11 release sequences.
<li>	Simplifying the preserved-program-order relations by
	omitting the <tt>po-loc</tt>, <tt>rd-rdw</tt>, <tt>detour</tt>, and
	<tt>rdw</tt> relations from them.
<li>	Omitting B-cumulativity, which has the effect of allowing
	some cycles as exemplified by
	<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-wmb-is-B-cumulative.litmus">this litmus test</a>.
<li>	Retaining a less-ornate version of the <tt>obs</tt>
	(observation) relation, which is called <tt>short-obs</tt>.
<li>	Retaining a less-ornate version of the <tt>cpord</tt>
	(coherence-point ordering) relation.
	This allows write-only cycles as exemplified by
	<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-2+2W+o-wmb-o+o-wmb-o.litmus">this litmus test</a>.
</ol>

<p>
Although we expect that this memory model will prove quite valuable, it
does have a few limitations in addition to those called out earlier
<a href="/Articles/718628/#Support Existing Non-Buggy Linux-Kernel Code">here</a>
and
<a href="/Articles/718628/#Be Compatible with Hardware Supported by the Linux Kernel">here</a>:

<ol class="spacylist">
<li>	These memory models do not constitute official statements by the
	various CPU vendors on their respective architectures.
	For example, any of these vendors might report bugs at any time
	against any version of this memory model.
	This memory model is therefore not a substitute for a carefully
	designed and vigorously executed validation regime.
	In addition, this memory model is under active development and
	might change at any time.
<li>	It is quite possible that this memory model will disagree with
	CPU architectures or with real hardware.
	For example, the model might well choose to allow behavior that
	all CPUs forbid if forbidding that behavior would render the
	model excessively complex.
	On the other hand, any situation where the model forbids behavior
	that some CPU allows constitutes a bug, either in the model or
	in the CPU.
<li>	This tool is exponential in nature.
	Litmus tests that seem quite small compared to the entire Linux kernel
	might well take geologic time for the <tt>herd</tt> tool to
	analyze.
	That said, this tool can be extremely effective in exhaustively
	analyzing the code at the core of a synchronization primitive.
<li>	The <tt>herd</tt> tool can only detect problems for which you
	have coded an assertion.  This weakness is common to all formal
	methods, and is one reason that we expect testing to continue
	to be important.
	In <a href="https://cs.stanford.edu/~uno/faq.html">the immortal words of Donald Knuth</a>: "Beware of bugs in the
	above code; I have only proved it correct, not tried it."
</ol>

<p>
On the other hand, one advantage of formal memory models is that tools based
on them can detect any problem that might occur, even if the probability
of occurrance is vanishingly small, in fact, even if current hardware
is incapable of making that problem happen.
Use of tools based on this memory model is therefore an excellent way to
future-proof your code.

</p><h3>Acknowledgments</h3>

<p>We owe thanks to H.&nbsp;Peter Anvin, Will Deacon, Andy Glew,
Derek Williams, Leonid Yegoshin, and Peter Zijlstra for their
patient explanations of their respective systems' memory models.
We are indebted to Peter Sewell, Susmit Sarkar, and their groups
for their seminal work formalizing many of these same memory models.
We all owe thanks to Dmitry Vyukov, Boqun Feng, and Peter Zijlstra for
their help making this human-readable.
We are also grateful to Michelle Rankin and Jim Wasko for their support
of this effort.


<h3><a name="Answers to Quick Quizzes"></a>
Answers to quick quizzes</h3>

<a name="qq1answer"></a>
<p><b>Quick Quiz 1</b>:
Can't the compiler also reorder these accesses?


</p><p><b>Answer</b>:
Given the current Linux-kernel definitions of <tt>READ_ONCE()</tt>
and <tt>WRITE_ONCE()</tt>, no.
These two macros map to volatile accesses, which the compiler is not
allowed to reorder with respect to each other.

<p>
However, if these macros instead mapped to non-volatile C11
<tt>memory_order_relaxed</tt> loads and stores, then the compiler
<i>would</i> be permitted to reorder them.
And, as a general rule, compilers are much more aggressive about
reordering accesses than even the most weakly ordered hardware.
In both cases, those who don't like such code rearrangement call it
&ldquo;weak ordering&rdquo; while those who do call it
&ldquo;optimization&rdquo;.


</p><p><a href="#Quick%20Quiz%201"><b>Back to Quick Quiz 1</b>.</a>

<a name="qq2answer"></a>
<p><b>Quick Quiz 2</b>:
The <tt>rf</tt>, <tt>co</tt>, and <tt>fr</tt> terms
in the definition of <tt>com</tt> describe write-read,
write-write, and read-write links respectively,
corresponding to three of the four
<a href="#coherence rules">coherence rules</a>.
Why is there no term corresponding to the read-read rule?


</p><p><b>Answer</b>:
It's not needed.
As we will see in the discussion of
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-CO+o-o+o-o.litmus">Litmus&nbsp;Test&nbsp;#4</a>,
a violation of the read-read coherence rule involves a
write being &ldquo;interposed&rdquo; between two reads
in the coherence order.
It therefore can be described as a length-3 cycle in
<tt>coherence-order</tt>, involving an <tt>fr</tt> link
followed by an <tt>rf</tt> link followed by a <tt>po-loc</tt> link.


</p><p><a href="#Quick%20Quiz%202"><b>Back to Quick Quiz 2</b>.</a>

<a name="qq3answer"></a>
<p><b>Quick Quiz 3</b>:
But don't Itanium and SPARC RMO allow read-read reordering of
acccesses to a single variable by a single CPU?
How does the model handle these CPUs?


</p><p><b>Answer</b>:
In the case of Itanium, <tt>gcc</tt> compiles volatile reads
(as in <tt>READ_ONCE()</tt>) as <tt>ld,acq</tt>,
which enforces read-read ordering.
And the Linux kernel runs SPARC in TSO mode, which prohibits
read-read reorderings in general, including to a single variable.


</p><p><a href="#Quick%20Quiz%203"><b>Back to Quick Quiz 3</b>.</a>

<a name="qq4answer"></a>
<p><b>Quick Quiz 4</b>:
Whatever happened to memory-barrier pairing???


</p><p><b>Answer</b>:
Memory-barrier pairing can be thought of as a special case of cycles,
but it was designed for a simpler time when people used much less
aggressive lockless designs.
Here is an example that breaks memory-barrier pairing:

<blockquote>
<a id="litmus5" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-R+o-wmb-o+o+mb+o.litmus">Litmus&nbsp;Test&nbsp;#5</a>
<pre>
  1 C C-R+o-wmb-o+o+mb+o.litmus
  2
  3 {
  4 }
  5
  6 P0(int *a, int *b)
  7 {
  8   WRITE_ONCE(*a, 1);
  9   smp_wmb();
 10   WRITE_ONCE(*b, 1);
 11 }
 12
 13 P1(int *a, int *b)
 14 {
 15   int r1;
 16
 17   WRITE_ONCE(*b, 2);
 18   smp_mb();
 19   r1 = READ_ONCE(*a);
 20 }
 21
 22 exists
 23 (b=2 /\ 1:r1=0)
</pre>
</blockquote>

<p>
Because the <tt>smp_wmb()</tt> orders writes and because the
<tt>smp_mb()</tt> orders everything, straightforward application of
memory-barrier pairing would lead you to believe that this cycle
would be forbidden.
This belief would be incorrect, as can be seen from running the
litmus test against the strong model:

<blockquote>
Outcome for <a id="litmus5" href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/C-R+o-wmb-o+o+mb+o.litmus">Litmus&nbsp;Test&nbsp;#5 (strong model)</a>
<pre>
 1 Test C-R+o-wmb-o+o+mb+o Allowed
 2 States 4
 3 1:r1=0; b=1;
 4 1:r1=0; b=2;
 5 1:r1=1; b=1;
 6 1:r1=1; b=2;
 7 Ok
 8 Witnesses
 9 Positive: 1 Negative: 3
10 Condition exists (b=2 /\ 1:r1=0)
11 Observation C-R+o-wmb-o+o+mb+o Sometimes 1 3
12 Hash=0a4dd1e17f6132a7145a13b711ccd167
</pre>
</blockquote>

<p>
The problem is that the <tt>co</tt> relationship between <tt>P0()</tt>'s
and <tt>P1()</tt>'s stores does not imply any sort of causal or
temporal relationship between the two stores.
Real hardware can and does chose the coherence ordering after the fact,
and so real hardware can and does allow the cycle.

<p>
In short, memory-barrier pairing was useful in its day, but its day is
rapidly drawing to a close.
More sophisticated use of lockless algorithms requires more sophisticated
mental models of memory barriers.


</p><p><a href="#Quick%20Quiz%204"><b>Back to Quick Quiz 4</b>.</a><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Memory_model">Memory model</a></td></tr>
            <tr><td><a href="/Archives/GuestIndex/">GuestArticles</a></td><td><a href="/Archives/GuestIndex/#McKenney_Paul_E.">McKenney, Paul E.</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/720550/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor721453"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Litmus test #5 and transitivity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 1, 2017 10:11 UTC (Mon)
                               by <b>akiyks</b> (guest, #115362)
                              [<a href="/Articles/721453/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does the result of Litmus test #5 given in the answer to Quick Quiz 4 have<br>
something to do with write barrier's lack of transitivity?<br>
I tried a Litmus test slightly modified from #5 by substituting smp_mb() for<br>
smp_wmb() in P0(). The result shows that the cycle never happens. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/721453/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor721931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Litmus test #5 and transitivity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 5, 2017 15:51 UTC (Fri)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/721931/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Transitivity does not come into play unless there are at least three threads, so does not play any role in this example.<br>
<p>
However, as you say, changing the smp_wmb() to smp_mb() forbids the cycle.  But the reason smp_wmb() is insufficient has nothing to do with transitivity, but is instead because of the test's read-to-write (fr) and write-to-write (co) edges.  Unlike write-to-read (rf) edges, fr and co edges do not imply time ordering, which means that (as a rough rule of thumb) as you add fr and co edges to your litmus test, you must also add strong memory barriers if you want to forbid the cycle.<br>
<p>
For background on this difference between rf edges on the one hand and fr and co edges on the other, please see slides 69-96 of this presentation: <a href="http://www.rdrop.com/users/paulmck/scalability/paper/LinuxMM.2017.01.19a-ext.LCA.pdf">http://www.rdrop.com/users/paulmck/scalability/paper/Linu...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/721931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor721944"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Litmus test #5 and transitivity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 5, 2017 16:58 UTC (Fri)
                               by <b>Alan.Stern</b> (subscriber, #12437)
                              [<a href="/Articles/721944/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It also might help to read through this document:<br>
<p>
<a href="https://www.kernel.org/pub/linux/kernel/people/paulmck/LWNLinuxMM/Examples.html">https://www.kernel.org/pub/linux/kernel/people/paulmck/LW...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/721944/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor722068"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Litmus test #5 and transitivity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 6, 2017 23:11 UTC (Sat)
                               by <b>akiyks</b> (guest, #115362)
                              [<a href="/Articles/722068/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you both for references.<br>
<p>
BTW, I'm wondering what is the convention in naming litmus tests such as<br>
"C-R+o-wmb-o+o+mb+o" (Litmus Test #5).<br>
Can you enlighten me?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/722068/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor722069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Litmus test #5 and transitivity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 7, 2017 0:58 UTC (Sun)
                               by <b>PaulMcKenney</b> (<b>&#x272D; supporter &#x272D;</b>, #9624)
                              [<a href="/Articles/722069/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"C-" says C-language rather than the "LISA" intermediate form used by the tool.<br>
<p>
"R" says the class of litmus test named "R".  A reasonably complete list of litmus-test classes may be found here: <a href="https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test6.pdf">https://www.cl.cam.ac.uk/~pes20/ppc-supplemental/test6.pdf</a> (first page, left-hand column, bottom half).<br>
<p>
"+" precedes the description of each process.<br>
<p>
"-" separates operations within a process.<br>
<p>
"o" is a "ONCE" access.  The type of access is controlled by the litmus test class, in this case "R".  The first process's accesses are therefore both writes, so WRITE_ONCE().  The second process's first access is also a write, and the second access a read, so READ_ONCE().<br>
<p>
"wmb" is a write memory barrier, or smp_wmb().<br>
<p>
"mb" is a full memory barrier, or smp_mb().<br>
<p>
But please note that there is no standard for this sort of naming.  Different groups often use different naming schemes.  In fact, you can see a variety of naming schemes in the litmus-test repository.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/722069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor895247"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Litmus test #5 and transitivity</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 14, 2022 12:26 UTC (Sat)
                               by <b>JamesWu</b> (guest, #158522)
                              [<a href="/Articles/895247/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I get the point co edges do not imply time ordering, but for this specific test #5, if P0&#x27;s write(b) has the cacheline first as described in the slides, because of smp_wmb() in P0, its write(a) should have its cacheline too, all these happen before P1 receives the cacheline response, and before P1&#x27;s smp_mb() and read(a), so that read(a) must return 1 if b==2?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/895247/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
