        <!DOCTYPE html>
        <html lang="en">
        <head><title>The return of SEEK_HOLE [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/440255/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/439623/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/440255/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The return of SEEK_HOLE</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>April 26, 2011</br>
           </div>
Back in 2007, LWN readers learned about the <a
href="/Articles/260795/">SEEK_HOLE and SEEK_DATA</a> options to the
<tt>lseek()</tt> system call.  These options allow an application to map
out the "holes" in a sparsely-allocated file; they were originally
implemented in Solaris for the ZFS filesystem.  At that time, this
extension was rejected for Linux; the Linux filesystem developers thought
they had a better way to solve the problem.  In the end, though, it may
have turned out that the Solaris crew had the better approach.
<p>
Filesystems on POSIX-compliant systems are not required to allocate blocks
for files if those blocks would contain nothing but zeros.  A range within
a file for which blocks have not been allocated is called a "hole."
Applications which read from a hole will get lots of zeros in response;
most of the time, applications will not be aware that the actual underlying
storage has not been allocated.  Files with holes are relatively rare, but
some applications do create "sparse" files which are more efficiently
stored if the holes are left out.
<p>
Most of the time, applications need not care about holes, but there are
exceptions.  Backup utilities can save storage space if they notice and
preserve the holes in files.  Simple utilities like <tt>cp</tt> can also,
if made aware of holes, ensure that those holes are not filled in any
copies made of the relevant files.  Thus, it makes sense for the system to
provide a way for applications which care to learn about where the holes in
a file - if any - may be found.
<p>
The interface created at Sun used the <tt>lseek()</tt> system call, which
is normally used to change the read/write position within a file.  If the
<tt>SEEK_HOLE</tt> option is provided to <tt>lseek()</tt>, the offset will
be moved to the beginning of the first hole which starts after the
specified position.  The <tt>SEEK_DATA</tt> option, instead, moves to the
beginning of the first non-hole region which starts after the given
position.  A "hole," in this case, is defined as a range of zeroes which
need not correspond to blocks which have actually been omitted from the
file, though in practice it almost certainly will.  Filesystems are not
required to know about or report holes; <tt>SEEK_HOLE</tt> is an
optimization, not a means for producing a 100% accurate map of every range
of zeroes in the file.
<p>
When Josef Bacik posted his 2007 <tt>SEEK_HOLE</tt> patch, it was <a
href="http://thread.gmane.org/gmane.linux.file-systems/19622/focus=19624">received</a>
with comments like:
<p>
<div class="BigQuote">
	I stand by my belief that SEEK_HOLE/SEEK_DATA is a lousy interface.
	It abuses the seek operation to become a query operation, it
	requires a total number of system calls proportional to the number
	holes+data and it isn't general enough for other similar uses
	(e.g. total number of contiguous extents, compressed extents,
	offline extents, extents currently shared with other inodes,
	extents embedded in the inode (tails), etc.)
</div>
<p>
So this patch was not merged.  What we got instead was a new
<tt>ioctl()</tt> operation called <tt>FIEMAP</tt>.  There can be no doubt
that <tt>FIEMAP</tt> is a more powerful operation; it allows the precise
mapping of the extents in the file, with knowledge of details like extents
which have been allocated but not written to and those which have been
written to but which do not, yet, have exact block numbers assigned.
Information for multiple extents can be had with a single system call.
With an interface like this, it was figured, there is no need for something
like <tt>SEEK_HOLE</tt>.
<p>
Recently, though, Josef has posted <a href="/Articles/439719/">a new
<tt>SEEK_HOLE</tt> patch</a> with the comment:
<p>
<div class="BigQuote">
	Turns out using fiemap in things like cp cause more problems than
	it solves, so lets try and give userspace an interface that doesn't
	suck.
</div>
<p>
A quick search on the net will turn up a long list of bug reports related
to <tt>FIEMAP</tt>.  Some of them are simply bugs in specific filesystem
implementations, like <a href="/Articles/429345/">the problems related to
delayed allocation</a> that were discovered in February.  Others have to do
with the rather complicated semantics of some of the <tt>FIEMAP</tt>
options and whether, for example, the file in question must be synced to
the disk before the operation can be run.  And others just seem to be
related to the complexity of the system call itself.  The end result has
been a long series of reports of corrupted files - not the sort of thing
filesystem developers want to find in their mailboxes.
<p>
It seems that <tt>FIEMAP</tt> is a power tool with sharp
edges which has been given to applications which just wanted a
butter knife.  For the purpose of simply finding out which parts of a file
need not be copied, a simple interface like <tt>SEEK_HOLE</tt> seems to be
more appropriate.  So, one assumes, this time the interface will likely get
into the kernel.
<p>
That said, it looks like a few tweaks will be needed first.  The API as
posted by Josef does not exactly match what Solaris does; to add an API
which is not compatible with the existing Solaris implementation makes
little sense.  There is also the question of what happens when the
underlying filesystem does not implement the <tt>SEEK_HOLE</tt> and
<tt>SEEK_DATA</tt> options; the current patch returns <tt>EINVAL</tt> in
this situation.  A proposed alternative is to have a VFS-level
implementation which just assumes that the file has no holes; that makes
the API appear to be supported on all filesystems and eliminates one error
case from applications.
<p>
Once these details are worked out - and appropriate man pages written -
<tt>SEEK_HOLE</tt> should be set to be merged this time around.
<tt>FIEMAP</tt> will still exist for applications which need to know more
about how files are laid out on disk; tools which try to optimize readahead
at bootstrap time are one example of such an application.  For everything
else, though, there should be - finally - a simpler alternative.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#FIEMAP_ioctl">FIEMAP ioctl()</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Filesystems">Filesystems</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/440255/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor440414"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2011 7:26 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/440414/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
does this just find the next 0 or non-0 in the file?<br>
<p>
if so, a horrible case where the file is 0101010101 would seem to be miserable (or any file that uses null as a field separator)<br>
<p>
is there any way to tune how _many_ 0's have to be found before it's considered a hole?<br>
<p>
while most media uses 512 byte blocks (and therefor holes can only really be in multiples of 512 bytes aligned on multiples of 512) I think it would be bad to assume that this will always be the case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440414/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2011 8:55 UTC (Thu)
                               by <b>peter-b</b> (subscriber, #66996)
                              [<a href="/Articles/440423/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; does this just find the next 0 or non-0 in the file?</font><br>
<p>
No. Read the fine article. SEEK_HOLE finds the next zone in the file for which storage has not yet been allocated.<br>
<p>
For example, create a 100 MB file (using e.g. mmap()) and write to the first and last 1 KB of it, and close the file.  You will find that many filesystems will not allocate 100 MB of disk space for the file; they will store the data that was written (which might require some padding) and simply note that there is a big chunk of "empty space" in the middle of the file.<br>
<p>
When you read the file again, the filesystem will report the "empty space" as containing 0.  Sometimes, you know that you can safely skip over these unallocated blocks as an optimisation when reading the file (such as in the case of 'cp').  The idea of SEEK_HOLE is to enable this.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440430"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2011 11:09 UTC (Thu)
                               by <b>johill</b> (subscriber, #25196)
                              [<a href="/Articles/440430/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      "No. Read the fine article." Actually, the article says:
<p><i>
A "hole," in this case, is defined as a range of zeroes which need not correspond to blocks which have actually been omitted from the file, though in practice it almost certainly will.</i>
<p>
This comes from the <a href="http://manpages.ubuntu.com/manpages/lucid/man2/lseek.2freebsd.html">Solaris/FreeBSD definition</a>. The actual patch implements what you say though. There's some talk about the minimum hole size as well.
      
          <div class="CommentReplyButton">
            <form action="/Articles/440430/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440432"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2011 11:31 UTC (Thu)
                               by <b>peter-b</b> (subscriber, #66996)
                              [<a href="/Articles/440432/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; A "hole," in this case, is defined as a range of zeroes which need not correspond to blocks which have actually been omitted from the file, though in practice it almost certainly will.</font><br>
<p>
<font class="QuotedText">&gt; This comes from the Solaris/FreeBSD definition. The actual patch implements what you say though. There's some talk about the minimum hole size as well. </font><br>
<p>
Okay, whoops. I kinda concentrated on the details of the actual patch. My bad. Sorry about that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440432/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor440486"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2011 17:32 UTC (Thu)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/440486/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But the article further says: "Filesystems are not required to know about or report holes; SEEK_HOLE is an optimization, not a means for producing a 100% accurate map of every range of zeroes in the file."<br>
<p>
And the man page you linked to says: "A 'hole' is defined as a contiguous range of bytes in a file, all having the value of zero, but not all zeros in a file are guaranteed to be represented as holes returned with SEEK_HOLE."<br>
<p>
So, it would seem that the "10101010" case would be covered by skipping (it's clearly not a hole).  Even if the filesystem were maniacal and reported each 0 as a hole (ie. lying) everything should still work, it just means backup software could be made to do an insane amount of work to faithfully "reproduce" such bogus holes; they could protect against that.  Might be fun to add this behavior to a bogo-filesystem for testing.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440486/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440586"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2011 5:11 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/440586/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
is 1000001 a hole? (note that I am assuming the '0' is a byte of 0, not a bit)<br>
<p>
how many 0's need to be in place before it should be identified as a hole?<br>
<p>
what if the source is on 4192 byte sector media and the destination is on 512 byte sector media and a string of 1M zeros starts at an offset of 1024 into the file? does the hole start at 1K (where the zeros start and space could be saved on the 512 byte sector media), or at 4K where the source may have a hole? what if the source is a raid array where holes can only really be useful if punched in blocks of 64K*#drives?<br>
<p>
I think the process of 'SEEK_HOLE' is better than getting a dump of how the file happens to be allocated at the moment, but it seems like this is too big a question to just overload into a single flag.<br>
<p>
Since software would have to be modified to use it anyway, it seems like it may be better to have a seek_hole() function rather than flag on the existing lseek so that you could tell seek_hole() what you consider a hole.<br>
<p>
I see the following valid definitions of holes as obvious<br>
<p>
1. if it's a hole at the time of the seek<br>
<p>
2. if it could be a hole at the time of the seek (taking into account the filesystem and device holding the file)<br>
<p>
3. #2 with an automatic 'if you could punch a hole here, do so' flag<br>
<p>
4. any string of X sequential bytes of 0 aligned on a multiple of Y bytes <br>
<p>
5. #3 but with the definition that represents the 'sector size' so X == Y and it only needs to be specified once.<br>
<p>
I could see all of these being useful in different situations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440586/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2011 18:32 UTC (Fri)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/440713/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think that's over-complicating it, imo.  Any file which has less bytes stored than the logical length of the file, is "sparse" and necessarily has "holes".  A hole is really only a part of the file which is not literally stored as a literal length of zeros on some filesystem data block.<br>
<p>
The key is that the filesystem has this information *without* having to go searching through data blocks for it.  It can therefore relay the hole locations to userspace efficiently, as opposed to the current userspace heuristic methods which must read() all the data and examine it for (position,length) runs of zeros, which it can then seek() forward over while writing.<br>
<p>
So, with that:<br>
<p>
"is 1000001 a hole?" - No.  I'm quite confident no existing filesystem would store that with a hole in it.  The zero run is too short.  However, a general 100...001 string may, or may not contain a hole, which could potentially (but not necessarily) be reported by lseek(SEEK_HOLE).<br>
<p>
"how many 0's need to be in place before it should be identified as a hole?" - it *should* only be identified as a hole if the zero's are not actually stored in data blocks, and thus the file is "sparse".  We are not asking the filesystem to analyze the content for potential holes, but just to report what holes it currently has, which should be efficient.  In fact, any lseek(SEEK_HOLE) implementation that has to examine data blocks for zero-content should probably be considered broken, imo.<br>
<p>
"what if the source is on 4192 byte sector media and the destination is on 512 byte sector media..." - It doesn't matter.  Nothing says holes are commutative, they are simply a storage optimization and need not be reproduced exactly.  A destination filesystem will automatically convert to the padding and alignment of new holes in its own internal structure if you lseek over zeros (though perhaps not optimally; it depends on how the file is constructed).  On vfat, for example, sparse files are not possible, and *every* zero byte will be stored literally, regardless of the sparsity of the original file.<br>
<p>
"it seems like it may be better to have a seek_hole() function" - the FIEMAP ioctl still exists, although since it is apparently error prone, the lseek(SEEK_HOLE) interface may produce less buggy client code, and still be hugely efficient on sparse file copies.<br>
<p>
"so that you could tell seek_hole() what you consider a hole." - There is no point in telling seek_hole() what you consider a hole, is there?  You can already find and try to reproduce all possible holes in a file, in user-space, by read()ing, and then seek()ing over zeros on copies (I'll have to check what madness 'coreutils' uses for "cp --sparse").  The filesystem *can* efficiently tell us what holes it currently has, though, potentially saving a lot of read()s.<br>
<p>
So currently, the classic way to create holes in sparse files is by lseeking() (mmap() also works); it seems somewhat logical to use lseek() to also detect those holes.  It's not all powerful, but it's reasonably simple.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2011 20:44 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/440733/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
from the article, quote:<br>
<p>
The interface created at Sun used the lseek() system call, which is normally used to change the read/write position within a file. If the SEEK_HOLE option is provided to lseek(), the offset will be moved to the beginning of the first hole which starts after the specified position. The SEEK_DATA option, instead, moves to the beginning of the first non-hole region which starts after the given position. A "hole," in this case, is defined as a range of zeroes which need not correspond to blocks which have actually been omitted from the file, though in practice it almost certainly will. Filesystems are not required to know about or report holes; SEEK_HOLE is an optimization, not a means for producing a 100% accurate map of every range of zeroes in the file.<br>
<p>
<p>
note specifically: A "hole," in this case, is defined as a range of zeroes which need not correspond to blocks which have actually been omitted from the file<br>
<p>
so this seems to be implying that this isn't just reporting what holes currently exist, but holes that could potentially exist, even if they haven't been punched out yet. at that point the question of what should be reported arises.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440778"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2011 21:55 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/440778/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Note also: "Filesystems are not required to know about or report holes; SEEK_HOLE is an optimization, not a means for producing a 100% accurate map of every range of zeroes in the file."<br>
<p>
Ergo, an implementation which only reported filesystem-level blocks of zeros actually omitted from the file would be perfectly valid. The interface is allowed, but not *required*, to report "holes that could potentially exist". In practice I would expect filesystems to only report omissions, as scanning arbitrarily large amounts of stored data for the first non-zero byte would be prohibitively expensive (and can be done just as easily from userspace).<br>
<p>
SEEK_HOLE and SEEK_DATA are meant as optimizations. It makes little sense to save the application the trouble of scanning for ranges of zeros in stored data at the expense of moving the same task into the filesystem. On the other hand, if the filesystem already knows that there is a hole--for example, because it was omitted from the stored data--then SEEK_HOLE and SEEK_DATA allow it to save the application some unnecessary reads.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440778/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440784"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2011 22:19 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/440784/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't see anything saying that SEEK_HOLE must report every actual hole either.<br>
<p>
so an implementation that reported every 0 in the file would be valid<br>
<p>
and an implementation that didn't report any holes in the file would be valid (although useless)<br>
<p>
I'm arguing that it would be better to allow the flexibility to define what a hole is if applications are going to be modified to make use of this feature.<br>
<p>
I'm not sure if the application should define the hole, or if it should be something that's tunable at the system (or device) level. I can definitely see a reluctance to have the app try and figure out what size hole is relevant, but at the same time, the ability to find potential holes without having to push the data all the way to userspace just to find 0's int he file seems like a useful optimisation for a small amount of code. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440784/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2011 23:29 UTC (Fri)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/440786/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Either reporting too many, or too few holes is potentially less efficient, but should be allowed simply because it won't change the content of the file.  So, while the interface allows it, it doesn't claim (imo) that the interface *must* report any and all actual or potential holes.  Doing so would work, but would be a pessimization.<br>
<p>
I assume the wording of the specification has to be "loose" like this to cover cases where the filesystem converts zero data blocks to holes (via block data scrubbing), or a file block of zeros gets rewritten as actual zeros (an optimization like zero-block data deduplication, for example) so that while the logical content of the file has not changed, the "hole" structure is different and the previous lseek(SEEK_HOLE) may no longer be a hole.  This is a lesser constraint than if the content itself is altered, and should still work.<br>
<p>
"so an implementation that reported every 0 in the file would be valid" - Yes, although it should at least adhere to the _PC_MIN_HOLE_SIZE as a lower bound.  If that lower bound can be 1, clients should be prepared for that; in particular, backup software might need to detect and refuse to bother with bookkeeping such small holes, and just read and store the zeros verbatim.<br>
<p>
"the ability to find potential holes without having to push the data all the way to userspace just to find 0's int he file seems like a useful optimisation for a small amount of code."  - A filesystem could choose to "scrub" the data in the background and look for places to add holes, but whether its userspace or kernel, the act of looking for potential holes will involve processing a lot of data blocks, and could be tricky when done on active filesystems.  The copying to userspace is trivial, compared to the block reads (even on non-rotating media).  Whereas, creating the file with holes initially can often be done efficiently, since the writing application may know where the holes belong at the start.  (ie. compare "time dd if=/dev/zero of=/var/tmp/non-sparse-file bs=1M count=1000" vs. "time dd if=/dev/zero of=/var/tmp/sparse-file bs=1M count=1 seek=999")<br>
<p>
That said, I wonder if any of the compressing files system try to aggressively find ways to make files sparser (given that they have to process all the data anyway)?  My guess is that sparseness is not much of a win on those filesystems, so they don't bother.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440795"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2011 23:49 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/440795/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
where is PC_MIN_HOLE_SIZE defined? (is it just hard-coded in the source?)<br>
<p>
I think that I'm saying that PC_MIN_HOLE_SIZE and what alignment it needs to have should be configurable at least on the device (including logical device) level<br>
<p>
if the purpose of this is to allow backups and copies to deal with holes efficiently, it seems like it would be good to be able to tune how aggressively to look for holes (or possible holes, if things are layered, you may not know for sure if the holes are real or not). remember that this is all happening long after the file was created (and after it may have been mangled by other tools that filled in holes because they didn't know any better)<br>
<p>
as for compressed filesystems, since a string of 0's compresses _really_ well, I suspect that none of them look for the special case of a full block of 0's aligned on a block boundry as it probably would take just about as much to record that special case as it takes to record that they are zero anyway ;-)<br>
<p>
if de-duplication logic forces holes to be replaced with a block of 0's (even a shared one), the authors of that code should be fired they are moving in the wrong direction (the block of 0's now takes up space and I/O where it didn't before)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440795/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440893"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2011 19:23 UTC (Sat)
                               by <b>jrn</b> (subscriber, #64214)
                              [<a href="/Articles/440893/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
See "man pathconf".<br>
<p>
Linux doesn't support Solaris's _PC_MIN_HOLE_SIZE currently.  It doesn't seem very useful --- it just lets applications know, any hole will be at least such-and-such size (e.g., 512 bytes).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440893/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor441409"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2011 18:27 UTC (Wed)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/441409/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; if de-duplication logic forces holes to be replaced with a block of 0's (even a shared one), the authors of that code should be fired</font><br>
<p>
It was a pure hypothetical, but for example some systems can convert an online volume to de-duped mode and back, all while serving files from it.  I could see (in such cases of intermediate online filesystem conversions, or other hypothetical situations) that a filesystem could choose to not honor, or incorrectly report the SEEK_HOLE values.  In such cases, the API would allow backups to still work, just less efficiently.  So, my point is that the SEEK_HOLE API is not bound by any particular filesystem constraint.<br>
<p>
<font class="QuotedText">&gt; if the purpose of this is to allow backups and copies to deal with holes efficiently, it seems like it would be good to be able to tune how aggressively to look for holes</font><br>
<p>
You don't want the filesystem to "look" for holes; it just knows them outright, if it supports them, based on what data blocks are actually stored.  The "looking" for all potential holes can already be (and is) done in userspace for any filesystem, at the cost of examining a lot of zeros.  Anyway, that's my view.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/441409/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor441421"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2011 19:01 UTC (Wed)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/441421/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
it just seems conceptually wrong to me that finding holes (or potential holes) should be a two step process.<br>
<p>
step 1 use SEEK_HOLE to find holes the filesystem knows about<br>
<p>
step 2 read the remainder of the file through userspace to look for additional holes (or holes that SEEK_HOLE didn't report.<br>
<p>
examining a range of memory to find if it's exclusively zero seems like the type of thing that is amiable to optimisation based on the particular CPU in use. Since the kernel is already optimised this way it would seem to be better to leverage this rather than require multiple userspace tools to all implement the checking (with the optimisations)<br>
<p>
<p>
<p>
the full details of what extents are used for a file seems like it isn't the right answer, both because it's complex, but also because it's presenting a lot of information that isn't useful (i.e. you don't care if a block of real data is in one block, or fragmented into lots of blocks), but at the same time it seems a bit wasteful to find the holes by doing a separate system call for each hole boundary. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/441421/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor441433"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 4, 2011 19:54 UTC (Wed)
                               by <b>chad.netzer</b> (subscriber, #4257)
                              [<a href="/Articles/441433/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; examining a range of memory to find if it's exclusively zero seems like the type of thing that is amiable to optimisation based on the particular CPU in use.</font><br>
<p>
Perhaps, but it's almost certainly I/O bound, not CPU.<br>
<p>
If you *really* want to aggressively replace long runs of zeros with holes, in existing files (ie. make them sparser), a background userspace scrubber could be employed; although doing it in-place without forcing a copy (new inode) is tricky.  At least some Linux filesystems have, or will have, the ability to "punch holes":<br>
<p>
<a rel="nofollow" href="http://permalink.gmane.org/gmane.comp.file-systems.xfs.general/35840">http://permalink.gmane.org/gmane.comp.file-systems.xfs.ge...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/441433/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor440814"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2011 3:16 UTC (Sat)
                               by <b>jrn</b> (subscriber, #64214)
                              [<a href="/Articles/440814/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; so this seems to be implying that this isn't just reporting what holes currently exist, but holes that could potentially exist</font><br>
<p>
I think you're misreading it.<br>
<p>
This is about reporting holes, but nobody wanted to guarantee that such a thing as a hole exists.  So the semantics are: if SEEK_HOLE reports a hole, the content there consists of NUL bytes. That's it (though naturally enough any sane kernel is only going to report large blocks of NUL bytes, for example by reporting the actual holes, and userspace programs are likely to rely on that assumption for reasonable performance).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440814/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440815"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2011 3:29 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/440815/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
the question is the defintion of 'large blocks'<br>
<p>
what may be a large block for a filesystem running on one device may not be a large block for another device.<br>
<p>
I'm not saying that it makes sense to have it report down to every single null byte in the file, but I do think that there should be some ability to define what 'large block' means outside of editing the source.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440815/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440890"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 30, 2011 19:10 UTC (Sat)
                               by <b>jrn</b> (subscriber, #64214)
                              [<a href="/Articles/440890/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think I'm missing something. I'll repeat what I already said and you can tell me where I go wrong.  The "large blocks" is a consequence of an implementation that doesn't care about the size of blocks.  It just reports holes.<br>
<p>
Perhaps you're talking about the holes feature in general, and saying that users or applications should be able to configure when a seek while writing will create a hole?  Then I would understand a little better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440890/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor440973"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 2, 2011 4:28 UTC (Mon)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/440973/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Really, the guarantee is "the kernel will tell you about those runs of zeros that it can identify more quickly than you could". Note that the kernel can't really detect actual blocks full of zeros and faster than userspace can -- memcmp doesn't magically run faster just because you're in kernel-land. But it can exploit knowledge of internal fs data structures (like holes) that aren't otherwise exposed to userspace.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440973/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor440476"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2011 16:27 UTC (Thu)
                               by <b>Yorick</b> (guest, #19241)
                              [<a href="/Articles/440476/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This shows how difficult it is to get the design of an interface right without writing the application for which it is intended at the same time. I am reminded of it all the time myself, no matter how well I think I know the problem domain or how much I plan ahead.<br>
<p>
The kernel policy of not allowing experimental syscalls but demanding indefinite support even for failed attempts once they are in a released kernel may have made it harder to co-develop application and interface. Maybe a policy demanding credible proof-of-concept user-space code accompanying any new syscall would do? (And, as has been suggested before, a man page.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440476/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor440510"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Querying file information and concurrent file access</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 28, 2011 19:02 UTC (Thu)
                               by <b>abacus</b> (guest, #49001)
                              [<a href="/Articles/440510/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are there any provisions in the FIEMAP ioctl() or SEEK_HOLE/SEEK_DATA operations to prevent concurrent write / append / unmap operations ? Does it make sense to allow a user-space process to query such information without first locking a file to prevent concurrent modifications ?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440510/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor440629"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Querying file information and concurrent file access</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2011 13:09 UTC (Fri)
                               by <b>CChittleborough</b> (subscriber, #60775)
                              [<a href="/Articles/440629/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The FIEMAP facility has a FIEMAP_FLAG_SYNC option: "If this flag is set, the kernel will sync the file before mapping extents" (quoting from Documentation/filesystems/fiemap.txt). But that does not lock anything ...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/440629/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor440677"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Querying file information and concurrent file access</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Apr 29, 2011 16:01 UTC (Fri)
                               by <b>dark</b> (guest, #8483)
                              [<a href="/Articles/440677/">Link</a>] 
      </p>
      
      </div>
      </summary>
      I think it makes sense. It's not really different from a read() that might return data that's already obsolete because another process is writing there. This can be fixed with locks or other techniques (such as tar's habit of displaying a warning if the file changed), and it's up to you to use them if you want to.

      
          <div class="CommentReplyButton">
            <form action="/Articles/440677/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor441123"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 3, 2011 11:05 UTC (Tue)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/441123/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just hopes that this interface will be able to report holes at end of file, I had strange stuff with FIBMAP in that case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/441123/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor441979"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 8, 2011 14:58 UTC (Sun)
                               by <b>guest</b> (guest, #2027)
                              [<a href="/Articles/441979/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just drop support for holy (sic) files!<br>
<p>
The small benefit they give doesn't justify the problems they produce.<br>
<p>
Has anyone actually measured how many holey files are in a typical fs and how big the holes are?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/441979/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor441996"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 9, 2011 1:11 UTC (Mon)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/441996/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, there's at least one use for them: some machines I've used have had a terrabyte-long /var/log/lastlog file, due to uid -1 being inserted in it, or something like that. It would've been a shame if that actually took a terrabyte of disk space (although that's actually feasible now!). :) <br>
<p>
Of course, on the problems side, this caused havoc with RPM, since under some conditions I don't really understand, it would try to read and checksum the entire file, every time you tried to install a package. But hey, just need to teach RPM about SEEK_HOLE, and it'll be all great!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/441996/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor442437"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted May 11, 2011 21:34 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/442437/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Other major holey files include quotas, coredumps, and some sorts of disk image (including, the biggie, virtual machine disk images). Of course there are virtual machine disk image formats that do *not* require holes, but either they allocate a lot of space right off or they basically have to reimplement holes at a higher level...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/442437/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor466977"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The return of SEEK_HOLE</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Nov 11, 2011 14:54 UTC (Fri)
                               by <b>johnflux</b> (guest, #58833)
                              [<a href="/Articles/466977/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Torrents use them a lot.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/466977/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2011, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
