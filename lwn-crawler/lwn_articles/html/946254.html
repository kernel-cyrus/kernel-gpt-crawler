        <!DOCTYPE html>
        <html lang="en">
        <head><title>The challenge of compiling for verified architectures [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/946254/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/946627/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/946254/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The challenge of compiling for verified architectures</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>October 6, 2023</br>
           <hr>
<a href="/Archives/ConferenceByYear/#2023-GNU_Tools_Cauldron">Cauldron</a>
</div>
On its surface, the BPF virtual machine resembles many other computer
architectures; it has registers and instructions to perform the usual
operations.  But there is a key difference: BPF programs must pass the
kernel's verifier before they can be run.  The verifier imposes a long list
of additional restrictions so that it can prove to itself that any given
program is safe to run; getting past those checks can be a source of
frustration for BPF developers.  At the <a
href="https://gcc.gnu.org/wiki/cauldron2023">2023 GNU Tools Cauldron</a>,
José Marchesi looked at the problem of compiling for verified architectures
and how the compiler can generate code that will pass verification.
<p>
Marchesi, who has been working on a BPF backend for GCC, started by saying
that the problem is inherently unsolvable.  The BPF verifier is trying to
do something that, in the theoretical sense, cannot be done; to make the
problem tractable it imposes a number of restrictions on BPF programs, with
the result that many correct programs still fail to pass verification.  The
verifier is a moving target as it evolves with each kernel release, and it
is not the only verifier out there (the <a href="/Articles/857215/">Windows
BPF implementation</a> has its own verifier that imposes a different set of
restrictions).  It is a challenging task but, perhaps, something can be
done in practice to at least improve the situation.
<p>
<a href="/Articles/946255/"><img
src="https://static.lwn.net/images/conf/2023/gtc/JoseMarchesi-sm.png" alt="[José Marchesi]"
title="José Marchesi" class="rthumb"></a>

The "world domination plan" for BPF support in GCC has several stages,
Marchesi said.  The initial goal was to achieve parity with LLVM, which is
still used for all BPF programs currently.  The LLVM BPF backend, he noted,
was created by the same developers who were working on the BPF virtual
machine, at the same time; each side could be changed to accommodate the
other.  The GCC developers, instead, have to deal with the virtual machine
as it exists.  So that task took a few years, but it has been largely
achieved.
<p>
The next step is to be able to compile and
run all of the kernel's BPF tests; that is what is being worked on now.
Compiling the tests is mostly done, but running them is trickier for the
reasons described above: although the programs are known to be correct, the
code generated by GCC runs afoul of the verifier.  Once that problem has
been overcome, Marchesi said, the next object will be to compile and run
all existing BPF programs.
<p>
A verified target like the BPF virtual machine is not the same as a
sandbox, he said.  A sandbox involves putting a jail around code to block
any attempted bad behavior.  The verifier, instead, proves to itself that a
program is not harmful, then runs it in a privileged environment.  That
verification imposes a number of "peculiarities" that a compiler must cope
with.  For example, BPF programs have disjoint stacks, where each frame is
stored separately from the others.  But the real problem is generating
verifiable code.  As an example here, he noted that the verifier will
complain about backward jumps in BPF code; developers can work to avoid
them, but optimizing compilers can do interesting things, and it's not
always clear where a backward jump might have been introduced.  There are
many other ways to fail verification, and the list changes from one kernel
release to the next.
<p>
Verification problems, he said, come in two broad categories.  One is that
certain types of source constructs are simply not verifiable; these include
computed gotos and loops without known bounds.  The other is
transformations from optimization; a developer can avoid problematic
constructs and generally write with verification in mind, but an optimizing
compiler can mangle the code and introduce problems.  To be useful, a
compiler for the BPF target must take extra pains to produce
verification-friendly code — not a simple objective.

<p>
<h4>Paths toward a solution</h4>
<p>
Marchesi then presented a long list of approaches that could be taken to
this problem, starting with "approach zero": "do nothing".  That, he said,
is the current strategy with the GCC work.  It is good enough to be able to
compile the DTrace BPF support routines, but far from sufficient in the
general case.  About 90% of the BPF self-tests, he said, do not currently
get past the verifier when compiled with GCC.  So this approach clearly is
not good enough even for existing programs, much less those that might
appear in the future.
<p>
Approach one is to disable optimizations entirely.  This comes at a cost to
both performance and program size; size is important, he said, because of
the size limit imposed by the verifier.  Another problem, it seems, is that
some programs simply will not work without <tt>-O2</tt> optimization; they
rely on the constant folding and propagation that the optimizer provides.
So this does not appear to be a viable option for a real-world compiler.
<p>
Approach two is to disable optimizations more selectively, finding the ones
that result in unverifiable code and disabling them.  This is a task that
would have to be handled automatically, he said.  It could be addressed by
formalizing the constraints imposed by the verifier, then testing the code
produced after each optimization pass to ensure that the constraints are
satisfied.  If a problem is introduced, the changes from that pass could be
discarded.  Some passes, though, can introduce a lot of different
optimizations; throwing them out would lose the good changes along with the
bad one.  Some problems, he said, are also caused by combinations of
passes.
<p>
A different way, approach three, would be "antipasses" that would
explicitly undo code transformations that create problems.  This is the
current approach used by LLVM; it has the advantage of only undoing
problematic changes, with no effect on the rest of the compilation process.
But antipasses are fragile and easily broken by changes elsewhere in the
compiler; that leads to "maintenance hell".  There was, he said,
frustration expressed at this year's <a
href="/Articles/lsfmmbpf2023/">LSFMM+BPF Summit</a> by developers who find
that they can only successfully build their programs with specific LLVM
versions.  As a result, the LLVM developers are adding new features, but
users are sticking with older releases that actually work and are not
benefiting from those features.
<p>
Approach four would be target-driven pass tailoring, or the disabling of
specific transformations by hooking directly into the optimization passes.
LLVM is trying to move in this direction, he said, but other compiler
developers are resisting that approach.  It leads to entirely legal (from
the language sense) transformations becoming illegal and unusable.  This
is, though, a more robust approach to the problem.
<p>
A variant would be approach five: generic pass tailoring.  A new option
(<tt>-Overifiable</tt>, perhaps) could be added to the compiler alongside
existing options like <tt>-Osmall</tt> or <tt>-Ofast</tt>.  With this
option, optimizations would be restricted to those that make relatively
unsurprising transformations to the code.  This option would not be
restricted to any one backend and could be useful in other contexts.  Some
companies, he said, have security teams that run static analyzers on binary
code.  A more predictable code stream created by an option like this (he
even suggested that <tt>-Opredictable</tt> might be a better option name)
would be easier for the analyzers to work with.
<p>
Approach six would be language-level support; this could take the form of,
for example, <tt>#pragma</tt> statements providing loop bounds.  It was
quickly pointed out, though, that the verifier cannot trust source-level
declarations of this kind, so this approach was quickly discarded.
Approach seven, adding support to the assembler, was also quickly set aside
as unworkable.
<p>
Marchesi concluded the talk by saying that, in the end, a combination of
the above approaches will probably be needed to get GCC to the point where
it routinely creates verifiable BPF code.  He would like to build a wider
consensus on the details of what is to be done before proceeding much
further.  To that end, he is working with the BPF standardization process,
and would like to get other GCC developers involved as well; he is also
coordinating with the LLVM developers.  The problem may be unsolvable in
the general sense, but it should still be possible to make things better
for BPF developers.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#BPF">BPF</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#GNU_Tools_Cauldron-2023">GNU Tools Cauldron/2023</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/946254/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor946860"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">approach six</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2023 15:56 UTC (Fri)
                               by <b>jemarch</b> (subscriber, #116773)
                              [<a href="/Articles/946860/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We thought a bit more about approach six and source level pragmas/annotations after the event.  While it is true that a pragma like the following cannot be trusted by the verifier:<br>
<p>
  #pragma loop bounded 64<br>
  for (int i = 0; i &lt; n; ++i) { ... }<br>
<p>
Another kind of pragmas may be useful to make compiling verified code more practical.  Let's call them "must-pragmas".  For example:<br>
<p>
  #pragma loop must bound 0, 64<br>
  for (int i = 0; i &lt; n; ++i) { ... }<br>
<p>
That pragma would make the compiler to fail at compile time if it is not able to determine with 100% certainty, all the stages of compilation considered, that the bounds of the loop are indeed 0 and 64.<br>
<p>
The idea is that if the compiler can figure out the loop bounds, then it may be possible to emit BPF code in a form from which the verifier can also determine the same bounds, and therefore there is a chance the compiler can produce a verifiable program.<br>
<p>
On the other hand, if the compiler cannot determine the loop bounds, using all the information it has about the program being compiled (from source code to the several intermediate representations in their respective abstraction levels) then there is little or no hope for a low-level verifier, that only has access to the compiled instructions, to do so.  A compile-time error is in order in that case, pointing to the specific "non-verifiable" source code construct.<br>
<p>
Other example of that kind of pragmas could be `#pragma loop must unroll' and, in general, annotations that make the compiler to fail if some particular optimization has not been successfully applied to some particular source code construct.<br>
<p>
So approach six may still contribute to the solution... perhaps 8-)<br>
<p>
We plan to continue and expand the discussion on how to make compiling to BPF and verified targets more practical at the LPC Toolchains Track in November, along with the clang/llvm and kernel chaps.  It will be fun, interesting and hopefully useful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946860/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">approach six</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2023 20:28 UTC (Fri)
                               by <b>ejr</b> (subscriber, #51652)
                              [<a href="/Articles/946909/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I've seen references combining CompCert and BPF, but I certainly am not up to date.<br>
<p>
Do you have any insights on how the certifiable-C-ish language infrastructures could help?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946992"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">approach six</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 18:16 UTC (Sat)
                               by <b>jemarch</b> (subscriber, #116773)
                              [<a href="/Articles/946992/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Hmm, AFAIK the verification provided by CompCert is that the generated code implements the same semantics than the source language file.  I don't think that is exactly relevant to the verified targets problem.  However, the notion/possibility of defining a BPF C subset of the C programming language that makes it easier to compile it into verifiable code has been already been raised by some.  How similar would that be to MISRA is an interesting question.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946992/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor946921"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Approach Load-time-optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 6, 2023 22:16 UTC (Fri)
                               by <b>rywang014</b> (subscriber, #167182)
                              [<a href="/Articles/946921/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The problem is that verification is done on the optimized byte code, but it's easier to be done on the pre-optimized one. So we can imagine to load a pre-optimized byte code, verify it, go through a trusted, in-kernel optimizer and then load it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946921/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946926"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Approach Load-time-optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 0:44 UTC (Sat)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/946926/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>People tried it and it just doesn't work. This assumes that your optimizer doesn't have bugs which is surprisingly hard, almost impossible to achieve if you allow it to accept arbitrary input.</p>

<p>Trusted optimizer is just something that doesn't exist, period.</p>

<p>Java developers tried to achieve that state and, ultimately, failed, after spending many billions on that.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/946926/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946929"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Approach Load-time-optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 1:46 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/946929/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's a way around that: Proof-carrying code. <a href="https://en.wikipedia.org/wiki/Proof-carrying_code">https://en.wikipedia.org/wiki/Proof-carrying_code</a><br>
It has never really been used AFAIK but the theory works. It's just hard work to write the compiler the right way.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946929/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Approach Load-time-optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 6:41 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/946953/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; It has never really been used AFAIK but the theory works. It's just hard work to write the compiler the right way.</span><br>
<p>
In theory, theory and practice are the same. In practice, they are not.<br>
<p>
Which is why I swear BY relational theory (it makes data analysis oh so easy), but I swear AT RDBMSs, and don't touch them with a barge pole unless I'm forced to (which is most of the time, now, sadly :-(<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946964"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Approach Load-time-optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 9:59 UTC (Sat)
                               by <b>joib</b> (subscriber, #8541)
                              [<a href="/Articles/946964/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm slightly in awe of your ability to twist every discussion into an argument about the merits of what was this thing called again (maybe Pick?) vs RDMS's. Here, have a (virtual) diploma. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946964/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Approach Load-time-optimization</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 17:08 UTC (Sat)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/946990/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
:-)<br>
<p>
Unfortunately, the more I work with them, the more I curse them. I can't help being a fanatic :-)<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor946931"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 1:51 UTC (Sat)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/946931/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
 &gt; A sandbox involves putting a jail around code to block any attempted bad behavior. The verifier, instead, proves to itself that a program is not harmful, then runs it in a privileged environment. <br>
<p>
This is a bit of a false dichotomy. WebAssembly combines static checks with dynamic checks, e.g. there is static checking that you don't use an uninitialized local variable, and dynamic checking that pointer accesses are in-bounds. Likewise BPF combines dynamic checks (e.g. array bounds) with static checks. WebAssembly leans more towards the dynamic side, that's all.<br>
<p>
If someone really thinks there's a hard line between a sandbox and a verifier, I'd like to know how they draw that line.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946931/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946994"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 18:51 UTC (Sat)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/946994/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There is importantly difference between BPF and WebAssembly that can be used to draw the line. <br>
<p>
BPF in Linux allows to run untrusted code in the same address space as the trusted code. So far all known speculative execution bugs has been addressed. WebAssembly implementations as I understand mostly gave up on that and assume that the security boundary is provided by the address space isolation.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946994/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor947000"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 21:46 UTC (Sat)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/947000/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This is incorrect. WebAssembly by construction can't access memory outside of its sandbox. Just like in eBPF, there's no way to create arbitrary pointers that can have unchecked access to memory.<br>
<p>
It's really no different from eBPF these days. Except that it has actual flow control and much better debugged code.<br>
<p>
For example: <a href="https://wasmer.io/posts">https://wasmer.io/posts</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947000/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor947001"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 23:26 UTC (Sat)
                               by <b>helge.bahmann</b> (subscriber, #56804)
                              [<a href="/Articles/947001/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You do not need to create arbitrary pointers, you just need to coax the CPU into speculating a confusion between a pointer and an integer.<br>
<p>
Roughly, this works by calling a function typed (void*)(uint64_t) through an indirect call (function pointer). While the WASM security model prevents you from directly assigning a function fn with signature void fn(void*) to the function pointer in question, you can cause the CPU to speculate that the call through your function pointer may end up in fn (via BTB poisoning) and therefore cause speculated access to arbitrary memory locations from WASM into the host address space (similarly applies to e.g. JacaScript). This can be exploited as really reliably for as long as the JIT ever emits an indirect call (and all JITs known to me do that, but notably researchers have also found ways to use the branch cascade resulting from switch/case-like constructs to cause the required BTB confusion).<br>
<p>
From a high level point of view, you have to assume that any "protection" offered by a languages or runtimes type system to separate pointers from arbitrary integers can be circumvented by speculative confusion of branch targets.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947001/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor947007"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 23:41 UTC (Sat)
                               by <b>helge.bahmann</b> (subscriber, #56804)
                              [<a href="/Articles/947007/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Should note: TTBOMK Wasm JITs (notably wasmtime) are not emitting retpolines which would stop the "naive" spectre V2 described at least. I am doubtful that even doing so would close all loopholes, it is damn hard to guarantee that adversarial code is jitted without side channels (unless you completely give up on asymptotically approaching "native" performance). I am not convinced eBPF is succeeding on side channel attacks either.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947007/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor947010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2023 2:06 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/947010/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt;  Roughly, this works by calling a function typed (void*)(uint64_t) through an indirect call (function pointer). </span><br>
<p>
Wasmtime does have a mitigation for this particular vulnerability: <a href="https://bytecodealliance.org/articles/security-and-correctness-in-wasmtime">https://bytecodealliance.org/articles/security-and-correc...</a><br>
<p>
It's fair to say that WASM does not try to guarantee the lack of side-channels in general. Implementations try to add mitigations where they feel that it's reasonable, but are not fixated on that. eBPF probably has some advantage in that area, but I doubt it's really insurmountable.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor947012"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2023 3:43 UTC (Sun)
                               by <b>helge.bahmann</b> (subscriber, #56804)
                              [<a href="/Articles/947012/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Are you certain? To my knowledge only "out-of-bounds" function table accesses are protected (so you "probably" cannot speculate jump out of JIT-generated code), and also no retpolines produced. I know that in 2021 I managed to get speculated call on wasmtime JIT to type-confused function happen after a lot of trial and error (AMD Zen2, and no IBRS in user space). Maybe I missed situation changing since then, but I am not aware.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947012/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor947013"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2023 3:25 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/947013/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
eBPF may have more comprehensive Spectre mitigations than (some implementations of) WebAssembly, but that would be a surprising way to define "sandbox" vs "verifier".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947013/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor947015"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2023 5:04 UTC (Sun)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/947015/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Checks at runtime can be bypassed via a speculation, checks in the verifier cannot.  Some runtime checks can be protected against speculative leaks, but V8 implementation of JS and Wasm, for example, gave up on that.<br>
<p>
So Wasm sandbox requires too many dynamic checks to hope for reliable practical protection against SPECTRE and friends. EBP implementation in Linux, by reducing the number of runtime checks and constraining the code sufficiently, still managed to provide the protection against known attacks. Hence ability to provide practical protection against speculative leaks is a useful criterion to classify.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947015/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor947020"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2023 7:06 UTC (Sun)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/947020/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Checks at runtime can be bypassed via a speculation, checks in the verifier cannot.</span><br>
<p>
Does that include new and fancy features like iterators?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947020/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor947028"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2023 9:57 UTC (Sun)
                               by <b>roc</b> (subscriber, #30627)
                              [<a href="/Articles/947028/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looks to me like Wasmtime is still "hoping for reliable practical protection against SPECTRE and friends".<br>
<a href="https://bytecodealliance.org/articles/security-and-correctness-in-wasmtime">https://bytecodealliance.org/articles/security-and-correc...</a><br>
<p>
I still think this is a poor way to draw a line between "sandbox" and "verifier". If Spectre vulnerabilities are found in eBPF will it cease to be a verifier and become a sandbox? That doesn't make sense to me.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947028/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor947037"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2023 12:57 UTC (Sun)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/947037/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Presently all found speculation bugs have been promptly addressed in BPF while Wasm implementations continue to hope. Yes, this difference is poorly defined and probably cannot be formalized.  Yet it is clear that it is affected by the nature of checks that has to be done at runtime.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947037/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor947059"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2023 2:24 UTC (Mon)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/947059/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think the big difference is in the consequences for ffi. If you want to expose some gross low level unsafe operations to ebpf that temporarily make the kernel's state inconsistent, that's fine – you just need to teach the verifier how to recognize when consistency is restored, so it can reject any programs that fail to do that.<br>
<p>
With a sandbox, you have to enter the inconsistent state before you can discover that the program is bad – which means your sandbox needs to be able to recover from arbitrarily complex inconsistent states after the fact, which is harder than recognizing them.<br>
<p>
This is closely related to ebpf verifying termination up front, vs a sandbox that handles non-termination by enforcing a timeout. If you want to enforce a timeout, it means you need a plan to recover consistency from any state the program could reach, because you don't know when the timeout might fire.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947059/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor947151"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2023 17:46 UTC (Mon)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/947151/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; – which means your sandbox needs to be able to recover from arbitrarily complex inconsistent states after the fact, which is harder than recognizing them.</span><br>
<p>
Not necessarily. You just have to be able to safely crash the tab in which the wasm is running. That's perfectly secure, but maybe not the best UX in the world, so browser developers *prefer* to try and fix the sandbox. But if the sandbox is unfixable, crashing the tab is always a valid option. The real dangers are:<br>
<p>
* Failing to recognize that the sandbox is broken in the first place.<br>
* Convincing yourself that you have fixed the sandbox, but it is not actually fixed.<br>
* Recognizing that the sandbox is broken, but too late (so the attacker has already had an opportunity to attack other parts of the browser and/or exfiltrate data).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947151/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor947162"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2023 20:20 UTC (Mon)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/947162/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; * Recognizing that the sandbox is broken, but too late (so the attacker has already had an opportunity to attack other parts of the browser and/or exfiltrate data).</span><br>
<p>
I thought we were talking about kernels, not browsers.<br>
<p>
The user is not going to be inconvenienced too much by wasm crashing a browser window, but the company could easily go bust if bpf crashes the kernel and/or exfiltrates data.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947162/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor947188"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2023 7:32 UTC (Tue)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/947188/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; if the sandbox is unfixable, crashing the tab is always a valid option</span><br>
<p>
Not if the tab has been granted FFI access to functions that manipulate state in the host. It's host state that I'm talking about, not sandbox state. eBPF programs regularly do things like write to long-lived data structures (maps, ring buffers), modify the reference counts of kernel objects, mutate packets in flight, etc.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947188/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor947621"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 12, 2023 19:13 UTC (Thu)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/947621/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Crashing the tab" is something that only exists in browsers, and to the best of my knowledge, no browser runs eBPF, so I'm really not sure what you're getting at here.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947621/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor946969"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 11:57 UTC (Sat)
                               by <b>gray_-_wolf</b> (subscriber, #131074)
                              [<a href="/Articles/946969/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; Another problem, it seems, is that some programs simply will not work without -O2 optimization; they rely on the constant folding and propagation that the optimizer provides.</span><br>
<p>
Does not these mean the programs are broken and should be fixed?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946969/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946970"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 12:37 UTC (Sat)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/946970/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Could it be that programs need -O2 to get under the instruction budget that (IIRC) eBPF enforces? Either verifier time or execution time could be too much without some kind of tree shaking or trivial inlining.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946970/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor946971"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 7, 2023 12:49 UTC (Sat)
                               by <b>segher</b> (subscriber, #109337)
                              [<a href="/Articles/946971/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not just the instruction budget, but you need some optimisation to pass the verifiers at all (mostly -O1, but still).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/946971/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor947017"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 8, 2023 5:21 UTC (Sun)
                               by <b>ibukanov</b> (guest, #3942)
                              [<a href="/Articles/947017/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As article explains, constant folding, for example, has to be done to sufficient extent to pass the verifier. Something like consteval from the latest C++ may help here, but that is not in C. Plus requiring to sprinkle consteval results in ugly code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947017/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor947141"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The challenge of compiling for verified architectures</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 9, 2023 16:44 UTC (Mon)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/947141/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm surprised that they don't have "no backwards jumps" as an attribute that targets can have that affects the optimization possibilities. I'd have thought that an input to the optimizer (or, really ordering in code generation, since assigning an ordering is always necessary even without doing transformations for optimization) would be the costs of jumps with different offsets, and a target could just say that any negative offset jump costs more than any other code. You'd still want a hint that it should find a sequence with only forward jumps if the graph doesn't have cycles, rather than making it guess what would be relatively inexpensive, but it should be possible to arrange that any transformation that introduces cycles or puts a block out of execution order looks to the optimizer like it would make the code run slower.<br>
<p>
In general, it seems like, if it were possible to get clear information on what will definitely pass verification, and it were possible to express that as costing less than other instruction sequences, then it would naturally do the right thing on the general principle that any transformation that turns out to increase the cost estimate rather than decreasing it should be skipped in this particular case.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/947141/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2023, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
