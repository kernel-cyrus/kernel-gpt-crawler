        <!DOCTYPE html>
        <html lang="en">
        <head><title>A system call for random numbers: getrandom() [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/606141/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/605745/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/606141/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A system call for random numbers: getrandom()</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>We're bad at marketing</b>
<p>
We can admit it, marketing is not our strong suit. Our strength is
writing the kind of articles that developers, administrators, and
free-software supporters depend on to know what is going on in the
Linux world. Please <a href="/Promo/nsn-bad/subscribe">subscribe today</a> to help us keep doing that, and so
we don’t have to get good at marketing.
</blockquote>
<div class="FeatureByline">
           By <b>Jake Edge</b><br>July 23, 2014</br>
           </div>
<p>
The Linux kernel already provides several ways to get random numbers, each
with its own set of constraints. But those constraints may make it
impossible for a process to get random data when it needs it.  The <a
href="http://www.libressl.org/">LibreSSL project</a> has recently been
making some 
noise about the lack of a "safe" way to get random data under Linux.  That
has led Ted Ts'o to <a href="/Articles/605828/">propose a new
<tt>getrandom()</tt> system call</a> that would provide LibreSSL with what it
needs, while also solving other kernel random number problems along
the way.
</p>

<p>
The kernel maintains random number "pools" that get fed data that comes
from sampling unpredictable events (e.g. inter-key timing from the
keyboard).  The amount of entropy contributed by each of these events is
estimated 
and tracked.  A cryptographically secure pseudo-random number generator
(PRNG) is used on the data in the pools, which then feed two separate
devices: <tt>/dev/urandom</tt> and <tt>/dev/random</tt>.

<p>
The standard way to get random numbers from the kernel is by reading from
the <tt>/dev/urandom</tt> device.  But there is also the <tt>/dev/random</tt>
device that will block until enough entropy has been collected to satisfy
the <tt>read()</tt> request.  <tt>/dev/urandom</tt> should be used for
essentially all random numbers required, but <tt>/dev/random</tt>
is sometimes used for things like extremely sensitive, long-lived keys
(e.g. GPG) or
one-time pads.  In
order to use either one, though, an application has to be able to
<tt>open()</tt> a file, which requires that there be file descriptors
available.  It also means that the application has to be able to see the
device files, which may not be the case in some containers or <tt>chroot()</tt>
environments. 
</p>

<p>
LibreSSL has been written to use <tt>/dev/urandom</tt>, but also to have a
fallback if there is an exhaustion of file descriptors (which an attacker
might try to arrange) or there is some other reason that the library can't
open the file. 
The fallback is to use the deprecated <a href="http://man7.org/linux/man-pages/man2/sysctl.2.html"><tt>sysctl()</tt> system call</a> to
retrieve the <tt>/proc/sys/kernel/random/uuid</tt> value, but without
actually having to open that file (since LibreSSL already knows that
<tt>/dev/urandom</tt> could not be opened).  But <tt>sysctl()</tt> may
disappear someday—some distribution kernels have already removed it—and, sometimes, using it puts a warning into the kernel log.
If the <tt>sysctl()</tt> fails, LibreSSL falls further back to a <a href="https://github.com/libressl-portable/openbsd/blob/4e9048830a68da79247f30aba182b1599da139b9/src/lib/libcrypto/crypto/getentropy_linux.c#L307">scary-looking function</a> that tries to
generate its own random numbers from various (hopefully) unpredictable
values available to user space (e.g. timestamps, PID numbers, etc.).
</p>

<p>
All of that can be seen in a well-commented <a
href="https://github.com/libressl-portable/openbsd/blob/4e9048830a68da79247f30aba182b1599da139b9/src/lib/libcrypto/crypto/getentropy_linux.c#L97">chunk
of code</a> in LibreSSL's <tt>getentropy_linux.c</tt> file.  The final
comment in that section makes a request:
<div class="BigQuote">
<pre>
* We hope this demonstrates that Linux should either retain their
* sysctl ABI, or consider providing a new failsafe API which
* works in a chroot or when file descriptors are exhausted.
*/
</pre>
</div>
</p>

<p>
That new API is precisely what Ts'o has proposed.  The <tt>getrandom()</tt> system
call is well-described in his patch (now up to <a
href="/Articles/606202/">version 4</a>).  It is declared as follows:
<pre>
    #include &lt;linux/random.h&gt;

    int getrandom(void *buf, size_t buflen, unsigned int flags);
</pre>
</p>

<p>
A call will fill <tt>buf</tt> with up to <tt>buflen</tt> bytes of random data
that can be used for cryptographic purposes, returning the number of bytes stored. 
As might be guessed, the
<tt>flags</tt> parameter will alter the behavior of the call.  In the
case where <tt>flags&nbsp;==&nbsp;0</tt>, <tt>getrandom()</tt>
will block 
until the <tt>/dev/urandom</tt> pool has been initialized.  If
<tt>flags</tt> is set to <tt>GRND_NONBLOCK</tt>, then <tt>getrandom()</tt>
will return -1 with an error number of <tt>EAGAIN</tt> if the pool is not
initialized. 
</p>

<p>
The <tt>GRND_RANDOM</tt> flag bit can be used to switch to the
<tt>/dev/random</tt> pool, subject to the entropy requirements of that
pool.   That means the call will block until the pool has the required entropy,
unless the <tt>GRND_NONBLOCK</tt> bit is also present in <tt>flags</tt>, in
which case it will return as many bytes as it can; it will return -1 for an
error with 
<tt>errno</tt> set to <tt>EAGAIN</tt> if there is no entropy available at all.
The call returns the number of bytes it placed into
<tt>buf</tt> (or -1 for an error).  Short reads can occur due to a lack of
entropy for the <tt>/dev/random</tt> pool or because the call was
interrupted by a signal, but reads of 256 bytes or less from
<tt>/dev/urandom</tt> are guaranteed to return the full request once that
device has been initialized.
</p>

<p>
In the proposed man page that accompanies the patch, Ts'o shows sample code
that could be used to emulate the OpenBSD <tt>getentropy()</tt> system call
using <tt>getrandom()</tt>.  One <a href="/Articles/606315/">complaint</a>
about the patch came from Christoph Hellwig, who was concerned that Ts'o
was not just implementing "<q>exactly the same system call</q>" as
OpenBSD. He continued: "<q>Having slightly different names and semantics for the same
functionality is highly annoying.</q>"  But Ts'o is trying to solve more
than just the LibreSSL problem, he <a href="/Articles/606316/">said</a>.
<tt>getrandom()</tt> is meant to be a superset of OpenBSD's
<tt>getentropy()</tt>—glibc can easily create a compatible
<tt>getentropy()</tt>, as he 
showed in the patch.
</p>

<p>
The requirement that <tt>/dev/urandom</tt> be initialized before
<tt>getrandom()</tt> will return any data from that pool is one of the new
features that the proposed system call delivers.  Currently, there is no way for
an application to know that at least 128 bits of entropy have been gathered
since the system was booted (which is the requirement to properly
initialize <tt>/dev/urandom</tt>).  Now, an application can either block to
wait for that to occur, or test for the condition using
<tt>GRND_NONBLOCK</tt> and looking for <tt>EAGAIN</tt>.  Since the behavior
of <tt>/dev/urandom</tt> is part of the kernel ABI, it could not change,
but adding this blocking to the new system call is perfectly reasonable.

<p>
The system call also provides a way to do a non-blocking read of <tt>/dev/random</tt> to
get a partial buffer in the event of a lack of entropy. It is a bit hard
to see any real application for
that—if you don't need a full buffer of high-estimated-entropy random
numbers, why 
ask for one?  In fact, the new call provides a number of ways to abuse the
kernel's random number facility (requesting <tt>INT_MAX</tt> bytes, for
example), but that isn't really any different than the existing interfaces.
</p>

<p>
There have been lots of comments of various sorts on Ts'o's patches, but
few complaints.  The overall idea seems to make sense to those
participating in the thread, anyway.
Some changes have been made based on the comments, most notably switching to
blocking by default.  But the latest revision generated only comments about
typos.  Unless that changes, it would seem that we could see
<tt>getrandom()</tt> in the kernel rather soon, perhaps as early as 3.17. 
</p><br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Random_numbers">Random numbers</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Random_number_generation">Security/Random number generation</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel">Linux kernel</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Random_number_generation">Random number generation</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/606141/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor606389"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2014 3:15 UTC (Thu)
                               by <b>busterb</b> (subscriber, #560)
                              [<a href="/Articles/606389/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While it is possible to use this call correctly, it does provide users with some extra rope to hang themselves with. Namely if you don't pay attention to the way length changes behavior, or assume the entropy pool is always initialized, it seems that one might accidentally get a partial or empty buffer.<br>
<p>
I wonder which Linux systems don't explicitly seed urandom on boot, or do not do it early enough for a getrandom caller to hit the uninitialized condition. It seems plausible that a number of embedded systems would forget, or have predictable initial seeding mechanisms. It'd be an interesting thing to research.<br>
<p>
I had never heard of pollinate until I started searching for how Ubuntu seeds itself:<br>
<a href="http://blog.dustinkirkland.com/2014/02/random-seeds-in-ubuntu-1404-lts-cloud.html">http://blog.dustinkirkland.com/2014/02/random-seeds-in-ub...</a><br>
<p>
Others load seed data from a file that can be written by the installer or the previous boot. It might pay to be careful with cloned system images though:<br>
<a href="http://www.freedesktop.org/software/systemd/man/systemd-random-seed.service.html">http://www.freedesktop.org/software/systemd/man/systemd-r...</a><br>
<p>
<a href="https://dev.openwrt.org/browser/trunk/openwrt/target/default/target_skeleton/etc/init.d/S20urandom">https://dev.openwrt.org/browser/trunk/openwrt/target/defa...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606389/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606401"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2014 5:07 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/606401/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I wonder which Linux systems don't explicitly seed urandom on boot,  or do not do it early enough for a getrandom caller to hit the uninitialized condition.</font><br>
<p>
Linux tries to do this. It initializes the entropy pool very early in the boot process, and works hard to populate it as quickly as possible<br>
<p>
However, on some system, there just isn't much randomness around, and on those systems it is possible that you won't have enough when you try to use it early in the boot process.<br>
<p>
And if you have applications that drain the pool by requesting too much randomness, you can run out, even on good systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606401/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606404"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2014 5:32 UTC (Thu)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/606404/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  And if you have applications that drain the pool by requesting too much randomness, you can run out, even on good systems.</font><br>
<p>
this of course only applies to random not urandom<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606404/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 5:58 UTC (Fri)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/606410/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
On the contrary: with /dev/urandom, you run out of randomness at the same time as you would have with /dev/random. You just can't tell when it happens, because it delivers bits either way. <br>
<p>
But you don't really run out, as such.  Rather, you get a decreasing amount of entropy with each read. Reads from /dev/random just block when it judges that the entropy it can deliver has been stretched too thin.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606706"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 18:33 UTC (Fri)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/606706/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I could be wrong but I don't think that makes sense, /dev/urandom doesn't "run out" of random numbers, once the PRNG is seeded it never runs out and the entropy never decreases, it does get new entropy added periodically while the system runs but its not a failure if there is no new randomness. /dev/random uses some of the same entropy and a PRNG but has different semantics and can block but if you've seeded your PRNG well in the first place then there is little benefit in doing so, also the heuristics for determining when you have enough quality entropy are a bit sketchy so applications are generally steered to /dev/urandom because it works better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606706/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 19:14 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/606714/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; /dev/urandom doesn't "run out" of random numbers</font><br>
<p>
Actually, it does. It doesn't run out of *pseudo*-random numbers, but real random numbers are hard to come by and in limited supply. Given enough data out of the PRNG relative to the size of the entropy pool, it is possible, at least in theory, to reverse-engineer the PRNG's internal state and predict which numbers it will produce next.<br>
<p>
So far as I know this attack has never been successful in practice, assuming a properly seeded PRNG. There is some concern when the system is starved for sources of randomness, primarily in embedded devices, since that can drastically reduce the search space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606717"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 20:01 UTC (Fri)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/606717/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
But that's the point, the way to get good random values for cryptography is to feed a randomness source into a PRNG and then use the output of the PRNG, the PRNG doesn't run out and you only need the source of randomness to get enough entropy to seed the PRNG.  The PRNG has a bunch of safeguards to make sure the output is uniform white noise, real sources of randomness don't have that filter and are often non-uniformly random so using real random sources directly is often a bad idea.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606717/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606728"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 23:10 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/606728/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That actually isn't the point at all. Yes, you want to filter and whiten your raw random source, but the PRNG doesn't introduce any new randomness; your entropy is limited to what you extracted from original random source. The PRNG just spreads the original entropy around; the more output you generate from a given amount of random input, the less actual entropy you have per bit. As a rule, the filtering and whitening steps *reduce* the bitrate relative to the original source. You're trying to concentrate the entropy (ideally achieving one bit of entropy for each output bit), not dilute it.<br>
<p>
Of course, the practical difference between an ideal PRNG with 256+ bits of internal state, seeded with an equivalent amount of entropy, and a true random number source is vanishingly small. The risk is that your PRNG isn't ideal (and is thus vulnerable to cryptoanalysis) or your seed doesn't have as much initial entropy as you thought.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606728/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606735"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2014 0:19 UTC (Sat)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/606735/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I must have grossly misunderstood your original point because I think we are largely in agreement here, I guess the only thing on which I think differently is that I'm not sure that you are _losing_ entropy as you use your PRNG, it's that you have a _fixed_ amount of entropy, well not exactly fixed because as pointed out elsewhere the position in the PRNG output is also a bit of information.  Given a sufficient amount of seed entropy you can _recycle_ it for a very long time.<br>
<p>
I suppose the question really is, how long can you recycle the same initial hardware randomness input in a PRNG before an attacker could figure something out.  That's kind of like figuring out how long your private keys need to be to be resilient against attack for a particular period of time.  I have no idea how the math works out on that though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606735/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606737"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2014 0:35 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/606737/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Figuring out the length of a PRNG cycle, where you are in it, and the seed needed to create is is exactly the problem of figuring out the sate of the pool from the output that is theoretically possible, but everyone practical (including djb) dismisses as being an impractical attack, something that nobody has ever come close to showing even in the most specific case, let alone for the general case where some of the output is deliberately thrown away to make it harder for the attacker.<br>
<p>
In other words, in theory it's a weakness against the PRNG and a reason to not use it, but in practice, avoiding a PRNG for this reason is pure paranoia.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606737/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor606726"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 22:06 UTC (Fri)
                               by <b>apoelstra</b> (subscriber, #75205)
                              [<a href="/Articles/606726/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
djb argues quite forcefully against this conventional wisdom: <a href="http://blog.cr.yp.to/20140205-entropy.html">http://blog.cr.yp.to/20140205-entropy.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606726/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606727"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 22:54 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/606727/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As I see it, djb is arguing that mixing in maybe-not-so-random data from source which can be controlled by an attacker can be worse than using a PRNG pre-seeded with higher quality, less controllable inputs. I have no objection to this point. He also argues, in effect, that reverse-engineering the PRNG state from the output is not a practical sort of attack to be worrying about. I agree, and said as much before--to my knowledge, this sort of attack has never succeeded against a well-seeded modern PRNG.<br>
<p>
However, where he relies on the line that "we can figure out how to use a single key to safely encrypt many messages"... that has been a problem for various cryptosystems in the past. If you're not careful, someone with access to enough ciphertexts may be able to infer the key used to encrypt them, particularly if they also know the corresponding plaintexts.<br>
<p>
In any case, my main point was simply that PRNGs don't create any randomness beyond whatever may have been in their initial seed. Seed a PRNG with 32 bits and generate 1 MiB of "random" data from it, and you still only have at most 32 bits of entropy--the probability of guessing the output (knowing which PRNG was used) would only be one in 2**32, not one in 2**1048576 as would be the case for the same quantity of truly random data.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606727/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606731"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 23:43 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/606731/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; the probability of guessing the output (knowing which PRNG was used) would only be one in 2**32, not one in 2**1048576 as would be the case for the same quantity of truly random data.</font><br>
<p>
not true, you not only would need to guess the correct 2**32 seed, you would also need to guess the correct offset into the resulting stream that the 1MiB of data was pulled from, that adds some additional bits of randomness (but still far less than the 2**1048576 if every bit was random)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606731/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606763"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2014 3:52 UTC (Sun)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/606763/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; you would also need to guess the correct offset into the resulting stream </font><br>
<p>
A fair point, assuming that the PRNG has an internal state larger than the  seed. One might alternatively consider that offset to be part of the seed. I was assuming that you generated the output after preparing the PRNG with at most 32 bits of entropy *in total*.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606763/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606764"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2014 4:02 UTC (Sun)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/606764/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I think your assumptions are incorrect<br>
<p>
As I understand it (vastly simplified and numbers small for examples sake)<br>
<p>
you take 32 bits of random data, it gets mixed and seeds the PRNG, but the PRNG has it's state pool.<br>
<p>
This state pool starts off with the 32 bits of random data, but is much larger (say 256 bits)<br>
<p>
each time data is read from the PRNG, it calculates some random data. Some of this random data is fed to the user, the rest of the random data replaces the existing pool.<br>
<p>
for 32 bits of random data, you can generate many TiB of output, and that output cannot be identified as not being random by any anlysis, yes, at some point it could repeat, but nobody can predict when that is, even if they have the contents of the pool<br>
<p>
so the offset into the stream can be much larger than the randomness used to initialize the pool in the first place<br>
<p>
If you are the only user of the PRNG, the offset into the stream is a known value to you and adds no randomness.<br>
<p>
But if there are other users of the PRNG output, then that adds to the randomness of the bits you read from the PRNG<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606764/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606795"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2014 23:12 UTC (Sun)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/606795/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I don't think you're actually disagreeing with me.<br>
<p>
If you don't control the offset, then yes, that contributes somewhat to the amount of entropy introduced into the PRNG. For example, if there could have been up to 1 MiB read from the PRNG in one-byte increments after it was seeded with 32 random bits but before you read your data, then that introduces at most 20 additional bits of entropy. You would have to search though a 52-bit space--32 bits of seed plus 20 bits of offset--to find a match for your data and determine the PRNG's internal state with a high degree of probability.<br>
<p>
I say "at most 20 bits" because it would be unreasonable to assume that the possible offsets are uniformly distributed from zero to 1 MiB; some sizes will be more likely than others, reducing the search space.<br>
<p>
On the other hand, if you fully randomized the PRNG's internal state, then any additional offset past that would contribute no additional entropy. Instead of searching the larger seed + offset space, you'd just search the PRNG's state space directly. If, that is, it were at all practical to brute-force search a 256-bit space.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606795/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2014 0:13 UTC (Mon)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/606797/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm a bit of a layman, I didn't know that the PRNG was considered successfully seeded with only 32 bits, that seems awfully low, 256 bits sounds like a more reasonable number.  It seems to be that it would be doable for a well financed organization to run the PRNG algorithm through every possible 32 bit seed value for a couple of megabytes of output at least.  System startup isn't exposed to that many random variables, so it wouldn't surprise me if randomness taken from IRQ/IO timings and whatnot were clustered and not white noise there is enough different hardware/software combinations out there that this might not matter in a practical sense but your 32 bits of entropy is really something slightly smaller.<br>
<p>
Over time as new randomness was folded in and the offset gets larger then I would have confidence that the state would be too random to predict but anything that uses the PRNG output shortly after it is initially set up seems that it could be using predictable values.  This would seem to be of concern to users of randomness early in the boot process, ssh key generation being the most obvious, but there are other things which use randomness.<br>
<p>
I would presume that the people who actually fully understand this stuff have thought about all of these things and are way ahead of a layman such as myself in mitigating these issues.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606886"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2014 15:36 UTC (Mon)
                               by <b>apoelstra</b> (subscriber, #75205)
                              [<a href="/Articles/606886/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;I didn't know that the PRNG was considered successfully seeded with only 32 bits</font><br>
<p>
It's not :) unless the parent post was just giving example numbers, he meant to say "32 bytes" or 256 bits.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606886/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606921"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2014 22:20 UTC (Mon)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/606921/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The parent post was just giving example numbers. Those 32 bits would indeed be a fairly small seed for something like /dev/urandom, though it was the standard size for the C library's PRNG seed on 32-bit systems. (Hopefully no one was relying on rand() for anything security-related.)<br>
<p>
On the other hand, if you seed /dev/urandom with 256 bits, but all but 32 of those bits are predictable to an attacker, you might as well be using a mere 32-bit seed... some entropy-starved embedded systems may be in this situation  shortly after startup.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606921/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor606739"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2014 1:33 UTC (Sat)
                               by <b>apoelstra</b> (subscriber, #75205)
                              [<a href="/Articles/606739/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; However, where he relies on the line that "we can figure out how to use a single key to safely encrypt many messages"... that has been a problem for various cryptosystems in the past. If you're not careful, someone with access to enough ciphertexts may be able to infer the key used to encrypt them, particularly if they also know the corresponding plaintexts.</font><br>
<p>
In the literature this sort of thing is called a "chosen plaintext attack", and any public-key cryptosystem requires a mathematical proof demonstrating that a successful CPA attack can be harnessed to solve some "hard" computational problem, e.g. the discrete logarithm problem for an elliptic curve group.<br>
<p>
Are these mathematical proofs worth anything? After all, they don't consider side-channel attacks or implementation bugs or compromised RNG's (except to assume them away, typically), and sometimes the proofs themselves are incorrect. This is a point of great controversy, but the fact is that as an academic discipline has moved beyond the "well, try not to let the attacker get -too- much information" kind of magical thinking that was typical for pre-1970's cryptography.<br>
<p>
If your encryption primitive is not CPA-secure (at least CPA-secure --- systems in use today typically have stronger security properties), then its security depends, at best, on the exact way it is used. It is hard enough to build cryptosystems when your primitives are secure against these very general attacks. Without it, you are hopeless!<br>
<p>
The security requirement for PRNGs, by the way, is that a computationally bounded adversary (i.e. one who is able to do polynomially many operations in the size of the seed) cannot distinguish the PRNG output from random with non-negligible probability. If your PRNG fails this requirement, it is not cryptographically secure and no amount of seed-guarding will change this. If it doesn't fail this, then a 256-bit seed is fine.<br>
<p>
To contrast, the attack djb describes where malicious entropy is inserted into whatever channels exist for this, is not only possible to attackers today, but is generally applicable: it will work no matter what the PRNG algorithm!<br>
<p>
<font class="QuotedText">&gt; In any case, my main point was simply that PRNGs don't create any randomness beyond whatever may have been in their initial seed. Seed a PRNG with 32 bits and generate 1 MiB of "random" data from it, and you still only have at most 32 bits of entropy--the probability of guessing the output (knowing which PRNG was used) would only be one in 2**32, not one in 2**1048576 as would be the case for the same quantity of truly random data.</font><br>
<p>
Right, but neither of those numbers can be counted to by computers in our universe in its lifetime, so the distinction is not important from a security perspective. (If you are defending against a computationally unbounded adversary, your RNG does not matter since your other cryptographic primitives are not secure anyway.) This is what djb is saying when he argues that if 256 bits is enough security for a signing key, it's enough for a PRNG.<br>
<p>
So if there's no benefit to "increasing the entropy" in this way, and it opens up a trivial algorithm-agnostic attack to any attacker who can influence the entropy source in any way....it's a bad idea.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606739/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor616047"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2014 17:45 UTC (Mon)
                               by <b>fuhchee</b> (guest, #40059)
                              [<a href="/Articles/616047/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;&gt; would only be one in 2**32, not one in 2**1048576 as would</font><br>
<font class="QuotedText">&gt;&gt; be the case for the same quantity of truly random data.</font><br>
<p>
<font class="QuotedText">&gt; Right, but neither of those numbers can be counted to by</font><br>
<font class="QuotedText">&gt; computers in our universe in its lifetime"</font><br>
<p>
Your cell phone can count to 4 billion in a second or two.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/616047/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor616053"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 13, 2014 18:19 UTC (Mon)
                               by <b>anselm</b> (subscriber, #2796)
                              [<a href="/Articles/616053/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>
Possibly, but there isn't enough energy in the universe to count up to 2**256.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/616053/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor606745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2014 3:43 UTC (Sat)
                               by <b>wahern</b> (subscriber, #37304)
                              [<a href="/Articles/606745/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"As I see it, djb is arguing that mixing in maybe-not-so-random data from source which can be controlled by an attacker can be worse than using a PRNG pre-seeded with higher quality, less controllable inputs."<br>
<p>
The argument is more nuanced than that. He's actually addressing the anxiety around hardware-based RNGs like on recent Intel chips. Those sources have privileged access to the existing RNG state in the kernel because they can access main memory directly. It's possible that they could smuggl data out of the system by carefully choosing the RNGs they generate. Then people like the NSA sniff carrier signals, such as TCP sequence numbers.<br>
<p>
"However, where he relies on the line that 'we can figure out how to use a single key to safely encrypt many messages'... that has been a problem for various cryptosystems in the past. If you're not careful, someone with access to enough ciphertexts may be able to infer the key used to encrypt them, particularly if they also know the corresponding plaintexts."<br>
<p>
His argument is premised on (1) CSPRNGs and (2) secure sources of entropy. We _definitely_ have #1. The problems with cryptosystems are higher up the ladder, almost always PEBKAC related.<br>
<p>
We have multiple sources for #2, but we shouldn't trust them. But we can mix them together. However _continued_ mixing could make you more susceptible to impossible-to-detect exfiltration attacks, so you should mix them until you're satisfied, then never interact with those sources again. Sort of a "wham, bam, thank you ma'am" relationship.<br>
<p>
The real problem is knowing when you've collected sufficient entropy. You need enough, but as DJB shows collecting too much could expose you to new forms of attack. Probably the best answer is to initially seed with hardware based solutions like Intel RdRand, then mix in low-quality sources until your satisfied that you've sufficiently closed the exfiltration gap. After that, you leave well enough alone. On networked systems we're talking a matter of seconds, or minutes at most.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor919399"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 9, 2023 10:08 UTC (Mon)
                               by <b>darwi</b> (subscriber, #131202)
                              [<a href="/Articles/919399/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote><font class="QuotedText">
<p>Linux tries to do this. It initializes the entropy pool very early in the boot process... However, on some system, there just isn't much randomness around... And if you have applications that drain the pool by requesting too much randomness, you can run out, even on good systems.
</font></blockquote>

This has been earlier reported, and a fix was applied by tglx and torvalds. Check earlier LWN articles <a href="https://lwn.net/Articles/800509/">here</a> and <a href="https://lwn.net/Articles/802360/">here</a> for context.








      
          <div class="CommentReplyButton">
            <form action="/Articles/919399/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor606603"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2014 20:42 UTC (Thu)
                               by <b>samroberts</b> (subscriber, #46749)
                              [<a href="/Articles/606603/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Why partial... probably so that you don't block indefinitely in an event-based application. If you only get partial, you can call again later, without hanging in the meantime, as you could poll() on /dev/random.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606603/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606665"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 13:19 UTC (Fri)
                               by <b>justincormack</b> (subscriber, #70439)
                              [<a href="/Articles/606665/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or just tell the user they need to wait longer; non blocking is always useful.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606665/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor606702"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 16:39 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/606702/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      Is exhaustion of file descriptors really an example of what this system call is intended to deal with?  When a system runs out of file descriptors or any other system resource, all Hell breaks loose and one more program failing, because it can't establish a secure connection, should be barely noticeable.
<p>
I can't recall ever seeing code that goes out of its way to work around being generally unable to open files.

      
          <div class="CommentReplyButton">
            <form action="/Articles/606702/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606720"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 20:15 UTC (Fri)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/606720/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Is exhaustion of file descriptors really an example of what this system call is intended to deal with? When a system runs out of file descriptors or any other system resource, all Hell breaks loose and one more program failing, because it can't establish a secure connection, should be barely noticeable. </font><br>
<font class="QuotedText">&gt; I can't recall ever seeing code that goes out of its way to work around being generally unable to open files.</font><br>
<p>
An attacker might exhaust file descriptors maliciously, just to get some software to pick a bad random number, which could end up leaking a private key from a privileged process.  The attacker would be careful in this case to try to cause the random number seeding to fail, while allowing the program to otherwise continue correctly.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606720/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 22:13 UTC (Fri)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/606725/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
An attacker might exhaust file descriptors maliciously, just to get some software to pick a bad random number,
</blockquote>
<p>
How would exhausting file descriptors get some software to pick a bad random number?  The natural result of that would be for software that uses random numbers to refuse to continue.
<p>
But regardless of whether it's a valid expectation of the attacker, it doesn't explain why LibreSSL needs to have a fallback other than "return -1" for exhausted file descriptors.  No other software does.

      
          <div class="CommentReplyButton">
            <form action="/Articles/606725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606730"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2014 23:41 UTC (Fri)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/606730/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; How would exhausting file descriptors get some software to pick a bad random number? The natural result of that would be for software that uses random numbers to refuse to continue. </font><br>
<p>
if the program zeros a buffer, then tries to read random data into that buffer and doesn't check the error codes properly, the result is that it continues on with zeros instead of it's random seed.<br>
<p>
This is an advantage for the bad guy.<br>
<p>
Yes, in theory this is handled by properly checking all error conditions<br>
<p>
But in practice, we all know that such checks are not always done.<br>
<p>
Also, note that shutting down the service is a DoS that is also to the advantage of the bad guy<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606730/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606741"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2014 1:42 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/606741/">Link</a>] (8 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
if the program zeros a buffer, then tries to read random data into that buffer and doesn't check the error codes properly, the result is that it continues on with zeros instead of it's random seed. ...
in practice, we all know that such checks are not always done.
</blockquote>
<p>
So that still doesn't shed any light on how the fact that file descriptors could be exhausted means LibreSSL needs a fallback method of generating random numbers.  LibreSSL <em>does</em> check the error condition -- that's how it knows to fall back.
<p>
<blockquote>
Also, note that shutting down the service is a DoS that is also to the advantage of the bad guy
</blockquote>
<p>
And yet, no other program under the sun avoids  DoS attacks by working around inability to open files.  In fact, the program using LibreSSL most probably uses files other than /dev/urandom, so the bad guy can kill it by exhausting file descriptors regardless of what LibreSSL does.
<p>
It looks to me like the article is simply mistaken about the relevance of file descriptor exhaustion attacks.  I think the reason LibreSSL has alternatives to /dev/urandom is that /dev/urandom might just be broken or not implemented on that system.

      
          <div class="CommentReplyButton">
            <form action="/Articles/606741/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606747"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2014 4:03 UTC (Sat)
                               by <b>jake</b> (editor, #205)
                              [<a href="/Articles/606747/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It looks to me like the article is simply mistaken about the </font><br>
<font class="QuotedText">&gt; relevance of file descriptor exhaustion attacks.</font><br>
<p>
so, this comment that was quoted in the article:<br>
<p>
<font class="QuotedText">&gt;    or consider providing a new failsafe API which</font><br>
<font class="QuotedText">&gt;    works in a chroot or when file descriptors are exhausted.</font><br>
<p>
(which comes from the LibreSSL source) was not enough to convince you that the LibreSSL folks (at least) are worried about file descriptor exhaustion?<br>
<p>
<font class="QuotedText">&gt; I think the reason LibreSSL has alternatives to /dev/urandom is </font><br>
<font class="QuotedText">&gt; that /dev/urandom might just be broken or not implemented on that </font><br>
<font class="QuotedText">&gt; system.</font><br>
<p>
interesting, but it certainly isn't what they *say* ...<br>
<p>
jake<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606747/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606758"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2014 15:55 UTC (Sat)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/606758/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
so, this comment that was quoted in the article:
<blockquote>
or consider providing a new failsafe API which
works in a chroot or when file descriptors are exhausted.
</blockquote>
 (which comes from the LibreSSL source) was not enough to convince you that the LibreSSL folks (at least) are worried about file descriptor exhaustion?
</blockquote>
<p>
OK, I missed that.  So the article is not mistaken.  It's more like the developers were really confused, thinking it's worth adding a whole new system call to the kernel just to make a program progress a little further before succumbing to file descriptor exhaustion.  Or there's some totally nonobvious attack vector I'm missing.
<P>
(I do understand that there are other, sensible, reasons to have getrandom()).

      
          <div class="CommentReplyButton">
            <form action="/Articles/606758/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606759"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2014 21:18 UTC (Sat)
                               by <b>dlang</b> (guest, #313)
                              [<a href="/Articles/606759/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  It's more like the developers were really confused, thinking it's worth adding a whole new system call to the kernel just to make a program progress a little further before succumbing to file descriptor exhaustion.</font><br>
<p>
well, that sort of thinking is par for the course for people who get tightly absorbed into security thinking. They start to see the small things that can fail and forget that the overall system is probably going to be down first.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606759/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor606771"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2014 11:57 UTC (Sun)
                               by <b>gioele</b> (subscriber, #61675)
                              [<a href="/Articles/606771/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; It's more like the developers were really confused, thinking it's worth adding a whole new system call to the kernel just to make a program progress a little further before succumbing to file descriptor exhaustion.</font><br>
<p>
Is it that hard to create a side program that uses some technique to force the exhaustion of fds during the entropy gathering (to create some weakness in a cryptographical step) and then stops, leaving the attacked programs with plenty of fds, as if nothing ever happened?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606771/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606780"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2014 16:11 UTC (Sun)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/606780/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Is it that hard to create a side program that uses some technique to
force the exhaustion of fds during the entropy gathering (to create some
weakness in a cryptographical step) and then stops, leaving the attacked
programs with plenty of fds, as if nothing ever happened?
</blockquote>
<p>
It doesn't matter because even if it's possible to create such a program, it's impossible for it to achieve its goal of creating weakness in a cryptographic step if LibreSSL refuses to proceed when the open of /dev/urandom fails.
<p>
That's what we've been talking about: the design choice of LibreSSL refusing to proceed in that case (the easy, natural, conventional thing to do) versus getting random numbers in some way that doesn't require file descriptors (which involves wishing for a new kind of system call) and proceeding.

      
          <div class="CommentReplyButton">
            <form action="/Articles/606780/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606784"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 27, 2014 17:49 UTC (Sun)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/606784/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; it's impossible for it to achieve its goal of creating weakness in a cryptographic step if LibreSSL refuses to proceed when the open of /dev/urandom fails.</font><br>
<p>
But what does "refuse to proceed" mean?  Return an easily-ignored error code?  Terminate the process?  Sit in a busy loop?  You'll get different answers based on who you ask.  I generally agree with your point, but it's not as simple as you make it out to be.  Making it so that the problem can never occur is just another way of fixing it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606784/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606924"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2014 22:50 UTC (Mon)
                               by <b>giraffedata</b> (guest, #1954)
                              [<a href="/Articles/606924/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
But what does "refuse to proceed" mean? Return an easily-ignored error code? Terminate the process? Sit in a busy loop? You'll get different answers based on who you ask.
</blockquote>
<P>
It really doesn't matter that there are options, because at least one of them is an entirely reasonable response to a catastrophic failure such as file descriptor exhaustion - a more reasonable response than designing a new kernel interface or computing entropy some other way.  As a practical matter, I think it's obvious in this case that "refuse to proceed" should just mean "return -1" when the open fails, which would ultimately cause the LibreSSL to return failure to the user instead of creating a connection.  The user can ignore that failure, but there's no way he can leak private information to an eavesdropper over a connection that does not exist.
<p>
<blockquote>
Making it so that the problem can never occur is just another way of fixing it.
</blockquote>
<p>
I'm really just asking why would a developer single out this one particular catastrophic failure for heroic action to avoid it?  I'll bet the same code allocates memory various places and just "refuses to proceed" if the allocation fails.  And at some point it creates a socket and likely just "refuses to proceed" if it fails because of file descriptor exhaustion.  Maybe it even uses a temporary file somewhere, and just "refuses to proceed" if the filesystem is full.

      
          <div class="CommentReplyButton">
            <form action="/Articles/606924/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor606930"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2014 23:13 UTC (Mon)
                               by <b>jimparis</b> (guest, #38647)
                              [<a href="/Articles/606930/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>As a practical matter, I think it's obvious in this case that "refuse to proceed" should just mean "return -1" when the open fails, which would ultimately cause the LibreSSL to return failure to the user instead of creating a connection.</blockquote>

This has nothing to do with "creating a connection"; existing code calls RAND_bytes() all the time for all sorts of things and  <a href="https://searchcode.com/?q=RAND_bytes">doesn't always check the return code</a>.

<blockquote>I'm really just asking why would a developer single out this one particular catastrophic failure for heroic action to avoid it?</blockquote>

Because this is only a problem on Linux.  Because the discussion was triggered by an article entitled <a href="https://www.agwa.name/blog/post/libressls_prng_is_unsafe_on_linux">LibreSSL's PRNG is Unsafe on Linux</a>.  Because, as a developer points out in the comments there, "we really want to see linux provide the getentropy() syscall, which fixes all the mentioned issues."
      
          <div class="CommentReplyButton">
            <form action="/Articles/606930/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor606743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 26, 2014 2:23 UTC (Sat)
                               by <b>idupree</b> (guest, #71169)
                              [<a href="/Articles/606743/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Does getrandom(buf, 0, flags) block/EAGAIN if the requested kind of entropy is unavailable?  Or does it succeed?  If the former, getrandom(buf, 0, GRND_NONBLOCK) could be a way to find out if the urandom pool is uninitialized.<br>
<p>
Why "It should not be used for Monte Carlo simulations or other programs/algorithms which are doing probabilistic sampling." (in the patch's man page): I'd like to see the man page say why.  According to <a href="http://thread.gmane.org/gmane.linux.kernel.cryptoapi/11666">http://thread.gmane.org/gmane.linux.kernel.cryptoapi/11666</a> the reason is: "It will be slow, and then the graduate student will whine and complain and send a bug report.  It will cause urandom to pull more heavily on entropy, and if that means that you are using some kind of hardware random generator on a laptop, such as tpm-rng, you will burn more battery, but no, it will not break.  This is why the man page says SHOULD not, and not MUST not.   :-)"<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/606743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor607210"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2014 5:29 UTC (Thu)
                               by <b>lordsutch</b> (guest, #53)
                              [<a href="/Articles/607210/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, if you're doing Monte Carlo or some other statistical analysis, usually you want the ability to replicate the analysis with a chosen seed and get the same numbers out (as well as being able to change the seed and see if you get the same results). The kernel random facility doesn't give you the ability to do that; indeed it's designed to make it very, very hard to get the RNG in the exact same state twice.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/607210/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor607217"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2014 7:41 UTC (Thu)
                               by <b>eternaleye</b> (guest, #67051)
                              [<a href="/Articles/607217/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's also that the kernel's random number generator is intended to be cryptographic randomness; this is considerably more stringent (and slower, and more computationally expensive) than the statistical randomness needed for Monte Carlo &amp;co. So it's just plain less useful than alternatives like WELL[1] or xorshift+[2]<br>
<p>
In addition, it depletes the scarce entropy resources of the kernel by the truckload, which may cause things that _really_ need good cryptographic randomness (long-term public keys, etc) to block indefinitely on /dev/random (since while urandom doesn't block, it _depletes the same pool_ causing random to block).<br>
<p>
[1] <a rel="nofollow" href="https://en.wikipedia.org/wiki/Well_Equidistributed_Long-period_Linear">https://en.wikipedia.org/wiki/Well_Equidistributed_Long-p...</a><br>
[2] <a rel="nofollow" href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/607217/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor607285"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 31, 2014 16:13 UTC (Thu)
                               by <b>raven667</b> (subscriber, #5198)
                              [<a href="/Articles/607285/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm not sure that /dev/random has "better" or more "real" random numbers than /dev/urandom,  when /dev/urandom is fully seeded and initialized it is as good as anything out there.  Maybe the only real use case for /dev/random is seeding your own PRNG in userspace, if you are just consuming randomness for cryptographic purposes then /dev/urandom is what you want.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/607285/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor675159"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A system call for random numbers: getrandom()</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Feb 11, 2016 8:59 UTC (Thu)
                               by <b>akostadinov</b> (guest, #48510)
                              [<a href="/Articles/675159/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Other users of urandom should not cause urandom to become less secure. As some comments pointed out, other users or urandom may even increase urandom entropy (by making it's internal state less predictable).<br>
<p>
A good read why `random` is not good idea <a href="http://www.2uo.de/myths-about-urandom/">http://www.2uo.de/myths-about-urandom/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/675159/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2014, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
