        <!DOCTYPE html>
        <html lang="en">
        <head><title>The Managed Runtime Initiative [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/392307/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/391868/">Return to the Kernel page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/392307/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>The Managed Runtime Initiative</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Ready to give LWN a try?</b>
<p>
With a subscription to LWN, you can stay current with what is happening in the Linux and free-software community and take advantage of subscriber-only site features.  We are pleased to offer you <b><a href="https://lwn.net/Promo/nst-trial/claim">a free trial subscription</a></b>, no credit card required, so that you can see for yourself.  Please, join us!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>June 16, 2010</br>
           </div>
The <a href="http://www.managedruntime.org/">Managed Runtime Initiative</a>
has recently <a
href="http://www.azulsystems.com/about_us/press/azul-systems-launches-open-initiative-improving-managed-runtimes">announced
its existence</a>.  This group is dedicated to making "managed runtime"
code (Java programs in particular) run faster on Linux systems.  MRI's
effort might not seem like a suitable topic for the Kernel Page, except for
one thing: this group has just released thousands of lines of
questionable code which, it claims, it plans to push upstream.
<p>
The specific problem that the MRI people (actually Azul Systems employees)
have set out to solve appears to be application pauses caused by garbage
collection.  Their solution is implemented at several levels, some of which
are found in the kernel.  For the curious, the patches can be found on <a
href="http://www.managedruntime.org/downloads">the MRI download page</a>,
helpfully packaged as a tarball filled with source-RPM files.  They have
also thoughtfully included all of Red Hat's patches; look for files
containing "az" to pick the new stuff out of the noise.
<p>
The first kernel patch adds an interface for loadable memory management
modules.  With this in place, loadable modules can create and claim their
own VMAs which they manage.  The Azul-supplied module creates a special
device which provides a few dozen <tt>ioctl()</tt> operations for the
management of memory within those VMAs.  What is actually done by this
module is on the
obscure side; it involves dividing memory into "accounts" with names like
"GC Pause Prevention."  There appears to be code to provide transparent
hugepage access to interested applications.  There is also some sort of
relaxed locking done within the special VMAs designed to improve
scalability there.
<p>
Then, there is the pluggable scheduler patch, creating a new <tt>SCHED_ALT</tt>
scheduling class which sits between CFS and the realtime classes.  The
actual scheduler module's purpose is described as:
<p>
<div class="BigQuote">
	The Azul scheduler is designed to provide a cpu resource guarantee
	on Linux: specifically that any process with 'committed' cpus and
	runnable threads available for those cpus will have its threads
	running on those cpus within 10ms.
</div>
<p>
It allows the partitioning of the system into "committed" and ordinary
CPUs, with special applications getting priority access to the committed
CPUs.
<p>
The MRI web page claims that "<q>it is the initiative's goal to upstream
those related contributions into existing and complementary OSS projects
(e.g. kernel.org and openjdk.org)<q>", but the kernel-related code has
never, to your editor's knowledge, been seen on any kernel-related mailing
list.  It is heavy with <tt>#ifdefs</tt>, light on comments, and it adds exports
for large numbers of low-level functions in the scheduler and VM code.  Plus there is the
little detail that the development community is unlikely to agree with this
code's fundamental purpose.  Pluggable schedulers have been rejected in the
past; until now nobody has even dared to suggest pluggable memory management
modules. 
<p>
In other words, we have a bunch of hackish code which was developed in
total isolation; one wonders how many customers it has been shipped to.  If
Azul Systems and the MRI are serious about wanting to upstream it, they
might just want to start talking with the development community fairly
soon.  One expects that they might just have a few changes to make.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Managed_Runtime_Initiative">Managed Runtime Initiative</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/392307/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor392331"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 0:56 UTC (Thu)
                               by <b>cma</b> (guest, #49905)
                              [<a href="/Articles/392331/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      Well...is just a beginning :) They might work along with the community.<br><br>

Anyway, this kind of initiatives is what makes Java very well suited to use on Linux based platforms.<br><br>

For me it would be a better idea integrating JVM on Linux kernel, for performance purposes! Unfortunately i doubt Linus or the community would accept patches for this. What a flamewar it would be!! ^_^'
      
          <div class="CommentReplyButton">
            <form action="/Articles/392331/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392730"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 1:31 UTC (Sat)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/392730/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Indeed, it would be as crazy as putting a webserver in the kernel. <a href="http://lwn.net/2000/0907/kernel.php3">Oh, wait...</a></p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/392730/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor392342"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel feedback for GC (was: The Managed Runtime Initiative)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 2:53 UTC (Thu)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/392342/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
One thing I once thought about many years ago was a way to provide feedback to a userspace GC from the kernel as to how much memory it should use. If the kernel was under memory pressure it would tell the userspace GC to discard some pages. On the other direction, the userspace GC would tell the kernel about how many pages it expected to be able to free easily, and how many pages it expected to be able to free with a bit more effort (running a slower memory compaction, for instance).<br>
<p>
The idea was to allow userspace programs to use the whole memory as a cache (for instance, for Firefox's memory cache) without the risk of going into swap. Also, if there were several GC-using userspace programs (for instance, several JVMs), they would be able to share the memory instead of fighting for it.<br>
<p>
The API would be something that you would mmap() in your address space, some way to tell that something to free a page in that mapping (turning it into the shared copy-on-write zero page), some way for the program to tell the kernel how many pages it wanted to use for that memory area (a minimum value below which it cannot free anymore, an optimum value, and a maximum value above which it has no use for the memory), and some way for the kernel to notify the program about the desired usage levels for that memory area (minimum, optimum, and maximum values). As you can see, I did not work out the API details.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392342/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392410"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel feedback for GC (was: The Managed Runtime Initiative)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 12:10 UTC (Thu)
                               by <b>alex</b> (subscriber, #1355)
                              [<a href="/Articles/392410/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That sounds like extending the sort of information you can pass with the madvise() methods.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392410/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor392761"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel feedback for GC (was: The Managed Runtime Initiative)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 12:26 UTC (Sat)
                               by <b>bcopeland</b> (subscriber, #51750)
                              [<a href="/Articles/392761/">Link</a>] 
      </p>
      
      </div>
      </summary>
      There's some research in that direction. <a href="http://walfield.org/papers/2009-walfield-support-for-memory-adaptive-applications.pdf">Here's a paper</a>.
      
          <div class="CommentReplyButton">
            <form action="/Articles/392761/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor393434"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Kernel feedback for GC (was: The Managed Runtime Initiative)</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 24, 2010 7:04 UTC (Thu)
                               by <b>renox</b> (guest, #23785)
                              [<a href="/Articles/393434/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another research about VMM / GC interaction is "Garbage collection without paging".<br>
<p>
One author even wrote that he sent a patch to lkml but it was rejected :-(<br>
<p>
Now that Java is opensource, one can hope that at some point GC and VMM will stop ignoring each other..<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/393434/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor392344"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 3:09 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/392344/">Link</a>] (55 responses)
      </p>
      
      </div>
      </summary>
      The problem this is supposed to relieve, "application pauses caused by garbage collection", is real enough. It's quite an embarrassment in this day and age.  Recently I read that BASIC programs in the '80s were prone to such pauses, as if it had long since been solved, but until very recently, Firefox was pausing on me for 15 seconds at at a stretch, every few minutes.  That it takes such an intrusive set of kernel patches to try to address this problem without application-level restructuring illustrates its true magnitude.  (Promoters of slow languages characteristically refer to this, like other systemic problems, as "some slight overhead".  When you hear the expression, it's best to think "orders of magnitude".)
<p>
The correct solution is to avoid programs that depend heavily on garbage collection.
      
          <div class="CommentReplyButton">
            <form action="/Articles/392344/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392348"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 3:52 UTC (Thu)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/392348/">Link</a>] (45 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or use a better garbage collector than a "stop-the-world" mark-sweep.  Incremental, real-time GC has existed for some time now.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392348/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392349"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 4:24 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/392349/">Link</a>] (38 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Users don't get to choose that option, so the choice is typically bad GC or a program that doesn't depend on GC.<br>
<p>
GC subsystems promoted as solving all crippling problems have existed long enough that if they really were usable, they would be used everywhere.  Apparently, either such GC solutions cannot be packaged in such a way that they can be used in each new project, or they impose constraints incompatible with other system-level requirements. Or both.  Or, maybe, no GC system actually does solve all the crippling problems, in real programs that run on real machines<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392349/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392360"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 5:22 UTC (Thu)
                               by <b>flewellyn</b> (subscriber, #5047)
                              [<a href="/Articles/392360/">Link</a>] (35 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Lisp systems have had good GCs for many years.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392360/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392366"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 6:49 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/392366/">Link</a>] (33 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Somehow, this fact has not led to good GCs appearing in places where they might find practical use, or even in all currently maintained Lisp systems.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392366/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392436"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 14:01 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392436/">Link</a>] (32 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
(the following is teaching my grandfather to suck eggs)<br>
<p>
Part of the problem is that writing a GC that tracks stuff residing on the C stack requires either pervasive changes to how your program does *all* its memory management, or (for things like the Chicken collector) pervasive changes to how your functions call each other and how the stack is managed. (The Boehm GC, via a triumph of inspired hackery, manages to do the first without source code changes: but it's computationally expensive as GCs go, not type-accurate, and can sometimes leave extra garbage lying around. I don't really understand why more C programs don't use the Boehm GC, though, it's a hell of a lot better than no GC at all. Perhaps C programmers *like* manual memory management? :/ )<br>
<p>
If you can guarantee that you'll never have pointers to GCed objects anywhere on the C stack when a GC happens, it gets much much simpler, but this is a really rather harsh requirement and most systems using a GC cannot satisfy it.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392436/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392452"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 14:18 UTC (Thu)
                               by <b>Tet</b> (subscriber, #5433)
                              [<a href="/Articles/392452/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <em>Perhaps C programmers *like* manual memory management?</em>
<p>
Yes, some of us do. Or rather, I don't like doing it in and of itself. But I love the determinism of it.
      
          <div class="CommentReplyButton">
            <form action="/Articles/392452/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392462"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 15:16 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392462/">Link</a>] (20 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Quite so. Deterministic GC is possible: it's just GC in which you must explicitly insert calls to fire off a GC cycle. (At the C level, this is how all garbage collectors are implemented, of course...)<br>
<p>
But when you're dealing with complex enough data structures (lots of cycles, trees with pointers to each other and so on), explicit memory management moves from 'deterministic' to 'lethally complex and horrifically annoying'. That's when GC really starts to be useful (and that's why GCC has a special-purpose garbage collector of its very own.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392462/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392657"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 13:47 UTC (Fri)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/392657/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That's when you have to start simplifying and improving your design instead.<br>
<p>
Seriously, you have to keep track of all links and pointers and datastructures anyway, memory management is only very little additional work. If it's lethally complex and horrifically annoying then your other code is too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392657/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392840"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2010 20:11 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392840/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Unfortunately, some problems (e.g. anything at all to do with translation/compilation/optimization) simply *are* intrinsically complex, and anything involving graphs with entities attached with varying lifetimes *is* going to have a horrific time without GC. (Reference counting can help in many other cases, but if the graphs have any cycles in them, you're dead.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392840/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor393069"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2010 13:48 UTC (Tue)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/393069/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, graphs with cycles are tricky to do without GC. You would need to <br>
walk the graph and basically do manual GC now and then. That's a hundred <br>
lines of extra code which runs when you want it to run. Trying to do more<br>
classic manual memory management would be horrific indeed, but when done in <br>
a way that fits the situation it adds negligible coding/complexity overhead.<br>
<p>
For complication/translation/optimization stuff you generally can just<br>
allocate everything you need and throw everything away afterwards, e.g.<br>
at program exit. Usually the optimization complexity explodes, so you <br>
want to limit the size of the problem anyway.<br>
<p>
It's like with locking; You don't have to always use the same granularity.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/393069/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor393177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2010 20:30 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/393177/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
For complication/translation/optimization stuff you generally can just allocate everything you need and throw everything away afterwards, e.g. at program exit.
</blockquote>
Hang on, I thought people were complaining that GCC used too much memory? This would make its memory use balloon insanely (many gigabytes to compile any nontrivial program).
<p>
Compilation always creates many intermediate data structures, many of which are elaborate graphs or have pointers to each other. You really do want to throw them away when you can, and you really do not want to do this by hand.

      
          <div class="CommentReplyButton">
            <form action="/Articles/393177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor393195"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 22, 2010 22:53 UTC (Tue)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/393195/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
In my experience most memory is used when linking, not when compiling,<br>
but I guess it can get pretty bad when compiling huge C++ codes with<br>
plenty templates.<br>
<p>
The thing is, you probably can't throw away much in each intermediate step,<br>
because you do need all that info, but you can easily throw away data<br>
generated by a whole intermediate step and keep only the intermediate <br>
results. So the main way to limit memory usage is by limiting the working<br>
set. GC doesn't help with that.<br>
<p>
Anyway, gcc already uses GC it seems, so if it uses too much memory then <br>
adding a GC won't help. (<a href="http://gcc.gnu.org/wiki/Memory_management">http://gcc.gnu.org/wiki/Memory_management</a>)<br>
That it would use much more without GC seems unlikely.<br>
<p>
I guess my argument boils down to: Managing object lifetime is only a<br>
small part of memory management, and GC only helps with that.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/393195/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor393246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2010 13:10 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/393246/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
In my experience most memory is used when linking, not when compiling
</blockquote>
The only reason you think that is because GCC runs several garbage collections when compiling even a small file.
<p>
And your assumption about being able to throw away whole intermediate steps at once -- that's how GCC used to work when it kept everything in obstacks. It's often correct, but if it's wrong only in part you have to keep a <i>lot</i> around because you have no way to tell which bits you're using and which you're not.
<p>
(actually, to be maximally pedantic it's almost never correct because most passes annotate or shuffle some tree somewhere: if it did nothing all the time it would be a pretty useless pass.)
<p>
But it seems you don't get it. I know GCC already has a GC: I'm using it as a counterexample to your claim that GC is unnecessary because you can always simplify your datastructures. You cannot always do that (although you often can and it should be the first thing you try, if practicable), and doing it by hand (i.e. explicitly triggering GC cycles) is often impractical too.
<p>
Managing (or rather mismanaging) object lifetime is the part of memory management that is most likely to cause bugs in C programs (less so in C++); GC largely eliminates that as a cause of bugs.

      
          <div class="CommentReplyButton">
            <form action="/Articles/393246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor393772"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 25, 2010 14:57 UTC (Fri)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/393772/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (actually, to be maximally pedantic it's almost never correct because</font><br>
<font class="QuotedText">&gt; most passes annotate or shuffle some tree somewhere: if it did nothing</font><br>
<font class="QuotedText">&gt; all the time it would be a pretty useless pass.) </font><br>
<p>
That's why I was talking about compilation stages, not optimisation <br>
stages. I don't think you can free any significant amount of memory <br>
between the latter ones, because you never know what may be needed <br>
in the future. Even if you just replace multiple nodes with fewer ones <br>
you can't save much memory because of fragmentation. At best it's a <br>
factor 2, in which case you have to manage overall memory consumption <br>
by reducing your working set anyway.<br>
<p>
I'm also sure that GCC does not use hundreds of megabytes to keep <br>
very complex graphs in memory.<br>
<p>
I'd rather have GCC spend its time on using 10 times the memory for <br>
compiling small files fast than waste time on reducing memory usage<br>
by running slower and not really achieving it anyway.<br>
<p>
<font class="QuotedText">&gt; But it seems you don't get it. I know GCC already has a GC: I'm using it </font><br>
<font class="QuotedText">&gt; as a counterexample to your claim that GC is unnecessary because you can </font><br>
<font class="QuotedText">&gt; always simplify your datastructures. You cannot always do that (although </font><br>
<font class="QuotedText">&gt; you often can and it should be the first thing you try, if practicable), </font><br>
<font class="QuotedText">&gt; and doing it by hand (i.e. explicitly triggering GC cycles) is often </font><br>
<font class="QuotedText">&gt; impractical too.</font><br>
<p>
No, I don't get it. You brought GCC as an example of something that people <br>
complain about that uses too much memory, and of something that uses <br>
complex datastructures that can't be easily handled with manual memory <br>
handling. What I'm trying to say is that GC doesn't solve any real problems, <br>
it's just convenience for the lazy, but when you do use too much memory <br>
(bloat or leak) it won't help you at all. When memory handling is important <br>
then you have to put it into your program design on a higher level. You seem <br>
to assume that GCC would use a lot more memory if it didn't use GC. I think <br>
it's rather that GC doesn't improve the situation.<br>
<p>
<font class="QuotedText">&gt; Managing (or rather mismanaging) object lifetime is the part of memory </font><br>
<font class="QuotedText">&gt; management that is most likely to cause bugs in C programs (less so in</font><br>
<font class="QuotedText">&gt; C++); GC largely eliminates that as a cause of bugs.</font><br>
<p>
In my experience memory leaks almost never happen and when they do <br>
happen they're easily fixed. At least in C: When it happens with Java it's <br>
a bit harder because then you have to hunt down the dangling references <br>
and you can't use Valgrind. Firefox is a different story, but even a perfect <br>
GC wouldn't have saved it. (But the problem of C++ programs is that C++ <br>
adds its own additional complexity without making anything easier, with <br>
as a result more bugs and memory leaks in general.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/393772/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor393948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 27, 2010 17:05 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/393948/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
That's why I was talking about compilation stages, not optimisation  stages.
</blockquote>
There is no meaningful distinction, after parsing, between translation and optimization. There are only compilers that optimize more, and compilers that optimize less.
<blockquote>
I'm also sure that GCC does not use hundreds of megabytes to keep very complex graphs in memory.
</blockquote>
You're hilariously wrong. (Seriously, what do you think it's <i>doing</i> with the gigabytes of space it can sometimes use? Playing electronic tic-tac-toe? Of <i>course</i> it's holding graphs, and other things some of which it indeed can never throw away e.g. hordes of decl nodes for all the declarations in all the header files it's parsed...)
<blockquote>
I'd rather have GCC spend its time on using 10 times the memory for compiling small files fast than waste time on reducing memory usage by running slower and not really achieving it anyway.
</blockquote>
You'd say that until you tried to compile something and it failed because you ran out of memory, or it started taking a thousand times longer than otherwise because you were pushed into swap. Also, the more we reduce memory usage, the better our (still quite awful) cache utilization becomes.
<blockquote>
You seem to assume that GCC would use a lot more memory if it didn't use GC. I think it's rather that GC doesn't improve the situation.
</blockquote>
No. If it never garbage collected and didn't free(), as you suggested, it would use incredibly much more memory (many times more than it does now).
<p>
As for what would happen if it was designed without GC, well, we have actual evidence of that because pre-3.0 it did indeed have no GC, and used manual memory management for everything, with explicit lifetimes. Maintaining the object lifetimes was a nightmare and there were countless bugs raised due to SEGVs caused by something being freed when it shouldn't.
<blockquote>
In my experience memory leaks almost never happen and when they do happen they're easily fixed.
</blockquote>
That's true until you have to manage complex data structures. It's also only true if your memory leak (or, worse, double-free) isn't tied up with an API bug somewhere and not fixable without changing the API. I've seen that too and it was a nightmare to fix (we had to change every caller and there were hundreds, ick, never again).
<p>
GC may be more inefficient than manual memory management (theoretically this is not true, but I've never heard of a situation where that theory is turned to practice) and is surely not right for every situation, but it wipes out <i>all</i> these problems at a stroke.
<p>
And to be honest if asked if I'd rather have a program that ran more slowly but used GC or a program that didn't work I'd surely pick the former.

      
          <div class="CommentReplyButton">
            <form action="/Articles/393948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor394746"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 4, 2010 17:14 UTC (Sun)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/394746/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, but compilers don't grab the whole source and optimise everything at<br>
once, at least not generally, though they can do that. So it's fine if they <br>
use a bit more memory when compiling one unit, the only moment when the <br>
whole program has to be in memory is when linking.<br>
<p>
Considering that optimising is a computationally expensive process which<br>
grows much more than O(n) if the working set increases by n, I'm really<br>
surprised that memory usage is a limiting factor at all, and that compile<br>
time hasn't gone through the roof before this became a problem.<br>
<p>
What the hell is gcc doing to achieve this? Making hundreds of copies of<br>
all the nodes every time it modifies them? (I know you can trade memory<br>
usage for time with certain algorithms, but is gcc actually doing that?)<br>
<p>
In a dark past I compiled the whole system on a slow, crappy computer with<br>
128 MB of RAM (bloody Gentoo, but Archlinux had no i586 binaries), and I'm<br>
pretty sure it was totally limited by CPU speed. Took a whole day, but it<br>
got to the end. What code makes gcc use hundreds of megabytes of memory <br>
in your experience?<br>
<p>
But yeah, if you have a huge body of code with crappy internal APIs then<br>
GC is probably a very good idea. Using explicit memory allocation for short <br>
lived objects plainly sucks, GC is better for that. In normal C the thing is<br>
to avoid such objects in the first place. I only use malloc for long-lived<br>
objects and mostly at program start-up or once per major event, like a new<br>
client connecting. If for whatever reason (IMHO mostly because of bad design,<br>
but not always) the code isn't orderly and clear, but messy, then having<br>
no GC would be a bit of a hell, I admit. But you might want to consider<br>
rewriting the whole thing in Python too, because just using a GC won't <br>
help much. And that's my main point you seem to ignore, that if having GC<br>
improves the situation, it generally means you got other, bigger, design <br>
problems. The case where it's really because of "complex data structures"<br>
is a rare case indeed. Mostly it's unnecessarily complex and then it's<br>
plain bad design.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/394746/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395174"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 7, 2010 15:56 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/395174/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Yes, but compilers don't grab the whole source and optimise everything at
once, at least not generally, though they can do that. So it's fine if they use a bit more memory when compiling one unit, the only moment when the whole program has to be in memory is when linking.
</blockquote>
Well, -flto does exactly that. In any case, grabbing <i>one translation unit</i> and optimizing it can easily use hundreds of megabytes of memory, and without doing garbage collections (i.e. never freeing storage) would easily use many gigabytes.
<blockquote>
Considering that optimising is a computationally expensive process which
grows much more than O(n) if the working set increases by n, I'm really
surprised that memory usage is a limiting factor at all, and that compile
time hasn't gone through the roof before this became a problem.
</blockquote>
Well, compile time having gone through the roof <i>is</i> a perennial complaint about GCC, and its L2 cache utilization is pretty awful.
<blockquote>
What the hell is gcc doing to achieve this? Making hundreds of copies of
all the nodes every time it modifies them? (I know you can trade memory
usage for time with certain algorithms, but is gcc actually doing that?)
</blockquote>
No, but it has a <i>lot</i> of optimization passes, several IRs, and it does a lot of work. Also, headers are large these days: decl nodes alone can use hundreds of megabytes, and recent work to reduce the size of decl nodes has reduced the memory consumption of the compiler considerably.
<p>
You might find the -fmem-report flag interesting.
<p>
(Note that reuse of tree nodes is a classic example of a time where GC is very useful, because all of a sudden that object's lifetime must be extended, and telling the entity that originally allocated it is likely to be unpleasant.)
<blockquote>
In a dark past I compiled the whole system on a slow, crappy computer with
128 MB of RAM (bloody Gentoo, but Archlinux had no i586 binaries), and I'm
pretty sure it was totally limited by CPU speed. Took a whole day, but it
got to the end. What code makes gcc use hundreds of megabytes of memory 
in your experience?
</blockquote>
Virtually anything in C++. Anything more than a few thousand lines long in C. It's downright <i>commonplace</i>. It's pretty common to see GCC using >500Mb, and I've seen it using gigabytes before now. If you run several compilations in parallel, you'll need even more...
<blockquote>
But yeah, if you have a huge body of code with crappy internal APIs then GC is probably a very good idea. Using explicit memory allocation for short lived objects plainly sucks, GC is better for that.
</blockquote>
That's exactly the class of allocations for which obstacks are good and GC can often be forgone. When you have long-lived allocations in a complex webwork in elaborate interconnected graphs, <i>then</i> is when GC becomes essential. And GCC has elaborate interconnected graphs up the wazoo. The quality of internal APIs is mostly irrelevant here: it's the nature of the data structures that matters.
<blockquote>
The case where it's really because of "complex data structures" is a rare case indeed.
</blockquote>
I find that about 5% of the programs I write start to get complex enough data structures that memory management becomes a serious burden. I think it depends on the class of program, really. If you mostly write little scripting things or financial add-up-these-numbers programs, then, no, complex data structures will be uncommon. If you're hacking on the inside of a database server or a compiler, then they'll be common.

      
          <div class="CommentReplyButton">
            <form action="/Articles/395174/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395417"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 14:36 UTC (Thu)
                               by <b>etienne</b> (guest, #25256)
                              [<a href="/Articles/395417/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Note that reuse of tree nodes is a classic example of a time where GC is</font><br>
<font class="QuotedText">&gt; very useful, because all of a sudden that object's lifetime must be</font><br>
<font class="QuotedText">&gt; extended, and telling the entity that originally allocated it is likely</font><br>
<font class="QuotedText">&gt; to be unpleasant.</font><br>
<p>
I am not a specialist of GC, but I wonder if the usual malloc/free interface is wrong, and if we should use something like malloc/memlock/free.<br>
Basically, the function which create the data allocates it, all functions using the data memlock() it, and every function calls free() when it finishes using that data. Free() decrements a counter and frees the memory when the counter reaches zero.<br>
Has that already been tried and what would be the problem of it?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395417/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor395423"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 8, 2010 14:52 UTC (Thu)
                               by <b>nye</b> (subscriber, #51576)
                              [<a href="/Articles/395423/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;Basically, the function which create the data allocates it, all functions using the data memlock() it, and every function calls free() when it finishes using that data. Free() decrements a counter and frees the memory when the counter reaches zero.</font><br>
<p>
How would this be different from any other form of reference counting, with its attendant problems?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395423/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor395616"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 9, 2010 16:22 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/395616/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Straight reference counting works if you can tell who the 'users' are, and if the data structures are fairly simple. But we can't really ask everyone touching a graph to walk the entire graph and all its data structures and increment, then decrement, all its reference counts (that would be much more cache-unfriendly and unpleasant to maintain than what is done now); and because nodes are often shared between graphs we can't have one giant reference count across the whole graph... and if the reference-count-freer walks the graph and only frees if all connected entities are at refcount zero, you might as well drop the reference count, because what you've got there is a garbage collector. :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395616/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor395976"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 14, 2010 14:23 UTC (Wed)
                               by <b>i3839</b> (guest, #31386)
                              [<a href="/Articles/395976/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
-flto enables link time optimisation, which is IMHO something slightly<br>
different, and earlier (current?) implementation has a reputation of being<br>
slow. I was thinking more about -combine -fwhole-program. As far as I know<br>
link time optimisation is about doing further optimisations before the real <br>
linking.<br>
<p>
-fmem-report flag is indeed interesting. On my current project, which <br>
is about 4K lines of C code, it reports 16MB allocated with combine + <br>
whole-program, 12MB when using dietlibc, and max 3MB when compiling <br>
files one at a time.<br>
<p>
So assuming C++ is ten times worse, and the code ten times bigger, then <br>
you're indeed easily using gigabytes of memory. I guess you don't want <br>
to compile big C++ programs at once though, doing it per file should be<br>
fine.<br>
<p>
<font class="QuotedText">&gt; That's exactly the class of allocations for which obstacks are good and </font><br>
<font class="QuotedText">&gt; GC can often be forgone. When you have long-lived allocations in a</font><br>
<font class="QuotedText">&gt; complex webwork in elaborate interconnected graphs, then is when GC</font><br>
<font class="QuotedText">&gt; becomes essential. And GCC has elaborate interconnected graphs up the</font><br>
<font class="QuotedText">&gt; wazoo. The quality of internal APIs is mostly irrelevant here: it's the</font><br>
<font class="QuotedText">&gt; nature of the data structures that matters. </font><br>
<p>
With crappy APIs/design you can't allocate objects on the stack, but are<br>
forced to allocate them dynamically even if they're short lived.<br>
<p>
The problem of elaborate interconnected graphs is that it's hard to end<br>
up with nodes with no references at all, so GC usually won't help much.<br>
And even if it does it probably doesn't reduce peak memory usage. So yes,<br>
in such cases you want something like GC, for your own sanity, but it<br>
won't improve the total memory usage much if you don't limit the graph <br>
size some other way.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/395976/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor396172"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 15, 2010 17:06 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/396172/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Link-time optimization works by having the compilation phases drive the compilation to the GIMPLE tree stage, then writing it out and having the link stage invoke the compiler again (via collect2, or via a linker plugin: the latter is preferable because then you can run it over the contents of .a archives as well) to read in all the GIMPLE trees and optimize them. At that stage you've got all the trees written out by all the compilation phases in memory at once. And a good few optimizations will, unless bounded explicitly, start using up crazy amounts of memory when hit with large programs all at once. (Of course they *are* bounded explicitly. At least all of them that anyone noticed are.)<br>
<p>
-combine -fwhole-program has a similar memory hit, for similar reasons.<br>
<p>
C++ is a good bit worse memory-wise than C, mostly because the headers make C headers look like child's toys: they have a lot of definitions in them and a large number of very complex declarations. I've known compiling *single C++ files* to eat a couple of gigabytes before (although, admittedly, those were exceptional, things like large yacc parsers compiled with C++: mysql's SQL parser is a good example).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/396172/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor403701"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2010 20:22 UTC (Mon)
                               by <b>Blaisorblade</b> (guest, #25465)
                              [<a href="/Articles/403701/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That's why I was talking about compilation stages, not optimisation </font><br>
stages.<br>
<font class="QuotedText">&gt; I don't think you can free any significant amount of memory </font><br>
between the latter ones, because you never know what may be needed <br>
in the future.<br>
<p>
Well, if no pointer exists to an object, there's no way somebody can use it. It seems you don't know what you're talking about.<br>
<p>
<font class="QuotedText">&gt; Even if you just replace multiple nodes with fewer ones you can't save much memory because of fragmentation</font><br>
<p>
Fragmentation only exists in languages which don't support GC well (i.e., C). GC have been able to fix that for ages. Whether we have decent heuristics for handling it without using too much CPUs is an open issue, when that's a problem choosing the GC algorithm among the implemented ones is the best solution.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/403701/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor403700"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2010 20:14 UTC (Mon)
                               by <b>Blaisorblade</b> (guest, #25465)
                              [<a href="/Articles/403700/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; That's when you have to start simplifying and improving your design instead.</font><br>
<font class="QuotedText">&gt; Seriously, you have to keep track of all links and pointers and datastructures anyway, memory management is only very little additional work. If it's lethally complex and horrifically annoying then your other code is too.</font><br>
<p>
First, refcounting is GC, and lots of C programs use it.<br>
<p>
I used to program in C in kernel space (on UserModeLinux, I remember a nix, probably you, on our MLs), now I usually program in functional languages. If you ever tried, you'd realize that there, manual memory management would be much more code than getting the job done.<br>
<p>
On the other hand, in C, and even in kernel space, reference counting is frequently used, especially for just _everything_ shared among multiple threads. It might be omitted for stuff which is only manipulated under locks in certain ways, but kernel code craves for using as few locks as possible, so refcounting is required by the coding style for such cases.<br>
<p>
And reference counting is... just another way to implement GC. Which is probably fine for those usages - but if you implement GC with it, it's often the worst way (because you really use it differently).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/403700/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor403711"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2010 21:17 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/403711/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, I'm the same Nix :)<br>
<p>
The biggest problem with refcounting GC (ignoring the cycle problem) is that its constant tweaking of refcounts leads to appalling cacheline bouncing with concurrent code. (Slightly different from the nasty cache effects of crude old mark-and-sweep collectors.)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/403711/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor403727"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2010 22:38 UTC (Mon)
                               by <b>Blaisorblade</b> (guest, #25465)
                              [<a href="/Articles/403727/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
The biggest problem with refcounting GC (ignoring the cycle problem) is that its constant tweaking of refcounts leads to appalling cacheline bouncing with concurrent code. (Slightly different from the nasty cache effects of crude old mark-and-sweep collectors.)
</blockquote>
<p>
Yep, that's what doesn't happen (not that much) in kernel (with explicit refcounting) and what smarter refcounting GCs try to avoid as much as possible. No refcounting for stack operations (which implies a stop-the-world phase to scan the stack) is an old optimization; the Recycler from IBM does something better, but there must be reasons why nobody actually uses it, and reading the paper with attention gives some suggestions. Most importantly, the most reputable comment I got about it was "it's crap", unfortunately I couldn't ask details.
</p>
&lt;OT&gt;
<blockquote>
Yes, I'm the same Nix :)
</blockquote>
<p>
Nice to see you again - I've noticed your nick a number of times here. And now I speak as a researcher in programming languages and their implementation - what a huge change.<br />
&lt;/OT&gt;
</p>
<p>
But back to UserModeLinux, I agree that it would definitely make sense to use these tricks, or at least something related (you mentioned that somewhere else). We were actually trying to push forward some code for our needs, i.e. Ingo's remap_file_pages patch, which I resumed. It allowed playing not only with offsets but also with protection bits of individual pages. It seems that here, the guys are doing much more stuff - including, probably, batched VM operations, since they need to use them to set up read barriers, i.e. to trap memory reads for their GC, which was originally developed for a RISC CPU which gives a small HW support for them!
</p>
<p>
But I would have needed a full-time position to handle that, rather than working on it on my free time, after UML maintenance and support, and UML as a whole was severely lacking manpower. But understanding and fixing some bugs in Ingo Molnar's code (on which he had played just for a small while) was one of my best achievements by that time.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/403727/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor403736"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2010 23:17 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/403736/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Nice to see you again - I've noticed your nick a number of times here. And now I speak as a researcher in programming languages and their implementation - what a huge change.
</blockquote>
I'd wondered what you'd been doing when you dropped out of UML hacking :)
<p>
Just like to say thanks for the UML work over the years, it kept my firewall happy for many years before that machine croaked its last and I switched to a Soekris... UML seems to have been obsoleted by qemu now, which is in a way a shame: it did a lot of things in interesting and unusual ways, and I'm fairly sure nobody else had ever abused ptrace() quite as badly (given the number of ptrace() bugs UML teased out, I think we can be sure of it).

      
          <div class="CommentReplyButton">
            <form action="/Articles/403736/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor392460"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">allocation in C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 16:02 UTC (Thu)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/392460/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Speaking about the largest C project I work on...<br>
<p>
In some places the reason I don't use a GC is because I'm lazy and there wasn't one sat there ready to go. It is possible that I should learn to use the Boehm GC in these cases and that I should evangelise its use.<br>
<p>
But in a lot of places it's because it's because the code's on the critical path. I don't see a GC (and particularly one you admit is "computationally expensive") buying us more than it costs in these codepaths. This is optimised code, where people have chosen the algorithms very carefully and read the latest papers, and run benchmarks to find good parameters and done all that good stuff. And we already have (by the nature of the system) an insatiable appetite for RAM so we certainly don't want to make that any worse.<br>
<p>
Perhaps a better goal is to stop using C at all for the "lazy" code. I probably spend as little as 30% of my programming time writing C these days anyway, maybe it should be less than 10%. Java for example seems to work well enough, it's slow and it wastes a lot of RAM, and it's missing a bunch of features I like, but it works well enough. Probably a lot of my "lazy" code could be Java, more than already is.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392460/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392841"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">allocation in C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2010 20:13 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392841/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
In some places the reason I don't use a GC is because I'm lazy and there wasn't one sat there ready to go. It is possible that I should learn to use the Boehm GC in these cases and that I should evangelise its use.
</blockquote>
Since using the boehm GC in its simplest form consists of including one header and instantly all your malloc()s are garbage-collected, that's not hard. (You don't need to take the free()s out, but they're no longer *necessary*, merely hints that this block no longer needs to be scanned for possible pointers.)
<p>
But yes, avoiding C for the boring stuff is probably best. Embed a better language (or embed the C in a better language) and use that, and get GC for free :)

      
          <div class="CommentReplyButton">
            <form action="/Articles/392841/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392866"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">allocation in C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2010 0:33 UTC (Mon)
                               by <b>khc</b> (guest, #45209)
                              [<a href="/Articles/392866/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or with LD_PRELOAD ;-) It's hard to decide which one is simpler though.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392866/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">allocation in C</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2010 20:54 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392989/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I suppose it depends if you have the source to all the bits or not. If you do, using LD_PRELOAD would be just icky. If you don't, it's unavoidable.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor392500"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 17:47 UTC (Thu)
                               by <b>jordanb</b> (guest, #45668)
                              [<a href="/Articles/392500/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; (The Boehm GC, via a triumph of inspired hackery, manages to do the first </font><br>
<font class="QuotedText">&gt; without source code changes: but it's computationally expensive as GCs go, </font><br>
<font class="QuotedText">&gt; not type-accurate, and can sometimes leave extra garbage lying around. I </font><br>
<font class="QuotedText">&gt; don't really understand why more C programs don't use the Boehm GC, though</font><br>
<p>
Seriously? <br>
<p>
With a sales pitch like that, who wouldn't use it? :P<br>
<p>
Anyway, I think RAII is a better approach to memory management than GC for high-performance applications. It's deterministic and has very little run-time cost. The only disadvantage is that it doesn't exist in C, but it's supported by all modern languages except the ones that have gone the builtin-GC route.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392500/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392518"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RAII, but no GC?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 19:05 UTC (Thu)
                               by <b>sbishop</b> (guest, #33061)
                              [<a href="/Articles/392518/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am not aware of a modern language which does not have built-in GC.  (Though "built-in GC" is a requirement under most people's definition of "modern language".)  Which languages are you thinking of?  I don't mean to argue with you; I'm just curious.<br>
<p>
I'm also curious to know where RAII is used outside of C++.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392518/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392534"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RAII, but no GC?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 19:29 UTC (Thu)
                               by <b>alextingle</b> (guest, #20593)
                              [<a href="/Articles/392534/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Python uses RAII, I believe.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392534/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392548"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RAII, but no GC?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 21:18 UTC (Thu)
                               by <b>tack</b> (guest, #12542)
                              [<a href="/Articles/392548/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Not exactly.  It's a peculiarity of (current versions of) CPython that RAII patterns can work, however there's nothing in the language that specifies that behavior, and you can't expect it from other implementations like Jython, or perhaps not even from future versions of CPython.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392548/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392770"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">RAII, but no GC?</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 13:39 UTC (Sat)
                               by <b>cortana</b> (subscriber, #24596)
                              [<a href="/Articles/392770/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Perhaps Alex was referring to to the 'with' statement: <a href="http://docs.python.org/reference/compound_stmts.html#with">http://docs.python.org/reference/compound_stmts.html#with</a><br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392770/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor392846"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2010 20:18 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392846/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
With a sales pitch like that, who wouldn't use it? :P
</blockquote>
Heh. Well, it does about as well as it's possible to do in C without massive assistance from the application. But that takes tradeoffs...
      
          <div class="CommentReplyButton">
            <form action="/Articles/392846/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor392746"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 5:34 UTC (Sat)
                               by <b>jonabbey</b> (guest, #2736)
                              [<a href="/Articles/392746/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And so do Java VMs.<br>
<p>
Modern versions of the JDK really do have truly exceptional GC performance.  Java 7 will feature a compacting, predictable delay time GC system that can take excellent advantage of many-core systems to provide great throughput.<br>
<p>
With GC systems, there's a trade-off between speed of collection, CPU efficiency, and overall memory usage.  Java allows these parameters to be tuned for a specific use case, but it is true that the default configuration tends to emphasize CPU efficiency over overall memory usage.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392746/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor392455"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 14:37 UTC (Thu)
                               by <b>NAR</b> (subscriber, #1313)
                              [<a href="/Articles/392455/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <I>GC subsystems promoted as solving all crippling problems have existed long enough that if they really were usable, they would be used everywhere.</I>
<P>
They might be used in a telephony exchange system near you? I'm not that familiar with the Erlang GC, but I haven't met the "everything stops for 15 seconds" problem yet. Of course, it's still possible to leak memory (i.e. breaking the code that removes the elements from a list, so it just grows and grows), and sometimes an explicit garbage collection frees up a surprising amount of memory, but it doesn't happen that often.
      
          <div class="CommentReplyButton">
            <form action="/Articles/392455/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392747"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 5:36 UTC (Sat)
                               by <b>jonabbey</b> (guest, #2736)
                              [<a href="/Articles/392747/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Erlang benefits a lot from its functional design.  If there's not a function working on a piece of data, it can be collected.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392747/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor392398"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Real-time GC does not work, period.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 10:57 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/392398/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <p>Problems with real-time GC is not the GC itself. Rather it's general problem: you can't manage memory efficiently unless the program does it. If you program keeps links to gigabyte of long-dead objects and then suddenly drop links to all these objects to create another gygabyte of objects you'll see UI freezes no matter what you do. And if your program is accurate enough and careful enough with allocation of objects then it's usually easy to add manual allocation or trivial refcounting GC.</p>

<p>Good memory management is hard, good memory management with GC is harder. Not only you must think about references to objects - you must keep the capabilities of GC in mind too!</p>

<p>GC is great for batch-processing, but real-time? It does not work in practice beyong toy samples.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/392398/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392472"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Real-time GC does not work, period.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 15:49 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/392472/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Rather it's general problem: you can't manage memory efficiently unless the program does it.</font><br>
<p>
OK...<br>
<p>
<font class="QuotedText">&gt; And if your program is accurate enough and careful enough with allocation of objects then it's usually easy to add manual allocation or trivial refcounting GC.</font><br>
<p>
If it is trivial then why do I have to do it myself?<br>
<p>
<p>
See also "GC allows for entirely different algorithms" somewhere here:<br>
<a href="http://www.azulsystems.com/blog/cliff-click/2009-09-06-java-vs-c-performanceagain">http://www.azulsystems.com/blog/cliff-click/2009-09-06-ja...</a><br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392472/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392577"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Real-time GC does not work, period.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 23:28 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/392577/">Link</a>] 
      </p>
      
      </div>
      </summary>
      It is trivial precisely because you <i>don't</i> have to do it yourself.
      
          <div class="CommentReplyButton">
            <form action="/Articles/392577/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor392589"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Real-time GC does not work, period.</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 1:07 UTC (Fri)
                               by <b>pflugstad</b> (subscriber, #224)
                              [<a href="/Articles/392589/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>GC is great for batch-processing, but real-time? It does not work in practice beyond toy samples.</blockquote>
<p>
Hmmm... Been there, done that: embedded system running RTOS and RT Java, driving an avionics Mil-Std-1553 bus at 50Hz with <30ms latency under heavy load for many hours.  Very non-trivial (several hundred thousand LOC).  
<p>
Yes we had to pay attention to memory allocations in the time critical code paths, but that was actually pretty easy.  And yes, we used the real-time GC that the RT Java gave us to essentially run in the background. 
<p>
And we had to tune some other parts of the code where some programmers had made some dreadful data structure choices (which worked find under low utilization, but didn't scale).  But mostly things worked and we didn't really pay much attention to memory allocations across the majority of the application.  No stop-the-world pauses, no burps in latency (which there were before we tuned). 
<p>
The key with the whole thing was to have enough memory available so the GC could come along behind and clean up without having to stop the rest of the system from running.  Similar tests on a much more memory constrained device did not scale as well - but not: it is just a matter of scaling. 
<p>
I'd done similar things on Windows with C/C++ and all the explicit memory management, so I'm very aware of the trade-offs.  I'll take the GC thank-you-very-much, and RT GC does work just fine, IMO. 

      
          <div class="CommentReplyButton">
            <form action="/Articles/392589/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor403699"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2010 20:00 UTC (Mon)
                               by <b>Blaisorblade</b> (guest, #25465)
                              [<a href="/Articles/403699/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Incremental, real-time GC has existed for some time now.</font><br>
Do you know how much slower it is? Like tens of percents in most cases?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/403699/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor409387"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Oct 10, 2010 1:18 UTC (Sun)
                               by <b>Blaisorblade</b> (guest, #25465)
                              [<a href="/Articles/409387/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I forgot to point out that one of their contributions is incremental GC with very small overhead.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/409387/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor392434"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 13:54 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392434/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
The correct solution is to avoid programs that depend heavily on garbage collection. 
</blockquote>
Like GCC! And Emacs! And Eclipse! hm, not sure what I'll write my code in now. vi, Notepad and TECO are still in the running.
<p>
(Your point is more valid for interactive programs, but as Emacs indicates, a sufficiently compelling program can cause people to put up with amazing delays, When I was running Emacs and X on a 6Mb 486 I regularly had to put up with 45s GC delays. I did so without -- much -- complaint.)

      
          <div class="CommentReplyButton">
            <form action="/Articles/392434/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392502"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 17:54 UTC (Thu)
                               by <b>dambacher</b> (subscriber, #1710)
                              [<a href="/Articles/392502/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
oh, emacs had this feature named "typing pause" nowerdays  for some years now.-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392502/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392847"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2010 20:19 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392847/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
typebreak.el is your friend :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392847/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor392578"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 23:39 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/392578/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You demonstrate the reach of ideology.  What a normal person would treat as a crippling bug, you take without complaint because the editor is written in what you think is a cool language.  But an awful lot of us do code in Vi, and have never suffered 45-second, or 2-second, pauses.  Does the GC explain why Gcc has got so slow? <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392578/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392792"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 21:33 UTC (Sat)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/392792/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; ... because the editor is written in what you think is a cool language.</font><br>
<p>
Please be serious: how emacs is made internally has nothing to do with why most people choose to use it. Most emacs users do not even know what LISP is (or even worse; they hate it as configuration file syntax), and they could not care less about a 2 seconds delay per week.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392792/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392858"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2010 21:05 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392858/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Actually I *did* start using Emacs because of the runtime configurability and extensibility (and learnt Lisp as a result and fell in love with it), but I know I'm weird.<br>
<p>
Its implementation language, of course, is partly ugly old Lisp and partly really rather nasty C (GCPRO, anyone?). The less that's in C and the more that's in Lisp, the better, as far as I'm concerned, but not because of the language -- more because, if it's in C, I can hack at it interactively, whenever I need to. :)<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392858/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor392848"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2010 20:23 UTC (Sun)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392848/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <blockquote>
Does the GC explain why Gcc has got so slow?
</blockquote>
Very possibly it does. When Apple was still contributing (back in the 4.0 days) someone (I think it was Mike Stump) ran shark over it, and saw a horrifying rate of L2 cache misses, something like one every twenty instructions if I recall. It appears that the GC's largest cost is not when it runs at all, but what it does to the program's locality of reference: scatters it all over the place, leading to absolutely pessimal cache behaviour.
<p>
GCC has been carefully migrating selected speed-critical things back into obstacks ever since: they may be really annoying (freeing must be in reverse order of allocation), but they are contiguous, and that's sometimes a major benefit.
<p>
(And, y'know, I did think that the 45-second pauses were a crippling bug, but then most other things on my system also had huge pauses at the time: 6Mb RAM in 1998 was not pleasant. The real problem was that my system was hugely under-RAMmed.)
<p>
With the smallest machine I regularly work on now having 12Gb RAM, it's amazing how little I can force myself to care about swap-induced problems and OOM. At least, for the next couple of years, until KDE4.9 or GNOME 3.5 bloats up and uses it all up again.

      
          <div class="CommentReplyButton">
            <form action="/Articles/392848/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor392440"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 14:32 UTC (Thu)
                               by <b>SEJeff</b> (guest, #51588)
                              [<a href="/Articles/392440/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Keep in mind that pauses of a few microseconds are way too much for certain environments (financial, aerospace, industrial, etc). Garbage collected languages in general are a serious problem in those sorts of environments.<br>
<p>
The problem is that a lot of colleges teach those gc'd languages and the skillset pool is rather deep. Also, lets not forget the argument for RAD. A mere mortal can generally crank out a lot more java/C#/&lt;insert_modern_garbage_collected_language_here&gt; than raw C. Not that I'm hating on C by any means, but it isn't unreasonable for them to want their cake and eat it too.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392440/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor392506"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Pauses</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 18:22 UTC (Thu)
                               by <b>iabervon</b> (subscriber, #722)
                              [<a href="/Articles/392506/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Until recently, Firefox was using a quite primitive JavaScript implementation. Avoiding stopping the world for GC is well-understood, but is only implemented when it seems important, because it involves a bunch of effort to implement. Even people implementing runtime systems are too lazy to implement all of the techniques they could use, when they aren't noticing performance problems that could be solved with those techniques. People don't choose a web browser based on whether it pauses with complex JavaScript; or, rather, they didn't until recently.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392506/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor392345"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 3:18 UTC (Thu)
                               by <b>russell</b> (guest, #10458)
                              [<a href="/Articles/392345/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How is this the kernel's problem?  Programs written in other languages don't seem to have this problem.  It seems to me to be just java.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392345/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392350"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 4:27 UTC (Thu)
                               by <b>elanthis</b> (guest, #6227)
                              [<a href="/Articles/392350/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Bullshit.  ALL GC languages have this problem.  The apps you see written in other languages besides C# and Java are just generally tiny little micro apps barely worthy of being called an actual "application."  They have small heap sizes, few allocated objects for the memory manager to deal with, and many are short-lived tools that will start and finish very quickly.<br>
<p>
When you start dealing with very, very large applications -- like an entire browser, office suite, Photoshop-esque image editor, long-running server process, game engine, or many scientific tools -- then the number of allocated objects is very high, the total amount of allocated memory is often high, and the memory manager deals with an awful lot of allocation churn.  These things are all really bad for most garbage collection algorithms.<br>
<p>
They're really not all that great for classic C/C++-style manual memory management, either.  A particularly good GC will actually be faster overall than even a well coded manual memory management using application.  The problem is that the manual memory management approach spreads all of its time out amongst every allocation and deallocation.  That means that there is never a big pause on one allocation only, and it also means that all the memory manager work happens at places in the code the programmer can easily identify.  With automatic memory management, a big chunk of the garbage collection process (possibly all of it) can happen at any allocation without any deterministic way to identify it.  Even with an incremental collector, this can lead to long pauses happening right in the middle of a relatively speed-sensitive bit of code; it's not a big deal if the GC happens during general idle loop processing in a GUI app but it can be noticeable if it kicks in during animation processing, for example.<br>
<p>
So anyway, yeah, all garbage collected languages have the problem, just most garbage collected languages don't have so much as a single app on the scale of what Java or C# are frequently used for.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392350/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392354"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 4:57 UTC (Thu)
                               by <b>skitching</b> (guest, #36856)
                              [<a href="/Articles/392354/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yep. Java's garbage-collection is pretty good; I wouldn't expect any language supporting GC to do much better. So I would bet this isn't java-specific.<br>
<p>
Note that Azul systems aren't just talking about "large apps like an office suite". They sell 54-core CPUs and java virtual machines designed to "scale to 670 GB of memory".<br>
<p>
So we are not talking about optimising applets here, but systems that can run stock markets, large brokerage houses, etc. But such applications are also sometimes sensitive to latency. The old "stop the world" garbage collectors would be a real problem here, but even "incremental" collectors may cause latencies to some threads.<br>
<p>
And (I haven't read the released code) perhaps they are more interested in moving some memory-management tasks from kernel to user-space. Things like large database systems often try to bypass OS behaviour and manage some things themselves (eg file caches) because they know better than the OS what the usage patterns are. Sounds plausable that a JVM may also have these needs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392354/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor392368"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 7:17 UTC (Thu)
                               by <b>helge.bahmann</b> (subscriber, #56804)
                              [<a href="/Articles/392368/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"A particularly good GC will actually be faster overall than even a well coded manual memory management using application."<br>
<p>
... but only when you are willing to throw about 4 times the memory an equivalent explicitly-managed program would use at the problem: <a href="http://www.cs.umass.edu/~emery/pubs/gcvsmalloc.pdf">http://www.cs.umass.edu/~emery/pubs/gcvsmalloc.pdf</a><br>
<p>
This unfortunately means that performance-wise garbage collection fares particularly badly with "large" applications where the working set size approaches the available RAM.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392368/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor392367"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">GC myth propagation</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 7:17 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/392367/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The assertion that GC systems may be faster than "manual" memory management is frequently made, but ill supported.  In particular, it's easy and, in academia, encouraged to rig tests to avoid interacting badly with virtual memory.  That's rarely so easy in Real Life.<br>
<p>
"Eager", by the way, would be a more accurate moniker for what is normally done in C++, as there memory management, with the aid of destructors, is no wise more manual than in Lisp.   Adopting the usage would allow GC promoters to hint at more honesty and scruples than their colleagues are inclined to exhibit.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392367/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor392464"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 15:42 UTC (Thu)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/392464/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"The apps you see written in other languages besides C# and Java are just generally tiny little micro apps barely worthy of being called an actual "application." They have small heap sizes, few allocated objects for the memory manager to deal with, and many are short-lived tools that will start and finish very quickly."<br>
<p>
<p>
Hmmm, that sounds like better memory management to me.  Good programmers have been writing small modular programs which do not live forever and work well together to create larger systems for decades.  There are many reasons for this and easier/better memory management is on the list.  <br>
<p>
Java programmers/system designers seem to be the only programmers in the world who do not take advantage of this model.  Maybe because with java, no one ever wants to leave the JVM, doing a fork from java is considered a horrible mistake (and will take many servers down)?  This NIH java disease is the reason that many java apps have horrible memory problems (a program already exists to do that, well, it's not in java... rewrite)  Without using pipes and forking, it is hard to create large robust modular programs in any language.  Only java programmers would even dream of it.  <br>
<p>
So, it is not java so much that is the problem, but the mindset when using it: I cannot fork, that would not be portable...(and uncool?)  Not to mention the slow JVM startup times.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392464/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392635"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 10:05 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/392635/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Without using pipes and forking, it is hard to create large robust modular programs in any language. </font><br>
<p>
Agreed.<br>
<p>
On the other hand, please tell us how to implement Eclipse or Emacs using a bunch of independent and loosely connected processes.<br>
<p>
Even better: please tell us how to implement something as powerful and fast as Linux using a micro-kernel and a bunch of loosely connected daemons :-P<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392635/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392671"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 15:48 UTC (Fri)
                               by <b>martinfick</b> (subscriber, #4455)
                              [<a href="/Articles/392671/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Eclipse -&gt; KDE (except KDE does so much more in so much less memory, and still, I would not call it efficient)<br>
Emacs -&gt; Vi + 1000 other small unix utilities<br>
<p>
Linux, well, we have to reverse things here a bit, linux is somewhat large, but still modularization was defined early by the original unix devs.  So the image looks more like this.<br>
<p>
multics -&gt; linux + 1000 other small unix utilities.<br>
<p>
<p>
Remeber how often the "do it in userspace" slogan is shouted from linux kernel devs.  Perhaps if the java devs used a bit more of this approach (i.e. do not use the same JVM for everything) they would not be suggesting to expand the kernel just so that JVMs can get bigger!  Note how different from normal scalable program requests that is.  This is not a request to" "be able to create 1 billion threads/processes and to switch efficiently and fairly among them", or "to communicate between them with low overhead"..., no it is a request to fundamentally support using larger and larger monolithic programs.  One might ask why the JVM even needs an OS, why not just run it straight on the iron and optimize the hell out of it, for this single use case, isn't that what the java devs really want? ;)<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392671/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor392365"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative kernel modifications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 7:04 UTC (Thu)
                               by <b>bgallmeister</b> (guest, #59580)
                              [<a href="/Articles/392365/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm one of the team at Azul working on these kernel-side changes.  You're right, we haven't talked with many folks about our enhancements yet. While we have had discussions with some in the kernel community, we've been unable to discuss our enhancements in the wider audience until the Managed Runtime Initiative was launched.<br>
<p>
We realize the kernel code we've just published as part of MRI is not yet ready for prime time, and will take iterations to wend its way upstream.  Right now, the code should be considered a basis for discussion.  It'd be good to have the conversation about the types of problems we're solving, and how we might improve our solutions.<br>
<p>
Until MRI kernel changes are perceived as solving a general problem in an acceptable, maintainable way, they're not going to be accepted by the Linux community.  That's fine, and it's why we published the code this week--so we could start talking about it.<br>
<p>
And, yeah, we know that facilities like pluggable memory managers and schedulers are...uh...contentious.  We thought this packaging was a bit more comprehensible than inline changes to all of the mm and sched code.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392365/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392392"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative kernel modifications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 10:05 UTC (Thu)
                               by <b>cesarb</b> (subscriber, #6266)
                              [<a href="/Articles/392392/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Let me see if I understood. You are saying "pluggable memory managers and schedulers" are not how it should be, but only a way of separating the code so it is easier to discuss? That is, the way you would really want it done is actually changing the core mm and sched code directly, instead of changing it to create a pluggable interface and then plugging the things you want done over it?<br>
<p>
I think everyone is going to discuss the "pluggable" part and ignore the rest of the code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392392/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392450"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative kernel modifications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 14:44 UTC (Thu)
                               by <b>giltene</b> (guest, #67734)
                              [<a href="/Articles/392450/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The purpose of releasing the code, and of the initiative as a whole, is to demonstrate the value of new functionality [as it pertains to improving runtime execution] and to advocate for the inclusion of such functionality in upstream projects and products. We think that "solving" garbage collection [across the 1GB-640GB range] is a pretty good demonstration, and will be interesting enough to consider the inclusion of the new functionality and interfaces that make it possible.<br>
 <br>
We fully expect that the code itself will morph 17 ways before it is accepted upstream. It's layout will change. It's APIs will change, and the functionality it provides will change, as people comment/argue about other generic uses of the same capabilities and how to best integrate the new functionality and interfaces with the existing ones [e.g. should/could everything be done under madvise? Should mmap be extended with new options?].<br>
<p>
Whether pluggable memory modules are good/bad will be a separate [sub]discussion - and we're not that attached to either form. It's a good development vehicle for now, and makes it convenient to focus most of the big functionality additions and new interfaces in isolated modules while their details are being ironed out and stabilized. Rapid fire changes to system calls is usually a bad thing, and a loadable module with ioctls allows for easier to experimentation and morphing. <br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392450/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392625"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative kernel modifications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 9:09 UTC (Fri)
                               by <b>cmot</b> (guest, #53097)
                              [<a href="/Articles/392625/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I have the suspicion that a large (and apparently under-documented) code dump like this will never seriously be looked at in depth.<br>
<p>
The way to get code in the kernel has always been small, incremental steps (or subsystems that are well isolated and speak to the kernel using established APIs, like new filesystems/drivers/... - but memory management and CPU scheduling code is probably not in this category...)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392625/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392633"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative kernel modifications</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 9:59 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/392633/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I have the suspicion that a large (and apparently under-documented) code dump like this will never seriously be looked at in depth.</font><br>
<p>
All good then, since the post you are replying to explains this was not a goal.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392633/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor392474"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 16:08 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/392474/">Link</a>] (22 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I seriously doubt that the Linux community would even consider any discussion from strangers about such core topics like memory and scheduling unless it is backed by hard facts (and even less if keywords like "java" of "GC" are used)<br>
<p>
In such a case the only way to get attention might be to start by publishing (ugly but) running code demonstrating the room for improvement in a non-refutable way.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392474/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392484"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 16:38 UTC (Thu)
                               by <b>giltene</b> (guest, #67734)
                              [<a href="/Articles/392484/">Link</a>] (21 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yup. That's exactly what we did. This is working, running code. It exhibits 100x improvements in managed runtime metrics like responsiveness, sustainable memory size, and object allocation rates (which translate linearly to sustainable transaction rates). It [hopefully] proves that this can actually be done, and that it's probably a good idea to do it. How exactly to integrate it upstream will be a long and interesting discussion.<br>
<p>
We've brought the beef. Let the chopping  begin. And here's hoping that at the end of it, we can remove "java" and "GC" from the bad words category for Linux community.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392484/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392490"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The beef</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 16:49 UTC (Thu)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/392490/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      What you've brought is a dump of code, in an obscure format, in an obscure place.  It's a start, but if you are serious about upstreaming this, you need to get onto linux-kernel and start discussing it with people.  I would recommend picking one smallish piece to start with, clearly describe your requirements and the reasons why you chose the solution you did.  Then be prepared to take a bit of grief; you really should have done this some time ago...  Still, if you can show real improvements to real workloads (and it appears you can), you have a basis to start with.
      
          <div class="CommentReplyButton">
            <form action="/Articles/392490/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392636"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The beef</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 10:11 UTC (Fri)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/392636/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; if you are serious about upstreaming this, you need to get onto linux-kernel and start discussing it with people.</font><br>
<p>
Maybe all you people can stop agreeing so much with each other.<br>
<p>
<font class="QuotedText">&gt; you really should have done this some time ago...</font><br>
<p>
I still do not understand why. Wakelock trauma? This case looks very different.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392636/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392790"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The beef</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 21:52 UTC (Sat)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/392790/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
wakelocks is just the most recent of a long stream of features which were developed outside the kernel.  It's just a painful thing whether it's CML2 or Xen.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392790/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor392576"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 23:26 UTC (Thu)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/392576/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"Java" and "GC" are bad words anywhere outside the walled garden.  You won't change that by demanding fundamental changes in schedulers and kernel memory management in order to get tolerable performance that normal programs get without.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392576/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392591"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 1:27 UTC (Fri)
                               by <b>giltene</b> (guest, #67734)
                              [<a href="/Articles/392591/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's a pretty big garden [Java, .NET, Python, ruby, etc.], It's more like the wide open space where most of the world actually is, and the walls seem to be around the rest of the [non managed runtime] world these days. Most enterprise scale apps written in the last several years run on managed runtimes. Most modern frameworks and reusable code bases target them, the vast majority of the world's programmers build software for them. Furthermore, apps running on managed runtimes tend to handle stuff with scales and complexities that nothing else tries to. Why? We don't really know. It's just reality.<br>
<p>
It does have some pesky issues. Like GC, but those can actually be solved. We've shown that. It's just that [at least the one way we know of for] solving them does require fundamental changes to things like kernel memory management. Some of the core operations we are advocating for make an actual 1,000,000x difference to how critical phases of GC behave, thereby making the difference between a practical, no-more-puases GC world, and the current one. [For some operation metrics numbers, see <a href="http://www.managedruntime.org/files/downloads/AzulVmemMetricsMRI.pdf">http://www.managedruntime.org/files/downloads/AzulVmemMet...</a> ]<br>
<p>
Does that make such fundamental changes worthwhile? We think so. Some may not.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392591/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392672"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 16:19 UTC (Fri)
                               by <b>jzbiciak</b> (guest, #5246)
                              [<a href="/Articles/392672/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <P>As an outsider looking in, these batch virtual memory operations sound interesting in their own right, and not specifically related to Java and GC.  It's just that your Java GC can make immediate use of them.  
</P><P>
This seems like a similar transformation to providing a vector of IO operations, versus repeated calls to read() or write().  
</P><P>
What other workloads might benefit from such batch-oriented VM?  Poul-Henning Kamp had an article <A HREF="http://queue.acm.org/detail.cfm?id=1814327">in ACM Queue</A> recently that showed a 10x speedup on heap structures by avoiding VM hits.  While not identical to the problem you're solving, I think it highlights that explicitly optimizing VM behavior, even on "solved problems," is a generally interesting space, with opportunities for huge improvements.  After all, heaps are "optimal," right?  Then why the 10x speedup?  Finding how your work can be leveraged outside your Java GC environment will make it more attractive.</P>
      
          <div class="CommentReplyButton">
            <form action="/Articles/392672/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392745"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 5:45 UTC (Sat)
                               by <b>giltene</b> (guest, #67734)
                              [<a href="/Articles/392745/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Good point about relevance outside of GC, Java, and Runtimes. There certainly may be uses in other workloads (in memory DBs? DBs in general? Sparse memory applications that rely on virtual memory tricks?). In general, current virtual memory implementations in almost all OSs assume that virtual memory manipulation is a relatively rare event, and we have put forward an algorithm and an application for rapidly-changing mappings that makes a real difference to a vast array of applications, but it can't do so within the limitations of current virtual memory APIs and manipulation speeds.<br>
<p>
We built the enhanced APIs to be generic [we think], without assumptions about the user-level code being a runtime, and focusing on the needed functionality and semantics. Our GC code is all in user space (part of the OpenJDK based code we put up along with the kernel mods)  - it just needs some very scalable and somewhat different virtual and physical memory manipulation semantics form the kernel.<br>
<p>
So yes, there can certainly be other uses for batched virtual memory operation with extremely fast commit times, and for other features like explicit-TLB-invalidate semantics (allowing user process to determine when a TLB invalidate is required, instead of issuing one per page), scalable virtual memory manipulation (not done under process-global lock), large page support that includes remapping capability, user-controlled shatter/unshatter transitions from large to small mappings while retaining large physical page layouts, etc.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392745/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392990"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2010 20:56 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/392990/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
A good few of these features seem like things that could be useful for things like user-mode-linux as well (and anything else that has to manipulate a *lot* of mappings).<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392990/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor392677"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 16:28 UTC (Fri)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/392677/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
While managed runtimes is as you say a large set, I don't hear about these sorts of nasty stalls in eg python, ruby, very much.  They definitely come up in java all the time.  I would get them when i developed back in 2005 on mono, but assumed that was immaturity (they were using a relatively naive boehm at the time).<br>
<p>
I always assumed the pervaisve and unpleasant nature of this problem was simply Sun's inability to make java a real platform for beyond a relatively narrow set of environments.  It seemed like the other kids all came up with solutions that worked for them.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392677/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392719"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 18, 2010 22:19 UTC (Fri)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/392719/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Python certainly does have GC stalls. <br>
<p>
But, python already has such poor performance, and, especially, cannot be running multiple threads at once, that it doesn't come up that much. People just don't use python for the kinds of applications that demand high performance with high allocation rates on 12 threads at once...<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392719/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor392753"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 8:46 UTC (Sat)
                               by <b>vachi</b> (guest, #67512)
                              [<a href="/Articles/392753/">Link</a>] (10 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I guess JVM is one of the most used VM in large and complex enterpise app. That's why most complaints are heard from that direction. By the way, I don't hear about complaints regarding scheduler performance of DOS nowadays. DOS must have a pretty good scheduler compared to Linux.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392753/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392784"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 19:19 UTC (Sat)
                               by <b>k8to</b> (guest, #15413)
                              [<a href="/Articles/392784/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Nah, the behavior is quite different.  Sun JVM seems very good at keeping a large number of objects in memory and stalling reclaiming their space until it can do a large number at once, causing stalls, and wasting memory.  Other sytems, like Python, seem to reclaim the objects much more incrementally which might not be as effecient in a long term view.<br>
<p>
Meanwhile, we can deconstruct your analogy by pointing out that DOS does not have a scheduler.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392784/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392788"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 19:51 UTC (Sat)
                               by <b>foom</b> (subscriber, #14868)
                              [<a href="/Articles/392788/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The Sun JVM has many different GC options. If you want lower throughput, but smaller pauses,  you can use the collector designed for doing just that: the concurrent collector. <br>
<p>
Use option -XX:+UseConcMarkSweepGC.<br>
<p>
For more information, see this article: <br>
<a href="http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html">http://java.sun.com/javase/technologies/hotspot/gc/gc_tun...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392788/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 19, 2010 23:37 UTC (Sat)
                               by <b>giltene</b> (guest, #67734)
                              [<a href="/Articles/392797/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
All current commercial forms of GCs on large scale runtimes include code that compacts the object heap in a stop-the-world operation. Compaction is unavoidable in long lived applications that use variable sized objects (e.g. XML data). Most GC setups can be tuned in various ways to delay this inevitable compaction, but none can avoid it. Think of it as a ticking time bomb - do enough work, and you'll need to defragment the heap because your new object can't fit in any of the empty spaces you've been tracking.<br>
<p>
The duration of the stop-the-world pause in all current JVM GC's is generally linear to the amount of live data the heap contains (you have to scan all that stuff and fix all the pointers to the relocated objects). This means that the larger the heap - the larger the pause. Sun's CMS (the Mostly Concurrent Mark Sweep -XX:+UseConcMarkSweepGC mentioned above) will delay the compaction as long as it can and track empty spaces in free lists, but it will eventually fall back on it's compaction code and pause for about 2-4 seconds per live gigabyte on a modern x86-64 machine. This is why JVMs are generally not used with more than a few GB of data, except for batch apps (ones that can accept a 10s of seconds of complete pause). Since a 256GB server now costs less than $18K, there is a ~100x and growing gap between commodity server capacity and the ability for individual runtime to scale with acceptable response times.<br>
<p>
The Pauseless GC algorithm and implementation put forward as part of the Managed Runtime Initiative changes all this. It compacts the heap and fixes up pointers concurrently, without having to stop the world to do so. As a result, response time is completely decoupled from memory size, and indirectly from allocation rate and throughput, breaking the 100x logjam.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392829"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 20, 2010 17:19 UTC (Sun)
                               by <b>rilder</b> (guest, #59804)
                              [<a href="/Articles/392829/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Looks interesting. However recently I read about commits related to memory compaction and transparent huge pages. These you may find useful in your work.<br>
Also in your current implementations. are VMs treated differently wrt memory management. There also have been commits wrt VMs for memory ballooing etc.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392829/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor392872"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 21, 2010 4:06 UTC (Mon)
                               by <b>giltene</b> (guest, #67734)
                              [<a href="/Articles/392872/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Both transparent huge page support and compaction (which transparent huge pages cannot reliably be done without) are good things. We may be able to merge some of our functionality with those over time. We are certainly large consumers of 2MB pages, so we see compaction as very important, and with it we may be able to provide transparent, reliable dynamic allocation of 2MB pages in our subsystem. Without compaction, pages must be explicitly funded and taken away from the kernel upfront, since fragmentation may make it impossible to get hold of them later.<br>
<p>
Due to various needs though, our current implementation a separate physical memory management subsystem. The main, overriding need for this is the avoidance of unnecessary TLB invalidates when physical pages are unmapped and mapped [a bit later] within the same process - this is the most frequent pattern across the pauseless collector and the application mutators, and addressing it pretty much requires process-local free lists, which we use. <br>
<p>
WRT VMs (e.g.. running this kernel as a guest on top of  KVM or VMWare), we see those as common targets. Because the rate of virtual memory mapping changes in our system is quite substantial (well over 1000x compared to the typical OS and application loads), we care a lot about the cost of those manipulations in virtualized environments. Luckily EPT (Intel) and NPT/RVI (AMD) features in all modern x86-64 machines practically eliminate this cost, taking the hypervisor out of the business of intercepting, tracking, and applying guest-virtiual to guest-physical mappings. Without those HW assisted features, applying changes at the rate we do would certainly "hurt" on virtualized systems.<br>
<p>
We'll also be able to play with memory ballooning, and we've got some very good uses for it, but the current implementation we've posted doesn't. When we do, we'll be looking to deflate balloons at sustained rates of several GBs per second, which will probably put some serious stress on current host implementations. This is one of the items at the hypervisor level that we're going to be playing with as part of the Managed Runtime Initiative [large page and high sustained rate ballooning]. At first glance, KVM's handling of ballooning seems like it can easily be extended to accommodate what we'll need.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392872/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor393292"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 23, 2010 17:06 UTC (Wed)
                               by <b>jonabbey</b> (guest, #2736)
                              [<a href="/Articles/393292/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Have you characterized the performance of Sun's G1 collector that they will be using in Java 7?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/393292/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor393898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 27, 2010 0:00 UTC (Sun)
                               by <b>giltene</b> (guest, #67734)
                              [<a href="/Articles/393898/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
We're obviously been following G1's progress and the algorithm it uses. Its' hard to "characterize the actual performance" of G1 right now given it's current experimental state [simple experiments right now show longer pauses than HotSpot's production CMS collector]. However, analyzing G1's basic mechanisms is pretty straight forward. Here is how they can be classified:<br>
<p>
1) A concurrent, multi-pass OldGen marker<br>
2) An incremental, stop-the-world OldGen compactor<br>
3) A stop-the-world NewGen copying collector<br>
<p>
It's the stop-the-world nature of (2) and (3) above that determine pause behavior for large heap and high throughput applications. When object copying and/or compaction are done in a stop the world operation, moving even a single object in memory requires that *all* references to that object in the heap be tracked down and corrected before the program is allowed to continue execution. This takes an amount of time bound only by the size of the heap (i.e. it takes a multi-seconds-per-live-GB pause to find all those references). While a lot of cool code and tuning goes into making such long pauses spaced out in time, all stop-the-world-compaction collectors (including G1) will periodically fall back on their full stop the world compaction code when dealing with complex heaps. [The collector's elaborate code for doing that operation is there for a reason]. For applications that cannot accept the "occasional 50 seconds pause" during normal operation, this means heap size is still limited by pause time.<br>
<p>
In contrast, The GPGC algorithm used in both Azul's Zing VM and in the Managed Runtime Initiative contribution (and in the default, production collector for Azul Vega systems since 2005), can be classified as:<br>
1) A concurrent, guaranteed-single-pass OldGen marker<br>
2) A concurrent OldGen compactor<br>
3) A concurrent, guaranteed-single-pass NewGen marker<br>
4) A concurrent NewGen compactor<br>
<p>
Concurrent [as opposed to incremental stop-the-world] compaction is the key here. It completely decouples application pause behavior from heap size and allocation rates, and allows us to deal with the amounts of memory prevalent in todays servers without those nasty many-seconds pauses. GPGC simply doesn't have any form of stop-the-world compaction code in it [as a fall back or otherwise]. It doesn't need it.  In GPGC, objects are relocated without having to stop the application while all references to them are tracked down and fixed. Instead, ref remapping is a concurrent operation supported by self-healing read barriers.<br>
<p>
It's the software pipeline used to support this concurrent compaction (and guaranteed-single-pass marking) that needs the new virtual memory operations we've put forward.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/393898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor403725"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2010 22:20 UTC (Mon)
                               by <b>Blaisorblade</b> (guest, #25465)
                              [<a href="/Articles/403725/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
Nah, the behavior is quite different. Sun JVM seems very good at keeping a large number of objects in memory and stalling reclaiming their space until it can do a large number at once, causing stalls, and wasting memory. Other sytems, like Python, seem to reclaim the objects much more incrementally which might not be as effecient in a long term view.
</blockquote>
<p>
As just said elsewhere by Nix, since Python uses standard reference counting, it is not efficient even in the short term view, because copying a pointer to the stack causes a heap mutation, even to pass a parameter to a procedure. That's why trying to support multithreading gave a 2x slowdown. Given that other portions of code have been optimized, I believe the slowdown nowadays would be bigger. And the slowdown you get with Java and a smaller heap is probably still not comparable to the one you get in Python (no less than 10x).
</p>
<p>
Python apps seems to have decent performance when they do little, and the rest is written in C, but as soon you try to actually do something with Python code, you lose. I don't get how the same community, which prefers C to Java for performance reasons, can even mention Python. I hope it's not the same people at least.
</p>
<p>
There are many realtime GCs, and each of them is better than Python's one.
In particular, Cliff Click described the pauseless GC, with its amazing performance and small overhead, somewhere on <a href="http://www.azulsystems.com/blogs/cliff/">this blog</a>, which I recommend for those interested in the field (even if quite technical). However, he describes their special CPU, but it seems they could port it to x86, and the code is in this release.
</p>
<p>
For Python, refcounting was just a bad choice in the beginning, and it's now impossible to get rid of it without rewriting everything - and they don't have the man power nor the will. And all of this was well-known, people implementing Lisp, Smalltalk, Self, knew it for the last 20 years, together with a number of other techniques.
</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/403725/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor403733"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2010 23:13 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/403733/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
since Python uses standard reference counting, it is not efficient even in the short term view, because copying a pointer to the stack causes a heap mutation, even to pass a parameter to a procedure. That's why trying to support multithreading gave a 2x slowdown.
</blockquote>
Oh no, there are much more appalling reasons why Python's multithreading is awful. The GIL acquisition macros were never designed with multiple CPUs in mind: on a one-thread-of-execution machine (what we used to call 'one CPU'), it all works fine, but if there's more than one, they race with each other and often end up bouncing ownership back and forth and both blocked for astounding periods of time. There's an awesome <a href="http://blip.tv/file/2232410">presentation</a> on the subject, strongly recommended.
      
          <div class="CommentReplyButton">
            <form action="/Articles/403733/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor404498"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 10, 2010 21:07 UTC (Fri)
                               by <b>Blaisorblade</b> (guest, #25465)
                              [<a href="/Articles/404498/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Ah, that's right, I even knew of that presentation (and watched it again). I kind-of guessed that people were working on that (without any evidence other than "somebody noticed"), and I had no idea about how to fix that.<br>
<p>
Moreover, there was work (from Antoine Pitrou IIRC) to change the policies of the GIL - it was/is released/reacquired every 100 opcodes (which might be ridiculously small or too large, depending on the opcodes), while A. Pitrou wanted to have some saner scheduling.<br>
<p>
Releasing it every timeslice (i.e. ~80/100 ms IIRC) would probably help with the problems of that presentation - I should have another look to know if this makes sense. A simple user-level scheduler for GIL acquisition would maybe be needed in the worst case, but hopefully not.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/404498/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor392488"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">The Managed Runtime Initiative</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 17, 2010 16:39 UTC (Thu)
                               by <b>linusw</b> (subscriber, #40300)
                              [<a href="/Articles/392488/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The talk about the patches providing "a cpu resource guarantee (...) that any process with 'committed' cpus and runnable threads available for those cpus will have its threads running on those cpus within 10ms." sounds like a clever way to reinvent cpusets + the new SCHED_DEADLINE scheduling class.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/392488/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor403730"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why real Unix developers should avoid C, by Eric S. Raymond</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 6, 2010 22:57 UTC (Mon)
                               by <b>Blaisorblade</b> (guest, #25465)
                              [<a href="/Articles/403730/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
To all those complaining against Java supposed slowness, have a look at a couple of sections of "The Art of Unix Programming" by Eric S. Raymond, and at the amount of Unix applications not written in C:<br>
<p>
Why not C? - (<a href="http://catb.org/esr/writings/taoup/html/why_not_c.html">http://catb.org/esr/writings/taoup/html/why_not_c.html</a>)<br>
Language Evaluations (<a href="http://catb.org/esr/writings/taoup/html/ch14s04.html">http://catb.org/esr/writings/taoup/html/ch14s04.html</a>)<br>
<p>
Moreover, think to the amount of security bugs due to C string and memory management. It is true that even C++ gets it more correct, and that IMHO NULL-termined strings were a bad idea even for C (say, because of strlen being O(n)); but many problems are due to C itself (dangling pointers, anyone?).<br>
<p>
Writing a project in C, in most cases, is premature optimization, the root of all evil.<br>
<p>
The only problem is that Java's tuning has given horrible startup performance, and that it's not tuned to perform well on small apps.<br>
<p>
But nowadays even Eclipse and NetBeans can run in amounts of memory comparable to web browsers, and more reliably - I know of no web browser without massive memory leaks, even though I admittedly open many tabs - but that's no reason for leaking 5 times the memory you need. Might work on a OS which crashes before the few days you need to get that much leaked, not on Linux (and for what I hear, not even on most recent Windows systems).<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/403730/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2010, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
