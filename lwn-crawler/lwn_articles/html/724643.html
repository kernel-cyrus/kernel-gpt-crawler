        <!DOCTYPE html>
        <html lang="en">
        <head><title>Waiting for entropy [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/724643/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/724455/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/724643/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>Waiting for entropy</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Benefits for LWN subscribers</b>
<p>
The primary benefit from <a href="/Promo/nst-nag5/subscribe">subscribing to LWN</a>
       is helping to keep us publishing, but, beyond that, subscribers get
       immediate access to all site content and access to a number of extra
       site features.  Please sign up today!
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>June 6, 2017</br>
           </div>
Many bytes have been expended over the years discussing the virtues of the
kernel's random number generation subsystem.  One of the biggest recurring
concerns has to do with systems that are unable to obtain sufficient
entropy during the boot process to meet early demands for random data.  The
latest discussion on this topic got off to a bit of a rough start, but it
may lead to an incremental improvement in this area.
<p>
Jason Donenfeld <a href="/Articles/724644/">started the thread</a> with
a complaint that <tt>/dev/urandom</tt> will, when read from user space,
return data even if the kernel's internal entropy pool has not yet been
properly seeded.  In such a case, it is theoretically possible for an
attacker to predict the not-so-random data that will be returned.  He
asserted that <tt>/dev/urandom</tt> should simply block until the entropy
pool is ready, and dismissed the reasoning behind the current behavior:
"<q>Yes, yes, you have arguments for why you're keeping this
pathological, but you're still wrong, and this api is still a bug.</q>"
<p>
Bug or not, as Ted Ts'o <a href="/Articles/724645/">pointed out</a>, making
<tt>/dev/urandom</tt> block causes distributions like Ubuntu and OpenWrt to
fail to boot.  That sort of behavioral change is typically called a
"regression", and regressions of this sort are not normally allowed.  So
<tt>/dev/urandom</tt> will retain its current behavior.  But that isn't
the point Donenfeld was really trying to address anyway.

The real issue, as it turns out, has to do with getting random data from
within the kernel instead of from user space.  That can be done with a call
to: 
<p>
<pre>
    void get_random_bytes(void *buf, int nbytes);
</pre>
<p>
This function will place <tt>nbytes</tt> of random data into the buffer
pointed to by <tt>buf</tt>; it will do so regardless of whether the entropy
pool is fully initialized.  So, once again, it is possible to get data that
is not truly random.  Since this function is called from inside the kernel,
those calls can happen early in the boot process, so the chance of
encountering an insufficiently random entropy pool are relatively high.
<p>
This problem is not unknown to the kernel development community, of
course.  In 2015, Stephan Mueller <a href="/Articles/724650/">proposed</a>
the addition of a 
version of <tt>get_random_bytes()</tt> that would block until the entropy
pool is ready, should that be necessary.  That idea ran into trouble,
though, when Herbert Xu <a href="/Articles/724651/">pointed out</a> that it
could 
lead to deadlocks — just the sort of random event that tends <i>not</i> to
be of interest.  So, instead, a callback interface was created.  Kernel
code that wants to ensure that it gets good random data starts by creating
a callback function and placing a pointer to that function in a
<tt>random_ready_callback</tt> structure:
<p>
<pre>
    struct random_ready_callback {
	struct list_head list;
	void (*func)(struct random_ready_callback *rdy);
	struct module *owner;
    };
</pre>
<p>
That structure is then passed to <tt>add_random_ready_callback()</tt>:
<p>
<pre>
    int add_random_ready_callback(struct random_ready_callback *rdy);
</pre>
<p>
When the random-number subsystem is ready, the given callback function will
be called.  By adding some more structure (most likely using a completion),
the calling code can create something that looks like a synchronous
function to get random data.
<p>
As Donenfeld pointed out, this interface is a little bit on the cumbersome
side, which may have something to do with the fact that it has exactly one
call site in the kernel.  He suggested that it might make sense to add a
synchronous interface that could be used in at least some situations; that
would make it possible to fix some places in the kernel that are at risk of
using nonrandom data.  Ts'o <a href="/Articles/724648/">agreed</a> that
this approach might make sense:
<P>
<div class="BigQuote">
	Or maybe we can then help figure out what percentage of the
	callsites can be fixed with a synchronous interface, and fix some
	number of them just to demonstrate that the synchronous interface
	does work well.
</div>
<p>
The end result was <a href="/Articles/724599/">a patch series</a> from
Donenfeld adding a new function:
<p>
<pre>
    int wait_for_random_bytes(bool is_interruptable, unsigned long timeout);
</pre>
<p>
As its name might suggest, <tt>wait_for_random_bytes()</tt> will wait until
random data is available.  If <tt>is_interruptable</tt> is set, the
function will return early (with an error code) should the calling process
receive a signal.  The <tt>timeout</tt> parameter can be used to put an
upper bound on how long the call will wait.  This functionality turned out
to be a bit more than was needed, though; in particular, Ts'o
<a href="/Articles/724649/">expressed skepticism</a> about the
timeout idea, asking: "<q>If you are using get_random_bytes()
for security reasons, does the security reason go away after 15
seconds?</q>"  The <a href="/Articles/724671/">third version of the patch
set</a> removed all of the arguments to <tt>wait_for_random_bytes()</tt>,
making all waits interruptible with no timeout.  
<p>
The patch series then adds a
set of convenience functions to combine  waiting and actually getting the
random data, including:
<p>
<pre>
    static inline int get_random_bytes_wait(void *buf, int nbytes);
</pre>
<p>
Most of the comments on the patch set at this point are about relatively minor
issues. 
So chances are that some version of this patch set will find its way into the
kernel eventually, with the result, hopefully, that there will be a reduced
chance of kernel code using insufficiently random data.  But there is one
other aspect of this situation that seems entirely deterministic: the arguments
about the quality of the kernel's random-number subsystem are far from
finished.  That is, after all, the fundamental problem with random numbers:
it is difficult to be sure that they are truly random.<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Random_numbers">Random numbers</a></td></tr>
            <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Security-Random_number_generation">Security/Random number generation</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Linux_kernel-Random_number_generation">Linux kernel/Random number generation</a></td></tr>
            <tr><td><a href="/Security/Index/">Security</a></td><td><a href="/Security/Index/#Random_number_generation">Random number generation</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/724643/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor724703"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Waiting for entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 16:13 UTC (Tue)
                               by <b>arjan</b> (subscriber, #36785)
                              [<a href="/Articles/724703/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
entropy is a hard thing.<br>
<p>
On the one hand, the hardcore crypto/random folks want to raise the bar (and block more), which from a strict perspective makes sense,<br>
<p>
On the other hand, the result ends up hurting higher layers in the stack, and apps and libraries then sadly decide to implement their own poor PRNG instead, with a worse result.<br>
<p>
<p>
I suppose the good news is that many modern cpus have instructions to get random numbers, and while the hardcore folks are very skeptical about those for /dev/random use, I can imaging /dev/urandom able to use them...<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724703/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor725050"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Waiting for entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2017 15:44 UTC (Mon)
                               by <b>dany</b> (guest, #18902)
                              [<a href="/Articles/725050/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
if that CPU instruction is available, /dev/urandom and /dev/random already use it (will mix bytes from this instruction into entropy pool)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725050/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor724708"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 16:28 UTC (Tue)
                               by <b>hsivonen</b> (subscriber, #91034)
                              [<a href="/Articles/724708/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Is there a reason better than NIH for not adopting the OpenBSD approach of making it the bootloader's responsibility to supply a seed to the kernel by having the boot loader read the seed from the disk from a location where the kernel wrote a seed when the system was previously running?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724708/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724713"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 17:04 UTC (Tue)
                               by <b>smurf</b> (subscriber, #17840)
                              [<a href="/Articles/724713/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It's still a regression if you boot a new kernel without that bootloader. OpenBSD controls userspace, it do this. Linux cannot, and some embedded systems don't _have_ boot loaders which can be adapted to do so.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724713/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor724714"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 17:10 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/724714/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Because not every system *has* a bootloader any more. In fact, a number of kernel developers consider the ideal state to be the bootloaderless state: it's one less famously unreliable moving piece to break.<br>
<p>
In particular, reading modern filesystems from a bootloader is a disaster waiting to happen: it's barely safe to read ext2 or FAT (with the only problem being the need to write yet more code to read filesystems when the kernel already contains perfectly good code to do just that), but as soon as you're reading a journalled filesystem, you really must replay the journal too. GRUB doesn't, leading to disaster on XFS, at least (since XFS considers everything committed to disk once it's committed to the journal, since, well, it is). Heck, in XFS the journal location can specified via a mount-time option if you're using an external journal: how on earth do you pass that to the bootloader? So there is nowhere safe to write the information out, unless you write it to a FAT filesystem or something simple like that.<br>
<p>
Better to toss all that crap out of the window if possible and let the firmware handle the problem of picking an OS to load. Some EFI implementations can do this quite well (but, sigh, not all, hence the need for things like rEFInd for systems with EFI implementations too crap to let you choose among CONFIG_EFI_STUB-compiled kernels on the EFI System Partition). This does then mean that the kernel has to get randomness somehow, but surely *it* is better able to get some randomness from somewhere on the disk than the bootloader? It already has tested, working filesystem access code, after all.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724714/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724722"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 18:30 UTC (Tue)
                               by <b>jdulaney</b> (subscriber, #83672)
                              [<a href="/Articles/724722/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, in theory the kernel has tested, working file system code.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724722/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724724"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 18:35 UTC (Tue)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/724724/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It has filesystem code you're already relying on in any case. :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724724/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724899"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2017 12:31 UTC (Fri)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/724899/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
And not being able to do this everywhere is no reason to not do it on at least one set of systems that *are* capable of supporting it.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724899/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor724743"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 22:19 UTC (Tue)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/724743/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  It already has tested, working filesystem access code, after all.</font><br>
<p>
So does the firmware. Just stash something on the ESP and read it in the boot stub (or use the EFI RNG interface if it's present). We'll just handwave about the risk of having your seed stored unencrypted…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724743/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724774"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2017 14:47 UTC (Wed)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/724774/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yes, that's actually what I was driving at. :)<br>
<p>
I suppose you can encrypt the thing via the TPM at read time or something, to ensure that an attacker who removes the disks and reads the seed state still can't tell what the seed will be without also attacking the TPM, which we assume to be difficult to do undetected. (The usual objections to use of the TPM for anything, notably that it's really slow and that there isn't really very much information you actually want to become unreadable if your motherboard fails, don't apply here: the random seed is *random*, after all: all you're using the TPM for here is to make sure that the contents of the entropy pool are hard to predict from the entropy on the disk.)<br>
<p>
This does seem like a rather extreme scenario to me, though it's so easy to defend against I might go off and hack this up just to learn something about EFI programming! Once the machine is booted the on-disk seed is useless and probably deleted: this is very much a defense against the sort of evil maid who not only sticks a USB into your machine but boots off a USB disk and clones the quiescent internal disk while you're out, and then finds a useful way to use that information before the entropy pool gets more unpredictable state dumped into it a few seconds into your next boot. I suppose if you were regenerating an SSH key on every boot this would let the attacker derive that, but... who does that except on a machine with no persistent storage at all? Even SSL session keys, etc, are generally derived long after the crucial instants.<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724774/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724776"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2017 15:22 UTC (Wed)
                               by <b>mjg59</b> (subscriber, #23239)
                              [<a href="/Articles/724776/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Of course, if you've got a TPM you've also got a hardware RNG…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724776/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor728454"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 20, 2017 19:05 UTC (Thu)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/728454/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;This does then mean that the kernel has to get randomness somehow, but surely *it* is better able to get some randomness from somewhere on the disk than the bootloader? It already has tested, working filesystem access code, after all.</font><br>
There's another alternative: store and load the entropy seed via pstore. Works on EFI, KVM and a few other platforms, no block device necessary. (and with the recent addition of in-kernel TLS, that opens the door to horrible ideas like netboot over HTTPS)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/728454/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor728555"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 21, 2017 21:37 UTC (Fri)
                               by <b>smckay</b> (guest, #103253)
                              [<a href="/Articles/728555/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Do you need TLS in the kernel? I'm pretty sure iPXE supports HTTPS already.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/728555/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor728674"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 24, 2017 16:55 UTC (Mon)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/728674/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
My only worry about pstore is that with occasional reports of machines getting bricked by use of pstore I'm frankly scared to turn it on on anything but sacrificial machines...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/728674/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor728737"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 25, 2017 14:59 UTC (Tue)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/728737/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
You might be confusing it with the efivarfs problem (where rm -rf could brick the chipset). pstore is a different interface to the same storage area, but it's currently append-only. The one likely failure mode I'm aware of with it is the EFI variable store itself can become full if your system's crashing in a loop and set to dump panic logs there.<br>
<p>
(I saw a colleague going in circles for hours trying to debug why their EFI bootloader changes weren't surviving a reboot, turns out it was that and the kernel wasn't yelling -ENOSPC at efibootmgr when it should've...)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/728737/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor729168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 28, 2017 20:31 UTC (Fri)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/729168/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, that was my confusion, indeed. Thanks for clearing it up.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/729168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor724752"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2017 7:34 UTC (Wed)
                               by <b>matthias</b> (subscriber, #94967)
                              [<a href="/Articles/724752/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Many home routers initialize their private keys on first boot. There is no entropy available that could be read from disk (or whatever). I once read a report, which I do not find any more that harvesting many public keys from home routers yields a surprising number of pairs of public keys, where the gcd is greater than one. This allows for trivial factorization and thus breaking the encryption. The reason was insufficient entropy at first boot.<br>
<p>
Unfortunately the installation images are identical on first boot. A seed would be the same on all identical routers providing no entropy at all.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724752/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724900"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2017 12:34 UTC (Fri)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/724900/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This can be fixed in the distribution. I have patched embedded distros to both add a random seed (obtained from the build host) into the image *and* another small one (obtained from the host the imaging script is run on) during the time the image is installed/flashed onto the target.<br>
<p>
Later firmware upgrades would then “just” need to carry over an entropy seed to the upgraded version before booting into it.<br>
<p>
And if you combine this with bootloader and kernel patches to pass (part) of such entropy to the kernel before handing control over to it, you win. (No, we did not do that for Linux back then.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724900/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor725044"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Why not involve the boot loader</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2017 13:55 UTC (Mon)
                               by <b>error27</b> (subscriber, #8346)
                              [<a href="/Articles/725044/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That was some years ago.  I think we fixed this by feeding a bunch of stuff like mac address into the entropy pool.  It's not really random but at least it's not exactly the same for every system on the internet so you don't end up with identical keys.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725044/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor724734"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Feedback from the userspace: Python urandom disaster</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 20:57 UTC (Tue)
                               by <b>vstinner</b> (subscriber, #42675)
                              [<a href="/Articles/724734/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I modified Python 3.5 to use the new fd-less getrandom() syscall. Quickly, we got two blocker bug reports about Python blocked forever. The Debian issue was that a Python 3 script was used to compute a checksum at boot, but Python was blocked at getrandom(). The bugs occurred on VMs and embedded devices.<br>
<p>
Quickly, our security experts concluded that it's a feature and that os.urandom() must block. Ok but how to fix the issur with Python initialization? Then the discussion became crazy, the bug tracker and the mailing list were flooded by hundred of messages of people wanting to give their opinon... The two most important security Python experts resigned...<br>
<p>
Trust me or not: a new mailing list was created just to answer the question of os.random(), should it block or not?<br>
<p>
Two PEPs were written. Mine won and is implemented in Python 3.6:<br>
<a href="https://www.python.org/dev/peps/pep-0524/">https://www.python.org/dev/peps/pep-0524/</a><br>
<p>
Python 3.6 now blocks on os.urandom(), but Python internal code to initialize Python falls back on non-blocking but unsafe /dev/urandom if getrandom() would block.<br>
<p>
Read also my blog post:<br>
<a href="https://haypo.github.io/pep-524-os-urandom-blocking.html">https://haypo.github.io/pep-524-os-urandom-blocking.html</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724734/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724850"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Feedback from the userspace: Python urandom disaster</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2017 12:10 UTC (Thu)
                               by <b>robbe</b> (guest, #16131)
                              [<a href="/Articles/724850/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wouldn’t you be better off only calling getrandom() once the first call to os.urandom() actually occurs, not unconditionally at startup or import of the random module?<br>
<p>
(Sorry for beating a dead horse.)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724850/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724852"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Feedback from the userspace: Python urandom disaster</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2017 12:42 UTC (Thu)
                               by <b>vstinner</b> (subscriber, #42675)
                              [<a href="/Articles/724852/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Wouldn’t you be better off only calling getrandom() once the first call to os.urandom() actually occurs, not unconditionally at startup or import of the random module?</font><br>
<p>
It's more complex than that in practice :-)<br>
<p>
To workaround a denial-of-service (DoS) on Python hash function, the hash function is now randomized by default. We need entropy for that. Python 3.6 now tries to get entropy from getrandom(), or falls back to /dev/urandom if getrandom() would block.<br>
<p>
There is a similar strategy (fallback) when the random module is imported, to create an instance of the Mersenne Twister PRNG.<br>
<p>
But when os.urandom() is called explicitly, we now always block on getrandom().<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724852/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor724964"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Feedback from the userspace: Python urandom disaster</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2017 20:27 UTC (Sat)
                               by <b>OrbatuThyanD</b> (guest, #114326)
                              [<a href="/Articles/724964/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Then the discussion became crazy, the bug tracker and the mailing list were flooded by hundred of messages of people wanting to give their opinon</font><br>
<p>
ugh, I had almost the exact same experience dealing with the python dev community back when I wrote a pep that got included in 3.3. it felt like it was a full year of arguing with bike shedders and the whole thing really turned me off to python all together.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724964/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724966"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Feedback from the userspace: Python urandom disaster</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 10, 2017 22:08 UTC (Sat)
                               by <b>vstinner</b> (subscriber, #42675)
                              [<a href="/Articles/724966/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Oh, I am sorry to hear that feedback. Sometimes we try to be too kind and welcome on python-dev, nobody asks to stop the bikeshedding. Well, I did exactly that once, for the Python 3.6 fspath protocol. A PEP was written to make the discussion more constructive.<br>
<p>
I was just wrote a PEP 546 to backport ssl.MemoryBIO to Python 2.7. After around 100 emails, the PEP was approved. The thing is that the discussion was interesting! But it's hard to follow such active discussion.<br>
<p>
In my experience, writing a PEP is painful but it is also really worth it! After the long discussion, the quality is much better and also corner cases have been analyzed ;-)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724966/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor724736"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Waiting for entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 21:17 UTC (Tue)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/724736/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I'm kinda disgusted by all this crap about random numbers. Has there been an actual attack through insecure urandom? It all looks like a bunch of people thinking up hypothetical stuff and breaking actual code in process.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724736/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724737"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Waiting for entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 21:41 UTC (Tue)
                               by <b>pbonzini</b> (subscriber, #60935)
                              [<a href="/Articles/724737/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I am reminded of those devices with the same SSH private key because the contents of /dev/random were entirely deterministic on the first boot.<br>
<p>
So in addition to your question, I'd ask: besides problems due to lack of entropy in /dev/urandom, how much could you trust /dev/urandom to be sufficiently nondeterministic on embedded systems, before a seed has been read from disk?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724737/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor724738"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Waiting for entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 6, 2017 21:59 UTC (Tue)
                               by <b>jepler</b> (subscriber, #105975)
                              [<a href="/Articles/724738/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Try <a href="https://www.cis.upenn.edu/~nadiah/papers/weak-keys/weak-keys.pdf">Weak Keys Remain Widespread in Network Devices</a> and its citations [21] and [26]:
<blockquote>In 2012, two academic groups reported having computed
the RSA private keys for 0.5% of HTTPS hosts on
the internet, and traced the underlying issue to widespread
random number generation failures on networked devices.
The vulnerability was reported to dozens of vendors,
several of whom responded with security advisories,
and the Linux kernel was patched to fix a boottime
entropy hole that contributed to the failures.…
<p>
In this [2016 -- jepler] paper, we measure the actions taken by vendors
and end users over time in response to the original
disclosure.</blockquote>
Spoiler: They didn't find that things had improved much, factoring over 313,000 public keys with the technique disclosed in 2012.
      
          <div class="CommentReplyButton">
            <form action="/Articles/724738/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor724748"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Waiting for entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2017 2:57 UTC (Wed)
                               by <b>gdt</b> (subscriber, #6284)
                              [<a href="/Articles/724748/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>Non-random keys and covert-channel (timing, power) attacks are the two ways into otherwise-secure crypto protocols. There's no shortage of academic papers with demonstrations against real platforms, and therefore likely no shortage of NSA implementations.</p>
      
          <div class="CommentReplyButton">
            <form action="/Articles/724748/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor724797"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Waiting for entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2017 16:30 UTC (Wed)
                               by <b>hmh</b> (subscriber, #3838)
                              [<a href="/Articles/724797/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are documented security episodes due to identical systems with identical initial state early at boot and poor entropy gathering capabilities, yes.  They end up generating the same crypto keys at first start-up.<br>
<p>
Look for the paper "Mining Your Ps and Qs: Detection of Widespread Weak Keys in Network Devices", by Nadia Heninger, Zakir Durumeric, Eric Wustrow and J. Alex Halderman.   Read the "Repeated keys due to low entropy" section.<br>
<p>
There is an online copy of that paper at: <a href="https://factorable.net/weakkeys12.extended.pdf">https://factorable.net/weakkeys12.extended.pdf</a><br>
<p>
That has nothing to do with /dev/urandom being secure or insecure, though.  The correct term would be "/dev/urandom misuse", IMHO.  But it is too easy to misuse.<br>
<p>
The problem is real.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724797/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor727246"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Waiting for entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jul 6, 2017 1:34 UTC (Thu)
                               by <b>vomlehn</b> (guest, #45588)
                              [<a href="/Articles/727246/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
An analogy--the mere presence of a lock on your door, no matter whether it is a lousy lock or even a fake, will prevent most people from even trying to open it. That's one of the social engineering aspects of security.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/727246/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor724744"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Waiting for entropy</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2017 0:46 UTC (Wed)
                               by <b>neilbrown</b> (subscriber, #359)
                              [<a href="/Articles/724744/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Surely "get_random_bytes()" should return an error if there aren't any random (by which I suspect we really mean "unguessable") bytes to be had.  Reporting success, but returning predictable data seems to violate the law of least surprise.<br>
Then we could have "get_random_bytes_or_4()", which never fails, but sometimes just returns "4" (<a href="https://xkcd.com/221/">https://xkcd.com/221/</a>).  This can be used by code which cannot wait, but cannot handle failure.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724744/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor724751"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware requirement</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2017 7:05 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/724751/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Another way forward, which would be painful for Linux to choose today, but remains an option, is to decide that hardware RNG is a mandatory platform feature, the same way Linux insists platforms should have certain other features in order to get a Linux port, most obviously virtual addressing.<br>
<p>
If you _want_ you could choose a platform in which the hardware RNG is set to output '4' or its own serial number, or whatever, and there would be some Linux whitening layer on top of your hardware RNG that would make that look at least pseudo-random, much like those old patches that would have Linux run "successfully" on machines where RAM didn't work properly. And when it breaks you'd get to keep both halves.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724751/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724796"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware requirement</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2017 17:26 UTC (Wed)
                               by <b>dps</b> (guest, #5725)
                              [<a href="/Articles/724796/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Requiring a hadrware random number generator would be a really bad idea IMHO.<br>
<p>
I have 6 core AMD phenom II box which AFAIK it does not have any random number generation hardware. I still works and I want to coninute to be able to run linux on it and a hardware requiremnet would make it this impossible. As a desktop stystem it probably has a reasonable amount of entropy most of the time. There are far too many boxes that don't have these features---last time I looked about 90% of amd motherboards do *not* have a tpm, random number hardware or efi firmware. I suspect that most mothetboards still don't have a tpm or rng hardware.<br>
<p>
I usually build my own desktop boxes, patly because it is usuall significantly less expensive and partly because that way I know exactly what hardware is in the box.<br>
<p>
Linux never ran on any hardware without a virtual pagied address space even in the days of  0.99pl13, which only supported &lt;1Gb of memory, one core 32 bit 80x86 processors. At the time you could be the fastest x86 processor was a single core 80486DX2/66, and most motherboards did not support more than 16Mb of RAM. The elks project exists for those that can't afford a MMU but a 8086 compatible motheboard might not be cheap.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724796/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor724817"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware requirement</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2017 20:39 UTC (Wed)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/724817/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Decreeing a billion tons of existing Linux devices to be e-waste might make the likes of Samsung happy, but a saner solution would be to fix it in software, like HAVEGE already does. There's plenty of usable entropy to be found in an average computer if you stop treating it as a perfectly spherical IBM 8088 with clock speed a fixed multiple of Planck time.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724817/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor724816"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware requirement</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 7, 2017 21:15 UTC (Wed)
                               by <b>rahvin</b> (guest, #16953)
                              [<a href="/Articles/724816/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There are a not insignificant number of people that believe the NSA worked through the hardware companies to produce hardware RNGs in a way that makes them deterministic for the group that understands the subtle bugs they put into the hardware. Whether or not you accept that it's not hard to understand that without genuine random data your encryption is worthless so any progress on making random numbers better is a good thing. <br>
<p>
I'm personally concerned about RNG's on routers with thinks like the rise of Mirari botnet. Mirari uses the simplest of compromise methods, default passwords, but it wouldn't be hard to upgrade it to target routers with good passwords but bad entropy and in doing so it would go from 600 million devices to several billion. Mirari is actually a threat to the internet itself given its scale and the ease with which anyone can build their own mirari and use it. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724816/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor724839"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware requirement</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2017 6:39 UTC (Thu)
                               by <b>daenzer</b> (subscriber, #7050)
                              [<a href="/Articles/724839/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
FYI, the name of the botnet is not "Mirari" but "Mirai", the transliteration of Japanese 未来 for "future".<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724839/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor725118"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware requirement</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 12, 2017 19:37 UTC (Mon)
                               by <b>bfields</b> (subscriber, #19510)
                              [<a href="/Articles/725118/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
"There are a not insignificant number of people that believe the NSA worked through the hardware companies to produce hardware RNGs in a way that makes them deterministic for the group that understands the subtle bugs they put into the hardware."<br>
<p>
What I don't get is why you'd focus on that specific attack.  I'm not sure how you design an operating system kernel for security against an attacker with the resources to pressure hardware companies to add backdoors to their designs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/725118/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor724843"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Hardware requirement</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 8, 2017 8:32 UTC (Thu)
                               by <b>njs</b> (guest, #40338)
                              [<a href="/Articles/724843/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
There's an important distinction here between entropy *sources*, and the kernel's *estimate* of how much entropy it has. In practice, there are lots of good entropy sources: many modern systems have hardware RNGs, and even if they don't, then measuring on any modern CPU cache latencies gives non-deterministic values as far as anyone can tell. But in both of these cases, the problem is that it's very hard to *know* whether they're good sources of entropy. (For hardware RNGs, it's not just the NSA issue; it's also that if they suffer some internal physical failure then the first notification you get is that your bitcoin wallet is suddenly empty. And the cache thing works really well as far as anyone can tell but in theory it *should* be totally predictable to someone who understands the hardware, so it makes people nervous.)<br>
<p>
Ted is happy to mix these sorts of sources into the pool, and they make you safer. But he doesn't count them when trying to estimate whether there's "enough" entropy for the kernel to *know* that you're safe. And it's that estimate that's used to decide whether to block or not during early startup, and causes difficult engineering problems downstream. So hardware RNGs don't actually help at all with that problem.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724843/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor724898"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Passing entropy at boot</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jun 9, 2017 12:29 UTC (Fri)
                               by <b>mirabilos</b> (subscriber, #84359)
                              [<a href="/Articles/724898/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
OpenBSD just changed the bootloader protocol, adding an additional entry that is bootloader-provided entropy passed to the kernel before handing control over to the kernel. The entropy is read from disc by their second-stage bootloader, and overwritten early by userspace to prevent repeats.<br>
<p>
Of course, this won’t work for _all_ scenarios in which the Linux kernel is currently booted, but it can be added to _some_ of them peu à peu.<br>
<p>
You could also conceivably put some write to /dev/urandom into the initrd, a couple of bytes just so that each initrd regeneration will add a bit of (by then pseudo-)random data to each boot, which, combined with the other input (including time, which, yes, I know, is not a secret and additionally susceptible to replay attacks in VMs, but still better than nothing¹), may help.<br>
<p>
Investigating platform-specific things is also a (not very low-hanging though) fruit. For example, if a board of a system is known to have two separate oscillators, measure the delta for a short while during early boot and add that¹².<br>
<p>
① In the words of the author of RANDOM.SYS for DOS: “Every bit counts.”<br>
② My recipe for this is: add enough sources, for which each source is at least one of, and for which the (XOR or otherwise well-combined) sum of all sources is all of: unpredictable; unobservable; mathematically well-distributed (e.g. prior PRNG output) — then worry about the mixing algorithm ☺<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/724898/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2017, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
