        <!DOCTYPE html>
        <html lang="en">
        <head><title>A pair of Rust kernel modules [LWN.net]</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="robots" CONTENT="noai, noimageai">
        <link rel="icon" href="https://static.lwn.net/images/favicon.png"
              type="image/png">
        <link rel="alternate" type="application/rss+xml" title="LWN.net headlines" href="https://lwn.net/headlines/rss">
<link rel="alternate" type="application/rss+xml" title="Comments posted to this article" href="https://lwn.net/headlines/907685/">
        <link rel="stylesheet" href="/CSS/lwn">
<link rel="stylesheet" href="/CSS/nosub">

        
<script type="text/javascript">var p="http",d="static";if(document.location.protocol=="https:"){p+="s";d="engine";}var z=document.createElement("script");z.type="text/javascript";z.async=true;z.src=p+"://"+d+".adzerk.net/ados.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(z,s);</script>
<script type="text/javascript">
var ados_keywords = ados_keywords || [];
if( location.protocol=='https:' ) {
        ados_keywords.push('T:SSL');
} else {
        ados_keywords.push('T:HTTP');
}

var ados = ados || {};
ados.run = ados.run || [];
ados.run.push(function() {

ados_add_placement(4669, 20979, "azk13321_leaderboard", 4).setZone(16026);

ados_add_placement(4669, 20979, "azk93271_right_zone", [5,10,6]).setZone(16027);

ados_add_placement(4669, 20979, "azk31017_tracking", 20).setZone(20995);



ados_setKeywords(ados_keywords.join(', ')); 
ados_load();
});</script>

        </head>
        <body>
        <a name="t"></a>
<div id="menu"><a href="/"><img src="https://static.lwn.net/images/logo/barepenguin-70.png" class="logo"
                 border="0" alt="LWN.net Logo">
           <span class="logo">LWN<br>.net</span>
           <span class="logobl">News from the source</span></a>
           <a href="/"><img src="https://static.lwn.net/images/lcorner-ss.png" class="sslogo"
                 border="0" alt="LWN"></a><div class="navmenu-container">
           <ul class="navmenu">
        <li><a class="navmenu" href="#t"><b>Content</b></a><ul><li><a href="/current/">Weekly Edition</a></li><li><a href="/Archives/">Archives</a></li><li><a href="/Search/">Search</a></li><li><a href="/Kernel/">Kernel</a></li><li><a href="/Security/">Security</a></li><li><a href="/Calendar/">Events calendar</a></li><li><a href="/Comments/unread">Unread comments</a></li><li><hr></li><li><a href="/op/FAQ.lwn">LWN FAQ</a></li><li><a href="/op/AuthorGuide.lwn">Write for us</a></li></ul></li>
<li><a class="navmenu" href="#t"><b>Edition</b></a><ul><li><a href="/Articles/907455/">Return to the Front page</a></li></ul></li>
</ul></div>
</div> <!-- menu -->
<div class="not-handset"
            	     style="margin-left: 10.5em; display: block;">
                   <div class="not-print"> <div id="azk13321_leaderboard"></div> </div>
                </div>
            <div class="topnav-container">
<div class="not-handset"><form action="https://lwn.net/Login/" method="post" name="loginform"
                 class="loginform">
        <label><b>User:</b> <input type="text" name="uname" value="" size="8" id="uc" /></label> 
		<label><b>Password:</b> <input type="password" name="pword" size="8" id="pc" /></label> <input type="hidden" name="target" value="/Articles/907685/" /> <input type="submit" name="submit" value="Log in" /></form> |
           <form action="https://lwn.net/subscribe/" method="post" class="loginform">
           <input type="submit" name="submit" value="Subscribe" />
           </form> |
           <form action="https://lwn.net/Login/newaccount" method="post" class="loginform">
           <input type="submit" name="submit" value="Register" />
           </form>
        </div>
               <div class="handset-only">
               <a href="/subscribe/"><b>Subscribe</b></a> /
               <a href="/Login/"><b>Log in</b></a> /
               <a href="/Login/newaccount"><b>New account</b></a>
               </div>
               </div><div class="maincolumn flexcol">
<div class="middlecolumn">
<div class="PageHeadline">
<h1>A pair of Rust kernel modules</h1>
</div>
<div class="ArticleText">
<blockquote class="ad">
<b>Did you know...?</b>
<p>
LWN.net is a subscriber-supported publication; we rely on subscribers
       to keep the entire operation going.  Please help out by <a
       href="/Promo/nst-nag4/subscribe">buying a subscription</a> and keeping LWN on the
       net.
</blockquote>
<div class="FeatureByline">
           By <b>Jonathan Corbet</b><br>September 12, 2022</br>
           <hr>
<a href="https://lwn.net/Archives/ConferenceByYear/#2022-Kangrejos">Kangrejos</a>
</div>
The idea of being able to write kernel code in the Rust language has a
certain appeal, but it is hard to judge how well that would actually work
in the absence of examples to look at.  Those examples, especially for
modules beyond the "hello world" level of complexity, have been somewhat
scarce, but that is beginning to change.  At the 2022 Kangrejos gathering
in Oviedo, Spain, two developers presented the modules they have developed
and some lessons that have been learned from this exercise.
<p>
<h4>An NVMe driver</h4>
<p>
Andreas Hindborg was up first to talk about <a
href="https://github.com/metaspace/rust-linux/commit/3446d310d9082c00eecb4b396a167e3f19b3b2f1">an
NVM Express driver</a> written
in Rust.  The primary reason for this project, he said, was to take
advantage of the
memory-safety guarantees that Rust offers and to gain some
real-world experience with the language.  His conclusions from this project
include that Rust comes with a lot of nice tooling and that its type
system is helpful for writing correct code.  It is, he said, easier to
write a kernel driver in Rust than in&nbsp;C.
<p>
<a href="/Articles/907716/"><img
src="https://static.lwn.net/images/conf/2022/kang/AndreasHindborg-sm.png" alt="[Andreas
Hindborg]" title="Andreas Hindborg" class="lthumb"></a>

Why write an NVMe driver when the kernel already has one that works well?
There are no problems with the existing driver, he said, but NVMe is a good
target for experiments with driver abstractions.  NVMe itself is relatively
simple, but it has high performance requirements.  It is widely deployed,
and the existing driver provides a mature reference implementation to
compare against.
<p>
Hindborg talked for a while about the internals of the NVMe interface; in
short, communications between the interface and the computer go through a
set of queues.  Often the driver will configure an I/O queue for each core
in the system if the interface can handle it. Creating data structures in
Rust to model these queues is a relatively straightforward task.  In the
end, the Rust driver, when tested with the <a
href="https://fio.readthedocs.io/en/latest/fio_doc.html#">FIO</a> tool,
performs <i>almost</i> as well as the existing C driver.  The difference,
Hindborg said, is that the C driver has already been highly tuned, while
the Rust driver has not; it should be able to get to the same level of
performance eventually.
<p>
He concluded by saying that the Rust NVMe driver is still "a playground"
and not 
production-ready at this point.  To move things forward, he would like to
create more abstractions that would allow the removal of the remaining
<tt>unsafe</tt> blocks in the driver.  It doesn't yet support device
removal or the sysfs knobs for the <tt>nvme-cli</tt> tool.  He would also
like to look into using the Rust async model, which would "simplify a lot
of things" in the driver, but possibly at the cost of performance.
<p>
At the end of Hindborg's talk, Paul McKenney asked if there was any
available information on the relative bug rates between the C and Rust
drivers.  Hindborg answered that there have certainly been some bugs;
building Rust abstractions around existing C code can be hard to do
correctly.  That work needs a lot of care and review, but once it works,
drivers built on it tend to show few problems.
<p>
<h4>A 9P filesystem server</h4>
<p>
Last year, Linus Walleij <a
href="/ml/linux-kernel/CACRpkdat-4BbKHMBerdxXBseMb9O3PiDRZmMLP_OWFE2ctSgEg@mail.gmail.com/">suggested</a>
that, rather than writing drivers in Rust, developers should target areas
with a higher attack surface — network protocols, for example.  Wedson
Almeida Filho has taken that advice and written <a
href="https://github.com/wedsonaf/linux/commits/9p">an in-kernel server</a>
for the
<a href="https://en.wikipedia.org/wiki/9P_(protocol)">9P</a> filesystem
protocol in the hopes that this project would demonstrate the productivity
gains and security benefits that Rust can provide.  Initially, he had
started trying to replace the <tt>ksmbd</tt> server, but that turned out to
not be an ideal project.  The SMB protocol is too complex and the server
needs some significant user-space components to work.  He wanted something
simpler; 9P fit the bill.
<p>

<a href="/Articles/907717/"><img
src="https://static.lwn.net/images/conf/2022/kang/WedsonAlmeidaFilho-sm.png" alt="[Wedson Almeida
Filho]" title="Wedson Almeida Filho" class="lthumb"></a>

The 9P file protocol, he said, comes from the <a
href="https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs">Plan&nbsp;9</a>
operating system.  The kernel has a 9P client, but no 9P server.  There is
a 9P server in <a
href="https://www.qemu.org">QEMU </a>
that can be used to export host filesystems into a guest.  The protocol is
simple, Almeida said, defining a set of only ten operations.  His 9P server
implementation works now, in a read-only mode, and required just over 1,000
lines of code.
<p>
Almeida was also looking for a way to experiment with <a
href="https://rust-lang.github.io/async-book/">async Rust</a> in the
kernel.  In the async model, the compiler takes thread-like code and turns
it into a state machine that can be implemented with "executors" and
"reactors", which are implemented in the kernel crate.  He created an
executor that can run async code in a kernel workqueue; anywhere such code
would block, it will release the workqueue thread for another task.  There
is also a socket reactor that is called for socket-state changes; it will
call <tt>Waker::wake()</tt> from the Rust kernel crate to get the appropriate
executor going again.
<p>
There is, of course, plenty of work yet to be done.  He would like to
implement reactors for other I/O submission paths, including KIOCBs
(asynchronous I/O), URBs (USB devices), and BIOs (block devices).  Memory
allocation can still use some work; it would be good if a
<tt>GFP_KERNEL</tt> could give up its thread while waiting for the
memory-management subsystem to do complicated things.
<p>
At the end, I asked whether the objective of demonstrating the security
benefits of Rust had been achieved; has there been, for example, any
fuzz testing of the server?  Almeida answered that the Rust-based parsing
interface makes a lot of mistakes impossible.  No fuzz testing has
been done — the server has only been working for a couple of weeks — but he
will do it.  He concluded that he will be interested to see how his server
fares in such testing relative to the QEMU implementation.
<p>
[Thanks to LWN subscribers for supporting my travel to this event.]<br clear="all"><table class="IndexEntries">
           <tr><th colspan=2>Index entries for this article</th></tr>
           <tr><td><a href="/Kernel/Index">Kernel</a></td><td><a href="/Kernel/Index#Development_tools-Rust">Development tools/Rust</a></td></tr>
            <tr><td><a href="/Archives/ConferenceIndex/">Conference</a></td><td><a href="/Archives/ConferenceIndex/#Kangrejos-2022">Kangrejos/2022</a></td></tr>
            </table><br clear="all">
<hr width="60%%" align="left">
            <form action="/Login/" method="post">
            <input type="hidden" name="target" value="/Articles/907685/" />
            <input type="submit" name="login" value="Log in" /> to post comments
            <p>
        
</div> <!-- ArticleText -->
<p><a name="Comments"></a>
<a name="CommAnchor907786"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2022 14:54 UTC (Mon)
                               by <b>iustin</b> (subscriber, #102433)
                              [<a href="/Articles/907786/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Interesting, so it finally starts? Looking forward to more Rust usage…<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907786/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor907785"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2022 14:54 UTC (Mon)
                               by <b>koverstreet</b> (subscriber, #4296)
                              [<a href="/Articles/907785/">Link</a>] (13 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The 9p server in particular is beyond slick.<br>
<p>
The async stuff in Rust works beautifully here; internally, the compiler is doing a CPS transformation. This is something (some of us) C programmers have known how to do for years, but in practice it&#x27;s _tedious_, so when we do it in C it&#x27;s always less than ergonomic and incomplete.<br>
<p>
And the RAII stuff means a lot of tricky cleanup code just doesn&#x27;t exist.<br>
<p>
This the code I always wished I could write - and unlike in C++, we can write it and actually trust that it&#x27;s correct.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907785/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907832"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 10:33 UTC (Tue)
                               by <b>ncm</b> (guest, #165)
                              [<a href="/Articles/907832/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      Or, you could code it in C++, correctly, and be done. 
<p>
Coding it in Rust does not, in fact, guarantee it is correct. Coding C++, you need only choose known-correct primitives to get the same level of assurance. But you would then face rabid, unreasoned hostility from Linus for C++ features you may use in Rust code without approbation; and have your patch summarily rejected with, most likely, a rude remark.
<p>
The easy way to get C++ code into the kernel is via eBPF, which offers solid support for building from C++, and where there is <em>nothing</em> Linus can do to stop you. And, it is exactly as safe as Rust eBPF, but likely less annoying to code.







      
          <div class="CommentReplyButton">
            <form action="/Articles/907832/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907837"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 11:08 UTC (Tue)
                               by <b>gspr</b> (guest, #91542)
                              [<a href="/Articles/907837/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Or, you could code it in C++, correctly, and be done. </font><br>
<p>
I believe that the parent commenter meant that doing exactly this is signficantly harder than it is in Rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907837/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907838"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 11:13 UTC (Tue)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/907838/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It&#x27;s far easier than in Rust, because in Rust it&#x27;s impossible. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907838/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907839"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Please</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 11:16 UTC (Tue)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/907839/">Link</a>] 
      </p>
      
      </div>
      </summary>
      Can we please try to avoid yet another round of silly language-advocacy postings here?  We've all heard it.  The article is about people showing real work, albeit at an early stage; let's focus on the actual work.
<p>
Thank you all.


      
          <div class="CommentReplyButton">
            <form action="/Articles/907839/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor907957"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 10:56 UTC (Wed)
                               by <b>xav</b> (guest, #18536)
                              [<a href="/Articles/907957/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Coding it in Rust does not, in fact, guarantee it is correct</font><br>
<p>
To a certain extend, it does out of unsafe blocks, and way more than C++ can even dream of.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907957/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908185"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 19:14 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/908185/">Link</a>] (7 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>
The easy way to get C++ code into the kernel is via eBPF, which offers solid support for building from C++
</blockquote>

Solid? Earlier this year I had a persistent failure getting <i>this</i> to verify (under 5.16):

<pre>
        uint32_t id;mp;
        dt_bpf_specs_t zero;

        __builtin_memset(&amp;zero, 0, sizeof (dt_bpf_specs_t));

        for (id = 1; id &lt;= 16; id++) {
                if (bpf_map_update_elem(&amp;specs, &amp;id, &amp;zero,
                                        BPF_NOEXIST) == 0)
                        return id;
        }
</pre>

A simple loop updating sixteen map values to 0 was rejected... because the verifier could not prove that this incredibly subtle and difficult loop would terminate. (I unrolled it, and everything was fine.)
<p>
Trying to write nontrivial C++ code and expecting it to turn to working eBPF without massive amounts of verifier agony is an exercise in futility at present. You can try if you like, but I wouldn't want to listen to the resulting cursing if you did. (Maybe this will change in time, but I very much suspect that turning the verifier into something that isn't full of arbitrary restrictions and can actually verify real code that wasn't written with 90% of one's attention on contorting things in unnatural ways to get it to verify will either slow it to unusability or just slam straight into the wall of Rice's theorem.)


      
          <div class="CommentReplyButton">
            <form action="/Articles/908185/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908189"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 19:37 UTC (Thu)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/908189/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Solid? Earlier this year I had a persistent failure getting this to verify (under 5.16):</font><br>
<p>
Have you tried the Rust ones? https://aya-rs.dev/ or <a href="https://crates.io/crates/bcc">https://crates.io/crates/bcc</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908189/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908199"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 21:13 UTC (Thu)
                               by <b>nix</b> (subscriber, #2304)
                              [<a href="/Articles/908199/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
No, but the problem was the *verifier*, not the input language. The same sort of thing written in raw eBPF was also rejected. (It worked if the loop bound was &lt; 4. How... useful.)<br>
<p>
Figuring out why required diving into the verifier source code, because there is of course nothing like a spec, and the verifier&#x27;s verification contains enough holes where obviously valid code is rejected out of hand because nobody&#x27;s written code to verify it (if you&#x27;re lucky, there are comments noting the lack of said verification) that it frankly should be called a collection of holes with a little fabric connecting them :)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908199/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908252"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 8:51 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/908252/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Earlier this year I had a persistent failure getting this to verify (under 5.16): …</font><br>
<p>
Strictly speaking, without taking into account knowledge of the internals of bpf_map_update_elem(), that loop might *not* terminate. You&#x27;re passing in a pointer to the loop counter (id) and the function could potentially update the variable via that pointer to prevent it from incrementing. (Yes, even if the pointer argument is const-qualified; you can cast away the const qualifier on a pointer with const_cast as long you&#x27;re not trying to store into a const object, and the variable id in this example isn&#x27;t a const object.)<br>
<p>
It would probably compile if you copied id into a separate local variable and passed a pointer to that variable to bpf_map_update_elem(). Then the compiler could easily prove that the function doesn&#x27;t update id since it doesn&#x27;t have its address (given the standard pointer provenance rules), which places a fixed upper bound on the number of loop iterations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908252/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908253"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 9:22 UTC (Fri)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/908253/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Or bpf could take fortran to heart, and the definition in the spec that says &quot;for loops do not guarantee that modifications to the index variable will &quot;stick&quot;&quot;.<br>
<p>
The standard explicitly permits moving the index into a register (which other code has no access to) and then it saves it to the variable whenever it increments or other fancy tricks. <br>
<p>
Whatever, as far as the code *inside* the loop is concerned, the index variable is either read-only, or if you do try and modify it, it&#x27;s undefined.<br>
<p>
So, provided the naive loop terminates, you can guarantee that any loop will terminate.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908253/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor909171"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 9:56 UTC (Fri)
                               by <b>rep_movsd</b> (guest, #100040)
                              [<a href="/Articles/909171/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
It looks like the id loop iterator is being passed by pointer to a function. <br>
Why would a function need a primitive value passed in by pointer unless it intended to modify it?<br>
<p>
The compiler cannot guarantee that id doesnt change whilst you are looping.<br>
<p>
So either the function takes a const pointer to int (which is braindead) and the compiler is brain dead not to see its not modifiable<br>
<p>
OR <br>
<p>
The function takes it by pointer (which may be braindead) and the compiler is right<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909171/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor909177"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 11:05 UTC (Fri)
                               by <b>adobriyan</b> (subscriber, #30858)
                              [<a href="/Articles/909177/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
&quot;key&quot; should be pointer to const.<br>
<p>
BPF_CALL_4(bpf_map_update_elem,<br>
    struct bpf_map *, map,<br>
    void *, key,<br>
    void *, value,<br>
    u64, flags)<br>
{<br>
        WARN_ON_ONCE(!rcu_read_lock_held() &amp;&amp; !rcu_read_lock_bh_held());<br>
        return map-&gt;ops-&gt;map_update_elem(map, key, value, flags);<br>
}<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909177/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor909259"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 23, 2022 18:04 UTC (Fri)
                               by <b>nybble41</b> (subscriber, #55106)
                              [<a href="/Articles/909259/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; So either the function takes a const pointer to int (which is braindead) and the compiler is brain dead not to see its not modifiable</font><br>
<p>
Even if the function did take a const-qualified pointer, it wouldn&#x27;t matter. It&#x27;s perfectly legal to do something like this:<br>
<p>
void f(int const *p) { *(int*)p = 7; }<br>
<p>
... as long as the original *object* was not const-qualified. (Attempting to write into a *variable* which was const-qualified at the point of declaration is, of course, undefined behavior, whether or not the pointer being used is const-qualified.) Consequently, the compiler can&#x27;t assume that the function won&#x27;t write into a mutable object even if the pointer argument is const-qualified.<br>
<p>
Also, the read-only pointer-to-int argument pattern isn&#x27;t quite so &quot;braindead&quot; as you suppose. These functions are generic; in this case the key happens to be an int, but that isn&#x27;t always true, and so the key is passed by reference rather than value. The comparison callback for the standard library&#x27;s qsort() function uses the same pattern, for example, when sorting an int array.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/909259/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
<a name="CommAnchor907789"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 12, 2022 16:28 UTC (Mon)
                               by <b>NHO</b> (guest, #104320)
                              [<a href="/Articles/907789/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Then there&#x27;s Asahi DRM driver for Apple Silicon.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907789/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor907829"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 9:48 UTC (Tue)
                               by <b>josh</b> (subscriber, #17465)
                              [<a href="/Articles/907829/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The NVMe driver was presented again the this week at Plumbers, to enthusiastic reactions: <a href="https://twitter.com/josh_triplett/status/1569363148985233414">https://twitter.com/josh_triplett/status/1569363148985233414</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907829/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907875"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 15:38 UTC (Tue)
                               by <b>MrWim</b> (subscriber, #47432)
                              [<a href="/Articles/907875/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Video: <a href="https://www.youtube.com/watch?v=Xw9pKeJ-4Bw&amp;t=8040s">https://www.youtube.com/watch?v=Xw9pKeJ-4Bw&amp;t=8040s</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907875/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor907834"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 11:12 UTC (Tue)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/907834/">Link</a>] (53 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; At the end of Hindborg&#x27;s talk, Paul McKenney asked if there was any available information on the relative bug rates between the C and Rust drivers. Hindborg answered that there have certainly been some bugs; building Rust abstractions around existing C code can be hard to do correctly. That work needs a lot of care and review, but once it works, drivers built on it tend to show few problems. </font><br>
<p>
So in other words: oh yes, there are still bugs, but we can just blame them on C. Any issues with interfacing Rust and C? Obviously the fault of C. Even though clearly and logically any bugs introduced by having to interface two languages is only reasonably attributable to the language that came along later and seems intent on forcing its way into the kernel regardless of what anyone else wants.<br>
<p>
And things like this:<br>
<p>
<font class="QuotedText">&gt; At the end, I asked whether the objective of demonstrating the security benefits of Rust had been achieved; has there been, for example, any fuzz testing of the server? Almeida answered that the Rust-based parsing interface makes a lot of mistakes impossible. No fuzz testing has been done — the server has only been working for a couple of weeks — but he will do it. He concluded that he will be interested to see how his server fares in such testing relative to the QEMU implementation. </font><br>
<p>
In other words &quot;no we haven&#x27;t actually tested it but I&#x27;m sure the language prevents bugs, they&#x27;re totally impossible&quot;. Yeah right. This is typical of the Rust community: huge promises, no evidence to back them up, all topped off with an &quot;if it compiles it is correct&quot; attitude that totally disregards that there are many more issues other than those the Rust people have decided count as &#x27;safety&#x27;. <br>
<p>
Anyone noticed that &#x27;unsafe&#x27; as a general concept has suddenly been redefined to mean &#x27;whatever Rust prevents&#x27; (if you don&#x27;t use `unsafe`, which the Rust for linux code does all over the place)? When people involved in Rust&#x27;s development realised just before the release of the language that the language was fundamentally unsound, allowing memory leaks, they quietly redefined &#x27;safety&#x27; to exclude leak freedom, because they didn&#x27;t have time to properly fix it before 1.0. This was despite months and years of telling people how wonderful Rust was because it prevented memory leaks, lol. This should come as no surprise from the same group of radicals that redefine words on a daily basis from what everyone in the world understood them to mean, inside and outside technology. &#x27;Master branch&#x27; is an (attempted) victim of the same ideology - nothing, not even in the truth, will stand in their way.<br>
<p>
The entire idea is horrible. I do not want a Rust compiler on my computer, I do not want to need a Rust compiler on my computer to be able to compile the kernel. Rust is &#x27;trusting trust&#x27; on steroids, for one thing. It is incredibly slow. Compiling a kernel takes long enough as it is! It&#x27;s specified as &#x27;whatever rustc does&#x27;. It has one implementation, with no other implementations even remotely close to being ready (there are other &quot;implementations&quot;, but they are nowhere near complete and cannot do borrow checking, the core feature of the language, so are practically useless.) It is an abhorrently complex language. Nobody has EVER explained what it provides to the kernel that Ada or better static analysis tools for C could not. The ONLY thing Rust has going for it is an incredibly pushy &quot;community&quot;. They say &quot;oh it will only be in a few drivers&quot;. Yeah, at first. But there&#x27;s no real point doing it if there&#x27;s not going to be a lot of it. And that means SLOW compile times and an inability to bootstrap reliably.<br>
<p>
Anyway, let&#x27;s be real: Rust is just not going to happen in the kernel. Rust can express legibly only one way of managing memory. Nobody has even managed to represent the Wayland memory model in Rust, and the kernel is far more complicated than that. The one serious attempt to do so failed after months of work because it required writing thousands upon thousands of lines of memory management boilerplate. If you want to represent anything more complex than Box or Rc you need to just about write a thesis. <br>
<p>
And look at the code itself. There&#x27;s a huge list of nightly (basically brand new!) compiler features that are required to build it. No way should there be code in the Linux kernel that requires anything other than stable language features. At least one of them is described as &quot;Status: the current design is perma-unstable -- a new RFC is needed. The issue may be split.&quot; And generic associated types have been in progress for more than 5 years with no real sign that they&#x27;re going to be stabilised any time soon.<br>
<p>
And last I checked, &#x27;async&#x27; in Rust is widely considered a failure of design.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907834/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907849"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 13:10 UTC (Tue)
                               by <b>PengZheng</b> (subscriber, #108006)
                              [<a href="/Articles/907849/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you very much for stopping me from reading a Rust book, successfully.<br>
<p>
I&#x27;d better invest that time learning C++20/23.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907849/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907854"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 14:04 UTC (Tue)
                               by <b>reijoslav</b> (guest, #98915)
                              [<a href="/Articles/907854/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The comment you&#x27;re replying to seems to be pretty trolly. The author has actually been banned from some other sites with the reason &quot;Troll&quot;.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907854/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907871"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 14:45 UTC (Tue)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/907871/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Said trolly author has clearly never heard of a Turing Machine, so yes ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907871/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907911"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 6:18 UTC (Wed)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/907911/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m perfectly aware of turing machines.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907911/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor907912"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 6:19 UTC (Wed)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/907912/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Accusing someone of &quot;trolling&quot; because they disagree with you is not constructive. Ironically, what you are doing is actually trolling...<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907912/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908193"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 21:13 UTC (Thu)
                               by <b>thecodedmessage</b> (guest, #160911)
                              [<a href="/Articles/908193/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
This poster is saying some true things in a loaded way to make them seem bad when they&#x27;re actually reasonable. Rust is a tool, and it can&#x27;t do everything that people sometimes carelessly claim about it. But that doesn&#x27;t mean C++ is just as good, or that Rust experts make these claims.<br>
<p>
Rust does not eliminate all bugs. It&#x27;s true that Rust&#x27;s safety features only prevent the behaviors that they&#x27;re designed to prevent. Of course that&#x27;s true -- no programming language can prevent all bugs, but Rust&#x27;s safety features do prevent some very bad types of memory corruption that are infamous for causing problems in C and C++. Additionally, even &#x27;unsafe&#x27; Rust does a better job at preventing those failures than C++, which in many cases doesn&#x27;t even give you any tools to manage the problem, relying instead entirely on the programmer.<br>
<p>
And yes, they tried to eliminate memory leaks in safe code and then realized that wasn&#x27;t an achievable goal in line with their other goals. That doesn&#x27;t mean that Rust is bad. Rust is much better at preventing memory leaks than C++, but it is still possible to leak memory. It&#x27;s way harder to do by accident, though.<br>
<p>
Rust is better than C++. The fact that it&#x27;s not utopian or perfect doesn&#x27;t mean that it&#x27;s not better.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908193/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor907872"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 15:06 UTC (Tue)
                               by <b>rav</b> (subscriber, #89256)
                              [<a href="/Articles/907872/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And generic associated types have been in progress for more than 5 years with no real sign that they&#x27;re going to be stabilised any time soon.</font><br>
<p>
Actually, under two hours after your comment, generic associated types were stabilised: <a href="https://github.com/rust-lang/rust/pull/96709#issuecomment-1245350608">https://github.com/rust-lang/rust/pull/96709#issuecomment...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907872/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907909"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 6:05 UTC (Wed)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/907909/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Gotta ❤️ hard-working, active communities.. !<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907909/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor907914"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 6:21 UTC (Wed)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/907914/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Which has still taken 4 years longer than it had any reason to take. C++ and Haskell have both had these features for years. There&#x27;s a huge amount of prior art. There&#x27;s no excuse for it to take this long. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907914/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907960"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 11:30 UTC (Wed)
                               by <b>jezuch</b> (subscriber, #52988)
                              [<a href="/Articles/907960/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I absolutely love it that they had 5 years to reflect and make sure that it doesn&#x27;t introduce any subtle warts and that it integrates well into not only current but also upcoming features of the language. It will be with us until forever, after all, and you can&#x27;t fix it once it&#x27;s delivered. For the same reason I&#x27;m excited about the evolution of Java (yes! Java!). Some of the features there (like Project Valhalla) have been baking for even longer than that. AND IT&#x27;S A GOOD THING. Brian Goetz, who leads these efforts, even says that if after all this time someone says &quot;Why on earth did it take you so long? It&#x27;s such a simple and obvious feature!&quot;, then it means that this was time well spent. Because if they delivered it sooner, then it would neither be simple nor obvious.<br>
<p>
Python, on the other hand... ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907960/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907984"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 11:47 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/907984/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Brian Goetz, who leads these efforts, even says that if after all this time someone says &quot;Why on earth did it take you so long? It&#x27;s such a simple and obvious feature!&quot;, then it means that this was time well spent. Because if they delivered it sooner, then it would neither be simple nor obvious.</font><br>
<p>
Cleanliness and simplicity in design is just SO important! I go on about WordPerfect, about INFORMATION (sadly defunct but my favourite Pick), precisely *because* they set out to have simple logic / design and clean implementation. <br>
<p>
I&#x27;ve been tripping over a Word bug for ages, and I&#x27;ve suddenly realised the problem - if a table extends over multiple pages it screws up printing! When printing labels, I often have grief with the printer so I get the first page and nothing else. If you try to start printing from page 2, it seems Word gets lost, assumes the entire table is on page 1, and prints nothing! WTF?<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907984/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908017"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 15:42 UTC (Wed)
                               by <b>rschroev</b> (subscriber, #4164)
                              [<a href="/Articles/908017/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Try printing to PDF first (Windows nowadays has a built-in virtual printer for that), then printing out that PDF. That workaround can sometimes work wonders for applications that don&#x27;t handle printers and their quirks very well.<br>
<p>
It&#x27;s sad of course that workaround like this are needed for any application, and double (or more) so for a high-profile word processor.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908017/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor908014"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 15:21 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/908014/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; There's no excuse for it to take this long.</font>

<p>Seriously? Modern, multithreaded OS kernels exist which means you should be able to create something like that in jiffy. Show me how, please. After we would benchmark it and compare to Linux and other popular kernels you would have a case.</p>

<font class="QuotedText">&gt; C++ and Haskell have both had these features for years.</font>

<p>And in both cases it took more than a decade to develop these. I still remember time when <a href="https://en.cppreference.com/w/cpp/memory/allocator">rebind</a> only existed in the standard, but not in G++.</p>

<font class="QuotedText">&gt; There's a huge amount of prior art.</font>

<p>The fact that there are “huge amount of prior art” doesn't assert certain feature is easy, sorry.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/908014/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor907880"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 16:12 UTC (Tue)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/907880/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <blockquote>Anyone noticed that 'unsafe' as a general concept has suddenly been redefined to mean 'whatever Rust prevents' (if you don't use `unsafe`, which the Rust for linux code does all over the place)? When people involved in Rust's development realised just before the release of the language that the language was fundamentally unsound, allowing memory leaks, they quietly redefined 'safety' to exclude leak freedom, because they didn't have time to properly fix it before 1.0. This was despite months and years of telling people how wonderful Rust was because it prevented memory leaks, lol.</blockquote>

<p>No, the "leakpocalype" (There's your googleable keyword) was specifically about the realization that the original version of the scoped threads API that got re-added recently was unsound because it didn't account for Arc&lt;T&gt; and a reference cycle allowing you to leak memory and, as such, allowed code not marked with "unsafe" to create pointers that outlived what they pointed to.</p>

<p>There was nothing "quietly" about it, and the thing they didn't have time to properly fix before 1.0 was the scoped threads API. It was already clear that preventing memory leaks in the the general case was a <a rel="nofollow" href="https://en.wikipedia.org/wiki/Rice%27s_theorem">Rice's theorem</a> problem. (Among other reasons, it's a good hint it might be when you can "leak memory" in the "same externally observed properties" sense in JavaScript just by losing track of which event handlers you've forgotten to unregister.)</p>

<blockquote>It's specified as 'whatever rustc does'.</blockquote>

As opposed to "whatever GCC does" like the dialect of C that the Linux kernel requires, which LLVM is still working to perfectly replicate?

<blockquote>Nobody has EVER explained what it provides to the kernel that Ada or better static analysis tools for C could not.</blockquote>

<p>Ada is more focused on constraining integer types, which requires more runtime support, which makes it a worse fit for interoperating with an existing C kernel. Also, I don't have a citation for this, but I remember reading a comment that it's misleading to look at GCC's platform support and assume that GNAT has proper support for all those platforms.</p>

<p>(And then there's the fact that Ada's more Wirth-style syntax feels more alien to the average 21st-century programmer than Rust's "Ocaml in a C++ trench coat" syntax does, and part of the interest in Rust is in heading off the "COBOL programmers get paid a ton because demand is outstripping supply" problem the kernel might face in the coming decades.)</p>

As for "better static analysis tools", I've used <a rel="nofollow" href="http://splint.org/">Splint</a>. Annotating C with the information needed to prove the relevant properties at compile time <em>rapidly</em> makes the code less readable than the equivalent Rust. That's why you generally don't see people just extending C to get the same results.

<blockquote>And last I checked, 'async' in Rust is widely considered a failure of design.</blockquote>

<p>Citation, please. The people I've seen tend to say that it's an impressive exercise in pushing the boundaries for what can be achieved without tracing garbage collection.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/907880/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907894"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 21:02 UTC (Tue)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/907894/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
How does anyone come to the conclusion that Rust is &quot;supposed to&quot; prevent memory leaks, when Box has a whole convenience function specifically for leaking memory? It boggles the mind.<br>
<p>
<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak">https://doc.rust-lang.org/std/boxed/struct.Box.html#metho...</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907894/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907902"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 1:54 UTC (Wed)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/907902/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Feel free to check when that function was added<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907902/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908024"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 17:14 UTC (Wed)
                               by <b>lambda</b> (subscriber, #40735)
                              [<a href="/Articles/908024/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Feel free to check when that function was added</font><br>
<p>
mem::forget was the original variant of this, and it was stabilized as safe pre-1.0 <a href="https://doc.rust-lang.org/std/mem/fn.forget.html">https://doc.rust-lang.org/std/mem/fn.forget.html</a> . It was originally marked as unsafe (in earlier pre-1.0 releases), but when it was realized that safety invariants couldn&#x27;t depend on destructors being guaranteed to run, it was changed to be marked as safe in order to make that point more clear.<br>
<p>
Box::leak is just a newer variant that provides a nicer API, allowing you to extract a reference to the leaked value at the same time.<br>
<p>
It was always known that it was possible to leak memory by forming a reference counted pointer cycle, but it was fairly late in the pre-1.0 process that folks realized the interaction between this fact, and some proposed APIs that required blocking in a destructor in order to keep a stack frame alive, were incompatible. There was a long and reasoned discussion about it, and the Rust team decided that because it&#x27;s not possible to categorically prevent resource exhaustion in a Turing complete language, that it was better to have the rules for what could be done in safe code include leaking memory (or otherwise failing to run destructors), and then code that provides safe abstractions has to keep that in mind, so you couldn&#x27;t rely on blocking in a destructor to keep a stack frame alive.<br>
<p>
It took some time in the development of Rust to figure out what the rules should be for what is marked as &quot;safe&quot; vs &quot;unsafe&quot;; you might imagine that any kind of undesirable behavior, like memory leaks, should be considered unsafe. But the distinction that the Rust project ended up on, and I think is the right decision, is that unsafe is only required for operations which could lead to undefined behavior. Rust provides tools to help prevent other kinds of undesirable behavior, like destructors that free memory for you when exiting a stack frame, but it won&#x27;t refuse to compile code in which you set up a reference cycle and thus leak memory, as the behavior in that case is perfectly well defined, you just use more resources and may eventually run out.<br>
<p>
Does this make sense to you? I feel like you are implying that there has been some massive rug-pull about what safety guarantees Rust provides, while Rust never guaranteed freedom from resource exhaustion, and during the run-up to 1.0 there was some learning about exactly the kind of guarantees you could make about when destructors were run, and some updates to the understanding of what unsafe code could rely on based on that and some engineering tradeoffs. If I&#x27;m misunderstanding your implication, or not explaining this clearly enough, let me know!<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908024/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor907904"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 3:08 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/907904/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>If language is serious about memory leaks then it have to provide tools which leak memory.</p>

<p>This may sound paradoxical, but it's not. If you define “memory leak” as something crazy and mostly useless (like tracing-GC languages do: it's not a memory leak if objects can be accesses by “live pointers”… even if program have no code which may actually ever access these objects) then you may “prevent them” but this wouldn't do anyone any good.</p>

<p>Either your language allows memory leaks <i>by losing track of which event handlers you've forgotten to unregister</i> or it's not a general-purpose language.</p>

<p>And if you admit that layman-definition memory leaks (as in: something which takes infinite amount of memory as time goes on is a memory leak, period) are impossible to prevent then having function which is specifically dedicated to creating persistent objects is obvious choice: this means that objects generated by that function can be treated specially by sanitizers, etc.</p>

<p>Lisps typically have these these to implement <a href="https://en.wikipedia.org/wiki/Interning_(computer_science)">interning</a>, e.g.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/907904/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor907915"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 6:22 UTC (Wed)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/907915/">Link</a>] (12 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Added in 2017, long after Rust 1.0. <br>
<p>
<a href="https://github.com/rust-lang/rust/pull/45881">https://github.com/rust-lang/rust/pull/45881</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907915/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907918"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 6:35 UTC (Wed)
                               by <b>zdzichu</b> (subscriber, #17118)
                              [<a href="/Articles/907918/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Meh, I&#x27;ve expected it would be an April 1st commit. I&#x27;m dissapointed.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907918/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor907945"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 9:10 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/907945/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wow:  Box::leak&lt;&#x27;a&gt;(Box&lt;T&gt;) -&gt; &amp;&#x27;a mut T where T: &#x27;a<br>
<p>
Are there really people who can parse this ? And how is that supposed to be pronounced ? That&#x27;s still one of the biggest showstopper for me in this language, coding entirely with smileys. There are 16 symbols for 24 alphanumeric chars in this statement, I have no idea what this could mean at all nor whether that generates some code or only declares stuff. Go find a typo there... It&#x27;s totally cryptic to me :-(<br>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907945/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907949"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 10:28 UTC (Wed)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/907949/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <p>Hey, it's a lot easier to understand than C function pointer syntax and you get a lot more guarantees out of it too.</p>

<p>For the record, that says:</p>

<ol>
<li>Member of "Box" named "leak"</li>
<li>Has one lifetime parameter named "a" (&lt;a'&gt; <em>is</em> a bit odd because it's actually two different "this is a generic" syntaxes smushed together. &lt; and &gt; from C++ denote the list of generic type parameters, and the leading apostrophe is a reurposing of Ocaml's syntax for generics, because lifetimes are a special kind of generic type parameter and Rust is sort of an ML-family language in a trench coat, to the point where the Rust compiler was written in OCaml before it became self-hosting.</li>
<li>Takes one argument of type "Box&lt;T&gt;" where T is a generic parameter.</li>
<li>Returns a mutable reference to whatever type T the box contained with lifetime "'a"</li>
<li>Returns neither a raw/FFI pointer nor something wrapped in Option&lt;T&gt;, so it's non-nullable.</li>
<li> Does not wrap the return value in Option&lt;T&gt; or Result&lt;T, E&gt;, so the operation is considered infallable barring system abstractions failures such as power outages, cosmic ray bit flips, etc.</li>
</ol>

As for that "where" clause, that's incorrect. The signature is actually

<pre>
pub fn leak&lt;'a&gt;(b: Box&lt;T, A&gt;) -&gt; &amp;'a mut T
where
    A: 'a,
</pre>
    
<p>That "A" generic is the allocator and defaults to the configured global allocator, which defaults to libc's malloc, so the "where A: 'a" part is saying that it will return a mutable reference that must not outlive allocator that was used to allocate what it points to.</p>

<p>It comes from the declaration for the Box struct as a whole:</p>

<pre>pub struct Box&lt;T, A = Global&gt;(_, _) 
where
    A: Allocator,
    T: ?Sized;
</pre>

<p>("?Sized" is used to opt out of the default "only types with sizes known at compile time" constraint... which is particularly relevant here because, in type constraint terms, Box is a wrapper to convert an unsized type into a sized type.)</p>









      
          <div class="CommentReplyButton">
            <form action="/Articles/907949/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908012"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 15:16 UTC (Wed)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/908012/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
C function pointer syntax is absolutely trivial. If you know how to write expressions you know how to write type expressions.<br>
<p>
If you have A, an array of pointers to functions that take an integer, a function taking int and returning int, and a pointer to a string, and which returns void*, how do you call it?<br>
<p>
A[0] // get one of the function pointers<br>
(*A[0]) // dereference the pointer<br>
(*A[0])(1, f, &quot;hello&quot;) // call it<br>
<p>
How do you write the type?<br>
<p>
int (*fps[])(int, int(*)(int), const char *);<br>
<p>
It&#x27;s almost exactly the same as calling it. This is well known. It is not difficult or complicated, and is far easier to understand than the line noise that is Rust or Perl. In Rust or C++ you need to learn about a hundred different sublanguages to learn the language proper. In C, the declaration and use syntax are almost exactly the same. Once you know one, you know the other.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908012/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908021"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 16:15 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/908021/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; In C, the declaration and use syntax are almost exactly the same. Once you know one, you know the other.</font>

<p>And in LISP it's even more uniform thus easier, right? Everyone uses lisp, right? No? Not everyone? But why?</p>

<p>Think about it.</p>

<font class="QuotedText">&gt; It's almost exactly the same as calling it.</font>

<p>If you forget about the fact that for function which returns function (like already mentioned <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html">void (*signal(int, void (*)(int)))(int)</a>) it doesn't work. That function have two arguments yet ends with <code>(int)</code> somehow. And about the fact that standalone variable declared as <code>int x[3];</code> has entirely different type from argument of function declared in the same fashion. And about bazillion other similar quirks.</p>

<p>Yes, C is simple if you ignore details. Which invariably bites you in the ass later. While Rust makes sure you wouldn't forget about details.</p>

<p>Yes, it's different strategy, but it works much better for the large or huge projects where hundreds or thousands people work on the same codebase.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/908021/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908043"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 19:27 UTC (Wed)
                               by <b>ssokolow</b> (guest, #94568)
                              [<a href="/Articles/908043/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The fact that the Clockwise/Spiral rule exists, and that I&#x27;ve had to look at this page more than once over the years, seems to disagree.<br>
<p>
https://c-faq.com/decl/spiral.anderson.html<br>
<p>
I never had to refresh my memory of how Rust type signatures worked back in the days before I started using it actively.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908043/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908820"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2022 22:25 UTC (Tue)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/908820/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For any pythoner c-style end of a function looks like wierd smiles too ); or ;}. And logic operations are terrible ! a&amp;&amp;b||c. Compare with not a and b or c.<br>
<p>
So when you mock rust for syntax, don&#x27;t forget about !!a&gt;&gt;b%c&amp;&amp;--d--.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908820/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor907956"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 11:04 UTC (Wed)
                               by <b>excors</b> (subscriber, #95769)
                              [<a href="/Articles/907956/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>I think it's not that complicated if you start learning Rust from a book that gradually introduces all the concepts and syntax (like <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a>). But you can't expect to automatically know what it means without putting some effort into learning the language, even if you're already very familiar with e.g. C++.</p>

<p>You can start with the basic syntax for declaring a struct, and an associated function that can be called with an argument of that type, which is pretty straightforward:</p>

<pre>struct Foo {
  val: i32,   // i32 is the 32-bit signed integer type
}
impl Foo {
  fn bar(f: Foo) -&gt; i32 {   // return type is i32
    f.val
  }
}</pre>

<p>Then you make it generic by replacing 'i32' with a type parameter T (similar to C++ templates):</p>

<pre>struct Foo<b>&lt;T&gt;</b> {
  val: <b>T</b>,
}
impl<b>&lt;T&gt;</b> Foo<b>&lt;T&gt;</b> {
  fn bar(f: Foo<b>&lt;T&gt;</b>) -&gt; <b>T</b> {
    f.val
  }
}</pre>

<p>Instead of returning a copy of the value, you might want to return a reference. References are either shared ("&amp;T") or exclusive ("&amp;mut T"), where an exclusive reference cannot exist simultaneously with any other reference to the same object. Since Box::leak consumes the object and returns a single reference, it can be exclusive:</p>

<pre>fn bar(f: Foo&lt;T&gt;) -&gt; <b>&amp;mut T</b> {
  // ...
}</pre>

<p>But reference types have lifetimes (so the compiler can verify the reference won't outlive the object it's referring to). That's one of the major new concepts in Rust, so you need to spend time learning about that. Often it all works automatically with no extra syntax and you don't even need to think about it, but if you're doing something slightly tricky then you need to explain it to the compiler. For Box::leak we can safely return a reference with <i>any</i> lifetime (because that will always be shorter than the (infinite) lifetime of the leaked object), so we make the function generic over an unconstrained lifetime parameter 'a (similar to making it generic over a type T), and use that lifetime for the reference:</p>

<pre>fn bar<b>&lt;'a&gt;</b>(f: Foo&lt;T&gt;) -&gt; &amp;<b>'a</b> mut T {
  // ...
}</pre>

<p>There's also a potential issue if T contains references to other objects - even though the leaked T is given an infinite lifetime, it may refer to objects with shorter lifetimes, and it's not safe to access the T after those objects' lifetimes. So we add an extra constraint to say that T's lifetime (which (I think) is defined as the lifetimes of any references contained within T) must be as long as 'a:</p>

<pre>fn bar&lt;'a&gt;(f: Foo&lt;T&gt;) -&gt; &amp;'a mut T
  <b>where T: 'a</b>
{
  // ...
}</pre>

<p>But that's not actually required for safety (the original patch says "Technically not needed, but kept to be explicit." and it was removed in later versions) - I think the borrow checker already prevents that potential issue.</p>

<p>And that matches the original definition of Box::leak. (It doesn't quite match the GitHub issue title you quoted, but they just improvised syntax to make it more concise. And it doesn't quite match the modern definition of Box::leak because they added the allocator type parameter.)</p>

<p>It looks intimidating at first, but I think it's okay when you go step by step with a willingness to learn. And this is a relatively complicated example - most Rust code doesn't need to be explicit about lifetimes, the default behaviour is usually sufficient.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/907956/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908010"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 14:59 UTC (Wed)
                               by <b>mbunkus</b> (subscriber, #87248)
                              [<a href="/Articles/908010/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Thank you, ssokolow &amp; excors, for two very nice explanations.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908010/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor907954"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 11:08 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/907954/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Are there really people who can parse this ?</font>

<p>Sure. It's actually easier to parse than something like <a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/signal.html">void (*signal(int, void (*)(int)))(int);</a>.</p>

<p>I mean: is it a function? Or pointer? Where are arguments? Heck, <b>how many</b> arguments are there?</p>

<p>Rust code can be parsed from left to right, at least.</p>

<font class="QuotedText">&gt; And how is that supposed to be pronounced ?</font>

<p>How is the definition of <code>signal</code> is supposed to be pronounced?</p>

<font class="QuotedText">&gt; There are 16 symbols for 24 alphanumeric chars in this statement</font>

<p>And 13 symbols for 20 alphanumeric chars in C is, somehow, radically better?</p>

<font class="QuotedText">&gt; It's totally cryptic to me :-(</font>

<p>Well… if you don't know the language, of course it would be cryptic. But Rust syntax while ugly, serves a purpose: it makes code similar to C++. And, as I have already mentioned, is actually easier to parse than C or C++. Yes, it's punctuation-heavy, but you can blame C and C++ for that: most sigils have come into Rust from there. Only <code>'a</code> is new but Ada uses such syntax, too.</p>

<p>I still hate Rust syntax (much less elegant than it could have been), but it's <b>useful</b> uglyness: it makes Rust look superficially similar to C++. Which is important mimicry not to spook C++ developers before they would be hooked.</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/907954/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908042"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 19:33 UTC (Wed)
                               by <b>Dr-Emann</b> (guest, #136829)
                              [<a href="/Articles/908042/">Link</a>] 
      </p>
      
      </div>
      </summary>
      For anyone <em>actually</em> trying to parse the signal type, it helps a lot to have a <a href="https://man7.org/linux/man-pages/man2/signal.2.html">typedef</a>:

<pre>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
</pre>

The equivalent in rust is still pretty readable without a typedef:

<pre>
fn signal(signum: c_int, handler: fn(int)) -&gt; fn(int)
</pre>




      
          <div class="CommentReplyButton">
            <form action="/Articles/908042/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor908065"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 22:25 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/908065/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Was it absolutely necessary to post two different replies both (essentially) saying the same thing? Especially considering that, as another commenter pointed out, mem::forget is significantly older, so your argument is not even correct.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908065/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
<a name="CommAnchor907873"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 18:23 UTC (Tue)
                               by <b>lambda</b> (subscriber, #40735)
                              [<a href="/Articles/907873/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m sure I shouldn&#x27;t be replying to the troll, but since other folks reading might be misled by this comment, I figure I should provide some clarifications.<br>
<p>
<font class="QuotedText">&gt; So in other words: oh yes, there are still bugs, but we can just blame them on C. Any issues with interfacing Rust and C? Obviously the fault of C.</font><br>
<p>
The fundamental unique feature of Rust is that it enables you to build safe abstractions around unsafe code (we&#x27;ll get to what &quot;safe&quot; means in a bit). Whether you are interfacing with C, or defining your own primitives in Rust, doing that can be tricky, but once it&#x27;s done, you have fairly strong guarantees on what can happen in the safe code that uses those abstractions.<br>
<p>
So, this isn&#x27;t &quot;blaming bugs on C&quot;, but just an acknowledgement that Rust is not a silver bullet (and has never been intended as such), and that the fundamental work of building safe abstractions over unsafe code still requires care. Since there are a large number of abstractions that already exist in the Linux kernel, interoperating with them requires work, and there will be bugs in the process.<br>
<p>
<font class="QuotedText">&gt; In other words &quot;no we haven&#x27;t actually tested it but I&#x27;m sure the language prevents bugs, they&#x27;re totally impossible&quot;.</font><br>
<p>
You&#x27;re attacking a strawman here. No one has ever said that bugs are totally impossible.<br>
<p>
<font class="QuotedText">&gt; Anyone noticed that &#x27;unsafe&#x27; as a general concept has suddenly been redefined to mean &#x27;whatever Rust prevents&#x27;</font><br>
<p>
&quot;Unsafe&quot; in Rust means &quot;can do things that could potentially be undefined behavior&quot; or in other words, could potentially have executions which have no valid behavior under the language model. And as a Turing-complete, general purpose language, Rust is not intended to prevent you from making logic bugs, infinite loops, or resource leaks; it does have a number of design features that help make them more difficult to make (RAII, exhaustive match statements, etc), but it makes a hard distinction between things that it prevents categorically, and things that the language design helps with but doesn&#x27;t prevent entirely.<br>
<p>
And this definition is part of a contract between the compiler, standard library, and libraries that provide safe abstractions over unsafe code. There needs to be a definition of what rules such libraries need to follow, and what assumptions they can make, so that you can combine two different libraries which each provide safe abstractions over unsafe code, and the combination itself will continue to be safe.<br>
<p>
So this particular set of rules are &quot;whatever Rust prevents.&quot; As an example, pre-Rust 1.0, there were some API designs that were safe only if it was impossible to leak an object and return to the caller; but of course, reference counted pointers could be set up to cause a cycle and leak an object. There was a long involved discussion of this, with various proposals, but in the end, it was decided that categorically preventing leaks would impose too much burden on language and library design; for instance, it would require a much more complicated system for reference counted objects in order to prevent circular references, and impose similar design burdens many other kinds of data structures. So rather, it was decided that leaking objects wasn&#x27;t something that would be categorically prevented in safe code, and libraries that provide safe abstractions over unsafe primitives can&#x27;t depend on an object not being leaked for their safety guarantees.<br>
<p>
So that&#x27;s just part of the contract now; there were alternative possibilities for that contract, which would have had different tradeoffs, but this was the tradeoff chosen.<br>
<p>
Effectively, what is forbidden in safe Rust is anything which could cause objects to be interpreted as the wrong type, accessed when they are not valid, or accessed in overlapping ways in space or time. This means no out of bounds access, use after free, data races (two threads accessing the same memory in ways that no linear interleaving could produce), iterator invalidation, etc. This is a category of bugs which are quite common in C and C++ programs, which are difficult to reason about because they effectively break the model of the programming language, and are quite commonly prone to exploitation by attackers.<br>
<p>
Leaking an object, on its own, does not lead to arbitrary behavior; it&#x27;s undesirable, and can lead to resource exhaustion, but in any Turing complete language you could write code which never halts or uses up an arbitrary amount of resources.<br>
<p>
<font class="QuotedText">&gt; because they didn&#x27;t have time to properly fix it before 1.0</font><br>
<p>
This is not true. It was not the case that &quot;they didn&#x27;t have time to properly fix it&quot;, it&#x27;s that there is no way to statically prevent leaking of resources in a way that would not be overly burdensome on the API of data structures.<br>
<p>
<font class="QuotedText">&gt; This was despite months and years of telling people how wonderful Rust was because it prevented memory leaks, lol.</font><br>
<p>
No one has ever claimed that Rust prevented memory leaks. Reference counted types have existed from the beginning, and everyone has always known that it&#x27;s possible to create reference counted cycles and leak memory that way. Anyone who thought that Rust was supposed to prevent all memory leaks likely misinterpreted the term &quot;memory safety&quot;, which is a term that predates Rust, and refers to preventing unsafe access to objects, not preventing leaking of objects.<br>
<p>
<font class="QuotedText">&gt; Rust is &#x27;trusting trust&#x27; on steroids, for one thing.</font><br>
<p>
There are at least two independent bootstrap paths currently possible for the Rust compiler; you can start from the original pre-1.0 compiler written in OCaml and bootstrap from release to release that way. Or there is an independent compiler, mrustc, written in C++ which is able to compile much more recent releases of rustc and start the bootstrap chain that way. This provides the diverse double compilation necessary to defeat trusting trust attacks.<br>
<p>
<font class="QuotedText">&gt; Nobody has EVER explained what it provides to the kernel that Ada or better static analysis tools for C could not.</font><br>
<p>
Kernel developers are interested in writing kernel code in Rust, not Ada. Ada is far more foreign, and wasn&#x27;t designed for the same kind of interop with C and encapsulation of unsafe code behind safe interface that Rust was.<br>
<p>
A lot of people focus on the safety guarantees of Rust, because it has a unique approach to safety that no other language provides. But besides that, it&#x27;s a modern language with a lot of nice features that many developers appreciate, and with a focus on balancing those safety goals with usability, performance, and interop with existing ecosystems like C.<br>
<p>
&quot;Better static analysis&quot; can only get you so far. The language level support that Rust provides means that you design your APIs around the type system and lifetimes, which means that code can be statically checked independently and separately; the lack of such guarantees and annotations in C makes it far more difficult to add static checking that is anywhere near as robust as what Rust provides out of the box. It&#x27;s not for lack of trying; people have been writing static checkers for C and C++ for decades, and yet memory safety errors still cause the majority of security vulnerabilities in codebases written in C and C++.<br>
<p>
<font class="QuotedText">&gt; It&#x27;s specified as &#x27;whatever rustc does&#x27;. It has one implementation, with no other implementations even remotely close to being ready</font><br>
<p>
You realize that the same was true of C in the kernel until relatively recently, right? The kernel is not written in standard C; it&#x27;s written in GCC C. The kernel has a memory model that is different than the standard C memory model. The kernel is now mostly able to be built with clang as well, but only by years of effort of adding GCC features to clang and modifying the kernel to not rely on them in quite as many places.<br>
<p>
There is a Rust reference, and ongoing efforts on continuing to specify Rust, but this is mostly irrelevant to its usage in the kernel.<br>
<p>
<font class="QuotedText">&gt; There&#x27;s a huge list of nightly (basically brand new!) compiler features that are required to build it. No way should there be code in the Linux kernel that requires anything other than stable language features.</font><br>
<p>
An unstable feature in Rust is much like an implementation-specific feature in C; and the kernel uses plenty of GCC features. It&#x27;s a way of providing some features without committing to supporting that feature in exactly that form indefinitely; there may be backwards incompatible changes in the future. Implementation-specific features in GCC may be replaced by standardized C features in the future, but that doesn&#x27;t mean they aren&#x27;t used in the kernel.<br>
<p>
The entirety of the internal Linux kernel API is considered unstable, Linux only provides a stable interface to userspace; does that mean that no one writing code in one part of the kernel should depend on code in another part because it&#x27;s unstable? No, it just means that changes to libraries within the kernel may need to be propagated to usages as well. The same is true of these unstable Rust features; you opt into a few, with the knowledge that you may need to make changes later on when upgrading compilers. It&#x27;s something you shouldn&#x27;t use willy-nilly, but using a few features where you may need to make changes in the future is not that big a deal.<br>
<p>
These aren&#x27;t being used with abandon; there is a tracking issue explaining all unstable features, and standard library config flags, what they are needed for, how essential they are, whether they&#x27;re on track to stabilization, etc: <a href="https://github.com/Rust-for-Linux/linux/issues/2">https://github.com/Rust-for-Linux/linux/issues/2</a><br>
<p>
Some of them will be stabilized in Rust, some will be removed from the kernel, and some will be lived with.<br>
<p>
<font class="QuotedText">&gt;  (basically brand new!)</font><br>
<font class="QuotedText">&gt; generic associated types have been in progress for more than 5 years with no real sign that they&#x27;re going to be stabilised any time soon.</font><br>
<p>
Ok, besides the fact that as someone else pointed out, this feature was agreed to be stabilized within hours of your post (it had already been in final comment period for a while), it&#x27;s funny that you call these features &quot;basically brand new&quot; while also acknowledging that some of thems have been undergoing serious development for years.<br>
<p>
<font class="QuotedText">&gt; Nobody has even managed to represent the Wayland memory model in Rust, and the kernel is far more complicated than that. The one serious attempt to do so failed after months of work because it required writing thousands upon thousands of lines of memory management boilerplate. If you want to represent anything more complex than Box or Rc you need to just about write a thesis. </font><br>
<p>
There are hundred of crates that provide memory management primitives beyond Box and Rc (<a href="https://lib.rs/memory-management">https://lib.rs/memory-management</a>), plus numerous examples of successful integration of Rust into C and C++ projects with custom memory management, including Firefox.<br>
<p>
There was one project in which someone attempted to provide a general-purpose rust API over wlroots, a C Wayland library, and eventually decided that it wasn&#x27;t worth it for their purposes. That doesn&#x27;t mean it&#x27;s impossible; just that one person tried one approach, didn&#x27;t like it, and decided it wasn&#x27;t what they wanted to spend their time doing.<br>
<p>
<font class="QuotedText">&gt;  And last I checked, &#x27;async&#x27; in Rust is widely considered a failure of design.</font><br>
<p>
So much of a failure of design that it&#x27;s being used for substantial production usage like an entire rewrite of the Tor client in Rust in two years: <a href="https://blog.torproject.org/arti_100_released/">https://blog.torproject.org/arti_100_released/</a><br>
<p>
There are gripes that folks have with aspects of async in Rust; but it&#x27;s actually a very well received, widely used feature, that just happens to be a little bit young and has had some ecosystem growing pains.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907873/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907947"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 9:45 UTC (Wed)
                               by <b>wtarreau</b> (subscriber, #51152)
                              [<a href="/Articles/907947/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Effectively, what is forbidden in safe Rust is anything which could cause objects to be interpreted as the wrong type, accessed when they are not valid, or accessed in overlapping ways in space or time. This means no out of bounds access, use after free, data races (two threads accessing the same memory in ways that no linear interleaving could produce), iterator invalidation, etc. This is a category of bugs which are quite common in C and C++ programs, which are difficult to reason about because they effectively break the model of the programming language, and are quite commonly prone to exploitation by attackers.</font><br>
<p>
But it could also be said that several other categories of bugs are avoided in C thanks to the language being quite primitive and reading fairly well and being suitable for peer reviewing. Do you have an estimate of the increased amount of logic bugs or algorithmic ones that could be caused by the language being significantly more difficult to use when it resists to your demands ? For example I&#x27;ve been caught many times adding bugs when trying to simply shut up an inappropriate gcc warning. When a compiler tries to force you to do something one way that doesn&#x27;t match your need, the friction introduces new risks of bugs.<br>
<p>
<font class="QuotedText">&gt; &gt; This was despite months and years of telling people how&gt; wonderful Rust was because it prevented memory leaks, lol.</font><br>
<font class="QuotedText">&gt; No one has ever claimed that Rust prevented memory leaks. </font><br>
<p>
Note, the two of you said at least once &quot;nobody shows&quot; or &quot;nobody claimed&quot; etc. It&#x27;s pointless to use such rhetoric. It doesn&#x27;t add any value and needlessly increases tensions because anyone can have one personal counter example. I&#x27;ve personally heard someone tell me the point above for example, and that irritated me because I knew it was an absurd claim. Actually saying &quot;no authoritative developer said/demonstrated/claimed&quot;, or even better &quot;I&#x27;ve never heard any ...&quot; would be easier to deal with for both parties in the discussion.<br>
<p>
<font class="QuotedText">&gt;  &gt; It&#x27;s specified as &#x27;whatever rustc does&#x27;. It has one implementation, with no other implementations even remotely close to being ready</font><br>
<font class="QuotedText">&gt; You realize that the same was true of C in the kernel until relatively recently, right? The kernel is not written in standard C; it&#x27;s written in GCC C. The kernel has a memory model that is different than the standard C memory model. The kernel is now mostly able to be built with clang as well, but only by years of effort of adding GCC features to clang and modifying the kernel to not rely on them in quite as many places.</font><br>
<p>
I can understand this concern and I do share it as well. Not directly for the kernel in fact, rather for the language&#x27;s life expectancy. 15 years ago I was told that Ruby was *the* language of the future, that prevented bugs etc... (hint: it just made them slower to appear). Now in 2022 can anyone cite any developer not working for Gitlab still using this language ? I do have the same concern about Rust: as long as it remains the self-defined input of rustc, it&#x27;s not exactly a language and it can seriously fail over time. Serious implementations are absolutely required for it to survive. For sure Linux uses GCC C. But C is used everywhere and runs the whole internet, some built with gcc, some with any other compiler. It maintains an ecosystem afloat and forces implementations from various origins and use cases to exchange and evolve the standard. Rust does need to adopt a similar approach where there is no more *the* leading implementation and a few others trying to catch up like clang does with gcc or gnugo does with Go, but a set of slightly different implementations all following one standard to reach a 100% compatible code base. From there it&#x27;s fine if some projects decide to only use one flavor for various reasons.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907947/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907955"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 10:53 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/907955/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Rust does need to adopt a similar approach where there is no more *the* leading implementation and a few others trying to catch up like clang does with gcc or gnugo does with Go, but a set of slightly different implementations all following one standard to reach a 100% compatible code base. From there it&#x27;s fine if some projects decide to only use one flavor for various reasons.</font><br>
<p>
That is incredibly difficult to achieve. For two perfect examples from the database arena, SQL and DataBASIC. There&#x27;s a whole bunch of subtle differences between SQL dialects, as many people here will be able to attest. Likewise, although far fewer people here are familiar with it, DataBASIC. Both have multiple competing implementations, and there are many corner cases where early design decisions collide badly with compatibility - my favourite DataBASIC statement<br>
<p>
REM: REM = REM(6,3); REM this takes the remainder of 6 / 3<br>
<p>
Every single usage of REM makes sense, and is legal in at least one DataBASIC compiler, but trying to support all four in this one statement is, well, tricky ... (I believe at least one does, probably OpenQM/ScarletDME.)<br>
<p>
We&#x27;re likely to end up with just the one implementation of rust just to get round the dialect problem. Like most C code is written to the &quot;it compiles with gcc&quot; standard for exactly the same reason.<br>
<p>
Probably one of the big drivers pushing the kernel towards llvm/clang is too many developers are getting fed up with the breakages caused by the gcc developers attitude towards &quot;undefined behaviour&quot;. And if we do get the kernel compiling successfully with llvm/clang we could rapidly hit a tipping point where new code supports the &quot;well it compiles with llvm/clang&quot; standard.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907955/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908016"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 15:42 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/908016/">Link</a>] (5 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; Probably one of the big drivers pushing the kernel towards llvm/clang is too many developers are getting fed up with the breakages caused by the gcc developers attitude towards "undefined behaviour".</font>

<p>I really like how Rust <a href="https://faultlore.com/blah/tower-of-weakenings/">solved</a> that crazy provenance business.</p>

<p>Instead of trying to invent rules which would work for everyone (that's what C/C++ attempted, but failed to do and thus and still, after 20 years, doesn't have such rules, remember!) Rust just gives you <b>rules which you can use</b>! And then its developers go back to their blackboard to try to invent something better.</p>

<p>What is surprising is that this is what was <a href="https://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf">supposed to happen in the C land, too</a>: <i><b>Undefined behavior</b> gives the implementor license not to catch certain program errors that are difficult to diagnose. It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior.</i></p>

<p>Only in Rust case they actually do that, instead of trying to find an excuse to justify yet-another-way which compiler is allowed to break your program.</p>

<p>C++ once, long ago, was like that, too: it split C-style cast into <code>const_cast</code>, <code>dynamic_cast</code>, <code>reinterpret_cast</code> and <code>static_cast</code> for similar reasons.</p>

<p>But somehow in XXI century all that went out of the window. We can only hope Rust wouldn't repeat the same mistake.</p>




      
          <div class="CommentReplyButton">
            <form action="/Articles/908016/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908115"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 13:03 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/908115/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <p>The really nice thing about the Tower of Weakenings approach is that Rust is now able to have several layers of rules for provenance. Strict provenance is guaranteed to be correct for all implementations of Rust on all hardware that can support Rust; but because you have this portable set of rules, it's now possible to define rules like "for Rust on AArch64" or "for single-threaded Rust programs" that only apply if you're a special case.
<p>In C and C++ standard terms, this has "strict provenance" as the rules that must apply, while permitting implementations to define relaxations of strict provenance that they will also accept as valid.


      
          <div class="CommentReplyButton">
            <form action="/Articles/908115/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908187"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 19:34 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/908187/">Link</a>] (3 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But somehow in XXI century all that went out of the window. We can only hope Rust wouldn&#x27;t repeat the same mistake.</font><br>
<p>
As I&#x27;ve said before, the C/C++ standards committee should be removing undefined behaviour. Placing the onus on the compiler writers to provide implementation-defined behaviour. Saying it&#x27;s &quot;whatever the hardware does&quot;. Whatever whatever but getting rid of all that crap.<br>
<p>
And then there are things you can&#x27;t define for whatever reason, where you admit that a definition is impossible.<br>
<p>
The thing is, Rust has all three of those, and it clearly pigeonholes them. Safe Rust is supposedly *only* *defined* behaviour. And if undefined behaviour creeps into safe code it is defined as a BUG, a MUST-FIX.<br>
<p>
I guess all that &quot;hardware defined&quot; stuff probably belongs in the &quot;unsafe Rust&quot; category, where the language can&#x27;t reason because it doesn&#x27;t have any idea what&#x27;s going to happen behind its back.<br>
<p>
And then there&#x27;s the stuff you can&#x27;t define, which is unsound, because there&#x27;s some fault in the logic somewhere.<br>
<p>
The important thing is, the programmer can REASON about all this lot, unlike C, where hardware behaviour triggers &quot;undefined behaviour&quot;, and the C compiler makes a whole bunch of false assumptions and screws up your code (like deleting necessary safety checks, etc etc).<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908187/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908192"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 20:19 UTC (Thu)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/908192/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <p>But the thing is: this is what was supposed to happen with C and C++, too! Except for safe subset, but otherwise it was planned like that.</p>

<p>I mean… the <a href="https://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf">Rationale for
International Standard— Programming Languages— C</a> says: <i><b>Undefined behavior</b> gives the implementor license not to catch certain program errors that are
difficult to diagnose. It also identifies areas of possible conforming language extension: <b>the implementor may augment the language by providing a definition of the officially undefined behavior</b>.</i></p>

<p>This is your <i>Tower of Weakenings</i> right there!</p>
<p>Note that before C89 was punished it <b>actually</b> worked that way: there was no standard but different implementations permitted different things and even if some were not so easy to implement (e.g. one-element-past-the-end-of-array means it becomes impossible to have simple 64KiB arrays on MS-DOS) they were added to standard where it made sense.</p>

<p>I wonder how that stance turned into “if standard says something is undefined behavior then we have the carte blanche to destroy the program” and then “if standard doesn't say something is undefined behavior <b>yet</b> then we have the permission to destroy your program <b>anyway</b>”.</p>

<p>I don't think there was some evil mastermind behind all these developments, but the end result sure is complete lack of trust.</p>

<p>Periodic Linus outbursts and public complaints is <b>not</b> how you plan development of language which is used by millions!</p>


      
          <div class="CommentReplyButton">
            <form action="/Articles/908192/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908200"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 21:35 UTC (Thu)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/908200/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; I wonder how that stance turned into “if standard says something is undefined behavior then we have the carte blanche to destroy the program” and then “if standard doesn&#x27;t say something is undefined behavior yet then we have the permission to destroy your program anyway”.</font><br>
<p>
Portability I would guess. Once more than one compiler could target a given platform (or one compiler could target more than one platform), &quot;my compiler/platform is better than yours&quot; creeps in and you start down the path of &quot;what kinds of optimizations can we squeeze out here?&quot; come up.<br>
<p>
Today? Code that is written to work on multiple platforms from the same source. Here, the compiler saying &quot;well, if it were $obscure_arch, this is different behavior, so we&#x27;ll show it to you on your machine via UB-based optimizations (but not make any noise about it either)&quot;.<br>
<p>
On one hand, a UB-less C would be &quot;safer&quot;, but its portability would tank because &quot;it worked on my x86_64&quot; means diddly squat when you compile it for aarch64.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908200/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908206"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 22:33 UTC (Thu)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/908206/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; On one hand, a UB-less C would be &quot;safer&quot;, but its portability would tank because &quot;it worked on my x86_64&quot; means diddly squat when you compile it for aarch64.</font><br>
<p>
You&#x27;ve missed &quot;implementation defined&quot; and &quot;hardware defined&quot;.<br>
<p>
If something is &quot;hardware defined&quot; then yes, just because it works on x86_64, you can&#x27;t expect the SAME code to work on aarch64, but firstly the programmer will KNOW that they need to check behaviour, and secondly they can put the ifdefs and whatever in there, and know that that IS DEFINED behaviour.<br>
<p>
The *only* grounds for UB should be because &quot;we can&#x27;t define it because we can&#x27;t get the logic to add up&quot;. There&#x27;s no need for the C/C++ standard to define everything itself - it can defer the definition to something else - but all behaviour should be defined *somewhere*, if a definition is possible.<br>
<p>
Take for example the size of a byte. In *PRACTICE* it&#x27;s always 8-bit nowadays. I wouldn&#x27;t be surprised if it&#x27;s actually already implementation or hardware defined, but that&#x27;s a perfect example of something that makes perfect sense as hardware-defined. In places, bytes are 6 bits, and if the programmer doesn&#x27;t account for it it will cause a major problem if they&#x27;re targetting an old platform. But the standard CAN, and SHOULD, address it.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908206/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor907995"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 13:56 UTC (Wed)
                               by <b>tialaramex</b> (subscriber, #21167)
                              [<a href="/Articles/907995/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; For example I&#x27;ve been caught many times adding bugs when trying to simply shut up an inappropriate gcc warning. </font><br>
<p>
If the warning is inappropriate in Rust, simply explain why in the source code<br>
<p>
// We genuinely need Drop here, see <a href="https://some.example/url">https://some.example/url</a><br>
#[allow(drop_bounds)]<br>
<p>
And we can promote a warning in the opposite way<br>
<p>
// We tried asking people nicely, it didn&#x27;t work. If you write an overlapping range this won&#x27;t compile. Learn to count.<br>
#[forbid(overlapping_range_endpoints)]<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907995/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor907993"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 15:35 UTC (Wed)
                               by <b>lambda</b> (subscriber, #40735)
                              [<a href="/Articles/907993/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; But it could also be said that several other categories of bugs are avoided in C thanks to the language being quite primitive and reading fairly well and being suitable for peer reviewing. Do you have an estimate of the increased amount of logic bugs or algorithmic ones that could be caused by the language being significantly more difficult to use when it resists to your demands ? For example I&#x27;ve been caught many times adding bugs when trying to simply shut up an inappropriate gcc warning. When a compiler tries to force you to do something one way that doesn&#x27;t match your need, the friction introduces new risks of bugs.</font><br>
<p>
I have not noticed any such tendency in Rust.<br>
<p>
One of the advantages of Rust is that the more powerful type system, and a number of language design features, make a lot of things more explicit and possible for the compiler to reason about precisely. For instance, reference types and nullability are orthogonal, so you don&#x27;t have to constantly add checks for null; the type tells you if a reference could possibly be null, and so there there can be fewer spurious compiler warnings due to the higher precision of the type system.<br>
<p>
Another example would be warnings about use of uninitialized value, like the famous Debian SSH key bug that was introduced by trying to silence a warning about use of uninitialized values. Because this warning was found by someone later who wasn&#x27;t the original author, they weren&#x27;t as familiar with the code when trying to fix it, and they made a mistake and removed the actual source of entropy that was being used as well as the uninitialized value. In Rust, this is not a separate warning, but part of the language, so it&#x27;s something that needs to be dealt with by the original author, rather than by someone else later on trying to silence warnings and not paying enough attention.<br>
<p>
That&#x27;s one of the major design goals of Rust; rather than having to rely on imprecise lints that can frequently lead to spurious warnings and dubious fixes, to have greater expressiveness in the language itself that allow these checks to be precise and enforced consistently, which leads to less confusion.<br>
<p>
Usually, the kinds of workarounds that you need to do in cases where the compiler gets it wrong are to just be a little bit more explicit, possibly at the cost of being more verbose. I don&#x27;t know of many cases where this has caused the introduction of bugs; I&#x27;m sure it could happen, but in my experience it seems like the additional expressiveness and precision of the type system far outweighs that, leading to many fewer of these kinds of bugs than you find in C.<br>
<p>
<font class="QuotedText">&gt; Note, the two of you said at least once &quot;nobody shows&quot; or &quot;nobody claimed&quot; etc. It&#x27;s pointless to use such rhetoric. It doesn&#x27;t add any value and needlessly increases tensions because anyone can have one personal counter example.</font><br>
<p>
Sorry, fair point! This is a somewhat common misconception, so you&#x27;re right, my rhetoric was probably too strong here.<br>
<p>
<font class="QuotedText">&gt; 15 years ago I was told that Ruby was *the* language of the future, that prevented bugs etc... (hint: it just made them slower to appear). Now in 2022 can anyone cite any developer not working for Gitlab still using this language ?</font><br>
<p>
Ruby seems like a fairly different case than Rust, but off the top of my head, Homebrew, Vagrant, Discourse are all fairly widely used tools written in Ruby; and of course, Ruby on Rails is still a quite popular framework for writing web apps, though many of them are non-free, simply SaaS applications.<br>
<p>
<font class="QuotedText">&gt; I do have the same concern about Rust: as long as it remains the self-defined input of rustc, it&#x27;s not exactly a language and it can seriously fail over time.</font><br>
<p>
There are plenty of other successful, long-lived languages. Python has been around for as long as the Linux kernel, and it is defined by a single primary implementation, while also having alternate compatible implementations that are useful like PyPy, and Python is widely used for a large variety of software.<br>
<p>
Rust is younger, and thus its alternate implementations are younger and not yet as complete, but it has one independent implementation mrustc which can be used for bootstrapping the compiler, it has another completely independent implementation in the gcc-rs project, and it has a GCC-based backend being added to rustc to supplement the LLVM based backend. The progress on these two implementations has been discussed on LWN recently: <a href="https://lwn.net/Articles/907405/">https://lwn.net/Articles/907405/</a><br>
<p>
I&#x27;ve also heard rumors that there are other implementation projects that haven&#x27;t yet been made public; of course those could never see the light of day, but there is a lot of active work in this field right now.<br>
<p>
There is also the Rust reference, there&#x27;s an extensive test suite, there&#x27;s the entirety of crates.io which is used as an additional test suite, and there&#x27;s a draft Ferrocene Language Specification <a href="https://spec.ferrocene.dev/">https://spec.ferrocene.dev/</a> which is intended to provide a set of requirements that can be verified against for safety-critical applications.<br>
<p>
<font class="QuotedText">&gt; Rust does need to adopt a similar approach where there is no more *the* leading implementation and a few others trying to catch up like clang does with gcc or gnugo does with Go</font><br>
<p>
I&#x27;m not sure I follow; as you&#x27;re saying here, the situation for Rust is no different than the situation with C in the Linux kernel, where GCC is the leading implementation and clang is catching up. Are you saying that Rust needs to be held to a higher standard, where there are two independent implementations with feature parity before you can use it? I don&#x27;t think that this is a reasonable requirement.<br>
<p>
Yes, there is value in having multiple independent implementations, but there&#x27;s also substantial cost in writing the new compiler and the standardization process itself. As mentioned, there is work in progress on all of these fronts (alternative implementations, and more detailed specifications/standards), but I don&#x27;t think there&#x27;s any reason to avoid using Rust before those are complete.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907993/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908168"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 19:02 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/908168/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Not directly for the kernel in fact, rather for the language&#x27;s life expectancy. 15 years ago I was told that Ruby was *the* language of the future, that prevented bugs etc...</font><br>
<p>
Ruby has been overshadowed by Go and JS now that most complex webapps have frontends in JavaScript and the backend just provides a REST API. But back in the day, Ruby allowed tons of small companies to quickly build decent applications and get to market with them.<br>
<p>
This list includes GitHub, AirBnB, Groupon, Zillow and many others. The company where I work is built on top of a Ruby app as well. <br>
<p>
So it&#x27;s fair to say that Ruby absolutely fulfilled its promise in the area of web apps. And it has never been really intended as a systems language or a language for desktop applications.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908168/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908190"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 19:39 UTC (Thu)
                               by <b>rahulsundaram</b> (subscriber, #21946)
                              [<a href="/Articles/908190/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And it has never been really intended as a systems language</font><br>
<p>
Yep, it hasn&#x27;t advertised as one.  Aside from the web arena, tools like Puppet or Chef uses it but that&#x27;s quite different from being a systems language.  <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908190/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor907942"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 9:51 UTC (Wed)
                               by <b>Fabien_C</b> (guest, #160870)
                              [<a href="/Articles/907942/">Link</a>] (4 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Ada is far more foreign, and wasn&#x27;t designed for the same kind of interop with C and encapsulation of unsafe code behind safe interface that Rust was.</font><br>
<p>
Ada/C interoperability is on par with Rust/C interoperability as far as I can tell (not a Rust expert). See <a rel="nofollow" href="https://learn.adacore.com/courses/intro-to-ada/chapters/interfacing_with_c.html">https://learn.adacore.com/courses/intro-to-ada/chapters/i...</a><br>
<p>
Using Ada&#x27;s formal verification subset (SPARK), one can even prove the correct use of a C API/Library at compile time. Very powerful in terms of software correctness, safety, and security.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907942/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908018"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 16:08 UTC (Wed)
                               by <b>lambda</b> (subscriber, #40735)
                              [<a href="/Articles/908018/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Ada/C interoperability is on par with Rust/C interoperability as far as I can tell (not a Rust expert).</font><br>
<p>
Fair enough! I&#x27;m not an Ada expert either, so I can&#x27;t necessarily speak to how the approaches compare.<br>
<p>
I can say that I&#x27;ve seen a lot more work in the free software world to incrementally port portions of software to Rust, such as the original motivating example of Firefox, librsvg, curl, and this work in the Linux kernel, than I have in Ada. The mindshare in Ada seems to mostly be around safety-critical systems, while Rust seems to appeal to free software developers more as a general purpose programming language, which provides some better guarantees out of the box than C or C++ do, even when not doing a full formal verification process for safety critical systems.<br>
<p>
I&#x27;d love to see examples where Ada has been used successfully to rewrite parts of free software to improve safety or maintainability, let me know if you know of any!<br>
<p>
My comments about Ada were mostly to respond to why Rust over Ada or other static analysis tools, and while I don&#x27;t know Ada well enough to do a detailed comparison, there just seems to be a lot more interest in using Rust for these kinds of use cases than Ada. If anyone has writeups on why Ada would be good for this kind of use case, I&#x27;d love to see them.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908018/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908057"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 22:02 UTC (Wed)
                               by <b>khim</b> (subscriber, #9252)
                              [<a href="/Articles/908057/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <font class="QuotedText">&gt; I can say that I've seen a lot more work in the free software world to incrementally port portions of software to Rust, such as the original motivating example of Firefox, librsvg, curl, and this work in the Linux kernel, than I have in Ada.</font>

<p>The biggest problem of Ada IMO is that it was always supposed to be about safety, but it never addressed the most common source of bugs: pointer safety. Not even with SPARK. It's like discussing about how can you fortify the door in a house with three walls. I <i>suspect</i> they planned to solve it like everyone else (with tracing GC), but that never materialised (because most Ads users don't want tracing GC) thus was always kinda weird “safe” language which doesn't tackle the most common source of bugs.</p>

<p>Finally, in year 2020, it <a href="https://blog.adacore.com/using-pointers-in-spark">solved that problem</a>. By picking ideas from Rust, of course.</p>

<p>But by that time momentum was lost and it would be very hard to overcome that “safe language without safety” stigma.</p>

<p>In addition Ada very much likes to live in the world where it can dictate the rules thus Rust is much more suitable for the kernel IMO.</p>

<font class="QuotedText">&gt; The mindshare in Ada seems to mostly be around safety-critical systems, while Rust seems to appeal to free software developers more as a general purpose programming language, which provides some better guarantees out of the box than C or C++ do, even when not doing a full formal verification process for safety critical systems.</font>

<p>It would be interesting to see how well <a href="https://ferrous-systems.com/blog/ferrocene-update-three-the-road/">Rust would do there</a>. I'm not sure Rust would be able to push Ada from that niche, but it's also highly unlikely that Ada would be able to go into general-purpose computing.</p>

<p>Mindsets of Ada programmers and general-purpose computing programmers are just too different.</p>

<font class="QuotedText">&gt; If anyone has writeups on why Ada would be good for this kind of use case, I'd love to see them.</font>

<p>It wouldn't. Ada provides some additional facilities which Rust doesn't provide (such as range types), but these are not <a href="https://en.wikipedia.org/wiki/Dependent_type">dependent types</a> which are needed to express safety and thus add bloat to the language without improving safety much.</p>

<p>This about it: the most famous example of range types are months and days… and yet, in Ada, you can not define type for day-of-month which is between 1 and 28 for February and 1 and 31 for January!</p>



      
          <div class="CommentReplyButton">
            <form action="/Articles/908057/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor958377"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Jan 16, 2024 13:56 UTC (Tue)
                               by <b>yawaramin</b> (guest, #169121)
                              [<a href="/Articles/958377/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<span class="QuotedText">&gt; and yet, in Ada, you can not define type for day-of-month which is between 1 and 28 for February and 1 and 31 for January!</span><br>
<p>
Yes you can:<br>
<p>
```<br>
procedure Adaproj is<br>
   type Month is (Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec);<br>
   type Month_Day (M : Month) is record<br>
      case M is<br>
         when Sep | Apr | Jun | Nov =&gt;<br>
            Day1_30 : Integer range 1 .. 30;<br>
         when Feb =&gt;<br>
            Day1_29 : Integer range 1 .. 29;<br>
         when Jan | Mar | May | Jul | Aug | Oct | Dec =&gt;<br>
            Day1_31 : Integer range 1 .. 31;<br>
      end case;<br>
   end record;<br>
begin<br>
   null;<br>
end Adaproj;<br>
```<br>
<p>
Sure, it's not exactly trivial; but it's possible.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/958377/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor908183"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 19:10 UTC (Thu)
                               by <b>Cyberax</b> (<b>&#x272D; supporter &#x272D;</b>, #52523)
                              [<a href="/Articles/908183/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Using Ada&#x27;s formal verification subset (SPARK)</font><br>
<p>
SPARK doesn&#x27;t support dynamically allocated objects well: <a href="https://docs.adacore.com/spark2014-docs/html/ug/en/source/language_restrictions.html#memory-ownership-policy">https://docs.adacore.com/spark2014-docs/html/ug/en/source...</a><br>
<p>
It&#x27;s similar to Rust without lifetime annotations and with less static analysis for stack objects.<br>
<p>
There are academic papers that try to fix that, but the outcome would basically look like Rust.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908183/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor907890"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 19:44 UTC (Tue)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/907890/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; Nobody has EVER explained what it provides to the kernel that Ada or better static analysis tools for C could not.</font><br>
<p>
To quote David Gerard: &quot;could&quot; is a word that means &quot;doesn&#x27;t&quot;<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907890/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor907941"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 8:54 UTC (Wed)
                               by <b>em</b> (subscriber, #91304)
                              [<a href="/Articles/907941/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; And generic associated types have been in progress for more than 5 years with no real sign that they&#x27;re going to be stabilised any time soon.</font><br>
<p>
GATs have been stabilized yesterday, fyi: <a href="https://github.com/rust-lang/rust/pull/96709">https://github.com/rust-lang/rust/pull/96709</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907941/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908265"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 11:26 UTC (Fri)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/908265/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; The entire idea is horrible. I do not want a Rust compiler on my computer, I do not want to need a Rust compiler on my computer to be able to compile the kernel.</font><br>
<p>
Simply write a better language with measurably lower defects per hour invested and then people will use it.<br>
<p>
This isn&#x27;t rocket science (according to you), but it *is* science. Not religion. Code talks, bullshit walks, see you when you&#x27;ve done the work.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908265/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908818"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 20, 2022 22:09 UTC (Tue)
                               by <b>amarao</b> (subscriber, #87073)
                              [<a href="/Articles/908818/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wow. Do you use systems, or it&#x27;s in the evil camp too?<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908818/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor907851"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">Glad to see this!</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 13, 2022 13:20 UTC (Tue)
                               by <b>david.a.wheeler</b> (subscriber, #72896)
                              [<a href="/Articles/907851/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m very glad to see this. The only real way to have justified confidence that the Rust APIs will work for kernel modules is to try using those APIs.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907851/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor907900"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 0:46 UTC (Wed)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/907900/">Link</a>] (23 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Wow, the anti-rust trolls are worse than the anti-Gnome or anti-Lennart trolls. One of them above actually writes, apparently without irony, «How does anyone come to the conclusion that Rust is &quot;supposed to&quot; prevent memory leaks, when Box has a whole convenience function specifically for leaking memory?»<br>
<p>
It boggles the mind. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907900/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907910"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 6:11 UTC (Wed)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/907910/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Well, if you wanna be glass half-full(ish), I believe Lennart received death threats. So progress, of a sort. I would say the community has come a long way, if this is the worst of it. Still a bit annoying, but progress is like that. <br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907910/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor907938"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 8:16 UTC (Wed)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/907938/">Link</a>] (19 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
I&#x27;m not sure it&#x27;s a troll. Trolls want to be read but this was too long, unstructured, lacking logic and with more emotional content than technical. I bet most people didn&#x27;t get past the first few lines. So it was not a good troll but bad trolls are usually not like that either: the English style is usually not that good. So I&#x27;m afraid it&#x27;s someone genuinely getting that emotional because of... computer code? Concerning, someone should help.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907938/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907946"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 9:20 UTC (Wed)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/907946/">Link</a>] (18 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Grow up. Criticism of a programming language on technical grounds is not &quot;emotional&quot;. What is emotional is the trolling and dogpiling of the Rust community in response to any kind of criticism.<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907946/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907948"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 9:54 UTC (Wed)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/907948/">Link</a>] (17 responses)
      </p>
      
      </div>
      </summary>
      It was a troll. For example, you wrote
<blockquote>Nobody has even managed to represent the Wayland memory model in Rust, and the kernel is far more complicated than that. The one serious attempt to do so failed after months of work because it required writing thousands upon thousands of lines of memory management boilerplate.
</blockquote>
In fact, the developer of wayland-rs rebutted this <a href="https://www.reddit.com/r/rust/comments/kj0b6d/comment/ggxxj99/?utm_source=share&utm_medium=web2x&context=3">two years ago</a>, and both wayland-rs and smithay (an alternative to wlroots -- not wayland -- in rust) are actively maintained today. Not in wide use (gnome/libweston dominates, kde and wlroots are a distant second/third, not much space for others). But it's there. Perhaps you are thinking of weston-rs. 
<p>Many of your other comments -- such as they are, omitting the "yeah right", "anyone notice that..." etc -- have been amply rebutted by others above. 
<p>As far as the kernel is concerned, if there was a huge issue with Linux's memory model, Linus would have noticed by now, I think. 




      
          <div class="CommentReplyButton">
            <form action="/Articles/907948/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907953"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 10:37 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/907953/">Link</a>] (16 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; &gt; What is emotional is the trolling and dogpiling of the Rust community in response to any kind of criticism.</font><br>
<p>
Isn&#x27;t it interesting that milesrout wrote this?  Because that is exactly what he is doing ...<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907953/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907958"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 11:12 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/907958/">Link</a>] (15 responses)
      </p>
      
      </div>
      </summary>
      How about if we <i>all</i> stop calling each other names here?  Please?


      
          <div class="CommentReplyButton">
            <form action="/Articles/907958/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907988"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 12:36 UTC (Wed)
                               by <b>nirbheek</b> (subscriber, #54111)
                              [<a href="/Articles/907988/">Link</a>] (14 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a spectator in this discussion, I have to say that the antics of people like milesrout make me not want to read the comments section at all. I wish the comments section had a way to collapse all replies underneath a rambling / trolling comment (similar to reddit) so I can skip to things that are actually worth reading.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907988/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907989"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 12:41 UTC (Wed)
                               by <b>mathstuf</b> (subscriber, #69389)
                              [<a href="/Articles/907989/">Link</a>] (11 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
As a subscriber (at least the &quot;professional hacker&quot; level), you have access to a feature to mask out certain users. I believe it hides the whole tree from any of their contributions.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907989/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907992"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 13:03 UTC (Wed)
                               by <b>nirbheek</b> (subscriber, #54111)
                              [<a href="/Articles/907992/">Link</a>] (9 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That&#x27;s useful, thanks! It&#x27;s a bit sad to me that the editors are allowing the comment section to become toxic enough to require adding such a feature. As a former reddit community moderator, it&#x27;s frustrating to me when I see people allow this to happen.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907992/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor907996"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 13:17 UTC (Wed)
                               by <b>Wol</b> (subscriber, #4433)
                              [<a href="/Articles/907996/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
For the most part, it doesn&#x27;t happen here. I suspect the majority of readers are subscribers, which means it&#x27;s only &quot;old&quot; articles that get the attention of trolls.<br>
<p>
The difficulty is when you get articles that by their very nature are contentious, and debate can easily get heated. That, sadly, then attracts trolls like moths to a flame.<br>
<p>
Which then encourages subscribers to subscribe to a level that permits them to apply their own moderation.<br>
<p>
It&#x27;s like democracy - &quot;the worst form of government, apart from all the others we&#x27;ve tried&quot;. Moderation is a bad thing. Just is it better than the alternatives? For the most part, for this site at least, it clearly is not.<br>
<p>
Cheers,<br>
Wol<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/907996/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor907997"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 13:21 UTC (Wed)
                               by <b>corbet</b> (editor, #1)
                              [<a href="/Articles/907997/">Link</a>] (6 responses)
      </p>
      
      </div>
      </summary>
      Out of curiosity, what would you propose that "the editors" do to make things better?  Assuming we had the time and stomach to go deleting/blocking posts, what are the criteria we should use?  Most of the time, asking LWN readers to behave like adults works; I'm not sure what to do in cases where it doesn't.


      
          <div class="CommentReplyButton">
            <form action="/Articles/907997/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908027"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 19:21 UTC (Wed)
                               by <b>atnot</b> (subscriber, #124910)
                              [<a href="/Articles/908027/">Link</a>] (2 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Assuming we had the time and stomach to go deleting/blocking posts, what are the criteria we should use?</font><br>
<p>
My opinion is that a large part of the problem is that those two, very blunt weapons are the only ones available. It means that as long as one nominally follows the rules[1], one is completely free to (deliberately or accidentally) abuse LWNs perverse feedback loops to derail discussions: Write the most incendiary thing you think you can get away with, get it as far up the page as possible by being early, fight with every reply and watch your discussion take up vertical space on the page until nobody has the patience to scroll past it to read anything more substantive anymore. At that point you have won by being the loudest and stop replying to avoid getting chastized by Your Editor.<br>
<p>
With no mechanism to counteract this, it&#x27;s unsurprising it keeps happening. Softer measures like hiding, collapsing or locking a thread, sending it to the bottom of the sort order, showing limited reply depth or rate limiting back and forth replies are probably more effective there than hardline moderation.<br>
<p>
<font class="QuotedText">&gt;  Most of the time, asking LWN readers to behave like adults works; I&#x27;m not sure what to do in cases where it doesn&#x27;t. </font><br>
<p>
I think it&#x27;s remarkable how well this works, all things considered.<br>
<p>
[1] <a href="https://eev.ee/blog/2016/07/22/on-a-technicality/">https://eev.ee/blog/2016/07/22/on-a-technicality/</a><br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908027/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908174"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 18:03 UTC (Thu)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/908174/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt;  Softer measures like hiding, collapsing or locking a thread, sending it to the bottom of the sort order, showing limited reply depth or rate limiting back and forth replies are probably more effective there than hardline moderation.</font><br>
<p>
This.<br>
<p>
Surprise, surprise, &quot;analog&quot; problems rarely ever have binary solutions (unless of course you read social media).<br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908174/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908236"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 3:32 UTC (Fri)
                               by <b>milesrout</b> (subscriber, #126894)
                              [<a href="/Articles/908236/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; With no mechanism to counteract this, it&#x27;s unsurprising it keeps happening. Softer measures like hiding, collapsing or locking a thread, sending it to the bottom of the sort order, showing limited reply depth or rate limiting back and forth replies are probably more effective there than hardline moderation.</font><br>
<p>
And what would be the grounds for doing this? Is this JUST for criticism of Rust? Or does it include a broader category of messages than that?<br>
<p>
In my opinion there is no issue. The discussion isn&#x27;t even heated. I made a SINGLE comment and was immediately accused of trolling. It seems to me that ANY criticism of Rust immediately gets labelled as trolling. Yet lots of topics covered here are contentious and prompt back-and-forth discussions that often are not particularly productive. Only criticism of Rust seems to get immediately labelled as trolling, as far as I can see. <br>
<p>
<p>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908236/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908079"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 7:05 UTC (Thu)
                               by <b>ssmith32</b> (subscriber, #72404)
                              [<a href="/Articles/908079/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Just throwing ideas out: if you ask someone to be an adult more than X times in window Y + random episilon, put them in a cooling off queue - not necessarily a ban, just slow the rate of posts, to a stop, and then ramp back up (assuming no more adult warnings)<br>
<p>
It could be automated - other than ticking an &quot;adult warning&quot; on your post. The randomness is to prevent gaming - keeps you wondering if this time is the one.<br>
<p>
I know, a bit naive, just thinking what would help me when I get too troll-y. Particularly in my younger years - I&#x27;d like to think I&#x27;m older and wiser then when I joined. Because I&#x27;m definitely older ;)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908079/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
<a name="CommAnchor908111"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 13:24 UTC (Thu)
                               by <b>farnz</b> (subscriber, #17727)
                              [<a href="/Articles/908111/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <p>Two concrete proposals:
<ol>
<li>Have the editors able to "flag" a post and all its children as problematic, which results in the thread content being hidden by default, and require readers to click through to read each flagged post in turn. This is a weaker form of deletion.
<li>Support delayed posting, with the minimum required delay set by the editors for replies to any post or its children, and also something that can be set on an individual account - the delay applicable at any point in the thread is the maximum delay of all of its parent posts. This means that when I hit "Post comment", instead of it actually posting, it enters a "quarantine" state, and I have to come back to the thread to release the comment from quarantine at a later time. This is a weaker form of blocking.
</ol>
<p>The idea behind the first option is to reduce the visibility of overheated threads, allowing you to indicate that you think that a given thread is non-productive (and discouraging people from either reading it or replying to it). The idea behind the second is to let you use time to cool off a thread that's become heated, or to increase the effort trolls and abusers have to put into actually being seen.
<p>Finally, when I killfile a user, I should have the option to not only killfile that user, but also all immediate replies to them; that way, if I killfile a user who's good at trolling, I don't see the replies that they successfully troll for (but I do see the replies to replies, which may be interesting tangents from the troll).


      
          <div class="CommentReplyButton">
            <form action="/Articles/908111/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908240"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 5:04 UTC (Fri)
                               by <b>edomaur</b> (subscriber, #14520)
                              [<a href="/Articles/908240/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Also, an idea would be to add a &quot;cooling down&quot; timer to subtrees selection of discussions, with a visual marker to signal that there is delayed posting enforced in that part of the comments. This can be also linked with a moderator message (typically one &quot;please refrain...&quot; from our favorite editor in chief)<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908240/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
<a name="CommAnchor908267"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 16, 2022 12:01 UTC (Fri)
                               by <b>flussence</b> (guest, #85566)
                              [<a href="/Articles/908267/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
The system here isn&#x27;t perfect, or modern, and people often criticise it when there&#x27;s an angry mob thread like this, but to date I haven&#x27;t yet witnessed an angry mob directed *at* the moderation. That&#x27;s a better success rate than nearly every web forum I&#x27;ve used in the past 20-odd years.<br>
<p>
Incidentally a major subreddit became Main Character Of The Day on other social media this week for grotesque moderator overreach. I would say the reddit/voat/8chan/urbit model of expendable community and digital royalty built atop it has produced some of the worst results. That website has trench lines by the hundred and the tools are designed to only escalate.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908267/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908009"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">LWN user ignore list pros &amp; cons</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 14:54 UTC (Wed)
                               by <b>mbunkus</b> (subscriber, #87248)
                              [<a href="/Articles/908009/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Yeah, this helps, and milesrout is one of the people I have on my ignore list. However, this doesn&#x27;t prevent the &quot;unread comments&quot; functionality from showing child posts to one of the ignored people. That way one is often sucked back in to such threads as reading such a reply makes me often wonder what they&#x27;re referring to — as I simply don&#x27;t remember anything they could refer to (due to it being hidden by default).<br>
<p>
Not sure what the best solution is here; maybe collapse those as well by default? Even if the top-most shown comment isn&#x27;t by an ignored user? Or at least marking it in an obvious way?<br>
<p>
Anyway, I&#x27;m very grateful to have that ignore list. For that &amp; the excellent content in general I continue to be a happy subscriber.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908009/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
<a name="CommAnchor908545"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2022 0:50 UTC (Mon)
                               by <b>ras</b> (subscriber, #33059)
                              [<a href="/Articles/908545/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
<font class="QuotedText">&gt; As a spectator in this discussion, I have to say that the antics of people like milesrout make me not want to read the comments section at all.</font><br>
<p>
As a counter point, I&#x27;ve enjoyed the discussion milesrout has created.  Some of the replies have been excellent - the best I&#x27;ve seen on this subject anywhere on the web.  They&#x27;re from people who clearly know the subject very well and also write clearly.<br>
<p>
I think that&#x27;s because they are passionate about the subject.  They wear that passion on their sleeves, which I suspect is what you are objecting to - it&#x27;s not a dry &quot;authoritative&quot; academic treatment of the subject.  Yes, that passion could easily drag the discussion into the weeds, but without the passion they would not of invested the time and effort needed to craft such replies.<br>
<p>
It&#x27;s difficult to argue passionately about something, while maintaining the disciplined needed to address the just subject and not the people delivering it.  Yet, that is mostly what has been achieved here, in what is effectively an open forum.  I put it down to corbet&#x27;s gentle steering.  As other&#x27;s have said, he limited tools available.  His most effective one seems to be leading by example.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908545/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908555"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 19, 2022 3:24 UTC (Mon)
                               by <b>marcH</b> (subscriber, #57642)
                              [<a href="/Articles/908555/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
LWN is probably the only site in the entire world where you can find people with expertise, writing skills, patience and willingness to politely answer impolite trolls by sharing knowledge badge-like articles - for free. It happens only on LWN but even on LWN it does not happen every time and a tiny bit of semi-automated moderation may not hurt. My 2c.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908555/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</details>
</details>
</details>
</details>
</details>
<a name="CommAnchor908067"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 14, 2022 22:28 UTC (Wed)
                               by <b>NYKevin</b> (subscriber, #129325)
                              [<a href="/Articles/908067/">Link</a>] (1 responses)
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
That was not anti-Rust, it was anti-anti-Rust. It was in reply to someone who (wrongly) claimed that Rust&#x27;s safety model was broken because it fails to prevent memory leaks. I was pointing out that Rust never claimed to do this in the first place, and that it makes no sense to assert otherwise. You may disagree with my reasoning, but please do not mischaracterize my position.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908067/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    <a name="CommAnchor908073"></a>
    <details class="CommentBox" open>
      <summary><h3 class="CommentTitle">A pair of Rust kernel modules</h3>
      <div class="AnnLine">
      <p class="CommentPoster"> Posted Sep 15, 2022 0:50 UTC (Thu)
                               by <b>rsidd</b> (subscriber, #2582)
                              [<a href="/Articles/908073/">Link</a>] 
      </p>
      
      </div>
      </summary>
      <div class="FormattedComment">
Sorry for misunderstanding.<br>
</div>

      
          <div class="CommentReplyButton">
            <form action="/Articles/908073/comment" method="post">
            <input type="submit" value="Reply to this comment">
            </form>
          </div>
        
     <p>
     
    </details>
</details>
</details>
</div> <!-- middlecolumn -->
<div class="rightcol not-print">
<div id="azk93271_right_zone"></div>
</div>
</div> <!-- maincolumn -->

            <br clear="all">
            <center>
            <P>
            <span class="ReallySmall">
            Copyright &copy; 2022, Eklektix, Inc.<BR>
            This article may be redistributed under the terms of the
              <a href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
              Commons CC BY-SA 4.0</a> license<br>
            Comments and public postings are copyrighted by their creators.<br>
            Linux  is a registered trademark of Linus Torvalds<br>
            </span>
            </center>
            
            </body></html>
