# A proposed API for full-memory encryption [LWN.net]

> **This article brought to you by LWN subscribers**
> 
> Subscribers to LWN.net made this article — and everything that surrounds it — possible. If you appreciate our content, please [buy a subscription](/Promo/nst-nag3/subscribe) and make the next set of articles possible. 

January 18, 2019

This article was contributed by Marta Rybczyńska

Hardware memory encryption is, or will soon be, available on multiple generic CPUs. In its absence, data is stored — and passes between the memory chips and the processor — in the clear. Attackers may be able to access it by using hardware probes or by directly accessing the chips, which is especially problematic with persistent memory. One new memory-encryption offering is Intel's [Multi-Key Total Memory Encryption (MKTME) [PDF]](https://software.intel.com/sites/default/files/managed/a5/16/Multi-Key-Total-Memory-Encryption-Spec.pdf); AMD's equivalent is called [Secure Encrypted Virtualization (SEV)](https://developer.amd.com/sev/). The implementation of support for this feature is in progress for the Linux kernel. Recently, Alison Schofield [proposed a user-space API](/Articles/773972/) for MKTME, provoking a long discussion on how memory encryption should be exposed to the user, if at all.

Filesystem encryption options offer a wide choice of possibilities; their use is now standard practice in a number of settings, protecting user data when it is at rest. On the other hand, data stored in main memory is kept in the clear, as are exchanges between memory chips and the processors. In a virtualized environment, if attackers can find a way to read memory from neighbor virtual machines, they can access the data from those machines. Physical attacks are possible by removing memory chips or spying on the memory buses. This is becoming a more serious threat with persistent-memory technologies, where the data stays in the clear even after power is removed. Memory-encryption technologies are aiming to address some of those attacks.

Memory encryption has been available in Intel chips for some time in the form of [Total Memory Encryption (TME)](https://en.wikichip.org/wiki/x86/tme). It uses a single, CPU-generated key for all of memory; users can control the usage of TME in the boot-level firmware. A new standard, which will be available in upcoming chips, is MKTME, an extension of TME that supports different encryption settings (including disabling encryption) at the page level, and more keys. Different keys can be used at the same time for different memory regions. The main use case for MKTME seems to be adding more protection in systems with multiple virtual machines (see [these slides from LinuxCon China [PDF]](https://schd.ws/hosted_files/lc32018/38/mktme_lc3_2018.pdf)). The encryption algorithm supported is AES-XTS 128 with the physical address being taken into account as a type of nonce.

Lower-level support for MKTME in the Linux kernel was [submitted](/Articles/764480/) in September 2018\. Memory encryption was also one of the subjects [discussed](/Articles/752683/) at the 2018 Linux Storage, Filesystem, and Memory-Management Summit. The recent [patch set](/ml/linux-security-module/cover.1543903910.git.alison.schofield@intel.com/) from Schofield goes further, adding the user interface to set up the encryption and (optionally) keys, assign key identifiers to memory regions; the patch set also adds a key store to support CPU hotplug.

#### encrypt_mprotect()

Setting up MKTME requires a few steps: create a key, map a region of anonymous memory, and enable the encryption. The key is created and added to the kernel keyring using the `add_key()` helper function from the [`keyutils` library](http://man7.org/linux/man-pages/man7/keyutils.7.html). It requires the key type and key material (if the key is not to be generated by the CPU) and additional, specific options. Then the user should map a region of anonymous memory with `mmap()`, then use a new system call to enable protection.

That new system call is `encrypt_mprotect()`. It takes the same parameters as `mprotect()` with addition of a key serial number. The prototype is:
    
    
        int encrypt_mprotect(unsigned long start, size_t len,
                             unsigned long prot, key_serial_t serial);
    

An [example](/ml/linux-security-module/c2276bbbb19f3a28bd37c3dd6b1021e2d9a10916.1543903910.git.alison.schofield@intel.com/) showing the use of the new system call was submitted with the patch set.

#### API alternatives, key changes and cache state

Andy Lutomirski [expressed a number of objections](/ml/linux-security-module/CALCETrUqqQiHR_LJoKB2JE6hCZ-e7LiFprEhmo-qoegDZJ9uYQ@mail.gmail.com/) to the API in its proposed form. The first point was about the new system call, which he described as ""an incomplete version of `mprotect()`"" due to its lack of support for [memory protection keys](/Articles/689395/). Its only function is to change the encryption key while, he said, the most secure usage is to stick with the CPU-generated key. 

He also had doubts about the safety of swapping encrypted memory. The kernel's direct-mapping area, which maps all of physical memory directly into the kernel's address space, can also be the source of cache-coherency issues. Problems could arise because the user's mapping and the kernel's direct mapping will have different keys for the same memory, so data corruption may occur. He doubted that MKTME should be used with anonymous memory (memory not backed up by a file or a device). As a solution, he proposed a different approach: instead of a generic API, there should be specific interfaces for persistent memory and virtual-machine hardening.

Dave Hansen [responded](/ml/linux-security-module/c610138f-32dd-a24c-dc52-4e0006a21409@intel.com/), explaining the logic behind the API proposal. The goal of adding the new system call was to allow it to stack with the generic `mprotect()` and [`pkey_mprotect()`](http://man7.org/linux/man-pages/man2/pkey_mprotect.2.html), rather than replacing those other calls. The cache-coherency issues are expected to be avoided by careful reference counting in the VMAs before issuing the `PCONFIG` instruction that changes the key. He also promised to find out why the user-provided keys had been included.

Dan Williams [pointed out](/ml/linux-security-module/CAPcyv4gg5ymssw75q9k8NwwPrstDUrqmCEeU_VNU=rKEM7izGg@mail.gmail.com/) that the persistent-memory code only needs to access the encrypted version of the data, so it never uses the direct mapping and can safely move blocks without considering the keys.

Further in the discussion Hansen [noted](/ml/linux-security-module/7ac80308-1831-fe42-9c53-05f913cba403@intel.com/) that the persistent-memory use case, which requires a user-supplied key, is reasonable, but it is not covered by the current patch set; he proposed to postpone it until that part is done. Other developers, like Jarkko Sakkinen also [asked questions](/ml/linux-security-module/10b900d7461d81433120e614287d6f837cea83ef.camel@intel.com/), including about what happens if a key changes suddenly. The answer is that it might result in data corruption if the right cache flushes are missing. The discussion ended for now without a clear conclusion on either the API or the main use case for this feature.

#### User keys and CPU hotplug

The MKTME code tries not to save any key material longer than needed, so the kernel destroys user-supplied key data once the hardware has been programmed. That leads to a potential problem, though: the kernel will need those keys if a new CPU comes online. This problem was solved by setting up an optional storage for key data in kernel memory. When the `mktme_savekeys` kernel command line option is enabled, the code uses this store. Otherwise, new CPUs are not allowed if any user-supplied keys are in use.

The saving of encryption keys caused questions; Kai Huang [asked if CPU-hotplug support is that important](/ml/linux-security-module/1544148839.28511.28.camel@intel.com/) as storing the keys can make them susceptible to [cold boot attacks](https://en.wikipedia.org/wiki/Cold_boot_attack). He noted that there are configurations where the kernel does not support CPU hotplug, and suggested that a per-socket key ID may be a solution. Kirill Shutemov [didn't like the idea](/ml/linux-security-module/20181207114709.kmrbghihyrht2l65@kshutemo-mobl1/), as it would add complexity in the MKTME code that would need to keep track of nodes. It would also complicate memory management, especially in the case of memory migration. The solution has not been yet found; the next version of the patch will have to try to resolve the issue.

#### The security model for virtual-machine isolation

There have been multiple discussions around the security model of MKTME and how the feature is expected to be used, especially in comparison with TME. The developers concentrated on various exploits and malicious code that might try to override the protection.

Lutomirski noted that MKTME [does not protect](/ml/linux-security-module/CALCETrXsh6wAy9kE_m1L+0yW8a6bNOb6g2Tf9nwpQJnyMzdSuw@mail.gmail.com/) against malicious accesses between virtual machines, as the memory controller does not know where any given access comes from. Sakkinen agreed; he [does not see](/ml/linux-security-module/a19a48ae1d6434a1764b02c2376a99130ce15174.camel@intel.com/) TME making virtual-machine isolation any better. Hansen [responded](/ml/linux-security-module/986544e1-ffd1-1cd2-f0d3-4b1a4e8e8f3b@intel.com/) that MKTME does not provide protection when the attacking code can execute code inside the hypervisor. Also, when the kernel keeps non-encrypted mappings of memory that also has encrypted mappings, the attacker may be able to read the memory via the non-encrypted mappings. To avoid those problems, Lutomirski is proposing to reuse the [exclusive page-frame ownership](/Articles/700647/) mechanism so that the direct mapping page is removed when memory is allocated for user space.

The [discussion on the security model](/ml/linux-security-module/655394650664715c39ef242689fbc8af726f09c3.camel@intel.com/) covered both virtual machines and CPUs. Interested readers may also refer to a [a research paper [PDF]](https://arxiv.org/pdf/1805.09604.pdf) on SEV subversion.

#### Conclusions

The addition of MKTME support provoked a number of different opinions on how to support the feature. A consensus has not been reached yet and the final implementation may turn out to be different than what has been proposed so far. The discussion shows how difficult it is sometimes to create a good API. The main work the developers have to do now is to understand the use cases better and agree on an interface that will cover those needs. We are likely going to see more iterations of this patch and more discussion in the near future.

  
Index entries for this article  
---  
[Kernel](/Kernel/Index)| [Memory management/Memory encryption](/Kernel/Index#Memory_management-Memory_encryption)  
[GuestArticles](/Archives/GuestIndex/)| [Rybczynska, Marta](/Archives/GuestIndex/#Rybczynska_Marta)  
  


* * *

to post comments 
