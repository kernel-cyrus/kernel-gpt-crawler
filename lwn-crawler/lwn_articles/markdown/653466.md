# Atomic mode setting design overview, part 2 [LWN.net]

August 12, 2015

This article was contributed by Daniel Vetter

Today's graphical applications require frame-perfect displays, while also taking advantage of specialized, power-saving hardware in embedded GPUs. To do that, the kernel must be able to update the hardware graphics state atomically — changing multiple independent parameters in a single operation so that users don't see corrupted frames while the change is taking place. The [first article](/Articles/653071/) of this series looked at why an atomic display update API has become necessary, how it came to be, and what the main driver interfaces look like. Here, we will look into a few more details and build on the material discussed earlier.

> **`$ sudo subscribe today`**
> 
> Subscribe today and elevate your LWN privileges. You’ll have access to all of LWN’s high-quality articles as soon as they’re published, and help support LWN in the process. [Act now](https://lwn.net/Promo/nst-sudo/claim) and you can start with a free trial subscription. 

Still, a short recap of the main interface can't hurt: an atomic display update is created by duplicating the state structures for display objects like planes or a CRTC and then updating the duplicates, which are collected in `struct drm_atomic_state`. Once all updates are applied, the new state is provided in its entirety to the driver's `->atomic_check()` function for validation. If it passes, then it can be committed using `->atomic_commit()`. Just validating updates to figure out in a generic way what's possible is also supported using a check-only mode. 

#### Of atomic updates and nuclear options

A big change in upstream atomic mode setting compared to the Android Display Framework (ADF) is that upstream allows any display state to be changed through the atomic `ioctl()`. ADF only allows plane states to be changed atomically; output routing and display-mode changes (which are called mode-set changes in this article) need separate calls from user space in ADF. At least on a cursory look, plane updates and mode-set changes are indeed two different things. On one hand, atomic plane updates are meant to be completed by the next frame displayed. Atomic mode-set updates, on the other hand, can cause a display to go to black for a bit, which is anything but perfect. Mode-set updates generally take hundreds of milliseconds. But both update the display state in an atomic, all-or-nothing fashion and they can both use the same "list of property changes" transport for the `ioctl()`. So, purely by just looking at the structures and data passed between user space and the kernel — and not the requested semantics — it makes a lot of sense to treat them as the same operation. 

The tension between these two types of updates resulted in a lot of confusion when discussing atomic plans for upstream. It was only fixed by calling full mode sets "atomic mode sets" and calling the plane updates "nuclear page flips". But when you look closer, the distinction between full mode sets and pure plane updates synchronized to the next frame becomes unclear quickly. Often a display mode change on integrated panels only means that the scaler used to fit the displayed area onto the panel needs to be adjusted. A lot of hardware can do that with a small update for the next frame, without the need for a full mode set and blanking the screen. But then there's hardware where some plane configuration changes require reallocation of FIFO space, and that is only possible when the display pipeline is shut down. Which looks very much like a mode set.

Furthermore, user space would often like to delay changes that require full mode sets to a more suitable time. For example, tablets and smartphones suspend so often that pretty much any mode set can be delayed without incurring too much energy waste by running in a suboptimal configuration until the next suspend. There, plane changes that need a full mode set shouldn't be done without the consent of user space to avoid a less-than-perfect visual experience for users.

After many bits were expended discussing this problem, the solution merged was the `DRM_MODE_ATOMIC_ALLOW_MODESET` flag. With this, user space can indicate whether a full mode set (with the downsides of potentially blanking seemingly unrelated screens and taking a long time) is acceptable or not. And, of course, this flag is also obeyed for the test-only mode. Most drivers don't need to bother with this, since the atomic helpers take care of checking for it — as long as the driver correctly indicates to the helper code that it needs or doesn't need a full mode set in one of the special cases mentioned above. 

#### Locking magic using wait/wound mutexes

Next up is how concurrent updates are handled. A while ago, [DRM gained per-CRTC locks](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=29494c174dc4793ebd236aa522a2a1ed73b7180e) to allow concurrent updates and changes on different display pipelines. That, in turn, required [per-plane locks](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=4d02e2de0e80a786452e70d7f3a20a50641e6620) since planes can (if the hardware supports it) change the CRTC they're connected to. In addition, there's one more lock to protect all the output routing and connector state — making those kinds of changes usually requires at least a few hundred milliseconds, thus will result in stalls no matter what. It's also a rare and usually system-wide operation, so finer-grained locking for that would just be wasted.

But one problem with the atomic `ioctl()` is that user space could pass its list of updates (in the form of `object_id`, `property_id`, `value` triples) in any order it wants. That could easily lead to deadlocks if they are processed in that order, since different objects require different locks. User space could provoke an AB-BA deadlock by creating two updates that list the same two objects but in a different order. 

That can be solved by sorting the entire list of triples by objects first, but unfortunately that only delays the problem. The first article explained that atomic state-checking code is only allowed to look at or touch the state of objects that are in the update. This guarantees that concurrent updates won't trample each another. Unfortunately, that also means that drivers must be able to add arbitrary objects and their states to the overall atomic update tracked in the `drm_atomic_state` structure in their `->atomic_check()` callback. That will allow the callback to check cross-object limits and make sure that shared resources are not exhausted. Because hardware is crazy, this can't be done outside of the driver code since every piece of hardware has its own unique shared state. Just grabbing all potentially needed locks up front isn't a great idea either, since that will only make all updates synchronous and hence make all the fine-grained locking pointless.

This means a locking scheme where locks can be taken in an arbitrary order is needed. Luckily, the kernel has that with its [wait/wound mutex](/Articles/548909/) support, which, incidentally, was also added by GPU driver hackers for some pesky memory-management troubles. Wait/wound mutexes are a topic of their own, really, but the summary is that they allow you to grab locks in arbitrary order, can reliably detect deadlocks, and have a means to back off from a deadlock without throwing fairness out the window or requiring costly spinning. They're also rather complex.

No one wants to inflict advanced locking schemes on driver writers unnecessarily, so the locking is all nicely encapsulated in functions provided by the atomic core. When you need to change which CRTC a plane is assigned to, just call `drm_atomic_set_crtc_for_plane()` and make sure any errors are forwarded correctly up the call chain. Similarly, if a driver needs to consult other state objects in its state-validation code (e.g. to check limits on shared resources), it can duplicate any state into the atomic update it needs and locks will be acquired correctly behind the scenes. The only important bit is to correctly forward the `-EDEADLK` error code and always use the provided functions to duplicate and update state structures. With that, magic simply happens. Well, as long as a driver's atomic check code is otherwise correct and doesn't touch hardware state nor anything else that might persist outside of just the state structures.

For users of the DRM-internal atomic interface things are a notch more complex, but not a lot. Wait/wound locking state is tracked in a `struct drm_modeset_acquire_ctx`, which is initialized using `drm_modeset_acquire_init()`. To make all the transparent lock-taking work when duplicating state objects into an atomic update, this is also stored in `drm_atomic_state->ctx`. As with drivers, any locks needed will be implicitly acquired when duplicating state objects; the only thing needed is to actually handle deadlocks signaled with the `-EDEADLK` error code. 

Since the deadlock backoff logic will drop locks, already duplicated state objects might become stale and need to be released first with `drm_atomic_state_clear()`. Then a call to `drm_modeset_backoff()` will drop any acquired mode-set locks and block on the contended lock until it's available. After that, the entire sequence needs to be restarted right after the initialization of the acquire context — that must not be reinitialized since it contains the queue ticket that ensures forward progress in the wait/wound locking algorithm. Finally, when everything has succeeded, locks can be dropped with `drm_modeset_drop_locks()` and the acquire context is finalized with `drm_modeset_acquire_fini()`.

Note that it's really easy to test all that special backoff code: enabling lock debugging and `CONFIG_DEBUG_WW_MUTEX_SLOWPATH` will cause the wait/wound mutex code to inject spurious deadlock conditions. With that, all the deadlock backoff code can be exhaustively tested just with single-threaded test cases. And of course wait/wound mutexes fully support all the Linux lock debugging and testing tools such as lockdep. 

#### Helper-library design

The other piece that took years to settle is the driver helper-library design. A [mid-layer approach](/Articles/336262/), as in ADF, was out of question because hardware has too many special cases to be able to create such a framework that is not too complex. There was already an extensive set of helpers used by most drivers anyway, so preferably drivers shouldn't have to rewrite all their callbacks and support code when converting to atomic updates. Directly reusing the existing callbacks was done for proof-of-concept conversions, but fundamentally there were a few troubles with the existing helpers and their driver callbacks:

  * They had no real support for checking cross-object constraints. Properly checking those is a major goal of the atomic changes. Checking for such arbitrary cross-device constraints is exposed to user space with the `DRM_MODE_ATOMIC_TEST_ONLY` flag, which is described in the first article.
  * There was no support for doing atomic updates of planes. For sane hardware that has lockout bits to prevent any updates until they have all been written to registers, this is easy to fix with just pre- and post-commit hooks. But in general, hardware needs more flexibility there. There were also no provisions for separating the checks from the commit phase of plane updates.
  * Any output routing changes required updating and enabling the primary plane too. Often that's not what you want, for example displaying a video overlay with black background for the letterbox or pillarbox bars doesn't need any primary plane at all. The hardware can do this, so it should be made possible. 
  * Finally, the legacy helpers were designed for the very first XRandR implementation. In the almost ten years that have passed since, DRM developers learned an awful lot of lessons about what works, what should be simplified (by providing stricter guarantees in helpers), and where more flexibility was needed to make the helpers more useful.



All in all, a full rewrite of the helper code was in order, while still making conversions fairly easy. The big change, certainly, is that the helper library doesn't just expose one monolithic template function for each hook, but also exposes separate pieces, for example to handle plane-only updates or only output configuration changes. Aside from a few restrictions imposed by the atomic semantics they can also be called in arbitrary order, as it best suits the hardware. This way drivers can mix and match between helper code and their own — or just augment helper code as needed (for checking or changing global state for example). 

A good example would be drivers supporting runtime power management (PM). The old legacy helpers updated planes in between disabling outputs and enabling them with the new configuration. For best backward compatibility, that's also what the atomic helpers do, but this is not the best for drivers supporting runtime PM. Such drivers will disable the hardware when the display pipelines are off and, hence, plane updates will get lost if they are done in the middle. It's better to do plane updates as the final step of committing the update to hardware, and the helpers allow this.

Another useful feature of the new helper library is that any derived state to steer control flow is stored in the state structures — it has to be, due to the check/commit split. That allows drivers to overwrite and control the helpers in fine detail. For example, a driver can force a full mode set (and the required state precomputation) when some shared global resources need to be adjusted, even when the helper wouldn't see a need for a full mode set on its own. Since the exported check functions are idempotent, they can be re-run when a later step uncovers the need (again due to shared resources) to include more objects in the atomic update. 

That is useful when a plane update uncovers the need for a full mode set. But a full mode set, in turn, might require recomputations for plane states, creating a loop. Making the exported helpers idempotent and callable in any order helps to break such loops. To avoid surprises, the default check function, `drm_atomic_helper_check()`, only calls the subordinate helpers to check plane updates and mode-set changes once each. But hardware with complicated dependencies between these two types of updates (like the example earlier where a plane update can require a full mode set, maybe even on an unrelated CRTC) can be handled by calling the helpers multiple times, until a steady state has been reached for the precomputed state. Note that this is only to facilitate the state validation, the actual commit of the atomic update to the hardware should still happen in one go, without any iterating. 

Also, all the functions to implement legacy callbacks in terms of the atomic driver interfaces are exported and can be called explicitly. Drivers without a need to specially handle legacy entry points can just put the provided helpers directly into the DRM driver operation function tables. This allows drivers to keep some features only supported for legacy interfaces by keeping the code for old platforms around. This is useful for drivers which support ten or more years of hardware iterations where it doesn't make sense to implement proper atomic support for every old special case.

The other big change is simpler semantics for drivers. Thanks to the atomic updates, the new helpers can keep track of state changes much better and guarantee that a disable or enable hook won't be called redundantly — which the old helpers routinely did. They also hide a lot of the potential flexibility of legacy interfaces like the four different [display power management signaling](https://en.wikipedia.org/wiki/VESA_Display_Power_Management_Signaling) (DPMS) levels used for runtime PM on outputs — the atomic helpers only have on and off. This is because modern hardware simply doesn't support intermediate DPMS levels any more. On anything but the oldest of hardware, drivers just clamped the intermediate levels to off. This also allows the atomic helpers to reuse the same enable and disable hooks for runtime PM as for the normal enabling and disabling of outputs, which simplifies drivers. The `->dpms()` callbacks are still supported to simplify converting drivers from legacy mode setting to atomic, but they are deprecated. Converted drivers should only have to implement the `->enable()` and `->disable()` hooks and should be able to delete the DPMS handlers entirely. 

Finally, there are transitional helpers to handle the impedance mismatch for planes between legacy helpers and the new atomic ones. They provide helpers like `drm_helper_crtc_mode_set_base()` that implement the legacy helper callbacks in terms of the new atomic helper callbacks. This allows driver writers to switch over to the new hooks for plane updates in their backend while otherwise still using the same code and overall control-flow. That helps a lot in converting big drivers by allowing the conversion to happen in multiple phases that only deal with a part of the driver. There's also a "[how to](http://blog.ffwll.ch/2014/11/atomic-modeset-support-for-kms-drivers.html)" that has all of the details for an atomic conversion — what all needs to be done and in which exact order.

Overall, there are a number of drivers already converted and the new helpers seem to be working out well. Some small changes in the interfaces of callbacks were needed, but thus far there have been no big problems with the semantics themselves. A big reason for that is that the new code has been modeled after the `i915.ko`-specific mode-set infrastructure, which has been developed over the past few years with an aim toward atomic updates. 

The big lesson learned from `i915.ko` led to the major difference in the merged code: how an atomic update is assembled before actually committing it to the hardware. In `i915.ko` all updates were staged using a set of `new_foo` members embedded into each mode-setting object structure, mirroring all the existing data structures and pointers. The major downside of that approach is that rolling back an update (either because it violates a constraint or because user space only asked to check constraints using `TEST_ONLY`) needed to carefully undo all these changes. Staging updates in the objects themselves also makes it much harder to have multiple updates in-flight at the same time. With the merged atomic infrastructure, updates are assembled out of free-standing state objects and no permanent mode-setting object structures are touched before actually committing state to the hardware. That makes rollback and handling concurrent updates much easier. 

The unresolved gap in the current helpers is handling non-blocking updates. Thus far, drivers need to manage their own work queues for the asynchronous tail of an atomic update and synchronize appropriately when an update depends upon global state, like they had to already for primary plane page flips with the old legacy `ioctl()`. There are ideas floating around to implement this in the atomic helpers. But nothing has come up that is both simple enough to be an improvement over the current state while still being useful for a lot of drivers.

#### Conclusions

After more than three years in the making, upstream has finally a mode-setting interface and support infrastructure for drivers that covers all of the use cases, from energy-sipping systems-on-chip (SoCs) with the need for all the special plane hardware and supporting perfect updates of each frame to big desktops supporting multiple screens. That's a first, since the original kernel mode setting pretty much left embedded systems to fbdev. But given the number of ongoing or already-merged conversions to atomic and entirely new drivers supporting it, it looks like upstream graphics for SoCs is finally happening and is bound to stay. Well, at least for the mode-setting side of GPUs. But even just that would be a big change and a great improvement for all the upstreaming efforts of Android-vendor kernel trees.

Let's all embrace the age of atomic mode setting — that future is here and it is looking good ...  
Index entries for this article  
---  
[Kernel](/Kernel/Index)| [Device drivers/Graphics](/Kernel/Index#Device_drivers-Graphics)  
[GuestArticles](/Archives/GuestIndex/)| [Vetter, Daniel](/Archives/GuestIndex/#Vetter_Daniel)  
  


* * *

to post comments 
